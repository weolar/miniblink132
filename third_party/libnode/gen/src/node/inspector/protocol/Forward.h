// This file is generated by Forward_h.template.

// Copyright 2016 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef node_inspector_protocol_Forward_h
#define node_inspector_protocol_Forward_h

#include <memory>
#include <vector>

#include "crdtp/error_support.h"
#include "crdtp/dispatch.h"
#include "crdtp/frontend_channel.h"
#include "crdtp/protocol_core.h"

#include "inspector/node_string.h"

namespace node {
namespace inspector {
namespace protocol {

using DispatchResponse = crdtp::DispatchResponse;
using ErrorSupport = crdtp::ErrorSupport;
using Serializable = crdtp::Serializable;
using FrontendChannel = crdtp::FrontendChannel;
using DomainDispatcher = crdtp::DomainDispatcher;
using UberDispatcher = crdtp::UberDispatcher;
using Response = DispatchResponse;

class DictionaryValue;
class FundamentalValue;
class ListValue;
class Object;
class SerializedValue;
class StringValue;
class Value;

using crdtp::detail::PtrMaybe;
using crdtp::detail::ValueMaybe;

template <typename T> using Maybe = crdtp::Maybe<T>;

namespace detail {

template <typename T> struct ArrayTypedef {
    typedef std::vector<std::unique_ptr<T>> type;
};

template <> struct ArrayTypedef<String> {
    typedef std::vector<String> type;
};

template <> struct ArrayTypedef<int> {
    typedef std::vector<int> type;
};

template <> struct ArrayTypedef<double> {
    typedef std::vector<double> type;
};

template <> struct ArrayTypedef<bool> {
    typedef std::vector<bool> type;
};

template <> struct ArrayTypedef<Binary> {
    typedef std::vector<Binary> type;
};

} // namespace detail

template <typename T> using Array = typename detail::ArrayTypedef<T>::type;

} // namespace node
} // namespace inspector
} // namespace protocol

#endif // !defined(node_inspector_protocol_Forward_h)
