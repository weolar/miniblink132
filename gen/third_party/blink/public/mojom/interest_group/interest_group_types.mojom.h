// third_party/blink/public/mojom/interest_group/interest_group_types.mojom.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef THIRD_PARTY_BLINK_PUBLIC_MOJOM_INTEREST_GROUP_INTEREST_GROUP_TYPES_MOJOM_H_
#define THIRD_PARTY_BLINK_PUBLIC_MOJOM_INTEREST_GROUP_INTEREST_GROUP_TYPES_MOJOM_H_

#include <stdint.h>

#include <limits>
#include <optional>
#include <type_traits>
#include <utility>

#include "base/types/cxx23_to_underlying.h"
#include "mojo/public/cpp/bindings/clone_traits.h"
#include "mojo/public/cpp/bindings/equals_traits.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/struct_ptr.h"
#include "mojo/public/cpp/bindings/struct_traits.h"
#include "mojo/public/cpp/bindings/union_traits.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "third_party/blink/public/mojom/interest_group/interest_group_types.mojom-features.h" // IWYU pragma: export
#include "third_party/blink/public/mojom/interest_group/interest_group_types.mojom-shared.h" // IWYU pragma: export
#include "third_party/blink/public/mojom/interest_group/interest_group_types.mojom-forward.h" // IWYU pragma: export
#include "mojo/public/mojom/base/int128.mojom.h"
#include "mojo/public/mojom/base/time.mojom.h"
#include "mojo/public/mojom/base/unguessable_token.mojom.h"
#include "mojo/public/mojom/base/uuid.mojom.h"
#include "third_party/blink/public/mojom/interest_group/ad_display_size.mojom.h"
#include "url/mojom/origin.mojom.h"
#include "url/mojom/url.mojom.h"
#include <string>
#include <vector>

#include "third_party/blink/public/common/interest_group/auction_config_mojom_traits.h"
#include "third_party/blink/public/common/interest_group/interest_group_mojom_traits.h"
#include "third_party/blink/public/common/common_export.h"

namespace blink::mojom {

class BLINK_COMMON_EXPORT SellerCapabilities {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<SellerCapabilities, T>::value>;
    using DataView = SellerCapabilitiesDataView;
    using Data_ = internal::SellerCapabilities_Data;

    template <typename... Args> static SellerCapabilitiesPtr New(Args&&... args)
    {
        return SellerCapabilitiesPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static SellerCapabilitiesPtr From(const U& u)
    {
        return mojo::TypeConverter<SellerCapabilitiesPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, SellerCapabilities>::Convert(*this);
    }

    SellerCapabilities()
    : allows_interest_group_counts(false)
    , allows_latency_stats(false)
{
}

    SellerCapabilities(bool allows_interest_group_counts_in, bool allows_latency_stats_in)
    : allows_interest_group_counts(std::move(allows_interest_group_counts_in))
    , allows_latency_stats(std::move(allows_latency_stats_in)){
}

    ~SellerCapabilities() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = SellerCapabilitiesPtr> SellerCapabilitiesPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, SellerCapabilities::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, SellerCapabilities::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, SellerCapabilities::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static std::vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<SellerCapabilities::DataView, std::vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<SellerCapabilities::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::SellerCapabilities_UnserializedMessageContext<UserType, SellerCapabilities::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<SellerCapabilities::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return SellerCapabilities::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::SellerCapabilities_UnserializedMessageContext<UserType, SellerCapabilities::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<SellerCapabilities::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    bool allows_interest_group_counts;

    bool allows_latency_stats;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, SellerCapabilities::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, SellerCapabilities::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, SellerCapabilities::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, SellerCapabilities::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class BLINK_COMMON_EXPORT AuctionServerRequestFlags {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<AuctionServerRequestFlags, T>::value>;
    using DataView = AuctionServerRequestFlagsDataView;
    using Data_ = internal::AuctionServerRequestFlags_Data;

    template <typename... Args> static AuctionServerRequestFlagsPtr New(Args&&... args)
    {
        return AuctionServerRequestFlagsPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static AuctionServerRequestFlagsPtr From(const U& u)
    {
        return mojo::TypeConverter<AuctionServerRequestFlagsPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, AuctionServerRequestFlags>::Convert(*this);
    }

    AuctionServerRequestFlags()
    : omit_ads(false)
    , include_full_ads(false)
    , omit_user_bidding_signals(false)
{
}

    AuctionServerRequestFlags(bool omit_ads_in, bool include_full_ads_in, bool omit_user_bidding_signals_in)
    : omit_ads(std::move(omit_ads_in))
    , include_full_ads(std::move(include_full_ads_in))
    , omit_user_bidding_signals(std::move(omit_user_bidding_signals_in)){
}

    ~AuctionServerRequestFlags() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = AuctionServerRequestFlagsPtr> AuctionServerRequestFlagsPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, AuctionServerRequestFlags::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, AuctionServerRequestFlags::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, AuctionServerRequestFlags::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static std::vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<AuctionServerRequestFlags::DataView, std::vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<AuctionServerRequestFlags::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(std::make_unique<internal::AuctionServerRequestFlags_UnserializedMessageContext<UserType, AuctionServerRequestFlags::DataView>>(
                                 0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<AuctionServerRequestFlags::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return AuctionServerRequestFlags::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context
            = input.TakeUnserializedContext<internal::AuctionServerRequestFlags_UnserializedMessageContext<UserType, AuctionServerRequestFlags::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<AuctionServerRequestFlags::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    bool omit_ads;

    bool include_full_ads;

    bool omit_user_bidding_signals;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, AuctionServerRequestFlags::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, AuctionServerRequestFlags::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, AuctionServerRequestFlags::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, AuctionServerRequestFlags::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class BLINK_COMMON_EXPORT AdKeywordReplacement {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<AdKeywordReplacement, T>::value>;
    using DataView = AdKeywordReplacementDataView;
    using Data_ = internal::AdKeywordReplacement_Data;

    template <typename... Args> static AdKeywordReplacementPtr New(Args&&... args)
    {
        return AdKeywordReplacementPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static AdKeywordReplacementPtr From(const U& u)
    {
        return mojo::TypeConverter<AdKeywordReplacementPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, AdKeywordReplacement>::Convert(*this);
    }

    AdKeywordReplacement()
    : match()
    , replacement()
{
}

    AdKeywordReplacement(const std::string& match_in, const std::string& replacement_in)
    : match(std::move(match_in))
    , replacement(std::move(replacement_in)){
}

    ~AdKeywordReplacement() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = AdKeywordReplacementPtr> AdKeywordReplacementPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, AdKeywordReplacement::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, AdKeywordReplacement::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, AdKeywordReplacement::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static std::vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<AdKeywordReplacement::DataView, std::vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<AdKeywordReplacement::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::AdKeywordReplacement_UnserializedMessageContext<UserType, AdKeywordReplacement::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<AdKeywordReplacement::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return AdKeywordReplacement::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::AdKeywordReplacement_UnserializedMessageContext<UserType, AdKeywordReplacement::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<AdKeywordReplacement::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    std::string match;

    std::string replacement;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, AdKeywordReplacement::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, AdKeywordReplacement::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, AdKeywordReplacement::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, AdKeywordReplacement::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class BLINK_COMMON_EXPORT AdCurrency {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<AdCurrency, T>::value>;
    using DataView = AdCurrencyDataView;
    using Data_ = internal::AdCurrency_Data;

    template <typename... Args> static AdCurrencyPtr New(Args&&... args)
    {
        return AdCurrencyPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static AdCurrencyPtr From(const U& u)
    {
        return mojo::TypeConverter<AdCurrencyPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, AdCurrency>::Convert(*this);
    }

    AdCurrency()
    : currency_code()
{
}

    explicit AdCurrency(const std::string& currency_code_in)
    : currency_code(std::move(currency_code_in)){
}

    ~AdCurrency() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = AdCurrencyPtr> AdCurrencyPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, AdCurrency::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, AdCurrency::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, AdCurrency::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static std::vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<AdCurrency::DataView, std::vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<AdCurrency::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(std::make_unique<internal::AdCurrency_UnserializedMessageContext<UserType, AdCurrency::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<AdCurrency::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return AdCurrency::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::AdCurrency_UnserializedMessageContext<UserType, AdCurrency::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<AdCurrency::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    std::string currency_code;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, AdCurrency::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, AdCurrency::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, AdCurrency::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, AdCurrency::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class BLINK_COMMON_EXPORT AuctionReportBuyerDebugModeConfig {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<AuctionReportBuyerDebugModeConfig, T>::value>;
    using DataView = AuctionReportBuyerDebugModeConfigDataView;
    using Data_ = internal::AuctionReportBuyerDebugModeConfig_Data;

    template <typename... Args> static AuctionReportBuyerDebugModeConfigPtr New(Args&&... args)
    {
        return AuctionReportBuyerDebugModeConfigPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static AuctionReportBuyerDebugModeConfigPtr From(const U& u)
    {
        return mojo::TypeConverter<AuctionReportBuyerDebugModeConfigPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, AuctionReportBuyerDebugModeConfig>::Convert(*this);
    }

    AuctionReportBuyerDebugModeConfig()
    : is_enabled(false)
    , debug_key()
{
}

    AuctionReportBuyerDebugModeConfig(bool is_enabled_in, std::optional<uint64_t> debug_key_in)
    : is_enabled(std::move(is_enabled_in))
    , debug_key(std::move(debug_key_in)){
}

    ~AuctionReportBuyerDebugModeConfig() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = AuctionReportBuyerDebugModeConfigPtr> AuctionReportBuyerDebugModeConfigPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, AuctionReportBuyerDebugModeConfig::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, AuctionReportBuyerDebugModeConfig::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, AuctionReportBuyerDebugModeConfig::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static std::vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<AuctionReportBuyerDebugModeConfig::DataView, std::vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<AuctionReportBuyerDebugModeConfig::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::AuctionReportBuyerDebugModeConfig_UnserializedMessageContext<UserType, AuctionReportBuyerDebugModeConfig::DataView>>(
                0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<AuctionReportBuyerDebugModeConfig::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return AuctionReportBuyerDebugModeConfig::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<
            internal::AuctionReportBuyerDebugModeConfig_UnserializedMessageContext<UserType, AuctionReportBuyerDebugModeConfig::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<AuctionReportBuyerDebugModeConfig::DataView>(
            input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    bool is_enabled;

    std::optional<uint64_t> debug_key;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, AuctionReportBuyerDebugModeConfig::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, AuctionReportBuyerDebugModeConfig::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, AuctionReportBuyerDebugModeConfig::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, AuctionReportBuyerDebugModeConfig::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class BLINK_COMMON_EXPORT AuctionDataBuyerConfig {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<AuctionDataBuyerConfig, T>::value>;
    using DataView = AuctionDataBuyerConfigDataView;
    using Data_ = internal::AuctionDataBuyerConfig_Data;

    template <typename... Args> static AuctionDataBuyerConfigPtr New(Args&&... args)
    {
        return AuctionDataBuyerConfigPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static AuctionDataBuyerConfigPtr From(const U& u)
    {
        return mojo::TypeConverter<AuctionDataBuyerConfigPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, AuctionDataBuyerConfig>::Convert(*this);
    }

    AuctionDataBuyerConfig()
    : target_size()
{
}

    explicit AuctionDataBuyerConfig(std::optional<uint32_t> target_size_in)
    : target_size(std::move(target_size_in)){
}

    ~AuctionDataBuyerConfig() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = AuctionDataBuyerConfigPtr> AuctionDataBuyerConfigPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, AuctionDataBuyerConfig::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, AuctionDataBuyerConfig::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, AuctionDataBuyerConfig::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static std::vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<AuctionDataBuyerConfig::DataView, std::vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<AuctionDataBuyerConfig::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::AuctionDataBuyerConfig_UnserializedMessageContext<UserType, AuctionDataBuyerConfig::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<AuctionDataBuyerConfig::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return AuctionDataBuyerConfig::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::AuctionDataBuyerConfig_UnserializedMessageContext<UserType, AuctionDataBuyerConfig::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<AuctionDataBuyerConfig::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    std::optional<uint32_t> target_size;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, AuctionDataBuyerConfig::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, AuctionDataBuyerConfig::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, AuctionDataBuyerConfig::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, AuctionDataBuyerConfig::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class BLINK_COMMON_EXPORT AuctionAdConfigMaybePromiseJson {
public:
    using DataView = AuctionAdConfigMaybePromiseJsonDataView;
    using Data_ = internal::AuctionAdConfigMaybePromiseJson_Data;
    using Tag = Data_::AuctionAdConfigMaybePromiseJson_Tag;

    template <typename... Args> static AuctionAdConfigMaybePromiseJsonPtr New(Args&&... args)
    {
        static_assert(sizeof...(args) < 0,
            "Do not use Union::New(); to create a union of a given subtype, use "
            "New<SubType>(), not New() followed by set_<sub_type>(). To represent "
            "an empty union, mark the field or parameter as nullable in the mojom "
            "definition.");
        return nullptr;
    }
    // Construct an instance holding |promise|.
    static AuctionAdConfigMaybePromiseJsonPtr NewPromise(uint32_t value)
    {
        auto result = AuctionAdConfigMaybePromiseJsonPtr(std::in_place);
        result->set_promise(std::move(value));
        return result;
    }
    // Construct an instance holding |value|.
    static AuctionAdConfigMaybePromiseJsonPtr NewValue(const std::optional<std::string>& value)
    {
        auto result = AuctionAdConfigMaybePromiseJsonPtr(std::in_place);
        result->set_value(std::move(value));
        return result;
    }

    template <typename U> static AuctionAdConfigMaybePromiseJsonPtr From(const U& u)
    {
        return mojo::TypeConverter<AuctionAdConfigMaybePromiseJsonPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, AuctionAdConfigMaybePromiseJson>::Convert(*this);
    }

    AuctionAdConfigMaybePromiseJson()
    : tag_(Tag::kPromise)
{
    data_.promise = uint32_t();
}
    ~AuctionAdConfigMaybePromiseJson(){
    DestroyActive();
}
    // Delete the copy constructor and copy assignment operators because `data_`
    // contains raw pointers that must not be copied.
    AuctionAdConfigMaybePromiseJson(const AuctionAdConfigMaybePromiseJson& other) = delete;
    AuctionAdConfigMaybePromiseJson& operator=(const AuctionAdConfigMaybePromiseJson& other) = delete;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename UnionPtrType = AuctionAdConfigMaybePromiseJsonPtr> AuctionAdConfigMaybePromiseJsonPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, typename std::enable_if<std::is_same<T, AuctionAdConfigMaybePromiseJson>::value>::type* = nullptr> bool Equals(const T& other) const;

    template <typename T, typename std::enable_if<std::is_same<T, AuctionAdConfigMaybePromiseJson>::value>::type* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    Tag which() const
    {
        return tag_;
    }

    bool is_promise() const
    {
        return tag_ == Tag::kPromise;
    }

    uint32_t get_promise() const
    {
        CHECK(tag_ == Tag::kPromise);
        return data_.promise;
    }

    void set_promise(uint32_t promise);

    bool is_value() const
    {
        return tag_ == Tag::kValue;
    }

    std::optional<std::string>& get_value() const
    {
        CHECK(tag_ == Tag::kValue);
        return *(data_.value);
    }

    void set_value(const std::optional<std::string>& value);

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<AuctionAdConfigMaybePromiseJson::DataView>(input);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        return mojo::internal::DeserializeImpl<AuctionAdConfigMaybePromiseJson::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

private:
    union Union_ {
        Union_() = default;
        ~Union_() = default;
        uint32_t promise;
        std::optional<std::string>* value;
    };

    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    void DestroyActive();
    Tag tag_;
    Union_ data_;
};

class BLINK_COMMON_EXPORT AuctionAdConfigMaybePromisePerBuyerSignals {
public:
    using DataView = AuctionAdConfigMaybePromisePerBuyerSignalsDataView;
    using Data_ = internal::AuctionAdConfigMaybePromisePerBuyerSignals_Data;
    using Tag = Data_::AuctionAdConfigMaybePromisePerBuyerSignals_Tag;

    template <typename... Args> static AuctionAdConfigMaybePromisePerBuyerSignalsPtr New(Args&&... args)
    {
        static_assert(sizeof...(args) < 0,
            "Do not use Union::New(); to create a union of a given subtype, use "
            "New<SubType>(), not New() followed by set_<sub_type>(). To represent "
            "an empty union, mark the field or parameter as nullable in the mojom "
            "definition.");
        return nullptr;
    }
    // Construct an instance holding |promise|.
    static AuctionAdConfigMaybePromisePerBuyerSignalsPtr NewPromise(uint32_t value)
    {
        auto result = AuctionAdConfigMaybePromisePerBuyerSignalsPtr(std::in_place);
        result->set_promise(std::move(value));
        return result;
    }
    // Construct an instance holding |value|.
    static AuctionAdConfigMaybePromisePerBuyerSignalsPtr NewValue(const std::optional<base::flat_map<::url::Origin, std::string>>& value)
    {
        auto result = AuctionAdConfigMaybePromisePerBuyerSignalsPtr(std::in_place);
        result->set_value(std::move(value));
        return result;
    }

    template <typename U> static AuctionAdConfigMaybePromisePerBuyerSignalsPtr From(const U& u)
    {
        return mojo::TypeConverter<AuctionAdConfigMaybePromisePerBuyerSignalsPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, AuctionAdConfigMaybePromisePerBuyerSignals>::Convert(*this);
    }

    AuctionAdConfigMaybePromisePerBuyerSignals()
    : tag_(Tag::kPromise)
{
    data_.promise = uint32_t();
}
    ~AuctionAdConfigMaybePromisePerBuyerSignals(){
    DestroyActive();
}
    // Delete the copy constructor and copy assignment operators because `data_`
    // contains raw pointers that must not be copied.
    AuctionAdConfigMaybePromisePerBuyerSignals(const AuctionAdConfigMaybePromisePerBuyerSignals& other) = delete;
    AuctionAdConfigMaybePromisePerBuyerSignals& operator=(const AuctionAdConfigMaybePromisePerBuyerSignals& other) = delete;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename UnionPtrType = AuctionAdConfigMaybePromisePerBuyerSignalsPtr> AuctionAdConfigMaybePromisePerBuyerSignalsPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, typename std::enable_if<std::is_same<T, AuctionAdConfigMaybePromisePerBuyerSignals>::value>::type* = nullptr>
    bool Equals(const T& other) const;

    template <typename T, typename std::enable_if<std::is_same<T, AuctionAdConfigMaybePromisePerBuyerSignals>::value>::type* = nullptr>
    bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    Tag which() const
    {
        return tag_;
    }

    bool is_promise() const
    {
        return tag_ == Tag::kPromise;
    }

    uint32_t get_promise() const
    {
        CHECK(tag_ == Tag::kPromise);
        return data_.promise;
    }

    void set_promise(uint32_t promise);

    bool is_value() const
    {
        return tag_ == Tag::kValue;
    }

    std::optional<base::flat_map<::url::Origin, std::string>>& get_value() const
    {
        CHECK(tag_ == Tag::kValue);
        return *(data_.value);
    }

    void set_value(const std::optional<base::flat_map<::url::Origin, std::string>>& value);

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<AuctionAdConfigMaybePromisePerBuyerSignals::DataView>(input);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        return mojo::internal::DeserializeImpl<AuctionAdConfigMaybePromisePerBuyerSignals::DataView>(
            input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

private:
    union Union_ {
        Union_() = default;
        ~Union_() = default;
        uint32_t promise;
        std::optional<base::flat_map<::url::Origin, std::string>>* value;
    };

    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    void DestroyActive();
    Tag tag_;
    Union_ data_;
};

class BLINK_COMMON_EXPORT AuctionAdConfigMaybePromiseBuyerTimeouts {
public:
    using DataView = AuctionAdConfigMaybePromiseBuyerTimeoutsDataView;
    using Data_ = internal::AuctionAdConfigMaybePromiseBuyerTimeouts_Data;
    using Tag = Data_::AuctionAdConfigMaybePromiseBuyerTimeouts_Tag;

    template <typename... Args> static AuctionAdConfigMaybePromiseBuyerTimeoutsPtr New(Args&&... args)
    {
        static_assert(sizeof...(args) < 0,
            "Do not use Union::New(); to create a union of a given subtype, use "
            "New<SubType>(), not New() followed by set_<sub_type>(). To represent "
            "an empty union, mark the field or parameter as nullable in the mojom "
            "definition.");
        return nullptr;
    }
    // Construct an instance holding |promise|.
    static AuctionAdConfigMaybePromiseBuyerTimeoutsPtr NewPromise(uint32_t value)
    {
        auto result = AuctionAdConfigMaybePromiseBuyerTimeoutsPtr(std::in_place);
        result->set_promise(std::move(value));
        return result;
    }
    // Construct an instance holding |value|.
    static AuctionAdConfigMaybePromiseBuyerTimeoutsPtr NewValue(const ::blink::AuctionConfig::BuyerTimeouts& value)
    {
        auto result = AuctionAdConfigMaybePromiseBuyerTimeoutsPtr(std::in_place);
        result->set_value(std::move(value));
        return result;
    }

    template <typename U> static AuctionAdConfigMaybePromiseBuyerTimeoutsPtr From(const U& u)
    {
        return mojo::TypeConverter<AuctionAdConfigMaybePromiseBuyerTimeoutsPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, AuctionAdConfigMaybePromiseBuyerTimeouts>::Convert(*this);
    }

    AuctionAdConfigMaybePromiseBuyerTimeouts()
    : tag_(Tag::kPromise)
{
    data_.promise = uint32_t();
}
    ~AuctionAdConfigMaybePromiseBuyerTimeouts(){
    DestroyActive();
}
    // Delete the copy constructor and copy assignment operators because `data_`
    // contains raw pointers that must not be copied.
    AuctionAdConfigMaybePromiseBuyerTimeouts(const AuctionAdConfigMaybePromiseBuyerTimeouts& other) = delete;
    AuctionAdConfigMaybePromiseBuyerTimeouts& operator=(const AuctionAdConfigMaybePromiseBuyerTimeouts& other) = delete;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename UnionPtrType = AuctionAdConfigMaybePromiseBuyerTimeoutsPtr> AuctionAdConfigMaybePromiseBuyerTimeoutsPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, typename std::enable_if<std::is_same<T, AuctionAdConfigMaybePromiseBuyerTimeouts>::value>::type* = nullptr>
    bool Equals(const T& other) const;

    template <typename T, typename std::enable_if<std::is_same<T, AuctionAdConfigMaybePromiseBuyerTimeouts>::value>::type* = nullptr>
    bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    Tag which() const
    {
        return tag_;
    }

    bool is_promise() const
    {
        return tag_ == Tag::kPromise;
    }

    uint32_t get_promise() const
    {
        CHECK(tag_ == Tag::kPromise);
        return data_.promise;
    }

    void set_promise(uint32_t promise);

    bool is_value() const
    {
        return tag_ == Tag::kValue;
    }

    ::blink::AuctionConfig::BuyerTimeouts& get_value() const
    {
        CHECK(tag_ == Tag::kValue);
        return *(data_.value);
    }

    void set_value(const ::blink::AuctionConfig::BuyerTimeouts& value);

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<AuctionAdConfigMaybePromiseBuyerTimeouts::DataView>(input);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        return mojo::internal::DeserializeImpl<AuctionAdConfigMaybePromiseBuyerTimeouts::DataView>(
            input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

private:
    union Union_ {
        Union_() = default;
        ~Union_() = default;
        uint32_t promise;
        ::blink::AuctionConfig::BuyerTimeouts* value;
    };

    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    void DestroyActive();
    Tag tag_;
    Union_ data_;
};

class BLINK_COMMON_EXPORT AuctionAdConfigMaybePromiseBuyerCurrencies {
public:
    using DataView = AuctionAdConfigMaybePromiseBuyerCurrenciesDataView;
    using Data_ = internal::AuctionAdConfigMaybePromiseBuyerCurrencies_Data;
    using Tag = Data_::AuctionAdConfigMaybePromiseBuyerCurrencies_Tag;

    template <typename... Args> static AuctionAdConfigMaybePromiseBuyerCurrenciesPtr New(Args&&... args)
    {
        static_assert(sizeof...(args) < 0,
            "Do not use Union::New(); to create a union of a given subtype, use "
            "New<SubType>(), not New() followed by set_<sub_type>(). To represent "
            "an empty union, mark the field or parameter as nullable in the mojom "
            "definition.");
        return nullptr;
    }
    // Construct an instance holding |promise|.
    static AuctionAdConfigMaybePromiseBuyerCurrenciesPtr NewPromise(uint32_t value)
    {
        auto result = AuctionAdConfigMaybePromiseBuyerCurrenciesPtr(std::in_place);
        result->set_promise(std::move(value));
        return result;
    }
    // Construct an instance holding |value|.
    static AuctionAdConfigMaybePromiseBuyerCurrenciesPtr NewValue(const ::blink::AuctionConfig::BuyerCurrencies& value)
    {
        auto result = AuctionAdConfigMaybePromiseBuyerCurrenciesPtr(std::in_place);
        result->set_value(std::move(value));
        return result;
    }

    template <typename U> static AuctionAdConfigMaybePromiseBuyerCurrenciesPtr From(const U& u)
    {
        return mojo::TypeConverter<AuctionAdConfigMaybePromiseBuyerCurrenciesPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, AuctionAdConfigMaybePromiseBuyerCurrencies>::Convert(*this);
    }

    AuctionAdConfigMaybePromiseBuyerCurrencies()
    : tag_(Tag::kPromise)
{
    data_.promise = uint32_t();
}
    ~AuctionAdConfigMaybePromiseBuyerCurrencies(){
    DestroyActive();
}
    // Delete the copy constructor and copy assignment operators because `data_`
    // contains raw pointers that must not be copied.
    AuctionAdConfigMaybePromiseBuyerCurrencies(const AuctionAdConfigMaybePromiseBuyerCurrencies& other) = delete;
    AuctionAdConfigMaybePromiseBuyerCurrencies& operator=(const AuctionAdConfigMaybePromiseBuyerCurrencies& other) = delete;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename UnionPtrType = AuctionAdConfigMaybePromiseBuyerCurrenciesPtr> AuctionAdConfigMaybePromiseBuyerCurrenciesPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, typename std::enable_if<std::is_same<T, AuctionAdConfigMaybePromiseBuyerCurrencies>::value>::type* = nullptr>
    bool Equals(const T& other) const;

    template <typename T, typename std::enable_if<std::is_same<T, AuctionAdConfigMaybePromiseBuyerCurrencies>::value>::type* = nullptr>
    bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    Tag which() const
    {
        return tag_;
    }

    bool is_promise() const
    {
        return tag_ == Tag::kPromise;
    }

    uint32_t get_promise() const
    {
        CHECK(tag_ == Tag::kPromise);
        return data_.promise;
    }

    void set_promise(uint32_t promise);

    bool is_value() const
    {
        return tag_ == Tag::kValue;
    }

    ::blink::AuctionConfig::BuyerCurrencies& get_value() const
    {
        CHECK(tag_ == Tag::kValue);
        return *(data_.value);
    }

    void set_value(const ::blink::AuctionConfig::BuyerCurrencies& value);

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<AuctionAdConfigMaybePromiseBuyerCurrencies::DataView>(input);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        return mojo::internal::DeserializeImpl<AuctionAdConfigMaybePromiseBuyerCurrencies::DataView>(
            input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

private:
    union Union_ {
        Union_() = default;
        ~Union_() = default;
        uint32_t promise;
        ::blink::AuctionConfig::BuyerCurrencies* value;
    };

    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    void DestroyActive();
    Tag tag_;
    Union_ data_;
};

class BLINK_COMMON_EXPORT AuctionAdConfigMaybePromiseDirectFromSellerSignals {
public:
    using DataView = AuctionAdConfigMaybePromiseDirectFromSellerSignalsDataView;
    using Data_ = internal::AuctionAdConfigMaybePromiseDirectFromSellerSignals_Data;
    using Tag = Data_::AuctionAdConfigMaybePromiseDirectFromSellerSignals_Tag;

    template <typename... Args> static AuctionAdConfigMaybePromiseDirectFromSellerSignalsPtr New(Args&&... args)
    {
        static_assert(sizeof...(args) < 0,
            "Do not use Union::New(); to create a union of a given subtype, use "
            "New<SubType>(), not New() followed by set_<sub_type>(). To represent "
            "an empty union, mark the field or parameter as nullable in the mojom "
            "definition.");
        return nullptr;
    }
    // Construct an instance holding |promise|.
    static AuctionAdConfigMaybePromiseDirectFromSellerSignalsPtr NewPromise(uint32_t value)
    {
        auto result = AuctionAdConfigMaybePromiseDirectFromSellerSignalsPtr(std::in_place);
        result->set_promise(std::move(value));
        return result;
    }
    // Construct an instance holding |value|.
    static AuctionAdConfigMaybePromiseDirectFromSellerSignalsPtr NewValue(const std::optional<::blink::DirectFromSellerSignals>& value)
    {
        auto result = AuctionAdConfigMaybePromiseDirectFromSellerSignalsPtr(std::in_place);
        result->set_value(std::move(value));
        return result;
    }

    template <typename U> static AuctionAdConfigMaybePromiseDirectFromSellerSignalsPtr From(const U& u)
    {
        return mojo::TypeConverter<AuctionAdConfigMaybePromiseDirectFromSellerSignalsPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, AuctionAdConfigMaybePromiseDirectFromSellerSignals>::Convert(*this);
    }

    AuctionAdConfigMaybePromiseDirectFromSellerSignals()
    : tag_(Tag::kPromise)
{
    data_.promise = uint32_t();
}
    ~AuctionAdConfigMaybePromiseDirectFromSellerSignals(){
    DestroyActive();
}
    // Delete the copy constructor and copy assignment operators because `data_`
    // contains raw pointers that must not be copied.
    AuctionAdConfigMaybePromiseDirectFromSellerSignals(const AuctionAdConfigMaybePromiseDirectFromSellerSignals& other) = delete;
    AuctionAdConfigMaybePromiseDirectFromSellerSignals& operator=(const AuctionAdConfigMaybePromiseDirectFromSellerSignals& other) = delete;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename UnionPtrType = AuctionAdConfigMaybePromiseDirectFromSellerSignalsPtr>
    AuctionAdConfigMaybePromiseDirectFromSellerSignalsPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, typename std::enable_if<std::is_same<T, AuctionAdConfigMaybePromiseDirectFromSellerSignals>::value>::type* = nullptr>
    bool Equals(const T& other) const;

    template <typename T, typename std::enable_if<std::is_same<T, AuctionAdConfigMaybePromiseDirectFromSellerSignals>::value>::type* = nullptr>
    bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    Tag which() const
    {
        return tag_;
    }

    bool is_promise() const
    {
        return tag_ == Tag::kPromise;
    }

    uint32_t get_promise() const
    {
        CHECK(tag_ == Tag::kPromise);
        return data_.promise;
    }

    void set_promise(uint32_t promise);

    bool is_value() const
    {
        return tag_ == Tag::kValue;
    }

    std::optional<::blink::DirectFromSellerSignals>& get_value() const
    {
        CHECK(tag_ == Tag::kValue);
        return *(data_.value);
    }

    void set_value(const std::optional<::blink::DirectFromSellerSignals>& value);

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<AuctionAdConfigMaybePromiseDirectFromSellerSignals::DataView>(input);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        return mojo::internal::DeserializeImpl<AuctionAdConfigMaybePromiseDirectFromSellerSignals::DataView>(
            input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

private:
    union Union_ {
        Union_() = default;
        ~Union_() = default;
        uint32_t promise;
        std::optional<::blink::DirectFromSellerSignals>* value;
    };

    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    void DestroyActive();
    Tag tag_;
    Union_ data_;
};

class BLINK_COMMON_EXPORT AuctionAdConfigMaybePromiseDeprecatedRenderURLReplacements {
public:
    using DataView = AuctionAdConfigMaybePromiseDeprecatedRenderURLReplacementsDataView;
    using Data_ = internal::AuctionAdConfigMaybePromiseDeprecatedRenderURLReplacements_Data;
    using Tag = Data_::AuctionAdConfigMaybePromiseDeprecatedRenderURLReplacements_Tag;

    template <typename... Args> static AuctionAdConfigMaybePromiseDeprecatedRenderURLReplacementsPtr New(Args&&... args)
    {
        static_assert(sizeof...(args) < 0,
            "Do not use Union::New(); to create a union of a given subtype, use "
            "New<SubType>(), not New() followed by set_<sub_type>(). To represent "
            "an empty union, mark the field or parameter as nullable in the mojom "
            "definition.");
        return nullptr;
    }
    // Construct an instance holding |promise|.
    static AuctionAdConfigMaybePromiseDeprecatedRenderURLReplacementsPtr NewPromise(uint32_t value)
    {
        auto result = AuctionAdConfigMaybePromiseDeprecatedRenderURLReplacementsPtr(std::in_place);
        result->set_promise(std::move(value));
        return result;
    }
    // Construct an instance holding |value|.
    static AuctionAdConfigMaybePromiseDeprecatedRenderURLReplacementsPtr NewValue(std::vector<::blink::AuctionConfig::AdKeywordReplacement> value)
    {
        auto result = AuctionAdConfigMaybePromiseDeprecatedRenderURLReplacementsPtr(std::in_place);
        result->set_value(std::move(value));
        return result;
    }

    template <typename U> static AuctionAdConfigMaybePromiseDeprecatedRenderURLReplacementsPtr From(const U& u)
    {
        return mojo::TypeConverter<AuctionAdConfigMaybePromiseDeprecatedRenderURLReplacementsPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, AuctionAdConfigMaybePromiseDeprecatedRenderURLReplacements>::Convert(*this);
    }

    AuctionAdConfigMaybePromiseDeprecatedRenderURLReplacements()
    : tag_(Tag::kPromise)
{
    data_.promise = uint32_t();
}
    ~AuctionAdConfigMaybePromiseDeprecatedRenderURLReplacements(){
    DestroyActive();
}
    // Delete the copy constructor and copy assignment operators because `data_`
    // contains raw pointers that must not be copied.
    AuctionAdConfigMaybePromiseDeprecatedRenderURLReplacements(const AuctionAdConfigMaybePromiseDeprecatedRenderURLReplacements& other) = delete;
    AuctionAdConfigMaybePromiseDeprecatedRenderURLReplacements& operator=(const AuctionAdConfigMaybePromiseDeprecatedRenderURLReplacements& other) = delete;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename UnionPtrType = AuctionAdConfigMaybePromiseDeprecatedRenderURLReplacementsPtr>
    AuctionAdConfigMaybePromiseDeprecatedRenderURLReplacementsPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, typename std::enable_if<std::is_same<T, AuctionAdConfigMaybePromiseDeprecatedRenderURLReplacements>::value>::type* = nullptr>
    bool Equals(const T& other) const;

    template <typename T, typename std::enable_if<std::is_same<T, AuctionAdConfigMaybePromiseDeprecatedRenderURLReplacements>::value>::type* = nullptr>
    bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    Tag which() const
    {
        return tag_;
    }

    bool is_promise() const
    {
        return tag_ == Tag::kPromise;
    }

    uint32_t get_promise() const
    {
        CHECK(tag_ == Tag::kPromise);
        return data_.promise;
    }

    void set_promise(uint32_t promise);

    bool is_value() const
    {
        return tag_ == Tag::kValue;
    }

    std::vector<::blink::AuctionConfig::AdKeywordReplacement>& get_value() const
    {
        CHECK(tag_ == Tag::kValue);
        return *(data_.value);
    }

    void set_value(std::vector<::blink::AuctionConfig::AdKeywordReplacement> value);

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<AuctionAdConfigMaybePromiseDeprecatedRenderURLReplacements::DataView>(input);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        return mojo::internal::DeserializeImpl<AuctionAdConfigMaybePromiseDeprecatedRenderURLReplacements::DataView>(
            input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

private:
    union Union_ {
        Union_() = default;
        ~Union_() = default;
        uint32_t promise;
        std::vector<::blink::AuctionConfig::AdKeywordReplacement>* value;
    };

    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    void DestroyActive();
    Tag tag_;
    Union_ data_;
};

class BLINK_COMMON_EXPORT InterestGroupAd {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<InterestGroupAd, T>::value>;
    using DataView = InterestGroupAdDataView;
    using Data_ = internal::InterestGroupAd_Data;

    template <typename... Args> static InterestGroupAdPtr New(Args&&... args)
    {
        return InterestGroupAdPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static InterestGroupAdPtr From(const U& u)
    {
        return mojo::TypeConverter<InterestGroupAdPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, InterestGroupAd>::Convert(*this);
    }

    InterestGroupAd()
    : render_url()
    , size_group()
    , buyer_reporting_id()
    , buyer_and_seller_reporting_id()
    , selectable_buyer_and_seller_reporting_ids()
    , metadata()
    , ad_render_id()
    , allowed_reporting_origins()
{
}

    InterestGroupAd(const std::string& render_url_in, const std::optional<std::string>& size_group_in,
    const std::optional<std::string>& buyer_reporting_id_in, const std::optional<std::string>& buyer_and_seller_reporting_id_in,
    std::optional<std::vector<std::string>> selectable_buyer_and_seller_reporting_ids_in, const std::optional<std::string>& metadata_in,
    const std::optional<std::string>& ad_render_id_in, std::optional<std::vector<::url::Origin>> allowed_reporting_origins_in)
    : render_url(std::move(render_url_in))
    , size_group(std::move(size_group_in))
    , buyer_reporting_id(std::move(buyer_reporting_id_in))
    , buyer_and_seller_reporting_id(std::move(buyer_and_seller_reporting_id_in))
    , selectable_buyer_and_seller_reporting_ids(std::move(selectable_buyer_and_seller_reporting_ids_in))
    , metadata(std::move(metadata_in))
    , ad_render_id(std::move(ad_render_id_in))
    , allowed_reporting_origins(std::move(allowed_reporting_origins_in)){
}

    ~InterestGroupAd() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = InterestGroupAdPtr> InterestGroupAdPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, InterestGroupAd::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, InterestGroupAd::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, InterestGroupAd::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static std::vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<InterestGroupAd::DataView, std::vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<InterestGroupAd::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::InterestGroupAd_UnserializedMessageContext<UserType, InterestGroupAd::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<InterestGroupAd::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return InterestGroupAd::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::InterestGroupAd_UnserializedMessageContext<UserType, InterestGroupAd::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<InterestGroupAd::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    std::string render_url;

    std::optional<std::string> size_group;

    std::optional<std::string> buyer_reporting_id;

    std::optional<std::string> buyer_and_seller_reporting_id;

    std::optional<std::vector<std::string>> selectable_buyer_and_seller_reporting_ids;

    std::optional<std::string> metadata;

    std::optional<std::string> ad_render_id;

    std::optional<std::vector<::url::Origin>> allowed_reporting_origins;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, InterestGroupAd::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, InterestGroupAd::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, InterestGroupAd::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, InterestGroupAd::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class BLINK_COMMON_EXPORT InterestGroup {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<InterestGroup, T>::value>;
    using DataView = InterestGroupDataView;
    using Data_ = internal::InterestGroup_Data;
    using ExecutionMode = InterestGroup_ExecutionMode;
    using TrustedBiddingSignalsSlotSizeMode = InterestGroup_TrustedBiddingSignalsSlotSizeMode;

    template <typename... Args> static InterestGroupPtr New(Args&&... args)
    {
        return InterestGroupPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static InterestGroupPtr From(const U& u)
    {
        return mojo::TypeConverter<InterestGroupPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, InterestGroup>::Convert(*this);
    }

    InterestGroup()
    : expiry()
    , owner()
    , name()
    , priority(0.0)
    , enable_bidding_signals_prioritization()
    , priority_vector()
    , priority_signals_overrides()
    , seller_capabilities()
    , all_sellers_capabilities()
    , execution_mode(InterestGroup_ExecutionMode::kCompatibilityMode)
    , trusted_bidding_signals_slot_size_mode(InterestGroup_TrustedBiddingSignalsSlotSizeMode::kNone)
    , bidding_url()
    , bidding_wasm_helper_url()
    , update_url()
    , trusted_bidding_signals_url()
    , trusted_bidding_signals_keys()
    , max_trusted_bidding_signals_url_length(0)
    , trusted_bidding_signals_coordinator()
    , user_bidding_signals()
    , ads()
    , ad_components()
    , ad_sizes()
    , size_groups()
    , auction_server_request_flags()
    , additional_bid_key()
    , aggregation_coordinator_origin()
{
}

    InterestGroup(::base::Time expiry_in, const ::url::Origin& owner_in, const std::string& name_in, double priority_in,
    bool enable_bidding_signals_prioritization_in, const std::optional<base::flat_map<std::string, double>>& priority_vector_in,
    const std::optional<base::flat_map<std::string, double>>& priority_signals_overrides_in,
    std::optional<base::flat_map<::url::Origin, SellerCapabilitiesPtr>> seller_capabilities_in, SellerCapabilitiesPtr all_sellers_capabilities_in,
    InterestGroup::ExecutionMode execution_mode_in, InterestGroup::TrustedBiddingSignalsSlotSizeMode trusted_bidding_signals_slot_size_mode_in,
    const std::optional<::GURL>& bidding_url_in, const std::optional<::GURL>& bidding_wasm_helper_url_in, const std::optional<::GURL>& update_url_in,
    const std::optional<::GURL>& trusted_bidding_signals_url_in, std::optional<std::vector<std::string>> trusted_bidding_signals_keys_in,
    int32_t max_trusted_bidding_signals_url_length_in, const std::optional<::url::Origin>& trusted_bidding_signals_coordinator_in,
    const std::optional<std::string>& user_bidding_signals_in, std::optional<std::vector<::blink::InterestGroup::Ad>> ads_in,
    std::optional<std::vector<::blink::InterestGroup::Ad>> ad_components_in, const std::optional<base::flat_map<std::string, ::blink::AdSize>>& ad_sizes_in,
    const std::optional<base::flat_map<std::string, std::vector<std::string>>>& size_groups_in, AuctionServerRequestFlagsPtr auction_server_request_flags_in,
    std::optional<std::vector<uint8_t>> additional_bid_key_in, const std::optional<::url::Origin>& aggregation_coordinator_origin_in)
    : expiry(std::move(expiry_in))
    , owner(std::move(owner_in))
    , name(std::move(name_in))
    , priority(std::move(priority_in))
    , enable_bidding_signals_prioritization(std::move(enable_bidding_signals_prioritization_in))
    , priority_vector(std::move(priority_vector_in))
    , priority_signals_overrides(std::move(priority_signals_overrides_in))
    , seller_capabilities(std::move(seller_capabilities_in))
    , all_sellers_capabilities(std::move(all_sellers_capabilities_in))
    , execution_mode(std::move(execution_mode_in))
    , trusted_bidding_signals_slot_size_mode(std::move(trusted_bidding_signals_slot_size_mode_in))
    , bidding_url(std::move(bidding_url_in))
    , bidding_wasm_helper_url(std::move(bidding_wasm_helper_url_in))
    , update_url(std::move(update_url_in))
    , trusted_bidding_signals_url(std::move(trusted_bidding_signals_url_in))
    , trusted_bidding_signals_keys(std::move(trusted_bidding_signals_keys_in))
    , max_trusted_bidding_signals_url_length(std::move(max_trusted_bidding_signals_url_length_in))
    , trusted_bidding_signals_coordinator(std::move(trusted_bidding_signals_coordinator_in))
    , user_bidding_signals(std::move(user_bidding_signals_in))
    , ads(std::move(ads_in))
    , ad_components(std::move(ad_components_in))
    , ad_sizes(std::move(ad_sizes_in))
    , size_groups(std::move(size_groups_in))
    , auction_server_request_flags(std::move(auction_server_request_flags_in))
    , additional_bid_key(std::move(additional_bid_key_in))
    , aggregation_coordinator_origin(std::move(aggregation_coordinator_origin_in)){
}

    InterestGroup(const InterestGroup&) = delete;
    InterestGroup& operator=(const InterestGroup&) = delete;

    ~InterestGroup() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = InterestGroupPtr> InterestGroupPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, InterestGroup::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, InterestGroup::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, InterestGroup::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static std::vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<InterestGroup::DataView, std::vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<InterestGroup::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(std::make_unique<internal::InterestGroup_UnserializedMessageContext<UserType, InterestGroup::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<InterestGroup::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return InterestGroup::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::InterestGroup_UnserializedMessageContext<UserType, InterestGroup::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<InterestGroup::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    ::base::Time expiry;

    ::url::Origin owner;

    std::string name;

    double priority;

    bool enable_bidding_signals_prioritization;

    std::optional<base::flat_map<std::string, double>> priority_vector;

    std::optional<base::flat_map<std::string, double>> priority_signals_overrides;

    std::optional<base::flat_map<::url::Origin, SellerCapabilitiesPtr>> seller_capabilities;

    SellerCapabilitiesPtr all_sellers_capabilities;

    InterestGroup::ExecutionMode execution_mode;

    InterestGroup::TrustedBiddingSignalsSlotSizeMode trusted_bidding_signals_slot_size_mode;

    std::optional<::GURL> bidding_url;

    std::optional<::GURL> bidding_wasm_helper_url;

    std::optional<::GURL> update_url;

    std::optional<::GURL> trusted_bidding_signals_url;

    std::optional<std::vector<std::string>> trusted_bidding_signals_keys;

    int32_t max_trusted_bidding_signals_url_length;

    std::optional<::url::Origin> trusted_bidding_signals_coordinator;

    std::optional<std::string> user_bidding_signals;

    std::optional<std::vector<::blink::InterestGroup::Ad>> ads;

    std::optional<std::vector<::blink::InterestGroup::Ad>> ad_components;

    std::optional<base::flat_map<std::string, ::blink::AdSize>> ad_sizes;

    std::optional<base::flat_map<std::string, std::vector<std::string>>> size_groups;

    AuctionServerRequestFlagsPtr auction_server_request_flags;

    std::optional<std::vector<uint8_t>> additional_bid_key;

    std::optional<::url::Origin> aggregation_coordinator_origin;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, InterestGroup::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, InterestGroup::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, InterestGroup::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, InterestGroup::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class BLINK_COMMON_EXPORT PreviousWin {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<PreviousWin, T>::value>;
    using DataView = PreviousWinDataView;
    using Data_ = internal::PreviousWin_Data;

    template <typename... Args> static PreviousWinPtr New(Args&&... args)
    {
        return PreviousWinPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static PreviousWinPtr From(const U& u)
    {
        return mojo::TypeConverter<PreviousWinPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, PreviousWin>::Convert(*this);
    }

    PreviousWin()
    : time()
    , ad_json()
{
}

    PreviousWin(::base::Time time_in, const std::string& ad_json_in)
    : time(std::move(time_in))
    , ad_json(std::move(ad_json_in)){
}

    ~PreviousWin() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = PreviousWinPtr> PreviousWinPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, PreviousWin::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, PreviousWin::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, PreviousWin::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static std::vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<PreviousWin::DataView, std::vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<PreviousWin::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(std::make_unique<internal::PreviousWin_UnserializedMessageContext<UserType, PreviousWin::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<PreviousWin::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return PreviousWin::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::PreviousWin_UnserializedMessageContext<UserType, PreviousWin::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<PreviousWin::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    ::base::Time time;

    std::string ad_json;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, PreviousWin::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, PreviousWin::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, PreviousWin::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, PreviousWin::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class BLINK_COMMON_EXPORT BiddingBrowserSignals {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<BiddingBrowserSignals, T>::value>;
    using DataView = BiddingBrowserSignalsDataView;
    using Data_ = internal::BiddingBrowserSignals_Data;

    template <typename... Args> static BiddingBrowserSignalsPtr New(Args&&... args)
    {
        return BiddingBrowserSignalsPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static BiddingBrowserSignalsPtr From(const U& u)
    {
        return mojo::TypeConverter<BiddingBrowserSignalsPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, BiddingBrowserSignals>::Convert(*this);
    }

    BiddingBrowserSignals()
    : join_count()
    , bid_count()
    , prev_wins()
    , for_debugging_only_in_cooldown_or_lockout()
{
}

    BiddingBrowserSignals(
    int32_t join_count_in, int32_t bid_count_in, std::vector<PreviousWinPtr> prev_wins_in, bool for_debugging_only_in_cooldown_or_lockout_in)
    : join_count(std::move(join_count_in))
    , bid_count(std::move(bid_count_in))
    , prev_wins(std::move(prev_wins_in))
    , for_debugging_only_in_cooldown_or_lockout(std::move(for_debugging_only_in_cooldown_or_lockout_in)){
}

    BiddingBrowserSignals(const BiddingBrowserSignals&) = delete;
    BiddingBrowserSignals& operator=(const BiddingBrowserSignals&) = delete;

    ~BiddingBrowserSignals() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = BiddingBrowserSignalsPtr> BiddingBrowserSignalsPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, BiddingBrowserSignals::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, BiddingBrowserSignals::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, BiddingBrowserSignals::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static std::vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<BiddingBrowserSignals::DataView, std::vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<BiddingBrowserSignals::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::BiddingBrowserSignals_UnserializedMessageContext<UserType, BiddingBrowserSignals::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<BiddingBrowserSignals::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return BiddingBrowserSignals::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::BiddingBrowserSignals_UnserializedMessageContext<UserType, BiddingBrowserSignals::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<BiddingBrowserSignals::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    int32_t join_count;

    int32_t bid_count;

    std::vector<PreviousWinPtr> prev_wins;

    bool for_debugging_only_in_cooldown_or_lockout;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, BiddingBrowserSignals::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, BiddingBrowserSignals::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, BiddingBrowserSignals::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, BiddingBrowserSignals::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class BLINK_COMMON_EXPORT StorageInterestGroup {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<StorageInterestGroup, T>::value>;
    using DataView = StorageInterestGroupDataView;
    using Data_ = internal::StorageInterestGroup_Data;

    template <typename... Args> static StorageInterestGroupPtr New(Args&&... args)
    {
        return StorageInterestGroupPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static StorageInterestGroupPtr From(const U& u)
    {
        return mojo::TypeConverter<StorageInterestGroupPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, StorageInterestGroup>::Convert(*this);
    }

    StorageInterestGroup()
    : interest_group()
    , bidding_browser_signals()
    , joining_origin()
    , join_time()
    , last_updated()
    , next_update_after()
    , estimated_size()
{
}

    StorageInterestGroup(const ::blink::InterestGroup& interest_group_in, BiddingBrowserSignalsPtr bidding_browser_signals_in,
    const ::url::Origin& joining_origin_in, ::base::Time join_time_in, ::base::Time last_updated_in, ::base::Time next_update_after_in,
    uint64_t estimated_size_in)
    : interest_group(std::move(interest_group_in))
    , bidding_browser_signals(std::move(bidding_browser_signals_in))
    , joining_origin(std::move(joining_origin_in))
    , join_time(std::move(join_time_in))
    , last_updated(std::move(last_updated_in))
    , next_update_after(std::move(next_update_after_in))
    , estimated_size(std::move(estimated_size_in)){
}

    StorageInterestGroup(const StorageInterestGroup&) = delete;
    StorageInterestGroup& operator=(const StorageInterestGroup&) = delete;

    ~StorageInterestGroup() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = StorageInterestGroupPtr> StorageInterestGroupPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, StorageInterestGroup::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, StorageInterestGroup::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, StorageInterestGroup::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static std::vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<StorageInterestGroup::DataView, std::vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<StorageInterestGroup::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::StorageInterestGroup_UnserializedMessageContext<UserType, StorageInterestGroup::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<StorageInterestGroup::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return StorageInterestGroup::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::StorageInterestGroup_UnserializedMessageContext<UserType, StorageInterestGroup::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<StorageInterestGroup::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    ::blink::InterestGroup interest_group;

    BiddingBrowserSignalsPtr bidding_browser_signals;

    ::url::Origin joining_origin;

    ::base::Time join_time;

    ::base::Time last_updated;

    ::base::Time next_update_after;

    uint64_t estimated_size;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, StorageInterestGroup::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, StorageInterestGroup::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, StorageInterestGroup::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, StorageInterestGroup::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class BLINK_COMMON_EXPORT DirectFromSellerSignalsSubresource {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<DirectFromSellerSignalsSubresource, T>::value>;
    using DataView = DirectFromSellerSignalsSubresourceDataView;
    using Data_ = internal::DirectFromSellerSignalsSubresource_Data;

    template <typename... Args> static DirectFromSellerSignalsSubresourcePtr New(Args&&... args)
    {
        return DirectFromSellerSignalsSubresourcePtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static DirectFromSellerSignalsSubresourcePtr From(const U& u)
    {
        return mojo::TypeConverter<DirectFromSellerSignalsSubresourcePtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, DirectFromSellerSignalsSubresource>::Convert(*this);
    }

    DirectFromSellerSignalsSubresource()
    : bundle_url()
    , token()
{
}

    DirectFromSellerSignalsSubresource(const ::GURL& bundle_url_in, const ::base::UnguessableToken& token_in)
    : bundle_url(std::move(bundle_url_in))
    , token(std::move(token_in)){
}

    ~DirectFromSellerSignalsSubresource() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = DirectFromSellerSignalsSubresourcePtr> DirectFromSellerSignalsSubresourcePtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, DirectFromSellerSignalsSubresource::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, DirectFromSellerSignalsSubresource::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, DirectFromSellerSignalsSubresource::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static std::vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<DirectFromSellerSignalsSubresource::DataView, std::vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<DirectFromSellerSignalsSubresource::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::DirectFromSellerSignalsSubresource_UnserializedMessageContext<UserType, DirectFromSellerSignalsSubresource::DataView>>(
                0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<DirectFromSellerSignalsSubresource::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return DirectFromSellerSignalsSubresource::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<
            internal::DirectFromSellerSignalsSubresource_UnserializedMessageContext<UserType, DirectFromSellerSignalsSubresource::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<DirectFromSellerSignalsSubresource::DataView>(
            input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    ::GURL bundle_url;

    ::base::UnguessableToken token;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, DirectFromSellerSignalsSubresource::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, DirectFromSellerSignalsSubresource::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, DirectFromSellerSignalsSubresource::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, DirectFromSellerSignalsSubresource::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class BLINK_COMMON_EXPORT DirectFromSellerSignals {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<DirectFromSellerSignals, T>::value>;
    using DataView = DirectFromSellerSignalsDataView;
    using Data_ = internal::DirectFromSellerSignals_Data;

    template <typename... Args> static DirectFromSellerSignalsPtr New(Args&&... args)
    {
        return DirectFromSellerSignalsPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static DirectFromSellerSignalsPtr From(const U& u)
    {
        return mojo::TypeConverter<DirectFromSellerSignalsPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, DirectFromSellerSignals>::Convert(*this);
    }

    DirectFromSellerSignals()
    : prefix()
    , per_buyer_signals()
    , seller_signals()
    , auction_signals()
{
}

    DirectFromSellerSignals(const ::GURL& prefix_in,
    const base::flat_map<::url::Origin, ::blink::DirectFromSellerSignalsSubresource>& per_buyer_signals_in,
    const std::optional<::blink::DirectFromSellerSignalsSubresource>& seller_signals_in,
    const std::optional<::blink::DirectFromSellerSignalsSubresource>& auction_signals_in)
    : prefix(std::move(prefix_in))
    , per_buyer_signals(std::move(per_buyer_signals_in))
    , seller_signals(std::move(seller_signals_in))
    , auction_signals(std::move(auction_signals_in)){
}

    ~DirectFromSellerSignals() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = DirectFromSellerSignalsPtr> DirectFromSellerSignalsPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, DirectFromSellerSignals::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, DirectFromSellerSignals::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, DirectFromSellerSignals::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static std::vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<DirectFromSellerSignals::DataView, std::vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<DirectFromSellerSignals::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::DirectFromSellerSignals_UnserializedMessageContext<UserType, DirectFromSellerSignals::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<DirectFromSellerSignals::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return DirectFromSellerSignals::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context
            = input.TakeUnserializedContext<internal::DirectFromSellerSignals_UnserializedMessageContext<UserType, DirectFromSellerSignals::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<DirectFromSellerSignals::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    ::GURL prefix;

    base::flat_map<::url::Origin, ::blink::DirectFromSellerSignalsSubresource> per_buyer_signals;

    std::optional<::blink::DirectFromSellerSignalsSubresource> seller_signals;

    std::optional<::blink::DirectFromSellerSignalsSubresource> auction_signals;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, DirectFromSellerSignals::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, DirectFromSellerSignals::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, DirectFromSellerSignals::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, DirectFromSellerSignals::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class BLINK_COMMON_EXPORT AuctionAdConfigBuyerTimeouts {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<AuctionAdConfigBuyerTimeouts, T>::value>;
    using DataView = AuctionAdConfigBuyerTimeoutsDataView;
    using Data_ = internal::AuctionAdConfigBuyerTimeouts_Data;

    template <typename... Args> static AuctionAdConfigBuyerTimeoutsPtr New(Args&&... args)
    {
        return AuctionAdConfigBuyerTimeoutsPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static AuctionAdConfigBuyerTimeoutsPtr From(const U& u)
    {
        return mojo::TypeConverter<AuctionAdConfigBuyerTimeoutsPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, AuctionAdConfigBuyerTimeouts>::Convert(*this);
    }

    AuctionAdConfigBuyerTimeouts()
    : all_buyers_timeout()
    , per_buyer_timeouts()
{
}

    AuctionAdConfigBuyerTimeouts(
    std::optional<::base::TimeDelta> all_buyers_timeout_in, const std::optional<base::flat_map<::url::Origin, ::base::TimeDelta>>& per_buyer_timeouts_in)
    : all_buyers_timeout(std::move(all_buyers_timeout_in))
    , per_buyer_timeouts(std::move(per_buyer_timeouts_in)){
}

    ~AuctionAdConfigBuyerTimeouts() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = AuctionAdConfigBuyerTimeoutsPtr> AuctionAdConfigBuyerTimeoutsPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, AuctionAdConfigBuyerTimeouts::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, AuctionAdConfigBuyerTimeouts::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, AuctionAdConfigBuyerTimeouts::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static std::vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<AuctionAdConfigBuyerTimeouts::DataView, std::vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<AuctionAdConfigBuyerTimeouts::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::AuctionAdConfigBuyerTimeouts_UnserializedMessageContext<UserType, AuctionAdConfigBuyerTimeouts::DataView>>(
                0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<AuctionAdConfigBuyerTimeouts::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return AuctionAdConfigBuyerTimeouts::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<
            internal::AuctionAdConfigBuyerTimeouts_UnserializedMessageContext<UserType, AuctionAdConfigBuyerTimeouts::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<AuctionAdConfigBuyerTimeouts::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    std::optional<::base::TimeDelta> all_buyers_timeout;

    std::optional<base::flat_map<::url::Origin, ::base::TimeDelta>> per_buyer_timeouts;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, AuctionAdConfigBuyerTimeouts::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, AuctionAdConfigBuyerTimeouts::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, AuctionAdConfigBuyerTimeouts::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, AuctionAdConfigBuyerTimeouts::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class BLINK_COMMON_EXPORT AuctionAdConfigBuyerCurrencies {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<AuctionAdConfigBuyerCurrencies, T>::value>;
    using DataView = AuctionAdConfigBuyerCurrenciesDataView;
    using Data_ = internal::AuctionAdConfigBuyerCurrencies_Data;

    template <typename... Args> static AuctionAdConfigBuyerCurrenciesPtr New(Args&&... args)
    {
        return AuctionAdConfigBuyerCurrenciesPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static AuctionAdConfigBuyerCurrenciesPtr From(const U& u)
    {
        return mojo::TypeConverter<AuctionAdConfigBuyerCurrenciesPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, AuctionAdConfigBuyerCurrencies>::Convert(*this);
    }

    AuctionAdConfigBuyerCurrencies()
    : all_buyers_currency()
    , per_buyer_currencies()
{
}

    AuctionAdConfigBuyerCurrencies(const std::optional<::blink::AdCurrency>& all_buyers_currency_in,
    const std::optional<base::flat_map<::url::Origin, ::blink::AdCurrency>>& per_buyer_currencies_in)
    : all_buyers_currency(std::move(all_buyers_currency_in))
    , per_buyer_currencies(std::move(per_buyer_currencies_in)){
}

    ~AuctionAdConfigBuyerCurrencies() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = AuctionAdConfigBuyerCurrenciesPtr> AuctionAdConfigBuyerCurrenciesPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, AuctionAdConfigBuyerCurrencies::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, AuctionAdConfigBuyerCurrencies::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, AuctionAdConfigBuyerCurrencies::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static std::vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<AuctionAdConfigBuyerCurrencies::DataView, std::vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<AuctionAdConfigBuyerCurrencies::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::AuctionAdConfigBuyerCurrencies_UnserializedMessageContext<UserType, AuctionAdConfigBuyerCurrencies::DataView>>(
                0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<AuctionAdConfigBuyerCurrencies::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return AuctionAdConfigBuyerCurrencies::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<
            internal::AuctionAdConfigBuyerCurrencies_UnserializedMessageContext<UserType, AuctionAdConfigBuyerCurrencies::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<AuctionAdConfigBuyerCurrencies::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    std::optional<::blink::AdCurrency> all_buyers_currency;

    std::optional<base::flat_map<::url::Origin, ::blink::AdCurrency>> per_buyer_currencies;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, AuctionAdConfigBuyerCurrencies::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, AuctionAdConfigBuyerCurrencies::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, AuctionAdConfigBuyerCurrencies::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, AuctionAdConfigBuyerCurrencies::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class BLINK_COMMON_EXPORT AuctionAdServerResponseConfig {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<AuctionAdServerResponseConfig, T>::value>;
    using DataView = AuctionAdServerResponseConfigDataView;
    using Data_ = internal::AuctionAdServerResponseConfig_Data;

    template <typename... Args> static AuctionAdServerResponseConfigPtr New(Args&&... args)
    {
        return AuctionAdServerResponseConfigPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static AuctionAdServerResponseConfigPtr From(const U& u)
    {
        return mojo::TypeConverter<AuctionAdServerResponseConfigPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, AuctionAdServerResponseConfig>::Convert(*this);
    }

    AuctionAdServerResponseConfig()
    : request_id()
{
}

    explicit AuctionAdServerResponseConfig(const ::base::Uuid& request_id_in)
    : request_id(std::move(request_id_in)){
}

    ~AuctionAdServerResponseConfig() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = AuctionAdServerResponseConfigPtr> AuctionAdServerResponseConfigPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, AuctionAdServerResponseConfig::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, AuctionAdServerResponseConfig::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, AuctionAdServerResponseConfig::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static std::vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<AuctionAdServerResponseConfig::DataView, std::vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<AuctionAdServerResponseConfig::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::AuctionAdServerResponseConfig_UnserializedMessageContext<UserType, AuctionAdServerResponseConfig::DataView>>(
                0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<AuctionAdServerResponseConfig::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return AuctionAdServerResponseConfig::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<
            internal::AuctionAdServerResponseConfig_UnserializedMessageContext<UserType, AuctionAdServerResponseConfig::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<AuctionAdServerResponseConfig::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    ::base::Uuid request_id;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, AuctionAdServerResponseConfig::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, AuctionAdServerResponseConfig::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, AuctionAdServerResponseConfig::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, AuctionAdServerResponseConfig::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class BLINK_COMMON_EXPORT AuctionReportBuyersConfig {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<AuctionReportBuyersConfig, T>::value>;
    using DataView = AuctionReportBuyersConfigDataView;
    using Data_ = internal::AuctionReportBuyersConfig_Data;

    template <typename... Args> static AuctionReportBuyersConfigPtr New(Args&&... args)
    {
        return AuctionReportBuyersConfigPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static AuctionReportBuyersConfigPtr From(const U& u)
    {
        return mojo::TypeConverter<AuctionReportBuyersConfigPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, AuctionReportBuyersConfig>::Convert(*this);
    }

    AuctionReportBuyersConfig()
    : bucket()
    , scale()
{
}

    AuctionReportBuyersConfig(const ::absl::uint128& bucket_in, double scale_in)
    : bucket(std::move(bucket_in))
    , scale(std::move(scale_in)){
}

    ~AuctionReportBuyersConfig() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = AuctionReportBuyersConfigPtr> AuctionReportBuyersConfigPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, AuctionReportBuyersConfig::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, AuctionReportBuyersConfig::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, AuctionReportBuyersConfig::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static std::vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<AuctionReportBuyersConfig::DataView, std::vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<AuctionReportBuyersConfig::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(std::make_unique<internal::AuctionReportBuyersConfig_UnserializedMessageContext<UserType, AuctionReportBuyersConfig::DataView>>(
                                 0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<AuctionReportBuyersConfig::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return AuctionReportBuyersConfig::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context
            = input.TakeUnserializedContext<internal::AuctionReportBuyersConfig_UnserializedMessageContext<UserType, AuctionReportBuyersConfig::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<AuctionReportBuyersConfig::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    ::absl::uint128 bucket;

    double scale;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, AuctionReportBuyersConfig::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, AuctionReportBuyersConfig::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, AuctionReportBuyersConfig::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, AuctionReportBuyersConfig::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class BLINK_COMMON_EXPORT AuctionAdConfigNonSharedParams {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<AuctionAdConfigNonSharedParams, T>::value>;
    using DataView = AuctionAdConfigNonSharedParamsDataView;
    using Data_ = internal::AuctionAdConfigNonSharedParams_Data;
    using BuyerReportType = AuctionAdConfigNonSharedParams_BuyerReportType;
    using RealTimeReportingType = AuctionAdConfigNonSharedParams_RealTimeReportingType;

    template <typename... Args> static AuctionAdConfigNonSharedParamsPtr New(Args&&... args)
    {
        return AuctionAdConfigNonSharedParamsPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static AuctionAdConfigNonSharedParamsPtr From(const U& u)
    {
        return mojo::TypeConverter<AuctionAdConfigNonSharedParamsPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, AuctionAdConfigNonSharedParams>::Convert(*this);
    }

    AuctionAdConfigNonSharedParams()
    : interest_group_buyers()
    , auction_signals()
    , seller_signals()
    , seller_timeout()
    , per_buyer_signals()
    , buyer_timeouts()
    , reporting_timeout()
    , seller_currency()
    , buyer_currencies()
    , buyer_cumulative_timeouts()
    , per_buyer_group_limits()
    , per_buyer_priority_signals()
    , all_buyers_priority_signals()
    , all_buyers_group_limit(65535U)
    , auction_report_buyer_keys()
    , auction_report_buyers()
    , auction_report_buyer_debug_mode_config()
    , required_seller_capabilities()
    , requested_size()
    , all_slots_requested_sizes()
    , per_buyer_multi_bid_limits()
    , all_buyers_multi_bid_limit()
    , auction_nonce()
    , seller_real_time_reporting_type()
    , per_buyer_real_time_reporting_types()
    , component_auctions()
    , deprecated_render_url_replacements()
    , max_trusted_scoring_signals_url_length(0)
    , trusted_scoring_signals_coordinator()
{
}

    AuctionAdConfigNonSharedParams(std::optional<std::vector<::url::Origin>> interest_group_buyers_in,
    const ::blink::AuctionConfig::MaybePromiseJson& auction_signals_in, const ::blink::AuctionConfig::MaybePromiseJson& seller_signals_in,
    std::optional<::base::TimeDelta> seller_timeout_in, const ::blink::AuctionConfig::MaybePromisePerBuyerSignals& per_buyer_signals_in,
    const ::blink::AuctionConfig::MaybePromiseBuyerTimeouts& buyer_timeouts_in, std::optional<::base::TimeDelta> reporting_timeout_in,
    const std::optional<::blink::AdCurrency>& seller_currency_in, const ::blink::AuctionConfig::MaybePromiseBuyerCurrencies& buyer_currencies_in,
    const ::blink::AuctionConfig::MaybePromiseBuyerTimeouts& buyer_cumulative_timeouts_in,
    const base::flat_map<::url::Origin, uint16_t>& per_buyer_group_limits_in,
    const std::optional<base::flat_map<::url::Origin, base::flat_map<std::string, double>>>& per_buyer_priority_signals_in,
    const std::optional<base::flat_map<std::string, double>>& all_buyers_priority_signals_in, uint16_t all_buyers_group_limit_in,
    std::optional<std::vector<::absl::uint128>> auction_report_buyer_keys_in,
    std::optional<base::flat_map<AuctionAdConfigNonSharedParams::BuyerReportType, AuctionReportBuyersConfigPtr>> auction_report_buyers_in,
    AuctionReportBuyerDebugModeConfigPtr auction_report_buyer_debug_mode_config_in, SellerCapabilitiesPtr required_seller_capabilities_in,
    const std::optional<::blink::AdSize>& requested_size_in, std::optional<std::vector<::blink::AdSize>> all_slots_requested_sizes_in,
    const base::flat_map<::url::Origin, uint16_t>& per_buyer_multi_bid_limits_in, uint16_t all_buyers_multi_bid_limit_in,
    const std::optional<::base::Uuid>& auction_nonce_in,
    std::optional<AuctionAdConfigNonSharedParams::RealTimeReportingType> seller_real_time_reporting_type_in,
    const std::optional<base::flat_map<::url::Origin, AuctionAdConfigNonSharedParams::RealTimeReportingType>>& per_buyer_real_time_reporting_types_in,
    std::vector<::blink::AuctionConfig> component_auctions_in,
    const ::blink::AuctionConfig::MaybePromiseDeprecatedRenderURLReplacements& deprecated_render_url_replacements_in,
    int32_t max_trusted_scoring_signals_url_length_in, const std::optional<::url::Origin>& trusted_scoring_signals_coordinator_in)
    : interest_group_buyers(std::move(interest_group_buyers_in))
    , auction_signals(std::move(auction_signals_in))
    , seller_signals(std::move(seller_signals_in))
    , seller_timeout(std::move(seller_timeout_in))
    , per_buyer_signals(std::move(per_buyer_signals_in))
    , buyer_timeouts(std::move(buyer_timeouts_in))
    , reporting_timeout(std::move(reporting_timeout_in))
    , seller_currency(std::move(seller_currency_in))
    , buyer_currencies(std::move(buyer_currencies_in))
    , buyer_cumulative_timeouts(std::move(buyer_cumulative_timeouts_in))
    , per_buyer_group_limits(std::move(per_buyer_group_limits_in))
    , per_buyer_priority_signals(std::move(per_buyer_priority_signals_in))
    , all_buyers_priority_signals(std::move(all_buyers_priority_signals_in))
    , all_buyers_group_limit(std::move(all_buyers_group_limit_in))
    , auction_report_buyer_keys(std::move(auction_report_buyer_keys_in))
    , auction_report_buyers(std::move(auction_report_buyers_in))
    , auction_report_buyer_debug_mode_config(std::move(auction_report_buyer_debug_mode_config_in))
    , required_seller_capabilities(std::move(required_seller_capabilities_in))
    , requested_size(std::move(requested_size_in))
    , all_slots_requested_sizes(std::move(all_slots_requested_sizes_in))
    , per_buyer_multi_bid_limits(std::move(per_buyer_multi_bid_limits_in))
    , all_buyers_multi_bid_limit(std::move(all_buyers_multi_bid_limit_in))
    , auction_nonce(std::move(auction_nonce_in))
    , seller_real_time_reporting_type(std::move(seller_real_time_reporting_type_in))
    , per_buyer_real_time_reporting_types(std::move(per_buyer_real_time_reporting_types_in))
    , component_auctions(std::move(component_auctions_in))
    , deprecated_render_url_replacements(std::move(deprecated_render_url_replacements_in))
    , max_trusted_scoring_signals_url_length(std::move(max_trusted_scoring_signals_url_length_in))
    , trusted_scoring_signals_coordinator(std::move(trusted_scoring_signals_coordinator_in)){
}

    AuctionAdConfigNonSharedParams(const AuctionAdConfigNonSharedParams&) = delete;
    AuctionAdConfigNonSharedParams& operator=(const AuctionAdConfigNonSharedParams&) = delete;

    ~AuctionAdConfigNonSharedParams() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = AuctionAdConfigNonSharedParamsPtr> AuctionAdConfigNonSharedParamsPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, AuctionAdConfigNonSharedParams::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, AuctionAdConfigNonSharedParams::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, AuctionAdConfigNonSharedParams::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static std::vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<AuctionAdConfigNonSharedParams::DataView, std::vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<AuctionAdConfigNonSharedParams::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::AuctionAdConfigNonSharedParams_UnserializedMessageContext<UserType, AuctionAdConfigNonSharedParams::DataView>>(
                0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<AuctionAdConfigNonSharedParams::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return AuctionAdConfigNonSharedParams::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<
            internal::AuctionAdConfigNonSharedParams_UnserializedMessageContext<UserType, AuctionAdConfigNonSharedParams::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<AuctionAdConfigNonSharedParams::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    std::optional<std::vector<::url::Origin>> interest_group_buyers;

    ::blink::AuctionConfig::MaybePromiseJson auction_signals;

    ::blink::AuctionConfig::MaybePromiseJson seller_signals;

    std::optional<::base::TimeDelta> seller_timeout;

    ::blink::AuctionConfig::MaybePromisePerBuyerSignals per_buyer_signals;

    ::blink::AuctionConfig::MaybePromiseBuyerTimeouts buyer_timeouts;

    std::optional<::base::TimeDelta> reporting_timeout;

    std::optional<::blink::AdCurrency> seller_currency;

    ::blink::AuctionConfig::MaybePromiseBuyerCurrencies buyer_currencies;

    ::blink::AuctionConfig::MaybePromiseBuyerTimeouts buyer_cumulative_timeouts;

    base::flat_map<::url::Origin, uint16_t> per_buyer_group_limits;

    std::optional<base::flat_map<::url::Origin, base::flat_map<std::string, double>>> per_buyer_priority_signals;

    std::optional<base::flat_map<std::string, double>> all_buyers_priority_signals;

    uint16_t all_buyers_group_limit;

    std::optional<std::vector<::absl::uint128>> auction_report_buyer_keys;

    std::optional<base::flat_map<AuctionAdConfigNonSharedParams::BuyerReportType, AuctionReportBuyersConfigPtr>> auction_report_buyers;

    AuctionReportBuyerDebugModeConfigPtr auction_report_buyer_debug_mode_config;

    SellerCapabilitiesPtr required_seller_capabilities;

    std::optional<::blink::AdSize> requested_size;

    std::optional<std::vector<::blink::AdSize>> all_slots_requested_sizes;

    base::flat_map<::url::Origin, uint16_t> per_buyer_multi_bid_limits;

    uint16_t all_buyers_multi_bid_limit;

    std::optional<::base::Uuid> auction_nonce;

    std::optional<AuctionAdConfigNonSharedParams::RealTimeReportingType> seller_real_time_reporting_type;

    std::optional<base::flat_map<::url::Origin, AuctionAdConfigNonSharedParams::RealTimeReportingType>> per_buyer_real_time_reporting_types;

    std::vector<::blink::AuctionConfig> component_auctions;

    ::blink::AuctionConfig::MaybePromiseDeprecatedRenderURLReplacements deprecated_render_url_replacements;

    int32_t max_trusted_scoring_signals_url_length;

    std::optional<::url::Origin> trusted_scoring_signals_coordinator;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, AuctionAdConfigNonSharedParams::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, AuctionAdConfigNonSharedParams::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, AuctionAdConfigNonSharedParams::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, AuctionAdConfigNonSharedParams::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class BLINK_COMMON_EXPORT AuctionAdConfig {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<AuctionAdConfig, T>::value>;
    using DataView = AuctionAdConfigDataView;
    using Data_ = internal::AuctionAdConfig_Data;

    template <typename... Args> static AuctionAdConfigPtr New(Args&&... args)
    {
        return AuctionAdConfigPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static AuctionAdConfigPtr From(const U& u)
    {
        return mojo::TypeConverter<AuctionAdConfigPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, AuctionAdConfig>::Convert(*this);
    }

    AuctionAdConfig()
    : seller()
    , server_response()
    , decision_logic_url()
    , trusted_scoring_signals_url()
    , auction_ad_config_non_shared_params()
    , direct_from_seller_signals()
    , expects_direct_from_seller_signals_header_ad_slot(false)
    , seller_experiment_group_id()
    , all_buyer_experiment_group_id()
    , per_buyer_experiment_group_ids()
    , expects_additional_bids(false)
    , aggregation_coordinator_origin()
{
}

    AuctionAdConfig(const ::url::Origin& seller_in, const std::optional<::blink::AuctionConfig::ServerResponseConfig>& server_response_in,
    const std::optional<::GURL>& decision_logic_url_in, const std::optional<::GURL>& trusted_scoring_signals_url_in,
    const ::blink::AuctionConfig::NonSharedParams& auction_ad_config_non_shared_params_in,
    const ::blink::AuctionConfig::MaybePromiseDirectFromSellerSignals& direct_from_seller_signals_in, bool expects_direct_from_seller_signals_header_ad_slot_in,
    std::optional<uint16_t> seller_experiment_group_id_in, std::optional<uint16_t> all_buyer_experiment_group_id_in,
    const base::flat_map<::url::Origin, uint16_t>& per_buyer_experiment_group_ids_in, bool expects_additional_bids_in,
    const std::optional<::url::Origin>& aggregation_coordinator_origin_in)
    : seller(std::move(seller_in))
    , server_response(std::move(server_response_in))
    , decision_logic_url(std::move(decision_logic_url_in))
    , trusted_scoring_signals_url(std::move(trusted_scoring_signals_url_in))
    , auction_ad_config_non_shared_params(std::move(auction_ad_config_non_shared_params_in))
    , direct_from_seller_signals(std::move(direct_from_seller_signals_in))
    , expects_direct_from_seller_signals_header_ad_slot(std::move(expects_direct_from_seller_signals_header_ad_slot_in))
    , seller_experiment_group_id(std::move(seller_experiment_group_id_in))
    , all_buyer_experiment_group_id(std::move(all_buyer_experiment_group_id_in))
    , per_buyer_experiment_group_ids(std::move(per_buyer_experiment_group_ids_in))
    , expects_additional_bids(std::move(expects_additional_bids_in))
    , aggregation_coordinator_origin(std::move(aggregation_coordinator_origin_in)){
}

    ~AuctionAdConfig() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = AuctionAdConfigPtr> AuctionAdConfigPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, AuctionAdConfig::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, AuctionAdConfig::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, AuctionAdConfig::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static std::vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<AuctionAdConfig::DataView, std::vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<AuctionAdConfig::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::AuctionAdConfig_UnserializedMessageContext<UserType, AuctionAdConfig::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<AuctionAdConfig::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return AuctionAdConfig::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::AuctionAdConfig_UnserializedMessageContext<UserType, AuctionAdConfig::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<AuctionAdConfig::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    ::url::Origin seller;

    std::optional<::blink::AuctionConfig::ServerResponseConfig> server_response;

    std::optional<::GURL> decision_logic_url;

    std::optional<::GURL> trusted_scoring_signals_url;

    ::blink::AuctionConfig::NonSharedParams auction_ad_config_non_shared_params;

    ::blink::AuctionConfig::MaybePromiseDirectFromSellerSignals direct_from_seller_signals;

    bool expects_direct_from_seller_signals_header_ad_slot;

    std::optional<uint16_t> seller_experiment_group_id;

    std::optional<uint16_t> all_buyer_experiment_group_id;

    base::flat_map<::url::Origin, uint16_t> per_buyer_experiment_group_ids;

    bool expects_additional_bids;

    std::optional<::url::Origin> aggregation_coordinator_origin;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, AuctionAdConfig::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, AuctionAdConfig::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, AuctionAdConfig::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, AuctionAdConfig::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class BLINK_COMMON_EXPORT AuctionDataConfig {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<AuctionDataConfig, T>::value>;
    using DataView = AuctionDataConfigDataView;
    using Data_ = internal::AuctionDataConfig_Data;

    template <typename... Args> static AuctionDataConfigPtr New(Args&&... args)
    {
        return AuctionDataConfigPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static AuctionDataConfigPtr From(const U& u)
    {
        return mojo::TypeConverter<AuctionDataConfigPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, AuctionDataConfig>::Convert(*this);
    }

    AuctionDataConfig()
    : per_buyer_configs()
    , request_size()
{
}

    AuctionDataConfig(base::flat_map<::url::Origin, AuctionDataBuyerConfigPtr> per_buyer_configs_in, std::optional<uint32_t> request_size_in)
    : per_buyer_configs(std::move(per_buyer_configs_in))
    , request_size(std::move(request_size_in)){
}

    AuctionDataConfig(const AuctionDataConfig&) = delete;
    AuctionDataConfig& operator=(const AuctionDataConfig&) = delete;

    ~AuctionDataConfig() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = AuctionDataConfigPtr> AuctionDataConfigPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, AuctionDataConfig::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, AuctionDataConfig::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, AuctionDataConfig::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static std::vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<AuctionDataConfig::DataView, std::vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<AuctionDataConfig::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::AuctionDataConfig_UnserializedMessageContext<UserType, AuctionDataConfig::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<AuctionDataConfig::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return AuctionDataConfig::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::AuctionDataConfig_UnserializedMessageContext<UserType, AuctionDataConfig::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<AuctionDataConfig::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    base::flat_map<::url::Origin, AuctionDataBuyerConfigPtr> per_buyer_configs;

    std::optional<uint32_t> request_size;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, AuctionDataConfig::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, AuctionDataConfig::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, AuctionDataConfig::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, AuctionDataConfig::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

template <typename UnionPtrType> AuctionAdConfigMaybePromiseJsonPtr AuctionAdConfigMaybePromiseJson::Clone() const
{
    switch (tag_) {
    case Tag::kPromise:
        return NewPromise(mojo::Clone(data_.promise));
    case Tag::kValue:
        return NewValue(mojo::Clone(*data_.value));
    }
    return nullptr;
}

template <typename T, typename std::enable_if<std::is_same<T, AuctionAdConfigMaybePromiseJson>::value>::type*>
bool AuctionAdConfigMaybePromiseJson::Equals(const T& other) const
{
    if (tag_ != other.which())
        return false;

    switch (tag_) {
    case Tag::kPromise:
        return mojo::Equals(data_.promise, other.data_.promise);
    case Tag::kValue:
        return mojo::Equals(*(data_.value), *(other.data_.value));
    }

    return false;
}
template <typename UnionPtrType> AuctionAdConfigMaybePromisePerBuyerSignalsPtr AuctionAdConfigMaybePromisePerBuyerSignals::Clone() const
{
    switch (tag_) {
    case Tag::kPromise:
        return NewPromise(mojo::Clone(data_.promise));
    case Tag::kValue:
        return NewValue(mojo::Clone(*data_.value));
    }
    return nullptr;
}

template <typename T, typename std::enable_if<std::is_same<T, AuctionAdConfigMaybePromisePerBuyerSignals>::value>::type*>
bool AuctionAdConfigMaybePromisePerBuyerSignals::Equals(const T& other) const
{
    if (tag_ != other.which())
        return false;

    switch (tag_) {
    case Tag::kPromise:
        return mojo::Equals(data_.promise, other.data_.promise);
    case Tag::kValue:
        return mojo::Equals(*(data_.value), *(other.data_.value));
    }

    return false;
}
template <typename UnionPtrType> AuctionAdConfigMaybePromiseBuyerTimeoutsPtr AuctionAdConfigMaybePromiseBuyerTimeouts::Clone() const
{
    switch (tag_) {
    case Tag::kPromise:
        return NewPromise(mojo::Clone(data_.promise));
    case Tag::kValue:
        return NewValue(mojo::Clone(*data_.value));
    }
    return nullptr;
}

template <typename T, typename std::enable_if<std::is_same<T, AuctionAdConfigMaybePromiseBuyerTimeouts>::value>::type*>
bool AuctionAdConfigMaybePromiseBuyerTimeouts::Equals(const T& other) const
{
    if (tag_ != other.which())
        return false;

    switch (tag_) {
    case Tag::kPromise:
        return mojo::Equals(data_.promise, other.data_.promise);
    case Tag::kValue:
        return mojo::Equals(*(data_.value), *(other.data_.value));
    }

    return false;
}
template <typename UnionPtrType> AuctionAdConfigMaybePromiseBuyerCurrenciesPtr AuctionAdConfigMaybePromiseBuyerCurrencies::Clone() const
{
    switch (tag_) {
    case Tag::kPromise:
        return NewPromise(mojo::Clone(data_.promise));
    case Tag::kValue:
        return NewValue(mojo::Clone(*data_.value));
    }
    return nullptr;
}

template <typename T, typename std::enable_if<std::is_same<T, AuctionAdConfigMaybePromiseBuyerCurrencies>::value>::type*>
bool AuctionAdConfigMaybePromiseBuyerCurrencies::Equals(const T& other) const
{
    if (tag_ != other.which())
        return false;

    switch (tag_) {
    case Tag::kPromise:
        return mojo::Equals(data_.promise, other.data_.promise);
    case Tag::kValue:
        return mojo::Equals(*(data_.value), *(other.data_.value));
    }

    return false;
}
template <typename UnionPtrType> AuctionAdConfigMaybePromiseDirectFromSellerSignalsPtr AuctionAdConfigMaybePromiseDirectFromSellerSignals::Clone() const
{
    switch (tag_) {
    case Tag::kPromise:
        return NewPromise(mojo::Clone(data_.promise));
    case Tag::kValue:
        return NewValue(mojo::Clone(*data_.value));
    }
    return nullptr;
}

template <typename T, typename std::enable_if<std::is_same<T, AuctionAdConfigMaybePromiseDirectFromSellerSignals>::value>::type*>
bool AuctionAdConfigMaybePromiseDirectFromSellerSignals::Equals(const T& other) const
{
    if (tag_ != other.which())
        return false;

    switch (tag_) {
    case Tag::kPromise:
        return mojo::Equals(data_.promise, other.data_.promise);
    case Tag::kValue:
        return mojo::Equals(*(data_.value), *(other.data_.value));
    }

    return false;
}
template <typename UnionPtrType>
AuctionAdConfigMaybePromiseDeprecatedRenderURLReplacementsPtr AuctionAdConfigMaybePromiseDeprecatedRenderURLReplacements::Clone() const
{
    switch (tag_) {
    case Tag::kPromise:
        return NewPromise(mojo::Clone(data_.promise));
    case Tag::kValue:
        return NewValue(mojo::Clone(*data_.value));
    }
    return nullptr;
}

template <typename T, typename std::enable_if<std::is_same<T, AuctionAdConfigMaybePromiseDeprecatedRenderURLReplacements>::value>::type*>
bool AuctionAdConfigMaybePromiseDeprecatedRenderURLReplacements::Equals(const T& other) const
{
    if (tag_ != other.which())
        return false;

    switch (tag_) {
    case Tag::kPromise:
        return mojo::Equals(data_.promise, other.data_.promise);
    case Tag::kValue:
        return mojo::Equals(*(data_.value), *(other.data_.value));
    }

    return false;
}
template <typename StructPtrType> InterestGroupAdPtr InterestGroupAd::Clone() const
{
    return New(mojo::Clone(render_url), mojo::Clone(size_group), mojo::Clone(buyer_reporting_id), mojo::Clone(buyer_and_seller_reporting_id),
        mojo::Clone(selectable_buyer_and_seller_reporting_ids), mojo::Clone(metadata), mojo::Clone(ad_render_id), mojo::Clone(allowed_reporting_origins));
}

template <typename T, InterestGroupAd::EnableIfSame<T>*> bool InterestGroupAd::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->render_url, other_struct.render_url))
        return false;
    if (!mojo::Equals(this->size_group, other_struct.size_group))
        return false;
    if (!mojo::Equals(this->buyer_reporting_id, other_struct.buyer_reporting_id))
        return false;
    if (!mojo::Equals(this->buyer_and_seller_reporting_id, other_struct.buyer_and_seller_reporting_id))
        return false;
    if (!mojo::Equals(this->selectable_buyer_and_seller_reporting_ids, other_struct.selectable_buyer_and_seller_reporting_ids))
        return false;
    if (!mojo::Equals(this->metadata, other_struct.metadata))
        return false;
    if (!mojo::Equals(this->ad_render_id, other_struct.ad_render_id))
        return false;
    if (!mojo::Equals(this->allowed_reporting_origins, other_struct.allowed_reporting_origins))
        return false;
    return true;
}

template <typename T, InterestGroupAd::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.render_url < rhs.render_url)
        return true;
    if (rhs.render_url < lhs.render_url)
        return false;
    if (lhs.size_group < rhs.size_group)
        return true;
    if (rhs.size_group < lhs.size_group)
        return false;
    if (lhs.buyer_reporting_id < rhs.buyer_reporting_id)
        return true;
    if (rhs.buyer_reporting_id < lhs.buyer_reporting_id)
        return false;
    if (lhs.buyer_and_seller_reporting_id < rhs.buyer_and_seller_reporting_id)
        return true;
    if (rhs.buyer_and_seller_reporting_id < lhs.buyer_and_seller_reporting_id)
        return false;
    if (lhs.selectable_buyer_and_seller_reporting_ids < rhs.selectable_buyer_and_seller_reporting_ids)
        return true;
    if (rhs.selectable_buyer_and_seller_reporting_ids < lhs.selectable_buyer_and_seller_reporting_ids)
        return false;
    if (lhs.metadata < rhs.metadata)
        return true;
    if (rhs.metadata < lhs.metadata)
        return false;
    if (lhs.ad_render_id < rhs.ad_render_id)
        return true;
    if (rhs.ad_render_id < lhs.ad_render_id)
        return false;
    if (lhs.allowed_reporting_origins < rhs.allowed_reporting_origins)
        return true;
    if (rhs.allowed_reporting_origins < lhs.allowed_reporting_origins)
        return false;
    return false;
}
template <typename StructPtrType> SellerCapabilitiesPtr SellerCapabilities::Clone() const
{
    return New(mojo::Clone(allows_interest_group_counts), mojo::Clone(allows_latency_stats));
}

template <typename T, SellerCapabilities::EnableIfSame<T>*> bool SellerCapabilities::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->allows_interest_group_counts, other_struct.allows_interest_group_counts))
        return false;
    if (!mojo::Equals(this->allows_latency_stats, other_struct.allows_latency_stats))
        return false;
    return true;
}

template <typename T, SellerCapabilities::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.allows_interest_group_counts < rhs.allows_interest_group_counts)
        return true;
    if (rhs.allows_interest_group_counts < lhs.allows_interest_group_counts)
        return false;
    if (lhs.allows_latency_stats < rhs.allows_latency_stats)
        return true;
    if (rhs.allows_latency_stats < lhs.allows_latency_stats)
        return false;
    return false;
}
template <typename StructPtrType> AuctionServerRequestFlagsPtr AuctionServerRequestFlags::Clone() const
{
    return New(mojo::Clone(omit_ads), mojo::Clone(include_full_ads), mojo::Clone(omit_user_bidding_signals));
}

template <typename T, AuctionServerRequestFlags::EnableIfSame<T>*> bool AuctionServerRequestFlags::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->omit_ads, other_struct.omit_ads))
        return false;
    if (!mojo::Equals(this->include_full_ads, other_struct.include_full_ads))
        return false;
    if (!mojo::Equals(this->omit_user_bidding_signals, other_struct.omit_user_bidding_signals))
        return false;
    return true;
}

template <typename T, AuctionServerRequestFlags::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.omit_ads < rhs.omit_ads)
        return true;
    if (rhs.omit_ads < lhs.omit_ads)
        return false;
    if (lhs.include_full_ads < rhs.include_full_ads)
        return true;
    if (rhs.include_full_ads < lhs.include_full_ads)
        return false;
    if (lhs.omit_user_bidding_signals < rhs.omit_user_bidding_signals)
        return true;
    if (rhs.omit_user_bidding_signals < lhs.omit_user_bidding_signals)
        return false;
    return false;
}
template <typename StructPtrType> AdKeywordReplacementPtr AdKeywordReplacement::Clone() const
{
    return New(mojo::Clone(match), mojo::Clone(replacement));
}

template <typename T, AdKeywordReplacement::EnableIfSame<T>*> bool AdKeywordReplacement::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->match, other_struct.match))
        return false;
    if (!mojo::Equals(this->replacement, other_struct.replacement))
        return false;
    return true;
}

template <typename T, AdKeywordReplacement::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.match < rhs.match)
        return true;
    if (rhs.match < lhs.match)
        return false;
    if (lhs.replacement < rhs.replacement)
        return true;
    if (rhs.replacement < lhs.replacement)
        return false;
    return false;
}
template <typename StructPtrType> InterestGroupPtr InterestGroup::Clone() const
{
    return New(mojo::Clone(expiry), mojo::Clone(owner), mojo::Clone(name), mojo::Clone(priority), mojo::Clone(enable_bidding_signals_prioritization),
        mojo::Clone(priority_vector), mojo::Clone(priority_signals_overrides), mojo::Clone(seller_capabilities), mojo::Clone(all_sellers_capabilities),
        mojo::Clone(execution_mode), mojo::Clone(trusted_bidding_signals_slot_size_mode), mojo::Clone(bidding_url), mojo::Clone(bidding_wasm_helper_url),
        mojo::Clone(update_url), mojo::Clone(trusted_bidding_signals_url), mojo::Clone(trusted_bidding_signals_keys),
        mojo::Clone(max_trusted_bidding_signals_url_length), mojo::Clone(trusted_bidding_signals_coordinator), mojo::Clone(user_bidding_signals),
        mojo::Clone(ads), mojo::Clone(ad_components), mojo::Clone(ad_sizes), mojo::Clone(size_groups), mojo::Clone(auction_server_request_flags),
        mojo::Clone(additional_bid_key), mojo::Clone(aggregation_coordinator_origin));
}

template <typename T, InterestGroup::EnableIfSame<T>*> bool InterestGroup::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->expiry, other_struct.expiry))
        return false;
    if (!mojo::Equals(this->owner, other_struct.owner))
        return false;
    if (!mojo::Equals(this->name, other_struct.name))
        return false;
    if (!mojo::Equals(this->priority, other_struct.priority))
        return false;
    if (!mojo::Equals(this->enable_bidding_signals_prioritization, other_struct.enable_bidding_signals_prioritization))
        return false;
    if (!mojo::Equals(this->priority_vector, other_struct.priority_vector))
        return false;
    if (!mojo::Equals(this->priority_signals_overrides, other_struct.priority_signals_overrides))
        return false;
    if (!mojo::Equals(this->seller_capabilities, other_struct.seller_capabilities))
        return false;
    if (!mojo::Equals(this->all_sellers_capabilities, other_struct.all_sellers_capabilities))
        return false;
    if (!mojo::Equals(this->execution_mode, other_struct.execution_mode))
        return false;
    if (!mojo::Equals(this->trusted_bidding_signals_slot_size_mode, other_struct.trusted_bidding_signals_slot_size_mode))
        return false;
    if (!mojo::Equals(this->bidding_url, other_struct.bidding_url))
        return false;
    if (!mojo::Equals(this->bidding_wasm_helper_url, other_struct.bidding_wasm_helper_url))
        return false;
    if (!mojo::Equals(this->update_url, other_struct.update_url))
        return false;
    if (!mojo::Equals(this->trusted_bidding_signals_url, other_struct.trusted_bidding_signals_url))
        return false;
    if (!mojo::Equals(this->trusted_bidding_signals_keys, other_struct.trusted_bidding_signals_keys))
        return false;
    if (!mojo::Equals(this->max_trusted_bidding_signals_url_length, other_struct.max_trusted_bidding_signals_url_length))
        return false;
    if (!mojo::Equals(this->trusted_bidding_signals_coordinator, other_struct.trusted_bidding_signals_coordinator))
        return false;
    if (!mojo::Equals(this->user_bidding_signals, other_struct.user_bidding_signals))
        return false;
    if (!mojo::Equals(this->ads, other_struct.ads))
        return false;
    if (!mojo::Equals(this->ad_components, other_struct.ad_components))
        return false;
    if (!mojo::Equals(this->ad_sizes, other_struct.ad_sizes))
        return false;
    if (!mojo::Equals(this->size_groups, other_struct.size_groups))
        return false;
    if (!mojo::Equals(this->auction_server_request_flags, other_struct.auction_server_request_flags))
        return false;
    if (!mojo::Equals(this->additional_bid_key, other_struct.additional_bid_key))
        return false;
    if (!mojo::Equals(this->aggregation_coordinator_origin, other_struct.aggregation_coordinator_origin))
        return false;
    return true;
}

template <typename T, InterestGroup::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.expiry < rhs.expiry)
        return true;
    if (rhs.expiry < lhs.expiry)
        return false;
    if (lhs.owner < rhs.owner)
        return true;
    if (rhs.owner < lhs.owner)
        return false;
    if (lhs.name < rhs.name)
        return true;
    if (rhs.name < lhs.name)
        return false;
    if (lhs.priority < rhs.priority)
        return true;
    if (rhs.priority < lhs.priority)
        return false;
    if (lhs.enable_bidding_signals_prioritization < rhs.enable_bidding_signals_prioritization)
        return true;
    if (rhs.enable_bidding_signals_prioritization < lhs.enable_bidding_signals_prioritization)
        return false;
    if (lhs.priority_vector < rhs.priority_vector)
        return true;
    if (rhs.priority_vector < lhs.priority_vector)
        return false;
    if (lhs.priority_signals_overrides < rhs.priority_signals_overrides)
        return true;
    if (rhs.priority_signals_overrides < lhs.priority_signals_overrides)
        return false;
    if (lhs.seller_capabilities < rhs.seller_capabilities)
        return true;
    if (rhs.seller_capabilities < lhs.seller_capabilities)
        return false;
    if (lhs.all_sellers_capabilities < rhs.all_sellers_capabilities)
        return true;
    if (rhs.all_sellers_capabilities < lhs.all_sellers_capabilities)
        return false;
    if (lhs.execution_mode < rhs.execution_mode)
        return true;
    if (rhs.execution_mode < lhs.execution_mode)
        return false;
    if (lhs.trusted_bidding_signals_slot_size_mode < rhs.trusted_bidding_signals_slot_size_mode)
        return true;
    if (rhs.trusted_bidding_signals_slot_size_mode < lhs.trusted_bidding_signals_slot_size_mode)
        return false;
    if (lhs.bidding_url < rhs.bidding_url)
        return true;
    if (rhs.bidding_url < lhs.bidding_url)
        return false;
    if (lhs.bidding_wasm_helper_url < rhs.bidding_wasm_helper_url)
        return true;
    if (rhs.bidding_wasm_helper_url < lhs.bidding_wasm_helper_url)
        return false;
    if (lhs.update_url < rhs.update_url)
        return true;
    if (rhs.update_url < lhs.update_url)
        return false;
    if (lhs.trusted_bidding_signals_url < rhs.trusted_bidding_signals_url)
        return true;
    if (rhs.trusted_bidding_signals_url < lhs.trusted_bidding_signals_url)
        return false;
    if (lhs.trusted_bidding_signals_keys < rhs.trusted_bidding_signals_keys)
        return true;
    if (rhs.trusted_bidding_signals_keys < lhs.trusted_bidding_signals_keys)
        return false;
    if (lhs.max_trusted_bidding_signals_url_length < rhs.max_trusted_bidding_signals_url_length)
        return true;
    if (rhs.max_trusted_bidding_signals_url_length < lhs.max_trusted_bidding_signals_url_length)
        return false;
    if (lhs.trusted_bidding_signals_coordinator < rhs.trusted_bidding_signals_coordinator)
        return true;
    if (rhs.trusted_bidding_signals_coordinator < lhs.trusted_bidding_signals_coordinator)
        return false;
    if (lhs.user_bidding_signals < rhs.user_bidding_signals)
        return true;
    if (rhs.user_bidding_signals < lhs.user_bidding_signals)
        return false;
    if (lhs.ads < rhs.ads)
        return true;
    if (rhs.ads < lhs.ads)
        return false;
    if (lhs.ad_components < rhs.ad_components)
        return true;
    if (rhs.ad_components < lhs.ad_components)
        return false;
    if (lhs.ad_sizes < rhs.ad_sizes)
        return true;
    if (rhs.ad_sizes < lhs.ad_sizes)
        return false;
    if (lhs.size_groups < rhs.size_groups)
        return true;
    if (rhs.size_groups < lhs.size_groups)
        return false;
    if (lhs.auction_server_request_flags < rhs.auction_server_request_flags)
        return true;
    if (rhs.auction_server_request_flags < lhs.auction_server_request_flags)
        return false;
    if (lhs.additional_bid_key < rhs.additional_bid_key)
        return true;
    if (rhs.additional_bid_key < lhs.additional_bid_key)
        return false;
    if (lhs.aggregation_coordinator_origin < rhs.aggregation_coordinator_origin)
        return true;
    if (rhs.aggregation_coordinator_origin < lhs.aggregation_coordinator_origin)
        return false;
    return false;
}
template <typename StructPtrType> PreviousWinPtr PreviousWin::Clone() const
{
    return New(mojo::Clone(time), mojo::Clone(ad_json));
}

template <typename T, PreviousWin::EnableIfSame<T>*> bool PreviousWin::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->time, other_struct.time))
        return false;
    if (!mojo::Equals(this->ad_json, other_struct.ad_json))
        return false;
    return true;
}

template <typename T, PreviousWin::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.time < rhs.time)
        return true;
    if (rhs.time < lhs.time)
        return false;
    if (lhs.ad_json < rhs.ad_json)
        return true;
    if (rhs.ad_json < lhs.ad_json)
        return false;
    return false;
}
template <typename StructPtrType> BiddingBrowserSignalsPtr BiddingBrowserSignals::Clone() const
{
    return New(mojo::Clone(join_count), mojo::Clone(bid_count), mojo::Clone(prev_wins), mojo::Clone(for_debugging_only_in_cooldown_or_lockout));
}

template <typename T, BiddingBrowserSignals::EnableIfSame<T>*> bool BiddingBrowserSignals::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->join_count, other_struct.join_count))
        return false;
    if (!mojo::Equals(this->bid_count, other_struct.bid_count))
        return false;
    if (!mojo::Equals(this->prev_wins, other_struct.prev_wins))
        return false;
    if (!mojo::Equals(this->for_debugging_only_in_cooldown_or_lockout, other_struct.for_debugging_only_in_cooldown_or_lockout))
        return false;
    return true;
}

template <typename T, BiddingBrowserSignals::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.join_count < rhs.join_count)
        return true;
    if (rhs.join_count < lhs.join_count)
        return false;
    if (lhs.bid_count < rhs.bid_count)
        return true;
    if (rhs.bid_count < lhs.bid_count)
        return false;
    if (lhs.prev_wins < rhs.prev_wins)
        return true;
    if (rhs.prev_wins < lhs.prev_wins)
        return false;
    if (lhs.for_debugging_only_in_cooldown_or_lockout < rhs.for_debugging_only_in_cooldown_or_lockout)
        return true;
    if (rhs.for_debugging_only_in_cooldown_or_lockout < lhs.for_debugging_only_in_cooldown_or_lockout)
        return false;
    return false;
}
template <typename StructPtrType> StorageInterestGroupPtr StorageInterestGroup::Clone() const
{
    return New(mojo::Clone(interest_group), mojo::Clone(bidding_browser_signals), mojo::Clone(joining_origin), mojo::Clone(join_time),
        mojo::Clone(last_updated), mojo::Clone(next_update_after), mojo::Clone(estimated_size));
}

template <typename T, StorageInterestGroup::EnableIfSame<T>*> bool StorageInterestGroup::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->interest_group, other_struct.interest_group))
        return false;
    if (!mojo::Equals(this->bidding_browser_signals, other_struct.bidding_browser_signals))
        return false;
    if (!mojo::Equals(this->joining_origin, other_struct.joining_origin))
        return false;
    if (!mojo::Equals(this->join_time, other_struct.join_time))
        return false;
    if (!mojo::Equals(this->last_updated, other_struct.last_updated))
        return false;
    if (!mojo::Equals(this->next_update_after, other_struct.next_update_after))
        return false;
    if (!mojo::Equals(this->estimated_size, other_struct.estimated_size))
        return false;
    return true;
}

template <typename T, StorageInterestGroup::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.interest_group < rhs.interest_group)
        return true;
    if (rhs.interest_group < lhs.interest_group)
        return false;
    if (lhs.bidding_browser_signals < rhs.bidding_browser_signals)
        return true;
    if (rhs.bidding_browser_signals < lhs.bidding_browser_signals)
        return false;
    if (lhs.joining_origin < rhs.joining_origin)
        return true;
    if (rhs.joining_origin < lhs.joining_origin)
        return false;
    if (lhs.join_time < rhs.join_time)
        return true;
    if (rhs.join_time < lhs.join_time)
        return false;
    if (lhs.last_updated < rhs.last_updated)
        return true;
    if (rhs.last_updated < lhs.last_updated)
        return false;
    if (lhs.next_update_after < rhs.next_update_after)
        return true;
    if (rhs.next_update_after < lhs.next_update_after)
        return false;
    if (lhs.estimated_size < rhs.estimated_size)
        return true;
    if (rhs.estimated_size < lhs.estimated_size)
        return false;
    return false;
}
template <typename StructPtrType> DirectFromSellerSignalsSubresourcePtr DirectFromSellerSignalsSubresource::Clone() const
{
    return New(mojo::Clone(bundle_url), mojo::Clone(token));
}

template <typename T, DirectFromSellerSignalsSubresource::EnableIfSame<T>*> bool DirectFromSellerSignalsSubresource::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->bundle_url, other_struct.bundle_url))
        return false;
    if (!mojo::Equals(this->token, other_struct.token))
        return false;
    return true;
}

template <typename T, DirectFromSellerSignalsSubresource::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.bundle_url < rhs.bundle_url)
        return true;
    if (rhs.bundle_url < lhs.bundle_url)
        return false;
    if (lhs.token < rhs.token)
        return true;
    if (rhs.token < lhs.token)
        return false;
    return false;
}
template <typename StructPtrType> DirectFromSellerSignalsPtr DirectFromSellerSignals::Clone() const
{
    return New(mojo::Clone(prefix), mojo::Clone(per_buyer_signals), mojo::Clone(seller_signals), mojo::Clone(auction_signals));
}

template <typename T, DirectFromSellerSignals::EnableIfSame<T>*> bool DirectFromSellerSignals::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->prefix, other_struct.prefix))
        return false;
    if (!mojo::Equals(this->per_buyer_signals, other_struct.per_buyer_signals))
        return false;
    if (!mojo::Equals(this->seller_signals, other_struct.seller_signals))
        return false;
    if (!mojo::Equals(this->auction_signals, other_struct.auction_signals))
        return false;
    return true;
}

template <typename T, DirectFromSellerSignals::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.prefix < rhs.prefix)
        return true;
    if (rhs.prefix < lhs.prefix)
        return false;
    if (lhs.per_buyer_signals < rhs.per_buyer_signals)
        return true;
    if (rhs.per_buyer_signals < lhs.per_buyer_signals)
        return false;
    if (lhs.seller_signals < rhs.seller_signals)
        return true;
    if (rhs.seller_signals < lhs.seller_signals)
        return false;
    if (lhs.auction_signals < rhs.auction_signals)
        return true;
    if (rhs.auction_signals < lhs.auction_signals)
        return false;
    return false;
}
template <typename StructPtrType> AuctionAdConfigBuyerTimeoutsPtr AuctionAdConfigBuyerTimeouts::Clone() const
{
    return New(mojo::Clone(all_buyers_timeout), mojo::Clone(per_buyer_timeouts));
}

template <typename T, AuctionAdConfigBuyerTimeouts::EnableIfSame<T>*> bool AuctionAdConfigBuyerTimeouts::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->all_buyers_timeout, other_struct.all_buyers_timeout))
        return false;
    if (!mojo::Equals(this->per_buyer_timeouts, other_struct.per_buyer_timeouts))
        return false;
    return true;
}

template <typename T, AuctionAdConfigBuyerTimeouts::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.all_buyers_timeout < rhs.all_buyers_timeout)
        return true;
    if (rhs.all_buyers_timeout < lhs.all_buyers_timeout)
        return false;
    if (lhs.per_buyer_timeouts < rhs.per_buyer_timeouts)
        return true;
    if (rhs.per_buyer_timeouts < lhs.per_buyer_timeouts)
        return false;
    return false;
}
template <typename StructPtrType> AdCurrencyPtr AdCurrency::Clone() const
{
    return New(mojo::Clone(currency_code));
}

template <typename T, AdCurrency::EnableIfSame<T>*> bool AdCurrency::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->currency_code, other_struct.currency_code))
        return false;
    return true;
}

template <typename T, AdCurrency::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.currency_code < rhs.currency_code)
        return true;
    if (rhs.currency_code < lhs.currency_code)
        return false;
    return false;
}
template <typename StructPtrType> AuctionAdConfigBuyerCurrenciesPtr AuctionAdConfigBuyerCurrencies::Clone() const
{
    return New(mojo::Clone(all_buyers_currency), mojo::Clone(per_buyer_currencies));
}

template <typename T, AuctionAdConfigBuyerCurrencies::EnableIfSame<T>*> bool AuctionAdConfigBuyerCurrencies::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->all_buyers_currency, other_struct.all_buyers_currency))
        return false;
    if (!mojo::Equals(this->per_buyer_currencies, other_struct.per_buyer_currencies))
        return false;
    return true;
}

template <typename T, AuctionAdConfigBuyerCurrencies::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.all_buyers_currency < rhs.all_buyers_currency)
        return true;
    if (rhs.all_buyers_currency < lhs.all_buyers_currency)
        return false;
    if (lhs.per_buyer_currencies < rhs.per_buyer_currencies)
        return true;
    if (rhs.per_buyer_currencies < lhs.per_buyer_currencies)
        return false;
    return false;
}
template <typename StructPtrType> AuctionAdServerResponseConfigPtr AuctionAdServerResponseConfig::Clone() const
{
    return New(mojo::Clone(request_id));
}

template <typename T, AuctionAdServerResponseConfig::EnableIfSame<T>*> bool AuctionAdServerResponseConfig::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->request_id, other_struct.request_id))
        return false;
    return true;
}

template <typename T, AuctionAdServerResponseConfig::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.request_id < rhs.request_id)
        return true;
    if (rhs.request_id < lhs.request_id)
        return false;
    return false;
}
template <typename StructPtrType> AuctionReportBuyerDebugModeConfigPtr AuctionReportBuyerDebugModeConfig::Clone() const
{
    return New(mojo::Clone(is_enabled), mojo::Clone(debug_key));
}

template <typename T, AuctionReportBuyerDebugModeConfig::EnableIfSame<T>*> bool AuctionReportBuyerDebugModeConfig::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->is_enabled, other_struct.is_enabled))
        return false;
    if (!mojo::Equals(this->debug_key, other_struct.debug_key))
        return false;
    return true;
}

template <typename T, AuctionReportBuyerDebugModeConfig::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.is_enabled < rhs.is_enabled)
        return true;
    if (rhs.is_enabled < lhs.is_enabled)
        return false;
    if (lhs.debug_key < rhs.debug_key)
        return true;
    if (rhs.debug_key < lhs.debug_key)
        return false;
    return false;
}
template <typename StructPtrType> AuctionReportBuyersConfigPtr AuctionReportBuyersConfig::Clone() const
{
    return New(mojo::Clone(bucket), mojo::Clone(scale));
}

template <typename T, AuctionReportBuyersConfig::EnableIfSame<T>*> bool AuctionReportBuyersConfig::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->bucket, other_struct.bucket))
        return false;
    if (!mojo::Equals(this->scale, other_struct.scale))
        return false;
    return true;
}

template <typename T, AuctionReportBuyersConfig::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.bucket < rhs.bucket)
        return true;
    if (rhs.bucket < lhs.bucket)
        return false;
    if (lhs.scale < rhs.scale)
        return true;
    if (rhs.scale < lhs.scale)
        return false;
    return false;
}
template <typename StructPtrType> AuctionAdConfigNonSharedParamsPtr AuctionAdConfigNonSharedParams::Clone() const
{
    return New(mojo::Clone(interest_group_buyers), mojo::Clone(auction_signals), mojo::Clone(seller_signals), mojo::Clone(seller_timeout),
        mojo::Clone(per_buyer_signals), mojo::Clone(buyer_timeouts), mojo::Clone(reporting_timeout), mojo::Clone(seller_currency),
        mojo::Clone(buyer_currencies), mojo::Clone(buyer_cumulative_timeouts), mojo::Clone(per_buyer_group_limits), mojo::Clone(per_buyer_priority_signals),
        mojo::Clone(all_buyers_priority_signals), mojo::Clone(all_buyers_group_limit), mojo::Clone(auction_report_buyer_keys),
        mojo::Clone(auction_report_buyers), mojo::Clone(auction_report_buyer_debug_mode_config), mojo::Clone(required_seller_capabilities),
        mojo::Clone(requested_size), mojo::Clone(all_slots_requested_sizes), mojo::Clone(per_buyer_multi_bid_limits), mojo::Clone(all_buyers_multi_bid_limit),
        mojo::Clone(auction_nonce), mojo::Clone(seller_real_time_reporting_type), mojo::Clone(per_buyer_real_time_reporting_types),
        mojo::Clone(component_auctions), mojo::Clone(deprecated_render_url_replacements), mojo::Clone(max_trusted_scoring_signals_url_length),
        mojo::Clone(trusted_scoring_signals_coordinator));
}

template <typename T, AuctionAdConfigNonSharedParams::EnableIfSame<T>*> bool AuctionAdConfigNonSharedParams::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->interest_group_buyers, other_struct.interest_group_buyers))
        return false;
    if (!mojo::Equals(this->auction_signals, other_struct.auction_signals))
        return false;
    if (!mojo::Equals(this->seller_signals, other_struct.seller_signals))
        return false;
    if (!mojo::Equals(this->seller_timeout, other_struct.seller_timeout))
        return false;
    if (!mojo::Equals(this->per_buyer_signals, other_struct.per_buyer_signals))
        return false;
    if (!mojo::Equals(this->buyer_timeouts, other_struct.buyer_timeouts))
        return false;
    if (!mojo::Equals(this->reporting_timeout, other_struct.reporting_timeout))
        return false;
    if (!mojo::Equals(this->seller_currency, other_struct.seller_currency))
        return false;
    if (!mojo::Equals(this->buyer_currencies, other_struct.buyer_currencies))
        return false;
    if (!mojo::Equals(this->buyer_cumulative_timeouts, other_struct.buyer_cumulative_timeouts))
        return false;
    if (!mojo::Equals(this->per_buyer_group_limits, other_struct.per_buyer_group_limits))
        return false;
    if (!mojo::Equals(this->per_buyer_priority_signals, other_struct.per_buyer_priority_signals))
        return false;
    if (!mojo::Equals(this->all_buyers_priority_signals, other_struct.all_buyers_priority_signals))
        return false;
    if (!mojo::Equals(this->all_buyers_group_limit, other_struct.all_buyers_group_limit))
        return false;
    if (!mojo::Equals(this->auction_report_buyer_keys, other_struct.auction_report_buyer_keys))
        return false;
    if (!mojo::Equals(this->auction_report_buyers, other_struct.auction_report_buyers))
        return false;
    if (!mojo::Equals(this->auction_report_buyer_debug_mode_config, other_struct.auction_report_buyer_debug_mode_config))
        return false;
    if (!mojo::Equals(this->required_seller_capabilities, other_struct.required_seller_capabilities))
        return false;
    if (!mojo::Equals(this->requested_size, other_struct.requested_size))
        return false;
    if (!mojo::Equals(this->all_slots_requested_sizes, other_struct.all_slots_requested_sizes))
        return false;
    if (!mojo::Equals(this->per_buyer_multi_bid_limits, other_struct.per_buyer_multi_bid_limits))
        return false;
    if (!mojo::Equals(this->all_buyers_multi_bid_limit, other_struct.all_buyers_multi_bid_limit))
        return false;
    if (!mojo::Equals(this->auction_nonce, other_struct.auction_nonce))
        return false;
    if (!mojo::Equals(this->seller_real_time_reporting_type, other_struct.seller_real_time_reporting_type))
        return false;
    if (!mojo::Equals(this->per_buyer_real_time_reporting_types, other_struct.per_buyer_real_time_reporting_types))
        return false;
    if (!mojo::Equals(this->component_auctions, other_struct.component_auctions))
        return false;
    if (!mojo::Equals(this->deprecated_render_url_replacements, other_struct.deprecated_render_url_replacements))
        return false;
    if (!mojo::Equals(this->max_trusted_scoring_signals_url_length, other_struct.max_trusted_scoring_signals_url_length))
        return false;
    if (!mojo::Equals(this->trusted_scoring_signals_coordinator, other_struct.trusted_scoring_signals_coordinator))
        return false;
    return true;
}

template <typename T, AuctionAdConfigNonSharedParams::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.interest_group_buyers < rhs.interest_group_buyers)
        return true;
    if (rhs.interest_group_buyers < lhs.interest_group_buyers)
        return false;
    if (lhs.auction_signals < rhs.auction_signals)
        return true;
    if (rhs.auction_signals < lhs.auction_signals)
        return false;
    if (lhs.seller_signals < rhs.seller_signals)
        return true;
    if (rhs.seller_signals < lhs.seller_signals)
        return false;
    if (lhs.seller_timeout < rhs.seller_timeout)
        return true;
    if (rhs.seller_timeout < lhs.seller_timeout)
        return false;
    if (lhs.per_buyer_signals < rhs.per_buyer_signals)
        return true;
    if (rhs.per_buyer_signals < lhs.per_buyer_signals)
        return false;
    if (lhs.buyer_timeouts < rhs.buyer_timeouts)
        return true;
    if (rhs.buyer_timeouts < lhs.buyer_timeouts)
        return false;
    if (lhs.reporting_timeout < rhs.reporting_timeout)
        return true;
    if (rhs.reporting_timeout < lhs.reporting_timeout)
        return false;
    if (lhs.seller_currency < rhs.seller_currency)
        return true;
    if (rhs.seller_currency < lhs.seller_currency)
        return false;
    if (lhs.buyer_currencies < rhs.buyer_currencies)
        return true;
    if (rhs.buyer_currencies < lhs.buyer_currencies)
        return false;
    if (lhs.buyer_cumulative_timeouts < rhs.buyer_cumulative_timeouts)
        return true;
    if (rhs.buyer_cumulative_timeouts < lhs.buyer_cumulative_timeouts)
        return false;
    if (lhs.per_buyer_group_limits < rhs.per_buyer_group_limits)
        return true;
    if (rhs.per_buyer_group_limits < lhs.per_buyer_group_limits)
        return false;
    if (lhs.per_buyer_priority_signals < rhs.per_buyer_priority_signals)
        return true;
    if (rhs.per_buyer_priority_signals < lhs.per_buyer_priority_signals)
        return false;
    if (lhs.all_buyers_priority_signals < rhs.all_buyers_priority_signals)
        return true;
    if (rhs.all_buyers_priority_signals < lhs.all_buyers_priority_signals)
        return false;
    if (lhs.all_buyers_group_limit < rhs.all_buyers_group_limit)
        return true;
    if (rhs.all_buyers_group_limit < lhs.all_buyers_group_limit)
        return false;
    if (lhs.auction_report_buyer_keys < rhs.auction_report_buyer_keys)
        return true;
    if (rhs.auction_report_buyer_keys < lhs.auction_report_buyer_keys)
        return false;
    if (lhs.auction_report_buyers < rhs.auction_report_buyers)
        return true;
    if (rhs.auction_report_buyers < lhs.auction_report_buyers)
        return false;
    if (lhs.auction_report_buyer_debug_mode_config < rhs.auction_report_buyer_debug_mode_config)
        return true;
    if (rhs.auction_report_buyer_debug_mode_config < lhs.auction_report_buyer_debug_mode_config)
        return false;
    if (lhs.required_seller_capabilities < rhs.required_seller_capabilities)
        return true;
    if (rhs.required_seller_capabilities < lhs.required_seller_capabilities)
        return false;
    if (lhs.requested_size < rhs.requested_size)
        return true;
    if (rhs.requested_size < lhs.requested_size)
        return false;
    if (lhs.all_slots_requested_sizes < rhs.all_slots_requested_sizes)
        return true;
    if (rhs.all_slots_requested_sizes < lhs.all_slots_requested_sizes)
        return false;
    if (lhs.per_buyer_multi_bid_limits < rhs.per_buyer_multi_bid_limits)
        return true;
    if (rhs.per_buyer_multi_bid_limits < lhs.per_buyer_multi_bid_limits)
        return false;
    if (lhs.all_buyers_multi_bid_limit < rhs.all_buyers_multi_bid_limit)
        return true;
    if (rhs.all_buyers_multi_bid_limit < lhs.all_buyers_multi_bid_limit)
        return false;
    if (lhs.auction_nonce < rhs.auction_nonce)
        return true;
    if (rhs.auction_nonce < lhs.auction_nonce)
        return false;
    if (lhs.seller_real_time_reporting_type < rhs.seller_real_time_reporting_type)
        return true;
    if (rhs.seller_real_time_reporting_type < lhs.seller_real_time_reporting_type)
        return false;
    if (lhs.per_buyer_real_time_reporting_types < rhs.per_buyer_real_time_reporting_types)
        return true;
    if (rhs.per_buyer_real_time_reporting_types < lhs.per_buyer_real_time_reporting_types)
        return false;
    if (lhs.component_auctions < rhs.component_auctions)
        return true;
    if (rhs.component_auctions < lhs.component_auctions)
        return false;
    if (lhs.deprecated_render_url_replacements < rhs.deprecated_render_url_replacements)
        return true;
    if (rhs.deprecated_render_url_replacements < lhs.deprecated_render_url_replacements)
        return false;
    if (lhs.max_trusted_scoring_signals_url_length < rhs.max_trusted_scoring_signals_url_length)
        return true;
    if (rhs.max_trusted_scoring_signals_url_length < lhs.max_trusted_scoring_signals_url_length)
        return false;
    if (lhs.trusted_scoring_signals_coordinator < rhs.trusted_scoring_signals_coordinator)
        return true;
    if (rhs.trusted_scoring_signals_coordinator < lhs.trusted_scoring_signals_coordinator)
        return false;
    return false;
}
template <typename StructPtrType> AuctionAdConfigPtr AuctionAdConfig::Clone() const
{
    return New(mojo::Clone(seller), mojo::Clone(server_response), mojo::Clone(decision_logic_url), mojo::Clone(trusted_scoring_signals_url),
        mojo::Clone(auction_ad_config_non_shared_params), mojo::Clone(direct_from_seller_signals),
        mojo::Clone(expects_direct_from_seller_signals_header_ad_slot), mojo::Clone(seller_experiment_group_id), mojo::Clone(all_buyer_experiment_group_id),
        mojo::Clone(per_buyer_experiment_group_ids), mojo::Clone(expects_additional_bids), mojo::Clone(aggregation_coordinator_origin));
}

template <typename T, AuctionAdConfig::EnableIfSame<T>*> bool AuctionAdConfig::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->seller, other_struct.seller))
        return false;
    if (!mojo::Equals(this->server_response, other_struct.server_response))
        return false;
    if (!mojo::Equals(this->decision_logic_url, other_struct.decision_logic_url))
        return false;
    if (!mojo::Equals(this->trusted_scoring_signals_url, other_struct.trusted_scoring_signals_url))
        return false;
    if (!mojo::Equals(this->auction_ad_config_non_shared_params, other_struct.auction_ad_config_non_shared_params))
        return false;
    if (!mojo::Equals(this->direct_from_seller_signals, other_struct.direct_from_seller_signals))
        return false;
    if (!mojo::Equals(this->expects_direct_from_seller_signals_header_ad_slot, other_struct.expects_direct_from_seller_signals_header_ad_slot))
        return false;
    if (!mojo::Equals(this->seller_experiment_group_id, other_struct.seller_experiment_group_id))
        return false;
    if (!mojo::Equals(this->all_buyer_experiment_group_id, other_struct.all_buyer_experiment_group_id))
        return false;
    if (!mojo::Equals(this->per_buyer_experiment_group_ids, other_struct.per_buyer_experiment_group_ids))
        return false;
    if (!mojo::Equals(this->expects_additional_bids, other_struct.expects_additional_bids))
        return false;
    if (!mojo::Equals(this->aggregation_coordinator_origin, other_struct.aggregation_coordinator_origin))
        return false;
    return true;
}

template <typename T, AuctionAdConfig::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.seller < rhs.seller)
        return true;
    if (rhs.seller < lhs.seller)
        return false;
    if (lhs.server_response < rhs.server_response)
        return true;
    if (rhs.server_response < lhs.server_response)
        return false;
    if (lhs.decision_logic_url < rhs.decision_logic_url)
        return true;
    if (rhs.decision_logic_url < lhs.decision_logic_url)
        return false;
    if (lhs.trusted_scoring_signals_url < rhs.trusted_scoring_signals_url)
        return true;
    if (rhs.trusted_scoring_signals_url < lhs.trusted_scoring_signals_url)
        return false;
    if (lhs.auction_ad_config_non_shared_params < rhs.auction_ad_config_non_shared_params)
        return true;
    if (rhs.auction_ad_config_non_shared_params < lhs.auction_ad_config_non_shared_params)
        return false;
    if (lhs.direct_from_seller_signals < rhs.direct_from_seller_signals)
        return true;
    if (rhs.direct_from_seller_signals < lhs.direct_from_seller_signals)
        return false;
    if (lhs.expects_direct_from_seller_signals_header_ad_slot < rhs.expects_direct_from_seller_signals_header_ad_slot)
        return true;
    if (rhs.expects_direct_from_seller_signals_header_ad_slot < lhs.expects_direct_from_seller_signals_header_ad_slot)
        return false;
    if (lhs.seller_experiment_group_id < rhs.seller_experiment_group_id)
        return true;
    if (rhs.seller_experiment_group_id < lhs.seller_experiment_group_id)
        return false;
    if (lhs.all_buyer_experiment_group_id < rhs.all_buyer_experiment_group_id)
        return true;
    if (rhs.all_buyer_experiment_group_id < lhs.all_buyer_experiment_group_id)
        return false;
    if (lhs.per_buyer_experiment_group_ids < rhs.per_buyer_experiment_group_ids)
        return true;
    if (rhs.per_buyer_experiment_group_ids < lhs.per_buyer_experiment_group_ids)
        return false;
    if (lhs.expects_additional_bids < rhs.expects_additional_bids)
        return true;
    if (rhs.expects_additional_bids < lhs.expects_additional_bids)
        return false;
    if (lhs.aggregation_coordinator_origin < rhs.aggregation_coordinator_origin)
        return true;
    if (rhs.aggregation_coordinator_origin < lhs.aggregation_coordinator_origin)
        return false;
    return false;
}
template <typename StructPtrType> AuctionDataBuyerConfigPtr AuctionDataBuyerConfig::Clone() const
{
    return New(mojo::Clone(target_size));
}

template <typename T, AuctionDataBuyerConfig::EnableIfSame<T>*> bool AuctionDataBuyerConfig::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->target_size, other_struct.target_size))
        return false;
    return true;
}

template <typename T, AuctionDataBuyerConfig::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.target_size < rhs.target_size)
        return true;
    if (rhs.target_size < lhs.target_size)
        return false;
    return false;
}
template <typename StructPtrType> AuctionDataConfigPtr AuctionDataConfig::Clone() const
{
    return New(mojo::Clone(per_buyer_configs), mojo::Clone(request_size));
}

template <typename T, AuctionDataConfig::EnableIfSame<T>*> bool AuctionDataConfig::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->per_buyer_configs, other_struct.per_buyer_configs))
        return false;
    if (!mojo::Equals(this->request_size, other_struct.request_size))
        return false;
    return true;
}

template <typename T, AuctionDataConfig::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.per_buyer_configs < rhs.per_buyer_configs)
        return true;
    if (rhs.per_buyer_configs < lhs.per_buyer_configs)
        return false;
    if (lhs.request_size < rhs.request_size)
        return true;
    if (rhs.request_size < lhs.request_size)
        return false;
    return false;
}

} // blink::mojom

namespace mojo {

template <> struct BLINK_COMMON_EXPORT StructTraits<::blink::mojom::InterestGroupAd::DataView, ::blink::mojom::InterestGroupAdPtr> {
    static bool IsNull(const ::blink::mojom::InterestGroupAdPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::InterestGroupAdPtr* output)
    {
        output->reset();
    }

    static const decltype(::blink::mojom::InterestGroupAd::render_url)& render_url(const ::blink::mojom::InterestGroupAdPtr& input)
    {
        return input->render_url;
    }

    static const decltype(::blink::mojom::InterestGroupAd::size_group)& size_group(const ::blink::mojom::InterestGroupAdPtr& input)
    {
        return input->size_group;
    }

    static const decltype(::blink::mojom::InterestGroupAd::buyer_reporting_id)& buyer_reporting_id(const ::blink::mojom::InterestGroupAdPtr& input)
    {
        return input->buyer_reporting_id;
    }

    static const decltype(::blink::mojom::InterestGroupAd::buyer_and_seller_reporting_id)& buyer_and_seller_reporting_id(
        const ::blink::mojom::InterestGroupAdPtr& input)
    {
        return input->buyer_and_seller_reporting_id;
    }

    static const decltype(::blink::mojom::InterestGroupAd::selectable_buyer_and_seller_reporting_ids)& selectable_buyer_and_seller_reporting_ids(
        const ::blink::mojom::InterestGroupAdPtr& input)
    {
        return input->selectable_buyer_and_seller_reporting_ids;
    }

    static const decltype(::blink::mojom::InterestGroupAd::metadata)& metadata(const ::blink::mojom::InterestGroupAdPtr& input)
    {
        return input->metadata;
    }

    static const decltype(::blink::mojom::InterestGroupAd::ad_render_id)& ad_render_id(const ::blink::mojom::InterestGroupAdPtr& input)
    {
        return input->ad_render_id;
    }

    static const decltype(::blink::mojom::InterestGroupAd::allowed_reporting_origins)& allowed_reporting_origins(
        const ::blink::mojom::InterestGroupAdPtr& input)
    {
        return input->allowed_reporting_origins;
    }

    static bool Read(::blink::mojom::InterestGroupAd::DataView input, ::blink::mojom::InterestGroupAdPtr* output);
};

template <> struct BLINK_COMMON_EXPORT StructTraits<::blink::mojom::SellerCapabilities::DataView, ::blink::mojom::SellerCapabilitiesPtr> {
    static bool IsNull(const ::blink::mojom::SellerCapabilitiesPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::SellerCapabilitiesPtr* output)
    {
        output->reset();
    }

    static decltype(::blink::mojom::SellerCapabilities::allows_interest_group_counts) allows_interest_group_counts(
        const ::blink::mojom::SellerCapabilitiesPtr& input)
    {
        return input->allows_interest_group_counts;
    }

    static decltype(::blink::mojom::SellerCapabilities::allows_latency_stats) allows_latency_stats(const ::blink::mojom::SellerCapabilitiesPtr& input)
    {
        return input->allows_latency_stats;
    }

    static bool Read(::blink::mojom::SellerCapabilities::DataView input, ::blink::mojom::SellerCapabilitiesPtr* output);
};

template <> struct BLINK_COMMON_EXPORT StructTraits<::blink::mojom::AuctionServerRequestFlags::DataView, ::blink::mojom::AuctionServerRequestFlagsPtr> {
    static bool IsNull(const ::blink::mojom::AuctionServerRequestFlagsPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::AuctionServerRequestFlagsPtr* output)
    {
        output->reset();
    }

    static decltype(::blink::mojom::AuctionServerRequestFlags::omit_ads) omit_ads(const ::blink::mojom::AuctionServerRequestFlagsPtr& input)
    {
        return input->omit_ads;
    }

    static decltype(::blink::mojom::AuctionServerRequestFlags::include_full_ads) include_full_ads(const ::blink::mojom::AuctionServerRequestFlagsPtr& input)
    {
        return input->include_full_ads;
    }

    static decltype(::blink::mojom::AuctionServerRequestFlags::omit_user_bidding_signals) omit_user_bidding_signals(
        const ::blink::mojom::AuctionServerRequestFlagsPtr& input)
    {
        return input->omit_user_bidding_signals;
    }

    static bool Read(::blink::mojom::AuctionServerRequestFlags::DataView input, ::blink::mojom::AuctionServerRequestFlagsPtr* output);
};

template <> struct BLINK_COMMON_EXPORT StructTraits<::blink::mojom::AdKeywordReplacement::DataView, ::blink::mojom::AdKeywordReplacementPtr> {
    static bool IsNull(const ::blink::mojom::AdKeywordReplacementPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::AdKeywordReplacementPtr* output)
    {
        output->reset();
    }

    static const decltype(::blink::mojom::AdKeywordReplacement::match)& match(const ::blink::mojom::AdKeywordReplacementPtr& input)
    {
        return input->match;
    }

    static const decltype(::blink::mojom::AdKeywordReplacement::replacement)& replacement(const ::blink::mojom::AdKeywordReplacementPtr& input)
    {
        return input->replacement;
    }

    static bool Read(::blink::mojom::AdKeywordReplacement::DataView input, ::blink::mojom::AdKeywordReplacementPtr* output);
};

template <> struct BLINK_COMMON_EXPORT StructTraits<::blink::mojom::InterestGroup::DataView, ::blink::mojom::InterestGroupPtr> {
    static bool IsNull(const ::blink::mojom::InterestGroupPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::InterestGroupPtr* output)
    {
        output->reset();
    }

    static const decltype(::blink::mojom::InterestGroup::expiry)& expiry(const ::blink::mojom::InterestGroupPtr& input)
    {
        return input->expiry;
    }

    static const decltype(::blink::mojom::InterestGroup::owner)& owner(const ::blink::mojom::InterestGroupPtr& input)
    {
        return input->owner;
    }

    static const decltype(::blink::mojom::InterestGroup::name)& name(const ::blink::mojom::InterestGroupPtr& input)
    {
        return input->name;
    }

    static decltype(::blink::mojom::InterestGroup::priority) priority(const ::blink::mojom::InterestGroupPtr& input)
    {
        return input->priority;
    }

    static decltype(::blink::mojom::InterestGroup::enable_bidding_signals_prioritization) enable_bidding_signals_prioritization(
        const ::blink::mojom::InterestGroupPtr& input)
    {
        return input->enable_bidding_signals_prioritization;
    }

    static const decltype(::blink::mojom::InterestGroup::priority_vector)& priority_vector(const ::blink::mojom::InterestGroupPtr& input)
    {
        return input->priority_vector;
    }

    static const decltype(::blink::mojom::InterestGroup::priority_signals_overrides)& priority_signals_overrides(const ::blink::mojom::InterestGroupPtr& input)
    {
        return input->priority_signals_overrides;
    }

    static const decltype(::blink::mojom::InterestGroup::seller_capabilities)& seller_capabilities(const ::blink::mojom::InterestGroupPtr& input)
    {
        return input->seller_capabilities;
    }

    static const decltype(::blink::mojom::InterestGroup::all_sellers_capabilities)& all_sellers_capabilities(const ::blink::mojom::InterestGroupPtr& input)
    {
        return input->all_sellers_capabilities;
    }

    static decltype(::blink::mojom::InterestGroup::execution_mode) execution_mode(const ::blink::mojom::InterestGroupPtr& input)
    {
        return input->execution_mode;
    }

    static decltype(::blink::mojom::InterestGroup::trusted_bidding_signals_slot_size_mode) trusted_bidding_signals_slot_size_mode(
        const ::blink::mojom::InterestGroupPtr& input)
    {
        return input->trusted_bidding_signals_slot_size_mode;
    }

    static const decltype(::blink::mojom::InterestGroup::bidding_url)& bidding_url(const ::blink::mojom::InterestGroupPtr& input)
    {
        return input->bidding_url;
    }

    static const decltype(::blink::mojom::InterestGroup::bidding_wasm_helper_url)& bidding_wasm_helper_url(const ::blink::mojom::InterestGroupPtr& input)
    {
        return input->bidding_wasm_helper_url;
    }

    static const decltype(::blink::mojom::InterestGroup::update_url)& update_url(const ::blink::mojom::InterestGroupPtr& input)
    {
        return input->update_url;
    }

    static const decltype(::blink::mojom::InterestGroup::trusted_bidding_signals_url)& trusted_bidding_signals_url(
        const ::blink::mojom::InterestGroupPtr& input)
    {
        return input->trusted_bidding_signals_url;
    }

    static const decltype(::blink::mojom::InterestGroup::trusted_bidding_signals_keys)& trusted_bidding_signals_keys(
        const ::blink::mojom::InterestGroupPtr& input)
    {
        return input->trusted_bidding_signals_keys;
    }

    static decltype(::blink::mojom::InterestGroup::max_trusted_bidding_signals_url_length) max_trusted_bidding_signals_url_length(
        const ::blink::mojom::InterestGroupPtr& input)
    {
        return input->max_trusted_bidding_signals_url_length;
    }

    static const decltype(::blink::mojom::InterestGroup::trusted_bidding_signals_coordinator)& trusted_bidding_signals_coordinator(
        const ::blink::mojom::InterestGroupPtr& input)
    {
        return input->trusted_bidding_signals_coordinator;
    }

    static const decltype(::blink::mojom::InterestGroup::user_bidding_signals)& user_bidding_signals(const ::blink::mojom::InterestGroupPtr& input)
    {
        return input->user_bidding_signals;
    }

    static const decltype(::blink::mojom::InterestGroup::ads)& ads(const ::blink::mojom::InterestGroupPtr& input)
    {
        return input->ads;
    }

    static const decltype(::blink::mojom::InterestGroup::ad_components)& ad_components(const ::blink::mojom::InterestGroupPtr& input)
    {
        return input->ad_components;
    }

    static const decltype(::blink::mojom::InterestGroup::ad_sizes)& ad_sizes(const ::blink::mojom::InterestGroupPtr& input)
    {
        return input->ad_sizes;
    }

    static const decltype(::blink::mojom::InterestGroup::size_groups)& size_groups(const ::blink::mojom::InterestGroupPtr& input)
    {
        return input->size_groups;
    }

    static const decltype(::blink::mojom::InterestGroup::auction_server_request_flags)& auction_server_request_flags(
        const ::blink::mojom::InterestGroupPtr& input)
    {
        return input->auction_server_request_flags;
    }

    static const decltype(::blink::mojom::InterestGroup::additional_bid_key)& additional_bid_key(const ::blink::mojom::InterestGroupPtr& input)
    {
        return input->additional_bid_key;
    }

    static const decltype(::blink::mojom::InterestGroup::aggregation_coordinator_origin)& aggregation_coordinator_origin(
        const ::blink::mojom::InterestGroupPtr& input)
    {
        return input->aggregation_coordinator_origin;
    }

    static bool Read(::blink::mojom::InterestGroup::DataView input, ::blink::mojom::InterestGroupPtr* output);
};

template <> struct BLINK_COMMON_EXPORT StructTraits<::blink::mojom::PreviousWin::DataView, ::blink::mojom::PreviousWinPtr> {
    static bool IsNull(const ::blink::mojom::PreviousWinPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::PreviousWinPtr* output)
    {
        output->reset();
    }

    static const decltype(::blink::mojom::PreviousWin::time)& time(const ::blink::mojom::PreviousWinPtr& input)
    {
        return input->time;
    }

    static const decltype(::blink::mojom::PreviousWin::ad_json)& ad_json(const ::blink::mojom::PreviousWinPtr& input)
    {
        return input->ad_json;
    }

    static bool Read(::blink::mojom::PreviousWin::DataView input, ::blink::mojom::PreviousWinPtr* output);
};

template <> struct BLINK_COMMON_EXPORT StructTraits<::blink::mojom::BiddingBrowserSignals::DataView, ::blink::mojom::BiddingBrowserSignalsPtr> {
    static bool IsNull(const ::blink::mojom::BiddingBrowserSignalsPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::BiddingBrowserSignalsPtr* output)
    {
        output->reset();
    }

    static decltype(::blink::mojom::BiddingBrowserSignals::join_count) join_count(const ::blink::mojom::BiddingBrowserSignalsPtr& input)
    {
        return input->join_count;
    }

    static decltype(::blink::mojom::BiddingBrowserSignals::bid_count) bid_count(const ::blink::mojom::BiddingBrowserSignalsPtr& input)
    {
        return input->bid_count;
    }

    static const decltype(::blink::mojom::BiddingBrowserSignals::prev_wins)& prev_wins(const ::blink::mojom::BiddingBrowserSignalsPtr& input)
    {
        return input->prev_wins;
    }

    static decltype(::blink::mojom::BiddingBrowserSignals::for_debugging_only_in_cooldown_or_lockout) for_debugging_only_in_cooldown_or_lockout(
        const ::blink::mojom::BiddingBrowserSignalsPtr& input)
    {
        return input->for_debugging_only_in_cooldown_or_lockout;
    }

    static bool Read(::blink::mojom::BiddingBrowserSignals::DataView input, ::blink::mojom::BiddingBrowserSignalsPtr* output);
};

template <> struct BLINK_COMMON_EXPORT StructTraits<::blink::mojom::StorageInterestGroup::DataView, ::blink::mojom::StorageInterestGroupPtr> {
    static bool IsNull(const ::blink::mojom::StorageInterestGroupPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::StorageInterestGroupPtr* output)
    {
        output->reset();
    }

    static const decltype(::blink::mojom::StorageInterestGroup::interest_group)& interest_group(const ::blink::mojom::StorageInterestGroupPtr& input)
    {
        return input->interest_group;
    }

    static const decltype(::blink::mojom::StorageInterestGroup::bidding_browser_signals)& bidding_browser_signals(
        const ::blink::mojom::StorageInterestGroupPtr& input)
    {
        return input->bidding_browser_signals;
    }

    static const decltype(::blink::mojom::StorageInterestGroup::joining_origin)& joining_origin(const ::blink::mojom::StorageInterestGroupPtr& input)
    {
        return input->joining_origin;
    }

    static const decltype(::blink::mojom::StorageInterestGroup::join_time)& join_time(const ::blink::mojom::StorageInterestGroupPtr& input)
    {
        return input->join_time;
    }

    static const decltype(::blink::mojom::StorageInterestGroup::last_updated)& last_updated(const ::blink::mojom::StorageInterestGroupPtr& input)
    {
        return input->last_updated;
    }

    static const decltype(::blink::mojom::StorageInterestGroup::next_update_after)& next_update_after(const ::blink::mojom::StorageInterestGroupPtr& input)
    {
        return input->next_update_after;
    }

    static decltype(::blink::mojom::StorageInterestGroup::estimated_size) estimated_size(const ::blink::mojom::StorageInterestGroupPtr& input)
    {
        return input->estimated_size;
    }

    static bool Read(::blink::mojom::StorageInterestGroup::DataView input, ::blink::mojom::StorageInterestGroupPtr* output);
};

template <>
struct BLINK_COMMON_EXPORT StructTraits<::blink::mojom::DirectFromSellerSignalsSubresource::DataView, ::blink::mojom::DirectFromSellerSignalsSubresourcePtr> {
    static bool IsNull(const ::blink::mojom::DirectFromSellerSignalsSubresourcePtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::DirectFromSellerSignalsSubresourcePtr* output)
    {
        output->reset();
    }

    static const decltype(::blink::mojom::DirectFromSellerSignalsSubresource::bundle_url)& bundle_url(
        const ::blink::mojom::DirectFromSellerSignalsSubresourcePtr& input)
    {
        return input->bundle_url;
    }

    static const decltype(::blink::mojom::DirectFromSellerSignalsSubresource::token)& token(const ::blink::mojom::DirectFromSellerSignalsSubresourcePtr& input)
    {
        return input->token;
    }

    static bool Read(::blink::mojom::DirectFromSellerSignalsSubresource::DataView input, ::blink::mojom::DirectFromSellerSignalsSubresourcePtr* output);
};

template <> struct BLINK_COMMON_EXPORT StructTraits<::blink::mojom::DirectFromSellerSignals::DataView, ::blink::mojom::DirectFromSellerSignalsPtr> {
    static bool IsNull(const ::blink::mojom::DirectFromSellerSignalsPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::DirectFromSellerSignalsPtr* output)
    {
        output->reset();
    }

    static const decltype(::blink::mojom::DirectFromSellerSignals::prefix)& prefix(const ::blink::mojom::DirectFromSellerSignalsPtr& input)
    {
        return input->prefix;
    }

    static const decltype(::blink::mojom::DirectFromSellerSignals::per_buyer_signals)& per_buyer_signals(
        const ::blink::mojom::DirectFromSellerSignalsPtr& input)
    {
        return input->per_buyer_signals;
    }

    static const decltype(::blink::mojom::DirectFromSellerSignals::seller_signals)& seller_signals(const ::blink::mojom::DirectFromSellerSignalsPtr& input)
    {
        return input->seller_signals;
    }

    static const decltype(::blink::mojom::DirectFromSellerSignals::auction_signals)& auction_signals(const ::blink::mojom::DirectFromSellerSignalsPtr& input)
    {
        return input->auction_signals;
    }

    static bool Read(::blink::mojom::DirectFromSellerSignals::DataView input, ::blink::mojom::DirectFromSellerSignalsPtr* output);
};

template <> struct BLINK_COMMON_EXPORT StructTraits<::blink::mojom::AuctionAdConfigBuyerTimeouts::DataView, ::blink::mojom::AuctionAdConfigBuyerTimeoutsPtr> {
    static bool IsNull(const ::blink::mojom::AuctionAdConfigBuyerTimeoutsPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::AuctionAdConfigBuyerTimeoutsPtr* output)
    {
        output->reset();
    }

    static const decltype(::blink::mojom::AuctionAdConfigBuyerTimeouts::all_buyers_timeout)& all_buyers_timeout(
        const ::blink::mojom::AuctionAdConfigBuyerTimeoutsPtr& input)
    {
        return input->all_buyers_timeout;
    }

    static const decltype(::blink::mojom::AuctionAdConfigBuyerTimeouts::per_buyer_timeouts)& per_buyer_timeouts(
        const ::blink::mojom::AuctionAdConfigBuyerTimeoutsPtr& input)
    {
        return input->per_buyer_timeouts;
    }

    static bool Read(::blink::mojom::AuctionAdConfigBuyerTimeouts::DataView input, ::blink::mojom::AuctionAdConfigBuyerTimeoutsPtr* output);
};

template <> struct BLINK_COMMON_EXPORT StructTraits<::blink::mojom::AdCurrency::DataView, ::blink::mojom::AdCurrencyPtr> {
    static bool IsNull(const ::blink::mojom::AdCurrencyPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::AdCurrencyPtr* output)
    {
        output->reset();
    }

    static const decltype(::blink::mojom::AdCurrency::currency_code)& currency_code(const ::blink::mojom::AdCurrencyPtr& input)
    {
        return input->currency_code;
    }

    static bool Read(::blink::mojom::AdCurrency::DataView input, ::blink::mojom::AdCurrencyPtr* output);
};

template <>
struct BLINK_COMMON_EXPORT StructTraits<::blink::mojom::AuctionAdConfigBuyerCurrencies::DataView, ::blink::mojom::AuctionAdConfigBuyerCurrenciesPtr> {
    static bool IsNull(const ::blink::mojom::AuctionAdConfigBuyerCurrenciesPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::AuctionAdConfigBuyerCurrenciesPtr* output)
    {
        output->reset();
    }

    static const decltype(::blink::mojom::AuctionAdConfigBuyerCurrencies::all_buyers_currency)& all_buyers_currency(
        const ::blink::mojom::AuctionAdConfigBuyerCurrenciesPtr& input)
    {
        return input->all_buyers_currency;
    }

    static const decltype(::blink::mojom::AuctionAdConfigBuyerCurrencies::per_buyer_currencies)& per_buyer_currencies(
        const ::blink::mojom::AuctionAdConfigBuyerCurrenciesPtr& input)
    {
        return input->per_buyer_currencies;
    }

    static bool Read(::blink::mojom::AuctionAdConfigBuyerCurrencies::DataView input, ::blink::mojom::AuctionAdConfigBuyerCurrenciesPtr* output);
};

template <> struct BLINK_COMMON_EXPORT StructTraits<::blink::mojom::AuctionAdServerResponseConfig::DataView, ::blink::mojom::AuctionAdServerResponseConfigPtr> {
    static bool IsNull(const ::blink::mojom::AuctionAdServerResponseConfigPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::AuctionAdServerResponseConfigPtr* output)
    {
        output->reset();
    }

    static const decltype(::blink::mojom::AuctionAdServerResponseConfig::request_id)& request_id(const ::blink::mojom::AuctionAdServerResponseConfigPtr& input)
    {
        return input->request_id;
    }

    static bool Read(::blink::mojom::AuctionAdServerResponseConfig::DataView input, ::blink::mojom::AuctionAdServerResponseConfigPtr* output);
};

template <>
struct BLINK_COMMON_EXPORT StructTraits<::blink::mojom::AuctionReportBuyerDebugModeConfig::DataView, ::blink::mojom::AuctionReportBuyerDebugModeConfigPtr> {
    static bool IsNull(const ::blink::mojom::AuctionReportBuyerDebugModeConfigPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::AuctionReportBuyerDebugModeConfigPtr* output)
    {
        output->reset();
    }

    static decltype(::blink::mojom::AuctionReportBuyerDebugModeConfig::is_enabled) is_enabled(const ::blink::mojom::AuctionReportBuyerDebugModeConfigPtr& input)
    {
        return input->is_enabled;
    }

    static decltype(::blink::mojom::AuctionReportBuyerDebugModeConfig::debug_key) debug_key(const ::blink::mojom::AuctionReportBuyerDebugModeConfigPtr& input)
    {
        return input->debug_key;
    }

    static bool Read(::blink::mojom::AuctionReportBuyerDebugModeConfig::DataView input, ::blink::mojom::AuctionReportBuyerDebugModeConfigPtr* output);
};

template <> struct BLINK_COMMON_EXPORT StructTraits<::blink::mojom::AuctionReportBuyersConfig::DataView, ::blink::mojom::AuctionReportBuyersConfigPtr> {
    static bool IsNull(const ::blink::mojom::AuctionReportBuyersConfigPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::AuctionReportBuyersConfigPtr* output)
    {
        output->reset();
    }

    static const decltype(::blink::mojom::AuctionReportBuyersConfig::bucket)& bucket(const ::blink::mojom::AuctionReportBuyersConfigPtr& input)
    {
        return input->bucket;
    }

    static decltype(::blink::mojom::AuctionReportBuyersConfig::scale) scale(const ::blink::mojom::AuctionReportBuyersConfigPtr& input)
    {
        return input->scale;
    }

    static bool Read(::blink::mojom::AuctionReportBuyersConfig::DataView input, ::blink::mojom::AuctionReportBuyersConfigPtr* output);
};

template <>
struct BLINK_COMMON_EXPORT StructTraits<::blink::mojom::AuctionAdConfigNonSharedParams::DataView, ::blink::mojom::AuctionAdConfigNonSharedParamsPtr> {
    static bool IsNull(const ::blink::mojom::AuctionAdConfigNonSharedParamsPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::AuctionAdConfigNonSharedParamsPtr* output)
    {
        output->reset();
    }

    static const decltype(::blink::mojom::AuctionAdConfigNonSharedParams::interest_group_buyers)& interest_group_buyers(
        const ::blink::mojom::AuctionAdConfigNonSharedParamsPtr& input)
    {
        return input->interest_group_buyers;
    }

    static const decltype(::blink::mojom::AuctionAdConfigNonSharedParams::auction_signals)& auction_signals(
        const ::blink::mojom::AuctionAdConfigNonSharedParamsPtr& input)
    {
        return input->auction_signals;
    }

    static const decltype(::blink::mojom::AuctionAdConfigNonSharedParams::seller_signals)& seller_signals(
        const ::blink::mojom::AuctionAdConfigNonSharedParamsPtr& input)
    {
        return input->seller_signals;
    }

    static const decltype(::blink::mojom::AuctionAdConfigNonSharedParams::seller_timeout)& seller_timeout(
        const ::blink::mojom::AuctionAdConfigNonSharedParamsPtr& input)
    {
        return input->seller_timeout;
    }

    static const decltype(::blink::mojom::AuctionAdConfigNonSharedParams::per_buyer_signals)& per_buyer_signals(
        const ::blink::mojom::AuctionAdConfigNonSharedParamsPtr& input)
    {
        return input->per_buyer_signals;
    }

    static const decltype(::blink::mojom::AuctionAdConfigNonSharedParams::buyer_timeouts)& buyer_timeouts(
        const ::blink::mojom::AuctionAdConfigNonSharedParamsPtr& input)
    {
        return input->buyer_timeouts;
    }

    static const decltype(::blink::mojom::AuctionAdConfigNonSharedParams::reporting_timeout)& reporting_timeout(
        const ::blink::mojom::AuctionAdConfigNonSharedParamsPtr& input)
    {
        return input->reporting_timeout;
    }

    static const decltype(::blink::mojom::AuctionAdConfigNonSharedParams::seller_currency)& seller_currency(
        const ::blink::mojom::AuctionAdConfigNonSharedParamsPtr& input)
    {
        return input->seller_currency;
    }

    static const decltype(::blink::mojom::AuctionAdConfigNonSharedParams::buyer_currencies)& buyer_currencies(
        const ::blink::mojom::AuctionAdConfigNonSharedParamsPtr& input)
    {
        return input->buyer_currencies;
    }

    static const decltype(::blink::mojom::AuctionAdConfigNonSharedParams::buyer_cumulative_timeouts)& buyer_cumulative_timeouts(
        const ::blink::mojom::AuctionAdConfigNonSharedParamsPtr& input)
    {
        return input->buyer_cumulative_timeouts;
    }

    static const decltype(::blink::mojom::AuctionAdConfigNonSharedParams::per_buyer_group_limits)& per_buyer_group_limits(
        const ::blink::mojom::AuctionAdConfigNonSharedParamsPtr& input)
    {
        return input->per_buyer_group_limits;
    }

    static const decltype(::blink::mojom::AuctionAdConfigNonSharedParams::per_buyer_priority_signals)& per_buyer_priority_signals(
        const ::blink::mojom::AuctionAdConfigNonSharedParamsPtr& input)
    {
        return input->per_buyer_priority_signals;
    }

    static const decltype(::blink::mojom::AuctionAdConfigNonSharedParams::all_buyers_priority_signals)& all_buyers_priority_signals(
        const ::blink::mojom::AuctionAdConfigNonSharedParamsPtr& input)
    {
        return input->all_buyers_priority_signals;
    }

    static decltype(::blink::mojom::AuctionAdConfigNonSharedParams::all_buyers_group_limit) all_buyers_group_limit(
        const ::blink::mojom::AuctionAdConfigNonSharedParamsPtr& input)
    {
        return input->all_buyers_group_limit;
    }

    static const decltype(::blink::mojom::AuctionAdConfigNonSharedParams::auction_report_buyer_keys)& auction_report_buyer_keys(
        const ::blink::mojom::AuctionAdConfigNonSharedParamsPtr& input)
    {
        return input->auction_report_buyer_keys;
    }

    static const decltype(::blink::mojom::AuctionAdConfigNonSharedParams::auction_report_buyers)& auction_report_buyers(
        const ::blink::mojom::AuctionAdConfigNonSharedParamsPtr& input)
    {
        return input->auction_report_buyers;
    }

    static const decltype(::blink::mojom::AuctionAdConfigNonSharedParams::auction_report_buyer_debug_mode_config)& auction_report_buyer_debug_mode_config(
        const ::blink::mojom::AuctionAdConfigNonSharedParamsPtr& input)
    {
        return input->auction_report_buyer_debug_mode_config;
    }

    static const decltype(::blink::mojom::AuctionAdConfigNonSharedParams::required_seller_capabilities)& required_seller_capabilities(
        const ::blink::mojom::AuctionAdConfigNonSharedParamsPtr& input)
    {
        return input->required_seller_capabilities;
    }

    static const decltype(::blink::mojom::AuctionAdConfigNonSharedParams::requested_size)& requested_size(
        const ::blink::mojom::AuctionAdConfigNonSharedParamsPtr& input)
    {
        return input->requested_size;
    }

    static const decltype(::blink::mojom::AuctionAdConfigNonSharedParams::all_slots_requested_sizes)& all_slots_requested_sizes(
        const ::blink::mojom::AuctionAdConfigNonSharedParamsPtr& input)
    {
        return input->all_slots_requested_sizes;
    }

    static const decltype(::blink::mojom::AuctionAdConfigNonSharedParams::per_buyer_multi_bid_limits)& per_buyer_multi_bid_limits(
        const ::blink::mojom::AuctionAdConfigNonSharedParamsPtr& input)
    {
        return input->per_buyer_multi_bid_limits;
    }

    static decltype(::blink::mojom::AuctionAdConfigNonSharedParams::all_buyers_multi_bid_limit) all_buyers_multi_bid_limit(
        const ::blink::mojom::AuctionAdConfigNonSharedParamsPtr& input)
    {
        return input->all_buyers_multi_bid_limit;
    }

    static const decltype(::blink::mojom::AuctionAdConfigNonSharedParams::auction_nonce)& auction_nonce(
        const ::blink::mojom::AuctionAdConfigNonSharedParamsPtr& input)
    {
        return input->auction_nonce;
    }

    static decltype(::blink::mojom::AuctionAdConfigNonSharedParams::seller_real_time_reporting_type) seller_real_time_reporting_type(
        const ::blink::mojom::AuctionAdConfigNonSharedParamsPtr& input)
    {
        return input->seller_real_time_reporting_type;
    }

    static const decltype(::blink::mojom::AuctionAdConfigNonSharedParams::per_buyer_real_time_reporting_types)& per_buyer_real_time_reporting_types(
        const ::blink::mojom::AuctionAdConfigNonSharedParamsPtr& input)
    {
        return input->per_buyer_real_time_reporting_types;
    }

    static const decltype(::blink::mojom::AuctionAdConfigNonSharedParams::component_auctions)& component_auctions(
        const ::blink::mojom::AuctionAdConfigNonSharedParamsPtr& input)
    {
        return input->component_auctions;
    }

    static const decltype(::blink::mojom::AuctionAdConfigNonSharedParams::deprecated_render_url_replacements)& deprecated_render_url_replacements(
        const ::blink::mojom::AuctionAdConfigNonSharedParamsPtr& input)
    {
        return input->deprecated_render_url_replacements;
    }

    static decltype(::blink::mojom::AuctionAdConfigNonSharedParams::max_trusted_scoring_signals_url_length) max_trusted_scoring_signals_url_length(
        const ::blink::mojom::AuctionAdConfigNonSharedParamsPtr& input)
    {
        return input->max_trusted_scoring_signals_url_length;
    }

    static const decltype(::blink::mojom::AuctionAdConfigNonSharedParams::trusted_scoring_signals_coordinator)& trusted_scoring_signals_coordinator(
        const ::blink::mojom::AuctionAdConfigNonSharedParamsPtr& input)
    {
        return input->trusted_scoring_signals_coordinator;
    }

    static bool Read(::blink::mojom::AuctionAdConfigNonSharedParams::DataView input, ::blink::mojom::AuctionAdConfigNonSharedParamsPtr* output);
};

template <> struct BLINK_COMMON_EXPORT StructTraits<::blink::mojom::AuctionAdConfig::DataView, ::blink::mojom::AuctionAdConfigPtr> {
    static bool IsNull(const ::blink::mojom::AuctionAdConfigPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::AuctionAdConfigPtr* output)
    {
        output->reset();
    }

    static const decltype(::blink::mojom::AuctionAdConfig::seller)& seller(const ::blink::mojom::AuctionAdConfigPtr& input)
    {
        return input->seller;
    }

    static const decltype(::blink::mojom::AuctionAdConfig::server_response)& server_response(const ::blink::mojom::AuctionAdConfigPtr& input)
    {
        return input->server_response;
    }

    static const decltype(::blink::mojom::AuctionAdConfig::decision_logic_url)& decision_logic_url(const ::blink::mojom::AuctionAdConfigPtr& input)
    {
        return input->decision_logic_url;
    }

    static const decltype(::blink::mojom::AuctionAdConfig::trusted_scoring_signals_url)& trusted_scoring_signals_url(
        const ::blink::mojom::AuctionAdConfigPtr& input)
    {
        return input->trusted_scoring_signals_url;
    }

    static const decltype(::blink::mojom::AuctionAdConfig::auction_ad_config_non_shared_params)& auction_ad_config_non_shared_params(
        const ::blink::mojom::AuctionAdConfigPtr& input)
    {
        return input->auction_ad_config_non_shared_params;
    }

    static const decltype(::blink::mojom::AuctionAdConfig::direct_from_seller_signals)& direct_from_seller_signals(
        const ::blink::mojom::AuctionAdConfigPtr& input)
    {
        return input->direct_from_seller_signals;
    }

    static decltype(::blink::mojom::AuctionAdConfig::expects_direct_from_seller_signals_header_ad_slot) expects_direct_from_seller_signals_header_ad_slot(
        const ::blink::mojom::AuctionAdConfigPtr& input)
    {
        return input->expects_direct_from_seller_signals_header_ad_slot;
    }

    static decltype(::blink::mojom::AuctionAdConfig::seller_experiment_group_id) seller_experiment_group_id(const ::blink::mojom::AuctionAdConfigPtr& input)
    {
        return input->seller_experiment_group_id;
    }

    static decltype(::blink::mojom::AuctionAdConfig::all_buyer_experiment_group_id) all_buyer_experiment_group_id(
        const ::blink::mojom::AuctionAdConfigPtr& input)
    {
        return input->all_buyer_experiment_group_id;
    }

    static const decltype(::blink::mojom::AuctionAdConfig::per_buyer_experiment_group_ids)& per_buyer_experiment_group_ids(
        const ::blink::mojom::AuctionAdConfigPtr& input)
    {
        return input->per_buyer_experiment_group_ids;
    }

    static decltype(::blink::mojom::AuctionAdConfig::expects_additional_bids) expects_additional_bids(const ::blink::mojom::AuctionAdConfigPtr& input)
    {
        return input->expects_additional_bids;
    }

    static const decltype(::blink::mojom::AuctionAdConfig::aggregation_coordinator_origin)& aggregation_coordinator_origin(
        const ::blink::mojom::AuctionAdConfigPtr& input)
    {
        return input->aggregation_coordinator_origin;
    }

    static bool Read(::blink::mojom::AuctionAdConfig::DataView input, ::blink::mojom::AuctionAdConfigPtr* output);
};

template <> struct BLINK_COMMON_EXPORT StructTraits<::blink::mojom::AuctionDataBuyerConfig::DataView, ::blink::mojom::AuctionDataBuyerConfigPtr> {
    static bool IsNull(const ::blink::mojom::AuctionDataBuyerConfigPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::AuctionDataBuyerConfigPtr* output)
    {
        output->reset();
    }

    static decltype(::blink::mojom::AuctionDataBuyerConfig::target_size) target_size(const ::blink::mojom::AuctionDataBuyerConfigPtr& input)
    {
        return input->target_size;
    }

    static bool Read(::blink::mojom::AuctionDataBuyerConfig::DataView input, ::blink::mojom::AuctionDataBuyerConfigPtr* output);
};

template <> struct BLINK_COMMON_EXPORT StructTraits<::blink::mojom::AuctionDataConfig::DataView, ::blink::mojom::AuctionDataConfigPtr> {
    static bool IsNull(const ::blink::mojom::AuctionDataConfigPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::AuctionDataConfigPtr* output)
    {
        output->reset();
    }

    static const decltype(::blink::mojom::AuctionDataConfig::per_buyer_configs)& per_buyer_configs(const ::blink::mojom::AuctionDataConfigPtr& input)
    {
        return input->per_buyer_configs;
    }

    static decltype(::blink::mojom::AuctionDataConfig::request_size) request_size(const ::blink::mojom::AuctionDataConfigPtr& input)
    {
        return input->request_size;
    }

    static bool Read(::blink::mojom::AuctionDataConfig::DataView input, ::blink::mojom::AuctionDataConfigPtr* output);
};

template <>
struct BLINK_COMMON_EXPORT UnionTraits<::blink::mojom::AuctionAdConfigMaybePromiseJson::DataView, ::blink::mojom::AuctionAdConfigMaybePromiseJsonPtr> {
    static bool IsNull(const ::blink::mojom::AuctionAdConfigMaybePromiseJsonPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::AuctionAdConfigMaybePromiseJsonPtr* output)
    {
        output->reset();
    }

    static ::blink::mojom::AuctionAdConfigMaybePromiseJson::Tag GetTag(const ::blink::mojom::AuctionAdConfigMaybePromiseJsonPtr& input)
    {
        return input->which();
    }

    static uint32_t promise(const ::blink::mojom::AuctionAdConfigMaybePromiseJsonPtr& input)
    {
        return input->get_promise();
    }

    static const std::optional<std::string>& value(const ::blink::mojom::AuctionAdConfigMaybePromiseJsonPtr& input)
    {
        return input->get_value();
    }

    static bool Read(::blink::mojom::AuctionAdConfigMaybePromiseJson::DataView input, ::blink::mojom::AuctionAdConfigMaybePromiseJsonPtr* output);
};

template <>
struct BLINK_COMMON_EXPORT
    UnionTraits<::blink::mojom::AuctionAdConfigMaybePromisePerBuyerSignals::DataView, ::blink::mojom::AuctionAdConfigMaybePromisePerBuyerSignalsPtr> {
    static bool IsNull(const ::blink::mojom::AuctionAdConfigMaybePromisePerBuyerSignalsPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::AuctionAdConfigMaybePromisePerBuyerSignalsPtr* output)
    {
        output->reset();
    }

    static ::blink::mojom::AuctionAdConfigMaybePromisePerBuyerSignals::Tag GetTag(const ::blink::mojom::AuctionAdConfigMaybePromisePerBuyerSignalsPtr& input)
    {
        return input->which();
    }

    static uint32_t promise(const ::blink::mojom::AuctionAdConfigMaybePromisePerBuyerSignalsPtr& input)
    {
        return input->get_promise();
    }

    static const std::optional<base::flat_map<::url::Origin, std::string>>& value(const ::blink::mojom::AuctionAdConfigMaybePromisePerBuyerSignalsPtr& input)
    {
        return input->get_value();
    }

    static bool Read(
        ::blink::mojom::AuctionAdConfigMaybePromisePerBuyerSignals::DataView input, ::blink::mojom::AuctionAdConfigMaybePromisePerBuyerSignalsPtr* output);
};

template <>
struct BLINK_COMMON_EXPORT
    UnionTraits<::blink::mojom::AuctionAdConfigMaybePromiseBuyerTimeouts::DataView, ::blink::mojom::AuctionAdConfigMaybePromiseBuyerTimeoutsPtr> {
    static bool IsNull(const ::blink::mojom::AuctionAdConfigMaybePromiseBuyerTimeoutsPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::AuctionAdConfigMaybePromiseBuyerTimeoutsPtr* output)
    {
        output->reset();
    }

    static ::blink::mojom::AuctionAdConfigMaybePromiseBuyerTimeouts::Tag GetTag(const ::blink::mojom::AuctionAdConfigMaybePromiseBuyerTimeoutsPtr& input)
    {
        return input->which();
    }

    static uint32_t promise(const ::blink::mojom::AuctionAdConfigMaybePromiseBuyerTimeoutsPtr& input)
    {
        return input->get_promise();
    }

    static const ::blink::AuctionConfig::BuyerTimeouts& value(const ::blink::mojom::AuctionAdConfigMaybePromiseBuyerTimeoutsPtr& input)
    {
        return input->get_value();
    }

    static bool Read(
        ::blink::mojom::AuctionAdConfigMaybePromiseBuyerTimeouts::DataView input, ::blink::mojom::AuctionAdConfigMaybePromiseBuyerTimeoutsPtr* output);
};

template <>
struct BLINK_COMMON_EXPORT
    UnionTraits<::blink::mojom::AuctionAdConfigMaybePromiseBuyerCurrencies::DataView, ::blink::mojom::AuctionAdConfigMaybePromiseBuyerCurrenciesPtr> {
    static bool IsNull(const ::blink::mojom::AuctionAdConfigMaybePromiseBuyerCurrenciesPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::AuctionAdConfigMaybePromiseBuyerCurrenciesPtr* output)
    {
        output->reset();
    }

    static ::blink::mojom::AuctionAdConfigMaybePromiseBuyerCurrencies::Tag GetTag(const ::blink::mojom::AuctionAdConfigMaybePromiseBuyerCurrenciesPtr& input)
    {
        return input->which();
    }

    static uint32_t promise(const ::blink::mojom::AuctionAdConfigMaybePromiseBuyerCurrenciesPtr& input)
    {
        return input->get_promise();
    }

    static const ::blink::AuctionConfig::BuyerCurrencies& value(const ::blink::mojom::AuctionAdConfigMaybePromiseBuyerCurrenciesPtr& input)
    {
        return input->get_value();
    }

    static bool Read(
        ::blink::mojom::AuctionAdConfigMaybePromiseBuyerCurrencies::DataView input, ::blink::mojom::AuctionAdConfigMaybePromiseBuyerCurrenciesPtr* output);
};

template <>
struct BLINK_COMMON_EXPORT UnionTraits<::blink::mojom::AuctionAdConfigMaybePromiseDirectFromSellerSignals::DataView,
    ::blink::mojom::AuctionAdConfigMaybePromiseDirectFromSellerSignalsPtr> {
    static bool IsNull(const ::blink::mojom::AuctionAdConfigMaybePromiseDirectFromSellerSignalsPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::AuctionAdConfigMaybePromiseDirectFromSellerSignalsPtr* output)
    {
        output->reset();
    }

    static ::blink::mojom::AuctionAdConfigMaybePromiseDirectFromSellerSignals::Tag GetTag(
        const ::blink::mojom::AuctionAdConfigMaybePromiseDirectFromSellerSignalsPtr& input)
    {
        return input->which();
    }

    static uint32_t promise(const ::blink::mojom::AuctionAdConfigMaybePromiseDirectFromSellerSignalsPtr& input)
    {
        return input->get_promise();
    }

    static const std::optional<::blink::DirectFromSellerSignals>& value(const ::blink::mojom::AuctionAdConfigMaybePromiseDirectFromSellerSignalsPtr& input)
    {
        return input->get_value();
    }

    static bool Read(::blink::mojom::AuctionAdConfigMaybePromiseDirectFromSellerSignals::DataView input,
        ::blink::mojom::AuctionAdConfigMaybePromiseDirectFromSellerSignalsPtr* output);
};

template <>
struct BLINK_COMMON_EXPORT UnionTraits<::blink::mojom::AuctionAdConfigMaybePromiseDeprecatedRenderURLReplacements::DataView,
    ::blink::mojom::AuctionAdConfigMaybePromiseDeprecatedRenderURLReplacementsPtr> {
    static bool IsNull(const ::blink::mojom::AuctionAdConfigMaybePromiseDeprecatedRenderURLReplacementsPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::AuctionAdConfigMaybePromiseDeprecatedRenderURLReplacementsPtr* output)
    {
        output->reset();
    }

    static ::blink::mojom::AuctionAdConfigMaybePromiseDeprecatedRenderURLReplacements::Tag GetTag(
        const ::blink::mojom::AuctionAdConfigMaybePromiseDeprecatedRenderURLReplacementsPtr& input)
    {
        return input->which();
    }

    static uint32_t promise(const ::blink::mojom::AuctionAdConfigMaybePromiseDeprecatedRenderURLReplacementsPtr& input)
    {
        return input->get_promise();
    }

    static const std::vector<::blink::AuctionConfig::AdKeywordReplacement>& value(
        const ::blink::mojom::AuctionAdConfigMaybePromiseDeprecatedRenderURLReplacementsPtr& input)
    {
        return input->get_value();
    }

    static bool Read(::blink::mojom::AuctionAdConfigMaybePromiseDeprecatedRenderURLReplacements::DataView input,
        ::blink::mojom::AuctionAdConfigMaybePromiseDeprecatedRenderURLReplacementsPtr* output);
};

} // namespace mojo

#endif // THIRD_PARTY_BLINK_PUBLIC_MOJOM_INTEREST_GROUP_INTEREST_GROUP_TYPES_MOJOM_H_
