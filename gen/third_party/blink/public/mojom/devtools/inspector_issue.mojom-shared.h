// third_party/blink/public/mojom/devtools/inspector_issue.mojom-shared.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef THIRD_PARTY_BLINK_PUBLIC_MOJOM_DEVTOOLS_INSPECTOR_ISSUE_MOJOM_SHARED_H_
#define THIRD_PARTY_BLINK_PUBLIC_MOJOM_DEVTOOLS_INSPECTOR_ISSUE_MOJOM_SHARED_H_

#include <stdint.h>

#include <functional>
#include <iosfwd>
#include <type_traits>
#include <utility>
#include "mojo/public/cpp/bindings/array_data_view.h"
#include "mojo/public/cpp/bindings/enum_traits.h"
#include "mojo/public/cpp/bindings/interface_data_view.h"
#include "mojo/public/cpp/bindings/lib/bindings_internal.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/map_data_view.h"
#include "mojo/public/cpp/bindings/string_data_view.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "third_party/blink/public/mojom/devtools/inspector_issue.mojom-shared-internal.h"
#include "url/mojom/url.mojom-shared.h"
#include "services/network/public/mojom/cookie_manager.mojom-shared.h"
#include "services/network/public/mojom/blocked_by_response_reason.mojom-shared.h"
#include "third_party/blink/public/mojom/fetch/fetch_api_request.mojom-shared.h"
#include "mojo/public/mojom/base/unguessable_token.mojom-shared.h"

#include "base/component_export.h"

namespace blink::mojom {
class AffectedCookieDataView;

class AffectedRequestDataView;

class AffectedFrameDataView;

class AffectedLocationDataView;

class BlockedByResponseIssueDetailsDataView;

class HeavyAdIssueDetailsDataView;

class AttributionReportingIssueDetailsDataView;

class MixedContentIssueDetailsDataView;

class ContentSecurityPolicyIssueDetailsDataView;

class CookieIssueDetailsDataView;

class SharedArrayBufferIssueDetailsDataView;

class LowTextContrastIssueDataView;

class FederatedAuthRequestIssueDetailsDataView;

class FederatedAuthUserInfoRequestIssueDetailsDataView;

class BounceTrackingIssueDetailsDataView;

class CookieDeprecationMetadataIssueDetailsDataView;

class GenericIssueDetailsDataView;

class DeprecationIssueDetailsDataView;

class InspectorIssueDetailsDataView;

class InspectorIssueInfoDataView;

} // blink::mojom

namespace mojo {
namespace internal {

template <> struct MojomTypeTraits<::blink::mojom::AffectedCookieDataView> {
    using Data = ::blink::mojom::internal::AffectedCookie_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::blink::mojom::AffectedRequestDataView> {
    using Data = ::blink::mojom::internal::AffectedRequest_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::blink::mojom::AffectedFrameDataView> {
    using Data = ::blink::mojom::internal::AffectedFrame_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::blink::mojom::AffectedLocationDataView> {
    using Data = ::blink::mojom::internal::AffectedLocation_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::blink::mojom::BlockedByResponseIssueDetailsDataView> {
    using Data = ::blink::mojom::internal::BlockedByResponseIssueDetails_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::blink::mojom::HeavyAdIssueDetailsDataView> {
    using Data = ::blink::mojom::internal::HeavyAdIssueDetails_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::blink::mojom::AttributionReportingIssueDetailsDataView> {
    using Data = ::blink::mojom::internal::AttributionReportingIssueDetails_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::blink::mojom::MixedContentIssueDetailsDataView> {
    using Data = ::blink::mojom::internal::MixedContentIssueDetails_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::blink::mojom::ContentSecurityPolicyIssueDetailsDataView> {
    using Data = ::blink::mojom::internal::ContentSecurityPolicyIssueDetails_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::blink::mojom::CookieIssueDetailsDataView> {
    using Data = ::blink::mojom::internal::CookieIssueDetails_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::blink::mojom::SharedArrayBufferIssueDetailsDataView> {
    using Data = ::blink::mojom::internal::SharedArrayBufferIssueDetails_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::blink::mojom::LowTextContrastIssueDataView> {
    using Data = ::blink::mojom::internal::LowTextContrastIssue_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::blink::mojom::FederatedAuthRequestIssueDetailsDataView> {
    using Data = ::blink::mojom::internal::FederatedAuthRequestIssueDetails_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::blink::mojom::FederatedAuthUserInfoRequestIssueDetailsDataView> {
    using Data = ::blink::mojom::internal::FederatedAuthUserInfoRequestIssueDetails_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::blink::mojom::BounceTrackingIssueDetailsDataView> {
    using Data = ::blink::mojom::internal::BounceTrackingIssueDetails_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::blink::mojom::CookieDeprecationMetadataIssueDetailsDataView> {
    using Data = ::blink::mojom::internal::CookieDeprecationMetadataIssueDetails_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::blink::mojom::GenericIssueDetailsDataView> {
    using Data = ::blink::mojom::internal::GenericIssueDetails_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::blink::mojom::DeprecationIssueDetailsDataView> {
    using Data = ::blink::mojom::internal::DeprecationIssueDetails_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::blink::mojom::InspectorIssueDetailsDataView> {
    using Data = ::blink::mojom::internal::InspectorIssueDetails_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::blink::mojom::InspectorIssueInfoDataView> {
    using Data = ::blink::mojom::internal::InspectorIssueInfo_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

} // namespace internal
} // namespace mojo

namespace blink::mojom {

enum class InspectorIssueCode : int32_t {

    kCookieIssue = 0,

    kMixedContentIssue = 1,

    kBlockedByResponseIssue = 2,

    kContentSecurityPolicyIssue = 3,

    kSharedArrayBufferIssue = 4,

    kHeavyAdIssue = 5,

    kAttributionReportingIssue = 6,

    kLowTextContrastIssue = 7,

    kFederatedAuthRequestIssue = 8,

    kBounceTrackingIssue = 9,

    kCookieDeprecationMetadataIssue = 10,

    kGenericIssue = 11,

    kDeprecationIssue = 12,

    kFederatedAuthUserInfoRequestIssue = 13,
    kMinValue = 0,
    kMaxValue = 13,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, InspectorIssueCode value);
inline bool IsKnownEnumValue(InspectorIssueCode value)
{
    return internal::InspectorIssueCode_Data::IsKnownValue(static_cast<int32_t>(value));
}

enum class HeavyAdResolutionStatus : int32_t {

    kHeavyAdBlocked = 0,

    kHeavyAdWarning = 1,
    kMinValue = 0,
    kMaxValue = 1,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, HeavyAdResolutionStatus value);
inline bool IsKnownEnumValue(HeavyAdResolutionStatus value)
{
    return internal::HeavyAdResolutionStatus_Data::IsKnownValue(static_cast<int32_t>(value));
}

enum class HeavyAdReason : int32_t {

    kNetworkTotalLimit = 0,

    kCpuTotalLimit = 1,

    kCpuPeakLimit = 2,
    kMinValue = 0,
    kMaxValue = 2,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, HeavyAdReason value);
inline bool IsKnownEnumValue(HeavyAdReason value)
{
    return internal::HeavyAdReason_Data::IsKnownValue(static_cast<int32_t>(value));
}

enum class AttributionReportingIssueType : int32_t {

    kPermissionPolicyDisabled = 0,

    kUntrustworthyReportingOrigin = 1,

    kInsecureContext = 2,

    kInvalidRegisterSourceHeader = 3,

    kInvalidRegisterTriggerHeader = 4,

    kSourceAndTriggerHeaders = 5,

    kSourceIgnored = 6,

    kTriggerIgnored = 7,

    kOsSourceIgnored = 8,

    kOsTriggerIgnored = 9,

    kInvalidRegisterOsSourceHeader = 10,

    kInvalidRegisterOsTriggerHeader = 11,

    kWebAndOsHeaders = 12,

    kNoWebOrOsSupport = 13,

    kNavigationRegistrationWithoutTransientUserActivation = 14,

    kInvalidInfoHeader = 15,

    kNoRegisterSourceHeader = 16,

    kNoRegisterTriggerHeader = 17,

    kNoRegisterOsSourceHeader = 18,

    kNoRegisterOsTriggerHeader = 19,

    kNavigationRegistrationUniqueScopeAlreadySet = 20,
    kMinValue = 0,
    kMaxValue = 20,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, AttributionReportingIssueType value);
inline bool IsKnownEnumValue(AttributionReportingIssueType value)
{
    return internal::AttributionReportingIssueType_Data::IsKnownValue(static_cast<int32_t>(value));
}

enum class MixedContentResolutionStatus : int32_t {

    kMixedContentBlocked = 0,

    kMixedContentAutomaticallyUpgraded = 1,

    kMixedContentWarning = 2,
    kMinValue = 0,
    kMaxValue = 2,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, MixedContentResolutionStatus value);
inline bool IsKnownEnumValue(MixedContentResolutionStatus value)
{
    return internal::MixedContentResolutionStatus_Data::IsKnownValue(static_cast<int32_t>(value));
}

enum class ContentSecurityPolicyViolationType : int32_t {

    kInlineViolation = 0,

    kEvalViolation = 1,

    kURLViolation = 2,

    kTrustedTypesSinkViolation = 3,

    kTrustedTypesPolicyViolation = 4,

    kWasmEvalViolation = 5,
    kMinValue = 0,
    kMaxValue = 5,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, ContentSecurityPolicyViolationType value);
inline bool IsKnownEnumValue(ContentSecurityPolicyViolationType value)
{
    return internal::ContentSecurityPolicyViolationType_Data::IsKnownValue(static_cast<int32_t>(value));
}

enum class CookieOperation : int32_t {

    kSetCookie = 0,

    kReadCookie = 1,
    kMinValue = 0,
    kMaxValue = 1,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, CookieOperation value);
inline bool IsKnownEnumValue(CookieOperation value)
{
    return internal::CookieOperation_Data::IsKnownValue(static_cast<int32_t>(value));
}

enum class CookieExclusionReason : int32_t {

    kExcludeSameSiteUnspecifiedTreatedAsLax = 0,

    kExcludeSameSiteNoneInsecure = 1,

    kExcludeSameSiteLax = 2,

    kExcludeSameSiteStrict = 3,

    kExcludeDomainNonASCII = 4,

    kExcludeThirdPartyPhaseout = 5,

    kExcludePortMismatch = 6,

    kExcludeSchemeMismatch = 7,
    kMinValue = 0,
    kMaxValue = 7,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, CookieExclusionReason value);
inline bool IsKnownEnumValue(CookieExclusionReason value)
{
    return internal::CookieExclusionReason_Data::IsKnownValue(static_cast<int32_t>(value));
}

enum class CookieWarningReason : int32_t {

    kWarnSameSiteUnspecifiedCrossSiteContext = 0,

    kWarnSameSiteNoneInsecure = 1,

    kWarnSameSiteUnspecifiedLaxAllowUnsafe = 2,

    kWarnSameSiteStrictLaxDowngradeStrict = 3,

    kWarnSameSiteStrictCrossDowngradeStrict = 4,

    kWarnSameSiteStrictCrossDowngradeLax = 5,

    kWarnSameSiteLaxCrossDowngradeStrict = 6,

    kWarnSameSiteLaxCrossDowngradeLax = 7,

    kWarnAttributeValueExceedsMaxSize = 8,

    kWarnDomainNonASCII = 9,

    kWarnThirdPartyPhaseout = 10,

    kWarnCrossSiteRedirectDowngradeChangesInclusion = 11,
    kMinValue = 0,
    kMaxValue = 11,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, CookieWarningReason value);
inline bool IsKnownEnumValue(CookieWarningReason value)
{
    return internal::CookieWarningReason_Data::IsKnownValue(static_cast<int32_t>(value));
}

enum class SharedArrayBufferIssueType : int32_t {

    kTransferIssue = 0,

    kCreationIssue = 1,
    kMinValue = 0,
    kMaxValue = 1,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, SharedArrayBufferIssueType value);
inline bool IsKnownEnumValue(SharedArrayBufferIssueType value)
{
    return internal::SharedArrayBufferIssueType_Data::IsKnownValue(static_cast<int32_t>(value));
}

enum class FederatedAuthRequestResult : int32_t {

    kSuccess = 0,

    kShouldEmbargo = 1,

    kIdpNotPotentiallyTrustworthy = 2,

    kDisabledInSettings = 3,

    kDisabledInFlags = 4,

    kTooManyRequests = 5,

    kWellKnownHttpNotFound = 6,

    kWellKnownNoResponse = 7,

    kWellKnownInvalidResponse = 8,

    kWellKnownListEmpty = 9,

    kWellKnownInvalidContentType = 10,

    kConfigNotInWellKnown = 11,

    kWellKnownTooBig = 12,

    kConfigHttpNotFound = 13,

    kConfigNoResponse = 14,

    kConfigInvalidResponse = 15,

    kConfigInvalidContentType = 16,

    kClientMetadataHttpNotFound = 17,

    kClientMetadataNoResponse = 18,

    kClientMetadataInvalidResponse = 19,

    kClientMetadataInvalidContentType = 20,

    kAccountsHttpNotFound = 21,

    kAccountsNoResponse = 22,

    kAccountsInvalidResponse = 23,

    kAccountsListEmpty = 24,

    kAccountsInvalidContentType = 25,

    kIdTokenHttpNotFound = 26,

    kIdTokenNoResponse = 27,

    kIdTokenInvalidResponse = 28,

    kIdTokenIdpErrorResponse = 29,

    kIdTokenCrossSiteIdpErrorResponse = 30,

    kIdTokenInvalidContentType = 31,

    kCanceled = 32,

    kRpPageNotVisible = 33,

    kSilentMediationFailure = 34,

    kThirdPartyCookiesBlocked = 35,

    kNotSignedInWithIdp = 36,

    kMissingTransientUserActivation = 37,

    kReplacedByActiveMode = 38,

    kInvalidFieldsSpecified = 39,

    kRelyingPartyOriginIsOpaque = 40,

    kTypeNotMatching = 41,

    kError = 42,
    kMinValue = 0,
    kMaxValue = 42,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, FederatedAuthRequestResult value);
inline bool IsKnownEnumValue(FederatedAuthRequestResult value)
{
    return internal::FederatedAuthRequestResult_Data::IsKnownValue(static_cast<int32_t>(value));
}

enum class FederatedAuthUserInfoRequestResult : int32_t {

    kSuccess = 0,

    kNotSameOrigin = 1,

    kNotIframe = 2,

    kNotPotentiallyTrustworthy = 3,

    kNoApiPermission = 4,

    kNotSignedInWithIdp = 5,

    kNoAccountSharingPermission = 6,

    kInvalidConfigOrWellKnown = 7,

    kInvalidAccountsResponse = 8,

    kNoReturningUserFromFetchedAccounts = 9,

    kUnhandledRequest = 10,
    kMinValue = 0,
    kMaxValue = 10,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, FederatedAuthUserInfoRequestResult value);
inline bool IsKnownEnumValue(FederatedAuthUserInfoRequestResult value)
{
    return internal::FederatedAuthUserInfoRequestResult_Data::IsKnownValue(static_cast<int32_t>(value));
}

enum class GenericIssueErrorType : int32_t {

    kFormLabelForNameError = 0,

    kFormDuplicateIdForInputError = 1,

    kFormInputWithNoLabelError = 2,

    kFormAutocompleteAttributeEmptyError = 3,

    kFormEmptyIdAndNameAttributesForInputError = 4,

    kFormAriaLabelledByToNonExistingId = 5,

    kFormInputAssignedAutocompleteValueToIdOrNameAttributeError = 6,

    kFormLabelHasNeitherForNorNestedInput = 7,

    kFormLabelForMatchesNonExistingIdError = 8,

    kFormInputHasWrongButWellIntendedAutocompleteValueError = 9,

    kResponseWasBlockedByORB = 10,
    kMinValue = 0,
    kMaxValue = 10,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, GenericIssueErrorType value);
inline bool IsKnownEnumValue(GenericIssueErrorType value)
{
    return internal::GenericIssueErrorType_Data::IsKnownValue(static_cast<int32_t>(value));
}

enum class DeprecationIssueType : int32_t {

    kPrivacySandboxExtensionsAPI = 0,
    kMinValue = 0,
    kMaxValue = 0,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, DeprecationIssueType value);
inline bool IsKnownEnumValue(DeprecationIssueType value)
{
    return internal::DeprecationIssueType_Data::IsKnownValue(static_cast<int32_t>(value));
}

class AffectedCookieDataView {
public:
    AffectedCookieDataView() = default;

    AffectedCookieDataView(internal::AffectedCookie_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetNameDataView(mojo::StringDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadName(UserType* output)
    {

        auto* pointer = data_->name.Get();
        return mojo::internal::Deserialize<mojo::StringDataView>(pointer, output, message_);
    }
    inline void GetPathDataView(mojo::StringDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadPath(UserType* output)
    {

        auto* pointer = data_->path.Get();
        return mojo::internal::Deserialize<mojo::StringDataView>(pointer, output, message_);
    }
    inline void GetDomainDataView(mojo::StringDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadDomain(UserType* output)
    {

        auto* pointer = data_->domain.Get();
        return mojo::internal::Deserialize<mojo::StringDataView>(pointer, output, message_);
    }

private:
    internal::AffectedCookie_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class AffectedRequestDataView {
public:
    AffectedRequestDataView() = default;

    AffectedRequestDataView(internal::AffectedRequest_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetRequestIdDataView(mojo::StringDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadRequestId(UserType* output)
    {

        auto* pointer = data_->request_id.Get();
        return mojo::internal::Deserialize<mojo::StringDataView>(pointer, output, message_);
    }
    inline void GetUrlDataView(mojo::StringDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadUrl(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<mojo::StringDataView, UserType>(),
            "Attempting to read the optional `url` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadUrl` instead "
            "of `ReadUrl if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->url.Get();
        return mojo::internal::Deserialize<mojo::StringDataView>(pointer, output, message_);
    }

private:
    internal::AffectedRequest_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class AffectedFrameDataView {
public:
    AffectedFrameDataView() = default;

    AffectedFrameDataView(internal::AffectedFrame_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetFrameIdDataView(mojo::StringDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadFrameId(UserType* output)
    {

        auto* pointer = data_->frame_id.Get();
        return mojo::internal::Deserialize<mojo::StringDataView>(pointer, output, message_);
    }

private:
    internal::AffectedFrame_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class AffectedLocationDataView {
public:
    AffectedLocationDataView() = default;

    AffectedLocationDataView(internal::AffectedLocation_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetScriptIdDataView(mojo::StringDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadScriptId(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<mojo::StringDataView, UserType>(),
            "Attempting to read the optional `script_id` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadScriptId` instead "
            "of `ReadScriptId if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->script_id.Get();
        return mojo::internal::Deserialize<mojo::StringDataView>(pointer, output, message_);
    }
    inline void GetUrlDataView(mojo::StringDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadUrl(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<mojo::StringDataView, UserType>(),
            "Attempting to read the optional `url` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadUrl` instead "
            "of `ReadUrl if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->url.Get();
        return mojo::internal::Deserialize<mojo::StringDataView>(pointer, output, message_);
    }
    uint32_t line() const
    {
        return data_->line;
    }
    uint32_t column() const
    {
        return data_->column;
    }

private:
    internal::AffectedLocation_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class BlockedByResponseIssueDetailsDataView {
public:
    BlockedByResponseIssueDetailsDataView() = default;

    BlockedByResponseIssueDetailsDataView(internal::BlockedByResponseIssueDetails_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetRequestDataView(AffectedRequestDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadRequest(UserType* output)
    {

        auto* pointer = data_->request.Get();
        return mojo::internal::Deserialize<::blink::mojom::AffectedRequestDataView>(pointer, output, message_);
    }
    inline void GetParentFrameDataView(AffectedFrameDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadParentFrame(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::blink::mojom::AffectedFrameDataView, UserType>(),
            "Attempting to read the optional `parentFrame` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadParentFrame` instead "
            "of `ReadParentFrame if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->parentFrame.Get();
        return mojo::internal::Deserialize<::blink::mojom::AffectedFrameDataView>(pointer, output, message_);
    }
    inline void GetBlockedFrameDataView(AffectedFrameDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadBlockedFrame(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::blink::mojom::AffectedFrameDataView, UserType>(),
            "Attempting to read the optional `blockedFrame` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadBlockedFrame` instead "
            "of `ReadBlockedFrame if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->blockedFrame.Get();
        return mojo::internal::Deserialize<::blink::mojom::AffectedFrameDataView>(pointer, output, message_);
    }
    template <typename UserType> [[nodiscard]] bool ReadReason(UserType* output) const
    {
        auto data_value = data_->reason;
        return mojo::internal::Deserialize<::network::mojom::BlockedByResponseReason>(data_value, output);
    }
    ::network::mojom::BlockedByResponseReason reason() const
    {
        return ::mojo::internal::ToKnownEnumValueHelper(static_cast<::network::mojom::BlockedByResponseReason>(data_->reason));
    }

private:
    internal::BlockedByResponseIssueDetails_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class HeavyAdIssueDetailsDataView {
public:
    HeavyAdIssueDetailsDataView() = default;

    HeavyAdIssueDetailsDataView(internal::HeavyAdIssueDetails_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    template <typename UserType> [[nodiscard]] bool ReadResolution(UserType* output) const
    {
        auto data_value = data_->resolution;
        return mojo::internal::Deserialize<::blink::mojom::HeavyAdResolutionStatus>(data_value, output);
    }
    HeavyAdResolutionStatus resolution() const
    {
        return ::mojo::internal::ToKnownEnumValueHelper(static_cast<::blink::mojom::HeavyAdResolutionStatus>(data_->resolution));
    }
    template <typename UserType> [[nodiscard]] bool ReadReason(UserType* output) const
    {
        auto data_value = data_->reason;
        return mojo::internal::Deserialize<::blink::mojom::HeavyAdReason>(data_value, output);
    }
    HeavyAdReason reason() const
    {
        return ::mojo::internal::ToKnownEnumValueHelper(static_cast<::blink::mojom::HeavyAdReason>(data_->reason));
    }
    inline void GetFrameDataView(AffectedFrameDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadFrame(UserType* output)
    {

        auto* pointer = data_->frame.Get();
        return mojo::internal::Deserialize<::blink::mojom::AffectedFrameDataView>(pointer, output, message_);
    }

private:
    internal::HeavyAdIssueDetails_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class AttributionReportingIssueDetailsDataView {
public:
    AttributionReportingIssueDetailsDataView() = default;

    AttributionReportingIssueDetailsDataView(internal::AttributionReportingIssueDetails_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    template <typename UserType> [[nodiscard]] bool ReadViolationType(UserType* output) const
    {
        auto data_value = data_->violation_type;
        return mojo::internal::Deserialize<::blink::mojom::AttributionReportingIssueType>(data_value, output);
    }
    AttributionReportingIssueType violation_type() const
    {
        return ::mojo::internal::ToKnownEnumValueHelper(static_cast<::blink::mojom::AttributionReportingIssueType>(data_->violation_type));
    }
    inline void GetRequestDataView(AffectedRequestDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadRequest(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::blink::mojom::AffectedRequestDataView, UserType>(),
            "Attempting to read the optional `request` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadRequest` instead "
            "of `ReadRequest if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->request.Get();
        return mojo::internal::Deserialize<::blink::mojom::AffectedRequestDataView>(pointer, output, message_);
    }
    inline void GetInvalidParameterDataView(mojo::StringDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadInvalidParameter(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<mojo::StringDataView, UserType>(),
            "Attempting to read the optional `invalid_parameter` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadInvalidParameter` instead "
            "of `ReadInvalidParameter if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->invalid_parameter.Get();
        return mojo::internal::Deserialize<mojo::StringDataView>(pointer, output, message_);
    }

private:
    internal::AttributionReportingIssueDetails_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class MixedContentIssueDetailsDataView {
public:
    MixedContentIssueDetailsDataView() = default;

    MixedContentIssueDetailsDataView(internal::MixedContentIssueDetails_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    template <typename UserType> [[nodiscard]] bool ReadRequestContext(UserType* output) const
    {
        auto data_value = data_->request_context;
        return mojo::internal::Deserialize<::blink::mojom::RequestContextType>(data_value, output);
    }
    ::blink::mojom::RequestContextType request_context() const
    {
        return ::mojo::internal::ToKnownEnumValueHelper(static_cast<::blink::mojom::RequestContextType>(data_->request_context));
    }
    template <typename UserType> [[nodiscard]] bool ReadResolutionStatus(UserType* output) const
    {
        auto data_value = data_->resolution_status;
        return mojo::internal::Deserialize<::blink::mojom::MixedContentResolutionStatus>(data_value, output);
    }
    MixedContentResolutionStatus resolution_status() const
    {
        return ::mojo::internal::ToKnownEnumValueHelper(static_cast<::blink::mojom::MixedContentResolutionStatus>(data_->resolution_status));
    }
    inline void GetInsecureUrlDataView(mojo::StringDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadInsecureUrl(UserType* output)
    {

        auto* pointer = data_->insecure_url.Get();
        return mojo::internal::Deserialize<mojo::StringDataView>(pointer, output, message_);
    }
    inline void GetMainResourceUrlDataView(mojo::StringDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadMainResourceUrl(UserType* output)
    {

        auto* pointer = data_->main_resource_url.Get();
        return mojo::internal::Deserialize<mojo::StringDataView>(pointer, output, message_);
    }
    inline void GetRequestDataView(AffectedRequestDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadRequest(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::blink::mojom::AffectedRequestDataView, UserType>(),
            "Attempting to read the optional `request` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadRequest` instead "
            "of `ReadRequest if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->request.Get();
        return mojo::internal::Deserialize<::blink::mojom::AffectedRequestDataView>(pointer, output, message_);
    }
    inline void GetFrameDataView(AffectedFrameDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadFrame(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::blink::mojom::AffectedFrameDataView, UserType>(),
            "Attempting to read the optional `frame` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadFrame` instead "
            "of `ReadFrame if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->frame.Get();
        return mojo::internal::Deserialize<::blink::mojom::AffectedFrameDataView>(pointer, output, message_);
    }

private:
    internal::MixedContentIssueDetails_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class ContentSecurityPolicyIssueDetailsDataView {
public:
    ContentSecurityPolicyIssueDetailsDataView() = default;

    ContentSecurityPolicyIssueDetailsDataView(internal::ContentSecurityPolicyIssueDetails_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetBlockedUrlDataView(::url::mojom::UrlDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadBlockedUrl(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::url::mojom::UrlDataView, UserType>(),
            "Attempting to read the optional `blocked_url` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadBlockedUrl` instead "
            "of `ReadBlockedUrl if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->blocked_url.Get();
        return mojo::internal::Deserialize<::url::mojom::UrlDataView>(pointer, output, message_);
    }
    inline void GetViolatedDirectiveDataView(mojo::StringDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadViolatedDirective(UserType* output)
    {

        auto* pointer = data_->violated_directive.Get();
        return mojo::internal::Deserialize<mojo::StringDataView>(pointer, output, message_);
    }
    bool is_report_only() const
    {
        return data_->is_report_only;
    }
    template <typename UserType> [[nodiscard]] bool ReadContentSecurityPolicyViolationType(UserType* output) const
    {
        auto data_value = data_->content_security_policy_violation_type;
        return mojo::internal::Deserialize<::blink::mojom::ContentSecurityPolicyViolationType>(data_value, output);
    }
    ContentSecurityPolicyViolationType content_security_policy_violation_type() const
    {
        return ::mojo::internal::ToKnownEnumValueHelper(
            static_cast<::blink::mojom::ContentSecurityPolicyViolationType>(data_->content_security_policy_violation_type));
    }
    inline void GetFrameAncestorDataView(AffectedFrameDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadFrameAncestor(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::blink::mojom::AffectedFrameDataView, UserType>(),
            "Attempting to read the optional `frame_ancestor` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadFrameAncestor` instead "
            "of `ReadFrameAncestor if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->frame_ancestor.Get();
        return mojo::internal::Deserialize<::blink::mojom::AffectedFrameDataView>(pointer, output, message_);
    }
    inline void GetAffectedLocationDataView(AffectedLocationDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadAffectedLocation(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::blink::mojom::AffectedLocationDataView, UserType>(),
            "Attempting to read the optional `affected_location` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadAffectedLocation` instead "
            "of `ReadAffectedLocation if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->affected_location.Get();
        return mojo::internal::Deserialize<::blink::mojom::AffectedLocationDataView>(pointer, output, message_);
    }
    int32_t violating_node_id() const
    {
        return data_->violating_node_id;
    }

private:
    internal::ContentSecurityPolicyIssueDetails_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class CookieIssueDetailsDataView {
public:
    CookieIssueDetailsDataView() = default;

    CookieIssueDetailsDataView(internal::CookieIssueDetails_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetCookieDataView(AffectedCookieDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadCookie(UserType* output)
    {

        auto* pointer = data_->cookie.Get();
        return mojo::internal::Deserialize<::blink::mojom::AffectedCookieDataView>(pointer, output, message_);
    }
    inline void GetExclusionReasonDataView(mojo::ArrayDataView<CookieExclusionReason>* output);

    template <typename UserType> [[nodiscard]] bool ReadExclusionReason(UserType* output)
    {

        auto* pointer = data_->exclusion_reason.Get();
        return mojo::internal::Deserialize<mojo::ArrayDataView<::blink::mojom::CookieExclusionReason>>(pointer, output, message_);
    }
    inline void GetWarningReasonDataView(mojo::ArrayDataView<CookieWarningReason>* output);

    template <typename UserType> [[nodiscard]] bool ReadWarningReason(UserType* output)
    {

        auto* pointer = data_->warning_reason.Get();
        return mojo::internal::Deserialize<mojo::ArrayDataView<::blink::mojom::CookieWarningReason>>(pointer, output, message_);
    }
    template <typename UserType> [[nodiscard]] bool ReadOperation(UserType* output) const
    {
        auto data_value = data_->operation;
        return mojo::internal::Deserialize<::blink::mojom::CookieOperation>(data_value, output);
    }
    CookieOperation operation() const
    {
        return ::mojo::internal::ToKnownEnumValueHelper(static_cast<::blink::mojom::CookieOperation>(data_->operation));
    }
    inline void GetSiteForCookiesDataView(::url::mojom::UrlDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadSiteForCookies(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::url::mojom::UrlDataView, UserType>(),
            "Attempting to read the optional `site_for_cookies` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadSiteForCookies` instead "
            "of `ReadSiteForCookies if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->site_for_cookies.Get();
        return mojo::internal::Deserialize<::url::mojom::UrlDataView>(pointer, output, message_);
    }
    inline void GetCookieUrlDataView(::url::mojom::UrlDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadCookieUrl(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::url::mojom::UrlDataView, UserType>(),
            "Attempting to read the optional `cookie_url` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadCookieUrl` instead "
            "of `ReadCookieUrl if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->cookie_url.Get();
        return mojo::internal::Deserialize<::url::mojom::UrlDataView>(pointer, output, message_);
    }
    inline void GetRequestDataView(AffectedRequestDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadRequest(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::blink::mojom::AffectedRequestDataView, UserType>(),
            "Attempting to read the optional `request` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadRequest` instead "
            "of `ReadRequest if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->request.Get();
        return mojo::internal::Deserialize<::blink::mojom::AffectedRequestDataView>(pointer, output, message_);
    }

private:
    internal::CookieIssueDetails_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class SharedArrayBufferIssueDetailsDataView {
public:
    SharedArrayBufferIssueDetailsDataView() = default;

    SharedArrayBufferIssueDetailsDataView(internal::SharedArrayBufferIssueDetails_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetAffectedLocationDataView(AffectedLocationDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadAffectedLocation(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::blink::mojom::AffectedLocationDataView, UserType>(),
            "Attempting to read the optional `affected_location` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadAffectedLocation` instead "
            "of `ReadAffectedLocation if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->affected_location.Get();
        return mojo::internal::Deserialize<::blink::mojom::AffectedLocationDataView>(pointer, output, message_);
    }
    bool is_warning() const
    {
        return data_->is_warning;
    }
    template <typename UserType> [[nodiscard]] bool ReadType(UserType* output) const
    {
        auto data_value = data_->type;
        return mojo::internal::Deserialize<::blink::mojom::SharedArrayBufferIssueType>(data_value, output);
    }
    SharedArrayBufferIssueType type() const
    {
        return ::mojo::internal::ToKnownEnumValueHelper(static_cast<::blink::mojom::SharedArrayBufferIssueType>(data_->type));
    }

private:
    internal::SharedArrayBufferIssueDetails_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class LowTextContrastIssueDataView {
public:
    LowTextContrastIssueDataView() = default;

    LowTextContrastIssueDataView(internal::LowTextContrastIssue_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    int32_t violating_node_id() const
    {
        return data_->violating_node_id;
    }
    inline void GetViolatingNodeSelectorDataView(mojo::StringDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadViolatingNodeSelector(UserType* output)
    {

        auto* pointer = data_->violating_node_selector.Get();
        return mojo::internal::Deserialize<mojo::StringDataView>(pointer, output, message_);
    }
    float contrast_ratio() const
    {
        return data_->contrast_ratio;
    }
    float threshold_aa() const
    {
        return data_->threshold_aa;
    }
    float threshold_aaa() const
    {
        return data_->threshold_aaa;
    }
    inline void GetFontSizeDataView(mojo::StringDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadFontSize(UserType* output)
    {

        auto* pointer = data_->font_size.Get();
        return mojo::internal::Deserialize<mojo::StringDataView>(pointer, output, message_);
    }
    inline void GetFontWeightDataView(mojo::StringDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadFontWeight(UserType* output)
    {

        auto* pointer = data_->font_weight.Get();
        return mojo::internal::Deserialize<mojo::StringDataView>(pointer, output, message_);
    }

private:
    internal::LowTextContrastIssue_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class FederatedAuthRequestIssueDetailsDataView {
public:
    FederatedAuthRequestIssueDetailsDataView() = default;

    FederatedAuthRequestIssueDetailsDataView(internal::FederatedAuthRequestIssueDetails_Data* data, mojo::Message* message)
        : data_(data)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    template <typename UserType> [[nodiscard]] bool ReadStatus(UserType* output) const
    {
        auto data_value = data_->status;
        return mojo::internal::Deserialize<::blink::mojom::FederatedAuthRequestResult>(data_value, output);
    }
    FederatedAuthRequestResult status() const
    {
        return ::mojo::internal::ToKnownEnumValueHelper(static_cast<::blink::mojom::FederatedAuthRequestResult>(data_->status));
    }

private:
    internal::FederatedAuthRequestIssueDetails_Data* data_ = nullptr;
};

class FederatedAuthUserInfoRequestIssueDetailsDataView {
public:
    FederatedAuthUserInfoRequestIssueDetailsDataView() = default;

    FederatedAuthUserInfoRequestIssueDetailsDataView(internal::FederatedAuthUserInfoRequestIssueDetails_Data* data, mojo::Message* message)
        : data_(data)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    template <typename UserType> [[nodiscard]] bool ReadStatus(UserType* output) const
    {
        auto data_value = data_->status;
        return mojo::internal::Deserialize<::blink::mojom::FederatedAuthUserInfoRequestResult>(data_value, output);
    }
    FederatedAuthUserInfoRequestResult status() const
    {
        return ::mojo::internal::ToKnownEnumValueHelper(static_cast<::blink::mojom::FederatedAuthUserInfoRequestResult>(data_->status));
    }

private:
    internal::FederatedAuthUserInfoRequestIssueDetails_Data* data_ = nullptr;
};

class BounceTrackingIssueDetailsDataView {
public:
    BounceTrackingIssueDetailsDataView() = default;

    BounceTrackingIssueDetailsDataView(internal::BounceTrackingIssueDetails_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetTrackingSitesDataView(mojo::ArrayDataView<mojo::StringDataView>* output);

    template <typename UserType> [[nodiscard]] bool ReadTrackingSites(UserType* output)
    {

        auto* pointer = data_->tracking_sites.Get();
        return mojo::internal::Deserialize<mojo::ArrayDataView<mojo::StringDataView>>(pointer, output, message_);
    }

private:
    internal::BounceTrackingIssueDetails_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class CookieDeprecationMetadataIssueDetailsDataView {
public:
    CookieDeprecationMetadataIssueDetailsDataView() = default;

    CookieDeprecationMetadataIssueDetailsDataView(internal::CookieDeprecationMetadataIssueDetails_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetAllowedSitesDataView(mojo::ArrayDataView<mojo::StringDataView>* output);

    template <typename UserType> [[nodiscard]] bool ReadAllowedSites(UserType* output)
    {

        auto* pointer = data_->allowed_sites.Get();
        return mojo::internal::Deserialize<mojo::ArrayDataView<mojo::StringDataView>>(pointer, output, message_);
    }
    uint32_t opt_out_percentage() const
    {
        return data_->opt_out_percentage;
    }
    bool is_opt_out_top_level() const
    {
        return data_->is_opt_out_top_level;
    }
    template <typename UserType> [[nodiscard]] bool ReadOperation(UserType* output) const
    {
        auto data_value = data_->operation;
        return mojo::internal::Deserialize<::blink::mojom::CookieOperation>(data_value, output);
    }
    CookieOperation operation() const
    {
        return ::mojo::internal::ToKnownEnumValueHelper(static_cast<::blink::mojom::CookieOperation>(data_->operation));
    }

private:
    internal::CookieDeprecationMetadataIssueDetails_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class GenericIssueDetailsDataView {
public:
    GenericIssueDetailsDataView() = default;

    GenericIssueDetailsDataView(internal::GenericIssueDetails_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    template <typename UserType> [[nodiscard]] bool ReadErrorType(UserType* output) const
    {
        auto data_value = data_->error_type;
        return mojo::internal::Deserialize<::blink::mojom::GenericIssueErrorType>(data_value, output);
    }
    GenericIssueErrorType error_type() const
    {
        return ::mojo::internal::ToKnownEnumValueHelper(static_cast<::blink::mojom::GenericIssueErrorType>(data_->error_type));
    }
    inline void GetFrameIdDataView(mojo::StringDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadFrameId(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<mojo::StringDataView, UserType>(),
            "Attempting to read the optional `frame_id` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadFrameId` instead "
            "of `ReadFrameId if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->frame_id.Get();
        return mojo::internal::Deserialize<mojo::StringDataView>(pointer, output, message_);
    }
    int32_t violating_node_id() const
    {
        return data_->violating_node_id;
    }
    inline void GetViolatingNodeAttributeDataView(mojo::StringDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadViolatingNodeAttribute(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<mojo::StringDataView, UserType>(),
            "Attempting to read the optional `violating_node_attribute` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadViolatingNodeAttribute` instead "
            "of `ReadViolatingNodeAttribute if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->violating_node_attribute.Get();
        return mojo::internal::Deserialize<mojo::StringDataView>(pointer, output, message_);
    }

private:
    internal::GenericIssueDetails_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class DeprecationIssueDetailsDataView {
public:
    DeprecationIssueDetailsDataView() = default;

    DeprecationIssueDetailsDataView(internal::DeprecationIssueDetails_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    template <typename UserType> [[nodiscard]] bool ReadType(UserType* output) const
    {
        auto data_value = data_->type;
        return mojo::internal::Deserialize<::blink::mojom::DeprecationIssueType>(data_value, output);
    }
    DeprecationIssueType type() const
    {
        return ::mojo::internal::ToKnownEnumValueHelper(static_cast<::blink::mojom::DeprecationIssueType>(data_->type));
    }
    inline void GetAffectedLocationDataView(AffectedLocationDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadAffectedLocation(UserType* output)
    {

        auto* pointer = data_->affected_location.Get();
        return mojo::internal::Deserialize<::blink::mojom::AffectedLocationDataView>(pointer, output, message_);
    }

private:
    internal::DeprecationIssueDetails_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class InspectorIssueDetailsDataView {
public:
    InspectorIssueDetailsDataView() = default;

    InspectorIssueDetailsDataView(internal::InspectorIssueDetails_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetCookieIssueDetailsDataView(CookieIssueDetailsDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadCookieIssueDetails(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::blink::mojom::CookieIssueDetailsDataView, UserType>(),
            "Attempting to read the optional `cookie_issue_details` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadCookieIssueDetails` instead "
            "of `ReadCookieIssueDetails if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->cookie_issue_details.Get();
        return mojo::internal::Deserialize<::blink::mojom::CookieIssueDetailsDataView>(pointer, output, message_);
    }
    inline void GetMixedContentIssueDetailsDataView(MixedContentIssueDetailsDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadMixedContentIssueDetails(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::blink::mojom::MixedContentIssueDetailsDataView, UserType>(),
            "Attempting to read the optional `mixed_content_issue_details` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadMixedContentIssueDetails` instead "
            "of `ReadMixedContentIssueDetails if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->mixed_content_issue_details.Get();
        return mojo::internal::Deserialize<::blink::mojom::MixedContentIssueDetailsDataView>(pointer, output, message_);
    }
    inline void GetBlockedByResponseIssueDetailsDataView(BlockedByResponseIssueDetailsDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadBlockedByResponseIssueDetails(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::blink::mojom::BlockedByResponseIssueDetailsDataView, UserType>(),
            "Attempting to read the optional `blocked_by_response_issue_details` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadBlockedByResponseIssueDetails` instead "
            "of `ReadBlockedByResponseIssueDetails if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->blocked_by_response_issue_details.Get();
        return mojo::internal::Deserialize<::blink::mojom::BlockedByResponseIssueDetailsDataView>(pointer, output, message_);
    }
    inline void GetCspIssueDetailsDataView(ContentSecurityPolicyIssueDetailsDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadCspIssueDetails(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::blink::mojom::ContentSecurityPolicyIssueDetailsDataView, UserType>(),
            "Attempting to read the optional `csp_issue_details` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadCspIssueDetails` instead "
            "of `ReadCspIssueDetails if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->csp_issue_details.Get();
        return mojo::internal::Deserialize<::blink::mojom::ContentSecurityPolicyIssueDetailsDataView>(pointer, output, message_);
    }
    inline void GetSabIssueDetailsDataView(SharedArrayBufferIssueDetailsDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadSabIssueDetails(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::blink::mojom::SharedArrayBufferIssueDetailsDataView, UserType>(),
            "Attempting to read the optional `sab_issue_details` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadSabIssueDetails` instead "
            "of `ReadSabIssueDetails if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->sab_issue_details.Get();
        return mojo::internal::Deserialize<::blink::mojom::SharedArrayBufferIssueDetailsDataView>(pointer, output, message_);
    }
    inline void GetHeavyAdIssueDetailsDataView(HeavyAdIssueDetailsDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadHeavyAdIssueDetails(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::blink::mojom::HeavyAdIssueDetailsDataView, UserType>(),
            "Attempting to read the optional `heavy_ad_issue_details` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadHeavyAdIssueDetails` instead "
            "of `ReadHeavyAdIssueDetails if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->heavy_ad_issue_details.Get();
        return mojo::internal::Deserialize<::blink::mojom::HeavyAdIssueDetailsDataView>(pointer, output, message_);
    }
    inline void GetAttributionReportingIssueDetailsDataView(AttributionReportingIssueDetailsDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadAttributionReportingIssueDetails(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::blink::mojom::AttributionReportingIssueDetailsDataView, UserType>(),
            "Attempting to read the optional `attribution_reporting_issue_details` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadAttributionReportingIssueDetails` instead "
            "of `ReadAttributionReportingIssueDetails if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->attribution_reporting_issue_details.Get();
        return mojo::internal::Deserialize<::blink::mojom::AttributionReportingIssueDetailsDataView>(pointer, output, message_);
    }
    inline void GetLowTextContrastDetailsDataView(LowTextContrastIssueDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadLowTextContrastDetails(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::blink::mojom::LowTextContrastIssueDataView, UserType>(),
            "Attempting to read the optional `low_text_contrast_details` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadLowTextContrastDetails` instead "
            "of `ReadLowTextContrastDetails if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->low_text_contrast_details.Get();
        return mojo::internal::Deserialize<::blink::mojom::LowTextContrastIssueDataView>(pointer, output, message_);
    }
    inline void GetFederatedAuthRequestDetailsDataView(FederatedAuthRequestIssueDetailsDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadFederatedAuthRequestDetails(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::blink::mojom::FederatedAuthRequestIssueDetailsDataView, UserType>(),
            "Attempting to read the optional `federated_auth_request_details` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadFederatedAuthRequestDetails` instead "
            "of `ReadFederatedAuthRequestDetails if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->federated_auth_request_details.Get();
        return mojo::internal::Deserialize<::blink::mojom::FederatedAuthRequestIssueDetailsDataView>(pointer, output, message_);
    }
    inline void GetBounceTrackingIssueDetailsDataView(BounceTrackingIssueDetailsDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadBounceTrackingIssueDetails(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::blink::mojom::BounceTrackingIssueDetailsDataView, UserType>(),
            "Attempting to read the optional `bounce_tracking_issue_details` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadBounceTrackingIssueDetails` instead "
            "of `ReadBounceTrackingIssueDetails if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->bounce_tracking_issue_details.Get();
        return mojo::internal::Deserialize<::blink::mojom::BounceTrackingIssueDetailsDataView>(pointer, output, message_);
    }
    inline void GetCookieDeprecationMetadataIssueDetailsDataView(CookieDeprecationMetadataIssueDetailsDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadCookieDeprecationMetadataIssueDetails(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::blink::mojom::CookieDeprecationMetadataIssueDetailsDataView, UserType>(),
            "Attempting to read the optional `cookie_deprecation_metadata_issue_details` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadCookieDeprecationMetadataIssueDetails` instead "
            "of `ReadCookieDeprecationMetadataIssueDetails if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->cookie_deprecation_metadata_issue_details.Get();
        return mojo::internal::Deserialize<::blink::mojom::CookieDeprecationMetadataIssueDetailsDataView>(pointer, output, message_);
    }
    inline void GetGenericIssueDetailsDataView(GenericIssueDetailsDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadGenericIssueDetails(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::blink::mojom::GenericIssueDetailsDataView, UserType>(),
            "Attempting to read the optional `generic_issue_details` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadGenericIssueDetails` instead "
            "of `ReadGenericIssueDetails if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->generic_issue_details.Get();
        return mojo::internal::Deserialize<::blink::mojom::GenericIssueDetailsDataView>(pointer, output, message_);
    }
    inline void GetDeprecationIssueDetailsDataView(DeprecationIssueDetailsDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadDeprecationIssueDetails(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::blink::mojom::DeprecationIssueDetailsDataView, UserType>(),
            "Attempting to read the optional `deprecation_issue_details` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadDeprecationIssueDetails` instead "
            "of `ReadDeprecationIssueDetails if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->deprecation_issue_details.Get();
        return mojo::internal::Deserialize<::blink::mojom::DeprecationIssueDetailsDataView>(pointer, output, message_);
    }
    inline void GetFederatedAuthUserInfoRequestDetailsDataView(FederatedAuthUserInfoRequestIssueDetailsDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadFederatedAuthUserInfoRequestDetails(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::blink::mojom::FederatedAuthUserInfoRequestIssueDetailsDataView, UserType>(),
            "Attempting to read the optional `federated_auth_user_info_request_details` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadFederatedAuthUserInfoRequestDetails` instead "
            "of `ReadFederatedAuthUserInfoRequestDetails if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->federated_auth_user_info_request_details.Get();
        return mojo::internal::Deserialize<::blink::mojom::FederatedAuthUserInfoRequestIssueDetailsDataView>(pointer, output, message_);
    }
    inline void GetIssueIdDataView(::mojo_base::mojom::UnguessableTokenDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadIssueId(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::mojo_base::mojom::UnguessableTokenDataView, UserType>(),
            "Attempting to read the optional `issue_id` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadIssueId` instead "
            "of `ReadIssueId if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->issue_id.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::UnguessableTokenDataView>(pointer, output, message_);
    }

private:
    internal::InspectorIssueDetails_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class InspectorIssueInfoDataView {
public:
    InspectorIssueInfoDataView() = default;

    InspectorIssueInfoDataView(internal::InspectorIssueInfo_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    template <typename UserType> [[nodiscard]] bool ReadCode(UserType* output) const
    {
        auto data_value = data_->code;
        return mojo::internal::Deserialize<::blink::mojom::InspectorIssueCode>(data_value, output);
    }
    InspectorIssueCode code() const
    {
        return ::mojo::internal::ToKnownEnumValueHelper(static_cast<::blink::mojom::InspectorIssueCode>(data_->code));
    }
    inline void GetDetailsDataView(InspectorIssueDetailsDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadDetails(UserType* output)
    {

        auto* pointer = data_->details.Get();
        return mojo::internal::Deserialize<::blink::mojom::InspectorIssueDetailsDataView>(pointer, output, message_);
    }

private:
    internal::InspectorIssueInfo_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

} // blink::mojom

namespace std {

template <> struct hash<::blink::mojom::InspectorIssueCode> : public mojo::internal::EnumHashImpl<::blink::mojom::InspectorIssueCode> { };

template <> struct hash<::blink::mojom::HeavyAdResolutionStatus> : public mojo::internal::EnumHashImpl<::blink::mojom::HeavyAdResolutionStatus> { };

template <> struct hash<::blink::mojom::HeavyAdReason> : public mojo::internal::EnumHashImpl<::blink::mojom::HeavyAdReason> { };

template <> struct hash<::blink::mojom::AttributionReportingIssueType> : public mojo::internal::EnumHashImpl<::blink::mojom::AttributionReportingIssueType> { };

template <> struct hash<::blink::mojom::MixedContentResolutionStatus> : public mojo::internal::EnumHashImpl<::blink::mojom::MixedContentResolutionStatus> { };

template <>
struct hash<::blink::mojom::ContentSecurityPolicyViolationType> : public mojo::internal::EnumHashImpl<::blink::mojom::ContentSecurityPolicyViolationType> { };

template <> struct hash<::blink::mojom::CookieOperation> : public mojo::internal::EnumHashImpl<::blink::mojom::CookieOperation> { };

template <> struct hash<::blink::mojom::CookieExclusionReason> : public mojo::internal::EnumHashImpl<::blink::mojom::CookieExclusionReason> { };

template <> struct hash<::blink::mojom::CookieWarningReason> : public mojo::internal::EnumHashImpl<::blink::mojom::CookieWarningReason> { };

template <> struct hash<::blink::mojom::SharedArrayBufferIssueType> : public mojo::internal::EnumHashImpl<::blink::mojom::SharedArrayBufferIssueType> { };

template <> struct hash<::blink::mojom::FederatedAuthRequestResult> : public mojo::internal::EnumHashImpl<::blink::mojom::FederatedAuthRequestResult> { };

template <>
struct hash<::blink::mojom::FederatedAuthUserInfoRequestResult> : public mojo::internal::EnumHashImpl<::blink::mojom::FederatedAuthUserInfoRequestResult> { };

template <> struct hash<::blink::mojom::GenericIssueErrorType> : public mojo::internal::EnumHashImpl<::blink::mojom::GenericIssueErrorType> { };

template <> struct hash<::blink::mojom::DeprecationIssueType> : public mojo::internal::EnumHashImpl<::blink::mojom::DeprecationIssueType> { };

} // namespace std

namespace mojo {

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::InspectorIssueCode, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = EnumTraits<::blink::mojom::InspectorIssueCode, UserType>;

    static void Serialize(UserType input, int32_t* output)
    {
        *output = static_cast<int32_t>(Traits::ToMojom(input));
    }

    static bool Deserialize(int32_t input, UserType* output)
    {
        return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(static_cast<::blink::mojom::InspectorIssueCode>(input)), output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::HeavyAdResolutionStatus, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = EnumTraits<::blink::mojom::HeavyAdResolutionStatus, UserType>;

    static void Serialize(UserType input, int32_t* output)
    {
        *output = static_cast<int32_t>(Traits::ToMojom(input));
    }

    static bool Deserialize(int32_t input, UserType* output)
    {
        return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(static_cast<::blink::mojom::HeavyAdResolutionStatus>(input)), output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::HeavyAdReason, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = EnumTraits<::blink::mojom::HeavyAdReason, UserType>;

    static void Serialize(UserType input, int32_t* output)
    {
        *output = static_cast<int32_t>(Traits::ToMojom(input));
    }

    static bool Deserialize(int32_t input, UserType* output)
    {
        return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(static_cast<::blink::mojom::HeavyAdReason>(input)), output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::AttributionReportingIssueType, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = EnumTraits<::blink::mojom::AttributionReportingIssueType, UserType>;

    static void Serialize(UserType input, int32_t* output)
    {
        *output = static_cast<int32_t>(Traits::ToMojom(input));
    }

    static bool Deserialize(int32_t input, UserType* output)
    {
        return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(static_cast<::blink::mojom::AttributionReportingIssueType>(input)), output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::MixedContentResolutionStatus, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = EnumTraits<::blink::mojom::MixedContentResolutionStatus, UserType>;

    static void Serialize(UserType input, int32_t* output)
    {
        *output = static_cast<int32_t>(Traits::ToMojom(input));
    }

    static bool Deserialize(int32_t input, UserType* output)
    {
        return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(static_cast<::blink::mojom::MixedContentResolutionStatus>(input)), output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::ContentSecurityPolicyViolationType, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = EnumTraits<::blink::mojom::ContentSecurityPolicyViolationType, UserType>;

    static void Serialize(UserType input, int32_t* output)
    {
        *output = static_cast<int32_t>(Traits::ToMojom(input));
    }

    static bool Deserialize(int32_t input, UserType* output)
    {
        return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(static_cast<::blink::mojom::ContentSecurityPolicyViolationType>(input)), output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::CookieOperation, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = EnumTraits<::blink::mojom::CookieOperation, UserType>;

    static void Serialize(UserType input, int32_t* output)
    {
        *output = static_cast<int32_t>(Traits::ToMojom(input));
    }

    static bool Deserialize(int32_t input, UserType* output)
    {
        return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(static_cast<::blink::mojom::CookieOperation>(input)), output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::CookieExclusionReason, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = EnumTraits<::blink::mojom::CookieExclusionReason, UserType>;

    static void Serialize(UserType input, int32_t* output)
    {
        *output = static_cast<int32_t>(Traits::ToMojom(input));
    }

    static bool Deserialize(int32_t input, UserType* output)
    {
        return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(static_cast<::blink::mojom::CookieExclusionReason>(input)), output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::CookieWarningReason, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = EnumTraits<::blink::mojom::CookieWarningReason, UserType>;

    static void Serialize(UserType input, int32_t* output)
    {
        *output = static_cast<int32_t>(Traits::ToMojom(input));
    }

    static bool Deserialize(int32_t input, UserType* output)
    {
        return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(static_cast<::blink::mojom::CookieWarningReason>(input)), output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::SharedArrayBufferIssueType, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = EnumTraits<::blink::mojom::SharedArrayBufferIssueType, UserType>;

    static void Serialize(UserType input, int32_t* output)
    {
        *output = static_cast<int32_t>(Traits::ToMojom(input));
    }

    static bool Deserialize(int32_t input, UserType* output)
    {
        return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(static_cast<::blink::mojom::SharedArrayBufferIssueType>(input)), output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::FederatedAuthRequestResult, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = EnumTraits<::blink::mojom::FederatedAuthRequestResult, UserType>;

    static void Serialize(UserType input, int32_t* output)
    {
        *output = static_cast<int32_t>(Traits::ToMojom(input));
    }

    static bool Deserialize(int32_t input, UserType* output)
    {
        return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(static_cast<::blink::mojom::FederatedAuthRequestResult>(input)), output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::FederatedAuthUserInfoRequestResult, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = EnumTraits<::blink::mojom::FederatedAuthUserInfoRequestResult, UserType>;

    static void Serialize(UserType input, int32_t* output)
    {
        *output = static_cast<int32_t>(Traits::ToMojom(input));
    }

    static bool Deserialize(int32_t input, UserType* output)
    {
        return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(static_cast<::blink::mojom::FederatedAuthUserInfoRequestResult>(input)), output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::GenericIssueErrorType, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = EnumTraits<::blink::mojom::GenericIssueErrorType, UserType>;

    static void Serialize(UserType input, int32_t* output)
    {
        *output = static_cast<int32_t>(Traits::ToMojom(input));
    }

    static bool Deserialize(int32_t input, UserType* output)
    {
        return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(static_cast<::blink::mojom::GenericIssueErrorType>(input)), output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::DeprecationIssueType, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = EnumTraits<::blink::mojom::DeprecationIssueType, UserType>;

    static void Serialize(UserType input, int32_t* output)
    {
        *output = static_cast<int32_t>(Traits::ToMojom(input));
    }

    static bool Deserialize(int32_t input, UserType* output)
    {
        return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(static_cast<::blink::mojom::DeprecationIssueType>(input)), output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::AffectedCookieDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::blink::mojom::AffectedCookieDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::blink::mojom::internal::AffectedCookie_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::name(input)) in_name = Traits::name(input);
        mojo::internal::MessageFragment<typename decltype(fragment->name)::BaseType> name_fragment(fragment.message());
        mojo::internal::Serialize<mojo::StringDataView>(in_name, name_fragment);
        fragment->name.Set(name_fragment.is_null() ? nullptr : name_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->name.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null name in AffectedCookie struct");
        decltype(Traits::path(input)) in_path = Traits::path(input);
        mojo::internal::MessageFragment<typename decltype(fragment->path)::BaseType> path_fragment(fragment.message());
        mojo::internal::Serialize<mojo::StringDataView>(in_path, path_fragment);
        fragment->path.Set(path_fragment.is_null() ? nullptr : path_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->path.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null path in AffectedCookie struct");
        decltype(Traits::domain(input)) in_domain = Traits::domain(input);
        mojo::internal::MessageFragment<typename decltype(fragment->domain)::BaseType> domain_fragment(fragment.message());
        mojo::internal::Serialize<mojo::StringDataView>(in_domain, domain_fragment);
        fragment->domain.Set(domain_fragment.is_null() ? nullptr : domain_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->domain.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null domain in AffectedCookie struct");
    }

    static bool Deserialize(::blink::mojom::internal::AffectedCookie_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::blink::mojom::AffectedCookieDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::AffectedRequestDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::blink::mojom::AffectedRequestDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::blink::mojom::internal::AffectedRequest_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::request_id(input)) in_request_id = Traits::request_id(input);
        mojo::internal::MessageFragment<typename decltype(fragment->request_id)::BaseType> request_id_fragment(fragment.message());
        mojo::internal::Serialize<mojo::StringDataView>(in_request_id, request_id_fragment);
        fragment->request_id.Set(request_id_fragment.is_null() ? nullptr : request_id_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->request_id.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null request_id in AffectedRequest struct");
        decltype(Traits::url(input)) in_url = Traits::url(input);
        mojo::internal::MessageFragment<typename decltype(fragment->url)::BaseType> url_fragment(fragment.message());
        mojo::internal::Serialize<mojo::StringDataView>(in_url, url_fragment);
        fragment->url.Set(url_fragment.is_null() ? nullptr : url_fragment.data());
    }

    static bool Deserialize(::blink::mojom::internal::AffectedRequest_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::blink::mojom::AffectedRequestDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::AffectedFrameDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::blink::mojom::AffectedFrameDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::blink::mojom::internal::AffectedFrame_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::frame_id(input)) in_frame_id = Traits::frame_id(input);
        mojo::internal::MessageFragment<typename decltype(fragment->frame_id)::BaseType> frame_id_fragment(fragment.message());
        mojo::internal::Serialize<mojo::StringDataView>(in_frame_id, frame_id_fragment);
        fragment->frame_id.Set(frame_id_fragment.is_null() ? nullptr : frame_id_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->frame_id.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null frame_id in AffectedFrame struct");
    }

    static bool Deserialize(::blink::mojom::internal::AffectedFrame_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::blink::mojom::AffectedFrameDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::AffectedLocationDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::blink::mojom::AffectedLocationDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::blink::mojom::internal::AffectedLocation_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::script_id(input)) in_script_id = Traits::script_id(input);
        mojo::internal::MessageFragment<typename decltype(fragment->script_id)::BaseType> script_id_fragment(fragment.message());
        mojo::internal::Serialize<mojo::StringDataView>(in_script_id, script_id_fragment);
        fragment->script_id.Set(script_id_fragment.is_null() ? nullptr : script_id_fragment.data());
        decltype(Traits::url(input)) in_url = Traits::url(input);
        mojo::internal::MessageFragment<typename decltype(fragment->url)::BaseType> url_fragment(fragment.message());
        mojo::internal::Serialize<mojo::StringDataView>(in_url, url_fragment);
        fragment->url.Set(url_fragment.is_null() ? nullptr : url_fragment.data());
        fragment->line = Traits::line(input);
        fragment->column = Traits::column(input);
    }

    static bool Deserialize(::blink::mojom::internal::AffectedLocation_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::blink::mojom::AffectedLocationDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::BlockedByResponseIssueDetailsDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::blink::mojom::BlockedByResponseIssueDetailsDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::blink::mojom::internal::BlockedByResponseIssueDetails_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::request(input)) in_request = Traits::request(input);
        mojo::internal::MessageFragment<typename decltype(fragment->request)::BaseType> request_fragment(fragment.message());
        mojo::internal::Serialize<::blink::mojom::AffectedRequestDataView>(in_request, request_fragment);
        fragment->request.Set(request_fragment.is_null() ? nullptr : request_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->request.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null request in BlockedByResponseIssueDetails struct");
        decltype(Traits::parentFrame(input)) in_parentFrame = Traits::parentFrame(input);
        mojo::internal::MessageFragment<typename decltype(fragment->parentFrame)::BaseType> parentFrame_fragment(fragment.message());
        mojo::internal::Serialize<::blink::mojom::AffectedFrameDataView>(in_parentFrame, parentFrame_fragment);
        fragment->parentFrame.Set(parentFrame_fragment.is_null() ? nullptr : parentFrame_fragment.data());
        decltype(Traits::blockedFrame(input)) in_blockedFrame = Traits::blockedFrame(input);
        mojo::internal::MessageFragment<typename decltype(fragment->blockedFrame)::BaseType> blockedFrame_fragment(fragment.message());
        mojo::internal::Serialize<::blink::mojom::AffectedFrameDataView>(in_blockedFrame, blockedFrame_fragment);
        fragment->blockedFrame.Set(blockedFrame_fragment.is_null() ? nullptr : blockedFrame_fragment.data());
        mojo::internal::Serialize<::network::mojom::BlockedByResponseReason>(Traits::reason(input), &fragment->reason);
    }

    static bool Deserialize(::blink::mojom::internal::BlockedByResponseIssueDetails_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::blink::mojom::BlockedByResponseIssueDetailsDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::HeavyAdIssueDetailsDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::blink::mojom::HeavyAdIssueDetailsDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::blink::mojom::internal::HeavyAdIssueDetails_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        mojo::internal::Serialize<::blink::mojom::HeavyAdResolutionStatus>(Traits::resolution(input), &fragment->resolution);
        mojo::internal::Serialize<::blink::mojom::HeavyAdReason>(Traits::reason(input), &fragment->reason);
        decltype(Traits::frame(input)) in_frame = Traits::frame(input);
        mojo::internal::MessageFragment<typename decltype(fragment->frame)::BaseType> frame_fragment(fragment.message());
        mojo::internal::Serialize<::blink::mojom::AffectedFrameDataView>(in_frame, frame_fragment);
        fragment->frame.Set(frame_fragment.is_null() ? nullptr : frame_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->frame.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null frame in HeavyAdIssueDetails struct");
    }

    static bool Deserialize(::blink::mojom::internal::HeavyAdIssueDetails_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::blink::mojom::HeavyAdIssueDetailsDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::AttributionReportingIssueDetailsDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::blink::mojom::AttributionReportingIssueDetailsDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::blink::mojom::internal::AttributionReportingIssueDetails_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        mojo::internal::Serialize<::blink::mojom::AttributionReportingIssueType>(Traits::violation_type(input), &fragment->violation_type);
        decltype(Traits::request(input)) in_request = Traits::request(input);
        mojo::internal::MessageFragment<typename decltype(fragment->request)::BaseType> request_fragment(fragment.message());
        mojo::internal::Serialize<::blink::mojom::AffectedRequestDataView>(in_request, request_fragment);
        fragment->request.Set(request_fragment.is_null() ? nullptr : request_fragment.data());
        decltype(Traits::invalid_parameter(input)) in_invalid_parameter = Traits::invalid_parameter(input);
        mojo::internal::MessageFragment<typename decltype(fragment->invalid_parameter)::BaseType> invalid_parameter_fragment(fragment.message());
        mojo::internal::Serialize<mojo::StringDataView>(in_invalid_parameter, invalid_parameter_fragment);
        fragment->invalid_parameter.Set(invalid_parameter_fragment.is_null() ? nullptr : invalid_parameter_fragment.data());
    }

    static bool Deserialize(::blink::mojom::internal::AttributionReportingIssueDetails_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::blink::mojom::AttributionReportingIssueDetailsDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::MixedContentIssueDetailsDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::blink::mojom::MixedContentIssueDetailsDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::blink::mojom::internal::MixedContentIssueDetails_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        mojo::internal::Serialize<::blink::mojom::RequestContextType>(Traits::request_context(input), &fragment->request_context);
        mojo::internal::Serialize<::blink::mojom::MixedContentResolutionStatus>(Traits::resolution_status(input), &fragment->resolution_status);
        decltype(Traits::insecure_url(input)) in_insecure_url = Traits::insecure_url(input);
        mojo::internal::MessageFragment<typename decltype(fragment->insecure_url)::BaseType> insecure_url_fragment(fragment.message());
        mojo::internal::Serialize<mojo::StringDataView>(in_insecure_url, insecure_url_fragment);
        fragment->insecure_url.Set(insecure_url_fragment.is_null() ? nullptr : insecure_url_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->insecure_url.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null insecure_url in MixedContentIssueDetails struct");
        decltype(Traits::main_resource_url(input)) in_main_resource_url = Traits::main_resource_url(input);
        mojo::internal::MessageFragment<typename decltype(fragment->main_resource_url)::BaseType> main_resource_url_fragment(fragment.message());
        mojo::internal::Serialize<mojo::StringDataView>(in_main_resource_url, main_resource_url_fragment);
        fragment->main_resource_url.Set(main_resource_url_fragment.is_null() ? nullptr : main_resource_url_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(fragment->main_resource_url.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null main_resource_url in MixedContentIssueDetails struct");
        decltype(Traits::request(input)) in_request = Traits::request(input);
        mojo::internal::MessageFragment<typename decltype(fragment->request)::BaseType> request_fragment(fragment.message());
        mojo::internal::Serialize<::blink::mojom::AffectedRequestDataView>(in_request, request_fragment);
        fragment->request.Set(request_fragment.is_null() ? nullptr : request_fragment.data());
        decltype(Traits::frame(input)) in_frame = Traits::frame(input);
        mojo::internal::MessageFragment<typename decltype(fragment->frame)::BaseType> frame_fragment(fragment.message());
        mojo::internal::Serialize<::blink::mojom::AffectedFrameDataView>(in_frame, frame_fragment);
        fragment->frame.Set(frame_fragment.is_null() ? nullptr : frame_fragment.data());
    }

    static bool Deserialize(::blink::mojom::internal::MixedContentIssueDetails_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::blink::mojom::MixedContentIssueDetailsDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::ContentSecurityPolicyIssueDetailsDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::blink::mojom::ContentSecurityPolicyIssueDetailsDataView, UserType>;

    static void Serialize(
        MaybeConstUserType& input, mojo::internal::MessageFragment<::blink::mojom::internal::ContentSecurityPolicyIssueDetails_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::blocked_url(input)) in_blocked_url = Traits::blocked_url(input);
        mojo::internal::MessageFragment<typename decltype(fragment->blocked_url)::BaseType> blocked_url_fragment(fragment.message());
        mojo::internal::Serialize<::url::mojom::UrlDataView>(in_blocked_url, blocked_url_fragment);
        fragment->blocked_url.Set(blocked_url_fragment.is_null() ? nullptr : blocked_url_fragment.data());
        decltype(Traits::violated_directive(input)) in_violated_directive = Traits::violated_directive(input);
        mojo::internal::MessageFragment<typename decltype(fragment->violated_directive)::BaseType> violated_directive_fragment(fragment.message());
        mojo::internal::Serialize<mojo::StringDataView>(in_violated_directive, violated_directive_fragment);
        fragment->violated_directive.Set(violated_directive_fragment.is_null() ? nullptr : violated_directive_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(fragment->violated_directive.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null violated_directive in ContentSecurityPolicyIssueDetails struct");
        fragment->is_report_only = Traits::is_report_only(input);
        mojo::internal::Serialize<::blink::mojom::ContentSecurityPolicyViolationType>(
            Traits::content_security_policy_violation_type(input), &fragment->content_security_policy_violation_type);
        decltype(Traits::frame_ancestor(input)) in_frame_ancestor = Traits::frame_ancestor(input);
        mojo::internal::MessageFragment<typename decltype(fragment->frame_ancestor)::BaseType> frame_ancestor_fragment(fragment.message());
        mojo::internal::Serialize<::blink::mojom::AffectedFrameDataView>(in_frame_ancestor, frame_ancestor_fragment);
        fragment->frame_ancestor.Set(frame_ancestor_fragment.is_null() ? nullptr : frame_ancestor_fragment.data());
        decltype(Traits::affected_location(input)) in_affected_location = Traits::affected_location(input);
        mojo::internal::MessageFragment<typename decltype(fragment->affected_location)::BaseType> affected_location_fragment(fragment.message());
        mojo::internal::Serialize<::blink::mojom::AffectedLocationDataView>(in_affected_location, affected_location_fragment);
        fragment->affected_location.Set(affected_location_fragment.is_null() ? nullptr : affected_location_fragment.data());
        fragment->violating_node_id = Traits::violating_node_id(input);
    }

    static bool Deserialize(::blink::mojom::internal::ContentSecurityPolicyIssueDetails_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::blink::mojom::ContentSecurityPolicyIssueDetailsDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::CookieIssueDetailsDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::blink::mojom::CookieIssueDetailsDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::blink::mojom::internal::CookieIssueDetails_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::cookie(input)) in_cookie = Traits::cookie(input);
        mojo::internal::MessageFragment<typename decltype(fragment->cookie)::BaseType> cookie_fragment(fragment.message());
        mojo::internal::Serialize<::blink::mojom::AffectedCookieDataView>(in_cookie, cookie_fragment);
        fragment->cookie.Set(cookie_fragment.is_null() ? nullptr : cookie_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->cookie.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null cookie in CookieIssueDetails struct");
        decltype(Traits::exclusion_reason(input)) in_exclusion_reason = Traits::exclusion_reason(input);
        mojo::internal::MessageFragment<typename decltype(fragment->exclusion_reason)::BaseType> exclusion_reason_fragment(fragment.message());
        constexpr const mojo::internal::ContainerValidateParams& exclusion_reason_validate_params
            = mojo::internal::GetArrayOfEnumsValidator<0, false, ::blink::mojom::internal::CookieExclusionReason_Data::Validate>();
        mojo::internal::Serialize<mojo::ArrayDataView<::blink::mojom::CookieExclusionReason>>(
            in_exclusion_reason, exclusion_reason_fragment, &exclusion_reason_validate_params);
        fragment->exclusion_reason.Set(exclusion_reason_fragment.is_null() ? nullptr : exclusion_reason_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(fragment->exclusion_reason.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null exclusion_reason in CookieIssueDetails struct");
        decltype(Traits::warning_reason(input)) in_warning_reason = Traits::warning_reason(input);
        mojo::internal::MessageFragment<typename decltype(fragment->warning_reason)::BaseType> warning_reason_fragment(fragment.message());
        constexpr const mojo::internal::ContainerValidateParams& warning_reason_validate_params
            = mojo::internal::GetArrayOfEnumsValidator<0, false, ::blink::mojom::internal::CookieWarningReason_Data::Validate>();
        mojo::internal::Serialize<mojo::ArrayDataView<::blink::mojom::CookieWarningReason>>(
            in_warning_reason, warning_reason_fragment, &warning_reason_validate_params);
        fragment->warning_reason.Set(warning_reason_fragment.is_null() ? nullptr : warning_reason_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->warning_reason.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null warning_reason in CookieIssueDetails struct");
        mojo::internal::Serialize<::blink::mojom::CookieOperation>(Traits::operation(input), &fragment->operation);
        decltype(Traits::site_for_cookies(input)) in_site_for_cookies = Traits::site_for_cookies(input);
        mojo::internal::MessageFragment<typename decltype(fragment->site_for_cookies)::BaseType> site_for_cookies_fragment(fragment.message());
        mojo::internal::Serialize<::url::mojom::UrlDataView>(in_site_for_cookies, site_for_cookies_fragment);
        fragment->site_for_cookies.Set(site_for_cookies_fragment.is_null() ? nullptr : site_for_cookies_fragment.data());
        decltype(Traits::cookie_url(input)) in_cookie_url = Traits::cookie_url(input);
        mojo::internal::MessageFragment<typename decltype(fragment->cookie_url)::BaseType> cookie_url_fragment(fragment.message());
        mojo::internal::Serialize<::url::mojom::UrlDataView>(in_cookie_url, cookie_url_fragment);
        fragment->cookie_url.Set(cookie_url_fragment.is_null() ? nullptr : cookie_url_fragment.data());
        decltype(Traits::request(input)) in_request = Traits::request(input);
        mojo::internal::MessageFragment<typename decltype(fragment->request)::BaseType> request_fragment(fragment.message());
        mojo::internal::Serialize<::blink::mojom::AffectedRequestDataView>(in_request, request_fragment);
        fragment->request.Set(request_fragment.is_null() ? nullptr : request_fragment.data());
    }

    static bool Deserialize(::blink::mojom::internal::CookieIssueDetails_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::blink::mojom::CookieIssueDetailsDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::SharedArrayBufferIssueDetailsDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::blink::mojom::SharedArrayBufferIssueDetailsDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::blink::mojom::internal::SharedArrayBufferIssueDetails_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::affected_location(input)) in_affected_location = Traits::affected_location(input);
        mojo::internal::MessageFragment<typename decltype(fragment->affected_location)::BaseType> affected_location_fragment(fragment.message());
        mojo::internal::Serialize<::blink::mojom::AffectedLocationDataView>(in_affected_location, affected_location_fragment);
        fragment->affected_location.Set(affected_location_fragment.is_null() ? nullptr : affected_location_fragment.data());
        fragment->is_warning = Traits::is_warning(input);
        mojo::internal::Serialize<::blink::mojom::SharedArrayBufferIssueType>(Traits::type(input), &fragment->type);
    }

    static bool Deserialize(::blink::mojom::internal::SharedArrayBufferIssueDetails_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::blink::mojom::SharedArrayBufferIssueDetailsDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::LowTextContrastIssueDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::blink::mojom::LowTextContrastIssueDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::blink::mojom::internal::LowTextContrastIssue_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        fragment->violating_node_id = Traits::violating_node_id(input);
        decltype(Traits::violating_node_selector(input)) in_violating_node_selector = Traits::violating_node_selector(input);
        mojo::internal::MessageFragment<typename decltype(fragment->violating_node_selector)::BaseType> violating_node_selector_fragment(fragment.message());
        mojo::internal::Serialize<mojo::StringDataView>(in_violating_node_selector, violating_node_selector_fragment);
        fragment->violating_node_selector.Set(violating_node_selector_fragment.is_null() ? nullptr : violating_node_selector_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(fragment->violating_node_selector.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null violating_node_selector in LowTextContrastIssue struct");
        fragment->contrast_ratio = Traits::contrast_ratio(input);
        fragment->threshold_aa = Traits::threshold_aa(input);
        fragment->threshold_aaa = Traits::threshold_aaa(input);
        decltype(Traits::font_size(input)) in_font_size = Traits::font_size(input);
        mojo::internal::MessageFragment<typename decltype(fragment->font_size)::BaseType> font_size_fragment(fragment.message());
        mojo::internal::Serialize<mojo::StringDataView>(in_font_size, font_size_fragment);
        fragment->font_size.Set(font_size_fragment.is_null() ? nullptr : font_size_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->font_size.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null font_size in LowTextContrastIssue struct");
        decltype(Traits::font_weight(input)) in_font_weight = Traits::font_weight(input);
        mojo::internal::MessageFragment<typename decltype(fragment->font_weight)::BaseType> font_weight_fragment(fragment.message());
        mojo::internal::Serialize<mojo::StringDataView>(in_font_weight, font_weight_fragment);
        fragment->font_weight.Set(font_weight_fragment.is_null() ? nullptr : font_weight_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->font_weight.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null font_weight in LowTextContrastIssue struct");
    }

    static bool Deserialize(::blink::mojom::internal::LowTextContrastIssue_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::blink::mojom::LowTextContrastIssueDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::FederatedAuthRequestIssueDetailsDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::blink::mojom::FederatedAuthRequestIssueDetailsDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::blink::mojom::internal::FederatedAuthRequestIssueDetails_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        mojo::internal::Serialize<::blink::mojom::FederatedAuthRequestResult>(Traits::status(input), &fragment->status);
    }

    static bool Deserialize(::blink::mojom::internal::FederatedAuthRequestIssueDetails_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::blink::mojom::FederatedAuthRequestIssueDetailsDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::FederatedAuthUserInfoRequestIssueDetailsDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::blink::mojom::FederatedAuthUserInfoRequestIssueDetailsDataView, UserType>;

    static void Serialize(
        MaybeConstUserType& input, mojo::internal::MessageFragment<::blink::mojom::internal::FederatedAuthUserInfoRequestIssueDetails_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        mojo::internal::Serialize<::blink::mojom::FederatedAuthUserInfoRequestResult>(Traits::status(input), &fragment->status);
    }

    static bool Deserialize(::blink::mojom::internal::FederatedAuthUserInfoRequestIssueDetails_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::blink::mojom::FederatedAuthUserInfoRequestIssueDetailsDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::BounceTrackingIssueDetailsDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::blink::mojom::BounceTrackingIssueDetailsDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::blink::mojom::internal::BounceTrackingIssueDetails_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::tracking_sites(input)) in_tracking_sites = Traits::tracking_sites(input);
        mojo::internal::MessageFragment<typename decltype(fragment->tracking_sites)::BaseType> tracking_sites_fragment(fragment.message());
        constexpr const mojo::internal::ContainerValidateParams& tracking_sites_validate_params
            = mojo::internal::GetArrayValidator<0, false, &mojo::internal::GetArrayValidator<0, false, nullptr>()>();
        mojo::internal::Serialize<mojo::ArrayDataView<mojo::StringDataView>>(in_tracking_sites, tracking_sites_fragment, &tracking_sites_validate_params);
        fragment->tracking_sites.Set(tracking_sites_fragment.is_null() ? nullptr : tracking_sites_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(fragment->tracking_sites.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null tracking_sites in BounceTrackingIssueDetails struct");
    }

    static bool Deserialize(::blink::mojom::internal::BounceTrackingIssueDetails_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::blink::mojom::BounceTrackingIssueDetailsDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::CookieDeprecationMetadataIssueDetailsDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::blink::mojom::CookieDeprecationMetadataIssueDetailsDataView, UserType>;

    static void Serialize(
        MaybeConstUserType& input, mojo::internal::MessageFragment<::blink::mojom::internal::CookieDeprecationMetadataIssueDetails_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::allowed_sites(input)) in_allowed_sites = Traits::allowed_sites(input);
        mojo::internal::MessageFragment<typename decltype(fragment->allowed_sites)::BaseType> allowed_sites_fragment(fragment.message());
        constexpr const mojo::internal::ContainerValidateParams& allowed_sites_validate_params
            = mojo::internal::GetArrayValidator<0, false, &mojo::internal::GetArrayValidator<0, false, nullptr>()>();
        mojo::internal::Serialize<mojo::ArrayDataView<mojo::StringDataView>>(in_allowed_sites, allowed_sites_fragment, &allowed_sites_validate_params);
        fragment->allowed_sites.Set(allowed_sites_fragment.is_null() ? nullptr : allowed_sites_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(fragment->allowed_sites.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null allowed_sites in CookieDeprecationMetadataIssueDetails struct");
        fragment->opt_out_percentage = Traits::opt_out_percentage(input);
        fragment->is_opt_out_top_level = Traits::is_opt_out_top_level(input);
        mojo::internal::Serialize<::blink::mojom::CookieOperation>(Traits::operation(input), &fragment->operation);
    }

    static bool Deserialize(::blink::mojom::internal::CookieDeprecationMetadataIssueDetails_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::blink::mojom::CookieDeprecationMetadataIssueDetailsDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::GenericIssueDetailsDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::blink::mojom::GenericIssueDetailsDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::blink::mojom::internal::GenericIssueDetails_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        mojo::internal::Serialize<::blink::mojom::GenericIssueErrorType>(Traits::error_type(input), &fragment->error_type);
        decltype(Traits::frame_id(input)) in_frame_id = Traits::frame_id(input);
        mojo::internal::MessageFragment<typename decltype(fragment->frame_id)::BaseType> frame_id_fragment(fragment.message());
        mojo::internal::Serialize<mojo::StringDataView>(in_frame_id, frame_id_fragment);
        fragment->frame_id.Set(frame_id_fragment.is_null() ? nullptr : frame_id_fragment.data());
        fragment->violating_node_id = Traits::violating_node_id(input);
        decltype(Traits::violating_node_attribute(input)) in_violating_node_attribute = Traits::violating_node_attribute(input);
        mojo::internal::MessageFragment<typename decltype(fragment->violating_node_attribute)::BaseType> violating_node_attribute_fragment(fragment.message());
        mojo::internal::Serialize<mojo::StringDataView>(in_violating_node_attribute, violating_node_attribute_fragment);
        fragment->violating_node_attribute.Set(violating_node_attribute_fragment.is_null() ? nullptr : violating_node_attribute_fragment.data());
    }

    static bool Deserialize(::blink::mojom::internal::GenericIssueDetails_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::blink::mojom::GenericIssueDetailsDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::DeprecationIssueDetailsDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::blink::mojom::DeprecationIssueDetailsDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::blink::mojom::internal::DeprecationIssueDetails_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        mojo::internal::Serialize<::blink::mojom::DeprecationIssueType>(Traits::type(input), &fragment->type);
        decltype(Traits::affected_location(input)) in_affected_location = Traits::affected_location(input);
        mojo::internal::MessageFragment<typename decltype(fragment->affected_location)::BaseType> affected_location_fragment(fragment.message());
        mojo::internal::Serialize<::blink::mojom::AffectedLocationDataView>(in_affected_location, affected_location_fragment);
        fragment->affected_location.Set(affected_location_fragment.is_null() ? nullptr : affected_location_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(fragment->affected_location.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null affected_location in DeprecationIssueDetails struct");
    }

    static bool Deserialize(::blink::mojom::internal::DeprecationIssueDetails_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::blink::mojom::DeprecationIssueDetailsDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::InspectorIssueDetailsDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::blink::mojom::InspectorIssueDetailsDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::blink::mojom::internal::InspectorIssueDetails_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::cookie_issue_details(input)) in_cookie_issue_details = Traits::cookie_issue_details(input);
        mojo::internal::MessageFragment<typename decltype(fragment->cookie_issue_details)::BaseType> cookie_issue_details_fragment(fragment.message());
        mojo::internal::Serialize<::blink::mojom::CookieIssueDetailsDataView>(in_cookie_issue_details, cookie_issue_details_fragment);
        fragment->cookie_issue_details.Set(cookie_issue_details_fragment.is_null() ? nullptr : cookie_issue_details_fragment.data());
        decltype(Traits::mixed_content_issue_details(input)) in_mixed_content_issue_details = Traits::mixed_content_issue_details(input);
        mojo::internal::MessageFragment<typename decltype(fragment->mixed_content_issue_details)::BaseType> mixed_content_issue_details_fragment(
            fragment.message());
        mojo::internal::Serialize<::blink::mojom::MixedContentIssueDetailsDataView>(in_mixed_content_issue_details, mixed_content_issue_details_fragment);
        fragment->mixed_content_issue_details.Set(mixed_content_issue_details_fragment.is_null() ? nullptr : mixed_content_issue_details_fragment.data());
        decltype(Traits::blocked_by_response_issue_details(input)) in_blocked_by_response_issue_details = Traits::blocked_by_response_issue_details(input);
        mojo::internal::MessageFragment<typename decltype(fragment->blocked_by_response_issue_details)::BaseType> blocked_by_response_issue_details_fragment(
            fragment.message());
        mojo::internal::Serialize<::blink::mojom::BlockedByResponseIssueDetailsDataView>(
            in_blocked_by_response_issue_details, blocked_by_response_issue_details_fragment);
        fragment->blocked_by_response_issue_details.Set(
            blocked_by_response_issue_details_fragment.is_null() ? nullptr : blocked_by_response_issue_details_fragment.data());
        decltype(Traits::csp_issue_details(input)) in_csp_issue_details = Traits::csp_issue_details(input);
        mojo::internal::MessageFragment<typename decltype(fragment->csp_issue_details)::BaseType> csp_issue_details_fragment(fragment.message());
        mojo::internal::Serialize<::blink::mojom::ContentSecurityPolicyIssueDetailsDataView>(in_csp_issue_details, csp_issue_details_fragment);
        fragment->csp_issue_details.Set(csp_issue_details_fragment.is_null() ? nullptr : csp_issue_details_fragment.data());
        decltype(Traits::sab_issue_details(input)) in_sab_issue_details = Traits::sab_issue_details(input);
        mojo::internal::MessageFragment<typename decltype(fragment->sab_issue_details)::BaseType> sab_issue_details_fragment(fragment.message());
        mojo::internal::Serialize<::blink::mojom::SharedArrayBufferIssueDetailsDataView>(in_sab_issue_details, sab_issue_details_fragment);
        fragment->sab_issue_details.Set(sab_issue_details_fragment.is_null() ? nullptr : sab_issue_details_fragment.data());
        decltype(Traits::heavy_ad_issue_details(input)) in_heavy_ad_issue_details = Traits::heavy_ad_issue_details(input);
        mojo::internal::MessageFragment<typename decltype(fragment->heavy_ad_issue_details)::BaseType> heavy_ad_issue_details_fragment(fragment.message());
        mojo::internal::Serialize<::blink::mojom::HeavyAdIssueDetailsDataView>(in_heavy_ad_issue_details, heavy_ad_issue_details_fragment);
        fragment->heavy_ad_issue_details.Set(heavy_ad_issue_details_fragment.is_null() ? nullptr : heavy_ad_issue_details_fragment.data());
        decltype(Traits::attribution_reporting_issue_details(input)) in_attribution_reporting_issue_details
            = Traits::attribution_reporting_issue_details(input);
        mojo::internal::MessageFragment<typename decltype(fragment->attribution_reporting_issue_details)::BaseType>
            attribution_reporting_issue_details_fragment(fragment.message());
        mojo::internal::Serialize<::blink::mojom::AttributionReportingIssueDetailsDataView>(
            in_attribution_reporting_issue_details, attribution_reporting_issue_details_fragment);
        fragment->attribution_reporting_issue_details.Set(
            attribution_reporting_issue_details_fragment.is_null() ? nullptr : attribution_reporting_issue_details_fragment.data());
        decltype(Traits::low_text_contrast_details(input)) in_low_text_contrast_details = Traits::low_text_contrast_details(input);
        mojo::internal::MessageFragment<typename decltype(fragment->low_text_contrast_details)::BaseType> low_text_contrast_details_fragment(
            fragment.message());
        mojo::internal::Serialize<::blink::mojom::LowTextContrastIssueDataView>(in_low_text_contrast_details, low_text_contrast_details_fragment);
        fragment->low_text_contrast_details.Set(low_text_contrast_details_fragment.is_null() ? nullptr : low_text_contrast_details_fragment.data());
        decltype(Traits::federated_auth_request_details(input)) in_federated_auth_request_details = Traits::federated_auth_request_details(input);
        mojo::internal::MessageFragment<typename decltype(fragment->federated_auth_request_details)::BaseType> federated_auth_request_details_fragment(
            fragment.message());
        mojo::internal::Serialize<::blink::mojom::FederatedAuthRequestIssueDetailsDataView>(
            in_federated_auth_request_details, federated_auth_request_details_fragment);
        fragment->federated_auth_request_details.Set(
            federated_auth_request_details_fragment.is_null() ? nullptr : federated_auth_request_details_fragment.data());
        decltype(Traits::bounce_tracking_issue_details(input)) in_bounce_tracking_issue_details = Traits::bounce_tracking_issue_details(input);
        mojo::internal::MessageFragment<typename decltype(fragment->bounce_tracking_issue_details)::BaseType> bounce_tracking_issue_details_fragment(
            fragment.message());
        mojo::internal::Serialize<::blink::mojom::BounceTrackingIssueDetailsDataView>(in_bounce_tracking_issue_details, bounce_tracking_issue_details_fragment);
        fragment->bounce_tracking_issue_details.Set(bounce_tracking_issue_details_fragment.is_null() ? nullptr : bounce_tracking_issue_details_fragment.data());
        decltype(Traits::cookie_deprecation_metadata_issue_details(input)) in_cookie_deprecation_metadata_issue_details
            = Traits::cookie_deprecation_metadata_issue_details(input);
        mojo::internal::MessageFragment<typename decltype(fragment->cookie_deprecation_metadata_issue_details)::BaseType>
            cookie_deprecation_metadata_issue_details_fragment(fragment.message());
        mojo::internal::Serialize<::blink::mojom::CookieDeprecationMetadataIssueDetailsDataView>(
            in_cookie_deprecation_metadata_issue_details, cookie_deprecation_metadata_issue_details_fragment);
        fragment->cookie_deprecation_metadata_issue_details.Set(
            cookie_deprecation_metadata_issue_details_fragment.is_null() ? nullptr : cookie_deprecation_metadata_issue_details_fragment.data());
        decltype(Traits::generic_issue_details(input)) in_generic_issue_details = Traits::generic_issue_details(input);
        mojo::internal::MessageFragment<typename decltype(fragment->generic_issue_details)::BaseType> generic_issue_details_fragment(fragment.message());
        mojo::internal::Serialize<::blink::mojom::GenericIssueDetailsDataView>(in_generic_issue_details, generic_issue_details_fragment);
        fragment->generic_issue_details.Set(generic_issue_details_fragment.is_null() ? nullptr : generic_issue_details_fragment.data());
        decltype(Traits::deprecation_issue_details(input)) in_deprecation_issue_details = Traits::deprecation_issue_details(input);
        mojo::internal::MessageFragment<typename decltype(fragment->deprecation_issue_details)::BaseType> deprecation_issue_details_fragment(
            fragment.message());
        mojo::internal::Serialize<::blink::mojom::DeprecationIssueDetailsDataView>(in_deprecation_issue_details, deprecation_issue_details_fragment);
        fragment->deprecation_issue_details.Set(deprecation_issue_details_fragment.is_null() ? nullptr : deprecation_issue_details_fragment.data());
        decltype(Traits::federated_auth_user_info_request_details(input)) in_federated_auth_user_info_request_details
            = Traits::federated_auth_user_info_request_details(input);
        mojo::internal::MessageFragment<typename decltype(fragment->federated_auth_user_info_request_details)::BaseType>
            federated_auth_user_info_request_details_fragment(fragment.message());
        mojo::internal::Serialize<::blink::mojom::FederatedAuthUserInfoRequestIssueDetailsDataView>(
            in_federated_auth_user_info_request_details, federated_auth_user_info_request_details_fragment);
        fragment->federated_auth_user_info_request_details.Set(
            federated_auth_user_info_request_details_fragment.is_null() ? nullptr : federated_auth_user_info_request_details_fragment.data());
        decltype(Traits::issue_id(input)) in_issue_id = Traits::issue_id(input);
        mojo::internal::MessageFragment<typename decltype(fragment->issue_id)::BaseType> issue_id_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::UnguessableTokenDataView>(in_issue_id, issue_id_fragment);
        fragment->issue_id.Set(issue_id_fragment.is_null() ? nullptr : issue_id_fragment.data());
    }

    static bool Deserialize(::blink::mojom::internal::InspectorIssueDetails_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::blink::mojom::InspectorIssueDetailsDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::InspectorIssueInfoDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::blink::mojom::InspectorIssueInfoDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::blink::mojom::internal::InspectorIssueInfo_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        mojo::internal::Serialize<::blink::mojom::InspectorIssueCode>(Traits::code(input), &fragment->code);
        decltype(Traits::details(input)) in_details = Traits::details(input);
        mojo::internal::MessageFragment<typename decltype(fragment->details)::BaseType> details_fragment(fragment.message());
        mojo::internal::Serialize<::blink::mojom::InspectorIssueDetailsDataView>(in_details, details_fragment);
        fragment->details.Set(details_fragment.is_null() ? nullptr : details_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->details.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null details in InspectorIssueInfo struct");
    }

    static bool Deserialize(::blink::mojom::internal::InspectorIssueInfo_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::blink::mojom::InspectorIssueInfoDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

} // namespace mojo

namespace blink::mojom {

inline void AffectedCookieDataView::GetNameDataView(mojo::StringDataView* output)
{
    auto pointer = data_->name.Get();
    *output = mojo::StringDataView(pointer, message_);
}
inline void AffectedCookieDataView::GetPathDataView(mojo::StringDataView* output)
{
    auto pointer = data_->path.Get();
    *output = mojo::StringDataView(pointer, message_);
}
inline void AffectedCookieDataView::GetDomainDataView(mojo::StringDataView* output)
{
    auto pointer = data_->domain.Get();
    *output = mojo::StringDataView(pointer, message_);
}

inline void AffectedRequestDataView::GetRequestIdDataView(mojo::StringDataView* output)
{
    auto pointer = data_->request_id.Get();
    *output = mojo::StringDataView(pointer, message_);
}
inline void AffectedRequestDataView::GetUrlDataView(mojo::StringDataView* output)
{
    auto pointer = data_->url.Get();
    *output = mojo::StringDataView(pointer, message_);
}

inline void AffectedFrameDataView::GetFrameIdDataView(mojo::StringDataView* output)
{
    auto pointer = data_->frame_id.Get();
    *output = mojo::StringDataView(pointer, message_);
}

inline void AffectedLocationDataView::GetScriptIdDataView(mojo::StringDataView* output)
{
    auto pointer = data_->script_id.Get();
    *output = mojo::StringDataView(pointer, message_);
}
inline void AffectedLocationDataView::GetUrlDataView(mojo::StringDataView* output)
{
    auto pointer = data_->url.Get();
    *output = mojo::StringDataView(pointer, message_);
}

inline void BlockedByResponseIssueDetailsDataView::GetRequestDataView(AffectedRequestDataView* output)
{
    auto pointer = data_->request.Get();
    *output = AffectedRequestDataView(pointer, message_);
}
inline void BlockedByResponseIssueDetailsDataView::GetParentFrameDataView(AffectedFrameDataView* output)
{
    auto pointer = data_->parentFrame.Get();
    *output = AffectedFrameDataView(pointer, message_);
}
inline void BlockedByResponseIssueDetailsDataView::GetBlockedFrameDataView(AffectedFrameDataView* output)
{
    auto pointer = data_->blockedFrame.Get();
    *output = AffectedFrameDataView(pointer, message_);
}

inline void HeavyAdIssueDetailsDataView::GetFrameDataView(AffectedFrameDataView* output)
{
    auto pointer = data_->frame.Get();
    *output = AffectedFrameDataView(pointer, message_);
}

inline void AttributionReportingIssueDetailsDataView::GetRequestDataView(AffectedRequestDataView* output)
{
    auto pointer = data_->request.Get();
    *output = AffectedRequestDataView(pointer, message_);
}
inline void AttributionReportingIssueDetailsDataView::GetInvalidParameterDataView(mojo::StringDataView* output)
{
    auto pointer = data_->invalid_parameter.Get();
    *output = mojo::StringDataView(pointer, message_);
}

inline void MixedContentIssueDetailsDataView::GetInsecureUrlDataView(mojo::StringDataView* output)
{
    auto pointer = data_->insecure_url.Get();
    *output = mojo::StringDataView(pointer, message_);
}
inline void MixedContentIssueDetailsDataView::GetMainResourceUrlDataView(mojo::StringDataView* output)
{
    auto pointer = data_->main_resource_url.Get();
    *output = mojo::StringDataView(pointer, message_);
}
inline void MixedContentIssueDetailsDataView::GetRequestDataView(AffectedRequestDataView* output)
{
    auto pointer = data_->request.Get();
    *output = AffectedRequestDataView(pointer, message_);
}
inline void MixedContentIssueDetailsDataView::GetFrameDataView(AffectedFrameDataView* output)
{
    auto pointer = data_->frame.Get();
    *output = AffectedFrameDataView(pointer, message_);
}

inline void ContentSecurityPolicyIssueDetailsDataView::GetBlockedUrlDataView(::url::mojom::UrlDataView* output)
{
    auto pointer = data_->blocked_url.Get();
    *output = ::url::mojom::UrlDataView(pointer, message_);
}
inline void ContentSecurityPolicyIssueDetailsDataView::GetViolatedDirectiveDataView(mojo::StringDataView* output)
{
    auto pointer = data_->violated_directive.Get();
    *output = mojo::StringDataView(pointer, message_);
}
inline void ContentSecurityPolicyIssueDetailsDataView::GetFrameAncestorDataView(AffectedFrameDataView* output)
{
    auto pointer = data_->frame_ancestor.Get();
    *output = AffectedFrameDataView(pointer, message_);
}
inline void ContentSecurityPolicyIssueDetailsDataView::GetAffectedLocationDataView(AffectedLocationDataView* output)
{
    auto pointer = data_->affected_location.Get();
    *output = AffectedLocationDataView(pointer, message_);
}

inline void CookieIssueDetailsDataView::GetCookieDataView(AffectedCookieDataView* output)
{
    auto pointer = data_->cookie.Get();
    *output = AffectedCookieDataView(pointer, message_);
}
inline void CookieIssueDetailsDataView::GetExclusionReasonDataView(mojo::ArrayDataView<CookieExclusionReason>* output)
{
    auto pointer = data_->exclusion_reason.Get();
    *output = mojo::ArrayDataView<CookieExclusionReason>(pointer, message_);
}
inline void CookieIssueDetailsDataView::GetWarningReasonDataView(mojo::ArrayDataView<CookieWarningReason>* output)
{
    auto pointer = data_->warning_reason.Get();
    *output = mojo::ArrayDataView<CookieWarningReason>(pointer, message_);
}
inline void CookieIssueDetailsDataView::GetSiteForCookiesDataView(::url::mojom::UrlDataView* output)
{
    auto pointer = data_->site_for_cookies.Get();
    *output = ::url::mojom::UrlDataView(pointer, message_);
}
inline void CookieIssueDetailsDataView::GetCookieUrlDataView(::url::mojom::UrlDataView* output)
{
    auto pointer = data_->cookie_url.Get();
    *output = ::url::mojom::UrlDataView(pointer, message_);
}
inline void CookieIssueDetailsDataView::GetRequestDataView(AffectedRequestDataView* output)
{
    auto pointer = data_->request.Get();
    *output = AffectedRequestDataView(pointer, message_);
}

inline void SharedArrayBufferIssueDetailsDataView::GetAffectedLocationDataView(AffectedLocationDataView* output)
{
    auto pointer = data_->affected_location.Get();
    *output = AffectedLocationDataView(pointer, message_);
}

inline void LowTextContrastIssueDataView::GetViolatingNodeSelectorDataView(mojo::StringDataView* output)
{
    auto pointer = data_->violating_node_selector.Get();
    *output = mojo::StringDataView(pointer, message_);
}
inline void LowTextContrastIssueDataView::GetFontSizeDataView(mojo::StringDataView* output)
{
    auto pointer = data_->font_size.Get();
    *output = mojo::StringDataView(pointer, message_);
}
inline void LowTextContrastIssueDataView::GetFontWeightDataView(mojo::StringDataView* output)
{
    auto pointer = data_->font_weight.Get();
    *output = mojo::StringDataView(pointer, message_);
}

inline void BounceTrackingIssueDetailsDataView::GetTrackingSitesDataView(mojo::ArrayDataView<mojo::StringDataView>* output)
{
    auto pointer = data_->tracking_sites.Get();
    *output = mojo::ArrayDataView<mojo::StringDataView>(pointer, message_);
}

inline void CookieDeprecationMetadataIssueDetailsDataView::GetAllowedSitesDataView(mojo::ArrayDataView<mojo::StringDataView>* output)
{
    auto pointer = data_->allowed_sites.Get();
    *output = mojo::ArrayDataView<mojo::StringDataView>(pointer, message_);
}

inline void GenericIssueDetailsDataView::GetFrameIdDataView(mojo::StringDataView* output)
{
    auto pointer = data_->frame_id.Get();
    *output = mojo::StringDataView(pointer, message_);
}
inline void GenericIssueDetailsDataView::GetViolatingNodeAttributeDataView(mojo::StringDataView* output)
{
    auto pointer = data_->violating_node_attribute.Get();
    *output = mojo::StringDataView(pointer, message_);
}

inline void DeprecationIssueDetailsDataView::GetAffectedLocationDataView(AffectedLocationDataView* output)
{
    auto pointer = data_->affected_location.Get();
    *output = AffectedLocationDataView(pointer, message_);
}

inline void InspectorIssueDetailsDataView::GetCookieIssueDetailsDataView(CookieIssueDetailsDataView* output)
{
    auto pointer = data_->cookie_issue_details.Get();
    *output = CookieIssueDetailsDataView(pointer, message_);
}
inline void InspectorIssueDetailsDataView::GetMixedContentIssueDetailsDataView(MixedContentIssueDetailsDataView* output)
{
    auto pointer = data_->mixed_content_issue_details.Get();
    *output = MixedContentIssueDetailsDataView(pointer, message_);
}
inline void InspectorIssueDetailsDataView::GetBlockedByResponseIssueDetailsDataView(BlockedByResponseIssueDetailsDataView* output)
{
    auto pointer = data_->blocked_by_response_issue_details.Get();
    *output = BlockedByResponseIssueDetailsDataView(pointer, message_);
}
inline void InspectorIssueDetailsDataView::GetCspIssueDetailsDataView(ContentSecurityPolicyIssueDetailsDataView* output)
{
    auto pointer = data_->csp_issue_details.Get();
    *output = ContentSecurityPolicyIssueDetailsDataView(pointer, message_);
}
inline void InspectorIssueDetailsDataView::GetSabIssueDetailsDataView(SharedArrayBufferIssueDetailsDataView* output)
{
    auto pointer = data_->sab_issue_details.Get();
    *output = SharedArrayBufferIssueDetailsDataView(pointer, message_);
}
inline void InspectorIssueDetailsDataView::GetHeavyAdIssueDetailsDataView(HeavyAdIssueDetailsDataView* output)
{
    auto pointer = data_->heavy_ad_issue_details.Get();
    *output = HeavyAdIssueDetailsDataView(pointer, message_);
}
inline void InspectorIssueDetailsDataView::GetAttributionReportingIssueDetailsDataView(AttributionReportingIssueDetailsDataView* output)
{
    auto pointer = data_->attribution_reporting_issue_details.Get();
    *output = AttributionReportingIssueDetailsDataView(pointer, message_);
}
inline void InspectorIssueDetailsDataView::GetLowTextContrastDetailsDataView(LowTextContrastIssueDataView* output)
{
    auto pointer = data_->low_text_contrast_details.Get();
    *output = LowTextContrastIssueDataView(pointer, message_);
}
inline void InspectorIssueDetailsDataView::GetFederatedAuthRequestDetailsDataView(FederatedAuthRequestIssueDetailsDataView* output)
{
    auto pointer = data_->federated_auth_request_details.Get();
    *output = FederatedAuthRequestIssueDetailsDataView(pointer, message_);
}
inline void InspectorIssueDetailsDataView::GetBounceTrackingIssueDetailsDataView(BounceTrackingIssueDetailsDataView* output)
{
    auto pointer = data_->bounce_tracking_issue_details.Get();
    *output = BounceTrackingIssueDetailsDataView(pointer, message_);
}
inline void InspectorIssueDetailsDataView::GetCookieDeprecationMetadataIssueDetailsDataView(CookieDeprecationMetadataIssueDetailsDataView* output)
{
    auto pointer = data_->cookie_deprecation_metadata_issue_details.Get();
    *output = CookieDeprecationMetadataIssueDetailsDataView(pointer, message_);
}
inline void InspectorIssueDetailsDataView::GetGenericIssueDetailsDataView(GenericIssueDetailsDataView* output)
{
    auto pointer = data_->generic_issue_details.Get();
    *output = GenericIssueDetailsDataView(pointer, message_);
}
inline void InspectorIssueDetailsDataView::GetDeprecationIssueDetailsDataView(DeprecationIssueDetailsDataView* output)
{
    auto pointer = data_->deprecation_issue_details.Get();
    *output = DeprecationIssueDetailsDataView(pointer, message_);
}
inline void InspectorIssueDetailsDataView::GetFederatedAuthUserInfoRequestDetailsDataView(FederatedAuthUserInfoRequestIssueDetailsDataView* output)
{
    auto pointer = data_->federated_auth_user_info_request_details.Get();
    *output = FederatedAuthUserInfoRequestIssueDetailsDataView(pointer, message_);
}
inline void InspectorIssueDetailsDataView::GetIssueIdDataView(::mojo_base::mojom::UnguessableTokenDataView* output)
{
    auto pointer = data_->issue_id.Get();
    *output = ::mojo_base::mojom::UnguessableTokenDataView(pointer, message_);
}

inline void InspectorIssueInfoDataView::GetDetailsDataView(InspectorIssueDetailsDataView* output)
{
    auto pointer = data_->details.Get();
    *output = InspectorIssueDetailsDataView(pointer, message_);
}

} // blink::mojom

// Declare TraceFormatTraits for enums, which should be defined in ::perfetto
// namespace.

namespace perfetto {

template <> struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::InspectorIssueCode> {
    static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::InspectorIssueCode value);
};

} // namespace perfetto

namespace perfetto {

template <> struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::HeavyAdResolutionStatus> {
    static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::HeavyAdResolutionStatus value);
};

} // namespace perfetto

namespace perfetto {

template <> struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::HeavyAdReason> {
    static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::HeavyAdReason value);
};

} // namespace perfetto

namespace perfetto {

template <> struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::AttributionReportingIssueType> {
    static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::AttributionReportingIssueType value);
};

} // namespace perfetto

namespace perfetto {

template <> struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::MixedContentResolutionStatus> {
    static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::MixedContentResolutionStatus value);
};

} // namespace perfetto

namespace perfetto {

template <> struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::ContentSecurityPolicyViolationType> {
    static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::ContentSecurityPolicyViolationType value);
};

} // namespace perfetto

namespace perfetto {

template <> struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::CookieOperation> {
    static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::CookieOperation value);
};

} // namespace perfetto

namespace perfetto {

template <> struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::CookieExclusionReason> {
    static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::CookieExclusionReason value);
};

} // namespace perfetto

namespace perfetto {

template <> struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::CookieWarningReason> {
    static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::CookieWarningReason value);
};

} // namespace perfetto

namespace perfetto {

template <> struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::SharedArrayBufferIssueType> {
    static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::SharedArrayBufferIssueType value);
};

} // namespace perfetto

namespace perfetto {

template <> struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::FederatedAuthRequestResult> {
    static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::FederatedAuthRequestResult value);
};

} // namespace perfetto

namespace perfetto {

template <> struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::FederatedAuthUserInfoRequestResult> {
    static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::FederatedAuthUserInfoRequestResult value);
};

} // namespace perfetto

namespace perfetto {

template <> struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::GenericIssueErrorType> {
    static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::GenericIssueErrorType value);
};

} // namespace perfetto

namespace perfetto {

template <> struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::DeprecationIssueType> {
    static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::DeprecationIssueType value);
};

} // namespace perfetto

#endif // THIRD_PARTY_BLINK_PUBLIC_MOJOM_DEVTOOLS_INSPECTOR_ISSUE_MOJOM_SHARED_H_
