// third_party/blink/public/mojom/frame/frame.mojom-shared.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef THIRD_PARTY_BLINK_PUBLIC_MOJOM_FRAME_FRAME_MOJOM_SHARED_H_
#define THIRD_PARTY_BLINK_PUBLIC_MOJOM_FRAME_FRAME_MOJOM_SHARED_H_

#include <stdint.h>

#include <functional>
#include <iosfwd>
#include <type_traits>
#include <utility>
#include "mojo/public/cpp/bindings/array_data_view.h"
#include "mojo/public/cpp/bindings/enum_traits.h"
#include "mojo/public/cpp/bindings/interface_data_view.h"
#include "mojo/public/cpp/bindings/lib/bindings_internal.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/map_data_view.h"
#include "mojo/public/cpp/bindings/string_data_view.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "third_party/blink/public/mojom/frame/frame.mojom-shared-internal.h"
#include "cc/mojom/browser_controls_state.mojom-shared.h"
#include "cc/mojom/browser_controls_offset_tags_info.mojom-shared.h"
#include "mojo/public/mojom/base/byte_string.mojom-shared.h"
#include "mojo/public/mojom/base/shared_memory.mojom-shared.h"
#include "mojo/public/mojom/base/string16.mojom-shared.h"
#include "mojo/public/mojom/base/text_direction.mojom-shared.h"
#include "mojo/public/mojom/base/time.mojom-shared.h"
#include "mojo/public/mojom/base/unguessable_token.mojom-shared.h"
#include "mojo/public/mojom/base/values.mojom-shared.h"
#include "services/network/public/mojom/content_security_policy.mojom-shared.h"
#include "services/network/public/mojom/cross_origin_opener_policy.mojom-shared.h"
#include "services/network/public/mojom/fetch_api.mojom-shared.h"
#include "services/network/public/mojom/load_timing_info.mojom-shared.h"
#include "services/network/public/mojom/network_types.mojom-shared.h"
#include "services/network/public/mojom/source_location.mojom-shared.h"
#include "services/network/public/mojom/url_loader_completion_status.mojom-shared.h"
#include "services/network/public/mojom/attribution.mojom-shared.h"
#include "services/viz/public/mojom/compositing/offset_tag.mojom-shared.h"
#include "skia/public/mojom/bitmap.mojom-shared.h"
#include "skia/public/mojom/skcolor.mojom-shared.h"
#include "skia/public/mojom/skcolor4f.mojom-shared.h"
#include "third_party/blink/public/mojom/blob/blob.mojom-shared.h"
#include "third_party/blink/public/mojom/blob/blob_url_store.mojom-shared.h"
#include "third_party/blink/public/mojom/choosers/popup_menu.mojom-shared.h"
#include "third_party/blink/public/mojom/close_watcher/close_listener.mojom-shared.h"
#include "third_party/blink/public/mojom/confidence_level.mojom-shared.h"
#include "third_party/blink/public/mojom/context_menu/context_menu.mojom-shared.h"
#include "third_party/blink/public/mojom/navigation/navigation_params.mojom-shared.h"
#include "third_party/blink/public/mojom/css/preferred_color_scheme.mojom-shared.h"
#include "third_party/blink/public/mojom/devtools/console_message.mojom-shared.h"
#include "third_party/blink/public/mojom/devtools/devtools_agent.mojom-shared.h"
#include "third_party/blink/public/mojom/devtools/inspector_issue.mojom-shared.h"
#include "third_party/blink/public/mojom/drag/drag.mojom-shared.h"
#include "third_party/blink/public/mojom/favicon/favicon_url.mojom-shared.h"
#include "third_party/blink/public/mojom/fenced_frame/fenced_frame.mojom-shared.h"
#include "third_party/blink/public/mojom/fenced_frame/fenced_frame_config.mojom-shared.h"
#include "third_party/blink/public/mojom/fetch/fetch_api_request.mojom-shared.h"
#include "third_party/blink/public/mojom/frame/blocked_navigation_types.mojom-shared.h"
#include "third_party/blink/public/mojom/frame/frame_owner_properties.mojom-shared.h"
#include "third_party/blink/public/mojom/frame/frame_policy.mojom-shared.h"
#include "third_party/blink/public/mojom/frame/frame_replication_state.mojom-shared.h"
#include "third_party/blink/public/mojom/frame/fullscreen.mojom-shared.h"
#include "third_party/blink/public/mojom/frame/lifecycle.mojom-shared.h"
#include "third_party/blink/public/mojom/frame/media_player_action.mojom-shared.h"
#include "third_party/blink/public/mojom/frame/remote_frame.mojom-shared.h"
#include "third_party/blink/public/mojom/frame/reporting_observer.mojom-shared.h"
#include "third_party/blink/public/mojom/frame/sudden_termination_disabler_type.mojom-shared.h"
#include "third_party/blink/public/mojom/frame/text_autosizer_page_info.mojom-shared.h"
#include "third_party/blink/public/mojom/frame/user_activation_notification_type.mojom-shared.h"
#include "third_party/blink/public/mojom/frame/user_activation_update_types.mojom-shared.h"
#include "third_party/blink/public/mojom/frame/view_transition_state.mojom-shared.h"
#include "third_party/blink/public/mojom/input/focus_type.mojom-shared.h"
#include "third_party/blink/public/mojom/input/scroll_direction.mojom-shared.h"
#include "third_party/blink/public/mojom/loader/referrer.mojom-shared.h"
#include "third_party/blink/public/mojom/loader/keep_alive_handle_factory.mojom-shared.h"
#include "third_party/blink/public/mojom/messaging/delegated_capability.mojom-shared.h"
#include "third_party/blink/public/mojom/messaging/task_attribution_id.mojom-shared.h"
#include "third_party/blink/public/mojom/messaging/transferable_message.mojom-shared.h"
#include "third_party/blink/public/mojom/navigation/navigation_api_history_entry_arrays.mojom-shared.h"
#include "third_party/blink/public/mojom/opengraph/metadata.mojom-shared.h"
#include "third_party/blink/public/mojom/page/draggable_region.mojom-shared.h"
#include "third_party/blink/public/mojom/page/widget.mojom-shared.h"
#include "third_party/blink/public/mojom/scroll/scroll_into_view_params.mojom-shared.h"
#include "third_party/blink/public/mojom/security_context/insecure_request_policy.mojom-shared.h"
#include "third_party/blink/public/mojom/timing/resource_timing.mojom-shared.h"
#include "third_party/blink/public/mojom/tokens/tokens.mojom-shared.h"
#include "third_party/blink/public/mojom/use_counter/metrics/web_feature.mojom-shared.h"
#include "third_party/blink/public/mojom/widget/platform_widget.mojom-shared.h"
#include "third_party/blink/public/mojom/window_features/window_features.mojom-shared.h"
#include "ui/base/ime/mojom/virtual_keyboard_types.mojom-shared.h"
#include "ui/base/mojom/window_open_disposition.mojom-shared.h"
#include "ui/events/mojom/scroll_granularity.mojom-shared.h"
#include "ui/gfx/geometry/mojom/geometry.mojom-shared.h"
#include "ui/gfx/image/mojom/image.mojom-shared.h"
#include "ui/gfx/range/mojom/range.mojom-shared.h"
#include "url/mojom/origin.mojom-shared.h"
#include "url/mojom/url.mojom-shared.h"
#include "mojo/public/cpp/bindings/lib/interface_serialization.h"
#include "mojo/public/cpp/system/data_pipe.h"

#include "base/component_export.h"

namespace blink::mojom {
class SavableSubframeDataView;

class GetSavableResourceLinksReplyDataView;

class FindInPageResultAXParamsDataView;

class DownloadURLParamsDataView;

class IframeAttributesDataView;

class LegacyTechEventCodeLocationDataView;

} // blink::mojom

namespace mojo {
namespace internal {

template <> struct MojomTypeTraits<::blink::mojom::SavableSubframeDataView> {
    using Data = ::blink::mojom::internal::SavableSubframe_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::blink::mojom::GetSavableResourceLinksReplyDataView> {
    using Data = ::blink::mojom::internal::GetSavableResourceLinksReply_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::blink::mojom::FindInPageResultAXParamsDataView> {
    using Data = ::blink::mojom::internal::FindInPageResultAXParams_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::blink::mojom::DownloadURLParamsDataView> {
    using Data = ::blink::mojom::internal::DownloadURLParams_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::blink::mojom::IframeAttributesDataView> {
    using Data = ::blink::mojom::internal::IframeAttributes_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::blink::mojom::LegacyTechEventCodeLocationDataView> {
    using Data = ::blink::mojom::internal::LegacyTechEventCodeLocation_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

} // namespace internal
} // namespace mojo

namespace blink::mojom {

enum class PluginActionType : int32_t {

    kRotate90Clockwise = 0,

    kRotate90Counterclockwise = 1,
    kMinValue = 0,
    kMaxValue = 1,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, PluginActionType value);
inline bool IsKnownEnumValue(PluginActionType value)
{
    return internal::PluginActionType_Data::IsKnownValue(static_cast<int32_t>(value));
}

enum class JavaScriptExecutionResultType : int32_t {

    kSuccess = 0,

    kException = 1,
    kMinValue = 0,
    kMaxValue = 1,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, JavaScriptExecutionResultType value);
inline bool IsKnownEnumValue(JavaScriptExecutionResultType value)
{
    return internal::JavaScriptExecutionResultType_Data::IsKnownValue(static_cast<int32_t>(value));
}

enum class TraverseCancelledReason : int32_t {

    kNotFound = 0,

    kSandboxViolation = 1,

    kAbortedBeforeCommit = 2,
    kMinValue = 0,
    kMaxValue = 2,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, TraverseCancelledReason value);
inline bool IsKnownEnumValue(TraverseCancelledReason value)
{
    return internal::TraverseCancelledReason_Data::IsKnownValue(static_cast<int32_t>(value));
}

enum class ViewTransitionSameOriginOptIn : int32_t {

    kDisabled = 0,

    kEnabled = 1,
    kMinValue = 0,
    kMaxValue = 1,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, ViewTransitionSameOriginOptIn value);
inline bool IsKnownEnumValue(ViewTransitionSameOriginOptIn value)
{
    return internal::ViewTransitionSameOriginOptIn_Data::IsKnownValue(static_cast<int32_t>(value));
}

enum class FrameOwnerElementType : int32_t {

    kNone = 0,

    kIframe = 1,

    kObject = 2,

    kEmbed = 3,

    kFrame = 4,

    kFencedframe = 5,
    kMinValue = 0,
    kMaxValue = 5,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, FrameOwnerElementType value);
inline bool IsKnownEnumValue(FrameOwnerElementType value)
{
    return internal::FrameOwnerElementType_Data::IsKnownValue(static_cast<int32_t>(value));
}

enum class NavigationApiEntryRestoreReason : int32_t {

    kBFCache = 0,

    kPrerenderActivationPush = 1,

    kPrerenderActivationReplace = 2,
    kMinValue = 0,
    kMaxValue = 2,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, NavigationApiEntryRestoreReason value);
inline bool IsKnownEnumValue(NavigationApiEntryRestoreReason value)
{
    return internal::NavigationApiEntryRestoreReason_Data::IsKnownValue(static_cast<int32_t>(value));
}

enum class StorageTypeAccessed : int32_t {

    kDatabase = 0,

    kCacheStorage = 1,

    kIndexedDB = 2,

    kFileSystem = 3,

    kWebLocks = 4,

    kLocalStorage = 5,

    kSessionStorage = 6,
    kMinValue = 0,
    kMaxValue = 6,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, StorageTypeAccessed value);
inline bool IsKnownEnumValue(StorageTypeAccessed value)
{
    return internal::StorageTypeAccessed_Data::IsKnownValue(static_cast<int32_t>(value));
}

enum class WindowProxyAccessType : int32_t {

    kLocation = 0,

    kClosed = 1,

    kLength = 2,

    kSelf = 3,

    kWindow = 4,

    kFrames = 5,

    kOpener = 6,

    kParent = 7,

    kTop = 8,

    kPostMessage = 9,

    kAnonymousIndexedGetter = 10,

    kClose = 11,

    kFocus = 12,

    kBlur = 13,

    kAnonymousNamedGetter = 14,
    kMinValue = 0,
    kMaxValue = 14,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, WindowProxyAccessType value);
inline bool IsKnownEnumValue(WindowProxyAccessType value)
{
    return internal::WindowProxyAccessType_Data::IsKnownValue(static_cast<int32_t>(value));
}
// Interface base classes. They are used for type safety check.
class LocalFrameHostInterfaceBase { };

using LocalFrameHostPtrDataView = mojo::InterfacePtrDataView<LocalFrameHostInterfaceBase>;
using LocalFrameHostRequestDataView = mojo::InterfaceRequestDataView<LocalFrameHostInterfaceBase>;
using LocalFrameHostAssociatedPtrInfoDataView = mojo::AssociatedInterfacePtrInfoDataView<LocalFrameHostInterfaceBase>;
using LocalFrameHostAssociatedRequestDataView = mojo::AssociatedInterfaceRequestDataView<LocalFrameHostInterfaceBase>;
class NonAssociatedLocalFrameHostInterfaceBase { };

using NonAssociatedLocalFrameHostPtrDataView = mojo::InterfacePtrDataView<NonAssociatedLocalFrameHostInterfaceBase>;
using NonAssociatedLocalFrameHostRequestDataView = mojo::InterfaceRequestDataView<NonAssociatedLocalFrameHostInterfaceBase>;
using NonAssociatedLocalFrameHostAssociatedPtrInfoDataView = mojo::AssociatedInterfacePtrInfoDataView<NonAssociatedLocalFrameHostInterfaceBase>;
using NonAssociatedLocalFrameHostAssociatedRequestDataView = mojo::AssociatedInterfaceRequestDataView<NonAssociatedLocalFrameHostInterfaceBase>;
class LocalFrameInterfaceBase { };

using LocalFramePtrDataView = mojo::InterfacePtrDataView<LocalFrameInterfaceBase>;
using LocalFrameRequestDataView = mojo::InterfaceRequestDataView<LocalFrameInterfaceBase>;
using LocalFrameAssociatedPtrInfoDataView = mojo::AssociatedInterfacePtrInfoDataView<LocalFrameInterfaceBase>;
using LocalFrameAssociatedRequestDataView = mojo::AssociatedInterfaceRequestDataView<LocalFrameInterfaceBase>;
class LocalMainFrameInterfaceBase { };

using LocalMainFramePtrDataView = mojo::InterfacePtrDataView<LocalMainFrameInterfaceBase>;
using LocalMainFrameRequestDataView = mojo::InterfaceRequestDataView<LocalMainFrameInterfaceBase>;
using LocalMainFrameAssociatedPtrInfoDataView = mojo::AssociatedInterfacePtrInfoDataView<LocalMainFrameInterfaceBase>;
using LocalMainFrameAssociatedRequestDataView = mojo::AssociatedInterfaceRequestDataView<LocalMainFrameInterfaceBase>;
class LocalMainFrameHostInterfaceBase { };

using LocalMainFrameHostPtrDataView = mojo::InterfacePtrDataView<LocalMainFrameHostInterfaceBase>;
using LocalMainFrameHostRequestDataView = mojo::InterfaceRequestDataView<LocalMainFrameHostInterfaceBase>;
using LocalMainFrameHostAssociatedPtrInfoDataView = mojo::AssociatedInterfacePtrInfoDataView<LocalMainFrameHostInterfaceBase>;
using LocalMainFrameHostAssociatedRequestDataView = mojo::AssociatedInterfaceRequestDataView<LocalMainFrameHostInterfaceBase>;

class SavableSubframeDataView {
public:
    SavableSubframeDataView() = default;

    SavableSubframeDataView(internal::SavableSubframe_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetOriginalUrlDataView(::url::mojom::UrlDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadOriginalUrl(UserType* output)
    {

        auto* pointer = data_->original_url.Get();
        return mojo::internal::Deserialize<::url::mojom::UrlDataView>(pointer, output, message_);
    }
    inline void GetSubframeTokenDataView(::blink::mojom::FrameTokenDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadSubframeToken(UserType* output)
    {

        auto* pointer = !data_->subframe_token.is_null() ? &data_->subframe_token : nullptr;
        return mojo::internal::Deserialize<::blink::mojom::FrameTokenDataView>(pointer, output, message_);
    }

private:
    internal::SavableSubframe_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class GetSavableResourceLinksReplyDataView {
public:
    GetSavableResourceLinksReplyDataView() = default;

    GetSavableResourceLinksReplyDataView(internal::GetSavableResourceLinksReply_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetResourcesListDataView(mojo::ArrayDataView<::url::mojom::UrlDataView>* output);

    template <typename UserType> [[nodiscard]] bool ReadResourcesList(UserType* output)
    {

        auto* pointer = data_->resources_list.Get();
        return mojo::internal::Deserialize<mojo::ArrayDataView<::url::mojom::UrlDataView>>(pointer, output, message_);
    }
    inline void GetReferrerDataView(::blink::mojom::ReferrerDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadReferrer(UserType* output)
    {

        auto* pointer = data_->referrer.Get();
        return mojo::internal::Deserialize<::blink::mojom::ReferrerDataView>(pointer, output, message_);
    }
    inline void GetSubframesDataView(mojo::ArrayDataView<SavableSubframeDataView>* output);

    template <typename UserType> [[nodiscard]] bool ReadSubframes(UserType* output)
    {

        auto* pointer = data_->subframes.Get();
        return mojo::internal::Deserialize<mojo::ArrayDataView<::blink::mojom::SavableSubframeDataView>>(pointer, output, message_);
    }

private:
    internal::GetSavableResourceLinksReply_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class FindInPageResultAXParamsDataView {
public:
    FindInPageResultAXParamsDataView() = default;

    FindInPageResultAXParamsDataView(internal::FindInPageResultAXParams_Data* data, mojo::Message* message)
        : data_(data)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    int32_t request_id() const
    {
        return data_->request_id;
    }
    int32_t match_index() const
    {
        return data_->match_index;
    }
    int32_t start_id() const
    {
        return data_->start_id;
    }
    int32_t start_offset() const
    {
        return data_->start_offset;
    }
    int32_t end_id() const
    {
        return data_->end_id;
    }
    int32_t end_offset() const
    {
        return data_->end_offset;
    }

private:
    internal::FindInPageResultAXParams_Data* data_ = nullptr;
};

class DownloadURLParamsDataView {
public:
    DownloadURLParamsDataView() = default;

    DownloadURLParamsDataView(internal::DownloadURLParams_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetUrlDataView(::url::mojom::UrlDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadUrl(UserType* output)
    {

        auto* pointer = data_->url.Get();
        return mojo::internal::Deserialize<::url::mojom::UrlDataView>(pointer, output, message_);
    }
    inline void GetReferrerDataView(::blink::mojom::ReferrerDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadReferrer(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::blink::mojom::ReferrerDataView, UserType>(),
            "Attempting to read the optional `referrer` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadReferrer` instead "
            "of `ReadReferrer if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->referrer.Get();
        return mojo::internal::Deserialize<::blink::mojom::ReferrerDataView>(pointer, output, message_);
    }
    inline void GetInitiatorOriginDataView(::url::mojom::OriginDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadInitiatorOrigin(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::url::mojom::OriginDataView, UserType>(),
            "Attempting to read the optional `initiator_origin` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadInitiatorOrigin` instead "
            "of `ReadInitiatorOrigin if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->initiator_origin.Get();
        return mojo::internal::Deserialize<::url::mojom::OriginDataView>(pointer, output, message_);
    }
    inline void GetSuggestedNameDataView(::mojo_base::mojom::String16DataView* output);

    template <typename UserType> [[nodiscard]] bool ReadSuggestedName(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::mojo_base::mojom::String16DataView, UserType>(),
            "Attempting to read the optional `suggested_name` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadSuggestedName` instead "
            "of `ReadSuggestedName if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->suggested_name.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::String16DataView>(pointer, output, message_);
    }
    template <typename UserType> [[nodiscard]] bool ReadCrossOriginRedirects(UserType* output) const
    {
        auto data_value = data_->cross_origin_redirects;
        return mojo::internal::Deserialize<::network::mojom::RedirectMode>(data_value, output);
    }
    ::network::mojom::RedirectMode cross_origin_redirects() const
    {
        return ::mojo::internal::ToKnownEnumValueHelper(static_cast<::network::mojom::RedirectMode>(data_->cross_origin_redirects));
    }
    template <typename UserType> UserType TakeBlobUrlToken()
    {
        UserType result;
        bool ret
            = mojo::internal::Deserialize<mojo::InterfacePtrDataView<::blink::mojom::BlobURLTokenInterfaceBase>>(&data_->blob_url_token, &result, message_);
        DCHECK(ret);
        return result;
    }
    template <typename UserType> UserType TakeDataUrlBlob()
    {
        UserType result;
        bool ret = mojo::internal::Deserialize<mojo::InterfacePtrDataView<::blink::mojom::BlobInterfaceBase>>(&data_->data_url_blob, &result, message_);
        DCHECK(ret);
        return result;
    }
    bool is_context_menu_save() const
    {
        return data_->is_context_menu_save;
    }
    bool has_user_gesture() const
    {
        return data_->has_user_gesture;
    }

private:
    internal::DownloadURLParams_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class IframeAttributesDataView {
public:
    IframeAttributesDataView() = default;

    IframeAttributesDataView(internal::IframeAttributes_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetParsedCspAttributeDataView(::network::mojom::ContentSecurityPolicyDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadParsedCspAttribute(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::network::mojom::ContentSecurityPolicyDataView, UserType>(),
            "Attempting to read the optional `parsed_csp_attribute` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadParsedCspAttribute` instead "
            "of `ReadParsedCspAttribute if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->parsed_csp_attribute.Get();
        return mojo::internal::Deserialize<::network::mojom::ContentSecurityPolicyDataView>(pointer, output, message_);
    }
    bool credentialless() const
    {
        return data_->credentialless;
    }
    bool browsing_topics() const
    {
        return data_->browsing_topics;
    }
    bool ad_auction_headers() const
    {
        return data_->ad_auction_headers;
    }
    bool shared_storage_writable_opted_in() const
    {
        return data_->shared_storage_writable_opted_in;
    }
    inline void GetIdDataView(mojo::StringDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadId(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<mojo::StringDataView, UserType>(),
            "Attempting to read the optional `id` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadId` instead "
            "of `ReadId if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->id.Get();
        return mojo::internal::Deserialize<mojo::StringDataView>(pointer, output, message_);
    }
    inline void GetNameDataView(mojo::StringDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadName(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<mojo::StringDataView, UserType>(),
            "Attempting to read the optional `name` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadName` instead "
            "of `ReadName if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->name.Get();
        return mojo::internal::Deserialize<mojo::StringDataView>(pointer, output, message_);
    }
    inline void GetSrcDataView(mojo::StringDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadSrc(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<mojo::StringDataView, UserType>(),
            "Attempting to read the optional `src` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadSrc` instead "
            "of `ReadSrc if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->src.Get();
        return mojo::internal::Deserialize<mojo::StringDataView>(pointer, output, message_);
    }

private:
    internal::IframeAttributes_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class LegacyTechEventCodeLocationDataView {
public:
    LegacyTechEventCodeLocationDataView() = default;

    LegacyTechEventCodeLocationDataView(internal::LegacyTechEventCodeLocation_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetFilenameDataView(mojo::StringDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadFilename(UserType* output)
    {

        auto* pointer = data_->filename.Get();
        return mojo::internal::Deserialize<mojo::StringDataView>(pointer, output, message_);
    }
    uint64_t line() const
    {
        return data_->line;
    }
    uint64_t column() const
    {
        return data_->column;
    }

private:
    internal::LegacyTechEventCodeLocation_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

} // blink::mojom

namespace std {

template <> struct hash<::blink::mojom::PluginActionType> : public mojo::internal::EnumHashImpl<::blink::mojom::PluginActionType> { };

template <> struct hash<::blink::mojom::JavaScriptExecutionResultType> : public mojo::internal::EnumHashImpl<::blink::mojom::JavaScriptExecutionResultType> { };

template <> struct hash<::blink::mojom::TraverseCancelledReason> : public mojo::internal::EnumHashImpl<::blink::mojom::TraverseCancelledReason> { };

template <> struct hash<::blink::mojom::ViewTransitionSameOriginOptIn> : public mojo::internal::EnumHashImpl<::blink::mojom::ViewTransitionSameOriginOptIn> { };

template <> struct hash<::blink::mojom::FrameOwnerElementType> : public mojo::internal::EnumHashImpl<::blink::mojom::FrameOwnerElementType> { };

template <>
struct hash<::blink::mojom::NavigationApiEntryRestoreReason> : public mojo::internal::EnumHashImpl<::blink::mojom::NavigationApiEntryRestoreReason> { };

template <> struct hash<::blink::mojom::StorageTypeAccessed> : public mojo::internal::EnumHashImpl<::blink::mojom::StorageTypeAccessed> { };

template <> struct hash<::blink::mojom::WindowProxyAccessType> : public mojo::internal::EnumHashImpl<::blink::mojom::WindowProxyAccessType> { };

} // namespace std

namespace mojo {

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::PluginActionType, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = EnumTraits<::blink::mojom::PluginActionType, UserType>;

    static void Serialize(UserType input, int32_t* output)
    {
        *output = static_cast<int32_t>(Traits::ToMojom(input));
    }

    static bool Deserialize(int32_t input, UserType* output)
    {
        return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(static_cast<::blink::mojom::PluginActionType>(input)), output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::JavaScriptExecutionResultType, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = EnumTraits<::blink::mojom::JavaScriptExecutionResultType, UserType>;

    static void Serialize(UserType input, int32_t* output)
    {
        *output = static_cast<int32_t>(Traits::ToMojom(input));
    }

    static bool Deserialize(int32_t input, UserType* output)
    {
        return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(static_cast<::blink::mojom::JavaScriptExecutionResultType>(input)), output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::TraverseCancelledReason, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = EnumTraits<::blink::mojom::TraverseCancelledReason, UserType>;

    static void Serialize(UserType input, int32_t* output)
    {
        *output = static_cast<int32_t>(Traits::ToMojom(input));
    }

    static bool Deserialize(int32_t input, UserType* output)
    {
        return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(static_cast<::blink::mojom::TraverseCancelledReason>(input)), output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::ViewTransitionSameOriginOptIn, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = EnumTraits<::blink::mojom::ViewTransitionSameOriginOptIn, UserType>;

    static void Serialize(UserType input, int32_t* output)
    {
        *output = static_cast<int32_t>(Traits::ToMojom(input));
    }

    static bool Deserialize(int32_t input, UserType* output)
    {
        return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(static_cast<::blink::mojom::ViewTransitionSameOriginOptIn>(input)), output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::FrameOwnerElementType, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = EnumTraits<::blink::mojom::FrameOwnerElementType, UserType>;

    static void Serialize(UserType input, int32_t* output)
    {
        *output = static_cast<int32_t>(Traits::ToMojom(input));
    }

    static bool Deserialize(int32_t input, UserType* output)
    {
        return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(static_cast<::blink::mojom::FrameOwnerElementType>(input)), output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::NavigationApiEntryRestoreReason, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = EnumTraits<::blink::mojom::NavigationApiEntryRestoreReason, UserType>;

    static void Serialize(UserType input, int32_t* output)
    {
        *output = static_cast<int32_t>(Traits::ToMojom(input));
    }

    static bool Deserialize(int32_t input, UserType* output)
    {
        return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(static_cast<::blink::mojom::NavigationApiEntryRestoreReason>(input)), output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::StorageTypeAccessed, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = EnumTraits<::blink::mojom::StorageTypeAccessed, UserType>;

    static void Serialize(UserType input, int32_t* output)
    {
        *output = static_cast<int32_t>(Traits::ToMojom(input));
    }

    static bool Deserialize(int32_t input, UserType* output)
    {
        return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(static_cast<::blink::mojom::StorageTypeAccessed>(input)), output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::WindowProxyAccessType, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = EnumTraits<::blink::mojom::WindowProxyAccessType, UserType>;

    static void Serialize(UserType input, int32_t* output)
    {
        *output = static_cast<int32_t>(Traits::ToMojom(input));
    }

    static bool Deserialize(int32_t input, UserType* output)
    {
        return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(static_cast<::blink::mojom::WindowProxyAccessType>(input)), output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::SavableSubframeDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::blink::mojom::SavableSubframeDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::blink::mojom::internal::SavableSubframe_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::original_url(input)) in_original_url = Traits::original_url(input);
        mojo::internal::MessageFragment<typename decltype(fragment->original_url)::BaseType> original_url_fragment(fragment.message());
        mojo::internal::Serialize<::url::mojom::UrlDataView>(in_original_url, original_url_fragment);
        fragment->original_url.Set(original_url_fragment.is_null() ? nullptr : original_url_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->original_url.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null original_url in SavableSubframe struct");
        decltype(Traits::subframe_token(input)) in_subframe_token = Traits::subframe_token(input);
        mojo::internal::MessageFragment<decltype(fragment->subframe_token)> subframe_token_fragment(fragment.message());
        subframe_token_fragment.Claim(&fragment->subframe_token);
        mojo::internal::Serialize<::blink::mojom::FrameTokenDataView>(in_subframe_token, subframe_token_fragment, true);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->subframe_token.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null subframe_token in SavableSubframe struct");
    }

    static bool Deserialize(::blink::mojom::internal::SavableSubframe_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::blink::mojom::SavableSubframeDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::GetSavableResourceLinksReplyDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::blink::mojom::GetSavableResourceLinksReplyDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::blink::mojom::internal::GetSavableResourceLinksReply_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::resources_list(input)) in_resources_list = Traits::resources_list(input);
        mojo::internal::MessageFragment<typename decltype(fragment->resources_list)::BaseType> resources_list_fragment(fragment.message());
        constexpr const mojo::internal::ContainerValidateParams& resources_list_validate_params = mojo::internal::GetArrayValidator<0, false, nullptr>();
        mojo::internal::Serialize<mojo::ArrayDataView<::url::mojom::UrlDataView>>(in_resources_list, resources_list_fragment, &resources_list_validate_params);
        fragment->resources_list.Set(resources_list_fragment.is_null() ? nullptr : resources_list_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(fragment->resources_list.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null resources_list in GetSavableResourceLinksReply struct");
        decltype(Traits::referrer(input)) in_referrer = Traits::referrer(input);
        mojo::internal::MessageFragment<typename decltype(fragment->referrer)::BaseType> referrer_fragment(fragment.message());
        mojo::internal::Serialize<::blink::mojom::ReferrerDataView>(in_referrer, referrer_fragment);
        fragment->referrer.Set(referrer_fragment.is_null() ? nullptr : referrer_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->referrer.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null referrer in GetSavableResourceLinksReply struct");
        decltype(Traits::subframes(input)) in_subframes = Traits::subframes(input);
        mojo::internal::MessageFragment<typename decltype(fragment->subframes)::BaseType> subframes_fragment(fragment.message());
        constexpr const mojo::internal::ContainerValidateParams& subframes_validate_params = mojo::internal::GetArrayValidator<0, false, nullptr>();
        mojo::internal::Serialize<mojo::ArrayDataView<::blink::mojom::SavableSubframeDataView>>(in_subframes, subframes_fragment, &subframes_validate_params);
        fragment->subframes.Set(subframes_fragment.is_null() ? nullptr : subframes_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->subframes.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null subframes in GetSavableResourceLinksReply struct");
    }

    static bool Deserialize(::blink::mojom::internal::GetSavableResourceLinksReply_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::blink::mojom::GetSavableResourceLinksReplyDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::FindInPageResultAXParamsDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::blink::mojom::FindInPageResultAXParamsDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::blink::mojom::internal::FindInPageResultAXParams_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        fragment->request_id = Traits::request_id(input);
        fragment->match_index = Traits::match_index(input);
        fragment->start_id = Traits::start_id(input);
        fragment->start_offset = Traits::start_offset(input);
        fragment->end_id = Traits::end_id(input);
        fragment->end_offset = Traits::end_offset(input);
    }

    static bool Deserialize(::blink::mojom::internal::FindInPageResultAXParams_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::blink::mojom::FindInPageResultAXParamsDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::DownloadURLParamsDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::blink::mojom::DownloadURLParamsDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::blink::mojom::internal::DownloadURLParams_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::url(input)) in_url = Traits::url(input);
        mojo::internal::MessageFragment<typename decltype(fragment->url)::BaseType> url_fragment(fragment.message());
        mojo::internal::Serialize<::url::mojom::UrlDataView>(in_url, url_fragment);
        fragment->url.Set(url_fragment.is_null() ? nullptr : url_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->url.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null url in DownloadURLParams struct");
        decltype(Traits::referrer(input)) in_referrer = Traits::referrer(input);
        mojo::internal::MessageFragment<typename decltype(fragment->referrer)::BaseType> referrer_fragment(fragment.message());
        mojo::internal::Serialize<::blink::mojom::ReferrerDataView>(in_referrer, referrer_fragment);
        fragment->referrer.Set(referrer_fragment.is_null() ? nullptr : referrer_fragment.data());
        decltype(Traits::initiator_origin(input)) in_initiator_origin = Traits::initiator_origin(input);
        mojo::internal::MessageFragment<typename decltype(fragment->initiator_origin)::BaseType> initiator_origin_fragment(fragment.message());
        mojo::internal::Serialize<::url::mojom::OriginDataView>(in_initiator_origin, initiator_origin_fragment);
        fragment->initiator_origin.Set(initiator_origin_fragment.is_null() ? nullptr : initiator_origin_fragment.data());
        decltype(Traits::suggested_name(input)) in_suggested_name = Traits::suggested_name(input);
        mojo::internal::MessageFragment<typename decltype(fragment->suggested_name)::BaseType> suggested_name_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(in_suggested_name, suggested_name_fragment);
        fragment->suggested_name.Set(suggested_name_fragment.is_null() ? nullptr : suggested_name_fragment.data());
        mojo::internal::Serialize<::network::mojom::RedirectMode>(Traits::cross_origin_redirects(input), &fragment->cross_origin_redirects);
        decltype(Traits::blob_url_token(input)) in_blob_url_token = Traits::blob_url_token(input);
        mojo::internal::Serialize<mojo::InterfacePtrDataView<::blink::mojom::BlobURLTokenInterfaceBase>>(
            in_blob_url_token, &fragment->blob_url_token, &fragment.message());
        decltype(Traits::data_url_blob(input)) in_data_url_blob = Traits::data_url_blob(input);
        mojo::internal::Serialize<mojo::InterfacePtrDataView<::blink::mojom::BlobInterfaceBase>>(
            in_data_url_blob, &fragment->data_url_blob, &fragment.message());
        fragment->is_context_menu_save = Traits::is_context_menu_save(input);
        fragment->has_user_gesture = Traits::has_user_gesture(input);
    }

    static bool Deserialize(::blink::mojom::internal::DownloadURLParams_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::blink::mojom::DownloadURLParamsDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::IframeAttributesDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::blink::mojom::IframeAttributesDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::blink::mojom::internal::IframeAttributes_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::parsed_csp_attribute(input)) in_parsed_csp_attribute = Traits::parsed_csp_attribute(input);
        mojo::internal::MessageFragment<typename decltype(fragment->parsed_csp_attribute)::BaseType> parsed_csp_attribute_fragment(fragment.message());
        mojo::internal::Serialize<::network::mojom::ContentSecurityPolicyDataView>(in_parsed_csp_attribute, parsed_csp_attribute_fragment);
        fragment->parsed_csp_attribute.Set(parsed_csp_attribute_fragment.is_null() ? nullptr : parsed_csp_attribute_fragment.data());
        fragment->credentialless = Traits::credentialless(input);
        fragment->browsing_topics = Traits::browsing_topics(input);
        fragment->ad_auction_headers = Traits::ad_auction_headers(input);
        fragment->shared_storage_writable_opted_in = Traits::shared_storage_writable_opted_in(input);
        decltype(Traits::id(input)) in_id = Traits::id(input);
        mojo::internal::MessageFragment<typename decltype(fragment->id)::BaseType> id_fragment(fragment.message());
        mojo::internal::Serialize<mojo::StringDataView>(in_id, id_fragment);
        fragment->id.Set(id_fragment.is_null() ? nullptr : id_fragment.data());
        decltype(Traits::name(input)) in_name = Traits::name(input);
        mojo::internal::MessageFragment<typename decltype(fragment->name)::BaseType> name_fragment(fragment.message());
        mojo::internal::Serialize<mojo::StringDataView>(in_name, name_fragment);
        fragment->name.Set(name_fragment.is_null() ? nullptr : name_fragment.data());
        decltype(Traits::src(input)) in_src = Traits::src(input);
        mojo::internal::MessageFragment<typename decltype(fragment->src)::BaseType> src_fragment(fragment.message());
        mojo::internal::Serialize<mojo::StringDataView>(in_src, src_fragment);
        fragment->src.Set(src_fragment.is_null() ? nullptr : src_fragment.data());
    }

    static bool Deserialize(::blink::mojom::internal::IframeAttributes_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::blink::mojom::IframeAttributesDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::LegacyTechEventCodeLocationDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::blink::mojom::LegacyTechEventCodeLocationDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::blink::mojom::internal::LegacyTechEventCodeLocation_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::filename(input)) in_filename = Traits::filename(input);
        mojo::internal::MessageFragment<typename decltype(fragment->filename)::BaseType> filename_fragment(fragment.message());
        mojo::internal::Serialize<mojo::StringDataView>(in_filename, filename_fragment);
        fragment->filename.Set(filename_fragment.is_null() ? nullptr : filename_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->filename.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null filename in LegacyTechEventCodeLocation struct");
        fragment->line = Traits::line(input);
        fragment->column = Traits::column(input);
    }

    static bool Deserialize(::blink::mojom::internal::LegacyTechEventCodeLocation_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::blink::mojom::LegacyTechEventCodeLocationDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

} // namespace mojo

namespace blink::mojom {

inline void SavableSubframeDataView::GetOriginalUrlDataView(::url::mojom::UrlDataView* output)
{
    auto pointer = data_->original_url.Get();
    *output = ::url::mojom::UrlDataView(pointer, message_);
}
inline void SavableSubframeDataView::GetSubframeTokenDataView(::blink::mojom::FrameTokenDataView* output)
{
    auto pointer = &data_->subframe_token;
    *output = ::blink::mojom::FrameTokenDataView(pointer, message_);
}

inline void GetSavableResourceLinksReplyDataView::GetResourcesListDataView(mojo::ArrayDataView<::url::mojom::UrlDataView>* output)
{
    auto pointer = data_->resources_list.Get();
    *output = mojo::ArrayDataView<::url::mojom::UrlDataView>(pointer, message_);
}
inline void GetSavableResourceLinksReplyDataView::GetReferrerDataView(::blink::mojom::ReferrerDataView* output)
{
    auto pointer = data_->referrer.Get();
    *output = ::blink::mojom::ReferrerDataView(pointer, message_);
}
inline void GetSavableResourceLinksReplyDataView::GetSubframesDataView(mojo::ArrayDataView<SavableSubframeDataView>* output)
{
    auto pointer = data_->subframes.Get();
    *output = mojo::ArrayDataView<SavableSubframeDataView>(pointer, message_);
}

inline void DownloadURLParamsDataView::GetUrlDataView(::url::mojom::UrlDataView* output)
{
    auto pointer = data_->url.Get();
    *output = ::url::mojom::UrlDataView(pointer, message_);
}
inline void DownloadURLParamsDataView::GetReferrerDataView(::blink::mojom::ReferrerDataView* output)
{
    auto pointer = data_->referrer.Get();
    *output = ::blink::mojom::ReferrerDataView(pointer, message_);
}
inline void DownloadURLParamsDataView::GetInitiatorOriginDataView(::url::mojom::OriginDataView* output)
{
    auto pointer = data_->initiator_origin.Get();
    *output = ::url::mojom::OriginDataView(pointer, message_);
}
inline void DownloadURLParamsDataView::GetSuggestedNameDataView(::mojo_base::mojom::String16DataView* output)
{
    auto pointer = data_->suggested_name.Get();
    *output = ::mojo_base::mojom::String16DataView(pointer, message_);
}

inline void IframeAttributesDataView::GetParsedCspAttributeDataView(::network::mojom::ContentSecurityPolicyDataView* output)
{
    auto pointer = data_->parsed_csp_attribute.Get();
    *output = ::network::mojom::ContentSecurityPolicyDataView(pointer, message_);
}
inline void IframeAttributesDataView::GetIdDataView(mojo::StringDataView* output)
{
    auto pointer = data_->id.Get();
    *output = mojo::StringDataView(pointer, message_);
}
inline void IframeAttributesDataView::GetNameDataView(mojo::StringDataView* output)
{
    auto pointer = data_->name.Get();
    *output = mojo::StringDataView(pointer, message_);
}
inline void IframeAttributesDataView::GetSrcDataView(mojo::StringDataView* output)
{
    auto pointer = data_->src.Get();
    *output = mojo::StringDataView(pointer, message_);
}

inline void LegacyTechEventCodeLocationDataView::GetFilenameDataView(mojo::StringDataView* output)
{
    auto pointer = data_->filename.Get();
    *output = mojo::StringDataView(pointer, message_);
}

} // blink::mojom

// Declare TraceFormatTraits for enums, which should be defined in ::perfetto
// namespace.

namespace perfetto {

template <> struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::PluginActionType> {
    static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::PluginActionType value);
};

} // namespace perfetto

namespace perfetto {

template <> struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::JavaScriptExecutionResultType> {
    static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::JavaScriptExecutionResultType value);
};

} // namespace perfetto

namespace perfetto {

template <> struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::TraverseCancelledReason> {
    static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::TraverseCancelledReason value);
};

} // namespace perfetto

namespace perfetto {

template <> struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::ViewTransitionSameOriginOptIn> {
    static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::ViewTransitionSameOriginOptIn value);
};

} // namespace perfetto

namespace perfetto {

template <> struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::FrameOwnerElementType> {
    static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::FrameOwnerElementType value);
};

} // namespace perfetto

namespace perfetto {

template <> struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::NavigationApiEntryRestoreReason> {
    static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::NavigationApiEntryRestoreReason value);
};

} // namespace perfetto

namespace perfetto {

template <> struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::StorageTypeAccessed> {
    static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::StorageTypeAccessed value);
};

} // namespace perfetto

namespace perfetto {

template <> struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::WindowProxyAccessType> {
    static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::WindowProxyAccessType value);
};

} // namespace perfetto

#endif // THIRD_PARTY_BLINK_PUBLIC_MOJOM_FRAME_FRAME_MOJOM_SHARED_H_
