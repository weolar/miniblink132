// third_party/blink/public/mojom/frame/frame.mojom-blink.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif

#include "third_party/blink/public/mojom/frame/frame.mojom-blink.h"

#include <math.h>
#include <stdint.h>
#include <utility>

#include "base/debug/alias.h"
#include "base/hash/md5_constexpr.h"
#include "base/run_loop.h"
#include "base/strings/string_number_conversions.h"
#include "base/task/thread_pool/thread_pool_instance.h"
#include "base/trace_event/trace_event.h"
#include "base/trace_event/typed_macros.h"
#include "mojo/public/cpp/bindings/features.h"
#include "mojo/public/cpp/bindings/lib/default_construct_tag_internal.h"
#include "mojo/public/cpp/bindings/lib/generated_code_util.h"
#include "mojo/public/cpp/bindings/lib/message_internal.h"
#include "mojo/public/cpp/bindings/lib/proxy_to_responder.h"
#include "mojo/public/cpp/bindings/lib/send_message_helper.h"
#include "mojo/public/cpp/bindings/lib/serialization_util.h"
#include "mojo/public/cpp/bindings/lib/unserialized_message_context.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/mojo_buildflags.h"
#include "mojo/public/cpp/bindings/urgent_message_scope.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"
#include "third_party/perfetto/include/perfetto/tracing/traced_value.h"

#include "third_party/blink/public/mojom/frame/frame.mojom-params-data.h"
#include "third_party/blink/public/mojom/frame/frame.mojom-shared-message-ids.h"

#include "third_party/blink/public/mojom/frame/frame.mojom-blink-import-headers.h"
#include "third_party/blink/public/mojom/frame/frame.mojom-blink-test-utils.h"
#include "mojo/public/cpp/bindings/lib/wtf_serialization.h"
#include "third_party/blink/common/permissions_policy/permissions_policy_mojom_traits.h"
#include "third_party/blink/public/common/frame/view_transition_state_mojom_traits.h"
#include "third_party/blink/public/common/messaging/accelerated_static_bitmap_image_mojom_traits.h"
#include "third_party/blink/public/common/messaging/task_attribution_id_mojom_traits.h"

namespace blink::mojom::blink {
SavableSubframe::SavableSubframe()
    : original_url()
    , subframe_token()
{
}

SavableSubframe::SavableSubframe(const ::blink::KURL& original_url_in, const ::blink::FrameToken& subframe_token_in)
    : original_url(std::move(original_url_in))
    , subframe_token(std::move(subframe_token_in))
{
}

SavableSubframe::~SavableSubframe() = default;

void SavableSubframe::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("original_url"), this->original_url,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const ::blink::KURL&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("subframe_token"), this->subframe_token,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const ::blink::FrameToken&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool SavableSubframe::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
GetSavableResourceLinksReply::GetSavableResourceLinksReply()
    : resources_list()
    , referrer()
    , subframes()
{
}

GetSavableResourceLinksReply::GetSavableResourceLinksReply(
    WTF::Vector<::blink::KURL> resources_list_in, ::blink::mojom::blink::ReferrerPtr referrer_in, WTF::Vector<SavableSubframePtr> subframes_in)
    : resources_list(std::move(resources_list_in))
    , referrer(std::move(referrer_in))
    , subframes(std::move(subframes_in))
{
}

GetSavableResourceLinksReply::~GetSavableResourceLinksReply() = default;

void GetSavableResourceLinksReply::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("resources_list"), this->resources_list,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const WTF::Vector<::blink::KURL>&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("referrer"), this->referrer,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type ::blink::mojom::blink::ReferrerPtr>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("subframes"), this->subframes,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type WTF::Vector<SavableSubframePtr>>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool GetSavableResourceLinksReply::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
FindInPageResultAXParams::FindInPageResultAXParams()
    : request_id()
    , match_index()
    , start_id()
    , start_offset()
    , end_id()
    , end_offset()
{
}

FindInPageResultAXParams::FindInPageResultAXParams(
    int32_t request_id_in, int32_t match_index_in, int32_t start_id_in, int32_t start_offset_in, int32_t end_id_in, int32_t end_offset_in)
    : request_id(std::move(request_id_in))
    , match_index(std::move(match_index_in))
    , start_id(std::move(start_id_in))
    , start_offset(std::move(start_offset_in))
    , end_id(std::move(end_id_in))
    , end_offset(std::move(end_offset_in))
{
}

FindInPageResultAXParams::~FindInPageResultAXParams() = default;
size_t FindInPageResultAXParams::Hash(size_t seed) const
{
    seed = mojo::internal::WTFHash(seed, this->request_id);
    seed = mojo::internal::WTFHash(seed, this->match_index);
    seed = mojo::internal::WTFHash(seed, this->start_id);
    seed = mojo::internal::WTFHash(seed, this->start_offset);
    seed = mojo::internal::WTFHash(seed, this->end_id);
    seed = mojo::internal::WTFHash(seed, this->end_offset);
    return seed;
}

void FindInPageResultAXParams::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("request_id"), this->request_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type int32_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("match_index"), this->match_index,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type int32_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("start_id"), this->start_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type int32_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("start_offset"), this->start_offset,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type int32_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("end_id"), this->end_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type int32_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("end_offset"), this->end_offset,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type int32_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool FindInPageResultAXParams::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
DownloadURLParams::DownloadURLParams()
    : url()
    , referrer()
    , initiator_origin()
    , suggested_name()
    , cross_origin_redirects()
    , blob_url_token()
    , data_url_blob()
    , is_context_menu_save(false)
    , has_user_gesture(false)
{
}

DownloadURLParams::DownloadURLParams(const ::blink::KURL& url_in, ::blink::mojom::blink::ReferrerPtr referrer_in,
    const ::scoped_refptr<const ::blink::SecurityOrigin>& initiator_origin_in, const ::WTF::String& suggested_name_in,
    ::network::mojom::blink::RedirectMode cross_origin_redirects_in, ::mojo::PendingRemote<::blink::mojom::blink::BlobURLToken> blob_url_token_in,
    ::mojo::PendingRemote<::blink::mojom::blink::Blob> data_url_blob_in, bool is_context_menu_save_in, bool has_user_gesture_in)
    : url(std::move(url_in))
    , referrer(std::move(referrer_in))
    , initiator_origin(std::move(initiator_origin_in))
    , suggested_name(std::move(suggested_name_in))
    , cross_origin_redirects(std::move(cross_origin_redirects_in))
    , blob_url_token(std::move(blob_url_token_in))
    , data_url_blob(std::move(data_url_blob_in))
    , is_context_menu_save(std::move(is_context_menu_save_in))
    , has_user_gesture(std::move(has_user_gesture_in))
{
}

DownloadURLParams::~DownloadURLParams() = default;

void DownloadURLParams::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("url"), this->url,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const ::blink::KURL&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("referrer"), this->referrer,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type ::blink::mojom::blink::ReferrerPtr>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("initiator_origin"), this->initiator_origin,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const ::scoped_refptr<const ::blink::SecurityOrigin>&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("suggested_name"), this->suggested_name,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const ::WTF::String&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("cross_origin_redirects"), this->cross_origin_redirects,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type ::network::mojom::blink::RedirectMode>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("blob_url_token"), this->blob_url_token,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type ::mojo::PendingRemote<::blink::mojom::blink::BlobURLToken>>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("data_url_blob"), this->data_url_blob,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type ::mojo::PendingRemote<::blink::mojom::blink::Blob>>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("is_context_menu_save"), this->is_context_menu_save,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type bool>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("has_user_gesture"), this->has_user_gesture,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type bool>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool DownloadURLParams::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
IframeAttributes::IframeAttributes()
    : parsed_csp_attribute()
    , credentialless()
    , browsing_topics()
    , ad_auction_headers()
    , shared_storage_writable_opted_in()
    , id()
    , name()
    , src()
{
}

IframeAttributes::IframeAttributes(::network::mojom::blink::ContentSecurityPolicyPtr parsed_csp_attribute_in, bool credentialless_in, bool browsing_topics_in,
    bool ad_auction_headers_in, bool shared_storage_writable_opted_in_in, const WTF::String& id_in, const WTF::String& name_in, const WTF::String& src_in)
    : parsed_csp_attribute(std::move(parsed_csp_attribute_in))
    , credentialless(std::move(credentialless_in))
    , browsing_topics(std::move(browsing_topics_in))
    , ad_auction_headers(std::move(ad_auction_headers_in))
    , shared_storage_writable_opted_in(std::move(shared_storage_writable_opted_in_in))
    , id(std::move(id_in))
    , name(std::move(name_in))
    , src(std::move(src_in))
{
}

IframeAttributes::~IframeAttributes() = default;

void IframeAttributes::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("parsed_csp_attribute"), this->parsed_csp_attribute,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type ::network::mojom::blink::ContentSecurityPolicyPtr>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("credentialless"), this->credentialless,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type bool>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("browsing_topics"), this->browsing_topics,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type bool>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("ad_auction_headers"), this->ad_auction_headers,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type bool>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("shared_storage_writable_opted_in"), this->shared_storage_writable_opted_in,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type bool>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("id"), this->id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const WTF::String&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("name"), this->name,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const WTF::String&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("src"), this->src,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const WTF::String&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool IframeAttributes::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
LegacyTechEventCodeLocation::LegacyTechEventCodeLocation()
    : filename()
    , line()
    , column()
{
}

LegacyTechEventCodeLocation::LegacyTechEventCodeLocation(const WTF::String& filename_in, uint64_t line_in, uint64_t column_in)
    : filename(std::move(filename_in))
    , line(std::move(line_in))
    , column(std::move(column_in))
{
}

LegacyTechEventCodeLocation::~LegacyTechEventCodeLocation() = default;
size_t LegacyTechEventCodeLocation::Hash(size_t seed) const
{
    seed = mojo::internal::WTFHash(seed, this->filename);
    seed = mojo::internal::WTFHash(seed, this->line);
    seed = mojo::internal::WTFHash(seed, this->column);
    return seed;
}

void LegacyTechEventCodeLocation::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("filename"), this->filename,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const WTF::String&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("line"), this->line,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("column"), this->column,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool LegacyTechEventCodeLocation::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
const char LocalFrameHost::Name_[] = "blink.mojom.LocalFrameHost";

LocalFrameHost::IPCStableHashFunction LocalFrameHost::MessageToMethodInfo_(mojo::Message& message)
{
#if !BUILDFLAG(IS_FUCHSIA)
    switch (static_cast<messages::LocalFrameHost>(message.name())) {
    case messages::LocalFrameHost::kEnterFullscreen: {
        return &LocalFrameHost::EnterFullscreen_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kExitFullscreen: {
        return &LocalFrameHost::ExitFullscreen_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kFullscreenStateChanged: {
        return &LocalFrameHost::FullscreenStateChanged_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kRegisterProtocolHandler: {
        return &LocalFrameHost::RegisterProtocolHandler_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kUnregisterProtocolHandler: {
        return &LocalFrameHost::UnregisterProtocolHandler_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kDidDisplayInsecureContent: {
        return &LocalFrameHost::DidDisplayInsecureContent_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kDidContainInsecureFormAction: {
        return &LocalFrameHost::DidContainInsecureFormAction_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kMainDocumentElementAvailable: {
        return &LocalFrameHost::MainDocumentElementAvailable_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kSetNeedsOcclusionTracking: {
        return &LocalFrameHost::SetNeedsOcclusionTracking_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kSetVirtualKeyboardMode: {
        return &LocalFrameHost::SetVirtualKeyboardMode_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kVisibilityChanged: {
        return &LocalFrameHost::VisibilityChanged_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kDidChangeThemeColor: {
        return &LocalFrameHost::DidChangeThemeColor_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kDidChangeBackgroundColor: {
        return &LocalFrameHost::DidChangeBackgroundColor_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kDidFailLoadWithError: {
        return &LocalFrameHost::DidFailLoadWithError_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kDidFocusFrame: {
        return &LocalFrameHost::DidFocusFrame_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kDidCallFocus: {
        return &LocalFrameHost::DidCallFocus_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kEnforceInsecureRequestPolicy: {
        return &LocalFrameHost::EnforceInsecureRequestPolicy_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kEnforceInsecureNavigationsSet: {
        return &LocalFrameHost::EnforceInsecureNavigationsSet_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kSuddenTerminationDisablerChanged: {
        return &LocalFrameHost::SuddenTerminationDisablerChanged_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kHadStickyUserActivationBeforeNavigationChanged: {
        return &LocalFrameHost::HadStickyUserActivationBeforeNavigationChanged_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kScrollRectToVisibleInParentFrame: {
        return &LocalFrameHost::ScrollRectToVisibleInParentFrame_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kBubbleLogicalScrollInParentFrame: {
        return &LocalFrameHost::BubbleLogicalScrollInParentFrame_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kStartLoadingForAsyncNavigationApiCommit: {
        return &LocalFrameHost::StartLoadingForAsyncNavigationApiCommit_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kDidBlockNavigation: {
        return &LocalFrameHost::DidBlockNavigation_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kDidChangeLoadProgress: {
        return &LocalFrameHost::DidChangeLoadProgress_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kDidFinishLoad: {
        return &LocalFrameHost::DidFinishLoad_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kDispatchLoad: {
        return &LocalFrameHost::DispatchLoad_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kGoToEntryAtOffset: {
        return &LocalFrameHost::GoToEntryAtOffset_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kNavigateToNavigationApiKey: {
        return &LocalFrameHost::NavigateToNavigationApiKey_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kNavigateEventHandlerPresenceChanged: {
        return &LocalFrameHost::NavigateEventHandlerPresenceChanged_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kUpdateTitle: {
        return &LocalFrameHost::UpdateTitle_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kUpdateAppTitle: {
        return &LocalFrameHost::UpdateAppTitle_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kUpdateUserActivationState: {
        return &LocalFrameHost::UpdateUserActivationState_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kDidConsumeHistoryUserActivation: {
        return &LocalFrameHost::DidConsumeHistoryUserActivation_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kHandleAccessibilityFindInPageResult: {
        return &LocalFrameHost::HandleAccessibilityFindInPageResult_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kHandleAccessibilityFindInPageTermination: {
        return &LocalFrameHost::HandleAccessibilityFindInPageTermination_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kDocumentOnLoadCompleted: {
        return &LocalFrameHost::DocumentOnLoadCompleted_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kForwardResourceTimingToParent: {
        return &LocalFrameHost::ForwardResourceTimingToParent_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kDidDispatchDOMContentLoadedEvent: {
        return &LocalFrameHost::DidDispatchDOMContentLoadedEvent_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kRunModalAlertDialog: {
        return &LocalFrameHost::RunModalAlertDialog_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kRunModalConfirmDialog: {
        return &LocalFrameHost::RunModalConfirmDialog_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kRunModalPromptDialog: {
        return &LocalFrameHost::RunModalPromptDialog_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kRunBeforeUnloadConfirm: {
        return &LocalFrameHost::RunBeforeUnloadConfirm_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kUpdateFaviconURL: {
        return &LocalFrameHost::UpdateFaviconURL_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kDownloadURL: {
        return &LocalFrameHost::DownloadURL_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kFocusedElementChanged: {
        return &LocalFrameHost::FocusedElementChanged_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kTextSelectionChanged: {
        return &LocalFrameHost::TextSelectionChanged_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kShowPopupMenu: {
        return &LocalFrameHost::ShowPopupMenu_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kCreateNewPopupWidget: {
        return &LocalFrameHost::CreateNewPopupWidget_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kShowContextMenu: {
        return &LocalFrameHost::ShowContextMenu_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kDidLoadResourceFromMemoryCache: {
        return &LocalFrameHost::DidLoadResourceFromMemoryCache_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kDidChangeFrameOwnerProperties: {
        return &LocalFrameHost::DidChangeFrameOwnerProperties_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kDidChangeOpener: {
        return &LocalFrameHost::DidChangeOpener_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kDidChangeFramePolicy: {
        return &LocalFrameHost::DidChangeFramePolicy_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kDidChangeIframeAttributes: {
        return &LocalFrameHost::DidChangeIframeAttributes_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kCapturePaintPreviewOfSubframe: {
        return &LocalFrameHost::CapturePaintPreviewOfSubframe_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kSetCloseListener: {
        return &LocalFrameHost::SetCloseListener_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kDetach: {
        return &LocalFrameHost::Detach_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kGetKeepAliveHandleFactory: {
        return &LocalFrameHost::GetKeepAliveHandleFactory_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kDidAddMessageToConsole: {
        return &LocalFrameHost::DidAddMessageToConsole_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kFrameSizeChanged: {
        return &LocalFrameHost::FrameSizeChanged_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kDidInferColorScheme: {
        return &LocalFrameHost::DidInferColorScheme_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kDidChangeSrcDoc: {
        return &LocalFrameHost::DidChangeSrcDoc_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kReceivedDelegatedCapability: {
        return &LocalFrameHost::ReceivedDelegatedCapability_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kSendFencedFrameReportingBeacon: {
        return &LocalFrameHost::SendFencedFrameReportingBeacon_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kSendFencedFrameReportingBeaconToCustomURL: {
        return &LocalFrameHost::SendFencedFrameReportingBeaconToCustomURL_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kDisableUntrustedNetworkInFencedFrame: {
        return &LocalFrameHost::DisableUntrustedNetworkInFencedFrame_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kExemptUrlFromNetworkRevocationForTesting: {
        return &LocalFrameHost::ExemptUrlFromNetworkRevocationForTesting_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kSendLegacyTechEvent: {
        return &LocalFrameHost::SendLegacyTechEvent_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kSetFencedFrameAutomaticBeaconReportEventData: {
        return &LocalFrameHost::SetFencedFrameAutomaticBeaconReportEventData_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kSendPrivateAggregationRequestsForFencedFrameEvent: {
        return &LocalFrameHost::SendPrivateAggregationRequestsForFencedFrameEvent_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kCreateFencedFrame: {
        return &LocalFrameHost::CreateFencedFrame_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kForwardFencedFrameEventAndUserActivationToEmbedder: {
        return &LocalFrameHost::ForwardFencedFrameEventAndUserActivationToEmbedder_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kOnViewTransitionOptInChanged: {
        return &LocalFrameHost::OnViewTransitionOptInChanged_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kStartDragging: {
        return &LocalFrameHost::StartDragging_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kIssueKeepAliveHandle: {
        return &LocalFrameHost::IssueKeepAliveHandle_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kNotifyStorageAccessed: {
        return &LocalFrameHost::NotifyStorageAccessed_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kRecordWindowProxyUsageMetrics: {
        return &LocalFrameHost::RecordWindowProxyUsageMetrics_Sym::IPCStableHash;
    }
    case messages::LocalFrameHost::kNotifyDocumentInteractive: {
        return &LocalFrameHost::NotifyDocumentInteractive_Sym::IPCStableHash;
    }
    }
#endif // !BUILDFLAG(IS_FUCHSIA)
    return nullptr;
}

const char* LocalFrameHost::MessageToMethodName_(mojo::Message& message)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
    if (!is_response) {
        switch (static_cast<messages::LocalFrameHost>(message.name())) {
        case messages::LocalFrameHost::kEnterFullscreen:
            return "Receive blink::mojom::LocalFrameHost::EnterFullscreen";
        case messages::LocalFrameHost::kExitFullscreen:
            return "Receive blink::mojom::LocalFrameHost::ExitFullscreen";
        case messages::LocalFrameHost::kFullscreenStateChanged:
            return "Receive blink::mojom::LocalFrameHost::FullscreenStateChanged";
        case messages::LocalFrameHost::kRegisterProtocolHandler:
            return "Receive blink::mojom::LocalFrameHost::RegisterProtocolHandler";
        case messages::LocalFrameHost::kUnregisterProtocolHandler:
            return "Receive blink::mojom::LocalFrameHost::UnregisterProtocolHandler";
        case messages::LocalFrameHost::kDidDisplayInsecureContent:
            return "Receive blink::mojom::LocalFrameHost::DidDisplayInsecureContent";
        case messages::LocalFrameHost::kDidContainInsecureFormAction:
            return "Receive blink::mojom::LocalFrameHost::DidContainInsecureFormAction";
        case messages::LocalFrameHost::kMainDocumentElementAvailable:
            return "Receive blink::mojom::LocalFrameHost::MainDocumentElementAvailable";
        case messages::LocalFrameHost::kSetNeedsOcclusionTracking:
            return "Receive blink::mojom::LocalFrameHost::SetNeedsOcclusionTracking";
        case messages::LocalFrameHost::kSetVirtualKeyboardMode:
            return "Receive blink::mojom::LocalFrameHost::SetVirtualKeyboardMode";
        case messages::LocalFrameHost::kVisibilityChanged:
            return "Receive blink::mojom::LocalFrameHost::VisibilityChanged";
        case messages::LocalFrameHost::kDidChangeThemeColor:
            return "Receive blink::mojom::LocalFrameHost::DidChangeThemeColor";
        case messages::LocalFrameHost::kDidChangeBackgroundColor:
            return "Receive blink::mojom::LocalFrameHost::DidChangeBackgroundColor";
        case messages::LocalFrameHost::kDidFailLoadWithError:
            return "Receive blink::mojom::LocalFrameHost::DidFailLoadWithError";
        case messages::LocalFrameHost::kDidFocusFrame:
            return "Receive blink::mojom::LocalFrameHost::DidFocusFrame";
        case messages::LocalFrameHost::kDidCallFocus:
            return "Receive blink::mojom::LocalFrameHost::DidCallFocus";
        case messages::LocalFrameHost::kEnforceInsecureRequestPolicy:
            return "Receive blink::mojom::LocalFrameHost::EnforceInsecureRequestPolicy";
        case messages::LocalFrameHost::kEnforceInsecureNavigationsSet:
            return "Receive blink::mojom::LocalFrameHost::EnforceInsecureNavigationsSet";
        case messages::LocalFrameHost::kSuddenTerminationDisablerChanged:
            return "Receive blink::mojom::LocalFrameHost::SuddenTerminationDisablerChanged";
        case messages::LocalFrameHost::kHadStickyUserActivationBeforeNavigationChanged:
            return "Receive blink::mojom::LocalFrameHost::HadStickyUserActivationBeforeNavigationChanged";
        case messages::LocalFrameHost::kScrollRectToVisibleInParentFrame:
            return "Receive blink::mojom::LocalFrameHost::ScrollRectToVisibleInParentFrame";
        case messages::LocalFrameHost::kBubbleLogicalScrollInParentFrame:
            return "Receive blink::mojom::LocalFrameHost::BubbleLogicalScrollInParentFrame";
        case messages::LocalFrameHost::kStartLoadingForAsyncNavigationApiCommit:
            return "Receive blink::mojom::LocalFrameHost::StartLoadingForAsyncNavigationApiCommit";
        case messages::LocalFrameHost::kDidBlockNavigation:
            return "Receive blink::mojom::LocalFrameHost::DidBlockNavigation";
        case messages::LocalFrameHost::kDidChangeLoadProgress:
            return "Receive blink::mojom::LocalFrameHost::DidChangeLoadProgress";
        case messages::LocalFrameHost::kDidFinishLoad:
            return "Receive blink::mojom::LocalFrameHost::DidFinishLoad";
        case messages::LocalFrameHost::kDispatchLoad:
            return "Receive blink::mojom::LocalFrameHost::DispatchLoad";
        case messages::LocalFrameHost::kGoToEntryAtOffset:
            return "Receive blink::mojom::LocalFrameHost::GoToEntryAtOffset";
        case messages::LocalFrameHost::kNavigateToNavigationApiKey:
            return "Receive blink::mojom::LocalFrameHost::NavigateToNavigationApiKey";
        case messages::LocalFrameHost::kNavigateEventHandlerPresenceChanged:
            return "Receive blink::mojom::LocalFrameHost::NavigateEventHandlerPresenceChanged";
        case messages::LocalFrameHost::kUpdateTitle:
            return "Receive blink::mojom::LocalFrameHost::UpdateTitle";
        case messages::LocalFrameHost::kUpdateAppTitle:
            return "Receive blink::mojom::LocalFrameHost::UpdateAppTitle";
        case messages::LocalFrameHost::kUpdateUserActivationState:
            return "Receive blink::mojom::LocalFrameHost::UpdateUserActivationState";
        case messages::LocalFrameHost::kDidConsumeHistoryUserActivation:
            return "Receive blink::mojom::LocalFrameHost::DidConsumeHistoryUserActivation";
        case messages::LocalFrameHost::kHandleAccessibilityFindInPageResult:
            return "Receive blink::mojom::LocalFrameHost::HandleAccessibilityFindInPageResult";
        case messages::LocalFrameHost::kHandleAccessibilityFindInPageTermination:
            return "Receive blink::mojom::LocalFrameHost::HandleAccessibilityFindInPageTermination";
        case messages::LocalFrameHost::kDocumentOnLoadCompleted:
            return "Receive blink::mojom::LocalFrameHost::DocumentOnLoadCompleted";
        case messages::LocalFrameHost::kForwardResourceTimingToParent:
            return "Receive blink::mojom::LocalFrameHost::ForwardResourceTimingToParent";
        case messages::LocalFrameHost::kDidDispatchDOMContentLoadedEvent:
            return "Receive blink::mojom::LocalFrameHost::DidDispatchDOMContentLoadedEvent";
        case messages::LocalFrameHost::kRunModalAlertDialog:
            return "Receive blink::mojom::LocalFrameHost::RunModalAlertDialog";
        case messages::LocalFrameHost::kRunModalConfirmDialog:
            return "Receive blink::mojom::LocalFrameHost::RunModalConfirmDialog";
        case messages::LocalFrameHost::kRunModalPromptDialog:
            return "Receive blink::mojom::LocalFrameHost::RunModalPromptDialog";
        case messages::LocalFrameHost::kRunBeforeUnloadConfirm:
            return "Receive blink::mojom::LocalFrameHost::RunBeforeUnloadConfirm";
        case messages::LocalFrameHost::kUpdateFaviconURL:
            return "Receive blink::mojom::LocalFrameHost::UpdateFaviconURL";
        case messages::LocalFrameHost::kDownloadURL:
            return "Receive blink::mojom::LocalFrameHost::DownloadURL";
        case messages::LocalFrameHost::kFocusedElementChanged:
            return "Receive blink::mojom::LocalFrameHost::FocusedElementChanged";
        case messages::LocalFrameHost::kTextSelectionChanged:
            return "Receive blink::mojom::LocalFrameHost::TextSelectionChanged";
        case messages::LocalFrameHost::kShowPopupMenu:
            return "Receive blink::mojom::LocalFrameHost::ShowPopupMenu";
        case messages::LocalFrameHost::kCreateNewPopupWidget:
            return "Receive blink::mojom::LocalFrameHost::CreateNewPopupWidget";
        case messages::LocalFrameHost::kShowContextMenu:
            return "Receive blink::mojom::LocalFrameHost::ShowContextMenu";
        case messages::LocalFrameHost::kDidLoadResourceFromMemoryCache:
            return "Receive blink::mojom::LocalFrameHost::DidLoadResourceFromMemoryCache";
        case messages::LocalFrameHost::kDidChangeFrameOwnerProperties:
            return "Receive blink::mojom::LocalFrameHost::DidChangeFrameOwnerProperties";
        case messages::LocalFrameHost::kDidChangeOpener:
            return "Receive blink::mojom::LocalFrameHost::DidChangeOpener";
        case messages::LocalFrameHost::kDidChangeFramePolicy:
            return "Receive blink::mojom::LocalFrameHost::DidChangeFramePolicy";
        case messages::LocalFrameHost::kDidChangeIframeAttributes:
            return "Receive blink::mojom::LocalFrameHost::DidChangeIframeAttributes";
        case messages::LocalFrameHost::kCapturePaintPreviewOfSubframe:
            return "Receive blink::mojom::LocalFrameHost::CapturePaintPreviewOfSubframe";
        case messages::LocalFrameHost::kSetCloseListener:
            return "Receive blink::mojom::LocalFrameHost::SetCloseListener";
        case messages::LocalFrameHost::kDetach:
            return "Receive blink::mojom::LocalFrameHost::Detach";
        case messages::LocalFrameHost::kGetKeepAliveHandleFactory:
            return "Receive blink::mojom::LocalFrameHost::GetKeepAliveHandleFactory";
        case messages::LocalFrameHost::kDidAddMessageToConsole:
            return "Receive blink::mojom::LocalFrameHost::DidAddMessageToConsole";
        case messages::LocalFrameHost::kFrameSizeChanged:
            return "Receive blink::mojom::LocalFrameHost::FrameSizeChanged";
        case messages::LocalFrameHost::kDidInferColorScheme:
            return "Receive blink::mojom::LocalFrameHost::DidInferColorScheme";
        case messages::LocalFrameHost::kDidChangeSrcDoc:
            return "Receive blink::mojom::LocalFrameHost::DidChangeSrcDoc";
        case messages::LocalFrameHost::kReceivedDelegatedCapability:
            return "Receive blink::mojom::LocalFrameHost::ReceivedDelegatedCapability";
        case messages::LocalFrameHost::kSendFencedFrameReportingBeacon:
            return "Receive blink::mojom::LocalFrameHost::SendFencedFrameReportingBeacon";
        case messages::LocalFrameHost::kSendFencedFrameReportingBeaconToCustomURL:
            return "Receive blink::mojom::LocalFrameHost::SendFencedFrameReportingBeaconToCustomURL";
        case messages::LocalFrameHost::kDisableUntrustedNetworkInFencedFrame:
            return "Receive blink::mojom::LocalFrameHost::DisableUntrustedNetworkInFencedFrame";
        case messages::LocalFrameHost::kExemptUrlFromNetworkRevocationForTesting:
            return "Receive blink::mojom::LocalFrameHost::ExemptUrlFromNetworkRevocationForTesting";
        case messages::LocalFrameHost::kSendLegacyTechEvent:
            return "Receive blink::mojom::LocalFrameHost::SendLegacyTechEvent";
        case messages::LocalFrameHost::kSetFencedFrameAutomaticBeaconReportEventData:
            return "Receive blink::mojom::LocalFrameHost::SetFencedFrameAutomaticBeaconReportEventData";
        case messages::LocalFrameHost::kSendPrivateAggregationRequestsForFencedFrameEvent:
            return "Receive blink::mojom::LocalFrameHost::SendPrivateAggregationRequestsForFencedFrameEvent";
        case messages::LocalFrameHost::kCreateFencedFrame:
            return "Receive blink::mojom::LocalFrameHost::CreateFencedFrame";
        case messages::LocalFrameHost::kForwardFencedFrameEventAndUserActivationToEmbedder:
            return "Receive blink::mojom::LocalFrameHost::ForwardFencedFrameEventAndUserActivationToEmbedder";
        case messages::LocalFrameHost::kOnViewTransitionOptInChanged:
            return "Receive blink::mojom::LocalFrameHost::OnViewTransitionOptInChanged";
        case messages::LocalFrameHost::kStartDragging:
            return "Receive blink::mojom::LocalFrameHost::StartDragging";
        case messages::LocalFrameHost::kIssueKeepAliveHandle:
            return "Receive blink::mojom::LocalFrameHost::IssueKeepAliveHandle";
        case messages::LocalFrameHost::kNotifyStorageAccessed:
            return "Receive blink::mojom::LocalFrameHost::NotifyStorageAccessed";
        case messages::LocalFrameHost::kRecordWindowProxyUsageMetrics:
            return "Receive blink::mojom::LocalFrameHost::RecordWindowProxyUsageMetrics";
        case messages::LocalFrameHost::kNotifyDocumentInteractive:
            return "Receive blink::mojom::LocalFrameHost::NotifyDocumentInteractive";
        }
    } else {
        switch (static_cast<messages::LocalFrameHost>(message.name())) {
        case messages::LocalFrameHost::kEnterFullscreen:
            return "Receive reply blink::mojom::LocalFrameHost::EnterFullscreen";
        case messages::LocalFrameHost::kExitFullscreen:
            return "Receive reply blink::mojom::LocalFrameHost::ExitFullscreen";
        case messages::LocalFrameHost::kFullscreenStateChanged:
            return "Receive reply blink::mojom::LocalFrameHost::FullscreenStateChanged";
        case messages::LocalFrameHost::kRegisterProtocolHandler:
            return "Receive reply blink::mojom::LocalFrameHost::RegisterProtocolHandler";
        case messages::LocalFrameHost::kUnregisterProtocolHandler:
            return "Receive reply blink::mojom::LocalFrameHost::UnregisterProtocolHandler";
        case messages::LocalFrameHost::kDidDisplayInsecureContent:
            return "Receive reply blink::mojom::LocalFrameHost::DidDisplayInsecureContent";
        case messages::LocalFrameHost::kDidContainInsecureFormAction:
            return "Receive reply blink::mojom::LocalFrameHost::DidContainInsecureFormAction";
        case messages::LocalFrameHost::kMainDocumentElementAvailable:
            return "Receive reply blink::mojom::LocalFrameHost::MainDocumentElementAvailable";
        case messages::LocalFrameHost::kSetNeedsOcclusionTracking:
            return "Receive reply blink::mojom::LocalFrameHost::SetNeedsOcclusionTracking";
        case messages::LocalFrameHost::kSetVirtualKeyboardMode:
            return "Receive reply blink::mojom::LocalFrameHost::SetVirtualKeyboardMode";
        case messages::LocalFrameHost::kVisibilityChanged:
            return "Receive reply blink::mojom::LocalFrameHost::VisibilityChanged";
        case messages::LocalFrameHost::kDidChangeThemeColor:
            return "Receive reply blink::mojom::LocalFrameHost::DidChangeThemeColor";
        case messages::LocalFrameHost::kDidChangeBackgroundColor:
            return "Receive reply blink::mojom::LocalFrameHost::DidChangeBackgroundColor";
        case messages::LocalFrameHost::kDidFailLoadWithError:
            return "Receive reply blink::mojom::LocalFrameHost::DidFailLoadWithError";
        case messages::LocalFrameHost::kDidFocusFrame:
            return "Receive reply blink::mojom::LocalFrameHost::DidFocusFrame";
        case messages::LocalFrameHost::kDidCallFocus:
            return "Receive reply blink::mojom::LocalFrameHost::DidCallFocus";
        case messages::LocalFrameHost::kEnforceInsecureRequestPolicy:
            return "Receive reply blink::mojom::LocalFrameHost::EnforceInsecureRequestPolicy";
        case messages::LocalFrameHost::kEnforceInsecureNavigationsSet:
            return "Receive reply blink::mojom::LocalFrameHost::EnforceInsecureNavigationsSet";
        case messages::LocalFrameHost::kSuddenTerminationDisablerChanged:
            return "Receive reply blink::mojom::LocalFrameHost::SuddenTerminationDisablerChanged";
        case messages::LocalFrameHost::kHadStickyUserActivationBeforeNavigationChanged:
            return "Receive reply blink::mojom::LocalFrameHost::HadStickyUserActivationBeforeNavigationChanged";
        case messages::LocalFrameHost::kScrollRectToVisibleInParentFrame:
            return "Receive reply blink::mojom::LocalFrameHost::ScrollRectToVisibleInParentFrame";
        case messages::LocalFrameHost::kBubbleLogicalScrollInParentFrame:
            return "Receive reply blink::mojom::LocalFrameHost::BubbleLogicalScrollInParentFrame";
        case messages::LocalFrameHost::kStartLoadingForAsyncNavigationApiCommit:
            return "Receive reply blink::mojom::LocalFrameHost::StartLoadingForAsyncNavigationApiCommit";
        case messages::LocalFrameHost::kDidBlockNavigation:
            return "Receive reply blink::mojom::LocalFrameHost::DidBlockNavigation";
        case messages::LocalFrameHost::kDidChangeLoadProgress:
            return "Receive reply blink::mojom::LocalFrameHost::DidChangeLoadProgress";
        case messages::LocalFrameHost::kDidFinishLoad:
            return "Receive reply blink::mojom::LocalFrameHost::DidFinishLoad";
        case messages::LocalFrameHost::kDispatchLoad:
            return "Receive reply blink::mojom::LocalFrameHost::DispatchLoad";
        case messages::LocalFrameHost::kGoToEntryAtOffset:
            return "Receive reply blink::mojom::LocalFrameHost::GoToEntryAtOffset";
        case messages::LocalFrameHost::kNavigateToNavigationApiKey:
            return "Receive reply blink::mojom::LocalFrameHost::NavigateToNavigationApiKey";
        case messages::LocalFrameHost::kNavigateEventHandlerPresenceChanged:
            return "Receive reply blink::mojom::LocalFrameHost::NavigateEventHandlerPresenceChanged";
        case messages::LocalFrameHost::kUpdateTitle:
            return "Receive reply blink::mojom::LocalFrameHost::UpdateTitle";
        case messages::LocalFrameHost::kUpdateAppTitle:
            return "Receive reply blink::mojom::LocalFrameHost::UpdateAppTitle";
        case messages::LocalFrameHost::kUpdateUserActivationState:
            return "Receive reply blink::mojom::LocalFrameHost::UpdateUserActivationState";
        case messages::LocalFrameHost::kDidConsumeHistoryUserActivation:
            return "Receive reply blink::mojom::LocalFrameHost::DidConsumeHistoryUserActivation";
        case messages::LocalFrameHost::kHandleAccessibilityFindInPageResult:
            return "Receive reply blink::mojom::LocalFrameHost::HandleAccessibilityFindInPageResult";
        case messages::LocalFrameHost::kHandleAccessibilityFindInPageTermination:
            return "Receive reply blink::mojom::LocalFrameHost::HandleAccessibilityFindInPageTermination";
        case messages::LocalFrameHost::kDocumentOnLoadCompleted:
            return "Receive reply blink::mojom::LocalFrameHost::DocumentOnLoadCompleted";
        case messages::LocalFrameHost::kForwardResourceTimingToParent:
            return "Receive reply blink::mojom::LocalFrameHost::ForwardResourceTimingToParent";
        case messages::LocalFrameHost::kDidDispatchDOMContentLoadedEvent:
            return "Receive reply blink::mojom::LocalFrameHost::DidDispatchDOMContentLoadedEvent";
        case messages::LocalFrameHost::kRunModalAlertDialog:
            return "Receive reply blink::mojom::LocalFrameHost::RunModalAlertDialog";
        case messages::LocalFrameHost::kRunModalConfirmDialog:
            return "Receive reply blink::mojom::LocalFrameHost::RunModalConfirmDialog";
        case messages::LocalFrameHost::kRunModalPromptDialog:
            return "Receive reply blink::mojom::LocalFrameHost::RunModalPromptDialog";
        case messages::LocalFrameHost::kRunBeforeUnloadConfirm:
            return "Receive reply blink::mojom::LocalFrameHost::RunBeforeUnloadConfirm";
        case messages::LocalFrameHost::kUpdateFaviconURL:
            return "Receive reply blink::mojom::LocalFrameHost::UpdateFaviconURL";
        case messages::LocalFrameHost::kDownloadURL:
            return "Receive reply blink::mojom::LocalFrameHost::DownloadURL";
        case messages::LocalFrameHost::kFocusedElementChanged:
            return "Receive reply blink::mojom::LocalFrameHost::FocusedElementChanged";
        case messages::LocalFrameHost::kTextSelectionChanged:
            return "Receive reply blink::mojom::LocalFrameHost::TextSelectionChanged";
        case messages::LocalFrameHost::kShowPopupMenu:
            return "Receive reply blink::mojom::LocalFrameHost::ShowPopupMenu";
        case messages::LocalFrameHost::kCreateNewPopupWidget:
            return "Receive reply blink::mojom::LocalFrameHost::CreateNewPopupWidget";
        case messages::LocalFrameHost::kShowContextMenu:
            return "Receive reply blink::mojom::LocalFrameHost::ShowContextMenu";
        case messages::LocalFrameHost::kDidLoadResourceFromMemoryCache:
            return "Receive reply blink::mojom::LocalFrameHost::DidLoadResourceFromMemoryCache";
        case messages::LocalFrameHost::kDidChangeFrameOwnerProperties:
            return "Receive reply blink::mojom::LocalFrameHost::DidChangeFrameOwnerProperties";
        case messages::LocalFrameHost::kDidChangeOpener:
            return "Receive reply blink::mojom::LocalFrameHost::DidChangeOpener";
        case messages::LocalFrameHost::kDidChangeFramePolicy:
            return "Receive reply blink::mojom::LocalFrameHost::DidChangeFramePolicy";
        case messages::LocalFrameHost::kDidChangeIframeAttributes:
            return "Receive reply blink::mojom::LocalFrameHost::DidChangeIframeAttributes";
        case messages::LocalFrameHost::kCapturePaintPreviewOfSubframe:
            return "Receive reply blink::mojom::LocalFrameHost::CapturePaintPreviewOfSubframe";
        case messages::LocalFrameHost::kSetCloseListener:
            return "Receive reply blink::mojom::LocalFrameHost::SetCloseListener";
        case messages::LocalFrameHost::kDetach:
            return "Receive reply blink::mojom::LocalFrameHost::Detach";
        case messages::LocalFrameHost::kGetKeepAliveHandleFactory:
            return "Receive reply blink::mojom::LocalFrameHost::GetKeepAliveHandleFactory";
        case messages::LocalFrameHost::kDidAddMessageToConsole:
            return "Receive reply blink::mojom::LocalFrameHost::DidAddMessageToConsole";
        case messages::LocalFrameHost::kFrameSizeChanged:
            return "Receive reply blink::mojom::LocalFrameHost::FrameSizeChanged";
        case messages::LocalFrameHost::kDidInferColorScheme:
            return "Receive reply blink::mojom::LocalFrameHost::DidInferColorScheme";
        case messages::LocalFrameHost::kDidChangeSrcDoc:
            return "Receive reply blink::mojom::LocalFrameHost::DidChangeSrcDoc";
        case messages::LocalFrameHost::kReceivedDelegatedCapability:
            return "Receive reply blink::mojom::LocalFrameHost::ReceivedDelegatedCapability";
        case messages::LocalFrameHost::kSendFencedFrameReportingBeacon:
            return "Receive reply blink::mojom::LocalFrameHost::SendFencedFrameReportingBeacon";
        case messages::LocalFrameHost::kSendFencedFrameReportingBeaconToCustomURL:
            return "Receive reply blink::mojom::LocalFrameHost::SendFencedFrameReportingBeaconToCustomURL";
        case messages::LocalFrameHost::kDisableUntrustedNetworkInFencedFrame:
            return "Receive reply blink::mojom::LocalFrameHost::DisableUntrustedNetworkInFencedFrame";
        case messages::LocalFrameHost::kExemptUrlFromNetworkRevocationForTesting:
            return "Receive reply blink::mojom::LocalFrameHost::ExemptUrlFromNetworkRevocationForTesting";
        case messages::LocalFrameHost::kSendLegacyTechEvent:
            return "Receive reply blink::mojom::LocalFrameHost::SendLegacyTechEvent";
        case messages::LocalFrameHost::kSetFencedFrameAutomaticBeaconReportEventData:
            return "Receive reply blink::mojom::LocalFrameHost::SetFencedFrameAutomaticBeaconReportEventData";
        case messages::LocalFrameHost::kSendPrivateAggregationRequestsForFencedFrameEvent:
            return "Receive reply blink::mojom::LocalFrameHost::SendPrivateAggregationRequestsForFencedFrameEvent";
        case messages::LocalFrameHost::kCreateFencedFrame:
            return "Receive reply blink::mojom::LocalFrameHost::CreateFencedFrame";
        case messages::LocalFrameHost::kForwardFencedFrameEventAndUserActivationToEmbedder:
            return "Receive reply blink::mojom::LocalFrameHost::ForwardFencedFrameEventAndUserActivationToEmbedder";
        case messages::LocalFrameHost::kOnViewTransitionOptInChanged:
            return "Receive reply blink::mojom::LocalFrameHost::OnViewTransitionOptInChanged";
        case messages::LocalFrameHost::kStartDragging:
            return "Receive reply blink::mojom::LocalFrameHost::StartDragging";
        case messages::LocalFrameHost::kIssueKeepAliveHandle:
            return "Receive reply blink::mojom::LocalFrameHost::IssueKeepAliveHandle";
        case messages::LocalFrameHost::kNotifyStorageAccessed:
            return "Receive reply blink::mojom::LocalFrameHost::NotifyStorageAccessed";
        case messages::LocalFrameHost::kRecordWindowProxyUsageMetrics:
            return "Receive reply blink::mojom::LocalFrameHost::RecordWindowProxyUsageMetrics";
        case messages::LocalFrameHost::kNotifyDocumentInteractive:
            return "Receive reply blink::mojom::LocalFrameHost::NotifyDocumentInteractive";
        }
    }
    return "Receive unknown mojo message";
#else
    bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
    if (is_response) {
        return "Receive mojo reply";
    } else {
        return "Receive mojo message";
    }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t LocalFrameHost::EnterFullscreen_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::EnterFullscreen");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::ExitFullscreen_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::ExitFullscreen");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::FullscreenStateChanged_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::FullscreenStateChanged");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::RegisterProtocolHandler_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::RegisterProtocolHandler");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::UnregisterProtocolHandler_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::UnregisterProtocolHandler");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::DidDisplayInsecureContent_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::DidDisplayInsecureContent");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::DidContainInsecureFormAction_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::DidContainInsecureFormAction");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::MainDocumentElementAvailable_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::MainDocumentElementAvailable");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::SetNeedsOcclusionTracking_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::SetNeedsOcclusionTracking");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::SetVirtualKeyboardMode_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::SetVirtualKeyboardMode");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::VisibilityChanged_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::VisibilityChanged");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::DidChangeThemeColor_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::DidChangeThemeColor");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::DidChangeBackgroundColor_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::DidChangeBackgroundColor");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::DidFailLoadWithError_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::DidFailLoadWithError");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::DidFocusFrame_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::DidFocusFrame");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::DidCallFocus_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::DidCallFocus");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::EnforceInsecureRequestPolicy_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::EnforceInsecureRequestPolicy");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::EnforceInsecureNavigationsSet_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::EnforceInsecureNavigationsSet");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::SuddenTerminationDisablerChanged_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::SuddenTerminationDisablerChanged");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::HadStickyUserActivationBeforeNavigationChanged_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::HadStickyUserActivationBeforeNavigationChanged");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::ScrollRectToVisibleInParentFrame_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::ScrollRectToVisibleInParentFrame");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::BubbleLogicalScrollInParentFrame_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::BubbleLogicalScrollInParentFrame");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::StartLoadingForAsyncNavigationApiCommit_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::StartLoadingForAsyncNavigationApiCommit");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::DidBlockNavigation_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::DidBlockNavigation");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::DidChangeLoadProgress_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::DidChangeLoadProgress");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::DidFinishLoad_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::DidFinishLoad");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::DispatchLoad_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::DispatchLoad");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::GoToEntryAtOffset_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::GoToEntryAtOffset");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::NavigateToNavigationApiKey_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::NavigateToNavigationApiKey");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::NavigateEventHandlerPresenceChanged_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::NavigateEventHandlerPresenceChanged");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::UpdateTitle_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::UpdateTitle");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::UpdateAppTitle_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::UpdateAppTitle");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::UpdateUserActivationState_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::UpdateUserActivationState");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::DidConsumeHistoryUserActivation_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::DidConsumeHistoryUserActivation");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::HandleAccessibilityFindInPageResult_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::HandleAccessibilityFindInPageResult");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::HandleAccessibilityFindInPageTermination_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::HandleAccessibilityFindInPageTermination");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::DocumentOnLoadCompleted_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::DocumentOnLoadCompleted");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::ForwardResourceTimingToParent_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::ForwardResourceTimingToParent");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::DidDispatchDOMContentLoadedEvent_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::DidDispatchDOMContentLoadedEvent");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::RunModalAlertDialog_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::RunModalAlertDialog");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::RunModalConfirmDialog_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::RunModalConfirmDialog");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::RunModalPromptDialog_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::RunModalPromptDialog");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::RunBeforeUnloadConfirm_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::RunBeforeUnloadConfirm");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::UpdateFaviconURL_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::UpdateFaviconURL");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::DownloadURL_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::DownloadURL");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::FocusedElementChanged_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::FocusedElementChanged");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::TextSelectionChanged_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::TextSelectionChanged");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::ShowPopupMenu_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::ShowPopupMenu");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::CreateNewPopupWidget_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::CreateNewPopupWidget");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::ShowContextMenu_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::ShowContextMenu");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::DidLoadResourceFromMemoryCache_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::DidLoadResourceFromMemoryCache");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::DidChangeFrameOwnerProperties_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::DidChangeFrameOwnerProperties");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::DidChangeOpener_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::DidChangeOpener");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::DidChangeFramePolicy_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::DidChangeFramePolicy");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::DidChangeIframeAttributes_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::DidChangeIframeAttributes");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::CapturePaintPreviewOfSubframe_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::CapturePaintPreviewOfSubframe");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::SetCloseListener_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::SetCloseListener");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::Detach_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::Detach");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::GetKeepAliveHandleFactory_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::GetKeepAliveHandleFactory");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::DidAddMessageToConsole_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::DidAddMessageToConsole");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::FrameSizeChanged_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::FrameSizeChanged");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::DidInferColorScheme_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::DidInferColorScheme");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::DidChangeSrcDoc_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::DidChangeSrcDoc");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::ReceivedDelegatedCapability_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::ReceivedDelegatedCapability");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::SendFencedFrameReportingBeacon_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::SendFencedFrameReportingBeacon");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::SendFencedFrameReportingBeaconToCustomURL_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::SendFencedFrameReportingBeaconToCustomURL");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::DisableUntrustedNetworkInFencedFrame_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::DisableUntrustedNetworkInFencedFrame");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::ExemptUrlFromNetworkRevocationForTesting_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::ExemptUrlFromNetworkRevocationForTesting");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::SendLegacyTechEvent_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::SendLegacyTechEvent");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::SetFencedFrameAutomaticBeaconReportEventData_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::SetFencedFrameAutomaticBeaconReportEventData");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::SendPrivateAggregationRequestsForFencedFrameEvent_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::SendPrivateAggregationRequestsForFencedFrameEvent");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::CreateFencedFrame_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::CreateFencedFrame");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::ForwardFencedFrameEventAndUserActivationToEmbedder_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::ForwardFencedFrameEventAndUserActivationToEmbedder");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::OnViewTransitionOptInChanged_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::OnViewTransitionOptInChanged");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::StartDragging_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::StartDragging");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::IssueKeepAliveHandle_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::IssueKeepAliveHandle");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::NotifyStorageAccessed_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::NotifyStorageAccessed");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::RecordWindowProxyUsageMetrics_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::RecordWindowProxyUsageMetrics");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrameHost::NotifyDocumentInteractive_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrameHost::NotifyDocumentInteractive");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
#endif // !BUILDFLAG(IS_FUCHSIA)
bool LocalFrameHost::RunModalAlertDialog(const ::WTF::String& alert_message, bool disable_third_party_subframe_suppresion)
{
    NOTREACHED();
}
bool LocalFrameHost::RunModalConfirmDialog(const ::WTF::String& alert_message, bool disable_third_party_subframe_suppresion, bool* out_success)
{
    NOTREACHED();
}
bool LocalFrameHost::RunModalPromptDialog(const ::WTF::String& alert_message, const ::WTF::String& default_value, bool disable_third_party_subframe_suppresion,
    bool* out_success, ::WTF::String* out_result)
{
    NOTREACHED();
}
bool LocalFrameHost::RunBeforeUnloadConfirm(bool is_reload, bool* out_success)
{
    NOTREACHED();
}

class LocalFrameHost_EnterFullscreen_ForwardToCallback : public mojo::MessageReceiver {
public:
    LocalFrameHost_EnterFullscreen_ForwardToCallback(LocalFrameHost::EnterFullscreenCallback callback)
        : callback_(std::move(callback))
    {
    }

    LocalFrameHost_EnterFullscreen_ForwardToCallback(const LocalFrameHost_EnterFullscreen_ForwardToCallback&) = delete;
    LocalFrameHost_EnterFullscreen_ForwardToCallback& operator=(const LocalFrameHost_EnterFullscreen_ForwardToCallback&) = delete;

    bool Accept(mojo::Message* message) override;

private:
    LocalFrameHost::EnterFullscreenCallback callback_;
};
class LocalFrameHost_RunModalAlertDialog_HandleSyncResponse : public mojo::MessageReceiver {
public:
    LocalFrameHost_RunModalAlertDialog_HandleSyncResponse(bool* result)
        : result_(result)
    {
        DCHECK(!*result_);
    }

    LocalFrameHost_RunModalAlertDialog_HandleSyncResponse(const LocalFrameHost_RunModalAlertDialog_HandleSyncResponse&) = delete;
    LocalFrameHost_RunModalAlertDialog_HandleSyncResponse& operator=(const LocalFrameHost_RunModalAlertDialog_HandleSyncResponse&) = delete;

    bool Accept(mojo::Message* message) override;

private:
    bool* result_;
};

class LocalFrameHost_RunModalAlertDialog_ForwardToCallback : public mojo::MessageReceiver {
public:
    LocalFrameHost_RunModalAlertDialog_ForwardToCallback(LocalFrameHost::RunModalAlertDialogCallback callback)
        : callback_(std::move(callback))
    {
    }

    LocalFrameHost_RunModalAlertDialog_ForwardToCallback(const LocalFrameHost_RunModalAlertDialog_ForwardToCallback&) = delete;
    LocalFrameHost_RunModalAlertDialog_ForwardToCallback& operator=(const LocalFrameHost_RunModalAlertDialog_ForwardToCallback&) = delete;

    bool Accept(mojo::Message* message) override;

private:
    LocalFrameHost::RunModalAlertDialogCallback callback_;
};
class LocalFrameHost_RunModalConfirmDialog_HandleSyncResponse : public mojo::MessageReceiver {
public:
    LocalFrameHost_RunModalConfirmDialog_HandleSyncResponse(bool* result, bool* out_success)
        : result_(result)
        , out_success_(out_success)
    {
        DCHECK(!*result_);
    }

    LocalFrameHost_RunModalConfirmDialog_HandleSyncResponse(const LocalFrameHost_RunModalConfirmDialog_HandleSyncResponse&) = delete;
    LocalFrameHost_RunModalConfirmDialog_HandleSyncResponse& operator=(const LocalFrameHost_RunModalConfirmDialog_HandleSyncResponse&) = delete;

    bool Accept(mojo::Message* message) override;

private:
    bool* result_;
    bool* out_success_;
};

class LocalFrameHost_RunModalConfirmDialog_ForwardToCallback : public mojo::MessageReceiver {
public:
    LocalFrameHost_RunModalConfirmDialog_ForwardToCallback(LocalFrameHost::RunModalConfirmDialogCallback callback)
        : callback_(std::move(callback))
    {
    }

    LocalFrameHost_RunModalConfirmDialog_ForwardToCallback(const LocalFrameHost_RunModalConfirmDialog_ForwardToCallback&) = delete;
    LocalFrameHost_RunModalConfirmDialog_ForwardToCallback& operator=(const LocalFrameHost_RunModalConfirmDialog_ForwardToCallback&) = delete;

    bool Accept(mojo::Message* message) override;

private:
    LocalFrameHost::RunModalConfirmDialogCallback callback_;
};
class LocalFrameHost_RunModalPromptDialog_HandleSyncResponse : public mojo::MessageReceiver {
public:
    LocalFrameHost_RunModalPromptDialog_HandleSyncResponse(bool* result, bool* out_success, ::WTF::String* out_result)
        : result_(result)
        , out_success_(out_success)
        , out_result_(out_result)
    {
        DCHECK(!*result_);
    }

    LocalFrameHost_RunModalPromptDialog_HandleSyncResponse(const LocalFrameHost_RunModalPromptDialog_HandleSyncResponse&) = delete;
    LocalFrameHost_RunModalPromptDialog_HandleSyncResponse& operator=(const LocalFrameHost_RunModalPromptDialog_HandleSyncResponse&) = delete;

    bool Accept(mojo::Message* message) override;

private:
    bool* result_;
    bool* out_success_;
    ::WTF::String* out_result_;
};

class LocalFrameHost_RunModalPromptDialog_ForwardToCallback : public mojo::MessageReceiver {
public:
    LocalFrameHost_RunModalPromptDialog_ForwardToCallback(LocalFrameHost::RunModalPromptDialogCallback callback)
        : callback_(std::move(callback))
    {
    }

    LocalFrameHost_RunModalPromptDialog_ForwardToCallback(const LocalFrameHost_RunModalPromptDialog_ForwardToCallback&) = delete;
    LocalFrameHost_RunModalPromptDialog_ForwardToCallback& operator=(const LocalFrameHost_RunModalPromptDialog_ForwardToCallback&) = delete;

    bool Accept(mojo::Message* message) override;

private:
    LocalFrameHost::RunModalPromptDialogCallback callback_;
};
class LocalFrameHost_RunBeforeUnloadConfirm_HandleSyncResponse : public mojo::MessageReceiver {
public:
    LocalFrameHost_RunBeforeUnloadConfirm_HandleSyncResponse(bool* result, bool* out_success)
        : result_(result)
        , out_success_(out_success)
    {
        DCHECK(!*result_);
    }

    LocalFrameHost_RunBeforeUnloadConfirm_HandleSyncResponse(const LocalFrameHost_RunBeforeUnloadConfirm_HandleSyncResponse&) = delete;
    LocalFrameHost_RunBeforeUnloadConfirm_HandleSyncResponse& operator=(const LocalFrameHost_RunBeforeUnloadConfirm_HandleSyncResponse&) = delete;

    bool Accept(mojo::Message* message) override;

private:
    bool* result_;
    bool* out_success_;
};

class LocalFrameHost_RunBeforeUnloadConfirm_ForwardToCallback : public mojo::MessageReceiver {
public:
    LocalFrameHost_RunBeforeUnloadConfirm_ForwardToCallback(LocalFrameHost::RunBeforeUnloadConfirmCallback callback)
        : callback_(std::move(callback))
    {
    }

    LocalFrameHost_RunBeforeUnloadConfirm_ForwardToCallback(const LocalFrameHost_RunBeforeUnloadConfirm_ForwardToCallback&) = delete;
    LocalFrameHost_RunBeforeUnloadConfirm_ForwardToCallback& operator=(const LocalFrameHost_RunBeforeUnloadConfirm_ForwardToCallback&) = delete;

    bool Accept(mojo::Message* message) override;

private:
    LocalFrameHost::RunBeforeUnloadConfirmCallback callback_;
};

class LocalFrameHost_DisableUntrustedNetworkInFencedFrame_ForwardToCallback : public mojo::MessageReceiver {
public:
    LocalFrameHost_DisableUntrustedNetworkInFencedFrame_ForwardToCallback(LocalFrameHost::DisableUntrustedNetworkInFencedFrameCallback callback)
        : callback_(std::move(callback))
    {
    }

    LocalFrameHost_DisableUntrustedNetworkInFencedFrame_ForwardToCallback(const LocalFrameHost_DisableUntrustedNetworkInFencedFrame_ForwardToCallback&)
        = delete;
    LocalFrameHost_DisableUntrustedNetworkInFencedFrame_ForwardToCallback& operator=(
        const LocalFrameHost_DisableUntrustedNetworkInFencedFrame_ForwardToCallback&)
        = delete;

    bool Accept(mojo::Message* message) override;

private:
    LocalFrameHost::DisableUntrustedNetworkInFencedFrameCallback callback_;
};

class LocalFrameHost_ExemptUrlFromNetworkRevocationForTesting_ForwardToCallback : public mojo::MessageReceiver {
public:
    LocalFrameHost_ExemptUrlFromNetworkRevocationForTesting_ForwardToCallback(LocalFrameHost::ExemptUrlFromNetworkRevocationForTestingCallback callback)
        : callback_(std::move(callback))
    {
    }

    LocalFrameHost_ExemptUrlFromNetworkRevocationForTesting_ForwardToCallback(const LocalFrameHost_ExemptUrlFromNetworkRevocationForTesting_ForwardToCallback&)
        = delete;
    LocalFrameHost_ExemptUrlFromNetworkRevocationForTesting_ForwardToCallback& operator=(
        const LocalFrameHost_ExemptUrlFromNetworkRevocationForTesting_ForwardToCallback&)
        = delete;

    bool Accept(mojo::Message* message) override;

private:
    LocalFrameHost::ExemptUrlFromNetworkRevocationForTestingCallback callback_;
};

LocalFrameHostProxy::LocalFrameHostProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver)
{
}

void LocalFrameHostProxy::EnterFullscreen(::blink::mojom::blink::FullscreenOptionsPtr in_options, EnterFullscreenCallback callback)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrameHost::EnterFullscreen", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("options"), in_options, "<value of type ::blink::mojom::blink::FullscreenOptionsPtr>");
    });
#endif

    const bool kExpectsResponse = true;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kEnterFullscreen), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_EnterFullscreen_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->options)::BaseType> options_fragment(params.message());
    mojo::internal::Serialize<::blink::mojom::FullscreenOptionsDataView>(in_options, options_fragment);
    params->options.Set(options_fragment.is_null() ? nullptr : options_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->options.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null options in LocalFrameHost.EnterFullscreen request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("EnterFullscreen");
#endif
    std::unique_ptr<mojo::MessageReceiver> responder(new LocalFrameHost_EnterFullscreen_ForwardToCallback(std::move(callback)));
    ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void LocalFrameHostProxy::ExitFullscreen()
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT0("mojom", "Send blink::mojom::LocalFrameHost::ExitFullscreen");
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kExitFullscreen), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_ExitFullscreen_Params_Data> params(message);
    params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("ExitFullscreen");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::FullscreenStateChanged(bool in_is_fullscreen, ::blink::mojom::blink::FullscreenOptionsPtr in_options)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrameHost::FullscreenStateChanged", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("is_fullscreen"), in_is_fullscreen, "<value of type bool>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("options"), in_options, "<value of type ::blink::mojom::blink::FullscreenOptionsPtr>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kFullscreenStateChanged), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_FullscreenStateChanged_Params_Data> params(message);
    params.Allocate();
    params->is_fullscreen = in_is_fullscreen;
    mojo::internal::MessageFragment<typename decltype(params->options)::BaseType> options_fragment(params.message());
    mojo::internal::Serialize<::blink::mojom::FullscreenOptionsDataView>(in_options, options_fragment);
    params->options.Set(options_fragment.is_null() ? nullptr : options_fragment.data());

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("FullscreenStateChanged");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::RegisterProtocolHandler(const WTF::String& in_scheme, const ::blink::KURL& in_url, bool in_user_gesture)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrameHost::RegisterProtocolHandler", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("scheme"), in_scheme, "<value of type const WTF::String&>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("url"), in_url, "<value of type const ::blink::KURL&>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("user_gesture"), in_user_gesture, "<value of type bool>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kRegisterProtocolHandler), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_RegisterProtocolHandler_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->scheme)::BaseType> scheme_fragment(params.message());
    mojo::internal::Serialize<mojo::StringDataView>(in_scheme, scheme_fragment);
    params->scheme.Set(scheme_fragment.is_null() ? nullptr : scheme_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->scheme.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null scheme in LocalFrameHost.RegisterProtocolHandler request");
    mojo::internal::MessageFragment<typename decltype(params->url)::BaseType> url_fragment(params.message());
    mojo::internal::Serialize<::url::mojom::UrlDataView>(in_url, url_fragment);
    params->url.Set(url_fragment.is_null() ? nullptr : url_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->url.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null url in LocalFrameHost.RegisterProtocolHandler request");
    params->user_gesture = in_user_gesture;

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("RegisterProtocolHandler");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::UnregisterProtocolHandler(const WTF::String& in_scheme, const ::blink::KURL& in_url, bool in_user_gesture)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrameHost::UnregisterProtocolHandler", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("scheme"), in_scheme, "<value of type const WTF::String&>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("url"), in_url, "<value of type const ::blink::KURL&>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("user_gesture"), in_user_gesture, "<value of type bool>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kUnregisterProtocolHandler), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_UnregisterProtocolHandler_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->scheme)::BaseType> scheme_fragment(params.message());
    mojo::internal::Serialize<mojo::StringDataView>(in_scheme, scheme_fragment);
    params->scheme.Set(scheme_fragment.is_null() ? nullptr : scheme_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->scheme.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null scheme in LocalFrameHost.UnregisterProtocolHandler request");
    mojo::internal::MessageFragment<typename decltype(params->url)::BaseType> url_fragment(params.message());
    mojo::internal::Serialize<::url::mojom::UrlDataView>(in_url, url_fragment);
    params->url.Set(url_fragment.is_null() ? nullptr : url_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->url.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null url in LocalFrameHost.UnregisterProtocolHandler request");
    params->user_gesture = in_user_gesture;

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("UnregisterProtocolHandler");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::DidDisplayInsecureContent()
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT0("mojom", "Send blink::mojom::LocalFrameHost::DidDisplayInsecureContent");
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kDidDisplayInsecureContent), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_DidDisplayInsecureContent_Params_Data> params(message);
    params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("DidDisplayInsecureContent");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::DidContainInsecureFormAction()
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT0("mojom", "Send blink::mojom::LocalFrameHost::DidContainInsecureFormAction");
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kDidContainInsecureFormAction), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_DidContainInsecureFormAction_Params_Data> params(message);
    params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("DidContainInsecureFormAction");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::MainDocumentElementAvailable(bool in_uses_temporary_zoom_level)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrameHost::MainDocumentElementAvailable", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("uses_temporary_zoom_level"), in_uses_temporary_zoom_level, "<value of type bool>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kMainDocumentElementAvailable), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_MainDocumentElementAvailable_Params_Data> params(message);
    params.Allocate();
    params->uses_temporary_zoom_level = in_uses_temporary_zoom_level;

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("MainDocumentElementAvailable");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::SetNeedsOcclusionTracking(bool in_needs_tracking)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrameHost::SetNeedsOcclusionTracking", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("needs_tracking"), in_needs_tracking, "<value of type bool>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kSetNeedsOcclusionTracking), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_SetNeedsOcclusionTracking_Params_Data> params(message);
    params.Allocate();
    params->needs_tracking = in_needs_tracking;

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("SetNeedsOcclusionTracking");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::SetVirtualKeyboardMode(::ui::mojom::blink::VirtualKeyboardMode in_type)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrameHost::SetVirtualKeyboardMode", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("type"), in_type, "<value of type ::ui::mojom::blink::VirtualKeyboardMode>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kSetVirtualKeyboardMode), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_SetVirtualKeyboardMode_Params_Data> params(message);
    params.Allocate();
    mojo::internal::Serialize<::ui::mojom::VirtualKeyboardMode>(in_type, &params->type);

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("SetVirtualKeyboardMode");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::VisibilityChanged(::blink::mojom::blink::FrameVisibility in_visibility)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrameHost::VisibilityChanged", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("visibility"), in_visibility, "<value of type ::blink::mojom::blink::FrameVisibility>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kVisibilityChanged), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_VisibilityChanged_Params_Data> params(message);
    params.Allocate();
    mojo::internal::Serialize<::blink::mojom::FrameVisibility>(in_visibility, &params->visibility);

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("VisibilityChanged");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::DidChangeThemeColor(std::optional<::SkColor> in_theme_color)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrameHost::DidChangeThemeColor", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("theme_color"), in_theme_color, "<value of type std::optional<::SkColor>>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kDidChangeThemeColor), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_DidChangeThemeColor_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->theme_color)::BaseType> theme_color_fragment(params.message());
    mojo::internal::Serialize<::skia::mojom::SkColorDataView>(in_theme_color, theme_color_fragment);
    params->theme_color.Set(theme_color_fragment.is_null() ? nullptr : theme_color_fragment.data());

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("DidChangeThemeColor");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::DidChangeBackgroundColor(const ::SkColor4f& in_background_color, bool in_color_adjust)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrameHost::DidChangeBackgroundColor", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("background_color"), in_background_color, "<value of type const ::SkColor4f&>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("color_adjust"), in_color_adjust, "<value of type bool>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kDidChangeBackgroundColor), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_DidChangeBackgroundColor_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->background_color)::BaseType> background_color_fragment(params.message());
    mojo::internal::Serialize<::skia::mojom::SkColor4fDataView>(in_background_color, background_color_fragment);
    params->background_color.Set(background_color_fragment.is_null() ? nullptr : background_color_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->background_color.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null background_color in LocalFrameHost.DidChangeBackgroundColor request");
    params->color_adjust = in_color_adjust;

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("DidChangeBackgroundColor");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::DidFailLoadWithError(const ::blink::KURL& in_url, int32_t in_error_code)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrameHost::DidFailLoadWithError", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("url"), in_url, "<value of type const ::blink::KURL&>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("error_code"), in_error_code, "<value of type int32_t>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kDidFailLoadWithError), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_DidFailLoadWithError_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->url)::BaseType> url_fragment(params.message());
    mojo::internal::Serialize<::url::mojom::UrlDataView>(in_url, url_fragment);
    params->url.Set(url_fragment.is_null() ? nullptr : url_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->url.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null url in LocalFrameHost.DidFailLoadWithError request");
    params->error_code = in_error_code;

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("DidFailLoadWithError");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::DidFocusFrame()
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT0("mojom", "Send blink::mojom::LocalFrameHost::DidFocusFrame");
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kDidFocusFrame), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_DidFocusFrame_Params_Data> params(message);
    params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("DidFocusFrame");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::DidCallFocus()
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT0("mojom", "Send blink::mojom::LocalFrameHost::DidCallFocus");
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kDidCallFocus), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_DidCallFocus_Params_Data> params(message);
    params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("DidCallFocus");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::EnforceInsecureRequestPolicy(::blink::mojom::blink::InsecureRequestPolicy in_policy_bitmap)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrameHost::EnforceInsecureRequestPolicy", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(
            dict.AddItem("policy_bitmap"), in_policy_bitmap, "<value of type ::blink::mojom::blink::InsecureRequestPolicy>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kEnforceInsecureRequestPolicy), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_EnforceInsecureRequestPolicy_Params_Data> params(message);
    params.Allocate();
    mojo::internal::Serialize<::blink::mojom::InsecureRequestPolicy>(in_policy_bitmap, &params->policy_bitmap);

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("EnforceInsecureRequestPolicy");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::EnforceInsecureNavigationsSet(const WTF::Vector<uint32_t>& in_set)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrameHost::EnforceInsecureNavigationsSet", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("set"), in_set, "<value of type const WTF::Vector<uint32_t>&>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kEnforceInsecureNavigationsSet), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_EnforceInsecureNavigationsSet_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->set)::BaseType> set_fragment(params.message());
    constexpr const mojo::internal::ContainerValidateParams& set_validate_params = mojo::internal::GetArrayValidator<0, false, nullptr>();
    mojo::internal::Serialize<mojo::ArrayDataView<uint32_t>>(in_set, set_fragment, &set_validate_params);
    params->set.Set(set_fragment.is_null() ? nullptr : set_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->set.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null set in LocalFrameHost.EnforceInsecureNavigationsSet request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("EnforceInsecureNavigationsSet");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::SuddenTerminationDisablerChanged(bool in_present, ::blink::mojom::blink::SuddenTerminationDisablerType in_disabler_type)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrameHost::SuddenTerminationDisablerChanged", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("present"), in_present, "<value of type bool>");
        perfetto::WriteIntoTracedValueWithFallback(
            dict.AddItem("disabler_type"), in_disabler_type, "<value of type ::blink::mojom::blink::SuddenTerminationDisablerType>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kSuddenTerminationDisablerChanged), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_SuddenTerminationDisablerChanged_Params_Data> params(message);
    params.Allocate();
    params->present = in_present;
    mojo::internal::Serialize<::blink::mojom::SuddenTerminationDisablerType>(in_disabler_type, &params->disabler_type);

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("SuddenTerminationDisablerChanged");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::HadStickyUserActivationBeforeNavigationChanged(bool in_has_gesture)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1(
        "mojom", "Send blink::mojom::LocalFrameHost::HadStickyUserActivationBeforeNavigationChanged", "input_parameters", [&](perfetto::TracedValue context) {
            auto dict = std::move(context).WriteDictionary();
            perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("has_gesture"), in_has_gesture, "<value of type bool>");
        });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kHadStickyUserActivationBeforeNavigationChanged), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_HadStickyUserActivationBeforeNavigationChanged_Params_Data> params(message);
    params.Allocate();
    params->has_gesture = in_has_gesture;

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("HadStickyUserActivationBeforeNavigationChanged");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::ScrollRectToVisibleInParentFrame(const ::gfx::RectF& in_rect_to_scroll, ::blink::mojom::blink::ScrollIntoViewParamsPtr in_params)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrameHost::ScrollRectToVisibleInParentFrame", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("rect_to_scroll"), in_rect_to_scroll, "<value of type const ::gfx::RectF&>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("params"), in_params, "<value of type ::blink::mojom::blink::ScrollIntoViewParamsPtr>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kScrollRectToVisibleInParentFrame), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_ScrollRectToVisibleInParentFrame_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->rect_to_scroll)::BaseType> rect_to_scroll_fragment(params.message());
    mojo::internal::Serialize<::gfx::mojom::RectFDataView>(in_rect_to_scroll, rect_to_scroll_fragment);
    params->rect_to_scroll.Set(rect_to_scroll_fragment.is_null() ? nullptr : rect_to_scroll_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->rect_to_scroll.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null rect_to_scroll in LocalFrameHost.ScrollRectToVisibleInParentFrame request");
    mojo::internal::MessageFragment<typename decltype(params->params)::BaseType> params_fragment(params.message());
    mojo::internal::Serialize<::blink::mojom::ScrollIntoViewParamsDataView>(in_params, params_fragment);
    params->params.Set(params_fragment.is_null() ? nullptr : params_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->params.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null params in LocalFrameHost.ScrollRectToVisibleInParentFrame request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("ScrollRectToVisibleInParentFrame");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::BubbleLogicalScrollInParentFrame(::blink::mojom::blink::ScrollDirection in_direction, ::ui::ScrollGranularity in_granularity)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrameHost::BubbleLogicalScrollInParentFrame", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("direction"), in_direction, "<value of type ::blink::mojom::blink::ScrollDirection>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("granularity"), in_granularity, "<value of type ::ui::ScrollGranularity>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kBubbleLogicalScrollInParentFrame), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_BubbleLogicalScrollInParentFrame_Params_Data> params(message);
    params.Allocate();
    mojo::internal::Serialize<::blink::mojom::ScrollDirection>(in_direction, &params->direction);
    mojo::internal::Serialize<::ui::mojom::ScrollGranularity>(in_granularity, &params->granularity);

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("BubbleLogicalScrollInParentFrame");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::StartLoadingForAsyncNavigationApiCommit()
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT0("mojom", "Send blink::mojom::LocalFrameHost::StartLoadingForAsyncNavigationApiCommit");
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kStartLoadingForAsyncNavigationApiCommit), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_StartLoadingForAsyncNavigationApiCommit_Params_Data> params(message);
    params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("StartLoadingForAsyncNavigationApiCommit");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::DidBlockNavigation(
    const ::blink::KURL& in_blocked_url, const ::blink::KURL& in_initiator_url, ::blink::mojom::blink::NavigationBlockedReason in_reason)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrameHost::DidBlockNavigation", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("blocked_url"), in_blocked_url, "<value of type const ::blink::KURL&>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("initiator_url"), in_initiator_url, "<value of type const ::blink::KURL&>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("reason"), in_reason, "<value of type ::blink::mojom::blink::NavigationBlockedReason>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kDidBlockNavigation), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_DidBlockNavigation_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->blocked_url)::BaseType> blocked_url_fragment(params.message());
    mojo::internal::Serialize<::url::mojom::UrlDataView>(in_blocked_url, blocked_url_fragment);
    params->blocked_url.Set(blocked_url_fragment.is_null() ? nullptr : blocked_url_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->blocked_url.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null blocked_url in LocalFrameHost.DidBlockNavigation request");
    mojo::internal::MessageFragment<typename decltype(params->initiator_url)::BaseType> initiator_url_fragment(params.message());
    mojo::internal::Serialize<::url::mojom::UrlDataView>(in_initiator_url, initiator_url_fragment);
    params->initiator_url.Set(initiator_url_fragment.is_null() ? nullptr : initiator_url_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->initiator_url.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null initiator_url in LocalFrameHost.DidBlockNavigation request");
    mojo::internal::Serialize<::blink::mojom::NavigationBlockedReason>(in_reason, &params->reason);

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("DidBlockNavigation");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::DidChangeLoadProgress(double in_load_progress)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrameHost::DidChangeLoadProgress", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("load_progress"), in_load_progress, "<value of type double>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kDidChangeLoadProgress), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_DidChangeLoadProgress_Params_Data> params(message);
    params.Allocate();
    params->load_progress = in_load_progress;

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("DidChangeLoadProgress");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::DidFinishLoad(const ::blink::KURL& in_validated_url)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrameHost::DidFinishLoad", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("validated_url"), in_validated_url, "<value of type const ::blink::KURL&>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kDidFinishLoad), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_DidFinishLoad_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->validated_url)::BaseType> validated_url_fragment(params.message());
    mojo::internal::Serialize<::url::mojom::UrlDataView>(in_validated_url, validated_url_fragment);
    params->validated_url.Set(validated_url_fragment.is_null() ? nullptr : validated_url_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->validated_url.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null validated_url in LocalFrameHost.DidFinishLoad request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("DidFinishLoad");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::DispatchLoad()
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT0("mojom", "Send blink::mojom::LocalFrameHost::DispatchLoad");
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kDispatchLoad), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_DispatchLoad_Params_Data> params(message);
    params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("DispatchLoad");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::GoToEntryAtOffset(
    int32_t in_offset, bool in_has_user_gesture, std::optional<::blink::scheduler::TaskAttributionId> in_soft_navigation_heuristics_task_id)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrameHost::GoToEntryAtOffset", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("offset"), in_offset, "<value of type int32_t>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("has_user_gesture"), in_has_user_gesture, "<value of type bool>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("soft_navigation_heuristics_task_id"), in_soft_navigation_heuristics_task_id,
            "<value of type std::optional<::blink::scheduler::TaskAttributionId>>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kGoToEntryAtOffset), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_GoToEntryAtOffset_Params_Data> params(message);
    params.Allocate();
    params->offset = in_offset;
    params->has_user_gesture = in_has_user_gesture;
    mojo::internal::MessageFragment<typename decltype(params->soft_navigation_heuristics_task_id)::BaseType> soft_navigation_heuristics_task_id_fragment(
        params.message());
    mojo::internal::Serialize<::blink::mojom::TaskAttributionIdDataView>(in_soft_navigation_heuristics_task_id, soft_navigation_heuristics_task_id_fragment);
    params->soft_navigation_heuristics_task_id.Set(
        soft_navigation_heuristics_task_id_fragment.is_null() ? nullptr : soft_navigation_heuristics_task_id_fragment.data());

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("GoToEntryAtOffset");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::NavigateToNavigationApiKey(
    const WTF::String& in_key, bool in_has_user_gesture, std::optional<::blink::scheduler::TaskAttributionId> in_soft_navigation_heuristics_task_id)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrameHost::NavigateToNavigationApiKey", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("key"), in_key, "<value of type const WTF::String&>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("has_user_gesture"), in_has_user_gesture, "<value of type bool>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("soft_navigation_heuristics_task_id"), in_soft_navigation_heuristics_task_id,
            "<value of type std::optional<::blink::scheduler::TaskAttributionId>>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kNavigateToNavigationApiKey), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_NavigateToNavigationApiKey_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->key)::BaseType> key_fragment(params.message());
    mojo::internal::Serialize<mojo::StringDataView>(in_key, key_fragment);
    params->key.Set(key_fragment.is_null() ? nullptr : key_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->key.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null key in LocalFrameHost.NavigateToNavigationApiKey request");
    params->has_user_gesture = in_has_user_gesture;
    mojo::internal::MessageFragment<typename decltype(params->soft_navigation_heuristics_task_id)::BaseType> soft_navigation_heuristics_task_id_fragment(
        params.message());
    mojo::internal::Serialize<::blink::mojom::TaskAttributionIdDataView>(in_soft_navigation_heuristics_task_id, soft_navigation_heuristics_task_id_fragment);
    params->soft_navigation_heuristics_task_id.Set(
        soft_navigation_heuristics_task_id_fragment.is_null() ? nullptr : soft_navigation_heuristics_task_id_fragment.data());

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("NavigateToNavigationApiKey");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::NavigateEventHandlerPresenceChanged(bool in_present)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrameHost::NavigateEventHandlerPresenceChanged", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("present"), in_present, "<value of type bool>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kNavigateEventHandlerPresenceChanged), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_NavigateEventHandlerPresenceChanged_Params_Data> params(message);
    params.Allocate();
    params->present = in_present;

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("NavigateEventHandlerPresenceChanged");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::UpdateTitle(const ::WTF::String& in_title, ::base::i18n::TextDirection in_title_direction)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrameHost::UpdateTitle", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("title"), in_title, "<value of type const ::WTF::String&>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("title_direction"), in_title_direction, "<value of type ::base::i18n::TextDirection>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kUpdateTitle), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_UpdateTitle_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->title)::BaseType> title_fragment(params.message());
    mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(in_title, title_fragment);
    params->title.Set(title_fragment.is_null() ? nullptr : title_fragment.data());
    mojo::internal::Serialize<::mojo_base::mojom::TextDirection>(in_title_direction, &params->title_direction);

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("UpdateTitle");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::UpdateAppTitle(const ::WTF::String& in_app_title)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrameHost::UpdateAppTitle", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("app_title"), in_app_title, "<value of type const ::WTF::String&>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kUpdateAppTitle), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_UpdateAppTitle_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->app_title)::BaseType> app_title_fragment(params.message());
    mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(in_app_title, app_title_fragment);
    params->app_title.Set(app_title_fragment.is_null() ? nullptr : app_title_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->app_title.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null app_title in LocalFrameHost.UpdateAppTitle request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("UpdateAppTitle");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::UpdateUserActivationState(
    ::blink::mojom::blink::UserActivationUpdateType in_update_type, ::blink::mojom::blink::UserActivationNotificationType in_notification_type)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrameHost::UpdateUserActivationState", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(
            dict.AddItem("update_type"), in_update_type, "<value of type ::blink::mojom::blink::UserActivationUpdateType>");
        perfetto::WriteIntoTracedValueWithFallback(
            dict.AddItem("notification_type"), in_notification_type, "<value of type ::blink::mojom::blink::UserActivationNotificationType>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kUpdateUserActivationState), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_UpdateUserActivationState_Params_Data> params(message);
    params.Allocate();
    mojo::internal::Serialize<::blink::mojom::UserActivationUpdateType>(in_update_type, &params->update_type);
    mojo::internal::Serialize<::blink::mojom::UserActivationNotificationType>(in_notification_type, &params->notification_type);

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("UpdateUserActivationState");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::DidConsumeHistoryUserActivation()
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT0("mojom", "Send blink::mojom::LocalFrameHost::DidConsumeHistoryUserActivation");
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kDidConsumeHistoryUserActivation), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_DidConsumeHistoryUserActivation_Params_Data> params(message);
    params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("DidConsumeHistoryUserActivation");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::HandleAccessibilityFindInPageResult(FindInPageResultAXParamsPtr in_params)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrameHost::HandleAccessibilityFindInPageResult", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("params"), in_params, "<value of type FindInPageResultAXParamsPtr>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kHandleAccessibilityFindInPageResult), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_HandleAccessibilityFindInPageResult_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->params)::BaseType> params_fragment(params.message());
    mojo::internal::Serialize<::blink::mojom::FindInPageResultAXParamsDataView>(in_params, params_fragment);
    params->params.Set(params_fragment.is_null() ? nullptr : params_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->params.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null params in LocalFrameHost.HandleAccessibilityFindInPageResult request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("HandleAccessibilityFindInPageResult");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::HandleAccessibilityFindInPageTermination()
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT0("mojom", "Send blink::mojom::LocalFrameHost::HandleAccessibilityFindInPageTermination");
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kHandleAccessibilityFindInPageTermination), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_HandleAccessibilityFindInPageTermination_Params_Data> params(message);
    params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("HandleAccessibilityFindInPageTermination");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::DocumentOnLoadCompleted()
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT0("mojom", "Send blink::mojom::LocalFrameHost::DocumentOnLoadCompleted");
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kDocumentOnLoadCompleted), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_DocumentOnLoadCompleted_Params_Data> params(message);
    params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("DocumentOnLoadCompleted");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::ForwardResourceTimingToParent(::blink::mojom::blink::ResourceTimingInfoPtr in_timing)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrameHost::ForwardResourceTimingToParent", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("timing"), in_timing, "<value of type ::blink::mojom::blink::ResourceTimingInfoPtr>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kForwardResourceTimingToParent), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_ForwardResourceTimingToParent_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->timing)::BaseType> timing_fragment(params.message());
    mojo::internal::Serialize<::blink::mojom::ResourceTimingInfoDataView>(in_timing, timing_fragment);
    params->timing.Set(timing_fragment.is_null() ? nullptr : timing_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->timing.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null timing in LocalFrameHost.ForwardResourceTimingToParent request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("ForwardResourceTimingToParent");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::DidDispatchDOMContentLoadedEvent()
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT0("mojom", "Send blink::mojom::LocalFrameHost::DidDispatchDOMContentLoadedEvent");
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kDidDispatchDOMContentLoadedEvent), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_DidDispatchDOMContentLoadedEvent_Params_Data> params(message);
    params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("DidDispatchDOMContentLoadedEvent");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}
bool LocalFrameHostProxy::RunModalAlertDialog(const ::WTF::String& param_alert_message, bool param_disable_third_party_subframe_suppresion)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT_BEGIN1("mojom", "Call blink::mojom::LocalFrameHost::RunModalAlertDialog (sync)", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("alert_message"), param_alert_message, "<value of type const ::WTF::String&>");
        perfetto::WriteIntoTracedValueWithFallback(
            dict.AddItem("disable_third_party_subframe_suppresion"), param_disable_third_party_subframe_suppresion, "<value of type bool>");
    });
#else
    TRACE_EVENT0("mojom", "LocalFrameHost::RunModalAlertDialog");
#endif

    const bool kExpectsResponse = true;
    const bool kIsSync = true;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kRunModalAlertDialog), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_RunModalAlertDialog_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->alert_message)::BaseType> alert_message_fragment(params.message());
    mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(param_alert_message, alert_message_fragment);
    params->alert_message.Set(alert_message_fragment.is_null() ? nullptr : alert_message_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->alert_message.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null alert_message in LocalFrameHost.RunModalAlertDialog request");
    params->disable_third_party_subframe_suppresion = param_disable_third_party_subframe_suppresion;

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("RunModalAlertDialog");
#endif

    bool result = false;
    std::unique_ptr<mojo::MessageReceiver> responder(new LocalFrameHost_RunModalAlertDialog_HandleSyncResponse(&result));
    ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT_END0("mojom", "LocalFrameHost::RunModalAlertDialog");
#endif
    return result;
}

void LocalFrameHostProxy::RunModalAlertDialog(
    const ::WTF::String& in_alert_message, bool in_disable_third_party_subframe_suppresion, RunModalAlertDialogCallback callback)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrameHost::RunModalAlertDialog", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("alert_message"), in_alert_message, "<value of type const ::WTF::String&>");
        perfetto::WriteIntoTracedValueWithFallback(
            dict.AddItem("disable_third_party_subframe_suppresion"), in_disable_third_party_subframe_suppresion, "<value of type bool>");
    });
#endif

    const bool kExpectsResponse = true;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kRunModalAlertDialog), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_RunModalAlertDialog_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->alert_message)::BaseType> alert_message_fragment(params.message());
    mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(in_alert_message, alert_message_fragment);
    params->alert_message.Set(alert_message_fragment.is_null() ? nullptr : alert_message_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->alert_message.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null alert_message in LocalFrameHost.RunModalAlertDialog request");
    params->disable_third_party_subframe_suppresion = in_disable_third_party_subframe_suppresion;

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("RunModalAlertDialog");
#endif
    std::unique_ptr<mojo::MessageReceiver> responder(new LocalFrameHost_RunModalAlertDialog_ForwardToCallback(std::move(callback)));
    ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}
bool LocalFrameHostProxy::RunModalConfirmDialog(
    const ::WTF::String& param_alert_message, bool param_disable_third_party_subframe_suppresion, bool* out_param_success)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT_BEGIN1("mojom", "Call blink::mojom::LocalFrameHost::RunModalConfirmDialog (sync)", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("alert_message"), param_alert_message, "<value of type const ::WTF::String&>");
        perfetto::WriteIntoTracedValueWithFallback(
            dict.AddItem("disable_third_party_subframe_suppresion"), param_disable_third_party_subframe_suppresion, "<value of type bool>");
    });
#else
    TRACE_EVENT0("mojom", "LocalFrameHost::RunModalConfirmDialog");
#endif

    const bool kExpectsResponse = true;
    const bool kIsSync = true;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kRunModalConfirmDialog), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_RunModalConfirmDialog_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->alert_message)::BaseType> alert_message_fragment(params.message());
    mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(param_alert_message, alert_message_fragment);
    params->alert_message.Set(alert_message_fragment.is_null() ? nullptr : alert_message_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->alert_message.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null alert_message in LocalFrameHost.RunModalConfirmDialog request");
    params->disable_third_party_subframe_suppresion = param_disable_third_party_subframe_suppresion;

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("RunModalConfirmDialog");
#endif

    bool result = false;
    std::unique_ptr<mojo::MessageReceiver> responder(new LocalFrameHost_RunModalConfirmDialog_HandleSyncResponse(&result, out_param_success));
    ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT_END1("mojom", "LocalFrameHost::RunModalConfirmDialog", "sync_response_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("success"), out_param_success, "<value of type bool>");
    });
#endif
    return result;
}

void LocalFrameHostProxy::RunModalConfirmDialog(
    const ::WTF::String& in_alert_message, bool in_disable_third_party_subframe_suppresion, RunModalConfirmDialogCallback callback)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrameHost::RunModalConfirmDialog", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("alert_message"), in_alert_message, "<value of type const ::WTF::String&>");
        perfetto::WriteIntoTracedValueWithFallback(
            dict.AddItem("disable_third_party_subframe_suppresion"), in_disable_third_party_subframe_suppresion, "<value of type bool>");
    });
#endif

    const bool kExpectsResponse = true;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kRunModalConfirmDialog), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_RunModalConfirmDialog_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->alert_message)::BaseType> alert_message_fragment(params.message());
    mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(in_alert_message, alert_message_fragment);
    params->alert_message.Set(alert_message_fragment.is_null() ? nullptr : alert_message_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->alert_message.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null alert_message in LocalFrameHost.RunModalConfirmDialog request");
    params->disable_third_party_subframe_suppresion = in_disable_third_party_subframe_suppresion;

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("RunModalConfirmDialog");
#endif
    std::unique_ptr<mojo::MessageReceiver> responder(new LocalFrameHost_RunModalConfirmDialog_ForwardToCallback(std::move(callback)));
    ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}
bool LocalFrameHostProxy::RunModalPromptDialog(const ::WTF::String& param_alert_message, const ::WTF::String& param_default_value,
    bool param_disable_third_party_subframe_suppresion, bool* out_param_success, ::WTF::String* out_param_result)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT_BEGIN1("mojom", "Call blink::mojom::LocalFrameHost::RunModalPromptDialog (sync)", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("alert_message"), param_alert_message, "<value of type const ::WTF::String&>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("default_value"), param_default_value, "<value of type const ::WTF::String&>");
        perfetto::WriteIntoTracedValueWithFallback(
            dict.AddItem("disable_third_party_subframe_suppresion"), param_disable_third_party_subframe_suppresion, "<value of type bool>");
    });
#else
    TRACE_EVENT0("mojom", "LocalFrameHost::RunModalPromptDialog");
#endif

    const bool kExpectsResponse = true;
    const bool kIsSync = true;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kRunModalPromptDialog), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_RunModalPromptDialog_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->alert_message)::BaseType> alert_message_fragment(params.message());
    mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(param_alert_message, alert_message_fragment);
    params->alert_message.Set(alert_message_fragment.is_null() ? nullptr : alert_message_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->alert_message.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null alert_message in LocalFrameHost.RunModalPromptDialog request");
    mojo::internal::MessageFragment<typename decltype(params->default_value)::BaseType> default_value_fragment(params.message());
    mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(param_default_value, default_value_fragment);
    params->default_value.Set(default_value_fragment.is_null() ? nullptr : default_value_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->default_value.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null default_value in LocalFrameHost.RunModalPromptDialog request");
    params->disable_third_party_subframe_suppresion = param_disable_third_party_subframe_suppresion;

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("RunModalPromptDialog");
#endif

    bool result = false;
    std::unique_ptr<mojo::MessageReceiver> responder(new LocalFrameHost_RunModalPromptDialog_HandleSyncResponse(&result, out_param_success, out_param_result));
    ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT_END1("mojom", "LocalFrameHost::RunModalPromptDialog", "sync_response_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("success"), out_param_success, "<value of type bool>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("result"), out_param_result, "<value of type const ::WTF::String&>");
    });
#endif
    return result;
}

void LocalFrameHostProxy::RunModalPromptDialog(const ::WTF::String& in_alert_message, const ::WTF::String& in_default_value,
    bool in_disable_third_party_subframe_suppresion, RunModalPromptDialogCallback callback)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrameHost::RunModalPromptDialog", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("alert_message"), in_alert_message, "<value of type const ::WTF::String&>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("default_value"), in_default_value, "<value of type const ::WTF::String&>");
        perfetto::WriteIntoTracedValueWithFallback(
            dict.AddItem("disable_third_party_subframe_suppresion"), in_disable_third_party_subframe_suppresion, "<value of type bool>");
    });
#endif

    const bool kExpectsResponse = true;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kRunModalPromptDialog), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_RunModalPromptDialog_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->alert_message)::BaseType> alert_message_fragment(params.message());
    mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(in_alert_message, alert_message_fragment);
    params->alert_message.Set(alert_message_fragment.is_null() ? nullptr : alert_message_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->alert_message.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null alert_message in LocalFrameHost.RunModalPromptDialog request");
    mojo::internal::MessageFragment<typename decltype(params->default_value)::BaseType> default_value_fragment(params.message());
    mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(in_default_value, default_value_fragment);
    params->default_value.Set(default_value_fragment.is_null() ? nullptr : default_value_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->default_value.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null default_value in LocalFrameHost.RunModalPromptDialog request");
    params->disable_third_party_subframe_suppresion = in_disable_third_party_subframe_suppresion;

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("RunModalPromptDialog");
#endif
    std::unique_ptr<mojo::MessageReceiver> responder(new LocalFrameHost_RunModalPromptDialog_ForwardToCallback(std::move(callback)));
    ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}
bool LocalFrameHostProxy::RunBeforeUnloadConfirm(bool param_is_reload, bool* out_param_success)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT_BEGIN1("mojom", "Call blink::mojom::LocalFrameHost::RunBeforeUnloadConfirm (sync)", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("is_reload"), param_is_reload, "<value of type bool>");
    });
#else
    TRACE_EVENT0("mojom", "LocalFrameHost::RunBeforeUnloadConfirm");
#endif

    const bool kExpectsResponse = true;
    const bool kIsSync = true;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kRunBeforeUnloadConfirm), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_RunBeforeUnloadConfirm_Params_Data> params(message);
    params.Allocate();
    params->is_reload = param_is_reload;

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("RunBeforeUnloadConfirm");
#endif

    bool result = false;
    std::unique_ptr<mojo::MessageReceiver> responder(new LocalFrameHost_RunBeforeUnloadConfirm_HandleSyncResponse(&result, out_param_success));
    ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT_END1("mojom", "LocalFrameHost::RunBeforeUnloadConfirm", "sync_response_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("success"), out_param_success, "<value of type bool>");
    });
#endif
    return result;
}

void LocalFrameHostProxy::RunBeforeUnloadConfirm(bool in_is_reload, RunBeforeUnloadConfirmCallback callback)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrameHost::RunBeforeUnloadConfirm", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("is_reload"), in_is_reload, "<value of type bool>");
    });
#endif

    const bool kExpectsResponse = true;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kRunBeforeUnloadConfirm), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_RunBeforeUnloadConfirm_Params_Data> params(message);
    params.Allocate();
    params->is_reload = in_is_reload;

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("RunBeforeUnloadConfirm");
#endif
    std::unique_ptr<mojo::MessageReceiver> responder(new LocalFrameHost_RunBeforeUnloadConfirm_ForwardToCallback(std::move(callback)));
    ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void LocalFrameHostProxy::UpdateFaviconURL(WTF::Vector<::blink::mojom::blink::FaviconURLPtr> in_favicon_urls)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrameHost::UpdateFaviconURL", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(
            dict.AddItem("favicon_urls"), in_favicon_urls, "<value of type WTF::Vector<::blink::mojom::blink::FaviconURLPtr>>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kUpdateFaviconURL), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_UpdateFaviconURL_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->favicon_urls)::BaseType> favicon_urls_fragment(params.message());
    constexpr const mojo::internal::ContainerValidateParams& favicon_urls_validate_params = mojo::internal::GetArrayValidator<0, false, nullptr>();
    mojo::internal::Serialize<mojo::ArrayDataView<::blink::mojom::FaviconURLDataView>>(in_favicon_urls, favicon_urls_fragment, &favicon_urls_validate_params);
    params->favicon_urls.Set(favicon_urls_fragment.is_null() ? nullptr : favicon_urls_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->favicon_urls.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null favicon_urls in LocalFrameHost.UpdateFaviconURL request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("UpdateFaviconURL");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::DownloadURL(DownloadURLParamsPtr in_params)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrameHost::DownloadURL", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("params"), in_params, "<value of type DownloadURLParamsPtr>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kDownloadURL), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_DownloadURL_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->params)::BaseType> params_fragment(params.message());
    mojo::internal::Serialize<::blink::mojom::DownloadURLParamsDataView>(in_params, params_fragment);
    params->params.Set(params_fragment.is_null() ? nullptr : params_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->params.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null params in LocalFrameHost.DownloadURL request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("DownloadURL");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::FocusedElementChanged(bool in_is_editable_element, bool in_is_richly_editable_element, const ::gfx::Rect& in_bounds_in_frame_widget,
    ::blink::mojom::blink::FocusType in_focus_type)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrameHost::FocusedElementChanged", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("is_editable_element"), in_is_editable_element, "<value of type bool>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("is_richly_editable_element"), in_is_richly_editable_element, "<value of type bool>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("bounds_in_frame_widget"), in_bounds_in_frame_widget, "<value of type const ::gfx::Rect&>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("focus_type"), in_focus_type, "<value of type ::blink::mojom::blink::FocusType>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kFocusedElementChanged), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_FocusedElementChanged_Params_Data> params(message);
    params.Allocate();
    params->is_editable_element = in_is_editable_element;
    params->is_richly_editable_element = in_is_richly_editable_element;
    mojo::internal::MessageFragment<typename decltype(params->bounds_in_frame_widget)::BaseType> bounds_in_frame_widget_fragment(params.message());
    mojo::internal::Serialize<::gfx::mojom::RectDataView>(in_bounds_in_frame_widget, bounds_in_frame_widget_fragment);
    params->bounds_in_frame_widget.Set(bounds_in_frame_widget_fragment.is_null() ? nullptr : bounds_in_frame_widget_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->bounds_in_frame_widget.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null bounds_in_frame_widget in LocalFrameHost.FocusedElementChanged request");
    mojo::internal::Serialize<::blink::mojom::FocusType>(in_focus_type, &params->focus_type);

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("FocusedElementChanged");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::TextSelectionChanged(const ::WTF::String& in_text, uint32_t in_offset, const ::gfx::Range& in_range)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrameHost::TextSelectionChanged", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("text"), in_text, "<value of type const ::WTF::String&>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("offset"), in_offset, "<value of type uint32_t>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("range"), in_range, "<value of type const ::gfx::Range&>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kTextSelectionChanged), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_TextSelectionChanged_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->text)::BaseType> text_fragment(params.message());
    mojo::internal::Serialize<::mojo_base::mojom::BigString16DataView>(in_text, text_fragment);
    params->text.Set(text_fragment.is_null() ? nullptr : text_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->text.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null text in LocalFrameHost.TextSelectionChanged request");
    params->offset = in_offset;
    mojo::internal::MessageFragment<typename decltype(params->range)::BaseType> range_fragment(params.message());
    mojo::internal::Serialize<::gfx::mojom::RangeDataView>(in_range, range_fragment);
    params->range.Set(range_fragment.is_null() ? nullptr : range_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->range.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null range in LocalFrameHost.TextSelectionChanged request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("TextSelectionChanged");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::ShowPopupMenu(::mojo::PendingRemote<::blink::mojom::blink::PopupMenuClient> in_popup_client, const ::gfx::Rect& in_bounds,
    int32_t in_item_height, double in_font_size, int32_t in_selected_item, WTF::Vector<::blink::mojom::blink::MenuItemPtr> in_menu_items, bool in_right_aligned,
    bool in_allow_multiple_selection)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrameHost::ShowPopupMenu", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(
            dict.AddItem("popup_client"), in_popup_client, "<value of type ::mojo::PendingRemote<::blink::mojom::blink::PopupMenuClient>>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("bounds"), in_bounds, "<value of type const ::gfx::Rect&>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("item_height"), in_item_height, "<value of type int32_t>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("font_size"), in_font_size, "<value of type double>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("selected_item"), in_selected_item, "<value of type int32_t>");
        perfetto::WriteIntoTracedValueWithFallback(
            dict.AddItem("menu_items"), in_menu_items, "<value of type WTF::Vector<::blink::mojom::blink::MenuItemPtr>>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("right_aligned"), in_right_aligned, "<value of type bool>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("allow_multiple_selection"), in_allow_multiple_selection, "<value of type bool>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kShowPopupMenu), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_ShowPopupMenu_Params_Data> params(message);
    params.Allocate();
    mojo::internal::Serialize<mojo::InterfacePtrDataView<::blink::mojom::PopupMenuClientInterfaceBase>>(
        in_popup_client, &params->popup_client, &params.message());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(!mojo::internal::IsHandleOrInterfaceValid(params->popup_client),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE, "invalid popup_client in LocalFrameHost.ShowPopupMenu request");
    mojo::internal::MessageFragment<typename decltype(params->bounds)::BaseType> bounds_fragment(params.message());
    mojo::internal::Serialize<::gfx::mojom::RectDataView>(in_bounds, bounds_fragment);
    params->bounds.Set(bounds_fragment.is_null() ? nullptr : bounds_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->bounds.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null bounds in LocalFrameHost.ShowPopupMenu request");
    params->item_height = in_item_height;
    params->font_size = in_font_size;
    params->selected_item = in_selected_item;
    mojo::internal::MessageFragment<typename decltype(params->menu_items)::BaseType> menu_items_fragment(params.message());
    constexpr const mojo::internal::ContainerValidateParams& menu_items_validate_params = mojo::internal::GetArrayValidator<0, false, nullptr>();
    mojo::internal::Serialize<mojo::ArrayDataView<::blink::mojom::MenuItemDataView>>(in_menu_items, menu_items_fragment, &menu_items_validate_params);
    params->menu_items.Set(menu_items_fragment.is_null() ? nullptr : menu_items_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->menu_items.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null menu_items in LocalFrameHost.ShowPopupMenu request");
    params->right_aligned = in_right_aligned;
    params->allow_multiple_selection = in_allow_multiple_selection;

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("ShowPopupMenu");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::CreateNewPopupWidget(::mojo::PendingAssociatedReceiver<::blink::mojom::blink::PopupWidgetHost> in_popup_host,
    ::mojo::PendingAssociatedReceiver<::blink::mojom::blink::WidgetHost> in_blink_widget_host,
    ::mojo::PendingAssociatedRemote<::blink::mojom::blink::Widget> in_blink_widget)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrameHost::CreateNewPopupWidget", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(
            dict.AddItem("popup_host"), in_popup_host, "<value of type ::mojo::PendingAssociatedReceiver<::blink::mojom::blink::PopupWidgetHost>>");
        perfetto::WriteIntoTracedValueWithFallback(
            dict.AddItem("blink_widget_host"), in_blink_widget_host, "<value of type ::mojo::PendingAssociatedReceiver<::blink::mojom::blink::WidgetHost>>");
        perfetto::WriteIntoTracedValueWithFallback(
            dict.AddItem("blink_widget"), in_blink_widget, "<value of type ::mojo::PendingAssociatedRemote<::blink::mojom::blink::Widget>>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kCreateNewPopupWidget), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_CreateNewPopupWidget_Params_Data> params(message);
    params.Allocate();
    mojo::internal::Serialize<::blink::mojom::PopupWidgetHostAssociatedRequestDataView>(in_popup_host, &params->popup_host, &params.message());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(!mojo::internal::IsHandleOrInterfaceValid(params->popup_host),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_INTERFACE_ID, "invalid popup_host in LocalFrameHost.CreateNewPopupWidget request");
    mojo::internal::Serialize<::blink::mojom::WidgetHostAssociatedRequestDataView>(in_blink_widget_host, &params->blink_widget_host, &params.message());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(!mojo::internal::IsHandleOrInterfaceValid(params->blink_widget_host),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_INTERFACE_ID, "invalid blink_widget_host in LocalFrameHost.CreateNewPopupWidget request");
    mojo::internal::Serialize<::blink::mojom::WidgetAssociatedPtrInfoDataView>(in_blink_widget, &params->blink_widget, &params.message());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(!mojo::internal::IsHandleOrInterfaceValid(params->blink_widget),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_INTERFACE_ID, "invalid blink_widget in LocalFrameHost.CreateNewPopupWidget request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("CreateNewPopupWidget");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::ShowContextMenu(
    ::mojo::PendingAssociatedRemote<::blink::mojom::blink::ContextMenuClient> in_client, const ::blink::UntrustworthyContextMenuParams& in_params)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrameHost::ShowContextMenu", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(
            dict.AddItem("client"), in_client, "<value of type ::mojo::PendingAssociatedRemote<::blink::mojom::blink::ContextMenuClient>>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("params"), in_params, "<value of type const ::blink::UntrustworthyContextMenuParams&>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kShowContextMenu), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_ShowContextMenu_Params_Data> params(message);
    params.Allocate();
    mojo::internal::Serialize<::blink::mojom::ContextMenuClientAssociatedPtrInfoDataView>(in_client, &params->client, &params.message());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(!mojo::internal::IsHandleOrInterfaceValid(params->client),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_INTERFACE_ID, "invalid client in LocalFrameHost.ShowContextMenu request");
    mojo::internal::MessageFragment<typename decltype(params->params)::BaseType> params_fragment(params.message());
    mojo::internal::Serialize<::blink::mojom::UntrustworthyContextMenuParamsDataView>(in_params, params_fragment);
    params->params.Set(params_fragment.is_null() ? nullptr : params_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->params.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null params in LocalFrameHost.ShowContextMenu request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("ShowContextMenu");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::DidLoadResourceFromMemoryCache(const ::blink::KURL& in_url, const WTF::String& in_http_method, const WTF::String& in_mime_type,
    ::network::mojom::blink::RequestDestination in_request_destination, bool in_include_credentials)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrameHost::DidLoadResourceFromMemoryCache", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("url"), in_url, "<value of type const ::blink::KURL&>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("http_method"), in_http_method, "<value of type const WTF::String&>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("mime_type"), in_mime_type, "<value of type const WTF::String&>");
        perfetto::WriteIntoTracedValueWithFallback(
            dict.AddItem("request_destination"), in_request_destination, "<value of type ::network::mojom::blink::RequestDestination>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("include_credentials"), in_include_credentials, "<value of type bool>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kDidLoadResourceFromMemoryCache), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_DidLoadResourceFromMemoryCache_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->url)::BaseType> url_fragment(params.message());
    mojo::internal::Serialize<::url::mojom::UrlDataView>(in_url, url_fragment);
    params->url.Set(url_fragment.is_null() ? nullptr : url_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->url.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null url in LocalFrameHost.DidLoadResourceFromMemoryCache request");
    mojo::internal::MessageFragment<typename decltype(params->http_method)::BaseType> http_method_fragment(params.message());
    mojo::internal::Serialize<mojo::StringDataView>(in_http_method, http_method_fragment);
    params->http_method.Set(http_method_fragment.is_null() ? nullptr : http_method_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->http_method.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null http_method in LocalFrameHost.DidLoadResourceFromMemoryCache request");
    mojo::internal::MessageFragment<typename decltype(params->mime_type)::BaseType> mime_type_fragment(params.message());
    mojo::internal::Serialize<mojo::StringDataView>(in_mime_type, mime_type_fragment);
    params->mime_type.Set(mime_type_fragment.is_null() ? nullptr : mime_type_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->mime_type.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null mime_type in LocalFrameHost.DidLoadResourceFromMemoryCache request");
    mojo::internal::Serialize<::network::mojom::RequestDestination>(in_request_destination, &params->request_destination);
    params->include_credentials = in_include_credentials;

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("DidLoadResourceFromMemoryCache");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::DidChangeFrameOwnerProperties(
    const ::blink::FrameToken& in_child_frame_token, ::blink::mojom::blink::FrameOwnerPropertiesPtr in_frame_owner_properties)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrameHost::DidChangeFrameOwnerProperties", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("child_frame_token"), in_child_frame_token, "<value of type const ::blink::FrameToken&>");
        perfetto::WriteIntoTracedValueWithFallback(
            dict.AddItem("frame_owner_properties"), in_frame_owner_properties, "<value of type ::blink::mojom::blink::FrameOwnerPropertiesPtr>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kDidChangeFrameOwnerProperties), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_DidChangeFrameOwnerProperties_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<decltype(params->child_frame_token)> child_frame_token_fragment(params.message());
    child_frame_token_fragment.Claim(&params->child_frame_token);
    mojo::internal::Serialize<::blink::mojom::FrameTokenDataView>(in_child_frame_token, child_frame_token_fragment, true);
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->child_frame_token.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null child_frame_token in LocalFrameHost.DidChangeFrameOwnerProperties request");
    mojo::internal::MessageFragment<typename decltype(params->frame_owner_properties)::BaseType> frame_owner_properties_fragment(params.message());
    mojo::internal::Serialize<::blink::mojom::FrameOwnerPropertiesDataView>(in_frame_owner_properties, frame_owner_properties_fragment);
    params->frame_owner_properties.Set(frame_owner_properties_fragment.is_null() ? nullptr : frame_owner_properties_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->frame_owner_properties.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null frame_owner_properties in LocalFrameHost.DidChangeFrameOwnerProperties request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("DidChangeFrameOwnerProperties");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::DidChangeOpener(const std::optional<::blink::LocalFrameToken>& in_opener_frame)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrameHost::DidChangeOpener", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(
            dict.AddItem("opener_frame"), in_opener_frame, "<value of type const std::optional<::blink::LocalFrameToken>&>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kDidChangeOpener), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_DidChangeOpener_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->opener_frame)::BaseType> opener_frame_fragment(params.message());
    mojo::internal::Serialize<::blink::mojom::LocalFrameTokenDataView>(in_opener_frame, opener_frame_fragment);
    params->opener_frame.Set(opener_frame_fragment.is_null() ? nullptr : opener_frame_fragment.data());

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("DidChangeOpener");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::DidChangeFramePolicy(const ::blink::FrameToken& in_child_frame_token, const ::blink::FramePolicy& in_frame_policy)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrameHost::DidChangeFramePolicy", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("child_frame_token"), in_child_frame_token, "<value of type const ::blink::FrameToken&>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("frame_policy"), in_frame_policy, "<value of type const ::blink::FramePolicy&>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kDidChangeFramePolicy), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_DidChangeFramePolicy_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<decltype(params->child_frame_token)> child_frame_token_fragment(params.message());
    child_frame_token_fragment.Claim(&params->child_frame_token);
    mojo::internal::Serialize<::blink::mojom::FrameTokenDataView>(in_child_frame_token, child_frame_token_fragment, true);
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->child_frame_token.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null child_frame_token in LocalFrameHost.DidChangeFramePolicy request");
    mojo::internal::MessageFragment<typename decltype(params->frame_policy)::BaseType> frame_policy_fragment(params.message());
    mojo::internal::Serialize<::blink::mojom::FramePolicyDataView>(in_frame_policy, frame_policy_fragment);
    params->frame_policy.Set(frame_policy_fragment.is_null() ? nullptr : frame_policy_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->frame_policy.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null frame_policy in LocalFrameHost.DidChangeFramePolicy request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("DidChangeFramePolicy");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::DidChangeIframeAttributes(const ::blink::FrameToken& in_child_frame_token, IframeAttributesPtr in_attributes)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrameHost::DidChangeIframeAttributes", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("child_frame_token"), in_child_frame_token, "<value of type const ::blink::FrameToken&>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("attributes"), in_attributes, "<value of type IframeAttributesPtr>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kDidChangeIframeAttributes), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_DidChangeIframeAttributes_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<decltype(params->child_frame_token)> child_frame_token_fragment(params.message());
    child_frame_token_fragment.Claim(&params->child_frame_token);
    mojo::internal::Serialize<::blink::mojom::FrameTokenDataView>(in_child_frame_token, child_frame_token_fragment, true);
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->child_frame_token.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null child_frame_token in LocalFrameHost.DidChangeIframeAttributes request");
    mojo::internal::MessageFragment<typename decltype(params->attributes)::BaseType> attributes_fragment(params.message());
    mojo::internal::Serialize<::blink::mojom::IframeAttributesDataView>(in_attributes, attributes_fragment);
    params->attributes.Set(attributes_fragment.is_null() ? nullptr : attributes_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->attributes.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null attributes in LocalFrameHost.DidChangeIframeAttributes request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("DidChangeIframeAttributes");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::CapturePaintPreviewOfSubframe(const ::gfx::Rect& in_clip_rect, const ::base::UnguessableToken& in_guid)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrameHost::CapturePaintPreviewOfSubframe", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("clip_rect"), in_clip_rect, "<value of type const ::gfx::Rect&>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("guid"), in_guid, "<value of type const ::base::UnguessableToken&>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kCapturePaintPreviewOfSubframe), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_CapturePaintPreviewOfSubframe_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->clip_rect)::BaseType> clip_rect_fragment(params.message());
    mojo::internal::Serialize<::gfx::mojom::RectDataView>(in_clip_rect, clip_rect_fragment);
    params->clip_rect.Set(clip_rect_fragment.is_null() ? nullptr : clip_rect_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->clip_rect.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null clip_rect in LocalFrameHost.CapturePaintPreviewOfSubframe request");
    mojo::internal::MessageFragment<typename decltype(params->guid)::BaseType> guid_fragment(params.message());
    mojo::internal::Serialize<::mojo_base::mojom::UnguessableTokenDataView>(in_guid, guid_fragment);
    params->guid.Set(guid_fragment.is_null() ? nullptr : guid_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->guid.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null guid in LocalFrameHost.CapturePaintPreviewOfSubframe request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("CapturePaintPreviewOfSubframe");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::SetCloseListener(::mojo::PendingRemote<::blink::mojom::blink::CloseListener> in_listener)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrameHost::SetCloseListener", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(
            dict.AddItem("listener"), in_listener, "<value of type ::mojo::PendingRemote<::blink::mojom::blink::CloseListener>>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kSetCloseListener), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_SetCloseListener_Params_Data> params(message);
    params.Allocate();
    mojo::internal::Serialize<mojo::InterfacePtrDataView<::blink::mojom::CloseListenerInterfaceBase>>(in_listener, &params->listener, &params.message());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(!mojo::internal::IsHandleOrInterfaceValid(params->listener),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE, "invalid listener in LocalFrameHost.SetCloseListener request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("SetCloseListener");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::Detach()
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT0("mojom", "Send blink::mojom::LocalFrameHost::Detach");
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kDetach), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_Detach_Params_Data> params(message);
    params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("Detach");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::GetKeepAliveHandleFactory(::mojo::PendingReceiver<::blink::mojom::blink::KeepAliveHandleFactory> in_factory)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrameHost::GetKeepAliveHandleFactory", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(
            dict.AddItem("factory"), in_factory, "<value of type ::mojo::PendingReceiver<::blink::mojom::blink::KeepAliveHandleFactory>>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kGetKeepAliveHandleFactory), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_GetKeepAliveHandleFactory_Params_Data> params(message);
    params.Allocate();
    mojo::internal::Serialize<mojo::InterfaceRequestDataView<::blink::mojom::KeepAliveHandleFactoryInterfaceBase>>(
        in_factory, &params->factory, &params.message());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(!mojo::internal::IsHandleOrInterfaceValid(params->factory),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE, "invalid factory in LocalFrameHost.GetKeepAliveHandleFactory request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("GetKeepAliveHandleFactory");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::DidAddMessageToConsole(::blink::mojom::blink::ConsoleMessageLevel in_log_level, const ::WTF::String& in_msg, uint32_t in_line_number,
    const ::WTF::String& in_source_id, const ::WTF::String& in_untrusted_stack_trace)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrameHost::DidAddMessageToConsole", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("log_level"), in_log_level, "<value of type ::blink::mojom::blink::ConsoleMessageLevel>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("msg"), in_msg, "<value of type const ::WTF::String&>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("line_number"), in_line_number, "<value of type uint32_t>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("source_id"), in_source_id, "<value of type const ::WTF::String&>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("untrusted_stack_trace"), in_untrusted_stack_trace, "<value of type const ::WTF::String&>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kDidAddMessageToConsole), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_DidAddMessageToConsole_Params_Data> params(message);
    params.Allocate();
    mojo::internal::Serialize<::blink::mojom::ConsoleMessageLevel>(in_log_level, &params->log_level);
    mojo::internal::MessageFragment<typename decltype(params->msg)::BaseType> msg_fragment(params.message());
    mojo::internal::Serialize<::mojo_base::mojom::BigString16DataView>(in_msg, msg_fragment);
    params->msg.Set(msg_fragment.is_null() ? nullptr : msg_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->msg.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null msg in LocalFrameHost.DidAddMessageToConsole request");
    params->line_number = in_line_number;
    mojo::internal::MessageFragment<typename decltype(params->source_id)::BaseType> source_id_fragment(params.message());
    mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(in_source_id, source_id_fragment);
    params->source_id.Set(source_id_fragment.is_null() ? nullptr : source_id_fragment.data());
    mojo::internal::MessageFragment<typename decltype(params->untrusted_stack_trace)::BaseType> untrusted_stack_trace_fragment(params.message());
    mojo::internal::Serialize<::mojo_base::mojom::BigString16DataView>(in_untrusted_stack_trace, untrusted_stack_trace_fragment);
    params->untrusted_stack_trace.Set(untrusted_stack_trace_fragment.is_null() ? nullptr : untrusted_stack_trace_fragment.data());

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("DidAddMessageToConsole");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::FrameSizeChanged(const ::gfx::Size& in_size)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrameHost::FrameSizeChanged", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("size"), in_size, "<value of type const ::gfx::Size&>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kFrameSizeChanged), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_FrameSizeChanged_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->size)::BaseType> size_fragment(params.message());
    mojo::internal::Serialize<::gfx::mojom::SizeDataView>(in_size, size_fragment);
    params->size.Set(size_fragment.is_null() ? nullptr : size_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->size.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null size in LocalFrameHost.FrameSizeChanged request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("FrameSizeChanged");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::DidInferColorScheme(::blink::mojom::blink::PreferredColorScheme in_color_scheme)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrameHost::DidInferColorScheme", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(
            dict.AddItem("color_scheme"), in_color_scheme, "<value of type ::blink::mojom::blink::PreferredColorScheme>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kDidInferColorScheme), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_DidInferColorScheme_Params_Data> params(message);
    params.Allocate();
    mojo::internal::Serialize<::blink::mojom::PreferredColorScheme>(in_color_scheme, &params->color_scheme);

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("DidInferColorScheme");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::DidChangeSrcDoc(const ::blink::FrameToken& in_child_frame_token, const WTF::String& in_srcdoc_value)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrameHost::DidChangeSrcDoc", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("child_frame_token"), in_child_frame_token, "<value of type const ::blink::FrameToken&>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("srcdoc_value"), in_srcdoc_value, "<value of type const WTF::String&>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kDidChangeSrcDoc), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_DidChangeSrcDoc_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<decltype(params->child_frame_token)> child_frame_token_fragment(params.message());
    child_frame_token_fragment.Claim(&params->child_frame_token);
    mojo::internal::Serialize<::blink::mojom::FrameTokenDataView>(in_child_frame_token, child_frame_token_fragment, true);
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->child_frame_token.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null child_frame_token in LocalFrameHost.DidChangeSrcDoc request");
    mojo::internal::MessageFragment<typename decltype(params->srcdoc_value)::BaseType> srcdoc_value_fragment(params.message());
    mojo::internal::Serialize<mojo::StringDataView>(in_srcdoc_value, srcdoc_value_fragment);
    params->srcdoc_value.Set(srcdoc_value_fragment.is_null() ? nullptr : srcdoc_value_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->srcdoc_value.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null srcdoc_value in LocalFrameHost.DidChangeSrcDoc request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("DidChangeSrcDoc");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::ReceivedDelegatedCapability(::blink::mojom::blink::DelegatedCapability in_delegated_capability)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrameHost::ReceivedDelegatedCapability", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(
            dict.AddItem("delegated_capability"), in_delegated_capability, "<value of type ::blink::mojom::blink::DelegatedCapability>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kReceivedDelegatedCapability), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_ReceivedDelegatedCapability_Params_Data> params(message);
    params.Allocate();
    mojo::internal::Serialize<::blink::mojom::DelegatedCapability>(in_delegated_capability, &params->delegated_capability);

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("ReceivedDelegatedCapability");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::SendFencedFrameReportingBeacon(const WTF::String& in_event_data, const WTF::String& in_event_type,
    const WTF::Vector<::blink::FencedFrame::ReportingDestination>& in_destinations, bool in_cross_origin_exposed)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrameHost::SendFencedFrameReportingBeacon", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("event_data"), in_event_data, "<value of type const WTF::String&>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("event_type"), in_event_type, "<value of type const WTF::String&>");
        perfetto::WriteIntoTracedValueWithFallback(
            dict.AddItem("destinations"), in_destinations, "<value of type const WTF::Vector<::blink::FencedFrame::ReportingDestination>&>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("cross_origin_exposed"), in_cross_origin_exposed, "<value of type bool>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kSendFencedFrameReportingBeacon), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_SendFencedFrameReportingBeacon_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->event_data)::BaseType> event_data_fragment(params.message());
    mojo::internal::Serialize<mojo::StringDataView>(in_event_data, event_data_fragment);
    params->event_data.Set(event_data_fragment.is_null() ? nullptr : event_data_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->event_data.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null event_data in LocalFrameHost.SendFencedFrameReportingBeacon request");
    mojo::internal::MessageFragment<typename decltype(params->event_type)::BaseType> event_type_fragment(params.message());
    mojo::internal::Serialize<mojo::StringDataView>(in_event_type, event_type_fragment);
    params->event_type.Set(event_type_fragment.is_null() ? nullptr : event_type_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->event_type.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null event_type in LocalFrameHost.SendFencedFrameReportingBeacon request");
    mojo::internal::MessageFragment<typename decltype(params->destinations)::BaseType> destinations_fragment(params.message());
    constexpr const mojo::internal::ContainerValidateParams& destinations_validate_params
        = mojo::internal::GetArrayOfEnumsValidator<0, false, ::blink::mojom::internal::ReportingDestination_Data::Validate>();
    mojo::internal::Serialize<mojo::ArrayDataView<::blink::mojom::ReportingDestination>>(in_destinations, destinations_fragment, &destinations_validate_params);
    params->destinations.Set(destinations_fragment.is_null() ? nullptr : destinations_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->destinations.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null destinations in LocalFrameHost.SendFencedFrameReportingBeacon request");
    params->cross_origin_exposed = in_cross_origin_exposed;

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("SendFencedFrameReportingBeacon");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::SendFencedFrameReportingBeaconToCustomURL(const ::blink::KURL& in_destination_url, bool in_cross_origin_exposed)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1(
        "mojom", "Send blink::mojom::LocalFrameHost::SendFencedFrameReportingBeaconToCustomURL", "input_parameters", [&](perfetto::TracedValue context) {
            auto dict = std::move(context).WriteDictionary();
            perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("destination_url"), in_destination_url, "<value of type const ::blink::KURL&>");
            perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("cross_origin_exposed"), in_cross_origin_exposed, "<value of type bool>");
        });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kSendFencedFrameReportingBeaconToCustomURL), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_SendFencedFrameReportingBeaconToCustomURL_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->destination_url)::BaseType> destination_url_fragment(params.message());
    mojo::internal::Serialize<::url::mojom::UrlDataView>(in_destination_url, destination_url_fragment);
    params->destination_url.Set(destination_url_fragment.is_null() ? nullptr : destination_url_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->destination_url.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null destination_url in LocalFrameHost.SendFencedFrameReportingBeaconToCustomURL request");
    params->cross_origin_exposed = in_cross_origin_exposed;

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("SendFencedFrameReportingBeaconToCustomURL");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::DisableUntrustedNetworkInFencedFrame(DisableUntrustedNetworkInFencedFrameCallback callback)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT0("mojom", "Send blink::mojom::LocalFrameHost::DisableUntrustedNetworkInFencedFrame");
#endif

    const bool kExpectsResponse = true;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kDisableUntrustedNetworkInFencedFrame), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_DisableUntrustedNetworkInFencedFrame_Params_Data> params(message);
    params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("DisableUntrustedNetworkInFencedFrame");
#endif
    std::unique_ptr<mojo::MessageReceiver> responder(new LocalFrameHost_DisableUntrustedNetworkInFencedFrame_ForwardToCallback(std::move(callback)));
    ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void LocalFrameHostProxy::ExemptUrlFromNetworkRevocationForTesting(
    const ::blink::KURL& in_exempted_url, ExemptUrlFromNetworkRevocationForTestingCallback callback)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1(
        "mojom", "Send blink::mojom::LocalFrameHost::ExemptUrlFromNetworkRevocationForTesting", "input_parameters", [&](perfetto::TracedValue context) {
            auto dict = std::move(context).WriteDictionary();
            perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("exempted_url"), in_exempted_url, "<value of type const ::blink::KURL&>");
        });
#endif

    const bool kExpectsResponse = true;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kExemptUrlFromNetworkRevocationForTesting), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_ExemptUrlFromNetworkRevocationForTesting_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->exempted_url)::BaseType> exempted_url_fragment(params.message());
    mojo::internal::Serialize<::url::mojom::UrlDataView>(in_exempted_url, exempted_url_fragment);
    params->exempted_url.Set(exempted_url_fragment.is_null() ? nullptr : exempted_url_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->exempted_url.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null exempted_url in LocalFrameHost.ExemptUrlFromNetworkRevocationForTesting request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("ExemptUrlFromNetworkRevocationForTesting");
#endif
    std::unique_ptr<mojo::MessageReceiver> responder(new LocalFrameHost_ExemptUrlFromNetworkRevocationForTesting_ForwardToCallback(std::move(callback)));
    ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void LocalFrameHostProxy::SendLegacyTechEvent(const WTF::String& in_type, LegacyTechEventCodeLocationPtr in_code_location)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrameHost::SendLegacyTechEvent", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("type"), in_type, "<value of type const WTF::String&>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("code_location"), in_code_location, "<value of type LegacyTechEventCodeLocationPtr>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kSendLegacyTechEvent), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_SendLegacyTechEvent_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->type)::BaseType> type_fragment(params.message());
    mojo::internal::Serialize<mojo::StringDataView>(in_type, type_fragment);
    params->type.Set(type_fragment.is_null() ? nullptr : type_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->type.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null type in LocalFrameHost.SendLegacyTechEvent request");
    mojo::internal::MessageFragment<typename decltype(params->code_location)::BaseType> code_location_fragment(params.message());
    mojo::internal::Serialize<::blink::mojom::LegacyTechEventCodeLocationDataView>(in_code_location, code_location_fragment);
    params->code_location.Set(code_location_fragment.is_null() ? nullptr : code_location_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->code_location.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null code_location in LocalFrameHost.SendLegacyTechEvent request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("SendLegacyTechEvent");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::SetFencedFrameAutomaticBeaconReportEventData(::blink::mojom::blink::AutomaticBeaconType in_event_type,
    const WTF::String& in_event_data, const WTF::Vector<::blink::FencedFrame::ReportingDestination>& in_destinations, bool in_once,
    bool in_cross_origin_exposed)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1(
        "mojom", "Send blink::mojom::LocalFrameHost::SetFencedFrameAutomaticBeaconReportEventData", "input_parameters", [&](perfetto::TracedValue context) {
            auto dict = std::move(context).WriteDictionary();
            perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("event_type"), in_event_type, "<value of type ::blink::mojom::blink::AutomaticBeaconType>");
            perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("event_data"), in_event_data, "<value of type const WTF::String&>");
            perfetto::WriteIntoTracedValueWithFallback(
                dict.AddItem("destinations"), in_destinations, "<value of type const WTF::Vector<::blink::FencedFrame::ReportingDestination>&>");
            perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("once"), in_once, "<value of type bool>");
            perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("cross_origin_exposed"), in_cross_origin_exposed, "<value of type bool>");
        });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kSetFencedFrameAutomaticBeaconReportEventData), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_SetFencedFrameAutomaticBeaconReportEventData_Params_Data> params(message);
    params.Allocate();
    mojo::internal::Serialize<::blink::mojom::AutomaticBeaconType>(in_event_type, &params->event_type);
    mojo::internal::MessageFragment<typename decltype(params->event_data)::BaseType> event_data_fragment(params.message());
    mojo::internal::Serialize<mojo::StringDataView>(in_event_data, event_data_fragment);
    params->event_data.Set(event_data_fragment.is_null() ? nullptr : event_data_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->event_data.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null event_data in LocalFrameHost.SetFencedFrameAutomaticBeaconReportEventData request");
    mojo::internal::MessageFragment<typename decltype(params->destinations)::BaseType> destinations_fragment(params.message());
    constexpr const mojo::internal::ContainerValidateParams& destinations_validate_params
        = mojo::internal::GetArrayOfEnumsValidator<0, false, ::blink::mojom::internal::ReportingDestination_Data::Validate>();
    mojo::internal::Serialize<mojo::ArrayDataView<::blink::mojom::ReportingDestination>>(in_destinations, destinations_fragment, &destinations_validate_params);
    params->destinations.Set(destinations_fragment.is_null() ? nullptr : destinations_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->destinations.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null destinations in LocalFrameHost.SetFencedFrameAutomaticBeaconReportEventData request");
    params->once = in_once;
    params->cross_origin_exposed = in_cross_origin_exposed;

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("SetFencedFrameAutomaticBeaconReportEventData");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::SendPrivateAggregationRequestsForFencedFrameEvent(const WTF::String& in_event_type)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrameHost::SendPrivateAggregationRequestsForFencedFrameEvent", "input_parameters",
        [&](perfetto::TracedValue context) {
            auto dict = std::move(context).WriteDictionary();
            perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("event_type"), in_event_type, "<value of type const WTF::String&>");
        });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kSendPrivateAggregationRequestsForFencedFrameEvent), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_SendPrivateAggregationRequestsForFencedFrameEvent_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->event_type)::BaseType> event_type_fragment(params.message());
    mojo::internal::Serialize<mojo::StringDataView>(in_event_type, event_type_fragment);
    params->event_type.Set(event_type_fragment.is_null() ? nullptr : event_type_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->event_type.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null event_type in LocalFrameHost.SendPrivateAggregationRequestsForFencedFrameEvent request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("SendPrivateAggregationRequestsForFencedFrameEvent");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::CreateFencedFrame(::mojo::PendingAssociatedReceiver<::blink::mojom::blink::FencedFrameOwnerHost> in_fenced_frame,
    ::blink::mojom::blink::RemoteFrameInterfacesFromRendererPtr in_remote_frame_interfaces, const ::blink::RemoteFrameToken& in_frame_token,
    const ::base::UnguessableToken& in_devtools_frame_token)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrameHost::CreateFencedFrame", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(
            dict.AddItem("fenced_frame"), in_fenced_frame, "<value of type ::mojo::PendingAssociatedReceiver<::blink::mojom::blink::FencedFrameOwnerHost>>");
        perfetto::WriteIntoTracedValueWithFallback(
            dict.AddItem("remote_frame_interfaces"), in_remote_frame_interfaces, "<value of type ::blink::mojom::blink::RemoteFrameInterfacesFromRendererPtr>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("frame_token"), in_frame_token, "<value of type const ::blink::RemoteFrameToken&>");
        perfetto::WriteIntoTracedValueWithFallback(
            dict.AddItem("devtools_frame_token"), in_devtools_frame_token, "<value of type const ::base::UnguessableToken&>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kCreateFencedFrame), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_CreateFencedFrame_Params_Data> params(message);
    params.Allocate();
    mojo::internal::Serialize<::blink::mojom::FencedFrameOwnerHostAssociatedRequestDataView>(in_fenced_frame, &params->fenced_frame, &params.message());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(!mojo::internal::IsHandleOrInterfaceValid(params->fenced_frame),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_INTERFACE_ID, "invalid fenced_frame in LocalFrameHost.CreateFencedFrame request");
    mojo::internal::MessageFragment<typename decltype(params->remote_frame_interfaces)::BaseType> remote_frame_interfaces_fragment(params.message());
    mojo::internal::Serialize<::blink::mojom::RemoteFrameInterfacesFromRendererDataView>(in_remote_frame_interfaces, remote_frame_interfaces_fragment);
    params->remote_frame_interfaces.Set(remote_frame_interfaces_fragment.is_null() ? nullptr : remote_frame_interfaces_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->remote_frame_interfaces.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null remote_frame_interfaces in LocalFrameHost.CreateFencedFrame request");
    mojo::internal::MessageFragment<typename decltype(params->frame_token)::BaseType> frame_token_fragment(params.message());
    mojo::internal::Serialize<::blink::mojom::RemoteFrameTokenDataView>(in_frame_token, frame_token_fragment);
    params->frame_token.Set(frame_token_fragment.is_null() ? nullptr : frame_token_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->frame_token.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null frame_token in LocalFrameHost.CreateFencedFrame request");
    mojo::internal::MessageFragment<typename decltype(params->devtools_frame_token)::BaseType> devtools_frame_token_fragment(params.message());
    mojo::internal::Serialize<::mojo_base::mojom::UnguessableTokenDataView>(in_devtools_frame_token, devtools_frame_token_fragment);
    params->devtools_frame_token.Set(devtools_frame_token_fragment.is_null() ? nullptr : devtools_frame_token_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->devtools_frame_token.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null devtools_frame_token in LocalFrameHost.CreateFencedFrame request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("CreateFencedFrame");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::ForwardFencedFrameEventAndUserActivationToEmbedder(const WTF::String& in_event_type)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrameHost::ForwardFencedFrameEventAndUserActivationToEmbedder", "input_parameters",
        [&](perfetto::TracedValue context) {
            auto dict = std::move(context).WriteDictionary();
            perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("event_type"), in_event_type, "<value of type const WTF::String&>");
        });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kForwardFencedFrameEventAndUserActivationToEmbedder), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_ForwardFencedFrameEventAndUserActivationToEmbedder_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->event_type)::BaseType> event_type_fragment(params.message());
    mojo::internal::Serialize<mojo::StringDataView>(in_event_type, event_type_fragment);
    params->event_type.Set(event_type_fragment.is_null() ? nullptr : event_type_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->event_type.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null event_type in LocalFrameHost.ForwardFencedFrameEventAndUserActivationToEmbedder request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("ForwardFencedFrameEventAndUserActivationToEmbedder");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::OnViewTransitionOptInChanged(ViewTransitionSameOriginOptIn in_view_transition_opt_in)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrameHost::OnViewTransitionOptInChanged", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(
            dict.AddItem("view_transition_opt_in"), in_view_transition_opt_in, "<value of type ViewTransitionSameOriginOptIn>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kOnViewTransitionOptInChanged), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_OnViewTransitionOptInChanged_Params_Data> params(message);
    params.Allocate();
    mojo::internal::Serialize<::blink::mojom::ViewTransitionSameOriginOptIn>(in_view_transition_opt_in, &params->view_transition_opt_in);

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("OnViewTransitionOptInChanged");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::StartDragging(const ::blink::WebDragData& in_drag_data, ::blink::DragOperationsMask in_operations_allowed, const ::SkBitmap& in_image,
    const ::gfx::Vector2d& in_cursor_offset_in_dip, const ::gfx::Rect& in_drag_obj_rect_in_dip, ::blink::mojom::blink::DragEventSourceInfoPtr in_event_info)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrameHost::StartDragging", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("drag_data"), in_drag_data, "<value of type const ::blink::WebDragData&>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("operations_allowed"), in_operations_allowed, "<value of type ::blink::DragOperationsMask>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("image"), in_image, "<value of type const ::SkBitmap&>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("cursor_offset_in_dip"), in_cursor_offset_in_dip, "<value of type const ::gfx::Vector2d&>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("drag_obj_rect_in_dip"), in_drag_obj_rect_in_dip, "<value of type const ::gfx::Rect&>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("event_info"), in_event_info, "<value of type ::blink::mojom::blink::DragEventSourceInfoPtr>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kStartDragging), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_StartDragging_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->drag_data)::BaseType> drag_data_fragment(params.message());
    mojo::internal::Serialize<::blink::mojom::DragDataDataView>(in_drag_data, drag_data_fragment);
    params->drag_data.Set(drag_data_fragment.is_null() ? nullptr : drag_data_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->drag_data.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null drag_data in LocalFrameHost.StartDragging request");
    mojo::internal::MessageFragment<typename decltype(params->operations_allowed)::BaseType> operations_allowed_fragment(params.message());
    mojo::internal::Serialize<::blink::mojom::AllowedDragOperationsDataView>(in_operations_allowed, operations_allowed_fragment);
    params->operations_allowed.Set(operations_allowed_fragment.is_null() ? nullptr : operations_allowed_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->operations_allowed.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null operations_allowed in LocalFrameHost.StartDragging request");
    mojo::internal::MessageFragment<typename decltype(params->image)::BaseType> image_fragment(params.message());
    mojo::internal::Serialize<::skia::mojom::BitmapN32DataView>(in_image, image_fragment);
    params->image.Set(image_fragment.is_null() ? nullptr : image_fragment.data());
    mojo::internal::MessageFragment<typename decltype(params->cursor_offset_in_dip)::BaseType> cursor_offset_in_dip_fragment(params.message());
    mojo::internal::Serialize<::gfx::mojom::Vector2dDataView>(in_cursor_offset_in_dip, cursor_offset_in_dip_fragment);
    params->cursor_offset_in_dip.Set(cursor_offset_in_dip_fragment.is_null() ? nullptr : cursor_offset_in_dip_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->cursor_offset_in_dip.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null cursor_offset_in_dip in LocalFrameHost.StartDragging request");
    mojo::internal::MessageFragment<typename decltype(params->drag_obj_rect_in_dip)::BaseType> drag_obj_rect_in_dip_fragment(params.message());
    mojo::internal::Serialize<::gfx::mojom::RectDataView>(in_drag_obj_rect_in_dip, drag_obj_rect_in_dip_fragment);
    params->drag_obj_rect_in_dip.Set(drag_obj_rect_in_dip_fragment.is_null() ? nullptr : drag_obj_rect_in_dip_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->drag_obj_rect_in_dip.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null drag_obj_rect_in_dip in LocalFrameHost.StartDragging request");
    mojo::internal::MessageFragment<typename decltype(params->event_info)::BaseType> event_info_fragment(params.message());
    mojo::internal::Serialize<::blink::mojom::DragEventSourceInfoDataView>(in_event_info, event_info_fragment);
    params->event_info.Set(event_info_fragment.is_null() ? nullptr : event_info_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->event_info.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null event_info in LocalFrameHost.StartDragging request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("StartDragging");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::IssueKeepAliveHandle(::mojo::PendingReceiver<::blink::mojom::blink::NavigationStateKeepAliveHandle> in_receiver)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrameHost::IssueKeepAliveHandle", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(
            dict.AddItem("receiver"), in_receiver, "<value of type ::mojo::PendingReceiver<::blink::mojom::blink::NavigationStateKeepAliveHandle>>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kIssueKeepAliveHandle), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_IssueKeepAliveHandle_Params_Data> params(message);
    params.Allocate();
    mojo::internal::Serialize<mojo::InterfaceRequestDataView<::blink::mojom::NavigationStateKeepAliveHandleInterfaceBase>>(
        in_receiver, &params->receiver, &params.message());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(!mojo::internal::IsHandleOrInterfaceValid(params->receiver),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE, "invalid receiver in LocalFrameHost.IssueKeepAliveHandle request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("IssueKeepAliveHandle");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::NotifyStorageAccessed(StorageTypeAccessed in_storageType, bool in_blocked)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrameHost::NotifyStorageAccessed", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("storageType"), in_storageType, "<value of type StorageTypeAccessed>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("blocked"), in_blocked, "<value of type bool>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kNotifyStorageAccessed), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_NotifyStorageAccessed_Params_Data> params(message);
    params.Allocate();
    mojo::internal::Serialize<::blink::mojom::StorageTypeAccessed>(in_storageType, &params->storageType);
    params->blocked = in_blocked;

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("NotifyStorageAccessed");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::RecordWindowProxyUsageMetrics(const ::blink::FrameToken& in_target_frame_token, WindowProxyAccessType in_access_type)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrameHost::RecordWindowProxyUsageMetrics", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("target_frame_token"), in_target_frame_token, "<value of type const ::blink::FrameToken&>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("access_type"), in_access_type, "<value of type WindowProxyAccessType>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kRecordWindowProxyUsageMetrics), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_RecordWindowProxyUsageMetrics_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<decltype(params->target_frame_token)> target_frame_token_fragment(params.message());
    target_frame_token_fragment.Claim(&params->target_frame_token);
    mojo::internal::Serialize<::blink::mojom::FrameTokenDataView>(in_target_frame_token, target_frame_token_fragment, true);
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->target_frame_token.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null target_frame_token in LocalFrameHost.RecordWindowProxyUsageMetrics request");
    mojo::internal::Serialize<::blink::mojom::WindowProxyAccessType>(in_access_type, &params->access_type);

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("RecordWindowProxyUsageMetrics");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::NotifyDocumentInteractive()
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT0("mojom", "Send blink::mojom::LocalFrameHost::NotifyDocumentInteractive");
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kNotifyDocumentInteractive), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_NotifyDocumentInteractive_Params_Data> params(message);
    params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("NotifyDocumentInteractive");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}
class LocalFrameHost_EnterFullscreen_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
public:
    static LocalFrameHost::EnterFullscreenCallback CreateCallback(::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
    {
        std::unique_ptr<LocalFrameHost_EnterFullscreen_ProxyToResponder> proxy(
            new LocalFrameHost_EnterFullscreen_ProxyToResponder(message, std::move(responder)));
        return base::BindOnce(&LocalFrameHost_EnterFullscreen_ProxyToResponder::Run, std::move(proxy));
    }

    ~LocalFrameHost_EnterFullscreen_ProxyToResponder()
    {
#if DCHECK_IS_ON()
        if (responder_) {
            // If we're being destroyed without being run, we want to ensure the
            // binding endpoint has been closed. This checks for that asynchronously.
            // We pass a bound generated callback to handle the response so that any
            // resulting DCHECK stack will have useful interface type information.
            // Instantiate a ScopedFizzleBlockShutdownTasks to allow this request to
            // fizzle if this happens after shutdown and the endpoint is bound to a
            // BLOCK_SHUTDOWN sequence.
            base::ThreadPoolInstance::ScopedFizzleBlockShutdownTasks fizzler;
            responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
        }
#endif
    }

private:
    LocalFrameHost_EnterFullscreen_ProxyToResponder(::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
        : ::mojo::internal::ProxyToResponder(message, std::move(responder))
    {
    }

#if DCHECK_IS_ON()
    static void OnIsConnectedComplete(bool connected)
    {
        DCHECK(!connected) << "LocalFrameHost::EnterFullscreenCallback was destroyed without "
                           << "first either being run or its corresponding binding being closed. "
                           << "It is an error to drop response callbacks which still correspond "
                           << "to an open interface pipe.";
    }
#endif

    void Run(bool in_granted);
};

bool LocalFrameHost_EnterFullscreen_ForwardToCallback::Accept(mojo::Message* message)
{
    DCHECK(message->is_serialized());
    internal::LocalFrameHost_EnterFullscreen_ResponseParams_Data* params
        = reinterpret_cast<internal::LocalFrameHost_EnterFullscreen_ResponseParams_Data*>(message->mutable_payload());

    // Validation for LocalFrameHost.0
    bool success = true;
    bool p_granted {};
    LocalFrameHost_EnterFullscreen_ResponseParamsDataView input_data_view(params, message);

    if (success)
        p_granted = input_data_view.granted();
    if (!success) {
        ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 0, true);
        return false;
    }
    if (!callback_.is_null())
        std::move(callback_).Run(std::move(p_granted));
    return true;
}

void LocalFrameHost_EnterFullscreen_ProxyToResponder::Run(bool in_granted)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send reply blink::mojom::LocalFrameHost::EnterFullscreen", "async_response_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("granted"), in_granted, "<value of type bool>");
    });
#endif

    const uint32_t kFlags = mojo::Message::kFlagIsResponse | ((is_sync_) ? mojo::Message::kFlagIsSync : 0) | ((true) ? 0 : mojo::Message::kFlagNoInterrupt)
        | ((false) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kEnterFullscreen), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_EnterFullscreen_ResponseParams_Data> params(message);
    params.Allocate();
    params->granted = in_granted;

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("EnterFullscreen");
#endif

    message.set_request_id(request_id_);
    message.set_trace_nonce(trace_nonce_);
    ::mojo::internal::SendMojoMessage(*responder_, message);
    // SendMojoMessage() fails silently if the responder connection is closed,
    // or if the message is malformed.
    //
    // TODO(darin): If Accept() returns false due to a malformed message, that
    // may be good reason to close the connection. However, we don't have a
    // way to do that from here. We should add a way.
    responder_ = nullptr;
}
class LocalFrameHost_RunModalAlertDialog_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
public:
    static LocalFrameHost::RunModalAlertDialogCallback CreateCallback(::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
    {
        std::unique_ptr<LocalFrameHost_RunModalAlertDialog_ProxyToResponder> proxy(
            new LocalFrameHost_RunModalAlertDialog_ProxyToResponder(message, std::move(responder)));
        return base::BindOnce(&LocalFrameHost_RunModalAlertDialog_ProxyToResponder::Run, std::move(proxy));
    }

    ~LocalFrameHost_RunModalAlertDialog_ProxyToResponder()
    {
#if DCHECK_IS_ON()
        if (responder_) {
            // If we're being destroyed without being run, we want to ensure the
            // binding endpoint has been closed. This checks for that asynchronously.
            // We pass a bound generated callback to handle the response so that any
            // resulting DCHECK stack will have useful interface type information.
            // Instantiate a ScopedFizzleBlockShutdownTasks to allow this request to
            // fizzle if this happens after shutdown and the endpoint is bound to a
            // BLOCK_SHUTDOWN sequence.
            base::ThreadPoolInstance::ScopedFizzleBlockShutdownTasks fizzler;
            responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
        }
#endif
    }

private:
    LocalFrameHost_RunModalAlertDialog_ProxyToResponder(::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
        : ::mojo::internal::ProxyToResponder(message, std::move(responder))
    {
    }

#if DCHECK_IS_ON()
    static void OnIsConnectedComplete(bool connected)
    {
        DCHECK(!connected) << "LocalFrameHost::RunModalAlertDialogCallback was destroyed without "
                           << "first either being run or its corresponding binding being closed. "
                           << "It is an error to drop response callbacks which still correspond "
                           << "to an open interface pipe.";
    }
#endif

    void Run();
};

bool LocalFrameHost_RunModalAlertDialog_ForwardToCallback::Accept(mojo::Message* message)
{
    DCHECK(message->is_serialized());
    internal::LocalFrameHost_RunModalAlertDialog_ResponseParams_Data* params
        = reinterpret_cast<internal::LocalFrameHost_RunModalAlertDialog_ResponseParams_Data*>(message->mutable_payload());

    // Validation for LocalFrameHost.39
    bool success = true;
    LocalFrameHost_RunModalAlertDialog_ResponseParamsDataView input_data_view(params, message);

    if (!success) {
        ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 39, true);
        return false;
    }
    if (!callback_.is_null())
        std::move(callback_).Run();
    return true;
}

void LocalFrameHost_RunModalAlertDialog_ProxyToResponder::Run()
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT0("mojom", "Send reply blink::mojom::LocalFrameHost::RunModalAlertDialog");
#endif

    const uint32_t kFlags = mojo::Message::kFlagIsResponse | ((is_sync_) ? mojo::Message::kFlagIsSync : 0) | ((true) ? 0 : mojo::Message::kFlagNoInterrupt)
        | ((false) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kRunModalAlertDialog), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_RunModalAlertDialog_ResponseParams_Data> params(message);
    params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("RunModalAlertDialog");
#endif

    message.set_request_id(request_id_);
    message.set_trace_nonce(trace_nonce_);
    ::mojo::internal::SendMojoMessage(*responder_, message);
    // SendMojoMessage() fails silently if the responder connection is closed,
    // or if the message is malformed.
    //
    // TODO(darin): If Accept() returns false due to a malformed message, that
    // may be good reason to close the connection. However, we don't have a
    // way to do that from here. We should add a way.
    responder_ = nullptr;
}
bool LocalFrameHost_RunModalAlertDialog_HandleSyncResponse::Accept(mojo::Message* message)
{
    DCHECK(message->is_serialized());
    internal::LocalFrameHost_RunModalAlertDialog_ResponseParams_Data* params
        = reinterpret_cast<internal::LocalFrameHost_RunModalAlertDialog_ResponseParams_Data*>(message->mutable_payload());

    // Validation for LocalFrameHost.39
    bool success = true;
    LocalFrameHost_RunModalAlertDialog_ResponseParamsDataView input_data_view(params, message);

    if (!success) {
        ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 39, true);
        return false;
    }
    *result_ = true;
    return true;
}
class LocalFrameHost_RunModalConfirmDialog_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
public:
    static LocalFrameHost::RunModalConfirmDialogCallback CreateCallback(::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
    {
        std::unique_ptr<LocalFrameHost_RunModalConfirmDialog_ProxyToResponder> proxy(
            new LocalFrameHost_RunModalConfirmDialog_ProxyToResponder(message, std::move(responder)));
        return base::BindOnce(&LocalFrameHost_RunModalConfirmDialog_ProxyToResponder::Run, std::move(proxy));
    }

    ~LocalFrameHost_RunModalConfirmDialog_ProxyToResponder()
    {
#if DCHECK_IS_ON()
        if (responder_) {
            // If we're being destroyed without being run, we want to ensure the
            // binding endpoint has been closed. This checks for that asynchronously.
            // We pass a bound generated callback to handle the response so that any
            // resulting DCHECK stack will have useful interface type information.
            // Instantiate a ScopedFizzleBlockShutdownTasks to allow this request to
            // fizzle if this happens after shutdown and the endpoint is bound to a
            // BLOCK_SHUTDOWN sequence.
            base::ThreadPoolInstance::ScopedFizzleBlockShutdownTasks fizzler;
            responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
        }
#endif
    }

private:
    LocalFrameHost_RunModalConfirmDialog_ProxyToResponder(::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
        : ::mojo::internal::ProxyToResponder(message, std::move(responder))
    {
    }

#if DCHECK_IS_ON()
    static void OnIsConnectedComplete(bool connected)
    {
        DCHECK(!connected) << "LocalFrameHost::RunModalConfirmDialogCallback was destroyed without "
                           << "first either being run or its corresponding binding being closed. "
                           << "It is an error to drop response callbacks which still correspond "
                           << "to an open interface pipe.";
    }
#endif

    void Run(bool in_success);
};

bool LocalFrameHost_RunModalConfirmDialog_ForwardToCallback::Accept(mojo::Message* message)
{
    DCHECK(message->is_serialized());
    internal::LocalFrameHost_RunModalConfirmDialog_ResponseParams_Data* params
        = reinterpret_cast<internal::LocalFrameHost_RunModalConfirmDialog_ResponseParams_Data*>(message->mutable_payload());

    // Validation for LocalFrameHost.40
    bool success = true;
    bool p_success {};
    LocalFrameHost_RunModalConfirmDialog_ResponseParamsDataView input_data_view(params, message);

    if (success)
        p_success = input_data_view.success();
    if (!success) {
        ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 40, true);
        return false;
    }
    if (!callback_.is_null())
        std::move(callback_).Run(std::move(p_success));
    return true;
}

void LocalFrameHost_RunModalConfirmDialog_ProxyToResponder::Run(bool in_success)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send reply blink::mojom::LocalFrameHost::RunModalConfirmDialog", "async_response_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("success"), in_success, "<value of type bool>");
    });
#endif

    const uint32_t kFlags = mojo::Message::kFlagIsResponse | ((is_sync_) ? mojo::Message::kFlagIsSync : 0) | ((true) ? 0 : mojo::Message::kFlagNoInterrupt)
        | ((false) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kRunModalConfirmDialog), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_RunModalConfirmDialog_ResponseParams_Data> params(message);
    params.Allocate();
    params->success = in_success;

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("RunModalConfirmDialog");
#endif

    message.set_request_id(request_id_);
    message.set_trace_nonce(trace_nonce_);
    ::mojo::internal::SendMojoMessage(*responder_, message);
    // SendMojoMessage() fails silently if the responder connection is closed,
    // or if the message is malformed.
    //
    // TODO(darin): If Accept() returns false due to a malformed message, that
    // may be good reason to close the connection. However, we don't have a
    // way to do that from here. We should add a way.
    responder_ = nullptr;
}
bool LocalFrameHost_RunModalConfirmDialog_HandleSyncResponse::Accept(mojo::Message* message)
{
    DCHECK(message->is_serialized());
    internal::LocalFrameHost_RunModalConfirmDialog_ResponseParams_Data* params
        = reinterpret_cast<internal::LocalFrameHost_RunModalConfirmDialog_ResponseParams_Data*>(message->mutable_payload());

    // Validation for LocalFrameHost.40
    bool success = true;
    bool p_success {};
    LocalFrameHost_RunModalConfirmDialog_ResponseParamsDataView input_data_view(params, message);

    if (success)
        p_success = input_data_view.success();
    if (!success) {
        ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 40, true);
        return false;
    }
    *out_success_ = std::move(p_success);
    *result_ = true;
    return true;
}
class LocalFrameHost_RunModalPromptDialog_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
public:
    static LocalFrameHost::RunModalPromptDialogCallback CreateCallback(::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
    {
        std::unique_ptr<LocalFrameHost_RunModalPromptDialog_ProxyToResponder> proxy(
            new LocalFrameHost_RunModalPromptDialog_ProxyToResponder(message, std::move(responder)));
        return base::BindOnce(&LocalFrameHost_RunModalPromptDialog_ProxyToResponder::Run, std::move(proxy));
    }

    ~LocalFrameHost_RunModalPromptDialog_ProxyToResponder()
    {
#if DCHECK_IS_ON()
        if (responder_) {
            // If we're being destroyed without being run, we want to ensure the
            // binding endpoint has been closed. This checks for that asynchronously.
            // We pass a bound generated callback to handle the response so that any
            // resulting DCHECK stack will have useful interface type information.
            // Instantiate a ScopedFizzleBlockShutdownTasks to allow this request to
            // fizzle if this happens after shutdown and the endpoint is bound to a
            // BLOCK_SHUTDOWN sequence.
            base::ThreadPoolInstance::ScopedFizzleBlockShutdownTasks fizzler;
            responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
        }
#endif
    }

private:
    LocalFrameHost_RunModalPromptDialog_ProxyToResponder(::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
        : ::mojo::internal::ProxyToResponder(message, std::move(responder))
    {
    }

#if DCHECK_IS_ON()
    static void OnIsConnectedComplete(bool connected)
    {
        DCHECK(!connected) << "LocalFrameHost::RunModalPromptDialogCallback was destroyed without "
                           << "first either being run or its corresponding binding being closed. "
                           << "It is an error to drop response callbacks which still correspond "
                           << "to an open interface pipe.";
    }
#endif

    void Run(bool in_success, const ::WTF::String& in_result);
};

bool LocalFrameHost_RunModalPromptDialog_ForwardToCallback::Accept(mojo::Message* message)
{
    DCHECK(message->is_serialized());
    internal::LocalFrameHost_RunModalPromptDialog_ResponseParams_Data* params
        = reinterpret_cast<internal::LocalFrameHost_RunModalPromptDialog_ResponseParams_Data*>(message->mutable_payload());

    // Validation for LocalFrameHost.41
    bool success = true;
    bool p_success {};
    ::WTF::String p_result {};
    LocalFrameHost_RunModalPromptDialog_ResponseParamsDataView input_data_view(params, message);

    if (success)
        p_success = input_data_view.success();
    if (success && !input_data_view.ReadResult(&p_result))
        success = false;
    if (!success) {
        ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 41, true);
        return false;
    }
    if (!callback_.is_null())
        std::move(callback_).Run(std::move(p_success), std::move(p_result));
    return true;
}

void LocalFrameHost_RunModalPromptDialog_ProxyToResponder::Run(bool in_success, const ::WTF::String& in_result)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send reply blink::mojom::LocalFrameHost::RunModalPromptDialog", "async_response_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("success"), in_success, "<value of type bool>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("result"), in_result, "<value of type const ::WTF::String&>");
    });
#endif

    const uint32_t kFlags = mojo::Message::kFlagIsResponse | ((is_sync_) ? mojo::Message::kFlagIsSync : 0) | ((true) ? 0 : mojo::Message::kFlagNoInterrupt)
        | ((false) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kRunModalPromptDialog), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_RunModalPromptDialog_ResponseParams_Data> params(message);
    params.Allocate();
    params->success = in_success;
    mojo::internal::MessageFragment<typename decltype(params->result)::BaseType> result_fragment(params.message());
    mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(in_result, result_fragment);
    params->result.Set(result_fragment.is_null() ? nullptr : result_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->result.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null result in ");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("RunModalPromptDialog");
#endif

    message.set_request_id(request_id_);
    message.set_trace_nonce(trace_nonce_);
    ::mojo::internal::SendMojoMessage(*responder_, message);
    // SendMojoMessage() fails silently if the responder connection is closed,
    // or if the message is malformed.
    //
    // TODO(darin): If Accept() returns false due to a malformed message, that
    // may be good reason to close the connection. However, we don't have a
    // way to do that from here. We should add a way.
    responder_ = nullptr;
}
bool LocalFrameHost_RunModalPromptDialog_HandleSyncResponse::Accept(mojo::Message* message)
{
    DCHECK(message->is_serialized());
    internal::LocalFrameHost_RunModalPromptDialog_ResponseParams_Data* params
        = reinterpret_cast<internal::LocalFrameHost_RunModalPromptDialog_ResponseParams_Data*>(message->mutable_payload());

    // Validation for LocalFrameHost.41
    bool success = true;
    bool p_success {};
    ::WTF::String p_result {};
    LocalFrameHost_RunModalPromptDialog_ResponseParamsDataView input_data_view(params, message);

    if (success)
        p_success = input_data_view.success();
    if (success && !input_data_view.ReadResult(&p_result))
        success = false;
    if (!success) {
        ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 41, true);
        return false;
    }
    *out_success_ = std::move(p_success);
    *out_result_ = std::move(p_result);
    *result_ = true;
    return true;
}
class LocalFrameHost_RunBeforeUnloadConfirm_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
public:
    static LocalFrameHost::RunBeforeUnloadConfirmCallback CreateCallback(::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
    {
        std::unique_ptr<LocalFrameHost_RunBeforeUnloadConfirm_ProxyToResponder> proxy(
            new LocalFrameHost_RunBeforeUnloadConfirm_ProxyToResponder(message, std::move(responder)));
        return base::BindOnce(&LocalFrameHost_RunBeforeUnloadConfirm_ProxyToResponder::Run, std::move(proxy));
    }

    ~LocalFrameHost_RunBeforeUnloadConfirm_ProxyToResponder()
    {
#if DCHECK_IS_ON()
        if (responder_) {
            // If we're being destroyed without being run, we want to ensure the
            // binding endpoint has been closed. This checks for that asynchronously.
            // We pass a bound generated callback to handle the response so that any
            // resulting DCHECK stack will have useful interface type information.
            // Instantiate a ScopedFizzleBlockShutdownTasks to allow this request to
            // fizzle if this happens after shutdown and the endpoint is bound to a
            // BLOCK_SHUTDOWN sequence.
            base::ThreadPoolInstance::ScopedFizzleBlockShutdownTasks fizzler;
            responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
        }
#endif
    }

private:
    LocalFrameHost_RunBeforeUnloadConfirm_ProxyToResponder(::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
        : ::mojo::internal::ProxyToResponder(message, std::move(responder))
    {
    }

#if DCHECK_IS_ON()
    static void OnIsConnectedComplete(bool connected)
    {
        DCHECK(!connected) << "LocalFrameHost::RunBeforeUnloadConfirmCallback was destroyed without "
                           << "first either being run or its corresponding binding being closed. "
                           << "It is an error to drop response callbacks which still correspond "
                           << "to an open interface pipe.";
    }
#endif

    void Run(bool in_success);
};

bool LocalFrameHost_RunBeforeUnloadConfirm_ForwardToCallback::Accept(mojo::Message* message)
{
    DCHECK(message->is_serialized());
    internal::LocalFrameHost_RunBeforeUnloadConfirm_ResponseParams_Data* params
        = reinterpret_cast<internal::LocalFrameHost_RunBeforeUnloadConfirm_ResponseParams_Data*>(message->mutable_payload());

    // Validation for LocalFrameHost.42
    bool success = true;
    bool p_success {};
    LocalFrameHost_RunBeforeUnloadConfirm_ResponseParamsDataView input_data_view(params, message);

    if (success)
        p_success = input_data_view.success();
    if (!success) {
        ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 42, true);
        return false;
    }
    if (!callback_.is_null())
        std::move(callback_).Run(std::move(p_success));
    return true;
}

void LocalFrameHost_RunBeforeUnloadConfirm_ProxyToResponder::Run(bool in_success)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send reply blink::mojom::LocalFrameHost::RunBeforeUnloadConfirm", "async_response_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("success"), in_success, "<value of type bool>");
    });
#endif

    const uint32_t kFlags = mojo::Message::kFlagIsResponse | ((is_sync_) ? mojo::Message::kFlagIsSync : 0) | ((true) ? 0 : mojo::Message::kFlagNoInterrupt)
        | ((false) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kRunBeforeUnloadConfirm), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_RunBeforeUnloadConfirm_ResponseParams_Data> params(message);
    params.Allocate();
    params->success = in_success;

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("RunBeforeUnloadConfirm");
#endif

    message.set_request_id(request_id_);
    message.set_trace_nonce(trace_nonce_);
    ::mojo::internal::SendMojoMessage(*responder_, message);
    // SendMojoMessage() fails silently if the responder connection is closed,
    // or if the message is malformed.
    //
    // TODO(darin): If Accept() returns false due to a malformed message, that
    // may be good reason to close the connection. However, we don't have a
    // way to do that from here. We should add a way.
    responder_ = nullptr;
}
bool LocalFrameHost_RunBeforeUnloadConfirm_HandleSyncResponse::Accept(mojo::Message* message)
{
    DCHECK(message->is_serialized());
    internal::LocalFrameHost_RunBeforeUnloadConfirm_ResponseParams_Data* params
        = reinterpret_cast<internal::LocalFrameHost_RunBeforeUnloadConfirm_ResponseParams_Data*>(message->mutable_payload());

    // Validation for LocalFrameHost.42
    bool success = true;
    bool p_success {};
    LocalFrameHost_RunBeforeUnloadConfirm_ResponseParamsDataView input_data_view(params, message);

    if (success)
        p_success = input_data_view.success();
    if (!success) {
        ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 42, true);
        return false;
    }
    *out_success_ = std::move(p_success);
    *result_ = true;
    return true;
}
class LocalFrameHost_DisableUntrustedNetworkInFencedFrame_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
public:
    static LocalFrameHost::DisableUntrustedNetworkInFencedFrameCallback CreateCallback(
        ::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
    {
        std::unique_ptr<LocalFrameHost_DisableUntrustedNetworkInFencedFrame_ProxyToResponder> proxy(
            new LocalFrameHost_DisableUntrustedNetworkInFencedFrame_ProxyToResponder(message, std::move(responder)));
        return base::BindOnce(&LocalFrameHost_DisableUntrustedNetworkInFencedFrame_ProxyToResponder::Run, std::move(proxy));
    }

    ~LocalFrameHost_DisableUntrustedNetworkInFencedFrame_ProxyToResponder()
    {
#if DCHECK_IS_ON()
        if (responder_) {
            // If we're being destroyed without being run, we want to ensure the
            // binding endpoint has been closed. This checks for that asynchronously.
            // We pass a bound generated callback to handle the response so that any
            // resulting DCHECK stack will have useful interface type information.
            // Instantiate a ScopedFizzleBlockShutdownTasks to allow this request to
            // fizzle if this happens after shutdown and the endpoint is bound to a
            // BLOCK_SHUTDOWN sequence.
            base::ThreadPoolInstance::ScopedFizzleBlockShutdownTasks fizzler;
            responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
        }
#endif
    }

private:
    LocalFrameHost_DisableUntrustedNetworkInFencedFrame_ProxyToResponder(::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
        : ::mojo::internal::ProxyToResponder(message, std::move(responder))
    {
    }

#if DCHECK_IS_ON()
    static void OnIsConnectedComplete(bool connected)
    {
        DCHECK(!connected) << "LocalFrameHost::DisableUntrustedNetworkInFencedFrameCallback was destroyed without "
                           << "first either being run or its corresponding binding being closed. "
                           << "It is an error to drop response callbacks which still correspond "
                           << "to an open interface pipe.";
    }
#endif

    void Run();
};

bool LocalFrameHost_DisableUntrustedNetworkInFencedFrame_ForwardToCallback::Accept(mojo::Message* message)
{
    DCHECK(message->is_serialized());
    internal::LocalFrameHost_DisableUntrustedNetworkInFencedFrame_ResponseParams_Data* params
        = reinterpret_cast<internal::LocalFrameHost_DisableUntrustedNetworkInFencedFrame_ResponseParams_Data*>(message->mutable_payload());

    // Validation for LocalFrameHost.66
    bool success = true;
    LocalFrameHost_DisableUntrustedNetworkInFencedFrame_ResponseParamsDataView input_data_view(params, message);

    if (!success) {
        ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 66, true);
        return false;
    }
    if (!callback_.is_null())
        std::move(callback_).Run();
    return true;
}

void LocalFrameHost_DisableUntrustedNetworkInFencedFrame_ProxyToResponder::Run()
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT0("mojom", "Send reply blink::mojom::LocalFrameHost::DisableUntrustedNetworkInFencedFrame");
#endif

    const uint32_t kFlags = mojo::Message::kFlagIsResponse | ((is_sync_) ? mojo::Message::kFlagIsSync : 0) | ((true) ? 0 : mojo::Message::kFlagNoInterrupt)
        | ((false) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kDisableUntrustedNetworkInFencedFrame), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_DisableUntrustedNetworkInFencedFrame_ResponseParams_Data> params(message);
    params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("DisableUntrustedNetworkInFencedFrame");
#endif

    message.set_request_id(request_id_);
    message.set_trace_nonce(trace_nonce_);
    ::mojo::internal::SendMojoMessage(*responder_, message);
    // SendMojoMessage() fails silently if the responder connection is closed,
    // or if the message is malformed.
    //
    // TODO(darin): If Accept() returns false due to a malformed message, that
    // may be good reason to close the connection. However, we don't have a
    // way to do that from here. We should add a way.
    responder_ = nullptr;
}
class LocalFrameHost_ExemptUrlFromNetworkRevocationForTesting_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
public:
    static LocalFrameHost::ExemptUrlFromNetworkRevocationForTestingCallback CreateCallback(
        ::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
    {
        std::unique_ptr<LocalFrameHost_ExemptUrlFromNetworkRevocationForTesting_ProxyToResponder> proxy(
            new LocalFrameHost_ExemptUrlFromNetworkRevocationForTesting_ProxyToResponder(message, std::move(responder)));
        return base::BindOnce(&LocalFrameHost_ExemptUrlFromNetworkRevocationForTesting_ProxyToResponder::Run, std::move(proxy));
    }

    ~LocalFrameHost_ExemptUrlFromNetworkRevocationForTesting_ProxyToResponder()
    {
#if DCHECK_IS_ON()
        if (responder_) {
            // If we're being destroyed without being run, we want to ensure the
            // binding endpoint has been closed. This checks for that asynchronously.
            // We pass a bound generated callback to handle the response so that any
            // resulting DCHECK stack will have useful interface type information.
            // Instantiate a ScopedFizzleBlockShutdownTasks to allow this request to
            // fizzle if this happens after shutdown and the endpoint is bound to a
            // BLOCK_SHUTDOWN sequence.
            base::ThreadPoolInstance::ScopedFizzleBlockShutdownTasks fizzler;
            responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
        }
#endif
    }

private:
    LocalFrameHost_ExemptUrlFromNetworkRevocationForTesting_ProxyToResponder(
        ::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
        : ::mojo::internal::ProxyToResponder(message, std::move(responder))
    {
    }

#if DCHECK_IS_ON()
    static void OnIsConnectedComplete(bool connected)
    {
        DCHECK(!connected) << "LocalFrameHost::ExemptUrlFromNetworkRevocationForTestingCallback was destroyed without "
                           << "first either being run or its corresponding binding being closed. "
                           << "It is an error to drop response callbacks which still correspond "
                           << "to an open interface pipe.";
    }
#endif

    void Run();
};

bool LocalFrameHost_ExemptUrlFromNetworkRevocationForTesting_ForwardToCallback::Accept(mojo::Message* message)
{
    DCHECK(message->is_serialized());
    internal::LocalFrameHost_ExemptUrlFromNetworkRevocationForTesting_ResponseParams_Data* params
        = reinterpret_cast<internal::LocalFrameHost_ExemptUrlFromNetworkRevocationForTesting_ResponseParams_Data*>(message->mutable_payload());

    // Validation for LocalFrameHost.67
    bool success = true;
    LocalFrameHost_ExemptUrlFromNetworkRevocationForTesting_ResponseParamsDataView input_data_view(params, message);

    if (!success) {
        ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 67, true);
        return false;
    }
    if (!callback_.is_null())
        std::move(callback_).Run();
    return true;
}

void LocalFrameHost_ExemptUrlFromNetworkRevocationForTesting_ProxyToResponder::Run()
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT0("mojom", "Send reply blink::mojom::LocalFrameHost::ExemptUrlFromNetworkRevocationForTesting");
#endif

    const uint32_t kFlags = mojo::Message::kFlagIsResponse | ((is_sync_) ? mojo::Message::kFlagIsSync : 0) | ((true) ? 0 : mojo::Message::kFlagNoInterrupt)
        | ((false) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrameHost::kExemptUrlFromNetworkRevocationForTesting), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameHost_ExemptUrlFromNetworkRevocationForTesting_ResponseParams_Data> params(message);
    params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrameHost::Name_);
    message.set_method_name("ExemptUrlFromNetworkRevocationForTesting");
#endif

    message.set_request_id(request_id_);
    message.set_trace_nonce(trace_nonce_);
    ::mojo::internal::SendMojoMessage(*responder_, message);
    // SendMojoMessage() fails silently if the responder connection is closed,
    // or if the message is malformed.
    //
    // TODO(darin): If Accept() returns false due to a malformed message, that
    // may be good reason to close the connection. However, we don't have a
    // way to do that from here. We should add a way.
    responder_ = nullptr;
}

// static
bool LocalFrameHostStubDispatch::Accept(LocalFrameHost* impl, mojo::Message* message)
{
    switch (static_cast<messages::LocalFrameHost>(message->header()->name)) {
    case messages::LocalFrameHost::kEnterFullscreen: {
        break;
    }
    case messages::LocalFrameHost::kExitFullscreen: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_ExitFullscreen_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_ExitFullscreen_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.1
        bool success = true;
        LocalFrameHost_ExitFullscreen_ParamsDataView input_data_view(params, message);

        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 1, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->ExitFullscreen();
        return true;
    }
    case messages::LocalFrameHost::kFullscreenStateChanged: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_FullscreenStateChanged_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_FullscreenStateChanged_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.2
        bool success = true;
        bool p_is_fullscreen {};
        ::blink::mojom::blink::FullscreenOptionsPtr p_options {};
        LocalFrameHost_FullscreenStateChanged_ParamsDataView input_data_view(params, message);

        if (success)
            p_is_fullscreen = input_data_view.is_fullscreen();
        if (success && !input_data_view.ReadOptions(&p_options))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 2, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->FullscreenStateChanged(std::move(p_is_fullscreen), std::move(p_options));
        return true;
    }
    case messages::LocalFrameHost::kRegisterProtocolHandler: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_RegisterProtocolHandler_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_RegisterProtocolHandler_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.3
        bool success = true;
        WTF::String p_scheme {};
        ::blink::KURL p_url {};
        bool p_user_gesture {};
        LocalFrameHost_RegisterProtocolHandler_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadScheme(&p_scheme))
            success = false;
        if (success && !input_data_view.ReadUrl(&p_url))
            success = false;
        if (success)
            p_user_gesture = input_data_view.user_gesture();
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 3, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->RegisterProtocolHandler(std::move(p_scheme), std::move(p_url), std::move(p_user_gesture));
        return true;
    }
    case messages::LocalFrameHost::kUnregisterProtocolHandler: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_UnregisterProtocolHandler_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_UnregisterProtocolHandler_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.4
        bool success = true;
        WTF::String p_scheme {};
        ::blink::KURL p_url {};
        bool p_user_gesture {};
        LocalFrameHost_UnregisterProtocolHandler_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadScheme(&p_scheme))
            success = false;
        if (success && !input_data_view.ReadUrl(&p_url))
            success = false;
        if (success)
            p_user_gesture = input_data_view.user_gesture();
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 4, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->UnregisterProtocolHandler(std::move(p_scheme), std::move(p_url), std::move(p_user_gesture));
        return true;
    }
    case messages::LocalFrameHost::kDidDisplayInsecureContent: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_DidDisplayInsecureContent_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_DidDisplayInsecureContent_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.5
        bool success = true;
        LocalFrameHost_DidDisplayInsecureContent_ParamsDataView input_data_view(params, message);

        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 5, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->DidDisplayInsecureContent();
        return true;
    }
    case messages::LocalFrameHost::kDidContainInsecureFormAction: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_DidContainInsecureFormAction_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_DidContainInsecureFormAction_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.6
        bool success = true;
        LocalFrameHost_DidContainInsecureFormAction_ParamsDataView input_data_view(params, message);

        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 6, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->DidContainInsecureFormAction();
        return true;
    }
    case messages::LocalFrameHost::kMainDocumentElementAvailable: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_MainDocumentElementAvailable_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_MainDocumentElementAvailable_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.7
        bool success = true;
        bool p_uses_temporary_zoom_level {};
        LocalFrameHost_MainDocumentElementAvailable_ParamsDataView input_data_view(params, message);

        if (success)
            p_uses_temporary_zoom_level = input_data_view.uses_temporary_zoom_level();
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 7, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->MainDocumentElementAvailable(std::move(p_uses_temporary_zoom_level));
        return true;
    }
    case messages::LocalFrameHost::kSetNeedsOcclusionTracking: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_SetNeedsOcclusionTracking_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_SetNeedsOcclusionTracking_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.8
        bool success = true;
        bool p_needs_tracking {};
        LocalFrameHost_SetNeedsOcclusionTracking_ParamsDataView input_data_view(params, message);

        if (success)
            p_needs_tracking = input_data_view.needs_tracking();
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 8, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->SetNeedsOcclusionTracking(std::move(p_needs_tracking));
        return true;
    }
    case messages::LocalFrameHost::kSetVirtualKeyboardMode: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_SetVirtualKeyboardMode_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_SetVirtualKeyboardMode_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.9
        bool success = true;
        ::ui::mojom::blink::VirtualKeyboardMode p_type {};
        LocalFrameHost_SetVirtualKeyboardMode_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadType(&p_type))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 9, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->SetVirtualKeyboardMode(std::move(p_type));
        return true;
    }
    case messages::LocalFrameHost::kVisibilityChanged: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_VisibilityChanged_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_VisibilityChanged_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.10
        bool success = true;
        ::blink::mojom::blink::FrameVisibility p_visibility {};
        LocalFrameHost_VisibilityChanged_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadVisibility(&p_visibility))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 10, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->VisibilityChanged(std::move(p_visibility));
        return true;
    }
    case messages::LocalFrameHost::kDidChangeThemeColor: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_DidChangeThemeColor_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_DidChangeThemeColor_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.11
        bool success = true;
        std::optional<::SkColor> p_theme_color {};
        LocalFrameHost_DidChangeThemeColor_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadThemeColor(&p_theme_color))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 11, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->DidChangeThemeColor(std::move(p_theme_color));
        return true;
    }
    case messages::LocalFrameHost::kDidChangeBackgroundColor: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_DidChangeBackgroundColor_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_DidChangeBackgroundColor_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.12
        bool success = true;
        ::SkColor4f p_background_color {};
        bool p_color_adjust {};
        LocalFrameHost_DidChangeBackgroundColor_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadBackgroundColor(&p_background_color))
            success = false;
        if (success)
            p_color_adjust = input_data_view.color_adjust();
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 12, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->DidChangeBackgroundColor(std::move(p_background_color), std::move(p_color_adjust));
        return true;
    }
    case messages::LocalFrameHost::kDidFailLoadWithError: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_DidFailLoadWithError_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_DidFailLoadWithError_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.13
        bool success = true;
        ::blink::KURL p_url {};
        int32_t p_error_code {};
        LocalFrameHost_DidFailLoadWithError_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadUrl(&p_url))
            success = false;
        if (success)
            p_error_code = input_data_view.error_code();
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 13, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->DidFailLoadWithError(std::move(p_url), std::move(p_error_code));
        return true;
    }
    case messages::LocalFrameHost::kDidFocusFrame: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_DidFocusFrame_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_DidFocusFrame_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.14
        bool success = true;
        LocalFrameHost_DidFocusFrame_ParamsDataView input_data_view(params, message);

        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 14, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->DidFocusFrame();
        return true;
    }
    case messages::LocalFrameHost::kDidCallFocus: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_DidCallFocus_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_DidCallFocus_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.15
        bool success = true;
        LocalFrameHost_DidCallFocus_ParamsDataView input_data_view(params, message);

        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 15, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->DidCallFocus();
        return true;
    }
    case messages::LocalFrameHost::kEnforceInsecureRequestPolicy: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_EnforceInsecureRequestPolicy_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_EnforceInsecureRequestPolicy_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.16
        bool success = true;
        ::blink::mojom::blink::InsecureRequestPolicy p_policy_bitmap {};
        LocalFrameHost_EnforceInsecureRequestPolicy_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadPolicyBitmap(&p_policy_bitmap))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 16, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->EnforceInsecureRequestPolicy(std::move(p_policy_bitmap));
        return true;
    }
    case messages::LocalFrameHost::kEnforceInsecureNavigationsSet: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_EnforceInsecureNavigationsSet_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_EnforceInsecureNavigationsSet_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.17
        bool success = true;
        WTF::Vector<uint32_t> p_set {};
        LocalFrameHost_EnforceInsecureNavigationsSet_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadSet(&p_set))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 17, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->EnforceInsecureNavigationsSet(std::move(p_set));
        return true;
    }
    case messages::LocalFrameHost::kSuddenTerminationDisablerChanged: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_SuddenTerminationDisablerChanged_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_SuddenTerminationDisablerChanged_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.18
        bool success = true;
        bool p_present {};
        ::blink::mojom::blink::SuddenTerminationDisablerType p_disabler_type {};
        LocalFrameHost_SuddenTerminationDisablerChanged_ParamsDataView input_data_view(params, message);

        if (success)
            p_present = input_data_view.present();
        if (success && !input_data_view.ReadDisablerType(&p_disabler_type))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 18, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->SuddenTerminationDisablerChanged(std::move(p_present), std::move(p_disabler_type));
        return true;
    }
    case messages::LocalFrameHost::kHadStickyUserActivationBeforeNavigationChanged: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_HadStickyUserActivationBeforeNavigationChanged_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_HadStickyUserActivationBeforeNavigationChanged_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.19
        bool success = true;
        bool p_has_gesture {};
        LocalFrameHost_HadStickyUserActivationBeforeNavigationChanged_ParamsDataView input_data_view(params, message);

        if (success)
            p_has_gesture = input_data_view.has_gesture();
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 19, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->HadStickyUserActivationBeforeNavigationChanged(std::move(p_has_gesture));
        return true;
    }
    case messages::LocalFrameHost::kScrollRectToVisibleInParentFrame: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_ScrollRectToVisibleInParentFrame_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_ScrollRectToVisibleInParentFrame_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.20
        bool success = true;
        ::gfx::RectF p_rect_to_scroll {};
        ::blink::mojom::blink::ScrollIntoViewParamsPtr p_params {};
        LocalFrameHost_ScrollRectToVisibleInParentFrame_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadRectToScroll(&p_rect_to_scroll))
            success = false;
        if (success && !input_data_view.ReadParams(&p_params))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 20, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->ScrollRectToVisibleInParentFrame(std::move(p_rect_to_scroll), std::move(p_params));
        return true;
    }
    case messages::LocalFrameHost::kBubbleLogicalScrollInParentFrame: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_BubbleLogicalScrollInParentFrame_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_BubbleLogicalScrollInParentFrame_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.21
        bool success = true;
        ::blink::mojom::blink::ScrollDirection p_direction {};
        ::ui::ScrollGranularity p_granularity {};
        LocalFrameHost_BubbleLogicalScrollInParentFrame_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadDirection(&p_direction))
            success = false;
        if (success && !input_data_view.ReadGranularity(&p_granularity))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 21, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->BubbleLogicalScrollInParentFrame(std::move(p_direction), std::move(p_granularity));
        return true;
    }
    case messages::LocalFrameHost::kStartLoadingForAsyncNavigationApiCommit: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_StartLoadingForAsyncNavigationApiCommit_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_StartLoadingForAsyncNavigationApiCommit_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.22
        bool success = true;
        LocalFrameHost_StartLoadingForAsyncNavigationApiCommit_ParamsDataView input_data_view(params, message);

        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 22, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->StartLoadingForAsyncNavigationApiCommit();
        return true;
    }
    case messages::LocalFrameHost::kDidBlockNavigation: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_DidBlockNavigation_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_DidBlockNavigation_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.23
        bool success = true;
        ::blink::KURL p_blocked_url {};
        ::blink::KURL p_initiator_url {};
        ::blink::mojom::blink::NavigationBlockedReason p_reason {};
        LocalFrameHost_DidBlockNavigation_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadBlockedUrl(&p_blocked_url))
            success = false;
        if (success && !input_data_view.ReadInitiatorUrl(&p_initiator_url))
            success = false;
        if (success && !input_data_view.ReadReason(&p_reason))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 23, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->DidBlockNavigation(std::move(p_blocked_url), std::move(p_initiator_url), std::move(p_reason));
        return true;
    }
    case messages::LocalFrameHost::kDidChangeLoadProgress: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_DidChangeLoadProgress_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_DidChangeLoadProgress_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.24
        bool success = true;
        double p_load_progress {};
        LocalFrameHost_DidChangeLoadProgress_ParamsDataView input_data_view(params, message);

        if (success)
            p_load_progress = input_data_view.load_progress();
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 24, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->DidChangeLoadProgress(std::move(p_load_progress));
        return true;
    }
    case messages::LocalFrameHost::kDidFinishLoad: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_DidFinishLoad_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_DidFinishLoad_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.25
        bool success = true;
        ::blink::KURL p_validated_url {};
        LocalFrameHost_DidFinishLoad_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadValidatedUrl(&p_validated_url))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 25, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->DidFinishLoad(std::move(p_validated_url));
        return true;
    }
    case messages::LocalFrameHost::kDispatchLoad: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_DispatchLoad_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_DispatchLoad_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.26
        bool success = true;
        LocalFrameHost_DispatchLoad_ParamsDataView input_data_view(params, message);

        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 26, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->DispatchLoad();
        return true;
    }
    case messages::LocalFrameHost::kGoToEntryAtOffset: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_GoToEntryAtOffset_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_GoToEntryAtOffset_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.27
        bool success = true;
        int32_t p_offset {};
        bool p_has_user_gesture {};
        std::optional<::blink::scheduler::TaskAttributionId> p_soft_navigation_heuristics_task_id {};
        LocalFrameHost_GoToEntryAtOffset_ParamsDataView input_data_view(params, message);

        if (success)
            p_offset = input_data_view.offset();
        if (success)
            p_has_user_gesture = input_data_view.has_user_gesture();
        if (success && !input_data_view.ReadSoftNavigationHeuristicsTaskId(&p_soft_navigation_heuristics_task_id))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 27, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->GoToEntryAtOffset(std::move(p_offset), std::move(p_has_user_gesture), std::move(p_soft_navigation_heuristics_task_id));
        return true;
    }
    case messages::LocalFrameHost::kNavigateToNavigationApiKey: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_NavigateToNavigationApiKey_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_NavigateToNavigationApiKey_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.28
        bool success = true;
        WTF::String p_key {};
        bool p_has_user_gesture {};
        std::optional<::blink::scheduler::TaskAttributionId> p_soft_navigation_heuristics_task_id {};
        LocalFrameHost_NavigateToNavigationApiKey_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadKey(&p_key))
            success = false;
        if (success)
            p_has_user_gesture = input_data_view.has_user_gesture();
        if (success && !input_data_view.ReadSoftNavigationHeuristicsTaskId(&p_soft_navigation_heuristics_task_id))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 28, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->NavigateToNavigationApiKey(std::move(p_key), std::move(p_has_user_gesture), std::move(p_soft_navigation_heuristics_task_id));
        return true;
    }
    case messages::LocalFrameHost::kNavigateEventHandlerPresenceChanged: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_NavigateEventHandlerPresenceChanged_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_NavigateEventHandlerPresenceChanged_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.29
        bool success = true;
        bool p_present {};
        LocalFrameHost_NavigateEventHandlerPresenceChanged_ParamsDataView input_data_view(params, message);

        if (success)
            p_present = input_data_view.present();
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 29, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->NavigateEventHandlerPresenceChanged(std::move(p_present));
        return true;
    }
    case messages::LocalFrameHost::kUpdateTitle: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_UpdateTitle_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_UpdateTitle_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.30
        bool success = true;
        ::WTF::String p_title {};
        ::base::i18n::TextDirection p_title_direction {};
        LocalFrameHost_UpdateTitle_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadTitle(&p_title))
            success = false;
        if (success && !input_data_view.ReadTitleDirection(&p_title_direction))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 30, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->UpdateTitle(std::move(p_title), std::move(p_title_direction));
        return true;
    }
    case messages::LocalFrameHost::kUpdateAppTitle: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_UpdateAppTitle_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_UpdateAppTitle_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.31
        bool success = true;
        ::WTF::String p_app_title {};
        LocalFrameHost_UpdateAppTitle_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadAppTitle(&p_app_title))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 31, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->UpdateAppTitle(std::move(p_app_title));
        return true;
    }
    case messages::LocalFrameHost::kUpdateUserActivationState: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_UpdateUserActivationState_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_UpdateUserActivationState_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.32
        bool success = true;
        ::blink::mojom::blink::UserActivationUpdateType p_update_type {};
        ::blink::mojom::blink::UserActivationNotificationType p_notification_type {};
        LocalFrameHost_UpdateUserActivationState_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadUpdateType(&p_update_type))
            success = false;
        if (success && !input_data_view.ReadNotificationType(&p_notification_type))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 32, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->UpdateUserActivationState(std::move(p_update_type), std::move(p_notification_type));
        return true;
    }
    case messages::LocalFrameHost::kDidConsumeHistoryUserActivation: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_DidConsumeHistoryUserActivation_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_DidConsumeHistoryUserActivation_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.33
        bool success = true;
        LocalFrameHost_DidConsumeHistoryUserActivation_ParamsDataView input_data_view(params, message);

        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 33, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->DidConsumeHistoryUserActivation();
        return true;
    }
    case messages::LocalFrameHost::kHandleAccessibilityFindInPageResult: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_HandleAccessibilityFindInPageResult_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_HandleAccessibilityFindInPageResult_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.34
        bool success = true;
        FindInPageResultAXParamsPtr p_params {};
        LocalFrameHost_HandleAccessibilityFindInPageResult_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadParams(&p_params))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 34, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->HandleAccessibilityFindInPageResult(std::move(p_params));
        return true;
    }
    case messages::LocalFrameHost::kHandleAccessibilityFindInPageTermination: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_HandleAccessibilityFindInPageTermination_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_HandleAccessibilityFindInPageTermination_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.35
        bool success = true;
        LocalFrameHost_HandleAccessibilityFindInPageTermination_ParamsDataView input_data_view(params, message);

        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 35, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->HandleAccessibilityFindInPageTermination();
        return true;
    }
    case messages::LocalFrameHost::kDocumentOnLoadCompleted: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_DocumentOnLoadCompleted_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_DocumentOnLoadCompleted_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.36
        bool success = true;
        LocalFrameHost_DocumentOnLoadCompleted_ParamsDataView input_data_view(params, message);

        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 36, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->DocumentOnLoadCompleted();
        return true;
    }
    case messages::LocalFrameHost::kForwardResourceTimingToParent: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_ForwardResourceTimingToParent_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_ForwardResourceTimingToParent_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.37
        bool success = true;
        ::blink::mojom::blink::ResourceTimingInfoPtr p_timing {};
        LocalFrameHost_ForwardResourceTimingToParent_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadTiming(&p_timing))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 37, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->ForwardResourceTimingToParent(std::move(p_timing));
        return true;
    }
    case messages::LocalFrameHost::kDidDispatchDOMContentLoadedEvent: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_DidDispatchDOMContentLoadedEvent_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_DidDispatchDOMContentLoadedEvent_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.38
        bool success = true;
        LocalFrameHost_DidDispatchDOMContentLoadedEvent_ParamsDataView input_data_view(params, message);

        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 38, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->DidDispatchDOMContentLoadedEvent();
        return true;
    }
    case messages::LocalFrameHost::kRunModalAlertDialog: {
        break;
    }
    case messages::LocalFrameHost::kRunModalConfirmDialog: {
        break;
    }
    case messages::LocalFrameHost::kRunModalPromptDialog: {
        break;
    }
    case messages::LocalFrameHost::kRunBeforeUnloadConfirm: {
        break;
    }
    case messages::LocalFrameHost::kUpdateFaviconURL: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_UpdateFaviconURL_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_UpdateFaviconURL_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.43
        bool success = true;
        WTF::Vector<::blink::mojom::blink::FaviconURLPtr> p_favicon_urls {};
        LocalFrameHost_UpdateFaviconURL_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadFaviconUrls(&p_favicon_urls))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 43, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->UpdateFaviconURL(std::move(p_favicon_urls));
        return true;
    }
    case messages::LocalFrameHost::kDownloadURL: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_DownloadURL_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_DownloadURL_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.44
        bool success = true;
        DownloadURLParamsPtr p_params {};
        LocalFrameHost_DownloadURL_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadParams(&p_params))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 44, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->DownloadURL(std::move(p_params));
        return true;
    }
    case messages::LocalFrameHost::kFocusedElementChanged: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_FocusedElementChanged_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_FocusedElementChanged_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.45
        bool success = true;
        bool p_is_editable_element {};
        bool p_is_richly_editable_element {};
        ::gfx::Rect p_bounds_in_frame_widget {};
        ::blink::mojom::blink::FocusType p_focus_type {};
        LocalFrameHost_FocusedElementChanged_ParamsDataView input_data_view(params, message);

        if (success)
            p_is_editable_element = input_data_view.is_editable_element();
        if (success)
            p_is_richly_editable_element = input_data_view.is_richly_editable_element();
        if (success && !input_data_view.ReadBoundsInFrameWidget(&p_bounds_in_frame_widget))
            success = false;
        if (success && !input_data_view.ReadFocusType(&p_focus_type))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 45, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->FocusedElementChanged(
            std::move(p_is_editable_element), std::move(p_is_richly_editable_element), std::move(p_bounds_in_frame_widget), std::move(p_focus_type));
        return true;
    }
    case messages::LocalFrameHost::kTextSelectionChanged: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_TextSelectionChanged_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_TextSelectionChanged_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.46
        bool success = true;
        ::WTF::String p_text {};
        uint32_t p_offset {};
        ::gfx::Range p_range {};
        LocalFrameHost_TextSelectionChanged_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadText(&p_text))
            success = false;
        if (success)
            p_offset = input_data_view.offset();
        if (success && !input_data_view.ReadRange(&p_range))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 46, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->TextSelectionChanged(std::move(p_text), std::move(p_offset), std::move(p_range));
        return true;
    }
    case messages::LocalFrameHost::kShowPopupMenu: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_ShowPopupMenu_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_ShowPopupMenu_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.47
        bool success = true;
        ::mojo::PendingRemote<::blink::mojom::blink::PopupMenuClient> p_popup_client {};
        ::gfx::Rect p_bounds {};
        int32_t p_item_height {};
        double p_font_size {};
        int32_t p_selected_item {};
        WTF::Vector<::blink::mojom::blink::MenuItemPtr> p_menu_items {};
        bool p_right_aligned {};
        bool p_allow_multiple_selection {};
        LocalFrameHost_ShowPopupMenu_ParamsDataView input_data_view(params, message);

        if (success) {
            p_popup_client = input_data_view.TakePopupClient<decltype(p_popup_client)>();
        }
        if (success && !input_data_view.ReadBounds(&p_bounds))
            success = false;
        if (success)
            p_item_height = input_data_view.item_height();
        if (success)
            p_font_size = input_data_view.font_size();
        if (success)
            p_selected_item = input_data_view.selected_item();
        if (success && !input_data_view.ReadMenuItems(&p_menu_items))
            success = false;
        if (success)
            p_right_aligned = input_data_view.right_aligned();
        if (success)
            p_allow_multiple_selection = input_data_view.allow_multiple_selection();
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 47, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->ShowPopupMenu(std::move(p_popup_client), std::move(p_bounds), std::move(p_item_height), std::move(p_font_size), std::move(p_selected_item),
            std::move(p_menu_items), std::move(p_right_aligned), std::move(p_allow_multiple_selection));
        return true;
    }
    case messages::LocalFrameHost::kCreateNewPopupWidget: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_CreateNewPopupWidget_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_CreateNewPopupWidget_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.48
        bool success = true;
        ::mojo::PendingAssociatedReceiver<::blink::mojom::blink::PopupWidgetHost> p_popup_host {};
        ::mojo::PendingAssociatedReceiver<::blink::mojom::blink::WidgetHost> p_blink_widget_host {};
        ::mojo::PendingAssociatedRemote<::blink::mojom::blink::Widget> p_blink_widget {};
        LocalFrameHost_CreateNewPopupWidget_ParamsDataView input_data_view(params, message);

        if (success) {
            p_popup_host = input_data_view.TakePopupHost<decltype(p_popup_host)>();
        }
        if (success) {
            p_blink_widget_host = input_data_view.TakeBlinkWidgetHost<decltype(p_blink_widget_host)>();
        }
        if (success) {
            p_blink_widget = input_data_view.TakeBlinkWidget<decltype(p_blink_widget)>();
        }
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 48, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->CreateNewPopupWidget(std::move(p_popup_host), std::move(p_blink_widget_host), std::move(p_blink_widget));
        return true;
    }
    case messages::LocalFrameHost::kShowContextMenu: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_ShowContextMenu_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_ShowContextMenu_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.49
        bool success = true;
        ::mojo::PendingAssociatedRemote<::blink::mojom::blink::ContextMenuClient> p_client {};
        ::blink::UntrustworthyContextMenuParams p_params {};
        LocalFrameHost_ShowContextMenu_ParamsDataView input_data_view(params, message);

        if (success) {
            p_client = input_data_view.TakeClient<decltype(p_client)>();
        }
        if (success && !input_data_view.ReadParams(&p_params))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 49, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->ShowContextMenu(std::move(p_client), std::move(p_params));
        return true;
    }
    case messages::LocalFrameHost::kDidLoadResourceFromMemoryCache: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_DidLoadResourceFromMemoryCache_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_DidLoadResourceFromMemoryCache_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.50
        bool success = true;
        ::blink::KURL p_url {};
        WTF::String p_http_method {};
        WTF::String p_mime_type {};
        ::network::mojom::blink::RequestDestination p_request_destination {};
        bool p_include_credentials {};
        LocalFrameHost_DidLoadResourceFromMemoryCache_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadUrl(&p_url))
            success = false;
        if (success && !input_data_view.ReadHttpMethod(&p_http_method))
            success = false;
        if (success && !input_data_view.ReadMimeType(&p_mime_type))
            success = false;
        if (success && !input_data_view.ReadRequestDestination(&p_request_destination))
            success = false;
        if (success)
            p_include_credentials = input_data_view.include_credentials();
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 50, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->DidLoadResourceFromMemoryCache(
            std::move(p_url), std::move(p_http_method), std::move(p_mime_type), std::move(p_request_destination), std::move(p_include_credentials));
        return true;
    }
    case messages::LocalFrameHost::kDidChangeFrameOwnerProperties: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_DidChangeFrameOwnerProperties_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_DidChangeFrameOwnerProperties_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.51
        bool success = true;
        ::blink::FrameToken p_child_frame_token {};
        ::blink::mojom::blink::FrameOwnerPropertiesPtr p_frame_owner_properties {};
        LocalFrameHost_DidChangeFrameOwnerProperties_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadChildFrameToken(&p_child_frame_token))
            success = false;
        if (success && !input_data_view.ReadFrameOwnerProperties(&p_frame_owner_properties))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 51, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->DidChangeFrameOwnerProperties(std::move(p_child_frame_token), std::move(p_frame_owner_properties));
        return true;
    }
    case messages::LocalFrameHost::kDidChangeOpener: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_DidChangeOpener_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_DidChangeOpener_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.52
        bool success = true;
        std::optional<::blink::LocalFrameToken> p_opener_frame {};
        LocalFrameHost_DidChangeOpener_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadOpenerFrame(&p_opener_frame))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 52, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->DidChangeOpener(std::move(p_opener_frame));
        return true;
    }
    case messages::LocalFrameHost::kDidChangeFramePolicy: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_DidChangeFramePolicy_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_DidChangeFramePolicy_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.53
        bool success = true;
        ::blink::FrameToken p_child_frame_token {};
        ::blink::FramePolicy p_frame_policy {};
        LocalFrameHost_DidChangeFramePolicy_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadChildFrameToken(&p_child_frame_token))
            success = false;
        if (success && !input_data_view.ReadFramePolicy(&p_frame_policy))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 53, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->DidChangeFramePolicy(std::move(p_child_frame_token), std::move(p_frame_policy));
        return true;
    }
    case messages::LocalFrameHost::kDidChangeIframeAttributes: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_DidChangeIframeAttributes_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_DidChangeIframeAttributes_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.54
        bool success = true;
        ::blink::FrameToken p_child_frame_token {};
        IframeAttributesPtr p_attributes {};
        LocalFrameHost_DidChangeIframeAttributes_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadChildFrameToken(&p_child_frame_token))
            success = false;
        if (success && !input_data_view.ReadAttributes(&p_attributes))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 54, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->DidChangeIframeAttributes(std::move(p_child_frame_token), std::move(p_attributes));
        return true;
    }
    case messages::LocalFrameHost::kCapturePaintPreviewOfSubframe: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_CapturePaintPreviewOfSubframe_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_CapturePaintPreviewOfSubframe_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.55
        bool success = true;
        ::gfx::Rect p_clip_rect {};
        ::base::UnguessableToken p_guid {};
        LocalFrameHost_CapturePaintPreviewOfSubframe_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadClipRect(&p_clip_rect))
            success = false;
        if (success && !input_data_view.ReadGuid(&p_guid))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 55, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->CapturePaintPreviewOfSubframe(std::move(p_clip_rect), std::move(p_guid));
        return true;
    }
    case messages::LocalFrameHost::kSetCloseListener: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_SetCloseListener_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_SetCloseListener_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.56
        bool success = true;
        ::mojo::PendingRemote<::blink::mojom::blink::CloseListener> p_listener {};
        LocalFrameHost_SetCloseListener_ParamsDataView input_data_view(params, message);

        if (success) {
            p_listener = input_data_view.TakeListener<decltype(p_listener)>();
        }
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 56, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->SetCloseListener(std::move(p_listener));
        return true;
    }
    case messages::LocalFrameHost::kDetach: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_Detach_Params_Data* params = reinterpret_cast<internal::LocalFrameHost_Detach_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.57
        bool success = true;
        LocalFrameHost_Detach_ParamsDataView input_data_view(params, message);

        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 57, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->Detach();
        return true;
    }
    case messages::LocalFrameHost::kGetKeepAliveHandleFactory: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_GetKeepAliveHandleFactory_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_GetKeepAliveHandleFactory_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.58
        bool success = true;
        ::mojo::PendingReceiver<::blink::mojom::blink::KeepAliveHandleFactory> p_factory {};
        LocalFrameHost_GetKeepAliveHandleFactory_ParamsDataView input_data_view(params, message);

        if (success) {
            p_factory = input_data_view.TakeFactory<decltype(p_factory)>();
        }
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 58, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->GetKeepAliveHandleFactory(std::move(p_factory));
        return true;
    }
    case messages::LocalFrameHost::kDidAddMessageToConsole: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_DidAddMessageToConsole_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_DidAddMessageToConsole_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.59
        bool success = true;
        ::blink::mojom::blink::ConsoleMessageLevel p_log_level {};
        ::WTF::String p_msg {};
        uint32_t p_line_number {};
        ::WTF::String p_source_id {};
        ::WTF::String p_untrusted_stack_trace {};
        LocalFrameHost_DidAddMessageToConsole_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadLogLevel(&p_log_level))
            success = false;
        if (success && !input_data_view.ReadMsg(&p_msg))
            success = false;
        if (success)
            p_line_number = input_data_view.line_number();
        if (success && !input_data_view.ReadSourceId(&p_source_id))
            success = false;
        if (success && !input_data_view.ReadUntrustedStackTrace(&p_untrusted_stack_trace))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 59, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->DidAddMessageToConsole(
            std::move(p_log_level), std::move(p_msg), std::move(p_line_number), std::move(p_source_id), std::move(p_untrusted_stack_trace));
        return true;
    }
    case messages::LocalFrameHost::kFrameSizeChanged: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_FrameSizeChanged_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_FrameSizeChanged_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.60
        bool success = true;
        ::gfx::Size p_size {};
        LocalFrameHost_FrameSizeChanged_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadSize(&p_size))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 60, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->FrameSizeChanged(std::move(p_size));
        return true;
    }
    case messages::LocalFrameHost::kDidInferColorScheme: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_DidInferColorScheme_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_DidInferColorScheme_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.61
        bool success = true;
        ::blink::mojom::blink::PreferredColorScheme p_color_scheme {};
        LocalFrameHost_DidInferColorScheme_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadColorScheme(&p_color_scheme))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 61, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->DidInferColorScheme(std::move(p_color_scheme));
        return true;
    }
    case messages::LocalFrameHost::kDidChangeSrcDoc: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_DidChangeSrcDoc_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_DidChangeSrcDoc_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.62
        bool success = true;
        ::blink::FrameToken p_child_frame_token {};
        WTF::String p_srcdoc_value {};
        LocalFrameHost_DidChangeSrcDoc_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadChildFrameToken(&p_child_frame_token))
            success = false;
        if (success && !input_data_view.ReadSrcdocValue(&p_srcdoc_value))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 62, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->DidChangeSrcDoc(std::move(p_child_frame_token), std::move(p_srcdoc_value));
        return true;
    }
    case messages::LocalFrameHost::kReceivedDelegatedCapability: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_ReceivedDelegatedCapability_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_ReceivedDelegatedCapability_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.63
        bool success = true;
        ::blink::mojom::blink::DelegatedCapability p_delegated_capability {};
        LocalFrameHost_ReceivedDelegatedCapability_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadDelegatedCapability(&p_delegated_capability))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 63, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->ReceivedDelegatedCapability(std::move(p_delegated_capability));
        return true;
    }
    case messages::LocalFrameHost::kSendFencedFrameReportingBeacon: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_SendFencedFrameReportingBeacon_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_SendFencedFrameReportingBeacon_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.64
        bool success = true;
        WTF::String p_event_data {};
        WTF::String p_event_type {};
        WTF::Vector<::blink::FencedFrame::ReportingDestination> p_destinations {};
        bool p_cross_origin_exposed {};
        LocalFrameHost_SendFencedFrameReportingBeacon_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadEventData(&p_event_data))
            success = false;
        if (success && !input_data_view.ReadEventType(&p_event_type))
            success = false;
        if (success && !input_data_view.ReadDestinations(&p_destinations))
            success = false;
        if (success)
            p_cross_origin_exposed = input_data_view.cross_origin_exposed();
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 64, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->SendFencedFrameReportingBeacon(std::move(p_event_data), std::move(p_event_type), std::move(p_destinations), std::move(p_cross_origin_exposed));
        return true;
    }
    case messages::LocalFrameHost::kSendFencedFrameReportingBeaconToCustomURL: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_SendFencedFrameReportingBeaconToCustomURL_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_SendFencedFrameReportingBeaconToCustomURL_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.65
        bool success = true;
        ::blink::KURL p_destination_url {};
        bool p_cross_origin_exposed {};
        LocalFrameHost_SendFencedFrameReportingBeaconToCustomURL_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadDestinationUrl(&p_destination_url))
            success = false;
        if (success)
            p_cross_origin_exposed = input_data_view.cross_origin_exposed();
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 65, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->SendFencedFrameReportingBeaconToCustomURL(std::move(p_destination_url), std::move(p_cross_origin_exposed));
        return true;
    }
    case messages::LocalFrameHost::kDisableUntrustedNetworkInFencedFrame: {
        break;
    }
    case messages::LocalFrameHost::kExemptUrlFromNetworkRevocationForTesting: {
        break;
    }
    case messages::LocalFrameHost::kSendLegacyTechEvent: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_SendLegacyTechEvent_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_SendLegacyTechEvent_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.68
        bool success = true;
        WTF::String p_type {};
        LegacyTechEventCodeLocationPtr p_code_location {};
        LocalFrameHost_SendLegacyTechEvent_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadType(&p_type))
            success = false;
        if (success && !input_data_view.ReadCodeLocation(&p_code_location))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 68, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->SendLegacyTechEvent(std::move(p_type), std::move(p_code_location));
        return true;
    }
    case messages::LocalFrameHost::kSetFencedFrameAutomaticBeaconReportEventData: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_SetFencedFrameAutomaticBeaconReportEventData_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_SetFencedFrameAutomaticBeaconReportEventData_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.69
        bool success = true;
        ::blink::mojom::blink::AutomaticBeaconType p_event_type {};
        WTF::String p_event_data {};
        WTF::Vector<::blink::FencedFrame::ReportingDestination> p_destinations {};
        bool p_once {};
        bool p_cross_origin_exposed {};
        LocalFrameHost_SetFencedFrameAutomaticBeaconReportEventData_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadEventType(&p_event_type))
            success = false;
        if (success && !input_data_view.ReadEventData(&p_event_data))
            success = false;
        if (success && !input_data_view.ReadDestinations(&p_destinations))
            success = false;
        if (success)
            p_once = input_data_view.once();
        if (success)
            p_cross_origin_exposed = input_data_view.cross_origin_exposed();
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 69, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->SetFencedFrameAutomaticBeaconReportEventData(
            std::move(p_event_type), std::move(p_event_data), std::move(p_destinations), std::move(p_once), std::move(p_cross_origin_exposed));
        return true;
    }
    case messages::LocalFrameHost::kSendPrivateAggregationRequestsForFencedFrameEvent: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_SendPrivateAggregationRequestsForFencedFrameEvent_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_SendPrivateAggregationRequestsForFencedFrameEvent_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.70
        bool success = true;
        WTF::String p_event_type {};
        LocalFrameHost_SendPrivateAggregationRequestsForFencedFrameEvent_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadEventType(&p_event_type))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 70, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->SendPrivateAggregationRequestsForFencedFrameEvent(std::move(p_event_type));
        return true;
    }
    case messages::LocalFrameHost::kCreateFencedFrame: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_CreateFencedFrame_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_CreateFencedFrame_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.71
        bool success = true;
        ::mojo::PendingAssociatedReceiver<::blink::mojom::blink::FencedFrameOwnerHost> p_fenced_frame {};
        ::blink::mojom::blink::RemoteFrameInterfacesFromRendererPtr p_remote_frame_interfaces {};
        ::blink::RemoteFrameToken p_frame_token {};
        ::base::UnguessableToken p_devtools_frame_token {};
        LocalFrameHost_CreateFencedFrame_ParamsDataView input_data_view(params, message);

        if (success) {
            p_fenced_frame = input_data_view.TakeFencedFrame<decltype(p_fenced_frame)>();
        }
        if (success && !input_data_view.ReadRemoteFrameInterfaces(&p_remote_frame_interfaces))
            success = false;
        if (success && !input_data_view.ReadFrameToken(&p_frame_token))
            success = false;
        if (success && !input_data_view.ReadDevtoolsFrameToken(&p_devtools_frame_token))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 71, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->CreateFencedFrame(std::move(p_fenced_frame), std::move(p_remote_frame_interfaces), std::move(p_frame_token), std::move(p_devtools_frame_token));
        return true;
    }
    case messages::LocalFrameHost::kForwardFencedFrameEventAndUserActivationToEmbedder: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_ForwardFencedFrameEventAndUserActivationToEmbedder_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_ForwardFencedFrameEventAndUserActivationToEmbedder_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.72
        bool success = true;
        WTF::String p_event_type {};
        LocalFrameHost_ForwardFencedFrameEventAndUserActivationToEmbedder_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadEventType(&p_event_type))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 72, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->ForwardFencedFrameEventAndUserActivationToEmbedder(std::move(p_event_type));
        return true;
    }
    case messages::LocalFrameHost::kOnViewTransitionOptInChanged: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_OnViewTransitionOptInChanged_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_OnViewTransitionOptInChanged_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.73
        bool success = true;
        ViewTransitionSameOriginOptIn p_view_transition_opt_in {};
        LocalFrameHost_OnViewTransitionOptInChanged_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadViewTransitionOptIn(&p_view_transition_opt_in))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 73, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->OnViewTransitionOptInChanged(std::move(p_view_transition_opt_in));
        return true;
    }
    case messages::LocalFrameHost::kStartDragging: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_StartDragging_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_StartDragging_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.74
        bool success = true;
        ::blink::WebDragData p_drag_data {};
        ::blink::DragOperationsMask p_operations_allowed {};
        ::SkBitmap p_image {};
        ::gfx::Vector2d p_cursor_offset_in_dip {};
        ::gfx::Rect p_drag_obj_rect_in_dip {};
        ::blink::mojom::blink::DragEventSourceInfoPtr p_event_info {};
        LocalFrameHost_StartDragging_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadDragData(&p_drag_data))
            success = false;
        if (success && !input_data_view.ReadOperationsAllowed(&p_operations_allowed))
            success = false;
        if (success && !input_data_view.ReadImage(&p_image))
            success = false;
        if (success && !input_data_view.ReadCursorOffsetInDip(&p_cursor_offset_in_dip))
            success = false;
        if (success && !input_data_view.ReadDragObjRectInDip(&p_drag_obj_rect_in_dip))
            success = false;
        if (success && !input_data_view.ReadEventInfo(&p_event_info))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 74, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->StartDragging(std::move(p_drag_data), std::move(p_operations_allowed), std::move(p_image), std::move(p_cursor_offset_in_dip),
            std::move(p_drag_obj_rect_in_dip), std::move(p_event_info));
        return true;
    }
    case messages::LocalFrameHost::kIssueKeepAliveHandle: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_IssueKeepAliveHandle_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_IssueKeepAliveHandle_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.75
        bool success = true;
        ::mojo::PendingReceiver<::blink::mojom::blink::NavigationStateKeepAliveHandle> p_receiver {};
        LocalFrameHost_IssueKeepAliveHandle_ParamsDataView input_data_view(params, message);

        if (success) {
            p_receiver = input_data_view.TakeReceiver<decltype(p_receiver)>();
        }
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 75, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->IssueKeepAliveHandle(std::move(p_receiver));
        return true;
    }
    case messages::LocalFrameHost::kNotifyStorageAccessed: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_NotifyStorageAccessed_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_NotifyStorageAccessed_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.76
        bool success = true;
        StorageTypeAccessed p_storageType {};
        bool p_blocked {};
        LocalFrameHost_NotifyStorageAccessed_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadStorageType(&p_storageType))
            success = false;
        if (success)
            p_blocked = input_data_view.blocked();
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 76, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->NotifyStorageAccessed(std::move(p_storageType), std::move(p_blocked));
        return true;
    }
    case messages::LocalFrameHost::kRecordWindowProxyUsageMetrics: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_RecordWindowProxyUsageMetrics_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_RecordWindowProxyUsageMetrics_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.77
        bool success = true;
        ::blink::FrameToken p_target_frame_token {};
        WindowProxyAccessType p_access_type {};
        LocalFrameHost_RecordWindowProxyUsageMetrics_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadTargetFrameToken(&p_target_frame_token))
            success = false;
        if (success && !input_data_view.ReadAccessType(&p_access_type))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 77, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->RecordWindowProxyUsageMetrics(std::move(p_target_frame_token), std::move(p_access_type));
        return true;
    }
    case messages::LocalFrameHost::kNotifyDocumentInteractive: {
        DCHECK(message->is_serialized());
        internal::LocalFrameHost_NotifyDocumentInteractive_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_NotifyDocumentInteractive_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.78
        bool success = true;
        LocalFrameHost_NotifyDocumentInteractive_ParamsDataView input_data_view(params, message);

        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 78, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->NotifyDocumentInteractive();
        return true;
    }
    }
    return false;
}

// static
bool LocalFrameHostStubDispatch::AcceptWithResponder(LocalFrameHost* impl, mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
{
    [[maybe_unused]] const bool message_is_sync = message->has_flag(mojo::Message::kFlagIsSync);
    [[maybe_unused]] const uint64_t request_id = message->request_id();
    switch (static_cast<messages::LocalFrameHost>(message->header()->name)) {
    case messages::LocalFrameHost::kEnterFullscreen: {
        internal::LocalFrameHost_EnterFullscreen_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_EnterFullscreen_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.0
        bool success = true;
        ::blink::mojom::blink::FullscreenOptionsPtr p_options {};
        LocalFrameHost_EnterFullscreen_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadOptions(&p_options))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 0, false);
            return false;
        }
        LocalFrameHost::EnterFullscreenCallback callback = LocalFrameHost_EnterFullscreen_ProxyToResponder::CreateCallback(*message, std::move(responder));
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->EnterFullscreen(std::move(p_options), std::move(callback));
        return true;
    }
    case messages::LocalFrameHost::kExitFullscreen: {
        break;
    }
    case messages::LocalFrameHost::kFullscreenStateChanged: {
        break;
    }
    case messages::LocalFrameHost::kRegisterProtocolHandler: {
        break;
    }
    case messages::LocalFrameHost::kUnregisterProtocolHandler: {
        break;
    }
    case messages::LocalFrameHost::kDidDisplayInsecureContent: {
        break;
    }
    case messages::LocalFrameHost::kDidContainInsecureFormAction: {
        break;
    }
    case messages::LocalFrameHost::kMainDocumentElementAvailable: {
        break;
    }
    case messages::LocalFrameHost::kSetNeedsOcclusionTracking: {
        break;
    }
    case messages::LocalFrameHost::kSetVirtualKeyboardMode: {
        break;
    }
    case messages::LocalFrameHost::kVisibilityChanged: {
        break;
    }
    case messages::LocalFrameHost::kDidChangeThemeColor: {
        break;
    }
    case messages::LocalFrameHost::kDidChangeBackgroundColor: {
        break;
    }
    case messages::LocalFrameHost::kDidFailLoadWithError: {
        break;
    }
    case messages::LocalFrameHost::kDidFocusFrame: {
        break;
    }
    case messages::LocalFrameHost::kDidCallFocus: {
        break;
    }
    case messages::LocalFrameHost::kEnforceInsecureRequestPolicy: {
        break;
    }
    case messages::LocalFrameHost::kEnforceInsecureNavigationsSet: {
        break;
    }
    case messages::LocalFrameHost::kSuddenTerminationDisablerChanged: {
        break;
    }
    case messages::LocalFrameHost::kHadStickyUserActivationBeforeNavigationChanged: {
        break;
    }
    case messages::LocalFrameHost::kScrollRectToVisibleInParentFrame: {
        break;
    }
    case messages::LocalFrameHost::kBubbleLogicalScrollInParentFrame: {
        break;
    }
    case messages::LocalFrameHost::kStartLoadingForAsyncNavigationApiCommit: {
        break;
    }
    case messages::LocalFrameHost::kDidBlockNavigation: {
        break;
    }
    case messages::LocalFrameHost::kDidChangeLoadProgress: {
        break;
    }
    case messages::LocalFrameHost::kDidFinishLoad: {
        break;
    }
    case messages::LocalFrameHost::kDispatchLoad: {
        break;
    }
    case messages::LocalFrameHost::kGoToEntryAtOffset: {
        break;
    }
    case messages::LocalFrameHost::kNavigateToNavigationApiKey: {
        break;
    }
    case messages::LocalFrameHost::kNavigateEventHandlerPresenceChanged: {
        break;
    }
    case messages::LocalFrameHost::kUpdateTitle: {
        break;
    }
    case messages::LocalFrameHost::kUpdateAppTitle: {
        break;
    }
    case messages::LocalFrameHost::kUpdateUserActivationState: {
        break;
    }
    case messages::LocalFrameHost::kDidConsumeHistoryUserActivation: {
        break;
    }
    case messages::LocalFrameHost::kHandleAccessibilityFindInPageResult: {
        break;
    }
    case messages::LocalFrameHost::kHandleAccessibilityFindInPageTermination: {
        break;
    }
    case messages::LocalFrameHost::kDocumentOnLoadCompleted: {
        break;
    }
    case messages::LocalFrameHost::kForwardResourceTimingToParent: {
        break;
    }
    case messages::LocalFrameHost::kDidDispatchDOMContentLoadedEvent: {
        break;
    }
    case messages::LocalFrameHost::kRunModalAlertDialog: {
        internal::LocalFrameHost_RunModalAlertDialog_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_RunModalAlertDialog_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.39
        bool success = true;
        ::WTF::String p_alert_message {};
        bool p_disable_third_party_subframe_suppresion {};
        LocalFrameHost_RunModalAlertDialog_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadAlertMessage(&p_alert_message))
            success = false;
        if (success)
            p_disable_third_party_subframe_suppresion = input_data_view.disable_third_party_subframe_suppresion();
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 39, false);
            return false;
        }
        LocalFrameHost::RunModalAlertDialogCallback callback
            = LocalFrameHost_RunModalAlertDialog_ProxyToResponder::CreateCallback(*message, std::move(responder));
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->RunModalAlertDialog(std::move(p_alert_message), std::move(p_disable_third_party_subframe_suppresion), std::move(callback));
        return true;
    }
    case messages::LocalFrameHost::kRunModalConfirmDialog: {
        internal::LocalFrameHost_RunModalConfirmDialog_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_RunModalConfirmDialog_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.40
        bool success = true;
        ::WTF::String p_alert_message {};
        bool p_disable_third_party_subframe_suppresion {};
        LocalFrameHost_RunModalConfirmDialog_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadAlertMessage(&p_alert_message))
            success = false;
        if (success)
            p_disable_third_party_subframe_suppresion = input_data_view.disable_third_party_subframe_suppresion();
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 40, false);
            return false;
        }
        LocalFrameHost::RunModalConfirmDialogCallback callback
            = LocalFrameHost_RunModalConfirmDialog_ProxyToResponder::CreateCallback(*message, std::move(responder));
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->RunModalConfirmDialog(std::move(p_alert_message), std::move(p_disable_third_party_subframe_suppresion), std::move(callback));
        return true;
    }
    case messages::LocalFrameHost::kRunModalPromptDialog: {
        internal::LocalFrameHost_RunModalPromptDialog_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_RunModalPromptDialog_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.41
        bool success = true;
        ::WTF::String p_alert_message {};
        ::WTF::String p_default_value {};
        bool p_disable_third_party_subframe_suppresion {};
        LocalFrameHost_RunModalPromptDialog_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadAlertMessage(&p_alert_message))
            success = false;
        if (success && !input_data_view.ReadDefaultValue(&p_default_value))
            success = false;
        if (success)
            p_disable_third_party_subframe_suppresion = input_data_view.disable_third_party_subframe_suppresion();
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 41, false);
            return false;
        }
        LocalFrameHost::RunModalPromptDialogCallback callback
            = LocalFrameHost_RunModalPromptDialog_ProxyToResponder::CreateCallback(*message, std::move(responder));
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->RunModalPromptDialog(
            std::move(p_alert_message), std::move(p_default_value), std::move(p_disable_third_party_subframe_suppresion), std::move(callback));
        return true;
    }
    case messages::LocalFrameHost::kRunBeforeUnloadConfirm: {
        internal::LocalFrameHost_RunBeforeUnloadConfirm_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_RunBeforeUnloadConfirm_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.42
        bool success = true;
        bool p_is_reload {};
        LocalFrameHost_RunBeforeUnloadConfirm_ParamsDataView input_data_view(params, message);

        if (success)
            p_is_reload = input_data_view.is_reload();
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 42, false);
            return false;
        }
        LocalFrameHost::RunBeforeUnloadConfirmCallback callback
            = LocalFrameHost_RunBeforeUnloadConfirm_ProxyToResponder::CreateCallback(*message, std::move(responder));
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->RunBeforeUnloadConfirm(std::move(p_is_reload), std::move(callback));
        return true;
    }
    case messages::LocalFrameHost::kUpdateFaviconURL: {
        break;
    }
    case messages::LocalFrameHost::kDownloadURL: {
        break;
    }
    case messages::LocalFrameHost::kFocusedElementChanged: {
        break;
    }
    case messages::LocalFrameHost::kTextSelectionChanged: {
        break;
    }
    case messages::LocalFrameHost::kShowPopupMenu: {
        break;
    }
    case messages::LocalFrameHost::kCreateNewPopupWidget: {
        break;
    }
    case messages::LocalFrameHost::kShowContextMenu: {
        break;
    }
    case messages::LocalFrameHost::kDidLoadResourceFromMemoryCache: {
        break;
    }
    case messages::LocalFrameHost::kDidChangeFrameOwnerProperties: {
        break;
    }
    case messages::LocalFrameHost::kDidChangeOpener: {
        break;
    }
    case messages::LocalFrameHost::kDidChangeFramePolicy: {
        break;
    }
    case messages::LocalFrameHost::kDidChangeIframeAttributes: {
        break;
    }
    case messages::LocalFrameHost::kCapturePaintPreviewOfSubframe: {
        break;
    }
    case messages::LocalFrameHost::kSetCloseListener: {
        break;
    }
    case messages::LocalFrameHost::kDetach: {
        break;
    }
    case messages::LocalFrameHost::kGetKeepAliveHandleFactory: {
        break;
    }
    case messages::LocalFrameHost::kDidAddMessageToConsole: {
        break;
    }
    case messages::LocalFrameHost::kFrameSizeChanged: {
        break;
    }
    case messages::LocalFrameHost::kDidInferColorScheme: {
        break;
    }
    case messages::LocalFrameHost::kDidChangeSrcDoc: {
        break;
    }
    case messages::LocalFrameHost::kReceivedDelegatedCapability: {
        break;
    }
    case messages::LocalFrameHost::kSendFencedFrameReportingBeacon: {
        break;
    }
    case messages::LocalFrameHost::kSendFencedFrameReportingBeaconToCustomURL: {
        break;
    }
    case messages::LocalFrameHost::kDisableUntrustedNetworkInFencedFrame: {
        internal::LocalFrameHost_DisableUntrustedNetworkInFencedFrame_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_DisableUntrustedNetworkInFencedFrame_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.66
        bool success = true;
        LocalFrameHost_DisableUntrustedNetworkInFencedFrame_ParamsDataView input_data_view(params, message);

        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 66, false);
            return false;
        }
        LocalFrameHost::DisableUntrustedNetworkInFencedFrameCallback callback
            = LocalFrameHost_DisableUntrustedNetworkInFencedFrame_ProxyToResponder::CreateCallback(*message, std::move(responder));
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->DisableUntrustedNetworkInFencedFrame(std::move(callback));
        return true;
    }
    case messages::LocalFrameHost::kExemptUrlFromNetworkRevocationForTesting: {
        internal::LocalFrameHost_ExemptUrlFromNetworkRevocationForTesting_Params_Data* params
            = reinterpret_cast<internal::LocalFrameHost_ExemptUrlFromNetworkRevocationForTesting_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrameHost.67
        bool success = true;
        ::blink::KURL p_exempted_url {};
        LocalFrameHost_ExemptUrlFromNetworkRevocationForTesting_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadExemptedUrl(&p_exempted_url))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrameHost::Name_, 67, false);
            return false;
        }
        LocalFrameHost::ExemptUrlFromNetworkRevocationForTestingCallback callback
            = LocalFrameHost_ExemptUrlFromNetworkRevocationForTesting_ProxyToResponder::CreateCallback(*message, std::move(responder));
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->ExemptUrlFromNetworkRevocationForTesting(std::move(p_exempted_url), std::move(callback));
        return true;
    }
    case messages::LocalFrameHost::kSendLegacyTechEvent: {
        break;
    }
    case messages::LocalFrameHost::kSetFencedFrameAutomaticBeaconReportEventData: {
        break;
    }
    case messages::LocalFrameHost::kSendPrivateAggregationRequestsForFencedFrameEvent: {
        break;
    }
    case messages::LocalFrameHost::kCreateFencedFrame: {
        break;
    }
    case messages::LocalFrameHost::kForwardFencedFrameEventAndUserActivationToEmbedder: {
        break;
    }
    case messages::LocalFrameHost::kOnViewTransitionOptInChanged: {
        break;
    }
    case messages::LocalFrameHost::kStartDragging: {
        break;
    }
    case messages::LocalFrameHost::kIssueKeepAliveHandle: {
        break;
    }
    case messages::LocalFrameHost::kNotifyStorageAccessed: {
        break;
    }
    case messages::LocalFrameHost::kRecordWindowProxyUsageMetrics: {
        break;
    }
    case messages::LocalFrameHost::kNotifyDocumentInteractive: {
        break;
    }
    }
    return false;
}
namespace {
} // namespace
static const mojo::internal::GenericValidationInfo kLocalFrameHostValidationInfo[] = {
    { &internal::LocalFrameHost_EnterFullscreen_Params_Data::Validate, &internal::LocalFrameHost_EnterFullscreen_ResponseParams_Data::Validate },
    { &internal::LocalFrameHost_ExitFullscreen_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_FullscreenStateChanged_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_RegisterProtocolHandler_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_UnregisterProtocolHandler_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_DidDisplayInsecureContent_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_DidContainInsecureFormAction_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_MainDocumentElementAvailable_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_SetNeedsOcclusionTracking_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_SetVirtualKeyboardMode_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_VisibilityChanged_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_DidChangeThemeColor_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_DidChangeBackgroundColor_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_DidFailLoadWithError_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_DidFocusFrame_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_DidCallFocus_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_EnforceInsecureRequestPolicy_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_EnforceInsecureNavigationsSet_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_SuddenTerminationDisablerChanged_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_HadStickyUserActivationBeforeNavigationChanged_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_ScrollRectToVisibleInParentFrame_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_BubbleLogicalScrollInParentFrame_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_StartLoadingForAsyncNavigationApiCommit_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_DidBlockNavigation_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_DidChangeLoadProgress_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_DidFinishLoad_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_DispatchLoad_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_GoToEntryAtOffset_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_NavigateToNavigationApiKey_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_NavigateEventHandlerPresenceChanged_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_UpdateTitle_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_UpdateAppTitle_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_UpdateUserActivationState_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_DidConsumeHistoryUserActivation_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_HandleAccessibilityFindInPageResult_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_HandleAccessibilityFindInPageTermination_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_DocumentOnLoadCompleted_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_ForwardResourceTimingToParent_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_DidDispatchDOMContentLoadedEvent_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_RunModalAlertDialog_Params_Data::Validate, &internal::LocalFrameHost_RunModalAlertDialog_ResponseParams_Data::Validate },
    { &internal::LocalFrameHost_RunModalConfirmDialog_Params_Data::Validate, &internal::LocalFrameHost_RunModalConfirmDialog_ResponseParams_Data::Validate },
    { &internal::LocalFrameHost_RunModalPromptDialog_Params_Data::Validate, &internal::LocalFrameHost_RunModalPromptDialog_ResponseParams_Data::Validate },
    { &internal::LocalFrameHost_RunBeforeUnloadConfirm_Params_Data::Validate, &internal::LocalFrameHost_RunBeforeUnloadConfirm_ResponseParams_Data::Validate },
    { &internal::LocalFrameHost_UpdateFaviconURL_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_DownloadURL_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_FocusedElementChanged_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_TextSelectionChanged_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_ShowPopupMenu_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_CreateNewPopupWidget_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_ShowContextMenu_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_DidLoadResourceFromMemoryCache_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_DidChangeFrameOwnerProperties_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_DidChangeOpener_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_DidChangeFramePolicy_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_DidChangeIframeAttributes_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_CapturePaintPreviewOfSubframe_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_SetCloseListener_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_Detach_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_GetKeepAliveHandleFactory_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_DidAddMessageToConsole_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_FrameSizeChanged_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_DidInferColorScheme_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_DidChangeSrcDoc_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_ReceivedDelegatedCapability_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_SendFencedFrameReportingBeacon_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_SendFencedFrameReportingBeaconToCustomURL_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_DisableUntrustedNetworkInFencedFrame_Params_Data::Validate,
        &internal::LocalFrameHost_DisableUntrustedNetworkInFencedFrame_ResponseParams_Data::Validate },
    { &internal::LocalFrameHost_ExemptUrlFromNetworkRevocationForTesting_Params_Data::Validate,
        &internal::LocalFrameHost_ExemptUrlFromNetworkRevocationForTesting_ResponseParams_Data::Validate },
    { &internal::LocalFrameHost_SendLegacyTechEvent_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_SetFencedFrameAutomaticBeaconReportEventData_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_SendPrivateAggregationRequestsForFencedFrameEvent_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_CreateFencedFrame_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_ForwardFencedFrameEventAndUserActivationToEmbedder_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_OnViewTransitionOptInChanged_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_StartDragging_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_IssueKeepAliveHandle_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_NotifyStorageAccessed_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_RecordWindowProxyUsageMetrics_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrameHost_NotifyDocumentInteractive_Params_Data::Validate, nullptr /* no response */ },
};

bool LocalFrameHostRequestValidator::Accept(mojo::Message* message)
{
    const char* name = ::blink::mojom::blink::LocalFrameHost::Name_;
    return mojo::internal::ValidateRequestGenericPacked(message, name, kLocalFrameHostValidationInfo);
}

bool LocalFrameHostResponseValidator::Accept(mojo::Message* message)
{
    const char* name = ::blink::mojom::blink::LocalFrameHost::Name_;
    return mojo::internal::ValidateResponseGenericPacked(message, name, kLocalFrameHostValidationInfo);
}
const char NonAssociatedLocalFrameHost::Name_[] = "blink.mojom.NonAssociatedLocalFrameHost";

NonAssociatedLocalFrameHost::IPCStableHashFunction NonAssociatedLocalFrameHost::MessageToMethodInfo_(mojo::Message& message)
{
#if !BUILDFLAG(IS_FUCHSIA)
    switch (static_cast<messages::NonAssociatedLocalFrameHost>(message.name())) {
    case messages::NonAssociatedLocalFrameHost::kMaybeStartOutermostMainFrameNavigation: {
        return &NonAssociatedLocalFrameHost::MaybeStartOutermostMainFrameNavigation_Sym::IPCStableHash;
    }
    }
#endif // !BUILDFLAG(IS_FUCHSIA)
    return nullptr;
}

const char* NonAssociatedLocalFrameHost::MessageToMethodName_(mojo::Message& message)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
    if (!is_response) {
        switch (static_cast<messages::NonAssociatedLocalFrameHost>(message.name())) {
        case messages::NonAssociatedLocalFrameHost::kMaybeStartOutermostMainFrameNavigation:
            return "Receive blink::mojom::NonAssociatedLocalFrameHost::MaybeStartOutermostMainFrameNavigation";
        }
    } else {
        switch (static_cast<messages::NonAssociatedLocalFrameHost>(message.name())) {
        case messages::NonAssociatedLocalFrameHost::kMaybeStartOutermostMainFrameNavigation:
            return "Receive reply blink::mojom::NonAssociatedLocalFrameHost::MaybeStartOutermostMainFrameNavigation";
        }
    }
    return "Receive unknown mojo message";
#else
    bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
    if (is_response) {
        return "Receive mojo reply";
    } else {
        return "Receive mojo message";
    }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t NonAssociatedLocalFrameHost::MaybeStartOutermostMainFrameNavigation_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::NonAssociatedLocalFrameHost::MaybeStartOutermostMainFrameNavigation");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
#endif // !BUILDFLAG(IS_FUCHSIA)

NonAssociatedLocalFrameHostProxy::NonAssociatedLocalFrameHostProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver)
{
}

void NonAssociatedLocalFrameHostProxy::MaybeStartOutermostMainFrameNavigation(const WTF::Vector<::blink::KURL>& in_urls)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::NonAssociatedLocalFrameHost::MaybeStartOutermostMainFrameNavigation", "input_parameters",
        [&](perfetto::TracedValue context) {
            auto dict = std::move(context).WriteDictionary();
            perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("urls"), in_urls, "<value of type const WTF::Vector<::blink::KURL>&>");
        });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::NonAssociatedLocalFrameHost::kMaybeStartOutermostMainFrameNavigation), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::NonAssociatedLocalFrameHost_MaybeStartOutermostMainFrameNavigation_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->urls)::BaseType> urls_fragment(params.message());
    constexpr const mojo::internal::ContainerValidateParams& urls_validate_params = mojo::internal::GetArrayValidator<0, false, nullptr>();
    mojo::internal::Serialize<mojo::ArrayDataView<::url::mojom::UrlDataView>>(in_urls, urls_fragment, &urls_validate_params);
    params->urls.Set(urls_fragment.is_null() ? nullptr : urls_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->urls.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null urls in NonAssociatedLocalFrameHost.MaybeStartOutermostMainFrameNavigation request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(NonAssociatedLocalFrameHost::Name_);
    message.set_method_name("MaybeStartOutermostMainFrameNavigation");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

// static
bool NonAssociatedLocalFrameHostStubDispatch::Accept(NonAssociatedLocalFrameHost* impl, mojo::Message* message)
{
    switch (static_cast<messages::NonAssociatedLocalFrameHost>(message->header()->name)) {
    case messages::NonAssociatedLocalFrameHost::kMaybeStartOutermostMainFrameNavigation: {
        DCHECK(message->is_serialized());
        internal::NonAssociatedLocalFrameHost_MaybeStartOutermostMainFrameNavigation_Params_Data* params
            = reinterpret_cast<internal::NonAssociatedLocalFrameHost_MaybeStartOutermostMainFrameNavigation_Params_Data*>(message->mutable_payload());

        // Validation for NonAssociatedLocalFrameHost.0
        bool success = true;
        WTF::Vector<::blink::KURL> p_urls {};
        NonAssociatedLocalFrameHost_MaybeStartOutermostMainFrameNavigation_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadUrls(&p_urls))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, NonAssociatedLocalFrameHost::Name_, 0, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->MaybeStartOutermostMainFrameNavigation(std::move(p_urls));
        return true;
    }
    }
    return false;
}

// static
bool NonAssociatedLocalFrameHostStubDispatch::AcceptWithResponder(
    NonAssociatedLocalFrameHost* impl, mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
{
    [[maybe_unused]] const bool message_is_sync = message->has_flag(mojo::Message::kFlagIsSync);
    [[maybe_unused]] const uint64_t request_id = message->request_id();
    switch (static_cast<messages::NonAssociatedLocalFrameHost>(message->header()->name)) {
    case messages::NonAssociatedLocalFrameHost::kMaybeStartOutermostMainFrameNavigation: {
        break;
    }
    }
    return false;
}
namespace {
} // namespace
static const mojo::internal::GenericValidationInfo kNonAssociatedLocalFrameHostValidationInfo[] = {
    { &internal::NonAssociatedLocalFrameHost_MaybeStartOutermostMainFrameNavigation_Params_Data::Validate, nullptr /* no response */ },
};

bool NonAssociatedLocalFrameHostRequestValidator::Accept(mojo::Message* message)
{
    const char* name = ::blink::mojom::blink::NonAssociatedLocalFrameHost::Name_;
    return mojo::internal::ValidateRequestGenericPacked(message, name, kNonAssociatedLocalFrameHostValidationInfo);
}

const char LocalFrame::Name_[] = "blink.mojom.LocalFrame";

LocalFrame::IPCStableHashFunction LocalFrame::MessageToMethodInfo_(mojo::Message& message)
{
#if !BUILDFLAG(IS_FUCHSIA)
    switch (static_cast<messages::LocalFrame>(message.name())) {
    case messages::LocalFrame::kGetTextSurroundingSelection: {
        return &LocalFrame::GetTextSurroundingSelection_Sym::IPCStableHash;
    }
    case messages::LocalFrame::kSendInterventionReport: {
        return &LocalFrame::SendInterventionReport_Sym::IPCStableHash;
    }
    case messages::LocalFrame::kSetFrameOwnerProperties: {
        return &LocalFrame::SetFrameOwnerProperties_Sym::IPCStableHash;
    }
    case messages::LocalFrame::kNotifyUserActivation: {
        return &LocalFrame::NotifyUserActivation_Sym::IPCStableHash;
    }
    case messages::LocalFrame::kNotifyVirtualKeyboardOverlayRect: {
        return &LocalFrame::NotifyVirtualKeyboardOverlayRect_Sym::IPCStableHash;
    }
    case messages::LocalFrame::kAddMessageToConsole: {
        return &LocalFrame::AddMessageToConsole_Sym::IPCStableHash;
    }
    case messages::LocalFrame::kSwapInImmediately: {
        return &LocalFrame::SwapInImmediately_Sym::IPCStableHash;
    }
    case messages::LocalFrame::kCheckCompleted: {
        return &LocalFrame::CheckCompleted_Sym::IPCStableHash;
    }
    case messages::LocalFrame::kStopLoading: {
        return &LocalFrame::StopLoading_Sym::IPCStableHash;
    }
    case messages::LocalFrame::kCollapse: {
        return &LocalFrame::Collapse_Sym::IPCStableHash;
    }
    case messages::LocalFrame::kEnableViewSourceMode: {
        return &LocalFrame::EnableViewSourceMode_Sym::IPCStableHash;
    }
    case messages::LocalFrame::kFocus: {
        return &LocalFrame::Focus_Sym::IPCStableHash;
    }
    case messages::LocalFrame::kClearFocusedElement: {
        return &LocalFrame::ClearFocusedElement_Sym::IPCStableHash;
    }
    case messages::LocalFrame::kCopyImageAt: {
        return &LocalFrame::CopyImageAt_Sym::IPCStableHash;
    }
    case messages::LocalFrame::kSaveImageAt: {
        return &LocalFrame::SaveImageAt_Sym::IPCStableHash;
    }
    case messages::LocalFrame::kReportBlinkFeatureUsage: {
        return &LocalFrame::ReportBlinkFeatureUsage_Sym::IPCStableHash;
    }
    case messages::LocalFrame::kRenderFallbackContent: {
        return &LocalFrame::RenderFallbackContent_Sym::IPCStableHash;
    }
    case messages::LocalFrame::kBeforeUnload: {
        return &LocalFrame::BeforeUnload_Sym::IPCStableHash;
    }
    case messages::LocalFrame::kMediaPlayerActionAt: {
        return &LocalFrame::MediaPlayerActionAt_Sym::IPCStableHash;
    }
    case messages::LocalFrame::kRequestVideoFrameAtWithBoundsHint: {
        return &LocalFrame::RequestVideoFrameAtWithBoundsHint_Sym::IPCStableHash;
    }
    case messages::LocalFrame::kPluginActionAt: {
        return &LocalFrame::PluginActionAt_Sym::IPCStableHash;
    }
    case messages::LocalFrame::kAdvanceFocusInFrame: {
        return &LocalFrame::AdvanceFocusInFrame_Sym::IPCStableHash;
    }
    case messages::LocalFrame::kAdvanceFocusForIME: {
        return &LocalFrame::AdvanceFocusForIME_Sym::IPCStableHash;
    }
    case messages::LocalFrame::kReportContentSecurityPolicyViolation: {
        return &LocalFrame::ReportContentSecurityPolicyViolation_Sym::IPCStableHash;
    }
    case messages::LocalFrame::kDidUpdateFramePolicy: {
        return &LocalFrame::DidUpdateFramePolicy_Sym::IPCStableHash;
    }
    case messages::LocalFrame::kOnFrameVisibilityChanged: {
        return &LocalFrame::OnFrameVisibilityChanged_Sym::IPCStableHash;
    }
    case messages::LocalFrame::kPostMessageEvent: {
        return &LocalFrame::PostMessageEvent_Sym::IPCStableHash;
    }
    case messages::LocalFrame::kJavaScriptMethodExecuteRequest: {
        return &LocalFrame::JavaScriptMethodExecuteRequest_Sym::IPCStableHash;
    }
    case messages::LocalFrame::kJavaScriptExecuteRequest: {
        return &LocalFrame::JavaScriptExecuteRequest_Sym::IPCStableHash;
    }
    case messages::LocalFrame::kJavaScriptExecuteRequestForTests: {
        return &LocalFrame::JavaScriptExecuteRequestForTests_Sym::IPCStableHash;
    }
    case messages::LocalFrame::kJavaScriptExecuteRequestInIsolatedWorld: {
        return &LocalFrame::JavaScriptExecuteRequestInIsolatedWorld_Sym::IPCStableHash;
    }
    case messages::LocalFrame::kBindReportingObserver: {
        return &LocalFrame::BindReportingObserver_Sym::IPCStableHash;
    }
    case messages::LocalFrame::kUpdateOpener: {
        return &LocalFrame::UpdateOpener_Sym::IPCStableHash;
    }
    case messages::LocalFrame::kGetSavableResourceLinks: {
        return &LocalFrame::GetSavableResourceLinks_Sym::IPCStableHash;
    }
    case messages::LocalFrame::kMixedContentFound: {
        return &LocalFrame::MixedContentFound_Sym::IPCStableHash;
    }
    case messages::LocalFrame::kBindDevToolsAgent: {
        return &LocalFrame::BindDevToolsAgent_Sym::IPCStableHash;
    }
    case messages::LocalFrame::kHandleRendererDebugURL: {
        return &LocalFrame::HandleRendererDebugURL_Sym::IPCStableHash;
    }
    case messages::LocalFrame::kGetCanonicalUrlForSharing: {
        return &LocalFrame::GetCanonicalUrlForSharing_Sym::IPCStableHash;
    }
    case messages::LocalFrame::kGetOpenGraphMetadata: {
        return &LocalFrame::GetOpenGraphMetadata_Sym::IPCStableHash;
    }
    case messages::LocalFrame::kSetNavigationApiHistoryEntriesForRestore: {
        return &LocalFrame::SetNavigationApiHistoryEntriesForRestore_Sym::IPCStableHash;
    }
    case messages::LocalFrame::kUpdatePrerenderURL: {
        return &LocalFrame::UpdatePrerenderURL_Sym::IPCStableHash;
    }
    case messages::LocalFrame::kNotifyNavigationApiOfDisposedEntries: {
        return &LocalFrame::NotifyNavigationApiOfDisposedEntries_Sym::IPCStableHash;
    }
    case messages::LocalFrame::kTraverseCancelled: {
        return &LocalFrame::TraverseCancelled_Sym::IPCStableHash;
    }
    case messages::LocalFrame::kDispatchNavigateEventForCrossDocumentTraversal: {
        return &LocalFrame::DispatchNavigateEventForCrossDocumentTraversal_Sym::IPCStableHash;
    }
    case messages::LocalFrame::kSnapshotDocumentForViewTransition: {
        return &LocalFrame::SnapshotDocumentForViewTransition_Sym::IPCStableHash;
    }
    case messages::LocalFrame::kNotifyViewTransitionAbortedToOldDocument: {
        return &LocalFrame::NotifyViewTransitionAbortedToOldDocument_Sym::IPCStableHash;
    }
    case messages::LocalFrame::kDispatchPageSwap: {
        return &LocalFrame::DispatchPageSwap_Sym::IPCStableHash;
    }
    case messages::LocalFrame::kAddResourceTimingEntryForFailedSubframeNavigation: {
        return &LocalFrame::AddResourceTimingEntryForFailedSubframeNavigation_Sym::IPCStableHash;
    }
    }
#endif // !BUILDFLAG(IS_FUCHSIA)
    return nullptr;
}

const char* LocalFrame::MessageToMethodName_(mojo::Message& message)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
    if (!is_response) {
        switch (static_cast<messages::LocalFrame>(message.name())) {
        case messages::LocalFrame::kGetTextSurroundingSelection:
            return "Receive blink::mojom::LocalFrame::GetTextSurroundingSelection";
        case messages::LocalFrame::kSendInterventionReport:
            return "Receive blink::mojom::LocalFrame::SendInterventionReport";
        case messages::LocalFrame::kSetFrameOwnerProperties:
            return "Receive blink::mojom::LocalFrame::SetFrameOwnerProperties";
        case messages::LocalFrame::kNotifyUserActivation:
            return "Receive blink::mojom::LocalFrame::NotifyUserActivation";
        case messages::LocalFrame::kNotifyVirtualKeyboardOverlayRect:
            return "Receive blink::mojom::LocalFrame::NotifyVirtualKeyboardOverlayRect";
        case messages::LocalFrame::kAddMessageToConsole:
            return "Receive blink::mojom::LocalFrame::AddMessageToConsole";
        case messages::LocalFrame::kSwapInImmediately:
            return "Receive blink::mojom::LocalFrame::SwapInImmediately";
        case messages::LocalFrame::kCheckCompleted:
            return "Receive blink::mojom::LocalFrame::CheckCompleted";
        case messages::LocalFrame::kStopLoading:
            return "Receive blink::mojom::LocalFrame::StopLoading";
        case messages::LocalFrame::kCollapse:
            return "Receive blink::mojom::LocalFrame::Collapse";
        case messages::LocalFrame::kEnableViewSourceMode:
            return "Receive blink::mojom::LocalFrame::EnableViewSourceMode";
        case messages::LocalFrame::kFocus:
            return "Receive blink::mojom::LocalFrame::Focus";
        case messages::LocalFrame::kClearFocusedElement:
            return "Receive blink::mojom::LocalFrame::ClearFocusedElement";
        case messages::LocalFrame::kCopyImageAt:
            return "Receive blink::mojom::LocalFrame::CopyImageAt";
        case messages::LocalFrame::kSaveImageAt:
            return "Receive blink::mojom::LocalFrame::SaveImageAt";
        case messages::LocalFrame::kReportBlinkFeatureUsage:
            return "Receive blink::mojom::LocalFrame::ReportBlinkFeatureUsage";
        case messages::LocalFrame::kRenderFallbackContent:
            return "Receive blink::mojom::LocalFrame::RenderFallbackContent";
        case messages::LocalFrame::kBeforeUnload:
            return "Receive blink::mojom::LocalFrame::BeforeUnload";
        case messages::LocalFrame::kMediaPlayerActionAt:
            return "Receive blink::mojom::LocalFrame::MediaPlayerActionAt";
        case messages::LocalFrame::kRequestVideoFrameAtWithBoundsHint:
            return "Receive blink::mojom::LocalFrame::RequestVideoFrameAtWithBoundsHint";
        case messages::LocalFrame::kPluginActionAt:
            return "Receive blink::mojom::LocalFrame::PluginActionAt";
        case messages::LocalFrame::kAdvanceFocusInFrame:
            return "Receive blink::mojom::LocalFrame::AdvanceFocusInFrame";
        case messages::LocalFrame::kAdvanceFocusForIME:
            return "Receive blink::mojom::LocalFrame::AdvanceFocusForIME";
        case messages::LocalFrame::kReportContentSecurityPolicyViolation:
            return "Receive blink::mojom::LocalFrame::ReportContentSecurityPolicyViolation";
        case messages::LocalFrame::kDidUpdateFramePolicy:
            return "Receive blink::mojom::LocalFrame::DidUpdateFramePolicy";
        case messages::LocalFrame::kOnFrameVisibilityChanged:
            return "Receive blink::mojom::LocalFrame::OnFrameVisibilityChanged";
        case messages::LocalFrame::kPostMessageEvent:
            return "Receive blink::mojom::LocalFrame::PostMessageEvent";
        case messages::LocalFrame::kJavaScriptMethodExecuteRequest:
            return "Receive blink::mojom::LocalFrame::JavaScriptMethodExecuteRequest";
        case messages::LocalFrame::kJavaScriptExecuteRequest:
            return "Receive blink::mojom::LocalFrame::JavaScriptExecuteRequest";
        case messages::LocalFrame::kJavaScriptExecuteRequestForTests:
            return "Receive blink::mojom::LocalFrame::JavaScriptExecuteRequestForTests";
        case messages::LocalFrame::kJavaScriptExecuteRequestInIsolatedWorld:
            return "Receive blink::mojom::LocalFrame::JavaScriptExecuteRequestInIsolatedWorld";
        case messages::LocalFrame::kBindReportingObserver:
            return "Receive blink::mojom::LocalFrame::BindReportingObserver";
        case messages::LocalFrame::kUpdateOpener:
            return "Receive blink::mojom::LocalFrame::UpdateOpener";
        case messages::LocalFrame::kGetSavableResourceLinks:
            return "Receive blink::mojom::LocalFrame::GetSavableResourceLinks";
        case messages::LocalFrame::kMixedContentFound:
            return "Receive blink::mojom::LocalFrame::MixedContentFound";
        case messages::LocalFrame::kBindDevToolsAgent:
            return "Receive blink::mojom::LocalFrame::BindDevToolsAgent";
        case messages::LocalFrame::kHandleRendererDebugURL:
            return "Receive blink::mojom::LocalFrame::HandleRendererDebugURL";
        case messages::LocalFrame::kGetCanonicalUrlForSharing:
            return "Receive blink::mojom::LocalFrame::GetCanonicalUrlForSharing";
        case messages::LocalFrame::kGetOpenGraphMetadata:
            return "Receive blink::mojom::LocalFrame::GetOpenGraphMetadata";
        case messages::LocalFrame::kSetNavigationApiHistoryEntriesForRestore:
            return "Receive blink::mojom::LocalFrame::SetNavigationApiHistoryEntriesForRestore";
        case messages::LocalFrame::kUpdatePrerenderURL:
            return "Receive blink::mojom::LocalFrame::UpdatePrerenderURL";
        case messages::LocalFrame::kNotifyNavigationApiOfDisposedEntries:
            return "Receive blink::mojom::LocalFrame::NotifyNavigationApiOfDisposedEntries";
        case messages::LocalFrame::kTraverseCancelled:
            return "Receive blink::mojom::LocalFrame::TraverseCancelled";
        case messages::LocalFrame::kDispatchNavigateEventForCrossDocumentTraversal:
            return "Receive blink::mojom::LocalFrame::DispatchNavigateEventForCrossDocumentTraversal";
        case messages::LocalFrame::kSnapshotDocumentForViewTransition:
            return "Receive blink::mojom::LocalFrame::SnapshotDocumentForViewTransition";
        case messages::LocalFrame::kNotifyViewTransitionAbortedToOldDocument:
            return "Receive blink::mojom::LocalFrame::NotifyViewTransitionAbortedToOldDocument";
        case messages::LocalFrame::kDispatchPageSwap:
            return "Receive blink::mojom::LocalFrame::DispatchPageSwap";
        case messages::LocalFrame::kAddResourceTimingEntryForFailedSubframeNavigation:
            return "Receive blink::mojom::LocalFrame::AddResourceTimingEntryForFailedSubframeNavigation";
        }
    } else {
        switch (static_cast<messages::LocalFrame>(message.name())) {
        case messages::LocalFrame::kGetTextSurroundingSelection:
            return "Receive reply blink::mojom::LocalFrame::GetTextSurroundingSelection";
        case messages::LocalFrame::kSendInterventionReport:
            return "Receive reply blink::mojom::LocalFrame::SendInterventionReport";
        case messages::LocalFrame::kSetFrameOwnerProperties:
            return "Receive reply blink::mojom::LocalFrame::SetFrameOwnerProperties";
        case messages::LocalFrame::kNotifyUserActivation:
            return "Receive reply blink::mojom::LocalFrame::NotifyUserActivation";
        case messages::LocalFrame::kNotifyVirtualKeyboardOverlayRect:
            return "Receive reply blink::mojom::LocalFrame::NotifyVirtualKeyboardOverlayRect";
        case messages::LocalFrame::kAddMessageToConsole:
            return "Receive reply blink::mojom::LocalFrame::AddMessageToConsole";
        case messages::LocalFrame::kSwapInImmediately:
            return "Receive reply blink::mojom::LocalFrame::SwapInImmediately";
        case messages::LocalFrame::kCheckCompleted:
            return "Receive reply blink::mojom::LocalFrame::CheckCompleted";
        case messages::LocalFrame::kStopLoading:
            return "Receive reply blink::mojom::LocalFrame::StopLoading";
        case messages::LocalFrame::kCollapse:
            return "Receive reply blink::mojom::LocalFrame::Collapse";
        case messages::LocalFrame::kEnableViewSourceMode:
            return "Receive reply blink::mojom::LocalFrame::EnableViewSourceMode";
        case messages::LocalFrame::kFocus:
            return "Receive reply blink::mojom::LocalFrame::Focus";
        case messages::LocalFrame::kClearFocusedElement:
            return "Receive reply blink::mojom::LocalFrame::ClearFocusedElement";
        case messages::LocalFrame::kCopyImageAt:
            return "Receive reply blink::mojom::LocalFrame::CopyImageAt";
        case messages::LocalFrame::kSaveImageAt:
            return "Receive reply blink::mojom::LocalFrame::SaveImageAt";
        case messages::LocalFrame::kReportBlinkFeatureUsage:
            return "Receive reply blink::mojom::LocalFrame::ReportBlinkFeatureUsage";
        case messages::LocalFrame::kRenderFallbackContent:
            return "Receive reply blink::mojom::LocalFrame::RenderFallbackContent";
        case messages::LocalFrame::kBeforeUnload:
            return "Receive reply blink::mojom::LocalFrame::BeforeUnload";
        case messages::LocalFrame::kMediaPlayerActionAt:
            return "Receive reply blink::mojom::LocalFrame::MediaPlayerActionAt";
        case messages::LocalFrame::kRequestVideoFrameAtWithBoundsHint:
            return "Receive reply blink::mojom::LocalFrame::RequestVideoFrameAtWithBoundsHint";
        case messages::LocalFrame::kPluginActionAt:
            return "Receive reply blink::mojom::LocalFrame::PluginActionAt";
        case messages::LocalFrame::kAdvanceFocusInFrame:
            return "Receive reply blink::mojom::LocalFrame::AdvanceFocusInFrame";
        case messages::LocalFrame::kAdvanceFocusForIME:
            return "Receive reply blink::mojom::LocalFrame::AdvanceFocusForIME";
        case messages::LocalFrame::kReportContentSecurityPolicyViolation:
            return "Receive reply blink::mojom::LocalFrame::ReportContentSecurityPolicyViolation";
        case messages::LocalFrame::kDidUpdateFramePolicy:
            return "Receive reply blink::mojom::LocalFrame::DidUpdateFramePolicy";
        case messages::LocalFrame::kOnFrameVisibilityChanged:
            return "Receive reply blink::mojom::LocalFrame::OnFrameVisibilityChanged";
        case messages::LocalFrame::kPostMessageEvent:
            return "Receive reply blink::mojom::LocalFrame::PostMessageEvent";
        case messages::LocalFrame::kJavaScriptMethodExecuteRequest:
            return "Receive reply blink::mojom::LocalFrame::JavaScriptMethodExecuteRequest";
        case messages::LocalFrame::kJavaScriptExecuteRequest:
            return "Receive reply blink::mojom::LocalFrame::JavaScriptExecuteRequest";
        case messages::LocalFrame::kJavaScriptExecuteRequestForTests:
            return "Receive reply blink::mojom::LocalFrame::JavaScriptExecuteRequestForTests";
        case messages::LocalFrame::kJavaScriptExecuteRequestInIsolatedWorld:
            return "Receive reply blink::mojom::LocalFrame::JavaScriptExecuteRequestInIsolatedWorld";
        case messages::LocalFrame::kBindReportingObserver:
            return "Receive reply blink::mojom::LocalFrame::BindReportingObserver";
        case messages::LocalFrame::kUpdateOpener:
            return "Receive reply blink::mojom::LocalFrame::UpdateOpener";
        case messages::LocalFrame::kGetSavableResourceLinks:
            return "Receive reply blink::mojom::LocalFrame::GetSavableResourceLinks";
        case messages::LocalFrame::kMixedContentFound:
            return "Receive reply blink::mojom::LocalFrame::MixedContentFound";
        case messages::LocalFrame::kBindDevToolsAgent:
            return "Receive reply blink::mojom::LocalFrame::BindDevToolsAgent";
        case messages::LocalFrame::kHandleRendererDebugURL:
            return "Receive reply blink::mojom::LocalFrame::HandleRendererDebugURL";
        case messages::LocalFrame::kGetCanonicalUrlForSharing:
            return "Receive reply blink::mojom::LocalFrame::GetCanonicalUrlForSharing";
        case messages::LocalFrame::kGetOpenGraphMetadata:
            return "Receive reply blink::mojom::LocalFrame::GetOpenGraphMetadata";
        case messages::LocalFrame::kSetNavigationApiHistoryEntriesForRestore:
            return "Receive reply blink::mojom::LocalFrame::SetNavigationApiHistoryEntriesForRestore";
        case messages::LocalFrame::kUpdatePrerenderURL:
            return "Receive reply blink::mojom::LocalFrame::UpdatePrerenderURL";
        case messages::LocalFrame::kNotifyNavigationApiOfDisposedEntries:
            return "Receive reply blink::mojom::LocalFrame::NotifyNavigationApiOfDisposedEntries";
        case messages::LocalFrame::kTraverseCancelled:
            return "Receive reply blink::mojom::LocalFrame::TraverseCancelled";
        case messages::LocalFrame::kDispatchNavigateEventForCrossDocumentTraversal:
            return "Receive reply blink::mojom::LocalFrame::DispatchNavigateEventForCrossDocumentTraversal";
        case messages::LocalFrame::kSnapshotDocumentForViewTransition:
            return "Receive reply blink::mojom::LocalFrame::SnapshotDocumentForViewTransition";
        case messages::LocalFrame::kNotifyViewTransitionAbortedToOldDocument:
            return "Receive reply blink::mojom::LocalFrame::NotifyViewTransitionAbortedToOldDocument";
        case messages::LocalFrame::kDispatchPageSwap:
            return "Receive reply blink::mojom::LocalFrame::DispatchPageSwap";
        case messages::LocalFrame::kAddResourceTimingEntryForFailedSubframeNavigation:
            return "Receive reply blink::mojom::LocalFrame::AddResourceTimingEntryForFailedSubframeNavigation";
        }
    }
    return "Receive unknown mojo message";
#else
    bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
    if (is_response) {
        return "Receive mojo reply";
    } else {
        return "Receive mojo message";
    }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t LocalFrame::GetTextSurroundingSelection_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrame::GetTextSurroundingSelection");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrame::SendInterventionReport_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrame::SendInterventionReport");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrame::SetFrameOwnerProperties_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrame::SetFrameOwnerProperties");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrame::NotifyUserActivation_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrame::NotifyUserActivation");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrame::NotifyVirtualKeyboardOverlayRect_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrame::NotifyVirtualKeyboardOverlayRect");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrame::AddMessageToConsole_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrame::AddMessageToConsole");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrame::SwapInImmediately_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrame::SwapInImmediately");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrame::CheckCompleted_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrame::CheckCompleted");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrame::StopLoading_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrame::StopLoading");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrame::Collapse_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrame::Collapse");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrame::EnableViewSourceMode_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrame::EnableViewSourceMode");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrame::Focus_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrame::Focus");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrame::ClearFocusedElement_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrame::ClearFocusedElement");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrame::CopyImageAt_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrame::CopyImageAt");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrame::SaveImageAt_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrame::SaveImageAt");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrame::ReportBlinkFeatureUsage_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrame::ReportBlinkFeatureUsage");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrame::RenderFallbackContent_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrame::RenderFallbackContent");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrame::BeforeUnload_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrame::BeforeUnload");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrame::MediaPlayerActionAt_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrame::MediaPlayerActionAt");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrame::RequestVideoFrameAtWithBoundsHint_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrame::RequestVideoFrameAtWithBoundsHint");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrame::PluginActionAt_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrame::PluginActionAt");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrame::AdvanceFocusInFrame_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrame::AdvanceFocusInFrame");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrame::AdvanceFocusForIME_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrame::AdvanceFocusForIME");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrame::ReportContentSecurityPolicyViolation_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrame::ReportContentSecurityPolicyViolation");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrame::DidUpdateFramePolicy_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrame::DidUpdateFramePolicy");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrame::OnFrameVisibilityChanged_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrame::OnFrameVisibilityChanged");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrame::PostMessageEvent_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrame::PostMessageEvent");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrame::JavaScriptMethodExecuteRequest_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrame::JavaScriptMethodExecuteRequest");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrame::JavaScriptExecuteRequest_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrame::JavaScriptExecuteRequest");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrame::JavaScriptExecuteRequestForTests_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrame::JavaScriptExecuteRequestForTests");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrame::JavaScriptExecuteRequestInIsolatedWorld_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrame::JavaScriptExecuteRequestInIsolatedWorld");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrame::BindReportingObserver_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrame::BindReportingObserver");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrame::UpdateOpener_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrame::UpdateOpener");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrame::GetSavableResourceLinks_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrame::GetSavableResourceLinks");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrame::MixedContentFound_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrame::MixedContentFound");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrame::BindDevToolsAgent_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrame::BindDevToolsAgent");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrame::HandleRendererDebugURL_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrame::HandleRendererDebugURL");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrame::GetCanonicalUrlForSharing_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrame::GetCanonicalUrlForSharing");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrame::GetOpenGraphMetadata_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrame::GetOpenGraphMetadata");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrame::SetNavigationApiHistoryEntriesForRestore_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrame::SetNavigationApiHistoryEntriesForRestore");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrame::UpdatePrerenderURL_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrame::UpdatePrerenderURL");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrame::NotifyNavigationApiOfDisposedEntries_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrame::NotifyNavigationApiOfDisposedEntries");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrame::TraverseCancelled_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrame::TraverseCancelled");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrame::DispatchNavigateEventForCrossDocumentTraversal_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrame::DispatchNavigateEventForCrossDocumentTraversal");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrame::SnapshotDocumentForViewTransition_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrame::SnapshotDocumentForViewTransition");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrame::NotifyViewTransitionAbortedToOldDocument_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrame::NotifyViewTransitionAbortedToOldDocument");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrame::DispatchPageSwap_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrame::DispatchPageSwap");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalFrame::AddResourceTimingEntryForFailedSubframeNavigation_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalFrame::AddResourceTimingEntryForFailedSubframeNavigation");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
#endif // !BUILDFLAG(IS_FUCHSIA)

class LocalFrame_GetTextSurroundingSelection_ForwardToCallback : public mojo::MessageReceiver {
public:
    LocalFrame_GetTextSurroundingSelection_ForwardToCallback(LocalFrame::GetTextSurroundingSelectionCallback callback)
        : callback_(std::move(callback))
    {
    }

    LocalFrame_GetTextSurroundingSelection_ForwardToCallback(const LocalFrame_GetTextSurroundingSelection_ForwardToCallback&) = delete;
    LocalFrame_GetTextSurroundingSelection_ForwardToCallback& operator=(const LocalFrame_GetTextSurroundingSelection_ForwardToCallback&) = delete;

    bool Accept(mojo::Message* message) override;

private:
    LocalFrame::GetTextSurroundingSelectionCallback callback_;
};

class LocalFrame_BeforeUnload_ForwardToCallback : public mojo::MessageReceiver {
public:
    LocalFrame_BeforeUnload_ForwardToCallback(LocalFrame::BeforeUnloadCallback callback)
        : callback_(std::move(callback))
    {
    }

    LocalFrame_BeforeUnload_ForwardToCallback(const LocalFrame_BeforeUnload_ForwardToCallback&) = delete;
    LocalFrame_BeforeUnload_ForwardToCallback& operator=(const LocalFrame_BeforeUnload_ForwardToCallback&) = delete;

    bool Accept(mojo::Message* message) override;

private:
    LocalFrame::BeforeUnloadCallback callback_;
};

class LocalFrame_RequestVideoFrameAtWithBoundsHint_ForwardToCallback : public mojo::MessageReceiver {
public:
    LocalFrame_RequestVideoFrameAtWithBoundsHint_ForwardToCallback(LocalFrame::RequestVideoFrameAtWithBoundsHintCallback callback)
        : callback_(std::move(callback))
    {
    }

    LocalFrame_RequestVideoFrameAtWithBoundsHint_ForwardToCallback(const LocalFrame_RequestVideoFrameAtWithBoundsHint_ForwardToCallback&) = delete;
    LocalFrame_RequestVideoFrameAtWithBoundsHint_ForwardToCallback& operator=(const LocalFrame_RequestVideoFrameAtWithBoundsHint_ForwardToCallback&) = delete;

    bool Accept(mojo::Message* message) override;

private:
    LocalFrame::RequestVideoFrameAtWithBoundsHintCallback callback_;
};

class LocalFrame_JavaScriptMethodExecuteRequest_ForwardToCallback : public mojo::MessageReceiver {
public:
    LocalFrame_JavaScriptMethodExecuteRequest_ForwardToCallback(LocalFrame::JavaScriptMethodExecuteRequestCallback callback)
        : callback_(std::move(callback))
    {
    }

    LocalFrame_JavaScriptMethodExecuteRequest_ForwardToCallback(const LocalFrame_JavaScriptMethodExecuteRequest_ForwardToCallback&) = delete;
    LocalFrame_JavaScriptMethodExecuteRequest_ForwardToCallback& operator=(const LocalFrame_JavaScriptMethodExecuteRequest_ForwardToCallback&) = delete;

    bool Accept(mojo::Message* message) override;

private:
    LocalFrame::JavaScriptMethodExecuteRequestCallback callback_;
};

class LocalFrame_JavaScriptExecuteRequest_ForwardToCallback : public mojo::MessageReceiver {
public:
    LocalFrame_JavaScriptExecuteRequest_ForwardToCallback(LocalFrame::JavaScriptExecuteRequestCallback callback)
        : callback_(std::move(callback))
    {
    }

    LocalFrame_JavaScriptExecuteRequest_ForwardToCallback(const LocalFrame_JavaScriptExecuteRequest_ForwardToCallback&) = delete;
    LocalFrame_JavaScriptExecuteRequest_ForwardToCallback& operator=(const LocalFrame_JavaScriptExecuteRequest_ForwardToCallback&) = delete;

    bool Accept(mojo::Message* message) override;

private:
    LocalFrame::JavaScriptExecuteRequestCallback callback_;
};

class LocalFrame_JavaScriptExecuteRequestForTests_ForwardToCallback : public mojo::MessageReceiver {
public:
    LocalFrame_JavaScriptExecuteRequestForTests_ForwardToCallback(LocalFrame::JavaScriptExecuteRequestForTestsCallback callback)
        : callback_(std::move(callback))
    {
    }

    LocalFrame_JavaScriptExecuteRequestForTests_ForwardToCallback(const LocalFrame_JavaScriptExecuteRequestForTests_ForwardToCallback&) = delete;
    LocalFrame_JavaScriptExecuteRequestForTests_ForwardToCallback& operator=(const LocalFrame_JavaScriptExecuteRequestForTests_ForwardToCallback&) = delete;

    bool Accept(mojo::Message* message) override;

private:
    LocalFrame::JavaScriptExecuteRequestForTestsCallback callback_;
};

class LocalFrame_JavaScriptExecuteRequestInIsolatedWorld_ForwardToCallback : public mojo::MessageReceiver {
public:
    LocalFrame_JavaScriptExecuteRequestInIsolatedWorld_ForwardToCallback(LocalFrame::JavaScriptExecuteRequestInIsolatedWorldCallback callback)
        : callback_(std::move(callback))
    {
    }

    LocalFrame_JavaScriptExecuteRequestInIsolatedWorld_ForwardToCallback(const LocalFrame_JavaScriptExecuteRequestInIsolatedWorld_ForwardToCallback&) = delete;
    LocalFrame_JavaScriptExecuteRequestInIsolatedWorld_ForwardToCallback& operator=(const LocalFrame_JavaScriptExecuteRequestInIsolatedWorld_ForwardToCallback&)
        = delete;

    bool Accept(mojo::Message* message) override;

private:
    LocalFrame::JavaScriptExecuteRequestInIsolatedWorldCallback callback_;
};

class LocalFrame_GetSavableResourceLinks_ForwardToCallback : public mojo::MessageReceiver {
public:
    LocalFrame_GetSavableResourceLinks_ForwardToCallback(LocalFrame::GetSavableResourceLinksCallback callback)
        : callback_(std::move(callback))
    {
    }

    LocalFrame_GetSavableResourceLinks_ForwardToCallback(const LocalFrame_GetSavableResourceLinks_ForwardToCallback&) = delete;
    LocalFrame_GetSavableResourceLinks_ForwardToCallback& operator=(const LocalFrame_GetSavableResourceLinks_ForwardToCallback&) = delete;

    bool Accept(mojo::Message* message) override;

private:
    LocalFrame::GetSavableResourceLinksCallback callback_;
};

class LocalFrame_GetCanonicalUrlForSharing_ForwardToCallback : public mojo::MessageReceiver {
public:
    LocalFrame_GetCanonicalUrlForSharing_ForwardToCallback(LocalFrame::GetCanonicalUrlForSharingCallback callback)
        : callback_(std::move(callback))
    {
    }

    LocalFrame_GetCanonicalUrlForSharing_ForwardToCallback(const LocalFrame_GetCanonicalUrlForSharing_ForwardToCallback&) = delete;
    LocalFrame_GetCanonicalUrlForSharing_ForwardToCallback& operator=(const LocalFrame_GetCanonicalUrlForSharing_ForwardToCallback&) = delete;

    bool Accept(mojo::Message* message) override;

private:
    LocalFrame::GetCanonicalUrlForSharingCallback callback_;
};

class LocalFrame_GetOpenGraphMetadata_ForwardToCallback : public mojo::MessageReceiver {
public:
    LocalFrame_GetOpenGraphMetadata_ForwardToCallback(LocalFrame::GetOpenGraphMetadataCallback callback)
        : callback_(std::move(callback))
    {
    }

    LocalFrame_GetOpenGraphMetadata_ForwardToCallback(const LocalFrame_GetOpenGraphMetadata_ForwardToCallback&) = delete;
    LocalFrame_GetOpenGraphMetadata_ForwardToCallback& operator=(const LocalFrame_GetOpenGraphMetadata_ForwardToCallback&) = delete;

    bool Accept(mojo::Message* message) override;

private:
    LocalFrame::GetOpenGraphMetadataCallback callback_;
};

class LocalFrame_UpdatePrerenderURL_ForwardToCallback : public mojo::MessageReceiver {
public:
    LocalFrame_UpdatePrerenderURL_ForwardToCallback(LocalFrame::UpdatePrerenderURLCallback callback)
        : callback_(std::move(callback))
    {
    }

    LocalFrame_UpdatePrerenderURL_ForwardToCallback(const LocalFrame_UpdatePrerenderURL_ForwardToCallback&) = delete;
    LocalFrame_UpdatePrerenderURL_ForwardToCallback& operator=(const LocalFrame_UpdatePrerenderURL_ForwardToCallback&) = delete;

    bool Accept(mojo::Message* message) override;

private:
    LocalFrame::UpdatePrerenderURLCallback callback_;
};

class LocalFrame_SnapshotDocumentForViewTransition_ForwardToCallback : public mojo::MessageReceiver {
public:
    LocalFrame_SnapshotDocumentForViewTransition_ForwardToCallback(LocalFrame::SnapshotDocumentForViewTransitionCallback callback)
        : callback_(std::move(callback))
    {
    }

    LocalFrame_SnapshotDocumentForViewTransition_ForwardToCallback(const LocalFrame_SnapshotDocumentForViewTransition_ForwardToCallback&) = delete;
    LocalFrame_SnapshotDocumentForViewTransition_ForwardToCallback& operator=(const LocalFrame_SnapshotDocumentForViewTransition_ForwardToCallback&) = delete;

    bool Accept(mojo::Message* message) override;

private:
    LocalFrame::SnapshotDocumentForViewTransitionCallback callback_;
};

LocalFrameProxy::LocalFrameProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver)
{
}

void LocalFrameProxy::GetTextSurroundingSelection(uint32_t in_max_length, GetTextSurroundingSelectionCallback callback)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrame::GetTextSurroundingSelection", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("max_length"), in_max_length, "<value of type uint32_t>");
    });
#endif

    const bool kExpectsResponse = true;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrame::kGetTextSurroundingSelection), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrame_GetTextSurroundingSelection_Params_Data> params(message);
    params.Allocate();
    params->max_length = in_max_length;

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrame::Name_);
    message.set_method_name("GetTextSurroundingSelection");
#endif
    std::unique_ptr<mojo::MessageReceiver> responder(new LocalFrame_GetTextSurroundingSelection_ForwardToCallback(std::move(callback)));
    ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void LocalFrameProxy::SendInterventionReport(const WTF::String& in_id, const WTF::String& in_message)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrame::SendInterventionReport", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("id"), in_id, "<value of type const WTF::String&>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("message"), in_message, "<value of type const WTF::String&>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrame::kSendInterventionReport), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrame_SendInterventionReport_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->id)::BaseType> id_fragment(params.message());
    mojo::internal::Serialize<mojo::StringDataView>(in_id, id_fragment);
    params->id.Set(id_fragment.is_null() ? nullptr : id_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->id.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null id in LocalFrame.SendInterventionReport request");
    mojo::internal::MessageFragment<typename decltype(params->message)::BaseType> message_fragment(params.message());
    mojo::internal::Serialize<mojo::StringDataView>(in_message, message_fragment);
    params->message.Set(message_fragment.is_null() ? nullptr : message_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->message.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null message in LocalFrame.SendInterventionReport request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrame::Name_);
    message.set_method_name("SendInterventionReport");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameProxy::SetFrameOwnerProperties(::blink::mojom::blink::FrameOwnerPropertiesPtr in_properties)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrame::SetFrameOwnerProperties", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("properties"), in_properties, "<value of type ::blink::mojom::blink::FrameOwnerPropertiesPtr>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrame::kSetFrameOwnerProperties), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrame_SetFrameOwnerProperties_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->properties)::BaseType> properties_fragment(params.message());
    mojo::internal::Serialize<::blink::mojom::FrameOwnerPropertiesDataView>(in_properties, properties_fragment);
    params->properties.Set(properties_fragment.is_null() ? nullptr : properties_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->properties.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null properties in LocalFrame.SetFrameOwnerProperties request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrame::Name_);
    message.set_method_name("SetFrameOwnerProperties");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameProxy::NotifyUserActivation(::blink::mojom::blink::UserActivationNotificationType in_notification_type)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrame::NotifyUserActivation", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(
            dict.AddItem("notification_type"), in_notification_type, "<value of type ::blink::mojom::blink::UserActivationNotificationType>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrame::kNotifyUserActivation), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrame_NotifyUserActivation_Params_Data> params(message);
    params.Allocate();
    mojo::internal::Serialize<::blink::mojom::UserActivationNotificationType>(in_notification_type, &params->notification_type);

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrame::Name_);
    message.set_method_name("NotifyUserActivation");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameProxy::NotifyVirtualKeyboardOverlayRect(const ::gfx::Rect& in_keyboard_rect)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrame::NotifyVirtualKeyboardOverlayRect", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("keyboard_rect"), in_keyboard_rect, "<value of type const ::gfx::Rect&>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrame::kNotifyVirtualKeyboardOverlayRect), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrame_NotifyVirtualKeyboardOverlayRect_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->keyboard_rect)::BaseType> keyboard_rect_fragment(params.message());
    mojo::internal::Serialize<::gfx::mojom::RectDataView>(in_keyboard_rect, keyboard_rect_fragment);
    params->keyboard_rect.Set(keyboard_rect_fragment.is_null() ? nullptr : keyboard_rect_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->keyboard_rect.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null keyboard_rect in LocalFrame.NotifyVirtualKeyboardOverlayRect request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrame::Name_);
    message.set_method_name("NotifyVirtualKeyboardOverlayRect");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameProxy::AddMessageToConsole(::blink::mojom::blink::ConsoleMessageLevel in_level, const WTF::String& in_message, bool in_discard_duplicates)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrame::AddMessageToConsole", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("level"), in_level, "<value of type ::blink::mojom::blink::ConsoleMessageLevel>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("message"), in_message, "<value of type const WTF::String&>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("discard_duplicates"), in_discard_duplicates, "<value of type bool>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrame::kAddMessageToConsole), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrame_AddMessageToConsole_Params_Data> params(message);
    params.Allocate();
    mojo::internal::Serialize<::blink::mojom::ConsoleMessageLevel>(in_level, &params->level);
    mojo::internal::MessageFragment<typename decltype(params->message)::BaseType> message_fragment(params.message());
    mojo::internal::Serialize<mojo::StringDataView>(in_message, message_fragment);
    params->message.Set(message_fragment.is_null() ? nullptr : message_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->message.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null message in LocalFrame.AddMessageToConsole request");
    params->discard_duplicates = in_discard_duplicates;

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrame::Name_);
    message.set_method_name("AddMessageToConsole");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameProxy::SwapInImmediately()
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT0("mojom", "Send blink::mojom::LocalFrame::SwapInImmediately");
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrame::kSwapInImmediately), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrame_SwapInImmediately_Params_Data> params(message);
    params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrame::Name_);
    message.set_method_name("SwapInImmediately");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameProxy::CheckCompleted()
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT0("mojom", "Send blink::mojom::LocalFrame::CheckCompleted");
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrame::kCheckCompleted), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrame_CheckCompleted_Params_Data> params(message);
    params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrame::Name_);
    message.set_method_name("CheckCompleted");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameProxy::StopLoading()
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT0("mojom", "Send blink::mojom::LocalFrame::StopLoading");
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrame::kStopLoading), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrame_StopLoading_Params_Data> params(message);
    params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrame::Name_);
    message.set_method_name("StopLoading");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameProxy::Collapse(bool in_collapsed)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrame::Collapse", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("collapsed"), in_collapsed, "<value of type bool>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrame::kCollapse), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrame_Collapse_Params_Data> params(message);
    params.Allocate();
    params->collapsed = in_collapsed;

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrame::Name_);
    message.set_method_name("Collapse");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameProxy::EnableViewSourceMode()
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT0("mojom", "Send blink::mojom::LocalFrame::EnableViewSourceMode");
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrame::kEnableViewSourceMode), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrame_EnableViewSourceMode_Params_Data> params(message);
    params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrame::Name_);
    message.set_method_name("EnableViewSourceMode");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameProxy::Focus()
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT0("mojom", "Send blink::mojom::LocalFrame::Focus");
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrame::kFocus), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrame_Focus_Params_Data> params(message);
    params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrame::Name_);
    message.set_method_name("Focus");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameProxy::ClearFocusedElement()
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT0("mojom", "Send blink::mojom::LocalFrame::ClearFocusedElement");
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrame::kClearFocusedElement), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrame_ClearFocusedElement_Params_Data> params(message);
    params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrame::Name_);
    message.set_method_name("ClearFocusedElement");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameProxy::CopyImageAt(const ::gfx::Point& in_window_point)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrame::CopyImageAt", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("window_point"), in_window_point, "<value of type const ::gfx::Point&>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrame::kCopyImageAt), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrame_CopyImageAt_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->window_point)::BaseType> window_point_fragment(params.message());
    mojo::internal::Serialize<::gfx::mojom::PointDataView>(in_window_point, window_point_fragment);
    params->window_point.Set(window_point_fragment.is_null() ? nullptr : window_point_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->window_point.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null window_point in LocalFrame.CopyImageAt request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrame::Name_);
    message.set_method_name("CopyImageAt");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameProxy::SaveImageAt(const ::gfx::Point& in_window_point)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrame::SaveImageAt", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("window_point"), in_window_point, "<value of type const ::gfx::Point&>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrame::kSaveImageAt), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrame_SaveImageAt_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->window_point)::BaseType> window_point_fragment(params.message());
    mojo::internal::Serialize<::gfx::mojom::PointDataView>(in_window_point, window_point_fragment);
    params->window_point.Set(window_point_fragment.is_null() ? nullptr : window_point_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->window_point.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null window_point in LocalFrame.SaveImageAt request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrame::Name_);
    message.set_method_name("SaveImageAt");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameProxy::ReportBlinkFeatureUsage(const WTF::Vector<::blink::mojom::blink::WebFeature>& in_features)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrame::ReportBlinkFeatureUsage", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(
            dict.AddItem("features"), in_features, "<value of type const WTF::Vector<::blink::mojom::blink::WebFeature>&>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrame::kReportBlinkFeatureUsage), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrame_ReportBlinkFeatureUsage_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->features)::BaseType> features_fragment(params.message());
    constexpr const mojo::internal::ContainerValidateParams& features_validate_params
        = mojo::internal::GetArrayOfEnumsValidator<0, false, ::blink::mojom::internal::WebFeature_Data::Validate>();
    mojo::internal::Serialize<mojo::ArrayDataView<::blink::mojom::WebFeature>>(in_features, features_fragment, &features_validate_params);
    params->features.Set(features_fragment.is_null() ? nullptr : features_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->features.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null features in LocalFrame.ReportBlinkFeatureUsage request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrame::Name_);
    message.set_method_name("ReportBlinkFeatureUsage");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameProxy::RenderFallbackContent()
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT0("mojom", "Send blink::mojom::LocalFrame::RenderFallbackContent");
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrame::kRenderFallbackContent), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrame_RenderFallbackContent_Params_Data> params(message);
    params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrame::Name_);
    message.set_method_name("RenderFallbackContent");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameProxy::BeforeUnload(bool in_is_reload, BeforeUnloadCallback callback)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrame::BeforeUnload", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("is_reload"), in_is_reload, "<value of type bool>");
    });
#endif

    const bool kExpectsResponse = true;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = mojo::UrgentMessageScope::IsInUrgentScope();

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrame::kBeforeUnload), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrame_BeforeUnload_Params_Data> params(message);
    params.Allocate();
    params->is_reload = in_is_reload;

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrame::Name_);
    message.set_method_name("BeforeUnload");
#endif
    std::unique_ptr<mojo::MessageReceiver> responder(new LocalFrame_BeforeUnload_ForwardToCallback(std::move(callback)));
    ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void LocalFrameProxy::MediaPlayerActionAt(const ::gfx::Point& in_location, ::blink::mojom::blink::MediaPlayerActionPtr in_action)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrame::MediaPlayerActionAt", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("location"), in_location, "<value of type const ::gfx::Point&>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("action"), in_action, "<value of type ::blink::mojom::blink::MediaPlayerActionPtr>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrame::kMediaPlayerActionAt), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrame_MediaPlayerActionAt_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->location)::BaseType> location_fragment(params.message());
    mojo::internal::Serialize<::gfx::mojom::PointDataView>(in_location, location_fragment);
    params->location.Set(location_fragment.is_null() ? nullptr : location_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->location.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null location in LocalFrame.MediaPlayerActionAt request");
    mojo::internal::MessageFragment<typename decltype(params->action)::BaseType> action_fragment(params.message());
    mojo::internal::Serialize<::blink::mojom::MediaPlayerActionDataView>(in_action, action_fragment);
    params->action.Set(action_fragment.is_null() ? nullptr : action_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->action.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null action in LocalFrame.MediaPlayerActionAt request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrame::Name_);
    message.set_method_name("MediaPlayerActionAt");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameProxy::RequestVideoFrameAtWithBoundsHint(
    const ::gfx::Point& in_location, const ::gfx::Size& in_max_size, int32_t in_max_area, RequestVideoFrameAtWithBoundsHintCallback callback)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrame::RequestVideoFrameAtWithBoundsHint", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("location"), in_location, "<value of type const ::gfx::Point&>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("max_size"), in_max_size, "<value of type const ::gfx::Size&>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("max_area"), in_max_area, "<value of type int32_t>");
    });
#endif

    const bool kExpectsResponse = true;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrame::kRequestVideoFrameAtWithBoundsHint), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrame_RequestVideoFrameAtWithBoundsHint_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->location)::BaseType> location_fragment(params.message());
    mojo::internal::Serialize<::gfx::mojom::PointDataView>(in_location, location_fragment);
    params->location.Set(location_fragment.is_null() ? nullptr : location_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->location.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null location in LocalFrame.RequestVideoFrameAtWithBoundsHint request");
    mojo::internal::MessageFragment<typename decltype(params->max_size)::BaseType> max_size_fragment(params.message());
    mojo::internal::Serialize<::gfx::mojom::SizeDataView>(in_max_size, max_size_fragment);
    params->max_size.Set(max_size_fragment.is_null() ? nullptr : max_size_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->max_size.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null max_size in LocalFrame.RequestVideoFrameAtWithBoundsHint request");
    params->max_area = in_max_area;

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrame::Name_);
    message.set_method_name("RequestVideoFrameAtWithBoundsHint");
#endif
    std::unique_ptr<mojo::MessageReceiver> responder(new LocalFrame_RequestVideoFrameAtWithBoundsHint_ForwardToCallback(std::move(callback)));
    ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void LocalFrameProxy::PluginActionAt(const ::gfx::Point& in_location, PluginActionType in_action)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrame::PluginActionAt", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("location"), in_location, "<value of type const ::gfx::Point&>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("action"), in_action, "<value of type PluginActionType>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrame::kPluginActionAt), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrame_PluginActionAt_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->location)::BaseType> location_fragment(params.message());
    mojo::internal::Serialize<::gfx::mojom::PointDataView>(in_location, location_fragment);
    params->location.Set(location_fragment.is_null() ? nullptr : location_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->location.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null location in LocalFrame.PluginActionAt request");
    mojo::internal::Serialize<::blink::mojom::PluginActionType>(in_action, &params->action);

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrame::Name_);
    message.set_method_name("PluginActionAt");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameProxy::AdvanceFocusInFrame(::blink::mojom::blink::FocusType in_focus_type, const std::optional<::blink::RemoteFrameToken>& in_source_frame_token)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrame::AdvanceFocusInFrame", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("focus_type"), in_focus_type, "<value of type ::blink::mojom::blink::FocusType>");
        perfetto::WriteIntoTracedValueWithFallback(
            dict.AddItem("source_frame_token"), in_source_frame_token, "<value of type const std::optional<::blink::RemoteFrameToken>&>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrame::kAdvanceFocusInFrame), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrame_AdvanceFocusInFrame_Params_Data> params(message);
    params.Allocate();
    mojo::internal::Serialize<::blink::mojom::FocusType>(in_focus_type, &params->focus_type);
    mojo::internal::MessageFragment<typename decltype(params->source_frame_token)::BaseType> source_frame_token_fragment(params.message());
    mojo::internal::Serialize<::blink::mojom::RemoteFrameTokenDataView>(in_source_frame_token, source_frame_token_fragment);
    params->source_frame_token.Set(source_frame_token_fragment.is_null() ? nullptr : source_frame_token_fragment.data());

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrame::Name_);
    message.set_method_name("AdvanceFocusInFrame");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameProxy::AdvanceFocusForIME(::blink::mojom::blink::FocusType in_focus_type)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrame::AdvanceFocusForIME", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("focus_type"), in_focus_type, "<value of type ::blink::mojom::blink::FocusType>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrame::kAdvanceFocusForIME), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrame_AdvanceFocusForIME_Params_Data> params(message);
    params.Allocate();
    mojo::internal::Serialize<::blink::mojom::FocusType>(in_focus_type, &params->focus_type);

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrame::Name_);
    message.set_method_name("AdvanceFocusForIME");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameProxy::ReportContentSecurityPolicyViolation(::network::mojom::blink::CSPViolationPtr in_violation)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrame::ReportContentSecurityPolicyViolation", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("violation"), in_violation, "<value of type ::network::mojom::blink::CSPViolationPtr>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrame::kReportContentSecurityPolicyViolation), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrame_ReportContentSecurityPolicyViolation_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->violation)::BaseType> violation_fragment(params.message());
    mojo::internal::Serialize<::network::mojom::CSPViolationDataView>(in_violation, violation_fragment);
    params->violation.Set(violation_fragment.is_null() ? nullptr : violation_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->violation.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null violation in LocalFrame.ReportContentSecurityPolicyViolation request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrame::Name_);
    message.set_method_name("ReportContentSecurityPolicyViolation");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameProxy::DidUpdateFramePolicy(const ::blink::FramePolicy& in_frame_policy)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrame::DidUpdateFramePolicy", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("frame_policy"), in_frame_policy, "<value of type const ::blink::FramePolicy&>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrame::kDidUpdateFramePolicy), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrame_DidUpdateFramePolicy_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->frame_policy)::BaseType> frame_policy_fragment(params.message());
    mojo::internal::Serialize<::blink::mojom::FramePolicyDataView>(in_frame_policy, frame_policy_fragment);
    params->frame_policy.Set(frame_policy_fragment.is_null() ? nullptr : frame_policy_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->frame_policy.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null frame_policy in LocalFrame.DidUpdateFramePolicy request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrame::Name_);
    message.set_method_name("DidUpdateFramePolicy");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameProxy::OnFrameVisibilityChanged(::blink::mojom::blink::FrameVisibility in_visibility)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrame::OnFrameVisibilityChanged", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("visibility"), in_visibility, "<value of type ::blink::mojom::blink::FrameVisibility>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrame::kOnFrameVisibilityChanged), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrame_OnFrameVisibilityChanged_Params_Data> params(message);
    params.Allocate();
    mojo::internal::Serialize<::blink::mojom::FrameVisibility>(in_visibility, &params->visibility);

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrame::Name_);
    message.set_method_name("OnFrameVisibilityChanged");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameProxy::PostMessageEvent(const std::optional<::blink::RemoteFrameToken>& in_source_frame_token, const ::WTF::String& in_source_origin,
    const ::WTF::String& in_target_origin, ::blink::BlinkTransferableMessage in_message)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrame::PostMessageEvent", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(
            dict.AddItem("source_frame_token"), in_source_frame_token, "<value of type const std::optional<::blink::RemoteFrameToken>&>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("source_origin"), in_source_origin, "<value of type const ::WTF::String&>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("target_origin"), in_target_origin, "<value of type const ::WTF::String&>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("message"), in_message, "<value of type ::blink::BlinkTransferableMessage>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrame::kPostMessageEvent), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrame_PostMessageEvent_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->source_frame_token)::BaseType> source_frame_token_fragment(params.message());
    mojo::internal::Serialize<::blink::mojom::RemoteFrameTokenDataView>(in_source_frame_token, source_frame_token_fragment);
    params->source_frame_token.Set(source_frame_token_fragment.is_null() ? nullptr : source_frame_token_fragment.data());
    mojo::internal::MessageFragment<typename decltype(params->source_origin)::BaseType> source_origin_fragment(params.message());
    mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(in_source_origin, source_origin_fragment);
    params->source_origin.Set(source_origin_fragment.is_null() ? nullptr : source_origin_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->source_origin.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null source_origin in LocalFrame.PostMessageEvent request");
    mojo::internal::MessageFragment<typename decltype(params->target_origin)::BaseType> target_origin_fragment(params.message());
    mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(in_target_origin, target_origin_fragment);
    params->target_origin.Set(target_origin_fragment.is_null() ? nullptr : target_origin_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->target_origin.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null target_origin in LocalFrame.PostMessageEvent request");
    mojo::internal::MessageFragment<typename decltype(params->message)::BaseType> message_fragment(params.message());
    mojo::internal::Serialize<::blink::mojom::TransferableMessageDataView>(in_message, message_fragment);
    params->message.Set(message_fragment.is_null() ? nullptr : message_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->message.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null message in LocalFrame.PostMessageEvent request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrame::Name_);
    message.set_method_name("PostMessageEvent");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameProxy::JavaScriptMethodExecuteRequest(const ::WTF::String& in_object_name, const ::WTF::String& in_method_name, ::base::Value::List in_arguments,
    bool in_wants_result, JavaScriptMethodExecuteRequestCallback callback)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrame::JavaScriptMethodExecuteRequest", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("object_name"), in_object_name, "<value of type const ::WTF::String&>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("method_name"), in_method_name, "<value of type const ::WTF::String&>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("arguments"), in_arguments, "<value of type ::base::Value::List>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("wants_result"), in_wants_result, "<value of type bool>");
    });
#endif

    const bool kExpectsResponse = true;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrame::kJavaScriptMethodExecuteRequest), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrame_JavaScriptMethodExecuteRequest_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->object_name)::BaseType> object_name_fragment(params.message());
    mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(in_object_name, object_name_fragment);
    params->object_name.Set(object_name_fragment.is_null() ? nullptr : object_name_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->object_name.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null object_name in LocalFrame.JavaScriptMethodExecuteRequest request");
    mojo::internal::MessageFragment<typename decltype(params->method_name)::BaseType> method_name_fragment(params.message());
    mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(in_method_name, method_name_fragment);
    params->method_name.Set(method_name_fragment.is_null() ? nullptr : method_name_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->method_name.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null method_name in LocalFrame.JavaScriptMethodExecuteRequest request");
    mojo::internal::MessageFragment<typename decltype(params->arguments)::BaseType> arguments_fragment(params.message());
    mojo::internal::Serialize<::mojo_base::mojom::ListValueDataView>(in_arguments, arguments_fragment);
    params->arguments.Set(arguments_fragment.is_null() ? nullptr : arguments_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->arguments.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null arguments in LocalFrame.JavaScriptMethodExecuteRequest request");
    params->wants_result = in_wants_result;

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrame::Name_);
    message.set_method_name("JavaScriptMethodExecuteRequest");
#endif
    std::unique_ptr<mojo::MessageReceiver> responder(new LocalFrame_JavaScriptMethodExecuteRequest_ForwardToCallback(std::move(callback)));
    ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void LocalFrameProxy::JavaScriptExecuteRequest(const ::WTF::String& in_javascript, bool in_wants_result, JavaScriptExecuteRequestCallback callback)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrame::JavaScriptExecuteRequest", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("javascript"), in_javascript, "<value of type const ::WTF::String&>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("wants_result"), in_wants_result, "<value of type bool>");
    });
#endif

    const bool kExpectsResponse = true;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrame::kJavaScriptExecuteRequest), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrame_JavaScriptExecuteRequest_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->javascript)::BaseType> javascript_fragment(params.message());
    mojo::internal::Serialize<::mojo_base::mojom::BigString16DataView>(in_javascript, javascript_fragment);
    params->javascript.Set(javascript_fragment.is_null() ? nullptr : javascript_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->javascript.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null javascript in LocalFrame.JavaScriptExecuteRequest request");
    params->wants_result = in_wants_result;

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrame::Name_);
    message.set_method_name("JavaScriptExecuteRequest");
#endif
    std::unique_ptr<mojo::MessageReceiver> responder(new LocalFrame_JavaScriptExecuteRequest_ForwardToCallback(std::move(callback)));
    ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void LocalFrameProxy::JavaScriptExecuteRequestForTests(const ::WTF::String& in_javascript, bool in_has_user_gesture, bool in_resolve_promises,
    bool in_honor_js_content_settings, int32_t in_world_id, JavaScriptExecuteRequestForTestsCallback callback)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrame::JavaScriptExecuteRequestForTests", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("javascript"), in_javascript, "<value of type const ::WTF::String&>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("has_user_gesture"), in_has_user_gesture, "<value of type bool>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("resolve_promises"), in_resolve_promises, "<value of type bool>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("honor_js_content_settings"), in_honor_js_content_settings, "<value of type bool>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("world_id"), in_world_id, "<value of type int32_t>");
    });
#endif

    const bool kExpectsResponse = true;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrame::kJavaScriptExecuteRequestForTests), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrame_JavaScriptExecuteRequestForTests_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->javascript)::BaseType> javascript_fragment(params.message());
    mojo::internal::Serialize<::mojo_base::mojom::BigString16DataView>(in_javascript, javascript_fragment);
    params->javascript.Set(javascript_fragment.is_null() ? nullptr : javascript_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->javascript.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null javascript in LocalFrame.JavaScriptExecuteRequestForTests request");
    params->has_user_gesture = in_has_user_gesture;
    params->resolve_promises = in_resolve_promises;
    params->honor_js_content_settings = in_honor_js_content_settings;
    params->world_id = in_world_id;

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrame::Name_);
    message.set_method_name("JavaScriptExecuteRequestForTests");
#endif
    std::unique_ptr<mojo::MessageReceiver> responder(new LocalFrame_JavaScriptExecuteRequestForTests_ForwardToCallback(std::move(callback)));
    ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void LocalFrameProxy::JavaScriptExecuteRequestInIsolatedWorld(
    const ::WTF::String& in_javascript, bool in_wants_result, int32_t in_world_id, JavaScriptExecuteRequestInIsolatedWorldCallback callback)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrame::JavaScriptExecuteRequestInIsolatedWorld", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("javascript"), in_javascript, "<value of type const ::WTF::String&>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("wants_result"), in_wants_result, "<value of type bool>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("world_id"), in_world_id, "<value of type int32_t>");
    });
#endif

    const bool kExpectsResponse = true;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrame::kJavaScriptExecuteRequestInIsolatedWorld), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrame_JavaScriptExecuteRequestInIsolatedWorld_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->javascript)::BaseType> javascript_fragment(params.message());
    mojo::internal::Serialize<::mojo_base::mojom::BigString16DataView>(in_javascript, javascript_fragment);
    params->javascript.Set(javascript_fragment.is_null() ? nullptr : javascript_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->javascript.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null javascript in LocalFrame.JavaScriptExecuteRequestInIsolatedWorld request");
    params->wants_result = in_wants_result;
    params->world_id = in_world_id;

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrame::Name_);
    message.set_method_name("JavaScriptExecuteRequestInIsolatedWorld");
#endif
    std::unique_ptr<mojo::MessageReceiver> responder(new LocalFrame_JavaScriptExecuteRequestInIsolatedWorld_ForwardToCallback(std::move(callback)));
    ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void LocalFrameProxy::BindReportingObserver(::mojo::PendingReceiver<::blink::mojom::blink::ReportingObserver> in_receiver)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrame::BindReportingObserver", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(
            dict.AddItem("receiver"), in_receiver, "<value of type ::mojo::PendingReceiver<::blink::mojom::blink::ReportingObserver>>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrame::kBindReportingObserver), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrame_BindReportingObserver_Params_Data> params(message);
    params.Allocate();
    mojo::internal::Serialize<mojo::InterfaceRequestDataView<::blink::mojom::ReportingObserverInterfaceBase>>(
        in_receiver, &params->receiver, &params.message());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(!mojo::internal::IsHandleOrInterfaceValid(params->receiver),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE, "invalid receiver in LocalFrame.BindReportingObserver request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrame::Name_);
    message.set_method_name("BindReportingObserver");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameProxy::UpdateOpener(const std::optional<::blink::FrameToken>& in_opener_frame_token)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrame::UpdateOpener", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(
            dict.AddItem("opener_frame_token"), in_opener_frame_token, "<value of type const std::optional<::blink::FrameToken>&>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrame::kUpdateOpener), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrame_UpdateOpener_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<decltype(params->opener_frame_token)> opener_frame_token_fragment(params.message());
    opener_frame_token_fragment.Claim(&params->opener_frame_token);
    mojo::internal::Serialize<::blink::mojom::FrameTokenDataView>(in_opener_frame_token, opener_frame_token_fragment, true);

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrame::Name_);
    message.set_method_name("UpdateOpener");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameProxy::GetSavableResourceLinks(GetSavableResourceLinksCallback callback)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT0("mojom", "Send blink::mojom::LocalFrame::GetSavableResourceLinks");
#endif

    const bool kExpectsResponse = true;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrame::kGetSavableResourceLinks), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrame_GetSavableResourceLinks_Params_Data> params(message);
    params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrame::Name_);
    message.set_method_name("GetSavableResourceLinks");
#endif
    std::unique_ptr<mojo::MessageReceiver> responder(new LocalFrame_GetSavableResourceLinks_ForwardToCallback(std::move(callback)));
    ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void LocalFrameProxy::MixedContentFound(const ::blink::KURL& in_main_resource_url, const ::blink::KURL& in_mixed_content_url,
    ::blink::mojom::blink::RequestContextType in_request_context, bool in_was_allowed, const ::blink::KURL& in_url_before_redirects, bool in_had_redirect,
    ::network::mojom::blink::SourceLocationPtr in_source_location)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrame::MixedContentFound", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("main_resource_url"), in_main_resource_url, "<value of type const ::blink::KURL&>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("mixed_content_url"), in_mixed_content_url, "<value of type const ::blink::KURL&>");
        perfetto::WriteIntoTracedValueWithFallback(
            dict.AddItem("request_context"), in_request_context, "<value of type ::blink::mojom::blink::RequestContextType>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("was_allowed"), in_was_allowed, "<value of type bool>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("url_before_redirects"), in_url_before_redirects, "<value of type const ::blink::KURL&>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("had_redirect"), in_had_redirect, "<value of type bool>");
        perfetto::WriteIntoTracedValueWithFallback(
            dict.AddItem("source_location"), in_source_location, "<value of type ::network::mojom::blink::SourceLocationPtr>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrame::kMixedContentFound), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrame_MixedContentFound_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->main_resource_url)::BaseType> main_resource_url_fragment(params.message());
    mojo::internal::Serialize<::url::mojom::UrlDataView>(in_main_resource_url, main_resource_url_fragment);
    params->main_resource_url.Set(main_resource_url_fragment.is_null() ? nullptr : main_resource_url_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->main_resource_url.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null main_resource_url in LocalFrame.MixedContentFound request");
    mojo::internal::MessageFragment<typename decltype(params->mixed_content_url)::BaseType> mixed_content_url_fragment(params.message());
    mojo::internal::Serialize<::url::mojom::UrlDataView>(in_mixed_content_url, mixed_content_url_fragment);
    params->mixed_content_url.Set(mixed_content_url_fragment.is_null() ? nullptr : mixed_content_url_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->mixed_content_url.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null mixed_content_url in LocalFrame.MixedContentFound request");
    mojo::internal::Serialize<::blink::mojom::RequestContextType>(in_request_context, &params->request_context);
    params->was_allowed = in_was_allowed;
    mojo::internal::MessageFragment<typename decltype(params->url_before_redirects)::BaseType> url_before_redirects_fragment(params.message());
    mojo::internal::Serialize<::url::mojom::UrlDataView>(in_url_before_redirects, url_before_redirects_fragment);
    params->url_before_redirects.Set(url_before_redirects_fragment.is_null() ? nullptr : url_before_redirects_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->url_before_redirects.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null url_before_redirects in LocalFrame.MixedContentFound request");
    params->had_redirect = in_had_redirect;
    mojo::internal::MessageFragment<typename decltype(params->source_location)::BaseType> source_location_fragment(params.message());
    mojo::internal::Serialize<::network::mojom::SourceLocationDataView>(in_source_location, source_location_fragment);
    params->source_location.Set(source_location_fragment.is_null() ? nullptr : source_location_fragment.data());

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrame::Name_);
    message.set_method_name("MixedContentFound");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameProxy::BindDevToolsAgent(::mojo::PendingAssociatedRemote<::blink::mojom::blink::DevToolsAgentHost> in_agent_host,
    ::mojo::PendingAssociatedReceiver<::blink::mojom::blink::DevToolsAgent> in_agent)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrame::BindDevToolsAgent", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(
            dict.AddItem("agent_host"), in_agent_host, "<value of type ::mojo::PendingAssociatedRemote<::blink::mojom::blink::DevToolsAgentHost>>");
        perfetto::WriteIntoTracedValueWithFallback(
            dict.AddItem("agent"), in_agent, "<value of type ::mojo::PendingAssociatedReceiver<::blink::mojom::blink::DevToolsAgent>>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrame::kBindDevToolsAgent), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrame_BindDevToolsAgent_Params_Data> params(message);
    params.Allocate();
    mojo::internal::Serialize<::blink::mojom::DevToolsAgentHostAssociatedPtrInfoDataView>(in_agent_host, &params->agent_host, &params.message());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(!mojo::internal::IsHandleOrInterfaceValid(params->agent_host),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_INTERFACE_ID, "invalid agent_host in LocalFrame.BindDevToolsAgent request");
    mojo::internal::Serialize<::blink::mojom::DevToolsAgentAssociatedRequestDataView>(in_agent, &params->agent, &params.message());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(!mojo::internal::IsHandleOrInterfaceValid(params->agent),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_INTERFACE_ID, "invalid agent in LocalFrame.BindDevToolsAgent request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrame::Name_);
    message.set_method_name("BindDevToolsAgent");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameProxy::HandleRendererDebugURL(const ::blink::KURL& in_url)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrame::HandleRendererDebugURL", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("url"), in_url, "<value of type const ::blink::KURL&>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrame::kHandleRendererDebugURL), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrame_HandleRendererDebugURL_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->url)::BaseType> url_fragment(params.message());
    mojo::internal::Serialize<::url::mojom::UrlDataView>(in_url, url_fragment);
    params->url.Set(url_fragment.is_null() ? nullptr : url_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->url.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null url in LocalFrame.HandleRendererDebugURL request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrame::Name_);
    message.set_method_name("HandleRendererDebugURL");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameProxy::GetCanonicalUrlForSharing(GetCanonicalUrlForSharingCallback callback)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT0("mojom", "Send blink::mojom::LocalFrame::GetCanonicalUrlForSharing");
#endif

    const bool kExpectsResponse = true;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrame::kGetCanonicalUrlForSharing), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrame_GetCanonicalUrlForSharing_Params_Data> params(message);
    params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrame::Name_);
    message.set_method_name("GetCanonicalUrlForSharing");
#endif
    std::unique_ptr<mojo::MessageReceiver> responder(new LocalFrame_GetCanonicalUrlForSharing_ForwardToCallback(std::move(callback)));
    ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void LocalFrameProxy::GetOpenGraphMetadata(GetOpenGraphMetadataCallback callback)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT0("mojom", "Send blink::mojom::LocalFrame::GetOpenGraphMetadata");
#endif

    const bool kExpectsResponse = true;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrame::kGetOpenGraphMetadata), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrame_GetOpenGraphMetadata_Params_Data> params(message);
    params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrame::Name_);
    message.set_method_name("GetOpenGraphMetadata");
#endif
    std::unique_ptr<mojo::MessageReceiver> responder(new LocalFrame_GetOpenGraphMetadata_ForwardToCallback(std::move(callback)));
    ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void LocalFrameProxy::SetNavigationApiHistoryEntriesForRestore(
    ::blink::mojom::blink::NavigationApiHistoryEntryArraysPtr in_entry_arrays, NavigationApiEntryRestoreReason in_restore_reason)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrame::SetNavigationApiHistoryEntriesForRestore", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(
            dict.AddItem("entry_arrays"), in_entry_arrays, "<value of type ::blink::mojom::blink::NavigationApiHistoryEntryArraysPtr>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("restore_reason"), in_restore_reason, "<value of type NavigationApiEntryRestoreReason>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrame::kSetNavigationApiHistoryEntriesForRestore), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrame_SetNavigationApiHistoryEntriesForRestore_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->entry_arrays)::BaseType> entry_arrays_fragment(params.message());
    mojo::internal::Serialize<::blink::mojom::NavigationApiHistoryEntryArraysDataView>(in_entry_arrays, entry_arrays_fragment);
    params->entry_arrays.Set(entry_arrays_fragment.is_null() ? nullptr : entry_arrays_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->entry_arrays.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null entry_arrays in LocalFrame.SetNavigationApiHistoryEntriesForRestore request");
    mojo::internal::Serialize<::blink::mojom::NavigationApiEntryRestoreReason>(in_restore_reason, &params->restore_reason);

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrame::Name_);
    message.set_method_name("SetNavigationApiHistoryEntriesForRestore");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameProxy::UpdatePrerenderURL(const ::blink::KURL& in_matched_url, UpdatePrerenderURLCallback callback)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrame::UpdatePrerenderURL", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("matched_url"), in_matched_url, "<value of type const ::blink::KURL&>");
    });
#endif

    const bool kExpectsResponse = true;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrame::kUpdatePrerenderURL), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrame_UpdatePrerenderURL_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->matched_url)::BaseType> matched_url_fragment(params.message());
    mojo::internal::Serialize<::url::mojom::UrlDataView>(in_matched_url, matched_url_fragment);
    params->matched_url.Set(matched_url_fragment.is_null() ? nullptr : matched_url_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->matched_url.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null matched_url in LocalFrame.UpdatePrerenderURL request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrame::Name_);
    message.set_method_name("UpdatePrerenderURL");
#endif
    std::unique_ptr<mojo::MessageReceiver> responder(new LocalFrame_UpdatePrerenderURL_ForwardToCallback(std::move(callback)));
    ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void LocalFrameProxy::NotifyNavigationApiOfDisposedEntries(const WTF::Vector<WTF::String>& in_keys)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrame::NotifyNavigationApiOfDisposedEntries", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("keys"), in_keys, "<value of type const WTF::Vector<WTF::String>&>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrame::kNotifyNavigationApiOfDisposedEntries), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrame_NotifyNavigationApiOfDisposedEntries_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->keys)::BaseType> keys_fragment(params.message());
    constexpr const mojo::internal::ContainerValidateParams& keys_validate_params
        = mojo::internal::GetArrayValidator<0, false, &mojo::internal::GetArrayValidator<0, false, nullptr>()>();
    mojo::internal::Serialize<mojo::ArrayDataView<mojo::StringDataView>>(in_keys, keys_fragment, &keys_validate_params);
    params->keys.Set(keys_fragment.is_null() ? nullptr : keys_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->keys.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null keys in LocalFrame.NotifyNavigationApiOfDisposedEntries request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrame::Name_);
    message.set_method_name("NotifyNavigationApiOfDisposedEntries");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameProxy::TraverseCancelled(const WTF::String& in_navigation_api_key, TraverseCancelledReason in_reason)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrame::TraverseCancelled", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("navigation_api_key"), in_navigation_api_key, "<value of type const WTF::String&>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("reason"), in_reason, "<value of type TraverseCancelledReason>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrame::kTraverseCancelled), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrame_TraverseCancelled_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->navigation_api_key)::BaseType> navigation_api_key_fragment(params.message());
    mojo::internal::Serialize<mojo::StringDataView>(in_navigation_api_key, navigation_api_key_fragment);
    params->navigation_api_key.Set(navigation_api_key_fragment.is_null() ? nullptr : navigation_api_key_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->navigation_api_key.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null navigation_api_key in LocalFrame.TraverseCancelled request");
    mojo::internal::Serialize<::blink::mojom::TraverseCancelledReason>(in_reason, &params->reason);

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrame::Name_);
    message.set_method_name("TraverseCancelled");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameProxy::DispatchNavigateEventForCrossDocumentTraversal(
    const ::blink::KURL& in_url, const std::string& in_page_state, bool in_is_browser_initiated)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1(
        "mojom", "Send blink::mojom::LocalFrame::DispatchNavigateEventForCrossDocumentTraversal", "input_parameters", [&](perfetto::TracedValue context) {
            auto dict = std::move(context).WriteDictionary();
            perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("url"), in_url, "<value of type const ::blink::KURL&>");
            perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("page_state"), in_page_state, "<value of type const std::string&>");
            perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("is_browser_initiated"), in_is_browser_initiated, "<value of type bool>");
        });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrame::kDispatchNavigateEventForCrossDocumentTraversal), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrame_DispatchNavigateEventForCrossDocumentTraversal_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->url)::BaseType> url_fragment(params.message());
    mojo::internal::Serialize<::url::mojom::UrlDataView>(in_url, url_fragment);
    params->url.Set(url_fragment.is_null() ? nullptr : url_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->url.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null url in LocalFrame.DispatchNavigateEventForCrossDocumentTraversal request");
    mojo::internal::MessageFragment<typename decltype(params->page_state)::BaseType> page_state_fragment(params.message());
    mojo::internal::Serialize<::mojo_base::mojom::ByteStringDataView>(in_page_state, page_state_fragment);
    params->page_state.Set(page_state_fragment.is_null() ? nullptr : page_state_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->page_state.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null page_state in LocalFrame.DispatchNavigateEventForCrossDocumentTraversal request");
    params->is_browser_initiated = in_is_browser_initiated;

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrame::Name_);
    message.set_method_name("DispatchNavigateEventForCrossDocumentTraversal");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameProxy::SnapshotDocumentForViewTransition(const ::blink::ViewTransitionToken& in_transition_token,
    ::blink::mojom::blink::PageSwapEventParamsPtr in_page_swap_event_params, SnapshotDocumentForViewTransitionCallback callback)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrame::SnapshotDocumentForViewTransition", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(
            dict.AddItem("transition_token"), in_transition_token, "<value of type const ::blink::ViewTransitionToken&>");
        perfetto::WriteIntoTracedValueWithFallback(
            dict.AddItem("page_swap_event_params"), in_page_swap_event_params, "<value of type ::blink::mojom::blink::PageSwapEventParamsPtr>");
    });
#endif

    const bool kExpectsResponse = true;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrame::kSnapshotDocumentForViewTransition), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrame_SnapshotDocumentForViewTransition_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->transition_token)::BaseType> transition_token_fragment(params.message());
    mojo::internal::Serialize<::blink::mojom::ViewTransitionTokenDataView>(in_transition_token, transition_token_fragment);
    params->transition_token.Set(transition_token_fragment.is_null() ? nullptr : transition_token_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->transition_token.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null transition_token in LocalFrame.SnapshotDocumentForViewTransition request");
    mojo::internal::MessageFragment<typename decltype(params->page_swap_event_params)::BaseType> page_swap_event_params_fragment(params.message());
    mojo::internal::Serialize<::blink::mojom::PageSwapEventParamsDataView>(in_page_swap_event_params, page_swap_event_params_fragment);
    params->page_swap_event_params.Set(page_swap_event_params_fragment.is_null() ? nullptr : page_swap_event_params_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->page_swap_event_params.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null page_swap_event_params in LocalFrame.SnapshotDocumentForViewTransition request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrame::Name_);
    message.set_method_name("SnapshotDocumentForViewTransition");
#endif
    std::unique_ptr<mojo::MessageReceiver> responder(new LocalFrame_SnapshotDocumentForViewTransition_ForwardToCallback(std::move(callback)));
    ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void LocalFrameProxy::NotifyViewTransitionAbortedToOldDocument()
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT0("mojom", "Send blink::mojom::LocalFrame::NotifyViewTransitionAbortedToOldDocument");
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrame::kNotifyViewTransitionAbortedToOldDocument), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrame_NotifyViewTransitionAbortedToOldDocument_Params_Data> params(message);
    params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrame::Name_);
    message.set_method_name("NotifyViewTransitionAbortedToOldDocument");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameProxy::DispatchPageSwap(::blink::mojom::blink::PageSwapEventParamsPtr in_page_swap_event_params)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalFrame::DispatchPageSwap", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(
            dict.AddItem("page_swap_event_params"), in_page_swap_event_params, "<value of type ::blink::mojom::blink::PageSwapEventParamsPtr>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrame::kDispatchPageSwap), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrame_DispatchPageSwap_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->page_swap_event_params)::BaseType> page_swap_event_params_fragment(params.message());
    mojo::internal::Serialize<::blink::mojom::PageSwapEventParamsDataView>(in_page_swap_event_params, page_swap_event_params_fragment);
    params->page_swap_event_params.Set(page_swap_event_params_fragment.is_null() ? nullptr : page_swap_event_params_fragment.data());

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrame::Name_);
    message.set_method_name("DispatchPageSwap");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameProxy::AddResourceTimingEntryForFailedSubframeNavigation(const ::blink::FrameToken& in_subframe_token, const ::blink::KURL& in_initial_url,
    ::base::TimeTicks in_start_time, ::base::TimeTicks in_redirect_time, ::base::TimeTicks in_request_start, ::base::TimeTicks in_response_start,
    uint32_t in_response_code, const WTF::String& in_mime_type, ::network::mojom::blink::LoadTimingInfoPtr in_load_timing_info,
    ::net::HttpConnectionInfo in_connection_info, const WTF::String& in_alpn_negotiated_protocol, bool in_is_secure_transport, bool in_is_validated,
    const WTF::String& in_normalized_server_timing, const ::network::URLLoaderCompletionStatus& in_completion_status)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1(
        "mojom", "Send blink::mojom::LocalFrame::AddResourceTimingEntryForFailedSubframeNavigation", "input_parameters", [&](perfetto::TracedValue context) {
            auto dict = std::move(context).WriteDictionary();
            perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("subframe_token"), in_subframe_token, "<value of type const ::blink::FrameToken&>");
            perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("initial_url"), in_initial_url, "<value of type const ::blink::KURL&>");
            perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("start_time"), in_start_time, "<value of type ::base::TimeTicks>");
            perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("redirect_time"), in_redirect_time, "<value of type ::base::TimeTicks>");
            perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("request_start"), in_request_start, "<value of type ::base::TimeTicks>");
            perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("response_start"), in_response_start, "<value of type ::base::TimeTicks>");
            perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("response_code"), in_response_code, "<value of type uint32_t>");
            perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("mime_type"), in_mime_type, "<value of type const WTF::String&>");
            perfetto::WriteIntoTracedValueWithFallback(
                dict.AddItem("load_timing_info"), in_load_timing_info, "<value of type ::network::mojom::blink::LoadTimingInfoPtr>");
            perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("connection_info"), in_connection_info, "<value of type ::net::HttpConnectionInfo>");
            perfetto::WriteIntoTracedValueWithFallback(
                dict.AddItem("alpn_negotiated_protocol"), in_alpn_negotiated_protocol, "<value of type const WTF::String&>");
            perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("is_secure_transport"), in_is_secure_transport, "<value of type bool>");
            perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("is_validated"), in_is_validated, "<value of type bool>");
            perfetto::WriteIntoTracedValueWithFallback(
                dict.AddItem("normalized_server_timing"), in_normalized_server_timing, "<value of type const WTF::String&>");
            perfetto::WriteIntoTracedValueWithFallback(
                dict.AddItem("completion_status"), in_completion_status, "<value of type const ::network::URLLoaderCompletionStatus&>");
        });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrame::kAddResourceTimingEntryForFailedSubframeNavigation), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrame_AddResourceTimingEntryForFailedSubframeNavigation_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<decltype(params->subframe_token)> subframe_token_fragment(params.message());
    subframe_token_fragment.Claim(&params->subframe_token);
    mojo::internal::Serialize<::blink::mojom::FrameTokenDataView>(in_subframe_token, subframe_token_fragment, true);
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->subframe_token.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null subframe_token in LocalFrame.AddResourceTimingEntryForFailedSubframeNavigation request");
    mojo::internal::MessageFragment<typename decltype(params->initial_url)::BaseType> initial_url_fragment(params.message());
    mojo::internal::Serialize<::url::mojom::UrlDataView>(in_initial_url, initial_url_fragment);
    params->initial_url.Set(initial_url_fragment.is_null() ? nullptr : initial_url_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->initial_url.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null initial_url in LocalFrame.AddResourceTimingEntryForFailedSubframeNavigation request");
    mojo::internal::MessageFragment<typename decltype(params->start_time)::BaseType> start_time_fragment(params.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeTicksDataView>(in_start_time, start_time_fragment);
    params->start_time.Set(start_time_fragment.is_null() ? nullptr : start_time_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->start_time.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null start_time in LocalFrame.AddResourceTimingEntryForFailedSubframeNavigation request");
    mojo::internal::MessageFragment<typename decltype(params->redirect_time)::BaseType> redirect_time_fragment(params.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeTicksDataView>(in_redirect_time, redirect_time_fragment);
    params->redirect_time.Set(redirect_time_fragment.is_null() ? nullptr : redirect_time_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->redirect_time.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null redirect_time in LocalFrame.AddResourceTimingEntryForFailedSubframeNavigation request");
    mojo::internal::MessageFragment<typename decltype(params->request_start)::BaseType> request_start_fragment(params.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeTicksDataView>(in_request_start, request_start_fragment);
    params->request_start.Set(request_start_fragment.is_null() ? nullptr : request_start_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->request_start.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null request_start in LocalFrame.AddResourceTimingEntryForFailedSubframeNavigation request");
    mojo::internal::MessageFragment<typename decltype(params->response_start)::BaseType> response_start_fragment(params.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeTicksDataView>(in_response_start, response_start_fragment);
    params->response_start.Set(response_start_fragment.is_null() ? nullptr : response_start_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->response_start.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null response_start in LocalFrame.AddResourceTimingEntryForFailedSubframeNavigation request");
    params->response_code = in_response_code;
    mojo::internal::MessageFragment<typename decltype(params->mime_type)::BaseType> mime_type_fragment(params.message());
    mojo::internal::Serialize<mojo::StringDataView>(in_mime_type, mime_type_fragment);
    params->mime_type.Set(mime_type_fragment.is_null() ? nullptr : mime_type_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->mime_type.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null mime_type in LocalFrame.AddResourceTimingEntryForFailedSubframeNavigation request");
    mojo::internal::MessageFragment<typename decltype(params->load_timing_info)::BaseType> load_timing_info_fragment(params.message());
    mojo::internal::Serialize<::network::mojom::LoadTimingInfoDataView>(in_load_timing_info, load_timing_info_fragment);
    params->load_timing_info.Set(load_timing_info_fragment.is_null() ? nullptr : load_timing_info_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->load_timing_info.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null load_timing_info in LocalFrame.AddResourceTimingEntryForFailedSubframeNavigation request");
    mojo::internal::Serialize<::network::mojom::ConnectionInfo>(in_connection_info, &params->connection_info);
    mojo::internal::MessageFragment<typename decltype(params->alpn_negotiated_protocol)::BaseType> alpn_negotiated_protocol_fragment(params.message());
    mojo::internal::Serialize<mojo::StringDataView>(in_alpn_negotiated_protocol, alpn_negotiated_protocol_fragment);
    params->alpn_negotiated_protocol.Set(alpn_negotiated_protocol_fragment.is_null() ? nullptr : alpn_negotiated_protocol_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->alpn_negotiated_protocol.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null alpn_negotiated_protocol in LocalFrame.AddResourceTimingEntryForFailedSubframeNavigation request");
    params->is_secure_transport = in_is_secure_transport;
    params->is_validated = in_is_validated;
    mojo::internal::MessageFragment<typename decltype(params->normalized_server_timing)::BaseType> normalized_server_timing_fragment(params.message());
    mojo::internal::Serialize<mojo::StringDataView>(in_normalized_server_timing, normalized_server_timing_fragment);
    params->normalized_server_timing.Set(normalized_server_timing_fragment.is_null() ? nullptr : normalized_server_timing_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->normalized_server_timing.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null normalized_server_timing in LocalFrame.AddResourceTimingEntryForFailedSubframeNavigation request");
    mojo::internal::MessageFragment<typename decltype(params->completion_status)::BaseType> completion_status_fragment(params.message());
    mojo::internal::Serialize<::network::mojom::URLLoaderCompletionStatusDataView>(in_completion_status, completion_status_fragment);
    params->completion_status.Set(completion_status_fragment.is_null() ? nullptr : completion_status_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->completion_status.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null completion_status in LocalFrame.AddResourceTimingEntryForFailedSubframeNavigation request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrame::Name_);
    message.set_method_name("AddResourceTimingEntryForFailedSubframeNavigation");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}
class LocalFrame_GetTextSurroundingSelection_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
public:
    static LocalFrame::GetTextSurroundingSelectionCallback CreateCallback(::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
    {
        std::unique_ptr<LocalFrame_GetTextSurroundingSelection_ProxyToResponder> proxy(
            new LocalFrame_GetTextSurroundingSelection_ProxyToResponder(message, std::move(responder)));
        return base::BindOnce(&LocalFrame_GetTextSurroundingSelection_ProxyToResponder::Run, std::move(proxy));
    }

    ~LocalFrame_GetTextSurroundingSelection_ProxyToResponder()
    {
#if DCHECK_IS_ON()
        if (responder_) {
            // If we're being destroyed without being run, we want to ensure the
            // binding endpoint has been closed. This checks for that asynchronously.
            // We pass a bound generated callback to handle the response so that any
            // resulting DCHECK stack will have useful interface type information.
            // Instantiate a ScopedFizzleBlockShutdownTasks to allow this request to
            // fizzle if this happens after shutdown and the endpoint is bound to a
            // BLOCK_SHUTDOWN sequence.
            base::ThreadPoolInstance::ScopedFizzleBlockShutdownTasks fizzler;
            responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
        }
#endif
    }

private:
    LocalFrame_GetTextSurroundingSelection_ProxyToResponder(::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
        : ::mojo::internal::ProxyToResponder(message, std::move(responder))
    {
    }

#if DCHECK_IS_ON()
    static void OnIsConnectedComplete(bool connected)
    {
        DCHECK(!connected) << "LocalFrame::GetTextSurroundingSelectionCallback was destroyed without "
                           << "first either being run or its corresponding binding being closed. "
                           << "It is an error to drop response callbacks which still correspond "
                           << "to an open interface pipe.";
    }
#endif

    void Run(const ::WTF::String& in_content, uint32_t in_start_offset, uint32_t in_end_offset);
};

bool LocalFrame_GetTextSurroundingSelection_ForwardToCallback::Accept(mojo::Message* message)
{
    DCHECK(message->is_serialized());
    internal::LocalFrame_GetTextSurroundingSelection_ResponseParams_Data* params
        = reinterpret_cast<internal::LocalFrame_GetTextSurroundingSelection_ResponseParams_Data*>(message->mutable_payload());

    // Validation for LocalFrame.0
    bool success = true;
    ::WTF::String p_content {};
    uint32_t p_start_offset {};
    uint32_t p_end_offset {};
    LocalFrame_GetTextSurroundingSelection_ResponseParamsDataView input_data_view(params, message);

    if (success && !input_data_view.ReadContent(&p_content))
        success = false;
    if (success)
        p_start_offset = input_data_view.start_offset();
    if (success)
        p_end_offset = input_data_view.end_offset();
    if (!success) {
        ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrame::Name_, 0, true);
        return false;
    }
    if (!callback_.is_null())
        std::move(callback_).Run(std::move(p_content), std::move(p_start_offset), std::move(p_end_offset));
    return true;
}

void LocalFrame_GetTextSurroundingSelection_ProxyToResponder::Run(const ::WTF::String& in_content, uint32_t in_start_offset, uint32_t in_end_offset)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send reply blink::mojom::LocalFrame::GetTextSurroundingSelection", "async_response_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("content"), in_content, "<value of type const ::WTF::String&>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("start_offset"), in_start_offset, "<value of type uint32_t>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("end_offset"), in_end_offset, "<value of type uint32_t>");
    });
#endif

    const uint32_t kFlags = mojo::Message::kFlagIsResponse | ((is_sync_) ? mojo::Message::kFlagIsSync : 0) | ((true) ? 0 : mojo::Message::kFlagNoInterrupt)
        | ((false) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrame::kGetTextSurroundingSelection), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrame_GetTextSurroundingSelection_ResponseParams_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->content)::BaseType> content_fragment(params.message());
    mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(in_content, content_fragment);
    params->content.Set(content_fragment.is_null() ? nullptr : content_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->content.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null content in ");
    params->start_offset = in_start_offset;
    params->end_offset = in_end_offset;

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrame::Name_);
    message.set_method_name("GetTextSurroundingSelection");
#endif

    message.set_request_id(request_id_);
    message.set_trace_nonce(trace_nonce_);
    ::mojo::internal::SendMojoMessage(*responder_, message);
    // SendMojoMessage() fails silently if the responder connection is closed,
    // or if the message is malformed.
    //
    // TODO(darin): If Accept() returns false due to a malformed message, that
    // may be good reason to close the connection. However, we don't have a
    // way to do that from here. We should add a way.
    responder_ = nullptr;
}
class LocalFrame_BeforeUnload_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
public:
    static LocalFrame::BeforeUnloadCallback CreateCallback(::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
    {
        std::unique_ptr<LocalFrame_BeforeUnload_ProxyToResponder> proxy(new LocalFrame_BeforeUnload_ProxyToResponder(message, std::move(responder)));
        return base::BindOnce(&LocalFrame_BeforeUnload_ProxyToResponder::Run, std::move(proxy));
    }

    ~LocalFrame_BeforeUnload_ProxyToResponder()
    {
#if DCHECK_IS_ON()
        if (responder_) {
            // If we're being destroyed without being run, we want to ensure the
            // binding endpoint has been closed. This checks for that asynchronously.
            // We pass a bound generated callback to handle the response so that any
            // resulting DCHECK stack will have useful interface type information.
            // Instantiate a ScopedFizzleBlockShutdownTasks to allow this request to
            // fizzle if this happens after shutdown and the endpoint is bound to a
            // BLOCK_SHUTDOWN sequence.
            base::ThreadPoolInstance::ScopedFizzleBlockShutdownTasks fizzler;
            responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
        }
#endif
    }

private:
    LocalFrame_BeforeUnload_ProxyToResponder(::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
        : ::mojo::internal::ProxyToResponder(message, std::move(responder))
    {
    }

#if DCHECK_IS_ON()
    static void OnIsConnectedComplete(bool connected)
    {
        DCHECK(!connected) << "LocalFrame::BeforeUnloadCallback was destroyed without "
                           << "first either being run or its corresponding binding being closed. "
                           << "It is an error to drop response callbacks which still correspond "
                           << "to an open interface pipe.";
    }
#endif

    void Run(bool in_proceed, ::base::TimeTicks in_before_unload_start_time, ::base::TimeTicks in_before_unload_end_time);
};

bool LocalFrame_BeforeUnload_ForwardToCallback::Accept(mojo::Message* message)
{
    DCHECK(message->is_serialized());
    internal::LocalFrame_BeforeUnload_ResponseParams_Data* params
        = reinterpret_cast<internal::LocalFrame_BeforeUnload_ResponseParams_Data*>(message->mutable_payload());

    // Validation for LocalFrame.17
    bool success = true;
    bool p_proceed {};
    ::base::TimeTicks p_before_unload_start_time {};
    ::base::TimeTicks p_before_unload_end_time {};
    LocalFrame_BeforeUnload_ResponseParamsDataView input_data_view(params, message);

    if (success)
        p_proceed = input_data_view.proceed();
    if (success && !input_data_view.ReadBeforeUnloadStartTime(&p_before_unload_start_time))
        success = false;
    if (success && !input_data_view.ReadBeforeUnloadEndTime(&p_before_unload_end_time))
        success = false;
    if (!success) {
        ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrame::Name_, 17, true);
        return false;
    }
    if (!callback_.is_null())
        std::move(callback_).Run(std::move(p_proceed), std::move(p_before_unload_start_time), std::move(p_before_unload_end_time));
    return true;
}

void LocalFrame_BeforeUnload_ProxyToResponder::Run(bool in_proceed, ::base::TimeTicks in_before_unload_start_time, ::base::TimeTicks in_before_unload_end_time)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send reply blink::mojom::LocalFrame::BeforeUnload", "async_response_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("proceed"), in_proceed, "<value of type bool>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("before_unload_start_time"), in_before_unload_start_time, "<value of type ::base::TimeTicks>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("before_unload_end_time"), in_before_unload_end_time, "<value of type ::base::TimeTicks>");
    });
#endif

    const uint32_t kFlags = mojo::Message::kFlagIsResponse | ((is_sync_) ? mojo::Message::kFlagIsSync : 0) | ((true) ? 0 : mojo::Message::kFlagNoInterrupt)
        | ((false) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrame::kBeforeUnload), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrame_BeforeUnload_ResponseParams_Data> params(message);
    params.Allocate();
    params->proceed = in_proceed;
    mojo::internal::MessageFragment<typename decltype(params->before_unload_start_time)::BaseType> before_unload_start_time_fragment(params.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeTicksDataView>(in_before_unload_start_time, before_unload_start_time_fragment);
    params->before_unload_start_time.Set(before_unload_start_time_fragment.is_null() ? nullptr : before_unload_start_time_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->before_unload_start_time.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null before_unload_start_time in ");
    mojo::internal::MessageFragment<typename decltype(params->before_unload_end_time)::BaseType> before_unload_end_time_fragment(params.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeTicksDataView>(in_before_unload_end_time, before_unload_end_time_fragment);
    params->before_unload_end_time.Set(before_unload_end_time_fragment.is_null() ? nullptr : before_unload_end_time_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->before_unload_end_time.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null before_unload_end_time in ");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrame::Name_);
    message.set_method_name("BeforeUnload");
#endif

    message.set_request_id(request_id_);
    message.set_trace_nonce(trace_nonce_);
    ::mojo::internal::SendMojoMessage(*responder_, message);
    // SendMojoMessage() fails silently if the responder connection is closed,
    // or if the message is malformed.
    //
    // TODO(darin): If Accept() returns false due to a malformed message, that
    // may be good reason to close the connection. However, we don't have a
    // way to do that from here. We should add a way.
    responder_ = nullptr;
}
class LocalFrame_RequestVideoFrameAtWithBoundsHint_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
public:
    static LocalFrame::RequestVideoFrameAtWithBoundsHintCallback CreateCallback(
        ::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
    {
        std::unique_ptr<LocalFrame_RequestVideoFrameAtWithBoundsHint_ProxyToResponder> proxy(
            new LocalFrame_RequestVideoFrameAtWithBoundsHint_ProxyToResponder(message, std::move(responder)));
        return base::BindOnce(&LocalFrame_RequestVideoFrameAtWithBoundsHint_ProxyToResponder::Run, std::move(proxy));
    }

    ~LocalFrame_RequestVideoFrameAtWithBoundsHint_ProxyToResponder()
    {
#if DCHECK_IS_ON()
        if (responder_) {
            // If we're being destroyed without being run, we want to ensure the
            // binding endpoint has been closed. This checks for that asynchronously.
            // We pass a bound generated callback to handle the response so that any
            // resulting DCHECK stack will have useful interface type information.
            // Instantiate a ScopedFizzleBlockShutdownTasks to allow this request to
            // fizzle if this happens after shutdown and the endpoint is bound to a
            // BLOCK_SHUTDOWN sequence.
            base::ThreadPoolInstance::ScopedFizzleBlockShutdownTasks fizzler;
            responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
        }
#endif
    }

private:
    LocalFrame_RequestVideoFrameAtWithBoundsHint_ProxyToResponder(::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
        : ::mojo::internal::ProxyToResponder(message, std::move(responder))
    {
    }

#if DCHECK_IS_ON()
    static void OnIsConnectedComplete(bool connected)
    {
        DCHECK(!connected) << "LocalFrame::RequestVideoFrameAtWithBoundsHintCallback was destroyed without "
                           << "first either being run or its corresponding binding being closed. "
                           << "It is an error to drop response callbacks which still correspond "
                           << "to an open interface pipe.";
    }
#endif

    void Run(const ::SkBitmap& in_bitmap, const ::gfx::Rect& in_bounds);
};

bool LocalFrame_RequestVideoFrameAtWithBoundsHint_ForwardToCallback::Accept(mojo::Message* message)
{
    DCHECK(message->is_serialized());
    internal::LocalFrame_RequestVideoFrameAtWithBoundsHint_ResponseParams_Data* params
        = reinterpret_cast<internal::LocalFrame_RequestVideoFrameAtWithBoundsHint_ResponseParams_Data*>(message->mutable_payload());

    // Validation for LocalFrame.19
    bool success = true;
    ::SkBitmap p_bitmap {};
    ::gfx::Rect p_bounds {};
    LocalFrame_RequestVideoFrameAtWithBoundsHint_ResponseParamsDataView input_data_view(params, message);

    if (success && !input_data_view.ReadBitmap(&p_bitmap))
        success = false;
    if (success && !input_data_view.ReadBounds(&p_bounds))
        success = false;
    if (!success) {
        ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrame::Name_, 19, true);
        return false;
    }
    if (!callback_.is_null())
        std::move(callback_).Run(std::move(p_bitmap), std::move(p_bounds));
    return true;
}

void LocalFrame_RequestVideoFrameAtWithBoundsHint_ProxyToResponder::Run(const ::SkBitmap& in_bitmap, const ::gfx::Rect& in_bounds)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1(
        "mojom", "Send reply blink::mojom::LocalFrame::RequestVideoFrameAtWithBoundsHint", "async_response_parameters", [&](perfetto::TracedValue context) {
            auto dict = std::move(context).WriteDictionary();
            perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("bitmap"), in_bitmap, "<value of type const ::SkBitmap&>");
            perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("bounds"), in_bounds, "<value of type const ::gfx::Rect&>");
        });
#endif

    const uint32_t kFlags = mojo::Message::kFlagIsResponse | ((is_sync_) ? mojo::Message::kFlagIsSync : 0) | ((true) ? 0 : mojo::Message::kFlagNoInterrupt)
        | ((false) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrame::kRequestVideoFrameAtWithBoundsHint), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrame_RequestVideoFrameAtWithBoundsHint_ResponseParams_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->bitmap)::BaseType> bitmap_fragment(params.message());
    mojo::internal::Serialize<::skia::mojom::BitmapN32DataView>(in_bitmap, bitmap_fragment);
    params->bitmap.Set(bitmap_fragment.is_null() ? nullptr : bitmap_fragment.data());
    mojo::internal::MessageFragment<typename decltype(params->bounds)::BaseType> bounds_fragment(params.message());
    mojo::internal::Serialize<::gfx::mojom::RectDataView>(in_bounds, bounds_fragment);
    params->bounds.Set(bounds_fragment.is_null() ? nullptr : bounds_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->bounds.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null bounds in ");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrame::Name_);
    message.set_method_name("RequestVideoFrameAtWithBoundsHint");
#endif

    message.set_request_id(request_id_);
    message.set_trace_nonce(trace_nonce_);
    ::mojo::internal::SendMojoMessage(*responder_, message);
    // SendMojoMessage() fails silently if the responder connection is closed,
    // or if the message is malformed.
    //
    // TODO(darin): If Accept() returns false due to a malformed message, that
    // may be good reason to close the connection. However, we don't have a
    // way to do that from here. We should add a way.
    responder_ = nullptr;
}
class LocalFrame_JavaScriptMethodExecuteRequest_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
public:
    static LocalFrame::JavaScriptMethodExecuteRequestCallback CreateCallback(
        ::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
    {
        std::unique_ptr<LocalFrame_JavaScriptMethodExecuteRequest_ProxyToResponder> proxy(
            new LocalFrame_JavaScriptMethodExecuteRequest_ProxyToResponder(message, std::move(responder)));
        return base::BindOnce(&LocalFrame_JavaScriptMethodExecuteRequest_ProxyToResponder::Run, std::move(proxy));
    }

    ~LocalFrame_JavaScriptMethodExecuteRequest_ProxyToResponder()
    {
#if DCHECK_IS_ON()
        if (responder_) {
            // If we're being destroyed without being run, we want to ensure the
            // binding endpoint has been closed. This checks for that asynchronously.
            // We pass a bound generated callback to handle the response so that any
            // resulting DCHECK stack will have useful interface type information.
            // Instantiate a ScopedFizzleBlockShutdownTasks to allow this request to
            // fizzle if this happens after shutdown and the endpoint is bound to a
            // BLOCK_SHUTDOWN sequence.
            base::ThreadPoolInstance::ScopedFizzleBlockShutdownTasks fizzler;
            responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
        }
#endif
    }

private:
    LocalFrame_JavaScriptMethodExecuteRequest_ProxyToResponder(::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
        : ::mojo::internal::ProxyToResponder(message, std::move(responder))
    {
    }

#if DCHECK_IS_ON()
    static void OnIsConnectedComplete(bool connected)
    {
        DCHECK(!connected) << "LocalFrame::JavaScriptMethodExecuteRequestCallback was destroyed without "
                           << "first either being run or its corresponding binding being closed. "
                           << "It is an error to drop response callbacks which still correspond "
                           << "to an open interface pipe.";
    }
#endif

    void Run(::base::Value in_result);
};

bool LocalFrame_JavaScriptMethodExecuteRequest_ForwardToCallback::Accept(mojo::Message* message)
{
    DCHECK(message->is_serialized());
    internal::LocalFrame_JavaScriptMethodExecuteRequest_ResponseParams_Data* params
        = reinterpret_cast<internal::LocalFrame_JavaScriptMethodExecuteRequest_ResponseParams_Data*>(message->mutable_payload());

    // Validation for LocalFrame.27
    bool success = true;
    ::base::Value p_result {};
    LocalFrame_JavaScriptMethodExecuteRequest_ResponseParamsDataView input_data_view(params, message);

    if (success && !input_data_view.ReadResult(&p_result))
        success = false;
    if (!success) {
        ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrame::Name_, 27, true);
        return false;
    }
    if (!callback_.is_null())
        std::move(callback_).Run(std::move(p_result));
    return true;
}

void LocalFrame_JavaScriptMethodExecuteRequest_ProxyToResponder::Run(::base::Value in_result)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1(
        "mojom", "Send reply blink::mojom::LocalFrame::JavaScriptMethodExecuteRequest", "async_response_parameters", [&](perfetto::TracedValue context) {
            auto dict = std::move(context).WriteDictionary();
            perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("result"), in_result, "<value of type ::base::Value>");
        });
#endif

    const uint32_t kFlags = mojo::Message::kFlagIsResponse | ((is_sync_) ? mojo::Message::kFlagIsSync : 0) | ((true) ? 0 : mojo::Message::kFlagNoInterrupt)
        | ((false) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrame::kJavaScriptMethodExecuteRequest), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrame_JavaScriptMethodExecuteRequest_ResponseParams_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<decltype(params->result)> result_fragment(params.message());
    result_fragment.Claim(&params->result);
    mojo::internal::Serialize<::mojo_base::mojom::ValueDataView>(in_result, result_fragment, true);
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->result.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null result in ");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrame::Name_);
    message.set_method_name("JavaScriptMethodExecuteRequest");
#endif

    message.set_request_id(request_id_);
    message.set_trace_nonce(trace_nonce_);
    ::mojo::internal::SendMojoMessage(*responder_, message);
    // SendMojoMessage() fails silently if the responder connection is closed,
    // or if the message is malformed.
    //
    // TODO(darin): If Accept() returns false due to a malformed message, that
    // may be good reason to close the connection. However, we don't have a
    // way to do that from here. We should add a way.
    responder_ = nullptr;
}
class LocalFrame_JavaScriptExecuteRequest_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
public:
    static LocalFrame::JavaScriptExecuteRequestCallback CreateCallback(::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
    {
        std::unique_ptr<LocalFrame_JavaScriptExecuteRequest_ProxyToResponder> proxy(
            new LocalFrame_JavaScriptExecuteRequest_ProxyToResponder(message, std::move(responder)));
        return base::BindOnce(&LocalFrame_JavaScriptExecuteRequest_ProxyToResponder::Run, std::move(proxy));
    }

    ~LocalFrame_JavaScriptExecuteRequest_ProxyToResponder()
    {
#if DCHECK_IS_ON()
        if (responder_) {
            // If we're being destroyed without being run, we want to ensure the
            // binding endpoint has been closed. This checks for that asynchronously.
            // We pass a bound generated callback to handle the response so that any
            // resulting DCHECK stack will have useful interface type information.
            // Instantiate a ScopedFizzleBlockShutdownTasks to allow this request to
            // fizzle if this happens after shutdown and the endpoint is bound to a
            // BLOCK_SHUTDOWN sequence.
            base::ThreadPoolInstance::ScopedFizzleBlockShutdownTasks fizzler;
            responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
        }
#endif
    }

private:
    LocalFrame_JavaScriptExecuteRequest_ProxyToResponder(::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
        : ::mojo::internal::ProxyToResponder(message, std::move(responder))
    {
    }

#if DCHECK_IS_ON()
    static void OnIsConnectedComplete(bool connected)
    {
        DCHECK(!connected) << "LocalFrame::JavaScriptExecuteRequestCallback was destroyed without "
                           << "first either being run or its corresponding binding being closed. "
                           << "It is an error to drop response callbacks which still correspond "
                           << "to an open interface pipe.";
    }
#endif

    void Run(::base::Value in_result);
};

bool LocalFrame_JavaScriptExecuteRequest_ForwardToCallback::Accept(mojo::Message* message)
{
    DCHECK(message->is_serialized());
    internal::LocalFrame_JavaScriptExecuteRequest_ResponseParams_Data* params
        = reinterpret_cast<internal::LocalFrame_JavaScriptExecuteRequest_ResponseParams_Data*>(message->mutable_payload());

    // Validation for LocalFrame.28
    bool success = true;
    ::base::Value p_result {};
    LocalFrame_JavaScriptExecuteRequest_ResponseParamsDataView input_data_view(params, message);

    if (success && !input_data_view.ReadResult(&p_result))
        success = false;
    if (!success) {
        ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrame::Name_, 28, true);
        return false;
    }
    if (!callback_.is_null())
        std::move(callback_).Run(std::move(p_result));
    return true;
}

void LocalFrame_JavaScriptExecuteRequest_ProxyToResponder::Run(::base::Value in_result)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send reply blink::mojom::LocalFrame::JavaScriptExecuteRequest", "async_response_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("result"), in_result, "<value of type ::base::Value>");
    });
#endif

    const uint32_t kFlags = mojo::Message::kFlagIsResponse | ((is_sync_) ? mojo::Message::kFlagIsSync : 0) | ((true) ? 0 : mojo::Message::kFlagNoInterrupt)
        | ((false) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrame::kJavaScriptExecuteRequest), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrame_JavaScriptExecuteRequest_ResponseParams_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<decltype(params->result)> result_fragment(params.message());
    result_fragment.Claim(&params->result);
    mojo::internal::Serialize<::mojo_base::mojom::ValueDataView>(in_result, result_fragment, true);
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->result.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null result in ");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrame::Name_);
    message.set_method_name("JavaScriptExecuteRequest");
#endif

    message.set_request_id(request_id_);
    message.set_trace_nonce(trace_nonce_);
    ::mojo::internal::SendMojoMessage(*responder_, message);
    // SendMojoMessage() fails silently if the responder connection is closed,
    // or if the message is malformed.
    //
    // TODO(darin): If Accept() returns false due to a malformed message, that
    // may be good reason to close the connection. However, we don't have a
    // way to do that from here. We should add a way.
    responder_ = nullptr;
}
class LocalFrame_JavaScriptExecuteRequestForTests_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
public:
    static LocalFrame::JavaScriptExecuteRequestForTestsCallback CreateCallback(
        ::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
    {
        std::unique_ptr<LocalFrame_JavaScriptExecuteRequestForTests_ProxyToResponder> proxy(
            new LocalFrame_JavaScriptExecuteRequestForTests_ProxyToResponder(message, std::move(responder)));
        return base::BindOnce(&LocalFrame_JavaScriptExecuteRequestForTests_ProxyToResponder::Run, std::move(proxy));
    }

    ~LocalFrame_JavaScriptExecuteRequestForTests_ProxyToResponder()
    {
#if DCHECK_IS_ON()
        if (responder_) {
            // If we're being destroyed without being run, we want to ensure the
            // binding endpoint has been closed. This checks for that asynchronously.
            // We pass a bound generated callback to handle the response so that any
            // resulting DCHECK stack will have useful interface type information.
            // Instantiate a ScopedFizzleBlockShutdownTasks to allow this request to
            // fizzle if this happens after shutdown and the endpoint is bound to a
            // BLOCK_SHUTDOWN sequence.
            base::ThreadPoolInstance::ScopedFizzleBlockShutdownTasks fizzler;
            responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
        }
#endif
    }

private:
    LocalFrame_JavaScriptExecuteRequestForTests_ProxyToResponder(::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
        : ::mojo::internal::ProxyToResponder(message, std::move(responder))
    {
    }

#if DCHECK_IS_ON()
    static void OnIsConnectedComplete(bool connected)
    {
        DCHECK(!connected) << "LocalFrame::JavaScriptExecuteRequestForTestsCallback was destroyed without "
                           << "first either being run or its corresponding binding being closed. "
                           << "It is an error to drop response callbacks which still correspond "
                           << "to an open interface pipe.";
    }
#endif

    void Run(JavaScriptExecutionResultType in_result_type, ::base::Value in_result);
};

bool LocalFrame_JavaScriptExecuteRequestForTests_ForwardToCallback::Accept(mojo::Message* message)
{
    DCHECK(message->is_serialized());
    internal::LocalFrame_JavaScriptExecuteRequestForTests_ResponseParams_Data* params
        = reinterpret_cast<internal::LocalFrame_JavaScriptExecuteRequestForTests_ResponseParams_Data*>(message->mutable_payload());

    // Validation for LocalFrame.29
    bool success = true;
    JavaScriptExecutionResultType p_result_type {};
    ::base::Value p_result {};
    LocalFrame_JavaScriptExecuteRequestForTests_ResponseParamsDataView input_data_view(params, message);

    if (success && !input_data_view.ReadResultType(&p_result_type))
        success = false;
    if (success && !input_data_view.ReadResult(&p_result))
        success = false;
    if (!success) {
        ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrame::Name_, 29, true);
        return false;
    }
    if (!callback_.is_null())
        std::move(callback_).Run(std::move(p_result_type), std::move(p_result));
    return true;
}

void LocalFrame_JavaScriptExecuteRequestForTests_ProxyToResponder::Run(JavaScriptExecutionResultType in_result_type, ::base::Value in_result)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1(
        "mojom", "Send reply blink::mojom::LocalFrame::JavaScriptExecuteRequestForTests", "async_response_parameters", [&](perfetto::TracedValue context) {
            auto dict = std::move(context).WriteDictionary();
            perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("result_type"), in_result_type, "<value of type JavaScriptExecutionResultType>");
            perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("result"), in_result, "<value of type ::base::Value>");
        });
#endif

    const uint32_t kFlags = mojo::Message::kFlagIsResponse | ((is_sync_) ? mojo::Message::kFlagIsSync : 0) | ((true) ? 0 : mojo::Message::kFlagNoInterrupt)
        | ((false) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrame::kJavaScriptExecuteRequestForTests), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrame_JavaScriptExecuteRequestForTests_ResponseParams_Data> params(message);
    params.Allocate();
    mojo::internal::Serialize<::blink::mojom::JavaScriptExecutionResultType>(in_result_type, &params->result_type);
    mojo::internal::MessageFragment<decltype(params->result)> result_fragment(params.message());
    result_fragment.Claim(&params->result);
    mojo::internal::Serialize<::mojo_base::mojom::ValueDataView>(in_result, result_fragment, true);
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->result.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null result in ");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrame::Name_);
    message.set_method_name("JavaScriptExecuteRequestForTests");
#endif

    message.set_request_id(request_id_);
    message.set_trace_nonce(trace_nonce_);
    ::mojo::internal::SendMojoMessage(*responder_, message);
    // SendMojoMessage() fails silently if the responder connection is closed,
    // or if the message is malformed.
    //
    // TODO(darin): If Accept() returns false due to a malformed message, that
    // may be good reason to close the connection. However, we don't have a
    // way to do that from here. We should add a way.
    responder_ = nullptr;
}
class LocalFrame_JavaScriptExecuteRequestInIsolatedWorld_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
public:
    static LocalFrame::JavaScriptExecuteRequestInIsolatedWorldCallback CreateCallback(
        ::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
    {
        std::unique_ptr<LocalFrame_JavaScriptExecuteRequestInIsolatedWorld_ProxyToResponder> proxy(
            new LocalFrame_JavaScriptExecuteRequestInIsolatedWorld_ProxyToResponder(message, std::move(responder)));
        return base::BindOnce(&LocalFrame_JavaScriptExecuteRequestInIsolatedWorld_ProxyToResponder::Run, std::move(proxy));
    }

    ~LocalFrame_JavaScriptExecuteRequestInIsolatedWorld_ProxyToResponder()
    {
#if DCHECK_IS_ON()
        if (responder_) {
            // If we're being destroyed without being run, we want to ensure the
            // binding endpoint has been closed. This checks for that asynchronously.
            // We pass a bound generated callback to handle the response so that any
            // resulting DCHECK stack will have useful interface type information.
            // Instantiate a ScopedFizzleBlockShutdownTasks to allow this request to
            // fizzle if this happens after shutdown and the endpoint is bound to a
            // BLOCK_SHUTDOWN sequence.
            base::ThreadPoolInstance::ScopedFizzleBlockShutdownTasks fizzler;
            responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
        }
#endif
    }

private:
    LocalFrame_JavaScriptExecuteRequestInIsolatedWorld_ProxyToResponder(::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
        : ::mojo::internal::ProxyToResponder(message, std::move(responder))
    {
    }

#if DCHECK_IS_ON()
    static void OnIsConnectedComplete(bool connected)
    {
        DCHECK(!connected) << "LocalFrame::JavaScriptExecuteRequestInIsolatedWorldCallback was destroyed without "
                           << "first either being run or its corresponding binding being closed. "
                           << "It is an error to drop response callbacks which still correspond "
                           << "to an open interface pipe.";
    }
#endif

    void Run(::base::Value in_result);
};

bool LocalFrame_JavaScriptExecuteRequestInIsolatedWorld_ForwardToCallback::Accept(mojo::Message* message)
{
    DCHECK(message->is_serialized());
    internal::LocalFrame_JavaScriptExecuteRequestInIsolatedWorld_ResponseParams_Data* params
        = reinterpret_cast<internal::LocalFrame_JavaScriptExecuteRequestInIsolatedWorld_ResponseParams_Data*>(message->mutable_payload());

    // Validation for LocalFrame.30
    bool success = true;
    ::base::Value p_result {};
    LocalFrame_JavaScriptExecuteRequestInIsolatedWorld_ResponseParamsDataView input_data_view(params, message);

    if (success && !input_data_view.ReadResult(&p_result))
        success = false;
    if (!success) {
        ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrame::Name_, 30, true);
        return false;
    }
    if (!callback_.is_null())
        std::move(callback_).Run(std::move(p_result));
    return true;
}

void LocalFrame_JavaScriptExecuteRequestInIsolatedWorld_ProxyToResponder::Run(::base::Value in_result)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send reply blink::mojom::LocalFrame::JavaScriptExecuteRequestInIsolatedWorld", "async_response_parameters",
        [&](perfetto::TracedValue context) {
            auto dict = std::move(context).WriteDictionary();
            perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("result"), in_result, "<value of type ::base::Value>");
        });
#endif

    const uint32_t kFlags = mojo::Message::kFlagIsResponse | ((is_sync_) ? mojo::Message::kFlagIsSync : 0) | ((true) ? 0 : mojo::Message::kFlagNoInterrupt)
        | ((false) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrame::kJavaScriptExecuteRequestInIsolatedWorld), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrame_JavaScriptExecuteRequestInIsolatedWorld_ResponseParams_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<decltype(params->result)> result_fragment(params.message());
    result_fragment.Claim(&params->result);
    mojo::internal::Serialize<::mojo_base::mojom::ValueDataView>(in_result, result_fragment, true);
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->result.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null result in ");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrame::Name_);
    message.set_method_name("JavaScriptExecuteRequestInIsolatedWorld");
#endif

    message.set_request_id(request_id_);
    message.set_trace_nonce(trace_nonce_);
    ::mojo::internal::SendMojoMessage(*responder_, message);
    // SendMojoMessage() fails silently if the responder connection is closed,
    // or if the message is malformed.
    //
    // TODO(darin): If Accept() returns false due to a malformed message, that
    // may be good reason to close the connection. However, we don't have a
    // way to do that from here. We should add a way.
    responder_ = nullptr;
}
class LocalFrame_GetSavableResourceLinks_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
public:
    static LocalFrame::GetSavableResourceLinksCallback CreateCallback(::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
    {
        std::unique_ptr<LocalFrame_GetSavableResourceLinks_ProxyToResponder> proxy(
            new LocalFrame_GetSavableResourceLinks_ProxyToResponder(message, std::move(responder)));
        return base::BindOnce(&LocalFrame_GetSavableResourceLinks_ProxyToResponder::Run, std::move(proxy));
    }

    ~LocalFrame_GetSavableResourceLinks_ProxyToResponder()
    {
#if DCHECK_IS_ON()
        if (responder_) {
            // If we're being destroyed without being run, we want to ensure the
            // binding endpoint has been closed. This checks for that asynchronously.
            // We pass a bound generated callback to handle the response so that any
            // resulting DCHECK stack will have useful interface type information.
            // Instantiate a ScopedFizzleBlockShutdownTasks to allow this request to
            // fizzle if this happens after shutdown and the endpoint is bound to a
            // BLOCK_SHUTDOWN sequence.
            base::ThreadPoolInstance::ScopedFizzleBlockShutdownTasks fizzler;
            responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
        }
#endif
    }

private:
    LocalFrame_GetSavableResourceLinks_ProxyToResponder(::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
        : ::mojo::internal::ProxyToResponder(message, std::move(responder))
    {
    }

#if DCHECK_IS_ON()
    static void OnIsConnectedComplete(bool connected)
    {
        DCHECK(!connected) << "LocalFrame::GetSavableResourceLinksCallback was destroyed without "
                           << "first either being run or its corresponding binding being closed. "
                           << "It is an error to drop response callbacks which still correspond "
                           << "to an open interface pipe.";
    }
#endif

    void Run(GetSavableResourceLinksReplyPtr in_reply);
};

bool LocalFrame_GetSavableResourceLinks_ForwardToCallback::Accept(mojo::Message* message)
{
    DCHECK(message->is_serialized());
    internal::LocalFrame_GetSavableResourceLinks_ResponseParams_Data* params
        = reinterpret_cast<internal::LocalFrame_GetSavableResourceLinks_ResponseParams_Data*>(message->mutable_payload());

    // Validation for LocalFrame.33
    bool success = true;
    GetSavableResourceLinksReplyPtr p_reply {};
    LocalFrame_GetSavableResourceLinks_ResponseParamsDataView input_data_view(params, message);

    if (success && !input_data_view.ReadReply(&p_reply))
        success = false;
    if (!success) {
        ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrame::Name_, 33, true);
        return false;
    }
    if (!callback_.is_null())
        std::move(callback_).Run(std::move(p_reply));
    return true;
}

void LocalFrame_GetSavableResourceLinks_ProxyToResponder::Run(GetSavableResourceLinksReplyPtr in_reply)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send reply blink::mojom::LocalFrame::GetSavableResourceLinks", "async_response_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("reply"), in_reply, "<value of type GetSavableResourceLinksReplyPtr>");
    });
#endif

    const uint32_t kFlags = mojo::Message::kFlagIsResponse | ((is_sync_) ? mojo::Message::kFlagIsSync : 0) | ((true) ? 0 : mojo::Message::kFlagNoInterrupt)
        | ((false) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrame::kGetSavableResourceLinks), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrame_GetSavableResourceLinks_ResponseParams_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->reply)::BaseType> reply_fragment(params.message());
    mojo::internal::Serialize<::blink::mojom::GetSavableResourceLinksReplyDataView>(in_reply, reply_fragment);
    params->reply.Set(reply_fragment.is_null() ? nullptr : reply_fragment.data());

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrame::Name_);
    message.set_method_name("GetSavableResourceLinks");
#endif

    message.set_request_id(request_id_);
    message.set_trace_nonce(trace_nonce_);
    ::mojo::internal::SendMojoMessage(*responder_, message);
    // SendMojoMessage() fails silently if the responder connection is closed,
    // or if the message is malformed.
    //
    // TODO(darin): If Accept() returns false due to a malformed message, that
    // may be good reason to close the connection. However, we don't have a
    // way to do that from here. We should add a way.
    responder_ = nullptr;
}
class LocalFrame_GetCanonicalUrlForSharing_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
public:
    static LocalFrame::GetCanonicalUrlForSharingCallback CreateCallback(::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
    {
        std::unique_ptr<LocalFrame_GetCanonicalUrlForSharing_ProxyToResponder> proxy(
            new LocalFrame_GetCanonicalUrlForSharing_ProxyToResponder(message, std::move(responder)));
        return base::BindOnce(&LocalFrame_GetCanonicalUrlForSharing_ProxyToResponder::Run, std::move(proxy));
    }

    ~LocalFrame_GetCanonicalUrlForSharing_ProxyToResponder()
    {
#if DCHECK_IS_ON()
        if (responder_) {
            // If we're being destroyed without being run, we want to ensure the
            // binding endpoint has been closed. This checks for that asynchronously.
            // We pass a bound generated callback to handle the response so that any
            // resulting DCHECK stack will have useful interface type information.
            // Instantiate a ScopedFizzleBlockShutdownTasks to allow this request to
            // fizzle if this happens after shutdown and the endpoint is bound to a
            // BLOCK_SHUTDOWN sequence.
            base::ThreadPoolInstance::ScopedFizzleBlockShutdownTasks fizzler;
            responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
        }
#endif
    }

private:
    LocalFrame_GetCanonicalUrlForSharing_ProxyToResponder(::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
        : ::mojo::internal::ProxyToResponder(message, std::move(responder))
    {
    }

#if DCHECK_IS_ON()
    static void OnIsConnectedComplete(bool connected)
    {
        DCHECK(!connected) << "LocalFrame::GetCanonicalUrlForSharingCallback was destroyed without "
                           << "first either being run or its corresponding binding being closed. "
                           << "It is an error to drop response callbacks which still correspond "
                           << "to an open interface pipe.";
    }
#endif

    void Run(const std::optional<::blink::KURL>& in_canonical_url);
};

bool LocalFrame_GetCanonicalUrlForSharing_ForwardToCallback::Accept(mojo::Message* message)
{
    DCHECK(message->is_serialized());
    internal::LocalFrame_GetCanonicalUrlForSharing_ResponseParams_Data* params
        = reinterpret_cast<internal::LocalFrame_GetCanonicalUrlForSharing_ResponseParams_Data*>(message->mutable_payload());

    // Validation for LocalFrame.37
    bool success = true;
    std::optional<::blink::KURL> p_canonical_url {};
    LocalFrame_GetCanonicalUrlForSharing_ResponseParamsDataView input_data_view(params, message);

    if (success && !input_data_view.ReadCanonicalUrl(&p_canonical_url))
        success = false;
    if (!success) {
        ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrame::Name_, 37, true);
        return false;
    }
    if (!callback_.is_null())
        std::move(callback_).Run(std::move(p_canonical_url));
    return true;
}

void LocalFrame_GetCanonicalUrlForSharing_ProxyToResponder::Run(const std::optional<::blink::KURL>& in_canonical_url)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send reply blink::mojom::LocalFrame::GetCanonicalUrlForSharing", "async_response_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("canonical_url"), in_canonical_url, "<value of type const std::optional<::blink::KURL>&>");
    });
#endif

    const uint32_t kFlags = mojo::Message::kFlagIsResponse | ((is_sync_) ? mojo::Message::kFlagIsSync : 0) | ((true) ? 0 : mojo::Message::kFlagNoInterrupt)
        | ((false) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrame::kGetCanonicalUrlForSharing), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrame_GetCanonicalUrlForSharing_ResponseParams_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->canonical_url)::BaseType> canonical_url_fragment(params.message());
    mojo::internal::Serialize<::url::mojom::UrlDataView>(in_canonical_url, canonical_url_fragment);
    params->canonical_url.Set(canonical_url_fragment.is_null() ? nullptr : canonical_url_fragment.data());

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrame::Name_);
    message.set_method_name("GetCanonicalUrlForSharing");
#endif

    message.set_request_id(request_id_);
    message.set_trace_nonce(trace_nonce_);
    ::mojo::internal::SendMojoMessage(*responder_, message);
    // SendMojoMessage() fails silently if the responder connection is closed,
    // or if the message is malformed.
    //
    // TODO(darin): If Accept() returns false due to a malformed message, that
    // may be good reason to close the connection. However, we don't have a
    // way to do that from here. We should add a way.
    responder_ = nullptr;
}
class LocalFrame_GetOpenGraphMetadata_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
public:
    static LocalFrame::GetOpenGraphMetadataCallback CreateCallback(::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
    {
        std::unique_ptr<LocalFrame_GetOpenGraphMetadata_ProxyToResponder> proxy(
            new LocalFrame_GetOpenGraphMetadata_ProxyToResponder(message, std::move(responder)));
        return base::BindOnce(&LocalFrame_GetOpenGraphMetadata_ProxyToResponder::Run, std::move(proxy));
    }

    ~LocalFrame_GetOpenGraphMetadata_ProxyToResponder()
    {
#if DCHECK_IS_ON()
        if (responder_) {
            // If we're being destroyed without being run, we want to ensure the
            // binding endpoint has been closed. This checks for that asynchronously.
            // We pass a bound generated callback to handle the response so that any
            // resulting DCHECK stack will have useful interface type information.
            // Instantiate a ScopedFizzleBlockShutdownTasks to allow this request to
            // fizzle if this happens after shutdown and the endpoint is bound to a
            // BLOCK_SHUTDOWN sequence.
            base::ThreadPoolInstance::ScopedFizzleBlockShutdownTasks fizzler;
            responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
        }
#endif
    }

private:
    LocalFrame_GetOpenGraphMetadata_ProxyToResponder(::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
        : ::mojo::internal::ProxyToResponder(message, std::move(responder))
    {
    }

#if DCHECK_IS_ON()
    static void OnIsConnectedComplete(bool connected)
    {
        DCHECK(!connected) << "LocalFrame::GetOpenGraphMetadataCallback was destroyed without "
                           << "first either being run or its corresponding binding being closed. "
                           << "It is an error to drop response callbacks which still correspond "
                           << "to an open interface pipe.";
    }
#endif

    void Run(::blink::mojom::blink::OpenGraphMetadataPtr in_metadata);
};

bool LocalFrame_GetOpenGraphMetadata_ForwardToCallback::Accept(mojo::Message* message)
{
    DCHECK(message->is_serialized());
    internal::LocalFrame_GetOpenGraphMetadata_ResponseParams_Data* params
        = reinterpret_cast<internal::LocalFrame_GetOpenGraphMetadata_ResponseParams_Data*>(message->mutable_payload());

    // Validation for LocalFrame.38
    bool success = true;
    ::blink::mojom::blink::OpenGraphMetadataPtr p_metadata {};
    LocalFrame_GetOpenGraphMetadata_ResponseParamsDataView input_data_view(params, message);

    if (success && !input_data_view.ReadMetadata(&p_metadata))
        success = false;
    if (!success) {
        ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrame::Name_, 38, true);
        return false;
    }
    if (!callback_.is_null())
        std::move(callback_).Run(std::move(p_metadata));
    return true;
}

void LocalFrame_GetOpenGraphMetadata_ProxyToResponder::Run(::blink::mojom::blink::OpenGraphMetadataPtr in_metadata)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send reply blink::mojom::LocalFrame::GetOpenGraphMetadata", "async_response_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("metadata"), in_metadata, "<value of type ::blink::mojom::blink::OpenGraphMetadataPtr>");
    });
#endif

    const uint32_t kFlags = mojo::Message::kFlagIsResponse | ((is_sync_) ? mojo::Message::kFlagIsSync : 0) | ((true) ? 0 : mojo::Message::kFlagNoInterrupt)
        | ((false) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrame::kGetOpenGraphMetadata), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrame_GetOpenGraphMetadata_ResponseParams_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->metadata)::BaseType> metadata_fragment(params.message());
    mojo::internal::Serialize<::blink::mojom::OpenGraphMetadataDataView>(in_metadata, metadata_fragment);
    params->metadata.Set(metadata_fragment.is_null() ? nullptr : metadata_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->metadata.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null metadata in ");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrame::Name_);
    message.set_method_name("GetOpenGraphMetadata");
#endif

    message.set_request_id(request_id_);
    message.set_trace_nonce(trace_nonce_);
    ::mojo::internal::SendMojoMessage(*responder_, message);
    // SendMojoMessage() fails silently if the responder connection is closed,
    // or if the message is malformed.
    //
    // TODO(darin): If Accept() returns false due to a malformed message, that
    // may be good reason to close the connection. However, we don't have a
    // way to do that from here. We should add a way.
    responder_ = nullptr;
}
class LocalFrame_UpdatePrerenderURL_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
public:
    static LocalFrame::UpdatePrerenderURLCallback CreateCallback(::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
    {
        std::unique_ptr<LocalFrame_UpdatePrerenderURL_ProxyToResponder> proxy(
            new LocalFrame_UpdatePrerenderURL_ProxyToResponder(message, std::move(responder)));
        return base::BindOnce(&LocalFrame_UpdatePrerenderURL_ProxyToResponder::Run, std::move(proxy));
    }

    ~LocalFrame_UpdatePrerenderURL_ProxyToResponder()
    {
#if DCHECK_IS_ON()
        if (responder_) {
            // If we're being destroyed without being run, we want to ensure the
            // binding endpoint has been closed. This checks for that asynchronously.
            // We pass a bound generated callback to handle the response so that any
            // resulting DCHECK stack will have useful interface type information.
            // Instantiate a ScopedFizzleBlockShutdownTasks to allow this request to
            // fizzle if this happens after shutdown and the endpoint is bound to a
            // BLOCK_SHUTDOWN sequence.
            base::ThreadPoolInstance::ScopedFizzleBlockShutdownTasks fizzler;
            responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
        }
#endif
    }

private:
    LocalFrame_UpdatePrerenderURL_ProxyToResponder(::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
        : ::mojo::internal::ProxyToResponder(message, std::move(responder))
    {
    }

#if DCHECK_IS_ON()
    static void OnIsConnectedComplete(bool connected)
    {
        DCHECK(!connected) << "LocalFrame::UpdatePrerenderURLCallback was destroyed without "
                           << "first either being run or its corresponding binding being closed. "
                           << "It is an error to drop response callbacks which still correspond "
                           << "to an open interface pipe.";
    }
#endif

    void Run();
};

bool LocalFrame_UpdatePrerenderURL_ForwardToCallback::Accept(mojo::Message* message)
{
    DCHECK(message->is_serialized());
    internal::LocalFrame_UpdatePrerenderURL_ResponseParams_Data* params
        = reinterpret_cast<internal::LocalFrame_UpdatePrerenderURL_ResponseParams_Data*>(message->mutable_payload());

    // Validation for LocalFrame.40
    bool success = true;
    LocalFrame_UpdatePrerenderURL_ResponseParamsDataView input_data_view(params, message);

    if (!success) {
        ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrame::Name_, 40, true);
        return false;
    }
    if (!callback_.is_null())
        std::move(callback_).Run();
    return true;
}

void LocalFrame_UpdatePrerenderURL_ProxyToResponder::Run()
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT0("mojom", "Send reply blink::mojom::LocalFrame::UpdatePrerenderURL");
#endif

    const uint32_t kFlags = mojo::Message::kFlagIsResponse | ((is_sync_) ? mojo::Message::kFlagIsSync : 0) | ((true) ? 0 : mojo::Message::kFlagNoInterrupt)
        | ((false) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrame::kUpdatePrerenderURL), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrame_UpdatePrerenderURL_ResponseParams_Data> params(message);
    params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrame::Name_);
    message.set_method_name("UpdatePrerenderURL");
#endif

    message.set_request_id(request_id_);
    message.set_trace_nonce(trace_nonce_);
    ::mojo::internal::SendMojoMessage(*responder_, message);
    // SendMojoMessage() fails silently if the responder connection is closed,
    // or if the message is malformed.
    //
    // TODO(darin): If Accept() returns false due to a malformed message, that
    // may be good reason to close the connection. However, we don't have a
    // way to do that from here. We should add a way.
    responder_ = nullptr;
}
class LocalFrame_SnapshotDocumentForViewTransition_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
public:
    static LocalFrame::SnapshotDocumentForViewTransitionCallback CreateCallback(
        ::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
    {
        std::unique_ptr<LocalFrame_SnapshotDocumentForViewTransition_ProxyToResponder> proxy(
            new LocalFrame_SnapshotDocumentForViewTransition_ProxyToResponder(message, std::move(responder)));
        return base::BindOnce(&LocalFrame_SnapshotDocumentForViewTransition_ProxyToResponder::Run, std::move(proxy));
    }

    ~LocalFrame_SnapshotDocumentForViewTransition_ProxyToResponder()
    {
#if DCHECK_IS_ON()
        if (responder_) {
            // If we're being destroyed without being run, we want to ensure the
            // binding endpoint has been closed. This checks for that asynchronously.
            // We pass a bound generated callback to handle the response so that any
            // resulting DCHECK stack will have useful interface type information.
            // Instantiate a ScopedFizzleBlockShutdownTasks to allow this request to
            // fizzle if this happens after shutdown and the endpoint is bound to a
            // BLOCK_SHUTDOWN sequence.
            base::ThreadPoolInstance::ScopedFizzleBlockShutdownTasks fizzler;
            responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
        }
#endif
    }

private:
    LocalFrame_SnapshotDocumentForViewTransition_ProxyToResponder(::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
        : ::mojo::internal::ProxyToResponder(message, std::move(responder))
    {
    }

#if DCHECK_IS_ON()
    static void OnIsConnectedComplete(bool connected)
    {
        DCHECK(!connected) << "LocalFrame::SnapshotDocumentForViewTransitionCallback was destroyed without "
                           << "first either being run or its corresponding binding being closed. "
                           << "It is an error to drop response callbacks which still correspond "
                           << "to an open interface pipe.";
    }
#endif

    void Run(const ::blink::ViewTransitionState& in_view_transition_state);
};

bool LocalFrame_SnapshotDocumentForViewTransition_ForwardToCallback::Accept(mojo::Message* message)
{
    DCHECK(message->is_serialized());
    internal::LocalFrame_SnapshotDocumentForViewTransition_ResponseParams_Data* params
        = reinterpret_cast<internal::LocalFrame_SnapshotDocumentForViewTransition_ResponseParams_Data*>(message->mutable_payload());

    // Validation for LocalFrame.44
    bool success = true;
    ::blink::ViewTransitionState p_view_transition_state {};
    LocalFrame_SnapshotDocumentForViewTransition_ResponseParamsDataView input_data_view(params, message);

    if (success && !input_data_view.ReadViewTransitionState(&p_view_transition_state))
        success = false;
    if (!success) {
        ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrame::Name_, 44, true);
        return false;
    }
    if (!callback_.is_null())
        std::move(callback_).Run(std::move(p_view_transition_state));
    return true;
}

void LocalFrame_SnapshotDocumentForViewTransition_ProxyToResponder::Run(const ::blink::ViewTransitionState& in_view_transition_state)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1(
        "mojom", "Send reply blink::mojom::LocalFrame::SnapshotDocumentForViewTransition", "async_response_parameters", [&](perfetto::TracedValue context) {
            auto dict = std::move(context).WriteDictionary();
            perfetto::WriteIntoTracedValueWithFallback(
                dict.AddItem("view_transition_state"), in_view_transition_state, "<value of type const ::blink::ViewTransitionState&>");
        });
#endif

    const uint32_t kFlags = mojo::Message::kFlagIsResponse | ((is_sync_) ? mojo::Message::kFlagIsSync : 0) | ((true) ? 0 : mojo::Message::kFlagNoInterrupt)
        | ((false) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalFrame::kSnapshotDocumentForViewTransition), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrame_SnapshotDocumentForViewTransition_ResponseParams_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->view_transition_state)::BaseType> view_transition_state_fragment(params.message());
    mojo::internal::Serialize<::blink::mojom::ViewTransitionStateDataView>(in_view_transition_state, view_transition_state_fragment);
    params->view_transition_state.Set(view_transition_state_fragment.is_null() ? nullptr : view_transition_state_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->view_transition_state.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null view_transition_state in ");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalFrame::Name_);
    message.set_method_name("SnapshotDocumentForViewTransition");
#endif

    message.set_request_id(request_id_);
    message.set_trace_nonce(trace_nonce_);
    ::mojo::internal::SendMojoMessage(*responder_, message);
    // SendMojoMessage() fails silently if the responder connection is closed,
    // or if the message is malformed.
    //
    // TODO(darin): If Accept() returns false due to a malformed message, that
    // may be good reason to close the connection. However, we don't have a
    // way to do that from here. We should add a way.
    responder_ = nullptr;
}

// static
bool LocalFrameStubDispatch::Accept(LocalFrame* impl, mojo::Message* message)
{
    switch (static_cast<messages::LocalFrame>(message->header()->name)) {
    case messages::LocalFrame::kGetTextSurroundingSelection: {
        break;
    }
    case messages::LocalFrame::kSendInterventionReport: {
        DCHECK(message->is_serialized());
        internal::LocalFrame_SendInterventionReport_Params_Data* params
            = reinterpret_cast<internal::LocalFrame_SendInterventionReport_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrame.1
        bool success = true;
        WTF::String p_id {};
        WTF::String p_message {};
        LocalFrame_SendInterventionReport_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadId(&p_id))
            success = false;
        if (success && !input_data_view.ReadMessage(&p_message))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrame::Name_, 1, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->SendInterventionReport(std::move(p_id), std::move(p_message));
        return true;
    }
    case messages::LocalFrame::kSetFrameOwnerProperties: {
        DCHECK(message->is_serialized());
        internal::LocalFrame_SetFrameOwnerProperties_Params_Data* params
            = reinterpret_cast<internal::LocalFrame_SetFrameOwnerProperties_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrame.2
        bool success = true;
        ::blink::mojom::blink::FrameOwnerPropertiesPtr p_properties {};
        LocalFrame_SetFrameOwnerProperties_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadProperties(&p_properties))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrame::Name_, 2, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->SetFrameOwnerProperties(std::move(p_properties));
        return true;
    }
    case messages::LocalFrame::kNotifyUserActivation: {
        DCHECK(message->is_serialized());
        internal::LocalFrame_NotifyUserActivation_Params_Data* params
            = reinterpret_cast<internal::LocalFrame_NotifyUserActivation_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrame.3
        bool success = true;
        ::blink::mojom::blink::UserActivationNotificationType p_notification_type {};
        LocalFrame_NotifyUserActivation_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadNotificationType(&p_notification_type))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrame::Name_, 3, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->NotifyUserActivation(std::move(p_notification_type));
        return true;
    }
    case messages::LocalFrame::kNotifyVirtualKeyboardOverlayRect: {
        DCHECK(message->is_serialized());
        internal::LocalFrame_NotifyVirtualKeyboardOverlayRect_Params_Data* params
            = reinterpret_cast<internal::LocalFrame_NotifyVirtualKeyboardOverlayRect_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrame.4
        bool success = true;
        ::gfx::Rect p_keyboard_rect {};
        LocalFrame_NotifyVirtualKeyboardOverlayRect_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadKeyboardRect(&p_keyboard_rect))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrame::Name_, 4, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->NotifyVirtualKeyboardOverlayRect(std::move(p_keyboard_rect));
        return true;
    }
    case messages::LocalFrame::kAddMessageToConsole: {
        DCHECK(message->is_serialized());
        internal::LocalFrame_AddMessageToConsole_Params_Data* params
            = reinterpret_cast<internal::LocalFrame_AddMessageToConsole_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrame.5
        bool success = true;
        ::blink::mojom::blink::ConsoleMessageLevel p_level {};
        WTF::String p_message {};
        bool p_discard_duplicates {};
        LocalFrame_AddMessageToConsole_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadLevel(&p_level))
            success = false;
        if (success && !input_data_view.ReadMessage(&p_message))
            success = false;
        if (success)
            p_discard_duplicates = input_data_view.discard_duplicates();
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrame::Name_, 5, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->AddMessageToConsole(std::move(p_level), std::move(p_message), std::move(p_discard_duplicates));
        return true;
    }
    case messages::LocalFrame::kSwapInImmediately: {
        DCHECK(message->is_serialized());
        internal::LocalFrame_SwapInImmediately_Params_Data* params
            = reinterpret_cast<internal::LocalFrame_SwapInImmediately_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrame.6
        bool success = true;
        LocalFrame_SwapInImmediately_ParamsDataView input_data_view(params, message);

        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrame::Name_, 6, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->SwapInImmediately();
        return true;
    }
    case messages::LocalFrame::kCheckCompleted: {
        DCHECK(message->is_serialized());
        internal::LocalFrame_CheckCompleted_Params_Data* params
            = reinterpret_cast<internal::LocalFrame_CheckCompleted_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrame.7
        bool success = true;
        LocalFrame_CheckCompleted_ParamsDataView input_data_view(params, message);

        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrame::Name_, 7, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->CheckCompleted();
        return true;
    }
    case messages::LocalFrame::kStopLoading: {
        DCHECK(message->is_serialized());
        internal::LocalFrame_StopLoading_Params_Data* params = reinterpret_cast<internal::LocalFrame_StopLoading_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrame.8
        bool success = true;
        LocalFrame_StopLoading_ParamsDataView input_data_view(params, message);

        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrame::Name_, 8, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->StopLoading();
        return true;
    }
    case messages::LocalFrame::kCollapse: {
        DCHECK(message->is_serialized());
        internal::LocalFrame_Collapse_Params_Data* params = reinterpret_cast<internal::LocalFrame_Collapse_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrame.9
        bool success = true;
        bool p_collapsed {};
        LocalFrame_Collapse_ParamsDataView input_data_view(params, message);

        if (success)
            p_collapsed = input_data_view.collapsed();
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrame::Name_, 9, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->Collapse(std::move(p_collapsed));
        return true;
    }
    case messages::LocalFrame::kEnableViewSourceMode: {
        DCHECK(message->is_serialized());
        internal::LocalFrame_EnableViewSourceMode_Params_Data* params
            = reinterpret_cast<internal::LocalFrame_EnableViewSourceMode_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrame.10
        bool success = true;
        LocalFrame_EnableViewSourceMode_ParamsDataView input_data_view(params, message);

        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrame::Name_, 10, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->EnableViewSourceMode();
        return true;
    }
    case messages::LocalFrame::kFocus: {
        DCHECK(message->is_serialized());
        internal::LocalFrame_Focus_Params_Data* params = reinterpret_cast<internal::LocalFrame_Focus_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrame.11
        bool success = true;
        LocalFrame_Focus_ParamsDataView input_data_view(params, message);

        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrame::Name_, 11, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->Focus();
        return true;
    }
    case messages::LocalFrame::kClearFocusedElement: {
        DCHECK(message->is_serialized());
        internal::LocalFrame_ClearFocusedElement_Params_Data* params
            = reinterpret_cast<internal::LocalFrame_ClearFocusedElement_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrame.12
        bool success = true;
        LocalFrame_ClearFocusedElement_ParamsDataView input_data_view(params, message);

        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrame::Name_, 12, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->ClearFocusedElement();
        return true;
    }
    case messages::LocalFrame::kCopyImageAt: {
        DCHECK(message->is_serialized());
        internal::LocalFrame_CopyImageAt_Params_Data* params = reinterpret_cast<internal::LocalFrame_CopyImageAt_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrame.13
        bool success = true;
        ::gfx::Point p_window_point {};
        LocalFrame_CopyImageAt_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadWindowPoint(&p_window_point))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrame::Name_, 13, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->CopyImageAt(std::move(p_window_point));
        return true;
    }
    case messages::LocalFrame::kSaveImageAt: {
        DCHECK(message->is_serialized());
        internal::LocalFrame_SaveImageAt_Params_Data* params = reinterpret_cast<internal::LocalFrame_SaveImageAt_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrame.14
        bool success = true;
        ::gfx::Point p_window_point {};
        LocalFrame_SaveImageAt_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadWindowPoint(&p_window_point))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrame::Name_, 14, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->SaveImageAt(std::move(p_window_point));
        return true;
    }
    case messages::LocalFrame::kReportBlinkFeatureUsage: {
        DCHECK(message->is_serialized());
        internal::LocalFrame_ReportBlinkFeatureUsage_Params_Data* params
            = reinterpret_cast<internal::LocalFrame_ReportBlinkFeatureUsage_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrame.15
        bool success = true;
        WTF::Vector<::blink::mojom::blink::WebFeature> p_features {};
        LocalFrame_ReportBlinkFeatureUsage_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadFeatures(&p_features))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrame::Name_, 15, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->ReportBlinkFeatureUsage(std::move(p_features));
        return true;
    }
    case messages::LocalFrame::kRenderFallbackContent: {
        DCHECK(message->is_serialized());
        internal::LocalFrame_RenderFallbackContent_Params_Data* params
            = reinterpret_cast<internal::LocalFrame_RenderFallbackContent_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrame.16
        bool success = true;
        LocalFrame_RenderFallbackContent_ParamsDataView input_data_view(params, message);

        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrame::Name_, 16, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->RenderFallbackContent();
        return true;
    }
    case messages::LocalFrame::kBeforeUnload: {
        break;
    }
    case messages::LocalFrame::kMediaPlayerActionAt: {
        DCHECK(message->is_serialized());
        internal::LocalFrame_MediaPlayerActionAt_Params_Data* params
            = reinterpret_cast<internal::LocalFrame_MediaPlayerActionAt_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrame.18
        bool success = true;
        ::gfx::Point p_location {};
        ::blink::mojom::blink::MediaPlayerActionPtr p_action {};
        LocalFrame_MediaPlayerActionAt_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadLocation(&p_location))
            success = false;
        if (success && !input_data_view.ReadAction(&p_action))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrame::Name_, 18, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->MediaPlayerActionAt(std::move(p_location), std::move(p_action));
        return true;
    }
    case messages::LocalFrame::kRequestVideoFrameAtWithBoundsHint: {
        break;
    }
    case messages::LocalFrame::kPluginActionAt: {
        DCHECK(message->is_serialized());
        internal::LocalFrame_PluginActionAt_Params_Data* params
            = reinterpret_cast<internal::LocalFrame_PluginActionAt_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrame.20
        bool success = true;
        ::gfx::Point p_location {};
        PluginActionType p_action {};
        LocalFrame_PluginActionAt_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadLocation(&p_location))
            success = false;
        if (success && !input_data_view.ReadAction(&p_action))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrame::Name_, 20, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->PluginActionAt(std::move(p_location), std::move(p_action));
        return true;
    }
    case messages::LocalFrame::kAdvanceFocusInFrame: {
        DCHECK(message->is_serialized());
        internal::LocalFrame_AdvanceFocusInFrame_Params_Data* params
            = reinterpret_cast<internal::LocalFrame_AdvanceFocusInFrame_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrame.21
        bool success = true;
        ::blink::mojom::blink::FocusType p_focus_type {};
        std::optional<::blink::RemoteFrameToken> p_source_frame_token {};
        LocalFrame_AdvanceFocusInFrame_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadFocusType(&p_focus_type))
            success = false;
        if (success && !input_data_view.ReadSourceFrameToken(&p_source_frame_token))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrame::Name_, 21, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->AdvanceFocusInFrame(std::move(p_focus_type), std::move(p_source_frame_token));
        return true;
    }
    case messages::LocalFrame::kAdvanceFocusForIME: {
        DCHECK(message->is_serialized());
        internal::LocalFrame_AdvanceFocusForIME_Params_Data* params
            = reinterpret_cast<internal::LocalFrame_AdvanceFocusForIME_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrame.22
        bool success = true;
        ::blink::mojom::blink::FocusType p_focus_type {};
        LocalFrame_AdvanceFocusForIME_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadFocusType(&p_focus_type))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrame::Name_, 22, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->AdvanceFocusForIME(std::move(p_focus_type));
        return true;
    }
    case messages::LocalFrame::kReportContentSecurityPolicyViolation: {
        DCHECK(message->is_serialized());
        internal::LocalFrame_ReportContentSecurityPolicyViolation_Params_Data* params
            = reinterpret_cast<internal::LocalFrame_ReportContentSecurityPolicyViolation_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrame.23
        bool success = true;
        ::network::mojom::blink::CSPViolationPtr p_violation {};
        LocalFrame_ReportContentSecurityPolicyViolation_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadViolation(&p_violation))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrame::Name_, 23, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->ReportContentSecurityPolicyViolation(std::move(p_violation));
        return true;
    }
    case messages::LocalFrame::kDidUpdateFramePolicy: {
        DCHECK(message->is_serialized());
        internal::LocalFrame_DidUpdateFramePolicy_Params_Data* params
            = reinterpret_cast<internal::LocalFrame_DidUpdateFramePolicy_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrame.24
        bool success = true;
        ::blink::FramePolicy p_frame_policy {};
        LocalFrame_DidUpdateFramePolicy_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadFramePolicy(&p_frame_policy))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrame::Name_, 24, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->DidUpdateFramePolicy(std::move(p_frame_policy));
        return true;
    }
    case messages::LocalFrame::kOnFrameVisibilityChanged: {
        DCHECK(message->is_serialized());
        internal::LocalFrame_OnFrameVisibilityChanged_Params_Data* params
            = reinterpret_cast<internal::LocalFrame_OnFrameVisibilityChanged_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrame.25
        bool success = true;
        ::blink::mojom::blink::FrameVisibility p_visibility {};
        LocalFrame_OnFrameVisibilityChanged_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadVisibility(&p_visibility))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrame::Name_, 25, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->OnFrameVisibilityChanged(std::move(p_visibility));
        return true;
    }
    case messages::LocalFrame::kPostMessageEvent: {
        DCHECK(message->is_serialized());
        internal::LocalFrame_PostMessageEvent_Params_Data* params
            = reinterpret_cast<internal::LocalFrame_PostMessageEvent_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrame.26
        bool success = true;
        std::optional<::blink::RemoteFrameToken> p_source_frame_token {};
        ::WTF::String p_source_origin {};
        ::WTF::String p_target_origin {};
        ::blink::BlinkTransferableMessage p_message {};
        LocalFrame_PostMessageEvent_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadSourceFrameToken(&p_source_frame_token))
            success = false;
        if (success && !input_data_view.ReadSourceOrigin(&p_source_origin))
            success = false;
        if (success && !input_data_view.ReadTargetOrigin(&p_target_origin))
            success = false;
        if (success && !input_data_view.ReadMessage(&p_message))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrame::Name_, 26, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->PostMessageEvent(std::move(p_source_frame_token), std::move(p_source_origin), std::move(p_target_origin), std::move(p_message));
        return true;
    }
    case messages::LocalFrame::kJavaScriptMethodExecuteRequest: {
        break;
    }
    case messages::LocalFrame::kJavaScriptExecuteRequest: {
        break;
    }
    case messages::LocalFrame::kJavaScriptExecuteRequestForTests: {
        break;
    }
    case messages::LocalFrame::kJavaScriptExecuteRequestInIsolatedWorld: {
        break;
    }
    case messages::LocalFrame::kBindReportingObserver: {
        DCHECK(message->is_serialized());
        internal::LocalFrame_BindReportingObserver_Params_Data* params
            = reinterpret_cast<internal::LocalFrame_BindReportingObserver_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrame.31
        bool success = true;
        ::mojo::PendingReceiver<::blink::mojom::blink::ReportingObserver> p_receiver {};
        LocalFrame_BindReportingObserver_ParamsDataView input_data_view(params, message);

        if (success) {
            p_receiver = input_data_view.TakeReceiver<decltype(p_receiver)>();
        }
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrame::Name_, 31, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->BindReportingObserver(std::move(p_receiver));
        return true;
    }
    case messages::LocalFrame::kUpdateOpener: {
        DCHECK(message->is_serialized());
        internal::LocalFrame_UpdateOpener_Params_Data* params = reinterpret_cast<internal::LocalFrame_UpdateOpener_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrame.32
        bool success = true;
        std::optional<::blink::FrameToken> p_opener_frame_token {};
        LocalFrame_UpdateOpener_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadOpenerFrameToken(&p_opener_frame_token))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrame::Name_, 32, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->UpdateOpener(std::move(p_opener_frame_token));
        return true;
    }
    case messages::LocalFrame::kGetSavableResourceLinks: {
        break;
    }
    case messages::LocalFrame::kMixedContentFound: {
        DCHECK(message->is_serialized());
        internal::LocalFrame_MixedContentFound_Params_Data* params
            = reinterpret_cast<internal::LocalFrame_MixedContentFound_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrame.34
        bool success = true;
        ::blink::KURL p_main_resource_url {};
        ::blink::KURL p_mixed_content_url {};
        ::blink::mojom::blink::RequestContextType p_request_context {};
        bool p_was_allowed {};
        ::blink::KURL p_url_before_redirects {};
        bool p_had_redirect {};
        ::network::mojom::blink::SourceLocationPtr p_source_location {};
        LocalFrame_MixedContentFound_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadMainResourceUrl(&p_main_resource_url))
            success = false;
        if (success && !input_data_view.ReadMixedContentUrl(&p_mixed_content_url))
            success = false;
        if (success && !input_data_view.ReadRequestContext(&p_request_context))
            success = false;
        if (success)
            p_was_allowed = input_data_view.was_allowed();
        if (success && !input_data_view.ReadUrlBeforeRedirects(&p_url_before_redirects))
            success = false;
        if (success)
            p_had_redirect = input_data_view.had_redirect();
        if (success && !input_data_view.ReadSourceLocation(&p_source_location))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrame::Name_, 34, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->MixedContentFound(std::move(p_main_resource_url), std::move(p_mixed_content_url), std::move(p_request_context), std::move(p_was_allowed),
            std::move(p_url_before_redirects), std::move(p_had_redirect), std::move(p_source_location));
        return true;
    }
    case messages::LocalFrame::kBindDevToolsAgent: {
        DCHECK(message->is_serialized());
        internal::LocalFrame_BindDevToolsAgent_Params_Data* params
            = reinterpret_cast<internal::LocalFrame_BindDevToolsAgent_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrame.35
        bool success = true;
        ::mojo::PendingAssociatedRemote<::blink::mojom::blink::DevToolsAgentHost> p_agent_host {};
        ::mojo::PendingAssociatedReceiver<::blink::mojom::blink::DevToolsAgent> p_agent {};
        LocalFrame_BindDevToolsAgent_ParamsDataView input_data_view(params, message);

        if (success) {
            p_agent_host = input_data_view.TakeAgentHost<decltype(p_agent_host)>();
        }
        if (success) {
            p_agent = input_data_view.TakeAgent<decltype(p_agent)>();
        }
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrame::Name_, 35, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->BindDevToolsAgent(std::move(p_agent_host), std::move(p_agent));
        return true;
    }
    case messages::LocalFrame::kHandleRendererDebugURL: {
        DCHECK(message->is_serialized());
        internal::LocalFrame_HandleRendererDebugURL_Params_Data* params
            = reinterpret_cast<internal::LocalFrame_HandleRendererDebugURL_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrame.36
        bool success = true;
        ::blink::KURL p_url {};
        LocalFrame_HandleRendererDebugURL_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadUrl(&p_url))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrame::Name_, 36, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->HandleRendererDebugURL(std::move(p_url));
        return true;
    }
    case messages::LocalFrame::kGetCanonicalUrlForSharing: {
        break;
    }
    case messages::LocalFrame::kGetOpenGraphMetadata: {
        break;
    }
    case messages::LocalFrame::kSetNavigationApiHistoryEntriesForRestore: {
        DCHECK(message->is_serialized());
        internal::LocalFrame_SetNavigationApiHistoryEntriesForRestore_Params_Data* params
            = reinterpret_cast<internal::LocalFrame_SetNavigationApiHistoryEntriesForRestore_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrame.39
        bool success = true;
        ::blink::mojom::blink::NavigationApiHistoryEntryArraysPtr p_entry_arrays {};
        NavigationApiEntryRestoreReason p_restore_reason {};
        LocalFrame_SetNavigationApiHistoryEntriesForRestore_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadEntryArrays(&p_entry_arrays))
            success = false;
        if (success && !input_data_view.ReadRestoreReason(&p_restore_reason))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrame::Name_, 39, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->SetNavigationApiHistoryEntriesForRestore(std::move(p_entry_arrays), std::move(p_restore_reason));
        return true;
    }
    case messages::LocalFrame::kUpdatePrerenderURL: {
        break;
    }
    case messages::LocalFrame::kNotifyNavigationApiOfDisposedEntries: {
        DCHECK(message->is_serialized());
        internal::LocalFrame_NotifyNavigationApiOfDisposedEntries_Params_Data* params
            = reinterpret_cast<internal::LocalFrame_NotifyNavigationApiOfDisposedEntries_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrame.41
        bool success = true;
        WTF::Vector<WTF::String> p_keys {};
        LocalFrame_NotifyNavigationApiOfDisposedEntries_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadKeys(&p_keys))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrame::Name_, 41, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->NotifyNavigationApiOfDisposedEntries(std::move(p_keys));
        return true;
    }
    case messages::LocalFrame::kTraverseCancelled: {
        DCHECK(message->is_serialized());
        internal::LocalFrame_TraverseCancelled_Params_Data* params
            = reinterpret_cast<internal::LocalFrame_TraverseCancelled_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrame.42
        bool success = true;
        WTF::String p_navigation_api_key {};
        TraverseCancelledReason p_reason {};
        LocalFrame_TraverseCancelled_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadNavigationApiKey(&p_navigation_api_key))
            success = false;
        if (success && !input_data_view.ReadReason(&p_reason))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrame::Name_, 42, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->TraverseCancelled(std::move(p_navigation_api_key), std::move(p_reason));
        return true;
    }
    case messages::LocalFrame::kDispatchNavigateEventForCrossDocumentTraversal: {
        DCHECK(message->is_serialized());
        internal::LocalFrame_DispatchNavigateEventForCrossDocumentTraversal_Params_Data* params
            = reinterpret_cast<internal::LocalFrame_DispatchNavigateEventForCrossDocumentTraversal_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrame.43
        bool success = true;
        ::blink::KURL p_url {};
        std::string p_page_state {};
        bool p_is_browser_initiated {};
        LocalFrame_DispatchNavigateEventForCrossDocumentTraversal_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadUrl(&p_url))
            success = false;
        if (success && !input_data_view.ReadPageState(&p_page_state))
            success = false;
        if (success)
            p_is_browser_initiated = input_data_view.is_browser_initiated();
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrame::Name_, 43, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->DispatchNavigateEventForCrossDocumentTraversal(std::move(p_url), std::move(p_page_state), std::move(p_is_browser_initiated));
        return true;
    }
    case messages::LocalFrame::kSnapshotDocumentForViewTransition: {
        break;
    }
    case messages::LocalFrame::kNotifyViewTransitionAbortedToOldDocument: {
        DCHECK(message->is_serialized());
        internal::LocalFrame_NotifyViewTransitionAbortedToOldDocument_Params_Data* params
            = reinterpret_cast<internal::LocalFrame_NotifyViewTransitionAbortedToOldDocument_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrame.45
        bool success = true;
        LocalFrame_NotifyViewTransitionAbortedToOldDocument_ParamsDataView input_data_view(params, message);

        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrame::Name_, 45, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->NotifyViewTransitionAbortedToOldDocument();
        return true;
    }
    case messages::LocalFrame::kDispatchPageSwap: {
        DCHECK(message->is_serialized());
        internal::LocalFrame_DispatchPageSwap_Params_Data* params
            = reinterpret_cast<internal::LocalFrame_DispatchPageSwap_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrame.46
        bool success = true;
        ::blink::mojom::blink::PageSwapEventParamsPtr p_page_swap_event_params {};
        LocalFrame_DispatchPageSwap_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadPageSwapEventParams(&p_page_swap_event_params))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrame::Name_, 46, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->DispatchPageSwap(std::move(p_page_swap_event_params));
        return true;
    }
    case messages::LocalFrame::kAddResourceTimingEntryForFailedSubframeNavigation: {
        DCHECK(message->is_serialized());
        internal::LocalFrame_AddResourceTimingEntryForFailedSubframeNavigation_Params_Data* params
            = reinterpret_cast<internal::LocalFrame_AddResourceTimingEntryForFailedSubframeNavigation_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrame.47
        bool success = true;
        ::blink::FrameToken p_subframe_token {};
        ::blink::KURL p_initial_url {};
        ::base::TimeTicks p_start_time {};
        ::base::TimeTicks p_redirect_time {};
        ::base::TimeTicks p_request_start {};
        ::base::TimeTicks p_response_start {};
        uint32_t p_response_code {};
        WTF::String p_mime_type {};
        ::network::mojom::blink::LoadTimingInfoPtr p_load_timing_info {};
        ::net::HttpConnectionInfo p_connection_info {};
        WTF::String p_alpn_negotiated_protocol {};
        bool p_is_secure_transport {};
        bool p_is_validated {};
        WTF::String p_normalized_server_timing {};
        ::network::URLLoaderCompletionStatus p_completion_status {};
        LocalFrame_AddResourceTimingEntryForFailedSubframeNavigation_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadSubframeToken(&p_subframe_token))
            success = false;
        if (success && !input_data_view.ReadInitialUrl(&p_initial_url))
            success = false;
        if (success && !input_data_view.ReadStartTime(&p_start_time))
            success = false;
        if (success && !input_data_view.ReadRedirectTime(&p_redirect_time))
            success = false;
        if (success && !input_data_view.ReadRequestStart(&p_request_start))
            success = false;
        if (success && !input_data_view.ReadResponseStart(&p_response_start))
            success = false;
        if (success)
            p_response_code = input_data_view.response_code();
        if (success && !input_data_view.ReadMimeType(&p_mime_type))
            success = false;
        if (success && !input_data_view.ReadLoadTimingInfo(&p_load_timing_info))
            success = false;
        if (success && !input_data_view.ReadConnectionInfo(&p_connection_info))
            success = false;
        if (success && !input_data_view.ReadAlpnNegotiatedProtocol(&p_alpn_negotiated_protocol))
            success = false;
        if (success)
            p_is_secure_transport = input_data_view.is_secure_transport();
        if (success)
            p_is_validated = input_data_view.is_validated();
        if (success && !input_data_view.ReadNormalizedServerTiming(&p_normalized_server_timing))
            success = false;
        if (success && !input_data_view.ReadCompletionStatus(&p_completion_status))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrame::Name_, 47, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->AddResourceTimingEntryForFailedSubframeNavigation(std::move(p_subframe_token), std::move(p_initial_url), std::move(p_start_time),
            std::move(p_redirect_time), std::move(p_request_start), std::move(p_response_start), std::move(p_response_code), std::move(p_mime_type),
            std::move(p_load_timing_info), std::move(p_connection_info), std::move(p_alpn_negotiated_protocol), std::move(p_is_secure_transport),
            std::move(p_is_validated), std::move(p_normalized_server_timing), std::move(p_completion_status));
        return true;
    }
    }
    return false;
}

// static
bool LocalFrameStubDispatch::AcceptWithResponder(LocalFrame* impl, mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
{
    [[maybe_unused]] const bool message_is_sync = message->has_flag(mojo::Message::kFlagIsSync);
    [[maybe_unused]] const uint64_t request_id = message->request_id();
    switch (static_cast<messages::LocalFrame>(message->header()->name)) {
    case messages::LocalFrame::kGetTextSurroundingSelection: {
        internal::LocalFrame_GetTextSurroundingSelection_Params_Data* params
            = reinterpret_cast<internal::LocalFrame_GetTextSurroundingSelection_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrame.0
        bool success = true;
        uint32_t p_max_length {};
        LocalFrame_GetTextSurroundingSelection_ParamsDataView input_data_view(params, message);

        if (success)
            p_max_length = input_data_view.max_length();
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrame::Name_, 0, false);
            return false;
        }
        LocalFrame::GetTextSurroundingSelectionCallback callback
            = LocalFrame_GetTextSurroundingSelection_ProxyToResponder::CreateCallback(*message, std::move(responder));
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->GetTextSurroundingSelection(std::move(p_max_length), std::move(callback));
        return true;
    }
    case messages::LocalFrame::kSendInterventionReport: {
        break;
    }
    case messages::LocalFrame::kSetFrameOwnerProperties: {
        break;
    }
    case messages::LocalFrame::kNotifyUserActivation: {
        break;
    }
    case messages::LocalFrame::kNotifyVirtualKeyboardOverlayRect: {
        break;
    }
    case messages::LocalFrame::kAddMessageToConsole: {
        break;
    }
    case messages::LocalFrame::kSwapInImmediately: {
        break;
    }
    case messages::LocalFrame::kCheckCompleted: {
        break;
    }
    case messages::LocalFrame::kStopLoading: {
        break;
    }
    case messages::LocalFrame::kCollapse: {
        break;
    }
    case messages::LocalFrame::kEnableViewSourceMode: {
        break;
    }
    case messages::LocalFrame::kFocus: {
        break;
    }
    case messages::LocalFrame::kClearFocusedElement: {
        break;
    }
    case messages::LocalFrame::kCopyImageAt: {
        break;
    }
    case messages::LocalFrame::kSaveImageAt: {
        break;
    }
    case messages::LocalFrame::kReportBlinkFeatureUsage: {
        break;
    }
    case messages::LocalFrame::kRenderFallbackContent: {
        break;
    }
    case messages::LocalFrame::kBeforeUnload: {
        internal::LocalFrame_BeforeUnload_Params_Data* params = reinterpret_cast<internal::LocalFrame_BeforeUnload_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrame.17
        bool success = true;
        bool p_is_reload {};
        LocalFrame_BeforeUnload_ParamsDataView input_data_view(params, message);

        if (success)
            p_is_reload = input_data_view.is_reload();
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrame::Name_, 17, false);
            return false;
        }
        LocalFrame::BeforeUnloadCallback callback = LocalFrame_BeforeUnload_ProxyToResponder::CreateCallback(*message, std::move(responder));
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->BeforeUnload(std::move(p_is_reload), std::move(callback));
        return true;
    }
    case messages::LocalFrame::kMediaPlayerActionAt: {
        break;
    }
    case messages::LocalFrame::kRequestVideoFrameAtWithBoundsHint: {
        internal::LocalFrame_RequestVideoFrameAtWithBoundsHint_Params_Data* params
            = reinterpret_cast<internal::LocalFrame_RequestVideoFrameAtWithBoundsHint_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrame.19
        bool success = true;
        ::gfx::Point p_location {};
        ::gfx::Size p_max_size {};
        int32_t p_max_area {};
        LocalFrame_RequestVideoFrameAtWithBoundsHint_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadLocation(&p_location))
            success = false;
        if (success && !input_data_view.ReadMaxSize(&p_max_size))
            success = false;
        if (success)
            p_max_area = input_data_view.max_area();
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrame::Name_, 19, false);
            return false;
        }
        LocalFrame::RequestVideoFrameAtWithBoundsHintCallback callback
            = LocalFrame_RequestVideoFrameAtWithBoundsHint_ProxyToResponder::CreateCallback(*message, std::move(responder));
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->RequestVideoFrameAtWithBoundsHint(std::move(p_location), std::move(p_max_size), std::move(p_max_area), std::move(callback));
        return true;
    }
    case messages::LocalFrame::kPluginActionAt: {
        break;
    }
    case messages::LocalFrame::kAdvanceFocusInFrame: {
        break;
    }
    case messages::LocalFrame::kAdvanceFocusForIME: {
        break;
    }
    case messages::LocalFrame::kReportContentSecurityPolicyViolation: {
        break;
    }
    case messages::LocalFrame::kDidUpdateFramePolicy: {
        break;
    }
    case messages::LocalFrame::kOnFrameVisibilityChanged: {
        break;
    }
    case messages::LocalFrame::kPostMessageEvent: {
        break;
    }
    case messages::LocalFrame::kJavaScriptMethodExecuteRequest: {
        internal::LocalFrame_JavaScriptMethodExecuteRequest_Params_Data* params
            = reinterpret_cast<internal::LocalFrame_JavaScriptMethodExecuteRequest_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrame.27
        bool success = true;
        ::WTF::String p_object_name {};
        ::WTF::String p_method_name {};
        ::base::Value::List p_arguments {};
        bool p_wants_result {};
        LocalFrame_JavaScriptMethodExecuteRequest_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadObjectName(&p_object_name))
            success = false;
        if (success && !input_data_view.ReadMethodName(&p_method_name))
            success = false;
        if (success && !input_data_view.ReadArguments(&p_arguments))
            success = false;
        if (success)
            p_wants_result = input_data_view.wants_result();
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrame::Name_, 27, false);
            return false;
        }
        LocalFrame::JavaScriptMethodExecuteRequestCallback callback
            = LocalFrame_JavaScriptMethodExecuteRequest_ProxyToResponder::CreateCallback(*message, std::move(responder));
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->JavaScriptMethodExecuteRequest(
            std::move(p_object_name), std::move(p_method_name), std::move(p_arguments), std::move(p_wants_result), std::move(callback));
        return true;
    }
    case messages::LocalFrame::kJavaScriptExecuteRequest: {
        internal::LocalFrame_JavaScriptExecuteRequest_Params_Data* params
            = reinterpret_cast<internal::LocalFrame_JavaScriptExecuteRequest_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrame.28
        bool success = true;
        ::WTF::String p_javascript {};
        bool p_wants_result {};
        LocalFrame_JavaScriptExecuteRequest_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadJavascript(&p_javascript))
            success = false;
        if (success)
            p_wants_result = input_data_view.wants_result();
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrame::Name_, 28, false);
            return false;
        }
        LocalFrame::JavaScriptExecuteRequestCallback callback
            = LocalFrame_JavaScriptExecuteRequest_ProxyToResponder::CreateCallback(*message, std::move(responder));
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->JavaScriptExecuteRequest(std::move(p_javascript), std::move(p_wants_result), std::move(callback));
        return true;
    }
    case messages::LocalFrame::kJavaScriptExecuteRequestForTests: {
        internal::LocalFrame_JavaScriptExecuteRequestForTests_Params_Data* params
            = reinterpret_cast<internal::LocalFrame_JavaScriptExecuteRequestForTests_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrame.29
        bool success = true;
        ::WTF::String p_javascript {};
        bool p_has_user_gesture {};
        bool p_resolve_promises {};
        bool p_honor_js_content_settings {};
        int32_t p_world_id {};
        LocalFrame_JavaScriptExecuteRequestForTests_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadJavascript(&p_javascript))
            success = false;
        if (success)
            p_has_user_gesture = input_data_view.has_user_gesture();
        if (success)
            p_resolve_promises = input_data_view.resolve_promises();
        if (success)
            p_honor_js_content_settings = input_data_view.honor_js_content_settings();
        if (success)
            p_world_id = input_data_view.world_id();
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrame::Name_, 29, false);
            return false;
        }
        LocalFrame::JavaScriptExecuteRequestForTestsCallback callback
            = LocalFrame_JavaScriptExecuteRequestForTests_ProxyToResponder::CreateCallback(*message, std::move(responder));
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->JavaScriptExecuteRequestForTests(std::move(p_javascript), std::move(p_has_user_gesture), std::move(p_resolve_promises),
            std::move(p_honor_js_content_settings), std::move(p_world_id), std::move(callback));
        return true;
    }
    case messages::LocalFrame::kJavaScriptExecuteRequestInIsolatedWorld: {
        internal::LocalFrame_JavaScriptExecuteRequestInIsolatedWorld_Params_Data* params
            = reinterpret_cast<internal::LocalFrame_JavaScriptExecuteRequestInIsolatedWorld_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrame.30
        bool success = true;
        ::WTF::String p_javascript {};
        bool p_wants_result {};
        int32_t p_world_id {};
        LocalFrame_JavaScriptExecuteRequestInIsolatedWorld_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadJavascript(&p_javascript))
            success = false;
        if (success)
            p_wants_result = input_data_view.wants_result();
        if (success)
            p_world_id = input_data_view.world_id();
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrame::Name_, 30, false);
            return false;
        }
        LocalFrame::JavaScriptExecuteRequestInIsolatedWorldCallback callback
            = LocalFrame_JavaScriptExecuteRequestInIsolatedWorld_ProxyToResponder::CreateCallback(*message, std::move(responder));
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->JavaScriptExecuteRequestInIsolatedWorld(std::move(p_javascript), std::move(p_wants_result), std::move(p_world_id), std::move(callback));
        return true;
    }
    case messages::LocalFrame::kBindReportingObserver: {
        break;
    }
    case messages::LocalFrame::kUpdateOpener: {
        break;
    }
    case messages::LocalFrame::kGetSavableResourceLinks: {
        internal::LocalFrame_GetSavableResourceLinks_Params_Data* params
            = reinterpret_cast<internal::LocalFrame_GetSavableResourceLinks_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrame.33
        bool success = true;
        LocalFrame_GetSavableResourceLinks_ParamsDataView input_data_view(params, message);

        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrame::Name_, 33, false);
            return false;
        }
        LocalFrame::GetSavableResourceLinksCallback callback
            = LocalFrame_GetSavableResourceLinks_ProxyToResponder::CreateCallback(*message, std::move(responder));
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->GetSavableResourceLinks(std::move(callback));
        return true;
    }
    case messages::LocalFrame::kMixedContentFound: {
        break;
    }
    case messages::LocalFrame::kBindDevToolsAgent: {
        break;
    }
    case messages::LocalFrame::kHandleRendererDebugURL: {
        break;
    }
    case messages::LocalFrame::kGetCanonicalUrlForSharing: {
        internal::LocalFrame_GetCanonicalUrlForSharing_Params_Data* params
            = reinterpret_cast<internal::LocalFrame_GetCanonicalUrlForSharing_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrame.37
        bool success = true;
        LocalFrame_GetCanonicalUrlForSharing_ParamsDataView input_data_view(params, message);

        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrame::Name_, 37, false);
            return false;
        }
        LocalFrame::GetCanonicalUrlForSharingCallback callback
            = LocalFrame_GetCanonicalUrlForSharing_ProxyToResponder::CreateCallback(*message, std::move(responder));
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->GetCanonicalUrlForSharing(std::move(callback));
        return true;
    }
    case messages::LocalFrame::kGetOpenGraphMetadata: {
        internal::LocalFrame_GetOpenGraphMetadata_Params_Data* params
            = reinterpret_cast<internal::LocalFrame_GetOpenGraphMetadata_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrame.38
        bool success = true;
        LocalFrame_GetOpenGraphMetadata_ParamsDataView input_data_view(params, message);

        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrame::Name_, 38, false);
            return false;
        }
        LocalFrame::GetOpenGraphMetadataCallback callback = LocalFrame_GetOpenGraphMetadata_ProxyToResponder::CreateCallback(*message, std::move(responder));
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->GetOpenGraphMetadata(std::move(callback));
        return true;
    }
    case messages::LocalFrame::kSetNavigationApiHistoryEntriesForRestore: {
        break;
    }
    case messages::LocalFrame::kUpdatePrerenderURL: {
        internal::LocalFrame_UpdatePrerenderURL_Params_Data* params
            = reinterpret_cast<internal::LocalFrame_UpdatePrerenderURL_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrame.40
        bool success = true;
        ::blink::KURL p_matched_url {};
        LocalFrame_UpdatePrerenderURL_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadMatchedUrl(&p_matched_url))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrame::Name_, 40, false);
            return false;
        }
        LocalFrame::UpdatePrerenderURLCallback callback = LocalFrame_UpdatePrerenderURL_ProxyToResponder::CreateCallback(*message, std::move(responder));
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->UpdatePrerenderURL(std::move(p_matched_url), std::move(callback));
        return true;
    }
    case messages::LocalFrame::kNotifyNavigationApiOfDisposedEntries: {
        break;
    }
    case messages::LocalFrame::kTraverseCancelled: {
        break;
    }
    case messages::LocalFrame::kDispatchNavigateEventForCrossDocumentTraversal: {
        break;
    }
    case messages::LocalFrame::kSnapshotDocumentForViewTransition: {
        internal::LocalFrame_SnapshotDocumentForViewTransition_Params_Data* params
            = reinterpret_cast<internal::LocalFrame_SnapshotDocumentForViewTransition_Params_Data*>(message->mutable_payload());

        // Validation for LocalFrame.44
        bool success = true;
        ::blink::ViewTransitionToken p_transition_token {};
        ::blink::mojom::blink::PageSwapEventParamsPtr p_page_swap_event_params {};
        LocalFrame_SnapshotDocumentForViewTransition_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadTransitionToken(&p_transition_token))
            success = false;
        if (success && !input_data_view.ReadPageSwapEventParams(&p_page_swap_event_params))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalFrame::Name_, 44, false);
            return false;
        }
        LocalFrame::SnapshotDocumentForViewTransitionCallback callback
            = LocalFrame_SnapshotDocumentForViewTransition_ProxyToResponder::CreateCallback(*message, std::move(responder));
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->SnapshotDocumentForViewTransition(std::move(p_transition_token), std::move(p_page_swap_event_params), std::move(callback));
        return true;
    }
    case messages::LocalFrame::kNotifyViewTransitionAbortedToOldDocument: {
        break;
    }
    case messages::LocalFrame::kDispatchPageSwap: {
        break;
    }
    case messages::LocalFrame::kAddResourceTimingEntryForFailedSubframeNavigation: {
        break;
    }
    }
    return false;
}
namespace {
} // namespace
static const mojo::internal::GenericValidationInfo kLocalFrameValidationInfo[] = {
    { &internal::LocalFrame_GetTextSurroundingSelection_Params_Data::Validate,
        &internal::LocalFrame_GetTextSurroundingSelection_ResponseParams_Data::Validate },
    { &internal::LocalFrame_SendInterventionReport_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrame_SetFrameOwnerProperties_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrame_NotifyUserActivation_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrame_NotifyVirtualKeyboardOverlayRect_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrame_AddMessageToConsole_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrame_SwapInImmediately_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrame_CheckCompleted_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrame_StopLoading_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrame_Collapse_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrame_EnableViewSourceMode_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrame_Focus_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrame_ClearFocusedElement_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrame_CopyImageAt_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrame_SaveImageAt_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrame_ReportBlinkFeatureUsage_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrame_RenderFallbackContent_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrame_BeforeUnload_Params_Data::Validate, &internal::LocalFrame_BeforeUnload_ResponseParams_Data::Validate },
    { &internal::LocalFrame_MediaPlayerActionAt_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrame_RequestVideoFrameAtWithBoundsHint_Params_Data::Validate,
        &internal::LocalFrame_RequestVideoFrameAtWithBoundsHint_ResponseParams_Data::Validate },
    { &internal::LocalFrame_PluginActionAt_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrame_AdvanceFocusInFrame_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrame_AdvanceFocusForIME_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrame_ReportContentSecurityPolicyViolation_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrame_DidUpdateFramePolicy_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrame_OnFrameVisibilityChanged_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrame_PostMessageEvent_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrame_JavaScriptMethodExecuteRequest_Params_Data::Validate,
        &internal::LocalFrame_JavaScriptMethodExecuteRequest_ResponseParams_Data::Validate },
    { &internal::LocalFrame_JavaScriptExecuteRequest_Params_Data::Validate, &internal::LocalFrame_JavaScriptExecuteRequest_ResponseParams_Data::Validate },
    { &internal::LocalFrame_JavaScriptExecuteRequestForTests_Params_Data::Validate,
        &internal::LocalFrame_JavaScriptExecuteRequestForTests_ResponseParams_Data::Validate },
    { &internal::LocalFrame_JavaScriptExecuteRequestInIsolatedWorld_Params_Data::Validate,
        &internal::LocalFrame_JavaScriptExecuteRequestInIsolatedWorld_ResponseParams_Data::Validate },
    { &internal::LocalFrame_BindReportingObserver_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrame_UpdateOpener_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrame_GetSavableResourceLinks_Params_Data::Validate, &internal::LocalFrame_GetSavableResourceLinks_ResponseParams_Data::Validate },
    { &internal::LocalFrame_MixedContentFound_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrame_BindDevToolsAgent_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrame_HandleRendererDebugURL_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrame_GetCanonicalUrlForSharing_Params_Data::Validate, &internal::LocalFrame_GetCanonicalUrlForSharing_ResponseParams_Data::Validate },
    { &internal::LocalFrame_GetOpenGraphMetadata_Params_Data::Validate, &internal::LocalFrame_GetOpenGraphMetadata_ResponseParams_Data::Validate },
    { &internal::LocalFrame_SetNavigationApiHistoryEntriesForRestore_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrame_UpdatePrerenderURL_Params_Data::Validate, &internal::LocalFrame_UpdatePrerenderURL_ResponseParams_Data::Validate },
    { &internal::LocalFrame_NotifyNavigationApiOfDisposedEntries_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrame_TraverseCancelled_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrame_DispatchNavigateEventForCrossDocumentTraversal_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrame_SnapshotDocumentForViewTransition_Params_Data::Validate,
        &internal::LocalFrame_SnapshotDocumentForViewTransition_ResponseParams_Data::Validate },
    { &internal::LocalFrame_NotifyViewTransitionAbortedToOldDocument_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrame_DispatchPageSwap_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalFrame_AddResourceTimingEntryForFailedSubframeNavigation_Params_Data::Validate, nullptr /* no response */ },
};

bool LocalFrameRequestValidator::Accept(mojo::Message* message)
{
    const char* name = ::blink::mojom::blink::LocalFrame::Name_;
    return mojo::internal::ValidateRequestGenericPacked(message, name, kLocalFrameValidationInfo);
}

bool LocalFrameResponseValidator::Accept(mojo::Message* message)
{
    const char* name = ::blink::mojom::blink::LocalFrame::Name_;
    return mojo::internal::ValidateResponseGenericPacked(message, name, kLocalFrameValidationInfo);
}
const char LocalMainFrame::Name_[] = "blink.mojom.LocalMainFrame";

LocalMainFrame::IPCStableHashFunction LocalMainFrame::MessageToMethodInfo_(mojo::Message& message)
{
#if !BUILDFLAG(IS_FUCHSIA)
    switch (static_cast<messages::LocalMainFrame>(message.name())) {
    case messages::LocalMainFrame::kAnimateDoubleTapZoom: {
        return &LocalMainFrame::AnimateDoubleTapZoom_Sym::IPCStableHash;
    }
    case messages::LocalMainFrame::kSetScaleFactor: {
        return &LocalMainFrame::SetScaleFactor_Sym::IPCStableHash;
    }
    case messages::LocalMainFrame::kClosePage: {
        return &LocalMainFrame::ClosePage_Sym::IPCStableHash;
    }
    case messages::LocalMainFrame::kGetFullPageSize: {
        return &LocalMainFrame::GetFullPageSize_Sym::IPCStableHash;
    }
    case messages::LocalMainFrame::kSetInitialFocus: {
        return &LocalMainFrame::SetInitialFocus_Sym::IPCStableHash;
    }
    case messages::LocalMainFrame::kEnablePreferredSizeChangedMode: {
        return &LocalMainFrame::EnablePreferredSizeChangedMode_Sym::IPCStableHash;
    }
    case messages::LocalMainFrame::kZoomToFindInPageRect: {
        return &LocalMainFrame::ZoomToFindInPageRect_Sym::IPCStableHash;
    }
    case messages::LocalMainFrame::kInstallCoopAccessMonitor: {
        return &LocalMainFrame::InstallCoopAccessMonitor_Sym::IPCStableHash;
    }
    case messages::LocalMainFrame::kUpdateBrowserControlsState: {
        return &LocalMainFrame::UpdateBrowserControlsState_Sym::IPCStableHash;
    }
    case messages::LocalMainFrame::kSetV8CompileHints: {
        return &LocalMainFrame::SetV8CompileHints_Sym::IPCStableHash;
    }
    case messages::LocalMainFrame::kDiscard: {
        return &LocalMainFrame::Discard_Sym::IPCStableHash;
    }
    case messages::LocalMainFrame::kFinalizeNavigationConfidence: {
        return &LocalMainFrame::FinalizeNavigationConfidence_Sym::IPCStableHash;
    }
    }
#endif // !BUILDFLAG(IS_FUCHSIA)
    return nullptr;
}

const char* LocalMainFrame::MessageToMethodName_(mojo::Message& message)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
    if (!is_response) {
        switch (static_cast<messages::LocalMainFrame>(message.name())) {
        case messages::LocalMainFrame::kAnimateDoubleTapZoom:
            return "Receive blink::mojom::LocalMainFrame::AnimateDoubleTapZoom";
        case messages::LocalMainFrame::kSetScaleFactor:
            return "Receive blink::mojom::LocalMainFrame::SetScaleFactor";
        case messages::LocalMainFrame::kClosePage:
            return "Receive blink::mojom::LocalMainFrame::ClosePage";
        case messages::LocalMainFrame::kGetFullPageSize:
            return "Receive blink::mojom::LocalMainFrame::GetFullPageSize";
        case messages::LocalMainFrame::kSetInitialFocus:
            return "Receive blink::mojom::LocalMainFrame::SetInitialFocus";
        case messages::LocalMainFrame::kEnablePreferredSizeChangedMode:
            return "Receive blink::mojom::LocalMainFrame::EnablePreferredSizeChangedMode";
        case messages::LocalMainFrame::kZoomToFindInPageRect:
            return "Receive blink::mojom::LocalMainFrame::ZoomToFindInPageRect";
        case messages::LocalMainFrame::kInstallCoopAccessMonitor:
            return "Receive blink::mojom::LocalMainFrame::InstallCoopAccessMonitor";
        case messages::LocalMainFrame::kUpdateBrowserControlsState:
            return "Receive blink::mojom::LocalMainFrame::UpdateBrowserControlsState";
        case messages::LocalMainFrame::kSetV8CompileHints:
            return "Receive blink::mojom::LocalMainFrame::SetV8CompileHints";
        case messages::LocalMainFrame::kDiscard:
            return "Receive blink::mojom::LocalMainFrame::Discard";
        case messages::LocalMainFrame::kFinalizeNavigationConfidence:
            return "Receive blink::mojom::LocalMainFrame::FinalizeNavigationConfidence";
        }
    } else {
        switch (static_cast<messages::LocalMainFrame>(message.name())) {
        case messages::LocalMainFrame::kAnimateDoubleTapZoom:
            return "Receive reply blink::mojom::LocalMainFrame::AnimateDoubleTapZoom";
        case messages::LocalMainFrame::kSetScaleFactor:
            return "Receive reply blink::mojom::LocalMainFrame::SetScaleFactor";
        case messages::LocalMainFrame::kClosePage:
            return "Receive reply blink::mojom::LocalMainFrame::ClosePage";
        case messages::LocalMainFrame::kGetFullPageSize:
            return "Receive reply blink::mojom::LocalMainFrame::GetFullPageSize";
        case messages::LocalMainFrame::kSetInitialFocus:
            return "Receive reply blink::mojom::LocalMainFrame::SetInitialFocus";
        case messages::LocalMainFrame::kEnablePreferredSizeChangedMode:
            return "Receive reply blink::mojom::LocalMainFrame::EnablePreferredSizeChangedMode";
        case messages::LocalMainFrame::kZoomToFindInPageRect:
            return "Receive reply blink::mojom::LocalMainFrame::ZoomToFindInPageRect";
        case messages::LocalMainFrame::kInstallCoopAccessMonitor:
            return "Receive reply blink::mojom::LocalMainFrame::InstallCoopAccessMonitor";
        case messages::LocalMainFrame::kUpdateBrowserControlsState:
            return "Receive reply blink::mojom::LocalMainFrame::UpdateBrowserControlsState";
        case messages::LocalMainFrame::kSetV8CompileHints:
            return "Receive reply blink::mojom::LocalMainFrame::SetV8CompileHints";
        case messages::LocalMainFrame::kDiscard:
            return "Receive reply blink::mojom::LocalMainFrame::Discard";
        case messages::LocalMainFrame::kFinalizeNavigationConfidence:
            return "Receive reply blink::mojom::LocalMainFrame::FinalizeNavigationConfidence";
        }
    }
    return "Receive unknown mojo message";
#else
    bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
    if (is_response) {
        return "Receive mojo reply";
    } else {
        return "Receive mojo message";
    }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t LocalMainFrame::AnimateDoubleTapZoom_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalMainFrame::AnimateDoubleTapZoom");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalMainFrame::SetScaleFactor_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalMainFrame::SetScaleFactor");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalMainFrame::ClosePage_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalMainFrame::ClosePage");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalMainFrame::GetFullPageSize_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalMainFrame::GetFullPageSize");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalMainFrame::SetInitialFocus_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalMainFrame::SetInitialFocus");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalMainFrame::EnablePreferredSizeChangedMode_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalMainFrame::EnablePreferredSizeChangedMode");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalMainFrame::ZoomToFindInPageRect_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalMainFrame::ZoomToFindInPageRect");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalMainFrame::InstallCoopAccessMonitor_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalMainFrame::InstallCoopAccessMonitor");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalMainFrame::UpdateBrowserControlsState_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalMainFrame::UpdateBrowserControlsState");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalMainFrame::SetV8CompileHints_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalMainFrame::SetV8CompileHints");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalMainFrame::Discard_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalMainFrame::Discard");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalMainFrame::FinalizeNavigationConfidence_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalMainFrame::FinalizeNavigationConfidence");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
#endif // !BUILDFLAG(IS_FUCHSIA)

class LocalMainFrame_ClosePage_ForwardToCallback : public mojo::MessageReceiver {
public:
    LocalMainFrame_ClosePage_ForwardToCallback(LocalMainFrame::ClosePageCallback callback)
        : callback_(std::move(callback))
    {
    }

    LocalMainFrame_ClosePage_ForwardToCallback(const LocalMainFrame_ClosePage_ForwardToCallback&) = delete;
    LocalMainFrame_ClosePage_ForwardToCallback& operator=(const LocalMainFrame_ClosePage_ForwardToCallback&) = delete;

    bool Accept(mojo::Message* message) override;

private:
    LocalMainFrame::ClosePageCallback callback_;
};

class LocalMainFrame_GetFullPageSize_ForwardToCallback : public mojo::MessageReceiver {
public:
    LocalMainFrame_GetFullPageSize_ForwardToCallback(LocalMainFrame::GetFullPageSizeCallback callback)
        : callback_(std::move(callback))
    {
    }

    LocalMainFrame_GetFullPageSize_ForwardToCallback(const LocalMainFrame_GetFullPageSize_ForwardToCallback&) = delete;
    LocalMainFrame_GetFullPageSize_ForwardToCallback& operator=(const LocalMainFrame_GetFullPageSize_ForwardToCallback&) = delete;

    bool Accept(mojo::Message* message) override;

private:
    LocalMainFrame::GetFullPageSizeCallback callback_;
};

LocalMainFrameProxy::LocalMainFrameProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver)
{
}

void LocalMainFrameProxy::AnimateDoubleTapZoom(const ::gfx::Point& in_point, const ::gfx::Rect& in_rect)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalMainFrame::AnimateDoubleTapZoom", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("point"), in_point, "<value of type const ::gfx::Point&>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("rect"), in_rect, "<value of type const ::gfx::Rect&>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalMainFrame::kAnimateDoubleTapZoom), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalMainFrame_AnimateDoubleTapZoom_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->point)::BaseType> point_fragment(params.message());
    mojo::internal::Serialize<::gfx::mojom::PointDataView>(in_point, point_fragment);
    params->point.Set(point_fragment.is_null() ? nullptr : point_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->point.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null point in LocalMainFrame.AnimateDoubleTapZoom request");
    mojo::internal::MessageFragment<typename decltype(params->rect)::BaseType> rect_fragment(params.message());
    mojo::internal::Serialize<::gfx::mojom::RectDataView>(in_rect, rect_fragment);
    params->rect.Set(rect_fragment.is_null() ? nullptr : rect_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->rect.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null rect in LocalMainFrame.AnimateDoubleTapZoom request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalMainFrame::Name_);
    message.set_method_name("AnimateDoubleTapZoom");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalMainFrameProxy::SetScaleFactor(float in_scale)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalMainFrame::SetScaleFactor", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("scale"), in_scale, "<value of type float>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalMainFrame::kSetScaleFactor), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalMainFrame_SetScaleFactor_Params_Data> params(message);
    params.Allocate();
    params->scale = in_scale;

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalMainFrame::Name_);
    message.set_method_name("SetScaleFactor");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalMainFrameProxy::ClosePage(ClosePageCallback callback)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT0("mojom", "Send blink::mojom::LocalMainFrame::ClosePage");
#endif

    const bool kExpectsResponse = true;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalMainFrame::kClosePage), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalMainFrame_ClosePage_Params_Data> params(message);
    params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalMainFrame::Name_);
    message.set_method_name("ClosePage");
#endif
    std::unique_ptr<mojo::MessageReceiver> responder(new LocalMainFrame_ClosePage_ForwardToCallback(std::move(callback)));
    ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void LocalMainFrameProxy::GetFullPageSize(GetFullPageSizeCallback callback)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT0("mojom", "Send blink::mojom::LocalMainFrame::GetFullPageSize");
#endif

    const bool kExpectsResponse = true;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalMainFrame::kGetFullPageSize), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalMainFrame_GetFullPageSize_Params_Data> params(message);
    params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalMainFrame::Name_);
    message.set_method_name("GetFullPageSize");
#endif
    std::unique_ptr<mojo::MessageReceiver> responder(new LocalMainFrame_GetFullPageSize_ForwardToCallback(std::move(callback)));
    ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void LocalMainFrameProxy::SetInitialFocus(bool in_reverse)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalMainFrame::SetInitialFocus", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("reverse"), in_reverse, "<value of type bool>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalMainFrame::kSetInitialFocus), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalMainFrame_SetInitialFocus_Params_Data> params(message);
    params.Allocate();
    params->reverse = in_reverse;

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalMainFrame::Name_);
    message.set_method_name("SetInitialFocus");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalMainFrameProxy::EnablePreferredSizeChangedMode()
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT0("mojom", "Send blink::mojom::LocalMainFrame::EnablePreferredSizeChangedMode");
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalMainFrame::kEnablePreferredSizeChangedMode), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalMainFrame_EnablePreferredSizeChangedMode_Params_Data> params(message);
    params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalMainFrame::Name_);
    message.set_method_name("EnablePreferredSizeChangedMode");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalMainFrameProxy::ZoomToFindInPageRect(const ::gfx::Rect& in_rect_in_root_frame)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalMainFrame::ZoomToFindInPageRect", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("rect_in_root_frame"), in_rect_in_root_frame, "<value of type const ::gfx::Rect&>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalMainFrame::kZoomToFindInPageRect), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalMainFrame_ZoomToFindInPageRect_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->rect_in_root_frame)::BaseType> rect_in_root_frame_fragment(params.message());
    mojo::internal::Serialize<::gfx::mojom::RectDataView>(in_rect_in_root_frame, rect_in_root_frame_fragment);
    params->rect_in_root_frame.Set(rect_in_root_frame_fragment.is_null() ? nullptr : rect_in_root_frame_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->rect_in_root_frame.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null rect_in_root_frame in LocalMainFrame.ZoomToFindInPageRect request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalMainFrame::Name_);
    message.set_method_name("ZoomToFindInPageRect");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalMainFrameProxy::InstallCoopAccessMonitor(const ::blink::FrameToken& in_accessed_window,
    ::network::mojom::blink::CrossOriginOpenerPolicyReporterParamsPtr in_coop_reporter_info, bool in_is_in_same_virtual_coop_related_group)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalMainFrame::InstallCoopAccessMonitor", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("accessed_window"), in_accessed_window, "<value of type const ::blink::FrameToken&>");
        perfetto::WriteIntoTracedValueWithFallback(
            dict.AddItem("coop_reporter_info"), in_coop_reporter_info, "<value of type ::network::mojom::blink::CrossOriginOpenerPolicyReporterParamsPtr>");
        perfetto::WriteIntoTracedValueWithFallback(
            dict.AddItem("is_in_same_virtual_coop_related_group"), in_is_in_same_virtual_coop_related_group, "<value of type bool>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalMainFrame::kInstallCoopAccessMonitor), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalMainFrame_InstallCoopAccessMonitor_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<decltype(params->accessed_window)> accessed_window_fragment(params.message());
    accessed_window_fragment.Claim(&params->accessed_window);
    mojo::internal::Serialize<::blink::mojom::FrameTokenDataView>(in_accessed_window, accessed_window_fragment, true);
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->accessed_window.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null accessed_window in LocalMainFrame.InstallCoopAccessMonitor request");
    mojo::internal::MessageFragment<typename decltype(params->coop_reporter_info)::BaseType> coop_reporter_info_fragment(params.message());
    mojo::internal::Serialize<::network::mojom::CrossOriginOpenerPolicyReporterParamsDataView>(in_coop_reporter_info, coop_reporter_info_fragment);
    params->coop_reporter_info.Set(coop_reporter_info_fragment.is_null() ? nullptr : coop_reporter_info_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->coop_reporter_info.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null coop_reporter_info in LocalMainFrame.InstallCoopAccessMonitor request");
    params->is_in_same_virtual_coop_related_group = in_is_in_same_virtual_coop_related_group;

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalMainFrame::Name_);
    message.set_method_name("InstallCoopAccessMonitor");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalMainFrameProxy::UpdateBrowserControlsState(::cc::BrowserControlsState in_constraints, ::cc::BrowserControlsState in_current, bool in_animate,
    const std::optional<::cc::BrowserControlsOffsetTagsInfo>& in_offset_tags_info)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalMainFrame::UpdateBrowserControlsState", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("constraints"), in_constraints, "<value of type ::cc::BrowserControlsState>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("current"), in_current, "<value of type ::cc::BrowserControlsState>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("animate"), in_animate, "<value of type bool>");
        perfetto::WriteIntoTracedValueWithFallback(
            dict.AddItem("offset_tags_info"), in_offset_tags_info, "<value of type const std::optional<::cc::BrowserControlsOffsetTagsInfo>&>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalMainFrame::kUpdateBrowserControlsState), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalMainFrame_UpdateBrowserControlsState_Params_Data> params(message);
    params.Allocate();
    mojo::internal::Serialize<::cc::mojom::BrowserControlsState>(in_constraints, &params->constraints);
    mojo::internal::Serialize<::cc::mojom::BrowserControlsState>(in_current, &params->current);
    params->animate = in_animate;
    mojo::internal::MessageFragment<typename decltype(params->offset_tags_info)::BaseType> offset_tags_info_fragment(params.message());
    mojo::internal::Serialize<::cc::mojom::BrowserControlsOffsetTagsInfoDataView>(in_offset_tags_info, offset_tags_info_fragment);
    params->offset_tags_info.Set(offset_tags_info_fragment.is_null() ? nullptr : offset_tags_info_fragment.data());

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalMainFrame::Name_);
    message.set_method_name("UpdateBrowserControlsState");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalMainFrameProxy::SetV8CompileHints(::base::ReadOnlySharedMemoryRegion in_data)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalMainFrame::SetV8CompileHints", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("data"), in_data, "<value of type ::base::ReadOnlySharedMemoryRegion>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalMainFrame::kSetV8CompileHints), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalMainFrame_SetV8CompileHints_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->data)::BaseType> data_fragment(params.message());
    mojo::internal::Serialize<::mojo_base::mojom::ReadOnlySharedMemoryRegionDataView>(in_data, data_fragment);
    params->data.Set(data_fragment.is_null() ? nullptr : data_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->data.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null data in LocalMainFrame.SetV8CompileHints request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalMainFrame::Name_);
    message.set_method_name("SetV8CompileHints");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalMainFrameProxy::Discard()
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT0("mojom", "Send blink::mojom::LocalMainFrame::Discard");
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalMainFrame::kDiscard), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalMainFrame_Discard_Params_Data> params(message);
    params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalMainFrame::Name_);
    message.set_method_name("Discard");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalMainFrameProxy::FinalizeNavigationConfidence(double in_randomized_trigger_rate, ::blink::mojom::blink::ConfidenceLevel in_confidence)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalMainFrame::FinalizeNavigationConfidence", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("randomized_trigger_rate"), in_randomized_trigger_rate, "<value of type double>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("confidence"), in_confidence, "<value of type ::blink::mojom::blink::ConfidenceLevel>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalMainFrame::kFinalizeNavigationConfidence), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalMainFrame_FinalizeNavigationConfidence_Params_Data> params(message);
    params.Allocate();
    params->randomized_trigger_rate = in_randomized_trigger_rate;
    mojo::internal::Serialize<::blink::mojom::ConfidenceLevel>(in_confidence, &params->confidence);

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalMainFrame::Name_);
    message.set_method_name("FinalizeNavigationConfidence");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}
class LocalMainFrame_ClosePage_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
public:
    static LocalMainFrame::ClosePageCallback CreateCallback(::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
    {
        std::unique_ptr<LocalMainFrame_ClosePage_ProxyToResponder> proxy(new LocalMainFrame_ClosePage_ProxyToResponder(message, std::move(responder)));
        return base::BindOnce(&LocalMainFrame_ClosePage_ProxyToResponder::Run, std::move(proxy));
    }

    ~LocalMainFrame_ClosePage_ProxyToResponder()
    {
#if DCHECK_IS_ON()
        if (responder_) {
            // If we're being destroyed without being run, we want to ensure the
            // binding endpoint has been closed. This checks for that asynchronously.
            // We pass a bound generated callback to handle the response so that any
            // resulting DCHECK stack will have useful interface type information.
            // Instantiate a ScopedFizzleBlockShutdownTasks to allow this request to
            // fizzle if this happens after shutdown and the endpoint is bound to a
            // BLOCK_SHUTDOWN sequence.
            base::ThreadPoolInstance::ScopedFizzleBlockShutdownTasks fizzler;
            responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
        }
#endif
    }

private:
    LocalMainFrame_ClosePage_ProxyToResponder(::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
        : ::mojo::internal::ProxyToResponder(message, std::move(responder))
    {
    }

#if DCHECK_IS_ON()
    static void OnIsConnectedComplete(bool connected)
    {
        DCHECK(!connected) << "LocalMainFrame::ClosePageCallback was destroyed without "
                           << "first either being run or its corresponding binding being closed. "
                           << "It is an error to drop response callbacks which still correspond "
                           << "to an open interface pipe.";
    }
#endif

    void Run();
};

bool LocalMainFrame_ClosePage_ForwardToCallback::Accept(mojo::Message* message)
{
    DCHECK(message->is_serialized());
    internal::LocalMainFrame_ClosePage_ResponseParams_Data* params
        = reinterpret_cast<internal::LocalMainFrame_ClosePage_ResponseParams_Data*>(message->mutable_payload());

    // Validation for LocalMainFrame.2
    bool success = true;
    LocalMainFrame_ClosePage_ResponseParamsDataView input_data_view(params, message);

    if (!success) {
        ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalMainFrame::Name_, 2, true);
        return false;
    }
    if (!callback_.is_null())
        std::move(callback_).Run();
    return true;
}

void LocalMainFrame_ClosePage_ProxyToResponder::Run()
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT0("mojom", "Send reply blink::mojom::LocalMainFrame::ClosePage");
#endif

    const uint32_t kFlags = mojo::Message::kFlagIsResponse | ((is_sync_) ? mojo::Message::kFlagIsSync : 0) | ((true) ? 0 : mojo::Message::kFlagNoInterrupt)
        | ((false) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalMainFrame::kClosePage), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalMainFrame_ClosePage_ResponseParams_Data> params(message);
    params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalMainFrame::Name_);
    message.set_method_name("ClosePage");
#endif

    message.set_request_id(request_id_);
    message.set_trace_nonce(trace_nonce_);
    ::mojo::internal::SendMojoMessage(*responder_, message);
    // SendMojoMessage() fails silently if the responder connection is closed,
    // or if the message is malformed.
    //
    // TODO(darin): If Accept() returns false due to a malformed message, that
    // may be good reason to close the connection. However, we don't have a
    // way to do that from here. We should add a way.
    responder_ = nullptr;
}
class LocalMainFrame_GetFullPageSize_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
public:
    static LocalMainFrame::GetFullPageSizeCallback CreateCallback(::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
    {
        std::unique_ptr<LocalMainFrame_GetFullPageSize_ProxyToResponder> proxy(
            new LocalMainFrame_GetFullPageSize_ProxyToResponder(message, std::move(responder)));
        return base::BindOnce(&LocalMainFrame_GetFullPageSize_ProxyToResponder::Run, std::move(proxy));
    }

    ~LocalMainFrame_GetFullPageSize_ProxyToResponder()
    {
#if DCHECK_IS_ON()
        if (responder_) {
            // If we're being destroyed without being run, we want to ensure the
            // binding endpoint has been closed. This checks for that asynchronously.
            // We pass a bound generated callback to handle the response so that any
            // resulting DCHECK stack will have useful interface type information.
            // Instantiate a ScopedFizzleBlockShutdownTasks to allow this request to
            // fizzle if this happens after shutdown and the endpoint is bound to a
            // BLOCK_SHUTDOWN sequence.
            base::ThreadPoolInstance::ScopedFizzleBlockShutdownTasks fizzler;
            responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
        }
#endif
    }

private:
    LocalMainFrame_GetFullPageSize_ProxyToResponder(::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
        : ::mojo::internal::ProxyToResponder(message, std::move(responder))
    {
    }

#if DCHECK_IS_ON()
    static void OnIsConnectedComplete(bool connected)
    {
        DCHECK(!connected) << "LocalMainFrame::GetFullPageSizeCallback was destroyed without "
                           << "first either being run or its corresponding binding being closed. "
                           << "It is an error to drop response callbacks which still correspond "
                           << "to an open interface pipe.";
    }
#endif

    void Run(const ::gfx::Size& in_full_page_size);
};

bool LocalMainFrame_GetFullPageSize_ForwardToCallback::Accept(mojo::Message* message)
{
    DCHECK(message->is_serialized());
    internal::LocalMainFrame_GetFullPageSize_ResponseParams_Data* params
        = reinterpret_cast<internal::LocalMainFrame_GetFullPageSize_ResponseParams_Data*>(message->mutable_payload());

    // Validation for LocalMainFrame.3
    bool success = true;
    ::gfx::Size p_full_page_size {};
    LocalMainFrame_GetFullPageSize_ResponseParamsDataView input_data_view(params, message);

    if (success && !input_data_view.ReadFullPageSize(&p_full_page_size))
        success = false;
    if (!success) {
        ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalMainFrame::Name_, 3, true);
        return false;
    }
    if (!callback_.is_null())
        std::move(callback_).Run(std::move(p_full_page_size));
    return true;
}

void LocalMainFrame_GetFullPageSize_ProxyToResponder::Run(const ::gfx::Size& in_full_page_size)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send reply blink::mojom::LocalMainFrame::GetFullPageSize", "async_response_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("full_page_size"), in_full_page_size, "<value of type const ::gfx::Size&>");
    });
#endif

    const uint32_t kFlags = mojo::Message::kFlagIsResponse | ((is_sync_) ? mojo::Message::kFlagIsSync : 0) | ((true) ? 0 : mojo::Message::kFlagNoInterrupt)
        | ((false) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalMainFrame::kGetFullPageSize), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalMainFrame_GetFullPageSize_ResponseParams_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->full_page_size)::BaseType> full_page_size_fragment(params.message());
    mojo::internal::Serialize<::gfx::mojom::SizeDataView>(in_full_page_size, full_page_size_fragment);
    params->full_page_size.Set(full_page_size_fragment.is_null() ? nullptr : full_page_size_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->full_page_size.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null full_page_size in ");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalMainFrame::Name_);
    message.set_method_name("GetFullPageSize");
#endif

    message.set_request_id(request_id_);
    message.set_trace_nonce(trace_nonce_);
    ::mojo::internal::SendMojoMessage(*responder_, message);
    // SendMojoMessage() fails silently if the responder connection is closed,
    // or if the message is malformed.
    //
    // TODO(darin): If Accept() returns false due to a malformed message, that
    // may be good reason to close the connection. However, we don't have a
    // way to do that from here. We should add a way.
    responder_ = nullptr;
}

// static
bool LocalMainFrameStubDispatch::Accept(LocalMainFrame* impl, mojo::Message* message)
{
    switch (static_cast<messages::LocalMainFrame>(message->header()->name)) {
    case messages::LocalMainFrame::kAnimateDoubleTapZoom: {
        DCHECK(message->is_serialized());
        internal::LocalMainFrame_AnimateDoubleTapZoom_Params_Data* params
            = reinterpret_cast<internal::LocalMainFrame_AnimateDoubleTapZoom_Params_Data*>(message->mutable_payload());

        // Validation for LocalMainFrame.0
        bool success = true;
        ::gfx::Point p_point {};
        ::gfx::Rect p_rect {};
        LocalMainFrame_AnimateDoubleTapZoom_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadPoint(&p_point))
            success = false;
        if (success && !input_data_view.ReadRect(&p_rect))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalMainFrame::Name_, 0, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->AnimateDoubleTapZoom(std::move(p_point), std::move(p_rect));
        return true;
    }
    case messages::LocalMainFrame::kSetScaleFactor: {
        DCHECK(message->is_serialized());
        internal::LocalMainFrame_SetScaleFactor_Params_Data* params
            = reinterpret_cast<internal::LocalMainFrame_SetScaleFactor_Params_Data*>(message->mutable_payload());

        // Validation for LocalMainFrame.1
        bool success = true;
        float p_scale {};
        LocalMainFrame_SetScaleFactor_ParamsDataView input_data_view(params, message);

        if (success)
            p_scale = input_data_view.scale();
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalMainFrame::Name_, 1, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->SetScaleFactor(std::move(p_scale));
        return true;
    }
    case messages::LocalMainFrame::kClosePage: {
        break;
    }
    case messages::LocalMainFrame::kGetFullPageSize: {
        break;
    }
    case messages::LocalMainFrame::kSetInitialFocus: {
        DCHECK(message->is_serialized());
        internal::LocalMainFrame_SetInitialFocus_Params_Data* params
            = reinterpret_cast<internal::LocalMainFrame_SetInitialFocus_Params_Data*>(message->mutable_payload());

        // Validation for LocalMainFrame.4
        bool success = true;
        bool p_reverse {};
        LocalMainFrame_SetInitialFocus_ParamsDataView input_data_view(params, message);

        if (success)
            p_reverse = input_data_view.reverse();
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalMainFrame::Name_, 4, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->SetInitialFocus(std::move(p_reverse));
        return true;
    }
    case messages::LocalMainFrame::kEnablePreferredSizeChangedMode: {
        DCHECK(message->is_serialized());
        internal::LocalMainFrame_EnablePreferredSizeChangedMode_Params_Data* params
            = reinterpret_cast<internal::LocalMainFrame_EnablePreferredSizeChangedMode_Params_Data*>(message->mutable_payload());

        // Validation for LocalMainFrame.5
        bool success = true;
        LocalMainFrame_EnablePreferredSizeChangedMode_ParamsDataView input_data_view(params, message);

        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalMainFrame::Name_, 5, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->EnablePreferredSizeChangedMode();
        return true;
    }
    case messages::LocalMainFrame::kZoomToFindInPageRect: {
        DCHECK(message->is_serialized());
        internal::LocalMainFrame_ZoomToFindInPageRect_Params_Data* params
            = reinterpret_cast<internal::LocalMainFrame_ZoomToFindInPageRect_Params_Data*>(message->mutable_payload());

        // Validation for LocalMainFrame.6
        bool success = true;
        ::gfx::Rect p_rect_in_root_frame {};
        LocalMainFrame_ZoomToFindInPageRect_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadRectInRootFrame(&p_rect_in_root_frame))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalMainFrame::Name_, 6, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->ZoomToFindInPageRect(std::move(p_rect_in_root_frame));
        return true;
    }
    case messages::LocalMainFrame::kInstallCoopAccessMonitor: {
        DCHECK(message->is_serialized());
        internal::LocalMainFrame_InstallCoopAccessMonitor_Params_Data* params
            = reinterpret_cast<internal::LocalMainFrame_InstallCoopAccessMonitor_Params_Data*>(message->mutable_payload());

        // Validation for LocalMainFrame.7
        bool success = true;
        ::blink::FrameToken p_accessed_window {};
        ::network::mojom::blink::CrossOriginOpenerPolicyReporterParamsPtr p_coop_reporter_info {};
        bool p_is_in_same_virtual_coop_related_group {};
        LocalMainFrame_InstallCoopAccessMonitor_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadAccessedWindow(&p_accessed_window))
            success = false;
        if (success && !input_data_view.ReadCoopReporterInfo(&p_coop_reporter_info))
            success = false;
        if (success)
            p_is_in_same_virtual_coop_related_group = input_data_view.is_in_same_virtual_coop_related_group();
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalMainFrame::Name_, 7, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->InstallCoopAccessMonitor(std::move(p_accessed_window), std::move(p_coop_reporter_info), std::move(p_is_in_same_virtual_coop_related_group));
        return true;
    }
    case messages::LocalMainFrame::kUpdateBrowserControlsState: {
        DCHECK(message->is_serialized());
        internal::LocalMainFrame_UpdateBrowserControlsState_Params_Data* params
            = reinterpret_cast<internal::LocalMainFrame_UpdateBrowserControlsState_Params_Data*>(message->mutable_payload());

        // Validation for LocalMainFrame.8
        bool success = true;
        ::cc::BrowserControlsState p_constraints {};
        ::cc::BrowserControlsState p_current {};
        bool p_animate {};
        std::optional<::cc::BrowserControlsOffsetTagsInfo> p_offset_tags_info {};
        LocalMainFrame_UpdateBrowserControlsState_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadConstraints(&p_constraints))
            success = false;
        if (success && !input_data_view.ReadCurrent(&p_current))
            success = false;
        if (success)
            p_animate = input_data_view.animate();
        if (success && !input_data_view.ReadOffsetTagsInfo(&p_offset_tags_info))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalMainFrame::Name_, 8, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->UpdateBrowserControlsState(std::move(p_constraints), std::move(p_current), std::move(p_animate), std::move(p_offset_tags_info));
        return true;
    }
    case messages::LocalMainFrame::kSetV8CompileHints: {
        DCHECK(message->is_serialized());
        internal::LocalMainFrame_SetV8CompileHints_Params_Data* params
            = reinterpret_cast<internal::LocalMainFrame_SetV8CompileHints_Params_Data*>(message->mutable_payload());

        // Validation for LocalMainFrame.9
        bool success = true;
        ::base::ReadOnlySharedMemoryRegion p_data {};
        LocalMainFrame_SetV8CompileHints_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadData(&p_data))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalMainFrame::Name_, 9, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->SetV8CompileHints(std::move(p_data));
        return true;
    }
    case messages::LocalMainFrame::kDiscard: {
        DCHECK(message->is_serialized());
        internal::LocalMainFrame_Discard_Params_Data* params = reinterpret_cast<internal::LocalMainFrame_Discard_Params_Data*>(message->mutable_payload());

        // Validation for LocalMainFrame.10
        bool success = true;
        LocalMainFrame_Discard_ParamsDataView input_data_view(params, message);

        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalMainFrame::Name_, 10, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->Discard();
        return true;
    }
    case messages::LocalMainFrame::kFinalizeNavigationConfidence: {
        DCHECK(message->is_serialized());
        internal::LocalMainFrame_FinalizeNavigationConfidence_Params_Data* params
            = reinterpret_cast<internal::LocalMainFrame_FinalizeNavigationConfidence_Params_Data*>(message->mutable_payload());

        // Validation for LocalMainFrame.11
        bool success = true;
        double p_randomized_trigger_rate {};
        ::blink::mojom::blink::ConfidenceLevel p_confidence {};
        LocalMainFrame_FinalizeNavigationConfidence_ParamsDataView input_data_view(params, message);

        if (success)
            p_randomized_trigger_rate = input_data_view.randomized_trigger_rate();
        if (success && !input_data_view.ReadConfidence(&p_confidence))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalMainFrame::Name_, 11, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->FinalizeNavigationConfidence(std::move(p_randomized_trigger_rate), std::move(p_confidence));
        return true;
    }
    }
    return false;
}

// static
bool LocalMainFrameStubDispatch::AcceptWithResponder(LocalMainFrame* impl, mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
{
    [[maybe_unused]] const bool message_is_sync = message->has_flag(mojo::Message::kFlagIsSync);
    [[maybe_unused]] const uint64_t request_id = message->request_id();
    switch (static_cast<messages::LocalMainFrame>(message->header()->name)) {
    case messages::LocalMainFrame::kAnimateDoubleTapZoom: {
        break;
    }
    case messages::LocalMainFrame::kSetScaleFactor: {
        break;
    }
    case messages::LocalMainFrame::kClosePage: {
        internal::LocalMainFrame_ClosePage_Params_Data* params = reinterpret_cast<internal::LocalMainFrame_ClosePage_Params_Data*>(message->mutable_payload());

        // Validation for LocalMainFrame.2
        bool success = true;
        LocalMainFrame_ClosePage_ParamsDataView input_data_view(params, message);

        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalMainFrame::Name_, 2, false);
            return false;
        }
        LocalMainFrame::ClosePageCallback callback = LocalMainFrame_ClosePage_ProxyToResponder::CreateCallback(*message, std::move(responder));
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->ClosePage(std::move(callback));
        return true;
    }
    case messages::LocalMainFrame::kGetFullPageSize: {
        internal::LocalMainFrame_GetFullPageSize_Params_Data* params
            = reinterpret_cast<internal::LocalMainFrame_GetFullPageSize_Params_Data*>(message->mutable_payload());

        // Validation for LocalMainFrame.3
        bool success = true;
        LocalMainFrame_GetFullPageSize_ParamsDataView input_data_view(params, message);

        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalMainFrame::Name_, 3, false);
            return false;
        }
        LocalMainFrame::GetFullPageSizeCallback callback = LocalMainFrame_GetFullPageSize_ProxyToResponder::CreateCallback(*message, std::move(responder));
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->GetFullPageSize(std::move(callback));
        return true;
    }
    case messages::LocalMainFrame::kSetInitialFocus: {
        break;
    }
    case messages::LocalMainFrame::kEnablePreferredSizeChangedMode: {
        break;
    }
    case messages::LocalMainFrame::kZoomToFindInPageRect: {
        break;
    }
    case messages::LocalMainFrame::kInstallCoopAccessMonitor: {
        break;
    }
    case messages::LocalMainFrame::kUpdateBrowserControlsState: {
        break;
    }
    case messages::LocalMainFrame::kSetV8CompileHints: {
        break;
    }
    case messages::LocalMainFrame::kDiscard: {
        break;
    }
    case messages::LocalMainFrame::kFinalizeNavigationConfidence: {
        break;
    }
    }
    return false;
}
namespace {
} // namespace
static const mojo::internal::GenericValidationInfo kLocalMainFrameValidationInfo[] = {
    { &internal::LocalMainFrame_AnimateDoubleTapZoom_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalMainFrame_SetScaleFactor_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalMainFrame_ClosePage_Params_Data::Validate, &internal::LocalMainFrame_ClosePage_ResponseParams_Data::Validate },
    { &internal::LocalMainFrame_GetFullPageSize_Params_Data::Validate, &internal::LocalMainFrame_GetFullPageSize_ResponseParams_Data::Validate },
    { &internal::LocalMainFrame_SetInitialFocus_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalMainFrame_EnablePreferredSizeChangedMode_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalMainFrame_ZoomToFindInPageRect_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalMainFrame_InstallCoopAccessMonitor_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalMainFrame_UpdateBrowserControlsState_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalMainFrame_SetV8CompileHints_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalMainFrame_Discard_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalMainFrame_FinalizeNavigationConfidence_Params_Data::Validate, nullptr /* no response */ },
};

bool LocalMainFrameRequestValidator::Accept(mojo::Message* message)
{
    const char* name = ::blink::mojom::blink::LocalMainFrame::Name_;
    return mojo::internal::ValidateRequestGenericPacked(message, name, kLocalMainFrameValidationInfo);
}

bool LocalMainFrameResponseValidator::Accept(mojo::Message* message)
{
    const char* name = ::blink::mojom::blink::LocalMainFrame::Name_;
    return mojo::internal::ValidateResponseGenericPacked(message, name, kLocalMainFrameValidationInfo);
}
const char LocalMainFrameHost::Name_[] = "blink.mojom.LocalMainFrameHost";

LocalMainFrameHost::IPCStableHashFunction LocalMainFrameHost::MessageToMethodInfo_(mojo::Message& message)
{
#if !BUILDFLAG(IS_FUCHSIA)
    switch (static_cast<messages::LocalMainFrameHost>(message.name())) {
    case messages::LocalMainFrameHost::kScaleFactorChanged: {
        return &LocalMainFrameHost::ScaleFactorChanged_Sym::IPCStableHash;
    }
    case messages::LocalMainFrameHost::kContentsPreferredSizeChanged: {
        return &LocalMainFrameHost::ContentsPreferredSizeChanged_Sym::IPCStableHash;
    }
    case messages::LocalMainFrameHost::kTextAutosizerPageInfoChanged: {
        return &LocalMainFrameHost::TextAutosizerPageInfoChanged_Sym::IPCStableHash;
    }
    case messages::LocalMainFrameHost::kFocusPage: {
        return &LocalMainFrameHost::FocusPage_Sym::IPCStableHash;
    }
    case messages::LocalMainFrameHost::kTakeFocus: {
        return &LocalMainFrameHost::TakeFocus_Sym::IPCStableHash;
    }
    case messages::LocalMainFrameHost::kUpdateTargetURL: {
        return &LocalMainFrameHost::UpdateTargetURL_Sym::IPCStableHash;
    }
    case messages::LocalMainFrameHost::kRequestClose: {
        return &LocalMainFrameHost::RequestClose_Sym::IPCStableHash;
    }
    case messages::LocalMainFrameHost::kShowCreatedWindow: {
        return &LocalMainFrameHost::ShowCreatedWindow_Sym::IPCStableHash;
    }
    case messages::LocalMainFrameHost::kSetWindowRect: {
        return &LocalMainFrameHost::SetWindowRect_Sym::IPCStableHash;
    }
    case messages::LocalMainFrameHost::kDidFirstVisuallyNonEmptyPaint: {
        return &LocalMainFrameHost::DidFirstVisuallyNonEmptyPaint_Sym::IPCStableHash;
    }
    case messages::LocalMainFrameHost::kDidAccessInitialMainDocument: {
        return &LocalMainFrameHost::DidAccessInitialMainDocument_Sym::IPCStableHash;
    }
    case messages::LocalMainFrameHost::kMaximize: {
        return &LocalMainFrameHost::Maximize_Sym::IPCStableHash;
    }
    case messages::LocalMainFrameHost::kMinimize: {
        return &LocalMainFrameHost::Minimize_Sym::IPCStableHash;
    }
    case messages::LocalMainFrameHost::kRestore: {
        return &LocalMainFrameHost::Restore_Sym::IPCStableHash;
    }
    case messages::LocalMainFrameHost::kSetResizable: {
        return &LocalMainFrameHost::SetResizable_Sym::IPCStableHash;
    }
    case messages::LocalMainFrameHost::kDraggableRegionsChanged: {
        return &LocalMainFrameHost::DraggableRegionsChanged_Sym::IPCStableHash;
    }
    case messages::LocalMainFrameHost::kOnFirstContentfulPaint: {
        return &LocalMainFrameHost::OnFirstContentfulPaint_Sym::IPCStableHash;
    }
    }
#endif // !BUILDFLAG(IS_FUCHSIA)
    return nullptr;
}

const char* LocalMainFrameHost::MessageToMethodName_(mojo::Message& message)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
    if (!is_response) {
        switch (static_cast<messages::LocalMainFrameHost>(message.name())) {
        case messages::LocalMainFrameHost::kScaleFactorChanged:
            return "Receive blink::mojom::LocalMainFrameHost::ScaleFactorChanged";
        case messages::LocalMainFrameHost::kContentsPreferredSizeChanged:
            return "Receive blink::mojom::LocalMainFrameHost::ContentsPreferredSizeChanged";
        case messages::LocalMainFrameHost::kTextAutosizerPageInfoChanged:
            return "Receive blink::mojom::LocalMainFrameHost::TextAutosizerPageInfoChanged";
        case messages::LocalMainFrameHost::kFocusPage:
            return "Receive blink::mojom::LocalMainFrameHost::FocusPage";
        case messages::LocalMainFrameHost::kTakeFocus:
            return "Receive blink::mojom::LocalMainFrameHost::TakeFocus";
        case messages::LocalMainFrameHost::kUpdateTargetURL:
            return "Receive blink::mojom::LocalMainFrameHost::UpdateTargetURL";
        case messages::LocalMainFrameHost::kRequestClose:
            return "Receive blink::mojom::LocalMainFrameHost::RequestClose";
        case messages::LocalMainFrameHost::kShowCreatedWindow:
            return "Receive blink::mojom::LocalMainFrameHost::ShowCreatedWindow";
        case messages::LocalMainFrameHost::kSetWindowRect:
            return "Receive blink::mojom::LocalMainFrameHost::SetWindowRect";
        case messages::LocalMainFrameHost::kDidFirstVisuallyNonEmptyPaint:
            return "Receive blink::mojom::LocalMainFrameHost::DidFirstVisuallyNonEmptyPaint";
        case messages::LocalMainFrameHost::kDidAccessInitialMainDocument:
            return "Receive blink::mojom::LocalMainFrameHost::DidAccessInitialMainDocument";
        case messages::LocalMainFrameHost::kMaximize:
            return "Receive blink::mojom::LocalMainFrameHost::Maximize";
        case messages::LocalMainFrameHost::kMinimize:
            return "Receive blink::mojom::LocalMainFrameHost::Minimize";
        case messages::LocalMainFrameHost::kRestore:
            return "Receive blink::mojom::LocalMainFrameHost::Restore";
        case messages::LocalMainFrameHost::kSetResizable:
            return "Receive blink::mojom::LocalMainFrameHost::SetResizable";
        case messages::LocalMainFrameHost::kDraggableRegionsChanged:
            return "Receive blink::mojom::LocalMainFrameHost::DraggableRegionsChanged";
        case messages::LocalMainFrameHost::kOnFirstContentfulPaint:
            return "Receive blink::mojom::LocalMainFrameHost::OnFirstContentfulPaint";
        }
    } else {
        switch (static_cast<messages::LocalMainFrameHost>(message.name())) {
        case messages::LocalMainFrameHost::kScaleFactorChanged:
            return "Receive reply blink::mojom::LocalMainFrameHost::ScaleFactorChanged";
        case messages::LocalMainFrameHost::kContentsPreferredSizeChanged:
            return "Receive reply blink::mojom::LocalMainFrameHost::ContentsPreferredSizeChanged";
        case messages::LocalMainFrameHost::kTextAutosizerPageInfoChanged:
            return "Receive reply blink::mojom::LocalMainFrameHost::TextAutosizerPageInfoChanged";
        case messages::LocalMainFrameHost::kFocusPage:
            return "Receive reply blink::mojom::LocalMainFrameHost::FocusPage";
        case messages::LocalMainFrameHost::kTakeFocus:
            return "Receive reply blink::mojom::LocalMainFrameHost::TakeFocus";
        case messages::LocalMainFrameHost::kUpdateTargetURL:
            return "Receive reply blink::mojom::LocalMainFrameHost::UpdateTargetURL";
        case messages::LocalMainFrameHost::kRequestClose:
            return "Receive reply blink::mojom::LocalMainFrameHost::RequestClose";
        case messages::LocalMainFrameHost::kShowCreatedWindow:
            return "Receive reply blink::mojom::LocalMainFrameHost::ShowCreatedWindow";
        case messages::LocalMainFrameHost::kSetWindowRect:
            return "Receive reply blink::mojom::LocalMainFrameHost::SetWindowRect";
        case messages::LocalMainFrameHost::kDidFirstVisuallyNonEmptyPaint:
            return "Receive reply blink::mojom::LocalMainFrameHost::DidFirstVisuallyNonEmptyPaint";
        case messages::LocalMainFrameHost::kDidAccessInitialMainDocument:
            return "Receive reply blink::mojom::LocalMainFrameHost::DidAccessInitialMainDocument";
        case messages::LocalMainFrameHost::kMaximize:
            return "Receive reply blink::mojom::LocalMainFrameHost::Maximize";
        case messages::LocalMainFrameHost::kMinimize:
            return "Receive reply blink::mojom::LocalMainFrameHost::Minimize";
        case messages::LocalMainFrameHost::kRestore:
            return "Receive reply blink::mojom::LocalMainFrameHost::Restore";
        case messages::LocalMainFrameHost::kSetResizable:
            return "Receive reply blink::mojom::LocalMainFrameHost::SetResizable";
        case messages::LocalMainFrameHost::kDraggableRegionsChanged:
            return "Receive reply blink::mojom::LocalMainFrameHost::DraggableRegionsChanged";
        case messages::LocalMainFrameHost::kOnFirstContentfulPaint:
            return "Receive reply blink::mojom::LocalMainFrameHost::OnFirstContentfulPaint";
        }
    }
    return "Receive unknown mojo message";
#else
    bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
    if (is_response) {
        return "Receive mojo reply";
    } else {
        return "Receive mojo message";
    }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t LocalMainFrameHost::ScaleFactorChanged_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalMainFrameHost::ScaleFactorChanged");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalMainFrameHost::ContentsPreferredSizeChanged_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalMainFrameHost::ContentsPreferredSizeChanged");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalMainFrameHost::TextAutosizerPageInfoChanged_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalMainFrameHost::TextAutosizerPageInfoChanged");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalMainFrameHost::FocusPage_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalMainFrameHost::FocusPage");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalMainFrameHost::TakeFocus_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalMainFrameHost::TakeFocus");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalMainFrameHost::UpdateTargetURL_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalMainFrameHost::UpdateTargetURL");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalMainFrameHost::RequestClose_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalMainFrameHost::RequestClose");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalMainFrameHost::ShowCreatedWindow_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalMainFrameHost::ShowCreatedWindow");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalMainFrameHost::SetWindowRect_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalMainFrameHost::SetWindowRect");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalMainFrameHost::DidFirstVisuallyNonEmptyPaint_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalMainFrameHost::DidFirstVisuallyNonEmptyPaint");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalMainFrameHost::DidAccessInitialMainDocument_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalMainFrameHost::DidAccessInitialMainDocument");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalMainFrameHost::Maximize_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalMainFrameHost::Maximize");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalMainFrameHost::Minimize_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalMainFrameHost::Minimize");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalMainFrameHost::Restore_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalMainFrameHost::Restore");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalMainFrameHost::SetResizable_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalMainFrameHost::SetResizable");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalMainFrameHost::DraggableRegionsChanged_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalMainFrameHost::DraggableRegionsChanged");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t LocalMainFrameHost::OnFirstContentfulPaint_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::LocalMainFrameHost::OnFirstContentfulPaint");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
#endif // !BUILDFLAG(IS_FUCHSIA)

class LocalMainFrameHost_UpdateTargetURL_ForwardToCallback : public mojo::MessageReceiver {
public:
    LocalMainFrameHost_UpdateTargetURL_ForwardToCallback(LocalMainFrameHost::UpdateTargetURLCallback callback)
        : callback_(std::move(callback))
    {
    }

    LocalMainFrameHost_UpdateTargetURL_ForwardToCallback(const LocalMainFrameHost_UpdateTargetURL_ForwardToCallback&) = delete;
    LocalMainFrameHost_UpdateTargetURL_ForwardToCallback& operator=(const LocalMainFrameHost_UpdateTargetURL_ForwardToCallback&) = delete;

    bool Accept(mojo::Message* message) override;

private:
    LocalMainFrameHost::UpdateTargetURLCallback callback_;
};

class LocalMainFrameHost_ShowCreatedWindow_ForwardToCallback : public mojo::MessageReceiver {
public:
    LocalMainFrameHost_ShowCreatedWindow_ForwardToCallback(LocalMainFrameHost::ShowCreatedWindowCallback callback)
        : callback_(std::move(callback))
    {
    }

    LocalMainFrameHost_ShowCreatedWindow_ForwardToCallback(const LocalMainFrameHost_ShowCreatedWindow_ForwardToCallback&) = delete;
    LocalMainFrameHost_ShowCreatedWindow_ForwardToCallback& operator=(const LocalMainFrameHost_ShowCreatedWindow_ForwardToCallback&) = delete;

    bool Accept(mojo::Message* message) override;

private:
    LocalMainFrameHost::ShowCreatedWindowCallback callback_;
};

class LocalMainFrameHost_SetWindowRect_ForwardToCallback : public mojo::MessageReceiver {
public:
    LocalMainFrameHost_SetWindowRect_ForwardToCallback(LocalMainFrameHost::SetWindowRectCallback callback)
        : callback_(std::move(callback))
    {
    }

    LocalMainFrameHost_SetWindowRect_ForwardToCallback(const LocalMainFrameHost_SetWindowRect_ForwardToCallback&) = delete;
    LocalMainFrameHost_SetWindowRect_ForwardToCallback& operator=(const LocalMainFrameHost_SetWindowRect_ForwardToCallback&) = delete;

    bool Accept(mojo::Message* message) override;

private:
    LocalMainFrameHost::SetWindowRectCallback callback_;
};

LocalMainFrameHostProxy::LocalMainFrameHostProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver)
{
}

void LocalMainFrameHostProxy::ScaleFactorChanged(float in_scale)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalMainFrameHost::ScaleFactorChanged", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("scale"), in_scale, "<value of type float>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalMainFrameHost::kScaleFactorChanged), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalMainFrameHost_ScaleFactorChanged_Params_Data> params(message);
    params.Allocate();
    params->scale = in_scale;

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalMainFrameHost::Name_);
    message.set_method_name("ScaleFactorChanged");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalMainFrameHostProxy::ContentsPreferredSizeChanged(const ::gfx::Size& in_pref_size)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalMainFrameHost::ContentsPreferredSizeChanged", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("pref_size"), in_pref_size, "<value of type const ::gfx::Size&>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalMainFrameHost::kContentsPreferredSizeChanged), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalMainFrameHost_ContentsPreferredSizeChanged_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->pref_size)::BaseType> pref_size_fragment(params.message());
    mojo::internal::Serialize<::gfx::mojom::SizeDataView>(in_pref_size, pref_size_fragment);
    params->pref_size.Set(pref_size_fragment.is_null() ? nullptr : pref_size_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->pref_size.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null pref_size in LocalMainFrameHost.ContentsPreferredSizeChanged request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalMainFrameHost::Name_);
    message.set_method_name("ContentsPreferredSizeChanged");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalMainFrameHostProxy::TextAutosizerPageInfoChanged(::blink::mojom::blink::TextAutosizerPageInfoPtr in_page_info)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalMainFrameHost::TextAutosizerPageInfoChanged", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("page_info"), in_page_info, "<value of type ::blink::mojom::blink::TextAutosizerPageInfoPtr>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalMainFrameHost::kTextAutosizerPageInfoChanged), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalMainFrameHost_TextAutosizerPageInfoChanged_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->page_info)::BaseType> page_info_fragment(params.message());
    mojo::internal::Serialize<::blink::mojom::TextAutosizerPageInfoDataView>(in_page_info, page_info_fragment);
    params->page_info.Set(page_info_fragment.is_null() ? nullptr : page_info_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->page_info.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null page_info in LocalMainFrameHost.TextAutosizerPageInfoChanged request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalMainFrameHost::Name_);
    message.set_method_name("TextAutosizerPageInfoChanged");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalMainFrameHostProxy::FocusPage()
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT0("mojom", "Send blink::mojom::LocalMainFrameHost::FocusPage");
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalMainFrameHost::kFocusPage), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalMainFrameHost_FocusPage_Params_Data> params(message);
    params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalMainFrameHost::Name_);
    message.set_method_name("FocusPage");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalMainFrameHostProxy::TakeFocus(bool in_reverse)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalMainFrameHost::TakeFocus", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("reverse"), in_reverse, "<value of type bool>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalMainFrameHost::kTakeFocus), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalMainFrameHost_TakeFocus_Params_Data> params(message);
    params.Allocate();
    params->reverse = in_reverse;

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalMainFrameHost::Name_);
    message.set_method_name("TakeFocus");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalMainFrameHostProxy::UpdateTargetURL(const ::blink::KURL& in_url, UpdateTargetURLCallback callback)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalMainFrameHost::UpdateTargetURL", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("url"), in_url, "<value of type const ::blink::KURL&>");
    });
#endif

    const bool kExpectsResponse = true;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalMainFrameHost::kUpdateTargetURL), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalMainFrameHost_UpdateTargetURL_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->url)::BaseType> url_fragment(params.message());
    mojo::internal::Serialize<::url::mojom::UrlDataView>(in_url, url_fragment);
    params->url.Set(url_fragment.is_null() ? nullptr : url_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->url.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null url in LocalMainFrameHost.UpdateTargetURL request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalMainFrameHost::Name_);
    message.set_method_name("UpdateTargetURL");
#endif
    std::unique_ptr<mojo::MessageReceiver> responder(new LocalMainFrameHost_UpdateTargetURL_ForwardToCallback(std::move(callback)));
    ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void LocalMainFrameHostProxy::RequestClose()
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT0("mojom", "Send blink::mojom::LocalMainFrameHost::RequestClose");
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalMainFrameHost::kRequestClose), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalMainFrameHost_RequestClose_Params_Data> params(message);
    params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalMainFrameHost::Name_);
    message.set_method_name("RequestClose");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalMainFrameHostProxy::ShowCreatedWindow(const ::blink::LocalFrameToken& in_opener_frame_token, ::ui::mojom::blink::WindowOpenDisposition in_disposition,
    ::blink::mojom::blink::WindowFeaturesPtr in_window_features, bool in_opened_by_user_gesture, ShowCreatedWindowCallback callback)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalMainFrameHost::ShowCreatedWindow", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(
            dict.AddItem("opener_frame_token"), in_opener_frame_token, "<value of type const ::blink::LocalFrameToken&>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("disposition"), in_disposition, "<value of type ::ui::mojom::blink::WindowOpenDisposition>");
        perfetto::WriteIntoTracedValueWithFallback(
            dict.AddItem("window_features"), in_window_features, "<value of type ::blink::mojom::blink::WindowFeaturesPtr>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("opened_by_user_gesture"), in_opened_by_user_gesture, "<value of type bool>");
    });
#endif

    const bool kExpectsResponse = true;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalMainFrameHost::kShowCreatedWindow), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalMainFrameHost_ShowCreatedWindow_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->opener_frame_token)::BaseType> opener_frame_token_fragment(params.message());
    mojo::internal::Serialize<::blink::mojom::LocalFrameTokenDataView>(in_opener_frame_token, opener_frame_token_fragment);
    params->opener_frame_token.Set(opener_frame_token_fragment.is_null() ? nullptr : opener_frame_token_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->opener_frame_token.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null opener_frame_token in LocalMainFrameHost.ShowCreatedWindow request");
    mojo::internal::Serialize<::ui::mojom::WindowOpenDisposition>(in_disposition, &params->disposition);
    mojo::internal::MessageFragment<typename decltype(params->window_features)::BaseType> window_features_fragment(params.message());
    mojo::internal::Serialize<::blink::mojom::WindowFeaturesDataView>(in_window_features, window_features_fragment);
    params->window_features.Set(window_features_fragment.is_null() ? nullptr : window_features_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->window_features.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null window_features in LocalMainFrameHost.ShowCreatedWindow request");
    params->opened_by_user_gesture = in_opened_by_user_gesture;

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalMainFrameHost::Name_);
    message.set_method_name("ShowCreatedWindow");
#endif
    std::unique_ptr<mojo::MessageReceiver> responder(new LocalMainFrameHost_ShowCreatedWindow_ForwardToCallback(std::move(callback)));
    ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void LocalMainFrameHostProxy::SetWindowRect(const ::gfx::Rect& in_bounds, SetWindowRectCallback callback)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalMainFrameHost::SetWindowRect", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("bounds"), in_bounds, "<value of type const ::gfx::Rect&>");
    });
#endif

    const bool kExpectsResponse = true;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalMainFrameHost::kSetWindowRect), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalMainFrameHost_SetWindowRect_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->bounds)::BaseType> bounds_fragment(params.message());
    mojo::internal::Serialize<::gfx::mojom::RectDataView>(in_bounds, bounds_fragment);
    params->bounds.Set(bounds_fragment.is_null() ? nullptr : bounds_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->bounds.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null bounds in LocalMainFrameHost.SetWindowRect request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalMainFrameHost::Name_);
    message.set_method_name("SetWindowRect");
#endif
    std::unique_ptr<mojo::MessageReceiver> responder(new LocalMainFrameHost_SetWindowRect_ForwardToCallback(std::move(callback)));
    ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void LocalMainFrameHostProxy::DidFirstVisuallyNonEmptyPaint()
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT0("mojom", "Send blink::mojom::LocalMainFrameHost::DidFirstVisuallyNonEmptyPaint");
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalMainFrameHost::kDidFirstVisuallyNonEmptyPaint), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalMainFrameHost_DidFirstVisuallyNonEmptyPaint_Params_Data> params(message);
    params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalMainFrameHost::Name_);
    message.set_method_name("DidFirstVisuallyNonEmptyPaint");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalMainFrameHostProxy::DidAccessInitialMainDocument()
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT0("mojom", "Send blink::mojom::LocalMainFrameHost::DidAccessInitialMainDocument");
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalMainFrameHost::kDidAccessInitialMainDocument), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalMainFrameHost_DidAccessInitialMainDocument_Params_Data> params(message);
    params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalMainFrameHost::Name_);
    message.set_method_name("DidAccessInitialMainDocument");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalMainFrameHostProxy::Maximize()
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT0("mojom", "Send blink::mojom::LocalMainFrameHost::Maximize");
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalMainFrameHost::kMaximize), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalMainFrameHost_Maximize_Params_Data> params(message);
    params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalMainFrameHost::Name_);
    message.set_method_name("Maximize");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalMainFrameHostProxy::Minimize()
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT0("mojom", "Send blink::mojom::LocalMainFrameHost::Minimize");
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalMainFrameHost::kMinimize), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalMainFrameHost_Minimize_Params_Data> params(message);
    params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalMainFrameHost::Name_);
    message.set_method_name("Minimize");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalMainFrameHostProxy::Restore()
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT0("mojom", "Send blink::mojom::LocalMainFrameHost::Restore");
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalMainFrameHost::kRestore), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalMainFrameHost_Restore_Params_Data> params(message);
    params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalMainFrameHost::Name_);
    message.set_method_name("Restore");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalMainFrameHostProxy::SetResizable(bool in_resizable)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalMainFrameHost::SetResizable", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("resizable"), in_resizable, "<value of type bool>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalMainFrameHost::kSetResizable), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalMainFrameHost_SetResizable_Params_Data> params(message);
    params.Allocate();
    params->resizable = in_resizable;

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalMainFrameHost::Name_);
    message.set_method_name("SetResizable");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalMainFrameHostProxy::DraggableRegionsChanged(WTF::Vector<::blink::mojom::blink::DraggableRegionPtr> in_regions)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::LocalMainFrameHost::DraggableRegionsChanged", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(
            dict.AddItem("regions"), in_regions, "<value of type WTF::Vector<::blink::mojom::blink::DraggableRegionPtr>>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalMainFrameHost::kDraggableRegionsChanged), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalMainFrameHost_DraggableRegionsChanged_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->regions)::BaseType> regions_fragment(params.message());
    constexpr const mojo::internal::ContainerValidateParams& regions_validate_params = mojo::internal::GetArrayValidator<0, false, nullptr>();
    mojo::internal::Serialize<mojo::ArrayDataView<::blink::mojom::DraggableRegionDataView>>(in_regions, regions_fragment, &regions_validate_params);
    params->regions.Set(regions_fragment.is_null() ? nullptr : regions_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->regions.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null regions in LocalMainFrameHost.DraggableRegionsChanged request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalMainFrameHost::Name_);
    message.set_method_name("DraggableRegionsChanged");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalMainFrameHostProxy::OnFirstContentfulPaint()
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT0("mojom", "Send blink::mojom::LocalMainFrameHost::OnFirstContentfulPaint");
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalMainFrameHost::kOnFirstContentfulPaint), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalMainFrameHost_OnFirstContentfulPaint_Params_Data> params(message);
    params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalMainFrameHost::Name_);
    message.set_method_name("OnFirstContentfulPaint");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}
class LocalMainFrameHost_UpdateTargetURL_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
public:
    static LocalMainFrameHost::UpdateTargetURLCallback CreateCallback(::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
    {
        std::unique_ptr<LocalMainFrameHost_UpdateTargetURL_ProxyToResponder> proxy(
            new LocalMainFrameHost_UpdateTargetURL_ProxyToResponder(message, std::move(responder)));
        return base::BindOnce(&LocalMainFrameHost_UpdateTargetURL_ProxyToResponder::Run, std::move(proxy));
    }

    ~LocalMainFrameHost_UpdateTargetURL_ProxyToResponder()
    {
#if DCHECK_IS_ON()
        if (responder_) {
            // If we're being destroyed without being run, we want to ensure the
            // binding endpoint has been closed. This checks for that asynchronously.
            // We pass a bound generated callback to handle the response so that any
            // resulting DCHECK stack will have useful interface type information.
            // Instantiate a ScopedFizzleBlockShutdownTasks to allow this request to
            // fizzle if this happens after shutdown and the endpoint is bound to a
            // BLOCK_SHUTDOWN sequence.
            base::ThreadPoolInstance::ScopedFizzleBlockShutdownTasks fizzler;
            responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
        }
#endif
    }

private:
    LocalMainFrameHost_UpdateTargetURL_ProxyToResponder(::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
        : ::mojo::internal::ProxyToResponder(message, std::move(responder))
    {
    }

#if DCHECK_IS_ON()
    static void OnIsConnectedComplete(bool connected)
    {
        DCHECK(!connected) << "LocalMainFrameHost::UpdateTargetURLCallback was destroyed without "
                           << "first either being run or its corresponding binding being closed. "
                           << "It is an error to drop response callbacks which still correspond "
                           << "to an open interface pipe.";
    }
#endif

    void Run();
};

bool LocalMainFrameHost_UpdateTargetURL_ForwardToCallback::Accept(mojo::Message* message)
{
    DCHECK(message->is_serialized());
    internal::LocalMainFrameHost_UpdateTargetURL_ResponseParams_Data* params
        = reinterpret_cast<internal::LocalMainFrameHost_UpdateTargetURL_ResponseParams_Data*>(message->mutable_payload());

    // Validation for LocalMainFrameHost.5
    bool success = true;
    LocalMainFrameHost_UpdateTargetURL_ResponseParamsDataView input_data_view(params, message);

    if (!success) {
        ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalMainFrameHost::Name_, 5, true);
        return false;
    }
    if (!callback_.is_null())
        std::move(callback_).Run();
    return true;
}

void LocalMainFrameHost_UpdateTargetURL_ProxyToResponder::Run()
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT0("mojom", "Send reply blink::mojom::LocalMainFrameHost::UpdateTargetURL");
#endif

    const uint32_t kFlags = mojo::Message::kFlagIsResponse | ((is_sync_) ? mojo::Message::kFlagIsSync : 0) | ((true) ? 0 : mojo::Message::kFlagNoInterrupt)
        | ((false) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalMainFrameHost::kUpdateTargetURL), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalMainFrameHost_UpdateTargetURL_ResponseParams_Data> params(message);
    params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalMainFrameHost::Name_);
    message.set_method_name("UpdateTargetURL");
#endif

    message.set_request_id(request_id_);
    message.set_trace_nonce(trace_nonce_);
    ::mojo::internal::SendMojoMessage(*responder_, message);
    // SendMojoMessage() fails silently if the responder connection is closed,
    // or if the message is malformed.
    //
    // TODO(darin): If Accept() returns false due to a malformed message, that
    // may be good reason to close the connection. However, we don't have a
    // way to do that from here. We should add a way.
    responder_ = nullptr;
}
class LocalMainFrameHost_ShowCreatedWindow_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
public:
    static LocalMainFrameHost::ShowCreatedWindowCallback CreateCallback(::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
    {
        std::unique_ptr<LocalMainFrameHost_ShowCreatedWindow_ProxyToResponder> proxy(
            new LocalMainFrameHost_ShowCreatedWindow_ProxyToResponder(message, std::move(responder)));
        return base::BindOnce(&LocalMainFrameHost_ShowCreatedWindow_ProxyToResponder::Run, std::move(proxy));
    }

    ~LocalMainFrameHost_ShowCreatedWindow_ProxyToResponder()
    {
#if DCHECK_IS_ON()
        if (responder_) {
            // If we're being destroyed without being run, we want to ensure the
            // binding endpoint has been closed. This checks for that asynchronously.
            // We pass a bound generated callback to handle the response so that any
            // resulting DCHECK stack will have useful interface type information.
            // Instantiate a ScopedFizzleBlockShutdownTasks to allow this request to
            // fizzle if this happens after shutdown and the endpoint is bound to a
            // BLOCK_SHUTDOWN sequence.
            base::ThreadPoolInstance::ScopedFizzleBlockShutdownTasks fizzler;
            responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
        }
#endif
    }

private:
    LocalMainFrameHost_ShowCreatedWindow_ProxyToResponder(::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
        : ::mojo::internal::ProxyToResponder(message, std::move(responder))
    {
    }

#if DCHECK_IS_ON()
    static void OnIsConnectedComplete(bool connected)
    {
        DCHECK(!connected) << "LocalMainFrameHost::ShowCreatedWindowCallback was destroyed without "
                           << "first either being run or its corresponding binding being closed. "
                           << "It is an error to drop response callbacks which still correspond "
                           << "to an open interface pipe.";
    }
#endif

    void Run();
};

bool LocalMainFrameHost_ShowCreatedWindow_ForwardToCallback::Accept(mojo::Message* message)
{
    DCHECK(message->is_serialized());
    internal::LocalMainFrameHost_ShowCreatedWindow_ResponseParams_Data* params
        = reinterpret_cast<internal::LocalMainFrameHost_ShowCreatedWindow_ResponseParams_Data*>(message->mutable_payload());

    // Validation for LocalMainFrameHost.7
    bool success = true;
    LocalMainFrameHost_ShowCreatedWindow_ResponseParamsDataView input_data_view(params, message);

    if (!success) {
        ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalMainFrameHost::Name_, 7, true);
        return false;
    }
    if (!callback_.is_null())
        std::move(callback_).Run();
    return true;
}

void LocalMainFrameHost_ShowCreatedWindow_ProxyToResponder::Run()
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT0("mojom", "Send reply blink::mojom::LocalMainFrameHost::ShowCreatedWindow");
#endif

    const uint32_t kFlags = mojo::Message::kFlagIsResponse | ((is_sync_) ? mojo::Message::kFlagIsSync : 0) | ((true) ? 0 : mojo::Message::kFlagNoInterrupt)
        | ((false) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalMainFrameHost::kShowCreatedWindow), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalMainFrameHost_ShowCreatedWindow_ResponseParams_Data> params(message);
    params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalMainFrameHost::Name_);
    message.set_method_name("ShowCreatedWindow");
#endif

    message.set_request_id(request_id_);
    message.set_trace_nonce(trace_nonce_);
    ::mojo::internal::SendMojoMessage(*responder_, message);
    // SendMojoMessage() fails silently if the responder connection is closed,
    // or if the message is malformed.
    //
    // TODO(darin): If Accept() returns false due to a malformed message, that
    // may be good reason to close the connection. However, we don't have a
    // way to do that from here. We should add a way.
    responder_ = nullptr;
}
class LocalMainFrameHost_SetWindowRect_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
public:
    static LocalMainFrameHost::SetWindowRectCallback CreateCallback(::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
    {
        std::unique_ptr<LocalMainFrameHost_SetWindowRect_ProxyToResponder> proxy(
            new LocalMainFrameHost_SetWindowRect_ProxyToResponder(message, std::move(responder)));
        return base::BindOnce(&LocalMainFrameHost_SetWindowRect_ProxyToResponder::Run, std::move(proxy));
    }

    ~LocalMainFrameHost_SetWindowRect_ProxyToResponder()
    {
#if DCHECK_IS_ON()
        if (responder_) {
            // If we're being destroyed without being run, we want to ensure the
            // binding endpoint has been closed. This checks for that asynchronously.
            // We pass a bound generated callback to handle the response so that any
            // resulting DCHECK stack will have useful interface type information.
            // Instantiate a ScopedFizzleBlockShutdownTasks to allow this request to
            // fizzle if this happens after shutdown and the endpoint is bound to a
            // BLOCK_SHUTDOWN sequence.
            base::ThreadPoolInstance::ScopedFizzleBlockShutdownTasks fizzler;
            responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
        }
#endif
    }

private:
    LocalMainFrameHost_SetWindowRect_ProxyToResponder(::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
        : ::mojo::internal::ProxyToResponder(message, std::move(responder))
    {
    }

#if DCHECK_IS_ON()
    static void OnIsConnectedComplete(bool connected)
    {
        DCHECK(!connected) << "LocalMainFrameHost::SetWindowRectCallback was destroyed without "
                           << "first either being run or its corresponding binding being closed. "
                           << "It is an error to drop response callbacks which still correspond "
                           << "to an open interface pipe.";
    }
#endif

    void Run();
};

bool LocalMainFrameHost_SetWindowRect_ForwardToCallback::Accept(mojo::Message* message)
{
    DCHECK(message->is_serialized());
    internal::LocalMainFrameHost_SetWindowRect_ResponseParams_Data* params
        = reinterpret_cast<internal::LocalMainFrameHost_SetWindowRect_ResponseParams_Data*>(message->mutable_payload());

    // Validation for LocalMainFrameHost.8
    bool success = true;
    LocalMainFrameHost_SetWindowRect_ResponseParamsDataView input_data_view(params, message);

    if (!success) {
        ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalMainFrameHost::Name_, 8, true);
        return false;
    }
    if (!callback_.is_null())
        std::move(callback_).Run();
    return true;
}

void LocalMainFrameHost_SetWindowRect_ProxyToResponder::Run()
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT0("mojom", "Send reply blink::mojom::LocalMainFrameHost::SetWindowRect");
#endif

    const uint32_t kFlags = mojo::Message::kFlagIsResponse | ((is_sync_) ? mojo::Message::kFlagIsSync : 0) | ((true) ? 0 : mojo::Message::kFlagNoInterrupt)
        | ((false) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::LocalMainFrameHost::kSetWindowRect), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::LocalMainFrameHost_SetWindowRect_ResponseParams_Data> params(message);
    params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(LocalMainFrameHost::Name_);
    message.set_method_name("SetWindowRect");
#endif

    message.set_request_id(request_id_);
    message.set_trace_nonce(trace_nonce_);
    ::mojo::internal::SendMojoMessage(*responder_, message);
    // SendMojoMessage() fails silently if the responder connection is closed,
    // or if the message is malformed.
    //
    // TODO(darin): If Accept() returns false due to a malformed message, that
    // may be good reason to close the connection. However, we don't have a
    // way to do that from here. We should add a way.
    responder_ = nullptr;
}

// static
bool LocalMainFrameHostStubDispatch::Accept(LocalMainFrameHost* impl, mojo::Message* message)
{
    const uint64_t kDebugAliasSentinel0 = 0xC0FFEE42;
    const uint64_t kMessageName = message->header()->name;
    const uint64_t kDebugAliasSentinel1 = 0xDECAFBAD;
    base::debug::Alias(&kDebugAliasSentinel0);
    base::debug::Alias(&kMessageName);
    base::debug::Alias(&kDebugAliasSentinel1);
    switch (static_cast<messages::LocalMainFrameHost>(message->header()->name)) {
    case messages::LocalMainFrameHost::kScaleFactorChanged: {
        DCHECK(message->is_serialized());
        internal::LocalMainFrameHost_ScaleFactorChanged_Params_Data* params
            = reinterpret_cast<internal::LocalMainFrameHost_ScaleFactorChanged_Params_Data*>(message->mutable_payload());

        // Validation for LocalMainFrameHost.0
        bool success = true;
        float p_scale {};
        LocalMainFrameHost_ScaleFactorChanged_ParamsDataView input_data_view(params, message);

        if (success)
            p_scale = input_data_view.scale();
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalMainFrameHost::Name_, 0, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->ScaleFactorChanged(std::move(p_scale));
        return true;
    }
    case messages::LocalMainFrameHost::kContentsPreferredSizeChanged: {
        DCHECK(message->is_serialized());
        internal::LocalMainFrameHost_ContentsPreferredSizeChanged_Params_Data* params
            = reinterpret_cast<internal::LocalMainFrameHost_ContentsPreferredSizeChanged_Params_Data*>(message->mutable_payload());

        // Validation for LocalMainFrameHost.1
        bool success = true;
        ::gfx::Size p_pref_size {};
        LocalMainFrameHost_ContentsPreferredSizeChanged_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadPrefSize(&p_pref_size))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalMainFrameHost::Name_, 1, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->ContentsPreferredSizeChanged(std::move(p_pref_size));
        return true;
    }
    case messages::LocalMainFrameHost::kTextAutosizerPageInfoChanged: {
        DCHECK(message->is_serialized());
        internal::LocalMainFrameHost_TextAutosizerPageInfoChanged_Params_Data* params
            = reinterpret_cast<internal::LocalMainFrameHost_TextAutosizerPageInfoChanged_Params_Data*>(message->mutable_payload());

        // Validation for LocalMainFrameHost.2
        bool success = true;
        ::blink::mojom::blink::TextAutosizerPageInfoPtr p_page_info {};
        LocalMainFrameHost_TextAutosizerPageInfoChanged_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadPageInfo(&p_page_info))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalMainFrameHost::Name_, 2, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->TextAutosizerPageInfoChanged(std::move(p_page_info));
        return true;
    }
    case messages::LocalMainFrameHost::kFocusPage: {
        DCHECK(message->is_serialized());
        internal::LocalMainFrameHost_FocusPage_Params_Data* params
            = reinterpret_cast<internal::LocalMainFrameHost_FocusPage_Params_Data*>(message->mutable_payload());

        // Validation for LocalMainFrameHost.3
        bool success = true;
        LocalMainFrameHost_FocusPage_ParamsDataView input_data_view(params, message);

        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalMainFrameHost::Name_, 3, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->FocusPage();
        return true;
    }
    case messages::LocalMainFrameHost::kTakeFocus: {
        DCHECK(message->is_serialized());
        internal::LocalMainFrameHost_TakeFocus_Params_Data* params
            = reinterpret_cast<internal::LocalMainFrameHost_TakeFocus_Params_Data*>(message->mutable_payload());

        // Validation for LocalMainFrameHost.4
        bool success = true;
        bool p_reverse {};
        LocalMainFrameHost_TakeFocus_ParamsDataView input_data_view(params, message);

        if (success)
            p_reverse = input_data_view.reverse();
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalMainFrameHost::Name_, 4, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->TakeFocus(std::move(p_reverse));
        return true;
    }
    case messages::LocalMainFrameHost::kUpdateTargetURL: {
        break;
    }
    case messages::LocalMainFrameHost::kRequestClose: {
        DCHECK(message->is_serialized());
        internal::LocalMainFrameHost_RequestClose_Params_Data* params
            = reinterpret_cast<internal::LocalMainFrameHost_RequestClose_Params_Data*>(message->mutable_payload());

        // Validation for LocalMainFrameHost.6
        bool success = true;
        LocalMainFrameHost_RequestClose_ParamsDataView input_data_view(params, message);

        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalMainFrameHost::Name_, 6, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->RequestClose();
        return true;
    }
    case messages::LocalMainFrameHost::kShowCreatedWindow: {
        break;
    }
    case messages::LocalMainFrameHost::kSetWindowRect: {
        break;
    }
    case messages::LocalMainFrameHost::kDidFirstVisuallyNonEmptyPaint: {
        DCHECK(message->is_serialized());
        internal::LocalMainFrameHost_DidFirstVisuallyNonEmptyPaint_Params_Data* params
            = reinterpret_cast<internal::LocalMainFrameHost_DidFirstVisuallyNonEmptyPaint_Params_Data*>(message->mutable_payload());

        // Validation for LocalMainFrameHost.9
        bool success = true;
        LocalMainFrameHost_DidFirstVisuallyNonEmptyPaint_ParamsDataView input_data_view(params, message);

        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalMainFrameHost::Name_, 9, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->DidFirstVisuallyNonEmptyPaint();
        return true;
    }
    case messages::LocalMainFrameHost::kDidAccessInitialMainDocument: {
        DCHECK(message->is_serialized());
        internal::LocalMainFrameHost_DidAccessInitialMainDocument_Params_Data* params
            = reinterpret_cast<internal::LocalMainFrameHost_DidAccessInitialMainDocument_Params_Data*>(message->mutable_payload());

        // Validation for LocalMainFrameHost.10
        bool success = true;
        LocalMainFrameHost_DidAccessInitialMainDocument_ParamsDataView input_data_view(params, message);

        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalMainFrameHost::Name_, 10, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->DidAccessInitialMainDocument();
        return true;
    }
    case messages::LocalMainFrameHost::kMaximize: {
        DCHECK(message->is_serialized());
        internal::LocalMainFrameHost_Maximize_Params_Data* params
            = reinterpret_cast<internal::LocalMainFrameHost_Maximize_Params_Data*>(message->mutable_payload());

        // Validation for LocalMainFrameHost.11
        bool success = true;
        LocalMainFrameHost_Maximize_ParamsDataView input_data_view(params, message);

        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalMainFrameHost::Name_, 11, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->Maximize();
        return true;
    }
    case messages::LocalMainFrameHost::kMinimize: {
        DCHECK(message->is_serialized());
        internal::LocalMainFrameHost_Minimize_Params_Data* params
            = reinterpret_cast<internal::LocalMainFrameHost_Minimize_Params_Data*>(message->mutable_payload());

        // Validation for LocalMainFrameHost.12
        bool success = true;
        LocalMainFrameHost_Minimize_ParamsDataView input_data_view(params, message);

        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalMainFrameHost::Name_, 12, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->Minimize();
        return true;
    }
    case messages::LocalMainFrameHost::kRestore: {
        DCHECK(message->is_serialized());
        internal::LocalMainFrameHost_Restore_Params_Data* params
            = reinterpret_cast<internal::LocalMainFrameHost_Restore_Params_Data*>(message->mutable_payload());

        // Validation for LocalMainFrameHost.13
        bool success = true;
        LocalMainFrameHost_Restore_ParamsDataView input_data_view(params, message);

        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalMainFrameHost::Name_, 13, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->Restore();
        return true;
    }
    case messages::LocalMainFrameHost::kSetResizable: {
        DCHECK(message->is_serialized());
        internal::LocalMainFrameHost_SetResizable_Params_Data* params
            = reinterpret_cast<internal::LocalMainFrameHost_SetResizable_Params_Data*>(message->mutable_payload());

        // Validation for LocalMainFrameHost.14
        bool success = true;
        bool p_resizable {};
        LocalMainFrameHost_SetResizable_ParamsDataView input_data_view(params, message);

        if (success)
            p_resizable = input_data_view.resizable();
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalMainFrameHost::Name_, 14, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->SetResizable(std::move(p_resizable));
        return true;
    }
    case messages::LocalMainFrameHost::kDraggableRegionsChanged: {
        DCHECK(message->is_serialized());
        internal::LocalMainFrameHost_DraggableRegionsChanged_Params_Data* params
            = reinterpret_cast<internal::LocalMainFrameHost_DraggableRegionsChanged_Params_Data*>(message->mutable_payload());

        // Validation for LocalMainFrameHost.15
        bool success = true;
        WTF::Vector<::blink::mojom::blink::DraggableRegionPtr> p_regions {};
        LocalMainFrameHost_DraggableRegionsChanged_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadRegions(&p_regions))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalMainFrameHost::Name_, 15, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->DraggableRegionsChanged(std::move(p_regions));
        return true;
    }
    case messages::LocalMainFrameHost::kOnFirstContentfulPaint: {
        DCHECK(message->is_serialized());
        internal::LocalMainFrameHost_OnFirstContentfulPaint_Params_Data* params
            = reinterpret_cast<internal::LocalMainFrameHost_OnFirstContentfulPaint_Params_Data*>(message->mutable_payload());

        // Validation for LocalMainFrameHost.16
        bool success = true;
        LocalMainFrameHost_OnFirstContentfulPaint_ParamsDataView input_data_view(params, message);

        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalMainFrameHost::Name_, 16, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->OnFirstContentfulPaint();
        return true;
    }
    }
    return false;
}

// static
bool LocalMainFrameHostStubDispatch::AcceptWithResponder(
    LocalMainFrameHost* impl, mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
{
    [[maybe_unused]] const bool message_is_sync = message->has_flag(mojo::Message::kFlagIsSync);
    [[maybe_unused]] const uint64_t request_id = message->request_id();
    switch (static_cast<messages::LocalMainFrameHost>(message->header()->name)) {
    case messages::LocalMainFrameHost::kScaleFactorChanged: {
        break;
    }
    case messages::LocalMainFrameHost::kContentsPreferredSizeChanged: {
        break;
    }
    case messages::LocalMainFrameHost::kTextAutosizerPageInfoChanged: {
        break;
    }
    case messages::LocalMainFrameHost::kFocusPage: {
        break;
    }
    case messages::LocalMainFrameHost::kTakeFocus: {
        break;
    }
    case messages::LocalMainFrameHost::kUpdateTargetURL: {
        internal::LocalMainFrameHost_UpdateTargetURL_Params_Data* params
            = reinterpret_cast<internal::LocalMainFrameHost_UpdateTargetURL_Params_Data*>(message->mutable_payload());

        // Validation for LocalMainFrameHost.5
        bool success = true;
        ::blink::KURL p_url {};
        LocalMainFrameHost_UpdateTargetURL_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadUrl(&p_url))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalMainFrameHost::Name_, 5, false);
            return false;
        }
        LocalMainFrameHost::UpdateTargetURLCallback callback
            = LocalMainFrameHost_UpdateTargetURL_ProxyToResponder::CreateCallback(*message, std::move(responder));
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->UpdateTargetURL(std::move(p_url), std::move(callback));
        return true;
    }
    case messages::LocalMainFrameHost::kRequestClose: {
        break;
    }
    case messages::LocalMainFrameHost::kShowCreatedWindow: {
        internal::LocalMainFrameHost_ShowCreatedWindow_Params_Data* params
            = reinterpret_cast<internal::LocalMainFrameHost_ShowCreatedWindow_Params_Data*>(message->mutable_payload());

        // Validation for LocalMainFrameHost.7
        bool success = true;
        ::blink::LocalFrameToken p_opener_frame_token {};
        ::ui::mojom::blink::WindowOpenDisposition p_disposition {};
        ::blink::mojom::blink::WindowFeaturesPtr p_window_features {};
        bool p_opened_by_user_gesture {};
        LocalMainFrameHost_ShowCreatedWindow_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadOpenerFrameToken(&p_opener_frame_token))
            success = false;
        if (success && !input_data_view.ReadDisposition(&p_disposition))
            success = false;
        if (success && !input_data_view.ReadWindowFeatures(&p_window_features))
            success = false;
        if (success)
            p_opened_by_user_gesture = input_data_view.opened_by_user_gesture();
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalMainFrameHost::Name_, 7, false);
            return false;
        }
        LocalMainFrameHost::ShowCreatedWindowCallback callback
            = LocalMainFrameHost_ShowCreatedWindow_ProxyToResponder::CreateCallback(*message, std::move(responder));
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->ShowCreatedWindow(
            std::move(p_opener_frame_token), std::move(p_disposition), std::move(p_window_features), std::move(p_opened_by_user_gesture), std::move(callback));
        return true;
    }
    case messages::LocalMainFrameHost::kSetWindowRect: {
        internal::LocalMainFrameHost_SetWindowRect_Params_Data* params
            = reinterpret_cast<internal::LocalMainFrameHost_SetWindowRect_Params_Data*>(message->mutable_payload());

        // Validation for LocalMainFrameHost.8
        bool success = true;
        ::gfx::Rect p_bounds {};
        LocalMainFrameHost_SetWindowRect_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadBounds(&p_bounds))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, LocalMainFrameHost::Name_, 8, false);
            return false;
        }
        LocalMainFrameHost::SetWindowRectCallback callback = LocalMainFrameHost_SetWindowRect_ProxyToResponder::CreateCallback(*message, std::move(responder));
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->SetWindowRect(std::move(p_bounds), std::move(callback));
        return true;
    }
    case messages::LocalMainFrameHost::kDidFirstVisuallyNonEmptyPaint: {
        break;
    }
    case messages::LocalMainFrameHost::kDidAccessInitialMainDocument: {
        break;
    }
    case messages::LocalMainFrameHost::kMaximize: {
        break;
    }
    case messages::LocalMainFrameHost::kMinimize: {
        break;
    }
    case messages::LocalMainFrameHost::kRestore: {
        break;
    }
    case messages::LocalMainFrameHost::kSetResizable: {
        break;
    }
    case messages::LocalMainFrameHost::kDraggableRegionsChanged: {
        break;
    }
    case messages::LocalMainFrameHost::kOnFirstContentfulPaint: {
        break;
    }
    }
    return false;
}
namespace {
} // namespace
static const mojo::internal::GenericValidationInfo kLocalMainFrameHostValidationInfo[] = {
    { &internal::LocalMainFrameHost_ScaleFactorChanged_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalMainFrameHost_ContentsPreferredSizeChanged_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalMainFrameHost_TextAutosizerPageInfoChanged_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalMainFrameHost_FocusPage_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalMainFrameHost_TakeFocus_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalMainFrameHost_UpdateTargetURL_Params_Data::Validate, &internal::LocalMainFrameHost_UpdateTargetURL_ResponseParams_Data::Validate },
    { &internal::LocalMainFrameHost_RequestClose_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalMainFrameHost_ShowCreatedWindow_Params_Data::Validate, &internal::LocalMainFrameHost_ShowCreatedWindow_ResponseParams_Data::Validate },
    { &internal::LocalMainFrameHost_SetWindowRect_Params_Data::Validate, &internal::LocalMainFrameHost_SetWindowRect_ResponseParams_Data::Validate },
    { &internal::LocalMainFrameHost_DidFirstVisuallyNonEmptyPaint_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalMainFrameHost_DidAccessInitialMainDocument_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalMainFrameHost_Maximize_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalMainFrameHost_Minimize_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalMainFrameHost_Restore_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalMainFrameHost_SetResizable_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalMainFrameHost_DraggableRegionsChanged_Params_Data::Validate, nullptr /* no response */ },
    { &internal::LocalMainFrameHost_OnFirstContentfulPaint_Params_Data::Validate, nullptr /* no response */ },
};

bool LocalMainFrameHostRequestValidator::Accept(mojo::Message* message)
{
    const char* name = ::blink::mojom::blink::LocalMainFrameHost::Name_;
    return mojo::internal::ValidateRequestGenericPacked(message, name, kLocalMainFrameHostValidationInfo);
}

bool LocalMainFrameHostResponseValidator::Accept(mojo::Message* message)
{
    const char* name = ::blink::mojom::blink::LocalMainFrameHost::Name_;
    return mojo::internal::ValidateResponseGenericPacked(message, name, kLocalMainFrameHostValidationInfo);
}

} // blink::mojom::blink

namespace mojo {

// static
bool StructTraits<::blink::mojom::blink::SavableSubframe::DataView, ::blink::mojom::blink::SavableSubframePtr>::Read(
    ::blink::mojom::blink::SavableSubframe::DataView input, ::blink::mojom::blink::SavableSubframePtr* output)
{
    bool success = true;
    ::blink::mojom::blink::SavableSubframePtr result(::blink::mojom::blink::SavableSubframe::New());

    if (success && !input.ReadOriginalUrl(&result->original_url))
        success = false;
    if (success && !input.ReadSubframeToken(&result->subframe_token))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::blink::mojom::blink::GetSavableResourceLinksReply::DataView, ::blink::mojom::blink::GetSavableResourceLinksReplyPtr>::Read(
    ::blink::mojom::blink::GetSavableResourceLinksReply::DataView input, ::blink::mojom::blink::GetSavableResourceLinksReplyPtr* output)
{
    bool success = true;
    ::blink::mojom::blink::GetSavableResourceLinksReplyPtr result(::blink::mojom::blink::GetSavableResourceLinksReply::New());

    if (success && !input.ReadResourcesList(&result->resources_list))
        success = false;
    if (success && !input.ReadReferrer(&result->referrer))
        success = false;
    if (success && !input.ReadSubframes(&result->subframes))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::blink::mojom::blink::FindInPageResultAXParams::DataView, ::blink::mojom::blink::FindInPageResultAXParamsPtr>::Read(
    ::blink::mojom::blink::FindInPageResultAXParams::DataView input, ::blink::mojom::blink::FindInPageResultAXParamsPtr* output)
{
    bool success = true;
    ::blink::mojom::blink::FindInPageResultAXParamsPtr result(::blink::mojom::blink::FindInPageResultAXParams::New());

    if (success)
        result->request_id = input.request_id();
    if (success)
        result->match_index = input.match_index();
    if (success)
        result->start_id = input.start_id();
    if (success)
        result->start_offset = input.start_offset();
    if (success)
        result->end_id = input.end_id();
    if (success)
        result->end_offset = input.end_offset();
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::blink::mojom::blink::DownloadURLParams::DataView, ::blink::mojom::blink::DownloadURLParamsPtr>::Read(
    ::blink::mojom::blink::DownloadURLParams::DataView input, ::blink::mojom::blink::DownloadURLParamsPtr* output)
{
    bool success = true;
    ::blink::mojom::blink::DownloadURLParamsPtr result(::blink::mojom::blink::DownloadURLParams::New());

    if (success && !input.ReadUrl(&result->url))
        success = false;
    if (success && !input.ReadReferrer(&result->referrer))
        success = false;
    if (success && !input.ReadInitiatorOrigin(&result->initiator_origin))
        success = false;
    if (success && !input.ReadSuggestedName(&result->suggested_name))
        success = false;
    if (success && !input.ReadCrossOriginRedirects(&result->cross_origin_redirects))
        success = false;
    if (success) {
        result->blob_url_token = input.TakeBlobUrlToken<decltype(result->blob_url_token)>();
    }
    if (success) {
        result->data_url_blob = input.TakeDataUrlBlob<decltype(result->data_url_blob)>();
    }
    if (success)
        result->is_context_menu_save = input.is_context_menu_save();
    if (success)
        result->has_user_gesture = input.has_user_gesture();
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::blink::mojom::blink::IframeAttributes::DataView, ::blink::mojom::blink::IframeAttributesPtr>::Read(
    ::blink::mojom::blink::IframeAttributes::DataView input, ::blink::mojom::blink::IframeAttributesPtr* output)
{
    bool success = true;
    ::blink::mojom::blink::IframeAttributesPtr result(::blink::mojom::blink::IframeAttributes::New());

    if (success && !input.ReadParsedCspAttribute(&result->parsed_csp_attribute))
        success = false;
    if (success)
        result->credentialless = input.credentialless();
    if (success)
        result->browsing_topics = input.browsing_topics();
    if (success)
        result->ad_auction_headers = input.ad_auction_headers();
    if (success)
        result->shared_storage_writable_opted_in = input.shared_storage_writable_opted_in();
    if (success && !input.ReadId(&result->id))
        success = false;
    if (success && !input.ReadName(&result->name))
        success = false;
    if (success && !input.ReadSrc(&result->src))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::blink::mojom::blink::LegacyTechEventCodeLocation::DataView, ::blink::mojom::blink::LegacyTechEventCodeLocationPtr>::Read(
    ::blink::mojom::blink::LegacyTechEventCodeLocation::DataView input, ::blink::mojom::blink::LegacyTechEventCodeLocationPtr* output)
{
    bool success = true;
    ::blink::mojom::blink::LegacyTechEventCodeLocationPtr result(::blink::mojom::blink::LegacyTechEventCodeLocation::New());

    if (success && !input.ReadFilename(&result->filename))
        success = false;
    if (success)
        result->line = input.line();
    if (success)
        result->column = input.column();
    *output = std::move(result);
    return success;
}

} // namespace mojo

// Symbols declared in the -test-utils.h header are defined here instead of a
// separate .cc file to save compile time.

namespace blink::mojom::blink {

void LocalFrameHostInterceptorForTesting::EnterFullscreen(::blink::mojom::blink::FullscreenOptionsPtr options, EnterFullscreenCallback callback)
{
    GetForwardingInterface()->EnterFullscreen(std::move(options), std::move(callback));
}
void LocalFrameHostInterceptorForTesting::ExitFullscreen()
{
    GetForwardingInterface()->ExitFullscreen();
}
void LocalFrameHostInterceptorForTesting::FullscreenStateChanged(bool is_fullscreen, ::blink::mojom::blink::FullscreenOptionsPtr options)
{
    GetForwardingInterface()->FullscreenStateChanged(std::move(is_fullscreen), std::move(options));
}
void LocalFrameHostInterceptorForTesting::RegisterProtocolHandler(const WTF::String& scheme, const ::blink::KURL& url, bool user_gesture)
{
    GetForwardingInterface()->RegisterProtocolHandler(std::move(scheme), std::move(url), std::move(user_gesture));
}
void LocalFrameHostInterceptorForTesting::UnregisterProtocolHandler(const WTF::String& scheme, const ::blink::KURL& url, bool user_gesture)
{
    GetForwardingInterface()->UnregisterProtocolHandler(std::move(scheme), std::move(url), std::move(user_gesture));
}
void LocalFrameHostInterceptorForTesting::DidDisplayInsecureContent()
{
    GetForwardingInterface()->DidDisplayInsecureContent();
}
void LocalFrameHostInterceptorForTesting::DidContainInsecureFormAction()
{
    GetForwardingInterface()->DidContainInsecureFormAction();
}
void LocalFrameHostInterceptorForTesting::MainDocumentElementAvailable(bool uses_temporary_zoom_level)
{
    GetForwardingInterface()->MainDocumentElementAvailable(std::move(uses_temporary_zoom_level));
}
void LocalFrameHostInterceptorForTesting::SetNeedsOcclusionTracking(bool needs_tracking)
{
    GetForwardingInterface()->SetNeedsOcclusionTracking(std::move(needs_tracking));
}
void LocalFrameHostInterceptorForTesting::SetVirtualKeyboardMode(::ui::mojom::blink::VirtualKeyboardMode type)
{
    GetForwardingInterface()->SetVirtualKeyboardMode(std::move(type));
}
void LocalFrameHostInterceptorForTesting::VisibilityChanged(::blink::mojom::blink::FrameVisibility visibility)
{
    GetForwardingInterface()->VisibilityChanged(std::move(visibility));
}
void LocalFrameHostInterceptorForTesting::DidChangeThemeColor(std::optional<::SkColor> theme_color)
{
    GetForwardingInterface()->DidChangeThemeColor(std::move(theme_color));
}
void LocalFrameHostInterceptorForTesting::DidChangeBackgroundColor(const ::SkColor4f& background_color, bool color_adjust)
{
    GetForwardingInterface()->DidChangeBackgroundColor(std::move(background_color), std::move(color_adjust));
}
void LocalFrameHostInterceptorForTesting::DidFailLoadWithError(const ::blink::KURL& url, int32_t error_code)
{
    GetForwardingInterface()->DidFailLoadWithError(std::move(url), std::move(error_code));
}
void LocalFrameHostInterceptorForTesting::DidFocusFrame()
{
    GetForwardingInterface()->DidFocusFrame();
}
void LocalFrameHostInterceptorForTesting::DidCallFocus()
{
    GetForwardingInterface()->DidCallFocus();
}
void LocalFrameHostInterceptorForTesting::EnforceInsecureRequestPolicy(::blink::mojom::blink::InsecureRequestPolicy policy_bitmap)
{
    GetForwardingInterface()->EnforceInsecureRequestPolicy(std::move(policy_bitmap));
}
void LocalFrameHostInterceptorForTesting::EnforceInsecureNavigationsSet(const WTF::Vector<uint32_t>& set)
{
    GetForwardingInterface()->EnforceInsecureNavigationsSet(std::move(set));
}
void LocalFrameHostInterceptorForTesting::SuddenTerminationDisablerChanged(bool present, ::blink::mojom::blink::SuddenTerminationDisablerType disabler_type)
{
    GetForwardingInterface()->SuddenTerminationDisablerChanged(std::move(present), std::move(disabler_type));
}
void LocalFrameHostInterceptorForTesting::HadStickyUserActivationBeforeNavigationChanged(bool has_gesture)
{
    GetForwardingInterface()->HadStickyUserActivationBeforeNavigationChanged(std::move(has_gesture));
}
void LocalFrameHostInterceptorForTesting::ScrollRectToVisibleInParentFrame(
    const ::gfx::RectF& rect_to_scroll, ::blink::mojom::blink::ScrollIntoViewParamsPtr params)
{
    GetForwardingInterface()->ScrollRectToVisibleInParentFrame(std::move(rect_to_scroll), std::move(params));
}
void LocalFrameHostInterceptorForTesting::BubbleLogicalScrollInParentFrame(
    ::blink::mojom::blink::ScrollDirection direction, ::ui::ScrollGranularity granularity)
{
    GetForwardingInterface()->BubbleLogicalScrollInParentFrame(std::move(direction), std::move(granularity));
}
void LocalFrameHostInterceptorForTesting::StartLoadingForAsyncNavigationApiCommit()
{
    GetForwardingInterface()->StartLoadingForAsyncNavigationApiCommit();
}
void LocalFrameHostInterceptorForTesting::DidBlockNavigation(
    const ::blink::KURL& blocked_url, const ::blink::KURL& initiator_url, ::blink::mojom::blink::NavigationBlockedReason reason)
{
    GetForwardingInterface()->DidBlockNavigation(std::move(blocked_url), std::move(initiator_url), std::move(reason));
}
void LocalFrameHostInterceptorForTesting::DidChangeLoadProgress(double load_progress)
{
    GetForwardingInterface()->DidChangeLoadProgress(std::move(load_progress));
}
void LocalFrameHostInterceptorForTesting::DidFinishLoad(const ::blink::KURL& validated_url)
{
    GetForwardingInterface()->DidFinishLoad(std::move(validated_url));
}
void LocalFrameHostInterceptorForTesting::DispatchLoad()
{
    GetForwardingInterface()->DispatchLoad();
}
void LocalFrameHostInterceptorForTesting::GoToEntryAtOffset(
    int32_t offset, bool has_user_gesture, std::optional<::blink::scheduler::TaskAttributionId> soft_navigation_heuristics_task_id)
{
    GetForwardingInterface()->GoToEntryAtOffset(std::move(offset), std::move(has_user_gesture), std::move(soft_navigation_heuristics_task_id));
}
void LocalFrameHostInterceptorForTesting::NavigateToNavigationApiKey(
    const WTF::String& key, bool has_user_gesture, std::optional<::blink::scheduler::TaskAttributionId> soft_navigation_heuristics_task_id)
{
    GetForwardingInterface()->NavigateToNavigationApiKey(std::move(key), std::move(has_user_gesture), std::move(soft_navigation_heuristics_task_id));
}
void LocalFrameHostInterceptorForTesting::NavigateEventHandlerPresenceChanged(bool present)
{
    GetForwardingInterface()->NavigateEventHandlerPresenceChanged(std::move(present));
}
void LocalFrameHostInterceptorForTesting::UpdateTitle(const ::WTF::String& title, ::base::i18n::TextDirection title_direction)
{
    GetForwardingInterface()->UpdateTitle(std::move(title), std::move(title_direction));
}
void LocalFrameHostInterceptorForTesting::UpdateAppTitle(const ::WTF::String& app_title)
{
    GetForwardingInterface()->UpdateAppTitle(std::move(app_title));
}
void LocalFrameHostInterceptorForTesting::UpdateUserActivationState(
    ::blink::mojom::blink::UserActivationUpdateType update_type, ::blink::mojom::blink::UserActivationNotificationType notification_type)
{
    GetForwardingInterface()->UpdateUserActivationState(std::move(update_type), std::move(notification_type));
}
void LocalFrameHostInterceptorForTesting::DidConsumeHistoryUserActivation()
{
    GetForwardingInterface()->DidConsumeHistoryUserActivation();
}
void LocalFrameHostInterceptorForTesting::HandleAccessibilityFindInPageResult(FindInPageResultAXParamsPtr params)
{
    GetForwardingInterface()->HandleAccessibilityFindInPageResult(std::move(params));
}
void LocalFrameHostInterceptorForTesting::HandleAccessibilityFindInPageTermination()
{
    GetForwardingInterface()->HandleAccessibilityFindInPageTermination();
}
void LocalFrameHostInterceptorForTesting::DocumentOnLoadCompleted()
{
    GetForwardingInterface()->DocumentOnLoadCompleted();
}
void LocalFrameHostInterceptorForTesting::ForwardResourceTimingToParent(::blink::mojom::blink::ResourceTimingInfoPtr timing)
{
    GetForwardingInterface()->ForwardResourceTimingToParent(std::move(timing));
}
void LocalFrameHostInterceptorForTesting::DidDispatchDOMContentLoadedEvent()
{
    GetForwardingInterface()->DidDispatchDOMContentLoadedEvent();
}
void LocalFrameHostInterceptorForTesting::RunModalAlertDialog(
    const ::WTF::String& alert_message, bool disable_third_party_subframe_suppresion, RunModalAlertDialogCallback callback)
{
    GetForwardingInterface()->RunModalAlertDialog(std::move(alert_message), std::move(disable_third_party_subframe_suppresion), std::move(callback));
}
void LocalFrameHostInterceptorForTesting::RunModalConfirmDialog(
    const ::WTF::String& alert_message, bool disable_third_party_subframe_suppresion, RunModalConfirmDialogCallback callback)
{
    GetForwardingInterface()->RunModalConfirmDialog(std::move(alert_message), std::move(disable_third_party_subframe_suppresion), std::move(callback));
}
void LocalFrameHostInterceptorForTesting::RunModalPromptDialog(
    const ::WTF::String& alert_message, const ::WTF::String& default_value, bool disable_third_party_subframe_suppresion, RunModalPromptDialogCallback callback)
{
    GetForwardingInterface()->RunModalPromptDialog(
        std::move(alert_message), std::move(default_value), std::move(disable_third_party_subframe_suppresion), std::move(callback));
}
void LocalFrameHostInterceptorForTesting::RunBeforeUnloadConfirm(bool is_reload, RunBeforeUnloadConfirmCallback callback)
{
    GetForwardingInterface()->RunBeforeUnloadConfirm(std::move(is_reload), std::move(callback));
}
void LocalFrameHostInterceptorForTesting::UpdateFaviconURL(WTF::Vector<::blink::mojom::blink::FaviconURLPtr> favicon_urls)
{
    GetForwardingInterface()->UpdateFaviconURL(std::move(favicon_urls));
}
void LocalFrameHostInterceptorForTesting::DownloadURL(DownloadURLParamsPtr params)
{
    GetForwardingInterface()->DownloadURL(std::move(params));
}
void LocalFrameHostInterceptorForTesting::FocusedElementChanged(
    bool is_editable_element, bool is_richly_editable_element, const ::gfx::Rect& bounds_in_frame_widget, ::blink::mojom::blink::FocusType focus_type)
{
    GetForwardingInterface()->FocusedElementChanged(
        std::move(is_editable_element), std::move(is_richly_editable_element), std::move(bounds_in_frame_widget), std::move(focus_type));
}
void LocalFrameHostInterceptorForTesting::TextSelectionChanged(const ::WTF::String& text, uint32_t offset, const ::gfx::Range& range)
{
    GetForwardingInterface()->TextSelectionChanged(std::move(text), std::move(offset), std::move(range));
}
void LocalFrameHostInterceptorForTesting::ShowPopupMenu(::mojo::PendingRemote<::blink::mojom::blink::PopupMenuClient> popup_client, const ::gfx::Rect& bounds,
    int32_t item_height, double font_size, int32_t selected_item, WTF::Vector<::blink::mojom::blink::MenuItemPtr> menu_items, bool right_aligned,
    bool allow_multiple_selection)
{
    GetForwardingInterface()->ShowPopupMenu(std::move(popup_client), std::move(bounds), std::move(item_height), std::move(font_size), std::move(selected_item),
        std::move(menu_items), std::move(right_aligned), std::move(allow_multiple_selection));
}
void LocalFrameHostInterceptorForTesting::CreateNewPopupWidget(::mojo::PendingAssociatedReceiver<::blink::mojom::blink::PopupWidgetHost> popup_host,
    ::mojo::PendingAssociatedReceiver<::blink::mojom::blink::WidgetHost> blink_widget_host,
    ::mojo::PendingAssociatedRemote<::blink::mojom::blink::Widget> blink_widget)
{
    GetForwardingInterface()->CreateNewPopupWidget(std::move(popup_host), std::move(blink_widget_host), std::move(blink_widget));
}
void LocalFrameHostInterceptorForTesting::ShowContextMenu(
    ::mojo::PendingAssociatedRemote<::blink::mojom::blink::ContextMenuClient> client, const ::blink::UntrustworthyContextMenuParams& params)
{
    GetForwardingInterface()->ShowContextMenu(std::move(client), std::move(params));
}
void LocalFrameHostInterceptorForTesting::DidLoadResourceFromMemoryCache(const ::blink::KURL& url, const WTF::String& http_method, const WTF::String& mime_type,
    ::network::mojom::blink::RequestDestination request_destination, bool include_credentials)
{
    GetForwardingInterface()->DidLoadResourceFromMemoryCache(
        std::move(url), std::move(http_method), std::move(mime_type), std::move(request_destination), std::move(include_credentials));
}
void LocalFrameHostInterceptorForTesting::DidChangeFrameOwnerProperties(
    const ::blink::FrameToken& child_frame_token, ::blink::mojom::blink::FrameOwnerPropertiesPtr frame_owner_properties)
{
    GetForwardingInterface()->DidChangeFrameOwnerProperties(std::move(child_frame_token), std::move(frame_owner_properties));
}
void LocalFrameHostInterceptorForTesting::DidChangeOpener(const std::optional<::blink::LocalFrameToken>& opener_frame)
{
    GetForwardingInterface()->DidChangeOpener(std::move(opener_frame));
}
void LocalFrameHostInterceptorForTesting::DidChangeFramePolicy(const ::blink::FrameToken& child_frame_token, const ::blink::FramePolicy& frame_policy)
{
    GetForwardingInterface()->DidChangeFramePolicy(std::move(child_frame_token), std::move(frame_policy));
}
void LocalFrameHostInterceptorForTesting::DidChangeIframeAttributes(const ::blink::FrameToken& child_frame_token, IframeAttributesPtr attributes)
{
    GetForwardingInterface()->DidChangeIframeAttributes(std::move(child_frame_token), std::move(attributes));
}
void LocalFrameHostInterceptorForTesting::CapturePaintPreviewOfSubframe(const ::gfx::Rect& clip_rect, const ::base::UnguessableToken& guid)
{
    GetForwardingInterface()->CapturePaintPreviewOfSubframe(std::move(clip_rect), std::move(guid));
}
void LocalFrameHostInterceptorForTesting::SetCloseListener(::mojo::PendingRemote<::blink::mojom::blink::CloseListener> listener)
{
    GetForwardingInterface()->SetCloseListener(std::move(listener));
}
void LocalFrameHostInterceptorForTesting::Detach()
{
    GetForwardingInterface()->Detach();
}
void LocalFrameHostInterceptorForTesting::GetKeepAliveHandleFactory(::mojo::PendingReceiver<::blink::mojom::blink::KeepAliveHandleFactory> factory)
{
    GetForwardingInterface()->GetKeepAliveHandleFactory(std::move(factory));
}
void LocalFrameHostInterceptorForTesting::DidAddMessageToConsole(::blink::mojom::blink::ConsoleMessageLevel log_level, const ::WTF::String& msg,
    uint32_t line_number, const ::WTF::String& source_id, const ::WTF::String& untrusted_stack_trace)
{
    GetForwardingInterface()->DidAddMessageToConsole(
        std::move(log_level), std::move(msg), std::move(line_number), std::move(source_id), std::move(untrusted_stack_trace));
}
void LocalFrameHostInterceptorForTesting::FrameSizeChanged(const ::gfx::Size& size)
{
    GetForwardingInterface()->FrameSizeChanged(std::move(size));
}
void LocalFrameHostInterceptorForTesting::DidInferColorScheme(::blink::mojom::blink::PreferredColorScheme color_scheme)
{
    GetForwardingInterface()->DidInferColorScheme(std::move(color_scheme));
}
void LocalFrameHostInterceptorForTesting::DidChangeSrcDoc(const ::blink::FrameToken& child_frame_token, const WTF::String& srcdoc_value)
{
    GetForwardingInterface()->DidChangeSrcDoc(std::move(child_frame_token), std::move(srcdoc_value));
}
void LocalFrameHostInterceptorForTesting::ReceivedDelegatedCapability(::blink::mojom::blink::DelegatedCapability delegated_capability)
{
    GetForwardingInterface()->ReceivedDelegatedCapability(std::move(delegated_capability));
}
void LocalFrameHostInterceptorForTesting::SendFencedFrameReportingBeacon(const WTF::String& event_data, const WTF::String& event_type,
    const WTF::Vector<::blink::FencedFrame::ReportingDestination>& destinations, bool cross_origin_exposed)
{
    GetForwardingInterface()->SendFencedFrameReportingBeacon(
        std::move(event_data), std::move(event_type), std::move(destinations), std::move(cross_origin_exposed));
}
void LocalFrameHostInterceptorForTesting::SendFencedFrameReportingBeaconToCustomURL(const ::blink::KURL& destination_url, bool cross_origin_exposed)
{
    GetForwardingInterface()->SendFencedFrameReportingBeaconToCustomURL(std::move(destination_url), std::move(cross_origin_exposed));
}
void LocalFrameHostInterceptorForTesting::DisableUntrustedNetworkInFencedFrame(DisableUntrustedNetworkInFencedFrameCallback callback)
{
    GetForwardingInterface()->DisableUntrustedNetworkInFencedFrame(std::move(callback));
}
void LocalFrameHostInterceptorForTesting::ExemptUrlFromNetworkRevocationForTesting(
    const ::blink::KURL& exempted_url, ExemptUrlFromNetworkRevocationForTestingCallback callback)
{
    GetForwardingInterface()->ExemptUrlFromNetworkRevocationForTesting(std::move(exempted_url), std::move(callback));
}
void LocalFrameHostInterceptorForTesting::SendLegacyTechEvent(const WTF::String& type, LegacyTechEventCodeLocationPtr code_location)
{
    GetForwardingInterface()->SendLegacyTechEvent(std::move(type), std::move(code_location));
}
void LocalFrameHostInterceptorForTesting::SetFencedFrameAutomaticBeaconReportEventData(::blink::mojom::blink::AutomaticBeaconType event_type,
    const WTF::String& event_data, const WTF::Vector<::blink::FencedFrame::ReportingDestination>& destinations, bool once, bool cross_origin_exposed)
{
    GetForwardingInterface()->SetFencedFrameAutomaticBeaconReportEventData(
        std::move(event_type), std::move(event_data), std::move(destinations), std::move(once), std::move(cross_origin_exposed));
}
void LocalFrameHostInterceptorForTesting::SendPrivateAggregationRequestsForFencedFrameEvent(const WTF::String& event_type)
{
    GetForwardingInterface()->SendPrivateAggregationRequestsForFencedFrameEvent(std::move(event_type));
}
void LocalFrameHostInterceptorForTesting::CreateFencedFrame(::mojo::PendingAssociatedReceiver<::blink::mojom::blink::FencedFrameOwnerHost> fenced_frame,
    ::blink::mojom::blink::RemoteFrameInterfacesFromRendererPtr remote_frame_interfaces, const ::blink::RemoteFrameToken& frame_token,
    const ::base::UnguessableToken& devtools_frame_token)
{
    GetForwardingInterface()->CreateFencedFrame(
        std::move(fenced_frame), std::move(remote_frame_interfaces), std::move(frame_token), std::move(devtools_frame_token));
}
void LocalFrameHostInterceptorForTesting::ForwardFencedFrameEventAndUserActivationToEmbedder(const WTF::String& event_type)
{
    GetForwardingInterface()->ForwardFencedFrameEventAndUserActivationToEmbedder(std::move(event_type));
}
void LocalFrameHostInterceptorForTesting::OnViewTransitionOptInChanged(ViewTransitionSameOriginOptIn view_transition_opt_in)
{
    GetForwardingInterface()->OnViewTransitionOptInChanged(std::move(view_transition_opt_in));
}
void LocalFrameHostInterceptorForTesting::StartDragging(const ::blink::WebDragData& drag_data, ::blink::DragOperationsMask operations_allowed,
    const ::SkBitmap& image, const ::gfx::Vector2d& cursor_offset_in_dip, const ::gfx::Rect& drag_obj_rect_in_dip,
    ::blink::mojom::blink::DragEventSourceInfoPtr event_info)
{
    GetForwardingInterface()->StartDragging(std::move(drag_data), std::move(operations_allowed), std::move(image), std::move(cursor_offset_in_dip),
        std::move(drag_obj_rect_in_dip), std::move(event_info));
}
void LocalFrameHostInterceptorForTesting::IssueKeepAliveHandle(::mojo::PendingReceiver<::blink::mojom::blink::NavigationStateKeepAliveHandle> receiver)
{
    GetForwardingInterface()->IssueKeepAliveHandle(std::move(receiver));
}
void LocalFrameHostInterceptorForTesting::NotifyStorageAccessed(StorageTypeAccessed storageType, bool blocked)
{
    GetForwardingInterface()->NotifyStorageAccessed(std::move(storageType), std::move(blocked));
}
void LocalFrameHostInterceptorForTesting::RecordWindowProxyUsageMetrics(const ::blink::FrameToken& target_frame_token, WindowProxyAccessType access_type)
{
    GetForwardingInterface()->RecordWindowProxyUsageMetrics(std::move(target_frame_token), std::move(access_type));
}
void LocalFrameHostInterceptorForTesting::NotifyDocumentInteractive()
{
    GetForwardingInterface()->NotifyDocumentInteractive();
}
LocalFrameHostAsyncWaiter::LocalFrameHostAsyncWaiter(LocalFrameHost* proxy)
    : proxy_(proxy)
{
}

LocalFrameHostAsyncWaiter::~LocalFrameHostAsyncWaiter() = default;

void LocalFrameHostAsyncWaiter::EnterFullscreen(::blink::mojom::blink::FullscreenOptionsPtr options, bool* out_granted)
{
    base::RunLoop loop;
    proxy_->EnterFullscreen(std::move(options),
        base::BindOnce(
            [](base::RunLoop* loop, bool* out_granted, bool granted) {
                *out_granted = std::move(granted);
                loop->Quit();
            },
            &loop, out_granted));
    loop.Run();
}

bool LocalFrameHostAsyncWaiter::EnterFullscreen(::blink::mojom::blink::FullscreenOptionsPtr options)
{
    bool async_wait_result;
    EnterFullscreen(std::move(options), &async_wait_result);
    return async_wait_result;
}

void LocalFrameHostAsyncWaiter::RunModalAlertDialog(const ::WTF::String& alert_message, bool disable_third_party_subframe_suppresion)
{
    base::RunLoop loop;
    proxy_->RunModalAlertDialog(
        std::move(alert_message), std::move(disable_third_party_subframe_suppresion), base::BindOnce([](base::RunLoop* loop) { loop->Quit(); }, &loop));
    loop.Run();
}

void LocalFrameHostAsyncWaiter::RunModalConfirmDialog(const ::WTF::String& alert_message, bool disable_third_party_subframe_suppresion, bool* out_success)
{
    base::RunLoop loop;
    proxy_->RunModalConfirmDialog(std::move(alert_message), std::move(disable_third_party_subframe_suppresion),
        base::BindOnce(
            [](base::RunLoop* loop, bool* out_success, bool success) {
                *out_success = std::move(success);
                loop->Quit();
            },
            &loop, out_success));
    loop.Run();
}

bool LocalFrameHostAsyncWaiter::RunModalConfirmDialog(const ::WTF::String& alert_message, bool disable_third_party_subframe_suppresion)
{
    bool async_wait_result;
    RunModalConfirmDialog(std::move(alert_message), std::move(disable_third_party_subframe_suppresion), &async_wait_result);
    return async_wait_result;
}

void LocalFrameHostAsyncWaiter::RunModalPromptDialog(const ::WTF::String& alert_message, const ::WTF::String& default_value,
    bool disable_third_party_subframe_suppresion, bool* out_success, ::WTF::String* out_result)
{
    base::RunLoop loop;
    proxy_->RunModalPromptDialog(std::move(alert_message), std::move(default_value), std::move(disable_third_party_subframe_suppresion),
        base::BindOnce(
            [](base::RunLoop* loop, bool* out_success, ::WTF::String* out_result, bool success, const ::WTF::String& result) {
                *out_success = std::move(success);
                *out_result = std::move(result);
                loop->Quit();
            },
            &loop, out_success, out_result));
    loop.Run();
}

void LocalFrameHostAsyncWaiter::RunBeforeUnloadConfirm(bool is_reload, bool* out_success)
{
    base::RunLoop loop;
    proxy_->RunBeforeUnloadConfirm(std::move(is_reload),
        base::BindOnce(
            [](base::RunLoop* loop, bool* out_success, bool success) {
                *out_success = std::move(success);
                loop->Quit();
            },
            &loop, out_success));
    loop.Run();
}

bool LocalFrameHostAsyncWaiter::RunBeforeUnloadConfirm(bool is_reload)
{
    bool async_wait_result;
    RunBeforeUnloadConfirm(std::move(is_reload), &async_wait_result);
    return async_wait_result;
}

void LocalFrameHostAsyncWaiter::DisableUntrustedNetworkInFencedFrame()
{
    base::RunLoop loop;
    proxy_->DisableUntrustedNetworkInFencedFrame(base::BindOnce([](base::RunLoop* loop) { loop->Quit(); }, &loop));
    loop.Run();
}

void LocalFrameHostAsyncWaiter::ExemptUrlFromNetworkRevocationForTesting(const ::blink::KURL& exempted_url)
{
    base::RunLoop loop;
    proxy_->ExemptUrlFromNetworkRevocationForTesting(std::move(exempted_url), base::BindOnce([](base::RunLoop* loop) { loop->Quit(); }, &loop));
    loop.Run();
}

void NonAssociatedLocalFrameHostInterceptorForTesting::MaybeStartOutermostMainFrameNavigation(const WTF::Vector<::blink::KURL>& urls)
{
    GetForwardingInterface()->MaybeStartOutermostMainFrameNavigation(std::move(urls));
}
NonAssociatedLocalFrameHostAsyncWaiter::NonAssociatedLocalFrameHostAsyncWaiter(NonAssociatedLocalFrameHost* proxy)
    : proxy_(proxy)
{
}

NonAssociatedLocalFrameHostAsyncWaiter::~NonAssociatedLocalFrameHostAsyncWaiter() = default;

void LocalFrameInterceptorForTesting::GetTextSurroundingSelection(uint32_t max_length, GetTextSurroundingSelectionCallback callback)
{
    GetForwardingInterface()->GetTextSurroundingSelection(std::move(max_length), std::move(callback));
}
void LocalFrameInterceptorForTesting::SendInterventionReport(const WTF::String& id, const WTF::String& message)
{
    GetForwardingInterface()->SendInterventionReport(std::move(id), std::move(message));
}
void LocalFrameInterceptorForTesting::SetFrameOwnerProperties(::blink::mojom::blink::FrameOwnerPropertiesPtr properties)
{
    GetForwardingInterface()->SetFrameOwnerProperties(std::move(properties));
}
void LocalFrameInterceptorForTesting::NotifyUserActivation(::blink::mojom::blink::UserActivationNotificationType notification_type)
{
    GetForwardingInterface()->NotifyUserActivation(std::move(notification_type));
}
void LocalFrameInterceptorForTesting::NotifyVirtualKeyboardOverlayRect(const ::gfx::Rect& keyboard_rect)
{
    GetForwardingInterface()->NotifyVirtualKeyboardOverlayRect(std::move(keyboard_rect));
}
void LocalFrameInterceptorForTesting::AddMessageToConsole(::blink::mojom::blink::ConsoleMessageLevel level, const WTF::String& message, bool discard_duplicates)
{
    GetForwardingInterface()->AddMessageToConsole(std::move(level), std::move(message), std::move(discard_duplicates));
}
void LocalFrameInterceptorForTesting::SwapInImmediately()
{
    GetForwardingInterface()->SwapInImmediately();
}
void LocalFrameInterceptorForTesting::CheckCompleted()
{
    GetForwardingInterface()->CheckCompleted();
}
void LocalFrameInterceptorForTesting::StopLoading()
{
    GetForwardingInterface()->StopLoading();
}
void LocalFrameInterceptorForTesting::Collapse(bool collapsed)
{
    GetForwardingInterface()->Collapse(std::move(collapsed));
}
void LocalFrameInterceptorForTesting::EnableViewSourceMode()
{
    GetForwardingInterface()->EnableViewSourceMode();
}
void LocalFrameInterceptorForTesting::Focus()
{
    GetForwardingInterface()->Focus();
}
void LocalFrameInterceptorForTesting::ClearFocusedElement()
{
    GetForwardingInterface()->ClearFocusedElement();
}
void LocalFrameInterceptorForTesting::CopyImageAt(const ::gfx::Point& window_point)
{
    GetForwardingInterface()->CopyImageAt(std::move(window_point));
}
void LocalFrameInterceptorForTesting::SaveImageAt(const ::gfx::Point& window_point)
{
    GetForwardingInterface()->SaveImageAt(std::move(window_point));
}
void LocalFrameInterceptorForTesting::ReportBlinkFeatureUsage(const WTF::Vector<::blink::mojom::blink::WebFeature>& features)
{
    GetForwardingInterface()->ReportBlinkFeatureUsage(std::move(features));
}
void LocalFrameInterceptorForTesting::RenderFallbackContent()
{
    GetForwardingInterface()->RenderFallbackContent();
}
void LocalFrameInterceptorForTesting::BeforeUnload(bool is_reload, BeforeUnloadCallback callback)
{
    GetForwardingInterface()->BeforeUnload(std::move(is_reload), std::move(callback));
}
void LocalFrameInterceptorForTesting::MediaPlayerActionAt(const ::gfx::Point& location, ::blink::mojom::blink::MediaPlayerActionPtr action)
{
    GetForwardingInterface()->MediaPlayerActionAt(std::move(location), std::move(action));
}
void LocalFrameInterceptorForTesting::RequestVideoFrameAtWithBoundsHint(
    const ::gfx::Point& location, const ::gfx::Size& max_size, int32_t max_area, RequestVideoFrameAtWithBoundsHintCallback callback)
{
    GetForwardingInterface()->RequestVideoFrameAtWithBoundsHint(std::move(location), std::move(max_size), std::move(max_area), std::move(callback));
}
void LocalFrameInterceptorForTesting::PluginActionAt(const ::gfx::Point& location, PluginActionType action)
{
    GetForwardingInterface()->PluginActionAt(std::move(location), std::move(action));
}
void LocalFrameInterceptorForTesting::AdvanceFocusInFrame(
    ::blink::mojom::blink::FocusType focus_type, const std::optional<::blink::RemoteFrameToken>& source_frame_token)
{
    GetForwardingInterface()->AdvanceFocusInFrame(std::move(focus_type), std::move(source_frame_token));
}
void LocalFrameInterceptorForTesting::AdvanceFocusForIME(::blink::mojom::blink::FocusType focus_type)
{
    GetForwardingInterface()->AdvanceFocusForIME(std::move(focus_type));
}
void LocalFrameInterceptorForTesting::ReportContentSecurityPolicyViolation(::network::mojom::blink::CSPViolationPtr violation)
{
    GetForwardingInterface()->ReportContentSecurityPolicyViolation(std::move(violation));
}
void LocalFrameInterceptorForTesting::DidUpdateFramePolicy(const ::blink::FramePolicy& frame_policy)
{
    GetForwardingInterface()->DidUpdateFramePolicy(std::move(frame_policy));
}
void LocalFrameInterceptorForTesting::OnFrameVisibilityChanged(::blink::mojom::blink::FrameVisibility visibility)
{
    GetForwardingInterface()->OnFrameVisibilityChanged(std::move(visibility));
}
void LocalFrameInterceptorForTesting::PostMessageEvent(const std::optional<::blink::RemoteFrameToken>& source_frame_token, const ::WTF::String& source_origin,
    const ::WTF::String& target_origin, ::blink::BlinkTransferableMessage message)
{
    GetForwardingInterface()->PostMessageEvent(std::move(source_frame_token), std::move(source_origin), std::move(target_origin), std::move(message));
}
void LocalFrameInterceptorForTesting::JavaScriptMethodExecuteRequest(const ::WTF::String& object_name, const ::WTF::String& method_name,
    ::base::Value::List arguments, bool wants_result, JavaScriptMethodExecuteRequestCallback callback)
{
    GetForwardingInterface()->JavaScriptMethodExecuteRequest(
        std::move(object_name), std::move(method_name), std::move(arguments), std::move(wants_result), std::move(callback));
}
void LocalFrameInterceptorForTesting::JavaScriptExecuteRequest(const ::WTF::String& javascript, bool wants_result, JavaScriptExecuteRequestCallback callback)
{
    GetForwardingInterface()->JavaScriptExecuteRequest(std::move(javascript), std::move(wants_result), std::move(callback));
}
void LocalFrameInterceptorForTesting::JavaScriptExecuteRequestForTests(const ::WTF::String& javascript, bool has_user_gesture, bool resolve_promises,
    bool honor_js_content_settings, int32_t world_id, JavaScriptExecuteRequestForTestsCallback callback)
{
    GetForwardingInterface()->JavaScriptExecuteRequestForTests(std::move(javascript), std::move(has_user_gesture), std::move(resolve_promises),
        std::move(honor_js_content_settings), std::move(world_id), std::move(callback));
}
void LocalFrameInterceptorForTesting::JavaScriptExecuteRequestInIsolatedWorld(
    const ::WTF::String& javascript, bool wants_result, int32_t world_id, JavaScriptExecuteRequestInIsolatedWorldCallback callback)
{
    GetForwardingInterface()->JavaScriptExecuteRequestInIsolatedWorld(std::move(javascript), std::move(wants_result), std::move(world_id), std::move(callback));
}
void LocalFrameInterceptorForTesting::BindReportingObserver(::mojo::PendingReceiver<::blink::mojom::blink::ReportingObserver> receiver)
{
    GetForwardingInterface()->BindReportingObserver(std::move(receiver));
}
void LocalFrameInterceptorForTesting::UpdateOpener(const std::optional<::blink::FrameToken>& opener_frame_token)
{
    GetForwardingInterface()->UpdateOpener(std::move(opener_frame_token));
}
void LocalFrameInterceptorForTesting::GetSavableResourceLinks(GetSavableResourceLinksCallback callback)
{
    GetForwardingInterface()->GetSavableResourceLinks(std::move(callback));
}
void LocalFrameInterceptorForTesting::MixedContentFound(const ::blink::KURL& main_resource_url, const ::blink::KURL& mixed_content_url,
    ::blink::mojom::blink::RequestContextType request_context, bool was_allowed, const ::blink::KURL& url_before_redirects, bool had_redirect,
    ::network::mojom::blink::SourceLocationPtr source_location)
{
    GetForwardingInterface()->MixedContentFound(std::move(main_resource_url), std::move(mixed_content_url), std::move(request_context), std::move(was_allowed),
        std::move(url_before_redirects), std::move(had_redirect), std::move(source_location));
}
void LocalFrameInterceptorForTesting::BindDevToolsAgent(::mojo::PendingAssociatedRemote<::blink::mojom::blink::DevToolsAgentHost> agent_host,
    ::mojo::PendingAssociatedReceiver<::blink::mojom::blink::DevToolsAgent> agent)
{
    GetForwardingInterface()->BindDevToolsAgent(std::move(agent_host), std::move(agent));
}
void LocalFrameInterceptorForTesting::HandleRendererDebugURL(const ::blink::KURL& url)
{
    GetForwardingInterface()->HandleRendererDebugURL(std::move(url));
}
void LocalFrameInterceptorForTesting::GetCanonicalUrlForSharing(GetCanonicalUrlForSharingCallback callback)
{
    GetForwardingInterface()->GetCanonicalUrlForSharing(std::move(callback));
}
void LocalFrameInterceptorForTesting::GetOpenGraphMetadata(GetOpenGraphMetadataCallback callback)
{
    GetForwardingInterface()->GetOpenGraphMetadata(std::move(callback));
}
void LocalFrameInterceptorForTesting::SetNavigationApiHistoryEntriesForRestore(
    ::blink::mojom::blink::NavigationApiHistoryEntryArraysPtr entry_arrays, NavigationApiEntryRestoreReason restore_reason)
{
    GetForwardingInterface()->SetNavigationApiHistoryEntriesForRestore(std::move(entry_arrays), std::move(restore_reason));
}
void LocalFrameInterceptorForTesting::UpdatePrerenderURL(const ::blink::KURL& matched_url, UpdatePrerenderURLCallback callback)
{
    GetForwardingInterface()->UpdatePrerenderURL(std::move(matched_url), std::move(callback));
}
void LocalFrameInterceptorForTesting::NotifyNavigationApiOfDisposedEntries(const WTF::Vector<WTF::String>& keys)
{
    GetForwardingInterface()->NotifyNavigationApiOfDisposedEntries(std::move(keys));
}
void LocalFrameInterceptorForTesting::TraverseCancelled(const WTF::String& navigation_api_key, TraverseCancelledReason reason)
{
    GetForwardingInterface()->TraverseCancelled(std::move(navigation_api_key), std::move(reason));
}
void LocalFrameInterceptorForTesting::DispatchNavigateEventForCrossDocumentTraversal(
    const ::blink::KURL& url, const std::string& page_state, bool is_browser_initiated)
{
    GetForwardingInterface()->DispatchNavigateEventForCrossDocumentTraversal(std::move(url), std::move(page_state), std::move(is_browser_initiated));
}
void LocalFrameInterceptorForTesting::SnapshotDocumentForViewTransition(const ::blink::ViewTransitionToken& transition_token,
    ::blink::mojom::blink::PageSwapEventParamsPtr page_swap_event_params, SnapshotDocumentForViewTransitionCallback callback)
{
    GetForwardingInterface()->SnapshotDocumentForViewTransition(std::move(transition_token), std::move(page_swap_event_params), std::move(callback));
}
void LocalFrameInterceptorForTesting::NotifyViewTransitionAbortedToOldDocument()
{
    GetForwardingInterface()->NotifyViewTransitionAbortedToOldDocument();
}
void LocalFrameInterceptorForTesting::DispatchPageSwap(::blink::mojom::blink::PageSwapEventParamsPtr page_swap_event_params)
{
    GetForwardingInterface()->DispatchPageSwap(std::move(page_swap_event_params));
}
void LocalFrameInterceptorForTesting::AddResourceTimingEntryForFailedSubframeNavigation(const ::blink::FrameToken& subframe_token,
    const ::blink::KURL& initial_url, ::base::TimeTicks start_time, ::base::TimeTicks redirect_time, ::base::TimeTicks request_start,
    ::base::TimeTicks response_start, uint32_t response_code, const WTF::String& mime_type, ::network::mojom::blink::LoadTimingInfoPtr load_timing_info,
    ::net::HttpConnectionInfo connection_info, const WTF::String& alpn_negotiated_protocol, bool is_secure_transport, bool is_validated,
    const WTF::String& normalized_server_timing, const ::network::URLLoaderCompletionStatus& completion_status)
{
    GetForwardingInterface()->AddResourceTimingEntryForFailedSubframeNavigation(std::move(subframe_token), std::move(initial_url), std::move(start_time),
        std::move(redirect_time), std::move(request_start), std::move(response_start), std::move(response_code), std::move(mime_type),
        std::move(load_timing_info), std::move(connection_info), std::move(alpn_negotiated_protocol), std::move(is_secure_transport), std::move(is_validated),
        std::move(normalized_server_timing), std::move(completion_status));
}
LocalFrameAsyncWaiter::LocalFrameAsyncWaiter(LocalFrame* proxy)
    : proxy_(proxy)
{
}

LocalFrameAsyncWaiter::~LocalFrameAsyncWaiter() = default;

void LocalFrameAsyncWaiter::GetTextSurroundingSelection(uint32_t max_length, ::WTF::String* out_content, uint32_t* out_start_offset, uint32_t* out_end_offset)
{
    base::RunLoop loop;
    proxy_->GetTextSurroundingSelection(std::move(max_length),
        base::BindOnce(
            [](base::RunLoop* loop, ::WTF::String* out_content, uint32_t* out_start_offset, uint32_t* out_end_offset, const ::WTF::String& content,
                uint32_t start_offset, uint32_t end_offset) {
                *out_content = std::move(content);
                *out_start_offset = std::move(start_offset);
                *out_end_offset = std::move(end_offset);
                loop->Quit();
            },
            &loop, out_content, out_start_offset, out_end_offset));
    loop.Run();
}

void LocalFrameAsyncWaiter::BeforeUnload(
    bool is_reload, bool* out_proceed, ::base::TimeTicks* out_before_unload_start_time, ::base::TimeTicks* out_before_unload_end_time)
{
    base::RunLoop loop;
    proxy_->BeforeUnload(std::move(is_reload),
        base::BindOnce(
            [](base::RunLoop* loop, bool* out_proceed, ::base::TimeTicks* out_before_unload_start_time, ::base::TimeTicks* out_before_unload_end_time,
                bool proceed, ::base::TimeTicks before_unload_start_time, ::base::TimeTicks before_unload_end_time) {
                *out_proceed = std::move(proceed);
                *out_before_unload_start_time = std::move(before_unload_start_time);
                *out_before_unload_end_time = std::move(before_unload_end_time);
                loop->Quit();
            },
            &loop, out_proceed, out_before_unload_start_time, out_before_unload_end_time));
    loop.Run();
}

void LocalFrameAsyncWaiter::RequestVideoFrameAtWithBoundsHint(
    const ::gfx::Point& location, const ::gfx::Size& max_size, int32_t max_area, ::SkBitmap* out_bitmap, ::gfx::Rect* out_bounds)
{
    base::RunLoop loop;
    proxy_->RequestVideoFrameAtWithBoundsHint(std::move(location), std::move(max_size), std::move(max_area),
        base::BindOnce(
            [](base::RunLoop* loop, ::SkBitmap* out_bitmap, ::gfx::Rect* out_bounds, const ::SkBitmap& bitmap, const ::gfx::Rect& bounds) {
                *out_bitmap = std::move(bitmap);
                *out_bounds = std::move(bounds);
                loop->Quit();
            },
            &loop, out_bitmap, out_bounds));
    loop.Run();
}

void LocalFrameAsyncWaiter::JavaScriptMethodExecuteRequest(
    const ::WTF::String& object_name, const ::WTF::String& method_name, ::base::Value::List arguments, bool wants_result, ::base::Value* out_result)
{
    base::RunLoop loop;
    proxy_->JavaScriptMethodExecuteRequest(std::move(object_name), std::move(method_name), std::move(arguments), std::move(wants_result),
        base::BindOnce(
            [](base::RunLoop* loop, ::base::Value* out_result, ::base::Value result) {
                *out_result = std::move(result);
                loop->Quit();
            },
            &loop, out_result));
    loop.Run();
}

::base::Value LocalFrameAsyncWaiter::JavaScriptMethodExecuteRequest(
    const ::WTF::String& object_name, const ::WTF::String& method_name, ::base::Value::List arguments, bool wants_result)
{
    ::base::Value async_wait_result;
    JavaScriptMethodExecuteRequest(std::move(object_name), std::move(method_name), std::move(arguments), std::move(wants_result), &async_wait_result);
    return async_wait_result;
}

void LocalFrameAsyncWaiter::JavaScriptExecuteRequest(const ::WTF::String& javascript, bool wants_result, ::base::Value* out_result)
{
    base::RunLoop loop;
    proxy_->JavaScriptExecuteRequest(std::move(javascript), std::move(wants_result),
        base::BindOnce(
            [](base::RunLoop* loop, ::base::Value* out_result, ::base::Value result) {
                *out_result = std::move(result);
                loop->Quit();
            },
            &loop, out_result));
    loop.Run();
}

::base::Value LocalFrameAsyncWaiter::JavaScriptExecuteRequest(const ::WTF::String& javascript, bool wants_result)
{
    ::base::Value async_wait_result;
    JavaScriptExecuteRequest(std::move(javascript), std::move(wants_result), &async_wait_result);
    return async_wait_result;
}

void LocalFrameAsyncWaiter::JavaScriptExecuteRequestForTests(const ::WTF::String& javascript, bool has_user_gesture, bool resolve_promises,
    bool honor_js_content_settings, int32_t world_id, JavaScriptExecutionResultType* out_result_type, ::base::Value* out_result)
{
    base::RunLoop loop;
    proxy_->JavaScriptExecuteRequestForTests(std::move(javascript), std::move(has_user_gesture), std::move(resolve_promises),
        std::move(honor_js_content_settings), std::move(world_id),
        base::BindOnce(
            [](base::RunLoop* loop, JavaScriptExecutionResultType* out_result_type, ::base::Value* out_result, JavaScriptExecutionResultType result_type,
                ::base::Value result) {
                *out_result_type = std::move(result_type);
                *out_result = std::move(result);
                loop->Quit();
            },
            &loop, out_result_type, out_result));
    loop.Run();
}

void LocalFrameAsyncWaiter::JavaScriptExecuteRequestInIsolatedWorld(
    const ::WTF::String& javascript, bool wants_result, int32_t world_id, ::base::Value* out_result)
{
    base::RunLoop loop;
    proxy_->JavaScriptExecuteRequestInIsolatedWorld(std::move(javascript), std::move(wants_result), std::move(world_id),
        base::BindOnce(
            [](base::RunLoop* loop, ::base::Value* out_result, ::base::Value result) {
                *out_result = std::move(result);
                loop->Quit();
            },
            &loop, out_result));
    loop.Run();
}

::base::Value LocalFrameAsyncWaiter::JavaScriptExecuteRequestInIsolatedWorld(const ::WTF::String& javascript, bool wants_result, int32_t world_id)
{
    ::base::Value async_wait_result;
    JavaScriptExecuteRequestInIsolatedWorld(std::move(javascript), std::move(wants_result), std::move(world_id), &async_wait_result);
    return async_wait_result;
}

void LocalFrameAsyncWaiter::GetSavableResourceLinks(GetSavableResourceLinksReplyPtr* out_reply)
{
    base::RunLoop loop;
    proxy_->GetSavableResourceLinks(base::BindOnce(
        [](base::RunLoop* loop, GetSavableResourceLinksReplyPtr* out_reply, GetSavableResourceLinksReplyPtr reply) {
            *out_reply = std::move(reply);
            loop->Quit();
        },
        &loop, out_reply));
    loop.Run();
}

GetSavableResourceLinksReplyPtr LocalFrameAsyncWaiter::GetSavableResourceLinks()
{
    GetSavableResourceLinksReplyPtr async_wait_result;
    GetSavableResourceLinks(&async_wait_result);
    return async_wait_result;
}

void LocalFrameAsyncWaiter::GetCanonicalUrlForSharing(std::optional<::blink::KURL>* out_canonical_url)
{
    base::RunLoop loop;
    proxy_->GetCanonicalUrlForSharing(base::BindOnce(
        [](base::RunLoop* loop, std::optional<::blink::KURL>* out_canonical_url, const std::optional<::blink::KURL>& canonical_url) {
            *out_canonical_url = std::move(canonical_url);
            loop->Quit();
        },
        &loop, out_canonical_url));
    loop.Run();
}

std::optional<::blink::KURL> LocalFrameAsyncWaiter::GetCanonicalUrlForSharing()
{
    std::optional<::blink::KURL> async_wait_result;
    GetCanonicalUrlForSharing(&async_wait_result);
    return async_wait_result;
}

void LocalFrameAsyncWaiter::GetOpenGraphMetadata(::blink::mojom::blink::OpenGraphMetadataPtr* out_metadata)
{
    base::RunLoop loop;
    proxy_->GetOpenGraphMetadata(base::BindOnce(
        [](base::RunLoop* loop, ::blink::mojom::blink::OpenGraphMetadataPtr* out_metadata, ::blink::mojom::blink::OpenGraphMetadataPtr metadata) {
            *out_metadata = std::move(metadata);
            loop->Quit();
        },
        &loop, out_metadata));
    loop.Run();
}

::blink::mojom::blink::OpenGraphMetadataPtr LocalFrameAsyncWaiter::GetOpenGraphMetadata()
{
    ::blink::mojom::blink::OpenGraphMetadataPtr async_wait_result;
    GetOpenGraphMetadata(&async_wait_result);
    return async_wait_result;
}

void LocalFrameAsyncWaiter::UpdatePrerenderURL(const ::blink::KURL& matched_url)
{
    base::RunLoop loop;
    proxy_->UpdatePrerenderURL(std::move(matched_url), base::BindOnce([](base::RunLoop* loop) { loop->Quit(); }, &loop));
    loop.Run();
}

void LocalFrameAsyncWaiter::SnapshotDocumentForViewTransition(const ::blink::ViewTransitionToken& transition_token,
    ::blink::mojom::blink::PageSwapEventParamsPtr page_swap_event_params, ::blink::ViewTransitionState* out_view_transition_state)
{
    base::RunLoop loop;
    proxy_->SnapshotDocumentForViewTransition(std::move(transition_token), std::move(page_swap_event_params),
        base::BindOnce(
            [](base::RunLoop* loop, ::blink::ViewTransitionState* out_view_transition_state, const ::blink::ViewTransitionState& view_transition_state) {
                *out_view_transition_state = std::move(view_transition_state);
                loop->Quit();
            },
            &loop, out_view_transition_state));
    loop.Run();
}

::blink::ViewTransitionState LocalFrameAsyncWaiter::SnapshotDocumentForViewTransition(
    const ::blink::ViewTransitionToken& transition_token, ::blink::mojom::blink::PageSwapEventParamsPtr page_swap_event_params)
{
    ::blink::ViewTransitionState async_wait_result;
    SnapshotDocumentForViewTransition(std::move(transition_token), std::move(page_swap_event_params), &async_wait_result);
    return async_wait_result;
}

void LocalMainFrameInterceptorForTesting::AnimateDoubleTapZoom(const ::gfx::Point& point, const ::gfx::Rect& rect)
{
    GetForwardingInterface()->AnimateDoubleTapZoom(std::move(point), std::move(rect));
}
void LocalMainFrameInterceptorForTesting::SetScaleFactor(float scale)
{
    GetForwardingInterface()->SetScaleFactor(std::move(scale));
}
void LocalMainFrameInterceptorForTesting::ClosePage(ClosePageCallback callback)
{
    GetForwardingInterface()->ClosePage(std::move(callback));
}
void LocalMainFrameInterceptorForTesting::GetFullPageSize(GetFullPageSizeCallback callback)
{
    GetForwardingInterface()->GetFullPageSize(std::move(callback));
}
void LocalMainFrameInterceptorForTesting::SetInitialFocus(bool reverse)
{
    GetForwardingInterface()->SetInitialFocus(std::move(reverse));
}
void LocalMainFrameInterceptorForTesting::EnablePreferredSizeChangedMode()
{
    GetForwardingInterface()->EnablePreferredSizeChangedMode();
}
void LocalMainFrameInterceptorForTesting::ZoomToFindInPageRect(const ::gfx::Rect& rect_in_root_frame)
{
    GetForwardingInterface()->ZoomToFindInPageRect(std::move(rect_in_root_frame));
}
void LocalMainFrameInterceptorForTesting::InstallCoopAccessMonitor(const ::blink::FrameToken& accessed_window,
    ::network::mojom::blink::CrossOriginOpenerPolicyReporterParamsPtr coop_reporter_info, bool is_in_same_virtual_coop_related_group)
{
    GetForwardingInterface()->InstallCoopAccessMonitor(
        std::move(accessed_window), std::move(coop_reporter_info), std::move(is_in_same_virtual_coop_related_group));
}
void LocalMainFrameInterceptorForTesting::UpdateBrowserControlsState(::cc::BrowserControlsState constraints, ::cc::BrowserControlsState current, bool animate,
    const std::optional<::cc::BrowserControlsOffsetTagsInfo>& offset_tags_info)
{
    GetForwardingInterface()->UpdateBrowserControlsState(std::move(constraints), std::move(current), std::move(animate), std::move(offset_tags_info));
}
void LocalMainFrameInterceptorForTesting::SetV8CompileHints(::base::ReadOnlySharedMemoryRegion data)
{
    GetForwardingInterface()->SetV8CompileHints(std::move(data));
}
void LocalMainFrameInterceptorForTesting::Discard()
{
    GetForwardingInterface()->Discard();
}
void LocalMainFrameInterceptorForTesting::FinalizeNavigationConfidence(double randomized_trigger_rate, ::blink::mojom::blink::ConfidenceLevel confidence)
{
    GetForwardingInterface()->FinalizeNavigationConfidence(std::move(randomized_trigger_rate), std::move(confidence));
}
LocalMainFrameAsyncWaiter::LocalMainFrameAsyncWaiter(LocalMainFrame* proxy)
    : proxy_(proxy)
{
}

LocalMainFrameAsyncWaiter::~LocalMainFrameAsyncWaiter() = default;

void LocalMainFrameAsyncWaiter::ClosePage()
{
    base::RunLoop loop;
    proxy_->ClosePage(base::BindOnce([](base::RunLoop* loop) { loop->Quit(); }, &loop));
    loop.Run();
}

void LocalMainFrameAsyncWaiter::GetFullPageSize(::gfx::Size* out_full_page_size)
{
    base::RunLoop loop;
    proxy_->GetFullPageSize(base::BindOnce(
        [](base::RunLoop* loop, ::gfx::Size* out_full_page_size, const ::gfx::Size& full_page_size) {
            *out_full_page_size = std::move(full_page_size);
            loop->Quit();
        },
        &loop, out_full_page_size));
    loop.Run();
}

::gfx::Size LocalMainFrameAsyncWaiter::GetFullPageSize()
{
    ::gfx::Size async_wait_result;
    GetFullPageSize(&async_wait_result);
    return async_wait_result;
}

void LocalMainFrameHostInterceptorForTesting::ScaleFactorChanged(float scale)
{
    GetForwardingInterface()->ScaleFactorChanged(std::move(scale));
}
void LocalMainFrameHostInterceptorForTesting::ContentsPreferredSizeChanged(const ::gfx::Size& pref_size)
{
    GetForwardingInterface()->ContentsPreferredSizeChanged(std::move(pref_size));
}
void LocalMainFrameHostInterceptorForTesting::TextAutosizerPageInfoChanged(::blink::mojom::blink::TextAutosizerPageInfoPtr page_info)
{
    GetForwardingInterface()->TextAutosizerPageInfoChanged(std::move(page_info));
}
void LocalMainFrameHostInterceptorForTesting::FocusPage()
{
    GetForwardingInterface()->FocusPage();
}
void LocalMainFrameHostInterceptorForTesting::TakeFocus(bool reverse)
{
    GetForwardingInterface()->TakeFocus(std::move(reverse));
}
void LocalMainFrameHostInterceptorForTesting::UpdateTargetURL(const ::blink::KURL& url, UpdateTargetURLCallback callback)
{
    GetForwardingInterface()->UpdateTargetURL(std::move(url), std::move(callback));
}
void LocalMainFrameHostInterceptorForTesting::RequestClose()
{
    GetForwardingInterface()->RequestClose();
}
void LocalMainFrameHostInterceptorForTesting::ShowCreatedWindow(const ::blink::LocalFrameToken& opener_frame_token,
    ::ui::mojom::blink::WindowOpenDisposition disposition, ::blink::mojom::blink::WindowFeaturesPtr window_features, bool opened_by_user_gesture,
    ShowCreatedWindowCallback callback)
{
    GetForwardingInterface()->ShowCreatedWindow(
        std::move(opener_frame_token), std::move(disposition), std::move(window_features), std::move(opened_by_user_gesture), std::move(callback));
}
void LocalMainFrameHostInterceptorForTesting::SetWindowRect(const ::gfx::Rect& bounds, SetWindowRectCallback callback)
{
    GetForwardingInterface()->SetWindowRect(std::move(bounds), std::move(callback));
}
void LocalMainFrameHostInterceptorForTesting::DidFirstVisuallyNonEmptyPaint()
{
    GetForwardingInterface()->DidFirstVisuallyNonEmptyPaint();
}
void LocalMainFrameHostInterceptorForTesting::DidAccessInitialMainDocument()
{
    GetForwardingInterface()->DidAccessInitialMainDocument();
}
void LocalMainFrameHostInterceptorForTesting::Maximize()
{
    GetForwardingInterface()->Maximize();
}
void LocalMainFrameHostInterceptorForTesting::Minimize()
{
    GetForwardingInterface()->Minimize();
}
void LocalMainFrameHostInterceptorForTesting::Restore()
{
    GetForwardingInterface()->Restore();
}
void LocalMainFrameHostInterceptorForTesting::SetResizable(bool resizable)
{
    GetForwardingInterface()->SetResizable(std::move(resizable));
}
void LocalMainFrameHostInterceptorForTesting::DraggableRegionsChanged(WTF::Vector<::blink::mojom::blink::DraggableRegionPtr> regions)
{
    GetForwardingInterface()->DraggableRegionsChanged(std::move(regions));
}
void LocalMainFrameHostInterceptorForTesting::OnFirstContentfulPaint()
{
    GetForwardingInterface()->OnFirstContentfulPaint();
}
LocalMainFrameHostAsyncWaiter::LocalMainFrameHostAsyncWaiter(LocalMainFrameHost* proxy)
    : proxy_(proxy)
{
}

LocalMainFrameHostAsyncWaiter::~LocalMainFrameHostAsyncWaiter() = default;

void LocalMainFrameHostAsyncWaiter::UpdateTargetURL(const ::blink::KURL& url)
{
    base::RunLoop loop;
    proxy_->UpdateTargetURL(std::move(url), base::BindOnce([](base::RunLoop* loop) { loop->Quit(); }, &loop));
    loop.Run();
}

void LocalMainFrameHostAsyncWaiter::ShowCreatedWindow(const ::blink::LocalFrameToken& opener_frame_token, ::ui::mojom::blink::WindowOpenDisposition disposition,
    ::blink::mojom::blink::WindowFeaturesPtr window_features, bool opened_by_user_gesture)
{
    base::RunLoop loop;
    proxy_->ShowCreatedWindow(std::move(opener_frame_token), std::move(disposition), std::move(window_features), std::move(opened_by_user_gesture),
        base::BindOnce([](base::RunLoop* loop) { loop->Quit(); }, &loop));
    loop.Run();
}

void LocalMainFrameHostAsyncWaiter::SetWindowRect(const ::gfx::Rect& bounds)
{
    base::RunLoop loop;
    proxy_->SetWindowRect(std::move(bounds), base::BindOnce([](base::RunLoop* loop) { loop->Quit(); }, &loop));
    loop.Run();
}

} // blink::mojom::blink

#if defined(__clang__)
#pragma clang diagnostic pop
#endif