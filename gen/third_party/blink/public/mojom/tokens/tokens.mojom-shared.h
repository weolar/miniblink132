// third_party/blink/public/mojom/tokens/tokens.mojom-shared.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef THIRD_PARTY_BLINK_PUBLIC_MOJOM_TOKENS_TOKENS_MOJOM_SHARED_H_
#define THIRD_PARTY_BLINK_PUBLIC_MOJOM_TOKENS_TOKENS_MOJOM_SHARED_H_

#include <stdint.h>

#include <functional>
#include <iosfwd>
#include <type_traits>
#include <utility>
#include "mojo/public/cpp/bindings/array_data_view.h"
#include "mojo/public/cpp/bindings/enum_traits.h"
#include "mojo/public/cpp/bindings/interface_data_view.h"
#include "mojo/public/cpp/bindings/lib/bindings_internal.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/map_data_view.h"
#include "mojo/public/cpp/bindings/string_data_view.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "third_party/blink/public/mojom/tokens/tokens.mojom-shared-internal.h"
#include "mojo/public/mojom/base/unguessable_token.mojom-shared.h"

#include "base/component_export.h"

namespace blink::mojom {
class DocumentTokenDataView;

class LocalFrameTokenDataView;

class RemoteFrameTokenDataView;

class DedicatedWorkerTokenDataView;

class ServiceWorkerTokenDataView;

class SharedWorkerTokenDataView;

class AnimationWorkletTokenDataView;

class AudioWorkletTokenDataView;

class LayoutWorkletTokenDataView;

class PaintWorkletTokenDataView;

class SharedStorageWorkletTokenDataView;

class ShadowRealmTokenDataView;

class AttributionSrcTokenDataView;

class ClipboardSequenceNumberTokenDataView;

class SameDocNavigationScreenshotDestinationTokenDataView;

class V8ContextTokenDataView;

class ViewTransitionTokenDataView;

class WebNNContextTokenDataView;

class WebNNTensorTokenDataView;

class FrameTokenDataView;
class WorkerTokenDataView;
class WorkletTokenDataView;
class ExecutionContextTokenDataView;
class WebGPUExecutionContextTokenDataView;

} // blink::mojom

namespace mojo {
namespace internal {

template <> struct MojomTypeTraits<::blink::mojom::DocumentTokenDataView> {
    using Data = ::blink::mojom::internal::DocumentToken_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::blink::mojom::LocalFrameTokenDataView> {
    using Data = ::blink::mojom::internal::LocalFrameToken_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::blink::mojom::RemoteFrameTokenDataView> {
    using Data = ::blink::mojom::internal::RemoteFrameToken_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::blink::mojom::DedicatedWorkerTokenDataView> {
    using Data = ::blink::mojom::internal::DedicatedWorkerToken_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::blink::mojom::ServiceWorkerTokenDataView> {
    using Data = ::blink::mojom::internal::ServiceWorkerToken_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::blink::mojom::SharedWorkerTokenDataView> {
    using Data = ::blink::mojom::internal::SharedWorkerToken_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::blink::mojom::AnimationWorkletTokenDataView> {
    using Data = ::blink::mojom::internal::AnimationWorkletToken_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::blink::mojom::AudioWorkletTokenDataView> {
    using Data = ::blink::mojom::internal::AudioWorkletToken_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::blink::mojom::LayoutWorkletTokenDataView> {
    using Data = ::blink::mojom::internal::LayoutWorkletToken_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::blink::mojom::PaintWorkletTokenDataView> {
    using Data = ::blink::mojom::internal::PaintWorkletToken_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::blink::mojom::SharedStorageWorkletTokenDataView> {
    using Data = ::blink::mojom::internal::SharedStorageWorkletToken_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::blink::mojom::ShadowRealmTokenDataView> {
    using Data = ::blink::mojom::internal::ShadowRealmToken_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::blink::mojom::AttributionSrcTokenDataView> {
    using Data = ::blink::mojom::internal::AttributionSrcToken_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::blink::mojom::ClipboardSequenceNumberTokenDataView> {
    using Data = ::blink::mojom::internal::ClipboardSequenceNumberToken_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::blink::mojom::SameDocNavigationScreenshotDestinationTokenDataView> {
    using Data = ::blink::mojom::internal::SameDocNavigationScreenshotDestinationToken_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::blink::mojom::V8ContextTokenDataView> {
    using Data = ::blink::mojom::internal::V8ContextToken_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::blink::mojom::ViewTransitionTokenDataView> {
    using Data = ::blink::mojom::internal::ViewTransitionToken_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::blink::mojom::WebNNContextTokenDataView> {
    using Data = ::blink::mojom::internal::WebNNContextToken_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::blink::mojom::WebNNTensorTokenDataView> {
    using Data = ::blink::mojom::internal::WebNNTensorToken_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::blink::mojom::FrameTokenDataView> {
    using Data = ::blink::mojom::internal::FrameToken_Data;
    using DataAsArrayElement = Data;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kUnion;
};

template <> struct MojomTypeTraits<::blink::mojom::WorkerTokenDataView> {
    using Data = ::blink::mojom::internal::WorkerToken_Data;
    using DataAsArrayElement = Data;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kUnion;
};

template <> struct MojomTypeTraits<::blink::mojom::WorkletTokenDataView> {
    using Data = ::blink::mojom::internal::WorkletToken_Data;
    using DataAsArrayElement = Data;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kUnion;
};

template <> struct MojomTypeTraits<::blink::mojom::ExecutionContextTokenDataView> {
    using Data = ::blink::mojom::internal::ExecutionContextToken_Data;
    using DataAsArrayElement = Data;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kUnion;
};

template <> struct MojomTypeTraits<::blink::mojom::WebGPUExecutionContextTokenDataView> {
    using Data = ::blink::mojom::internal::WebGPUExecutionContextToken_Data;
    using DataAsArrayElement = Data;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kUnion;
};

} // namespace internal
} // namespace mojo

namespace blink::mojom {

class DocumentTokenDataView {
public:
    DocumentTokenDataView() = default;

    DocumentTokenDataView(internal::DocumentToken_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetValueDataView(::mojo_base::mojom::UnguessableTokenDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadValue(UserType* output)
    {

        auto* pointer = data_->value.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::UnguessableTokenDataView>(pointer, output, message_);
    }

private:
    internal::DocumentToken_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class LocalFrameTokenDataView {
public:
    LocalFrameTokenDataView() = default;

    LocalFrameTokenDataView(internal::LocalFrameToken_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetValueDataView(::mojo_base::mojom::UnguessableTokenDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadValue(UserType* output)
    {

        auto* pointer = data_->value.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::UnguessableTokenDataView>(pointer, output, message_);
    }

private:
    internal::LocalFrameToken_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class RemoteFrameTokenDataView {
public:
    RemoteFrameTokenDataView() = default;

    RemoteFrameTokenDataView(internal::RemoteFrameToken_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetValueDataView(::mojo_base::mojom::UnguessableTokenDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadValue(UserType* output)
    {

        auto* pointer = data_->value.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::UnguessableTokenDataView>(pointer, output, message_);
    }

private:
    internal::RemoteFrameToken_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class DedicatedWorkerTokenDataView {
public:
    DedicatedWorkerTokenDataView() = default;

    DedicatedWorkerTokenDataView(internal::DedicatedWorkerToken_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetValueDataView(::mojo_base::mojom::UnguessableTokenDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadValue(UserType* output)
    {

        auto* pointer = data_->value.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::UnguessableTokenDataView>(pointer, output, message_);
    }

private:
    internal::DedicatedWorkerToken_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class ServiceWorkerTokenDataView {
public:
    ServiceWorkerTokenDataView() = default;

    ServiceWorkerTokenDataView(internal::ServiceWorkerToken_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetValueDataView(::mojo_base::mojom::UnguessableTokenDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadValue(UserType* output)
    {

        auto* pointer = data_->value.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::UnguessableTokenDataView>(pointer, output, message_);
    }

private:
    internal::ServiceWorkerToken_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class SharedWorkerTokenDataView {
public:
    SharedWorkerTokenDataView() = default;

    SharedWorkerTokenDataView(internal::SharedWorkerToken_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetValueDataView(::mojo_base::mojom::UnguessableTokenDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadValue(UserType* output)
    {

        auto* pointer = data_->value.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::UnguessableTokenDataView>(pointer, output, message_);
    }

private:
    internal::SharedWorkerToken_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class AnimationWorkletTokenDataView {
public:
    AnimationWorkletTokenDataView() = default;

    AnimationWorkletTokenDataView(internal::AnimationWorkletToken_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetValueDataView(::mojo_base::mojom::UnguessableTokenDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadValue(UserType* output)
    {

        auto* pointer = data_->value.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::UnguessableTokenDataView>(pointer, output, message_);
    }

private:
    internal::AnimationWorkletToken_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class AudioWorkletTokenDataView {
public:
    AudioWorkletTokenDataView() = default;

    AudioWorkletTokenDataView(internal::AudioWorkletToken_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetValueDataView(::mojo_base::mojom::UnguessableTokenDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadValue(UserType* output)
    {

        auto* pointer = data_->value.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::UnguessableTokenDataView>(pointer, output, message_);
    }

private:
    internal::AudioWorkletToken_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class LayoutWorkletTokenDataView {
public:
    LayoutWorkletTokenDataView() = default;

    LayoutWorkletTokenDataView(internal::LayoutWorkletToken_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetValueDataView(::mojo_base::mojom::UnguessableTokenDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadValue(UserType* output)
    {

        auto* pointer = data_->value.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::UnguessableTokenDataView>(pointer, output, message_);
    }

private:
    internal::LayoutWorkletToken_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class PaintWorkletTokenDataView {
public:
    PaintWorkletTokenDataView() = default;

    PaintWorkletTokenDataView(internal::PaintWorkletToken_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetValueDataView(::mojo_base::mojom::UnguessableTokenDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadValue(UserType* output)
    {

        auto* pointer = data_->value.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::UnguessableTokenDataView>(pointer, output, message_);
    }

private:
    internal::PaintWorkletToken_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class SharedStorageWorkletTokenDataView {
public:
    SharedStorageWorkletTokenDataView() = default;

    SharedStorageWorkletTokenDataView(internal::SharedStorageWorkletToken_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetValueDataView(::mojo_base::mojom::UnguessableTokenDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadValue(UserType* output)
    {

        auto* pointer = data_->value.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::UnguessableTokenDataView>(pointer, output, message_);
    }

private:
    internal::SharedStorageWorkletToken_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class ShadowRealmTokenDataView {
public:
    ShadowRealmTokenDataView() = default;

    ShadowRealmTokenDataView(internal::ShadowRealmToken_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetValueDataView(::mojo_base::mojom::UnguessableTokenDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadValue(UserType* output)
    {

        auto* pointer = data_->value.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::UnguessableTokenDataView>(pointer, output, message_);
    }

private:
    internal::ShadowRealmToken_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class AttributionSrcTokenDataView {
public:
    AttributionSrcTokenDataView() = default;

    AttributionSrcTokenDataView(internal::AttributionSrcToken_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetValueDataView(::mojo_base::mojom::UnguessableTokenDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadValue(UserType* output)
    {

        auto* pointer = data_->value.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::UnguessableTokenDataView>(pointer, output, message_);
    }

private:
    internal::AttributionSrcToken_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class ClipboardSequenceNumberTokenDataView {
public:
    ClipboardSequenceNumberTokenDataView() = default;

    ClipboardSequenceNumberTokenDataView(internal::ClipboardSequenceNumberToken_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetValueDataView(::mojo_base::mojom::UnguessableTokenDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadValue(UserType* output)
    {

        auto* pointer = data_->value.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::UnguessableTokenDataView>(pointer, output, message_);
    }

private:
    internal::ClipboardSequenceNumberToken_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class SameDocNavigationScreenshotDestinationTokenDataView {
public:
    SameDocNavigationScreenshotDestinationTokenDataView() = default;

    SameDocNavigationScreenshotDestinationTokenDataView(internal::SameDocNavigationScreenshotDestinationToken_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetValueDataView(::mojo_base::mojom::UnguessableTokenDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadValue(UserType* output)
    {

        auto* pointer = data_->value.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::UnguessableTokenDataView>(pointer, output, message_);
    }

private:
    internal::SameDocNavigationScreenshotDestinationToken_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class V8ContextTokenDataView {
public:
    V8ContextTokenDataView() = default;

    V8ContextTokenDataView(internal::V8ContextToken_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetValueDataView(::mojo_base::mojom::UnguessableTokenDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadValue(UserType* output)
    {

        auto* pointer = data_->value.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::UnguessableTokenDataView>(pointer, output, message_);
    }

private:
    internal::V8ContextToken_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class ViewTransitionTokenDataView {
public:
    ViewTransitionTokenDataView() = default;

    ViewTransitionTokenDataView(internal::ViewTransitionToken_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetValueDataView(::mojo_base::mojom::UnguessableTokenDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadValue(UserType* output)
    {

        auto* pointer = data_->value.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::UnguessableTokenDataView>(pointer, output, message_);
    }

private:
    internal::ViewTransitionToken_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class WebNNContextTokenDataView {
public:
    WebNNContextTokenDataView() = default;

    WebNNContextTokenDataView(internal::WebNNContextToken_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetValueDataView(::mojo_base::mojom::UnguessableTokenDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadValue(UserType* output)
    {

        auto* pointer = data_->value.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::UnguessableTokenDataView>(pointer, output, message_);
    }

private:
    internal::WebNNContextToken_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class WebNNTensorTokenDataView {
public:
    WebNNTensorTokenDataView() = default;

    WebNNTensorTokenDataView(internal::WebNNTensorToken_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetValueDataView(::mojo_base::mojom::UnguessableTokenDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadValue(UserType* output)
    {

        auto* pointer = data_->value.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::UnguessableTokenDataView>(pointer, output, message_);
    }

private:
    internal::WebNNTensorToken_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class FrameTokenDataView {
public:
    using Tag = internal::FrameToken_Data::FrameToken_Tag;

    FrameTokenDataView() = default;

    FrameTokenDataView(internal::FrameToken_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        // For inlined unions, |data_| is always non-null. In that case we need to
        // check |data_->is_null()|.
        return !data_ || data_->is_null();
    }

    Tag tag() const
    {
        return data_->tag;
    }
    bool is_local_frame_token() const
    {
        return data_->tag == Tag::kLocalFrameToken;
    }
    inline void GetLocalFrameTokenDataView(LocalFrameTokenDataView* output) const;

    template <typename UserType> [[nodiscard]] bool ReadLocalFrameToken(UserType* output) const
    {

        CHECK(is_local_frame_token());
        return mojo::internal::Deserialize<::blink::mojom::LocalFrameTokenDataView>(data_->data.f_local_frame_token.Get(), output, message_);
    }
    bool is_remote_frame_token() const
    {
        return data_->tag == Tag::kRemoteFrameToken;
    }
    inline void GetRemoteFrameTokenDataView(RemoteFrameTokenDataView* output) const;

    template <typename UserType> [[nodiscard]] bool ReadRemoteFrameToken(UserType* output) const
    {

        CHECK(is_remote_frame_token());
        return mojo::internal::Deserialize<::blink::mojom::RemoteFrameTokenDataView>(data_->data.f_remote_frame_token.Get(), output, message_);
    }

private:
    internal::FrameToken_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class WorkerTokenDataView {
public:
    using Tag = internal::WorkerToken_Data::WorkerToken_Tag;

    WorkerTokenDataView() = default;

    WorkerTokenDataView(internal::WorkerToken_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        // For inlined unions, |data_| is always non-null. In that case we need to
        // check |data_->is_null()|.
        return !data_ || data_->is_null();
    }

    Tag tag() const
    {
        return data_->tag;
    }
    bool is_dedicated_worker_token() const
    {
        return data_->tag == Tag::kDedicatedWorkerToken;
    }
    inline void GetDedicatedWorkerTokenDataView(DedicatedWorkerTokenDataView* output) const;

    template <typename UserType> [[nodiscard]] bool ReadDedicatedWorkerToken(UserType* output) const
    {

        CHECK(is_dedicated_worker_token());
        return mojo::internal::Deserialize<::blink::mojom::DedicatedWorkerTokenDataView>(data_->data.f_dedicated_worker_token.Get(), output, message_);
    }
    bool is_service_worker_token() const
    {
        return data_->tag == Tag::kServiceWorkerToken;
    }
    inline void GetServiceWorkerTokenDataView(ServiceWorkerTokenDataView* output) const;

    template <typename UserType> [[nodiscard]] bool ReadServiceWorkerToken(UserType* output) const
    {

        CHECK(is_service_worker_token());
        return mojo::internal::Deserialize<::blink::mojom::ServiceWorkerTokenDataView>(data_->data.f_service_worker_token.Get(), output, message_);
    }
    bool is_shared_worker_token() const
    {
        return data_->tag == Tag::kSharedWorkerToken;
    }
    inline void GetSharedWorkerTokenDataView(SharedWorkerTokenDataView* output) const;

    template <typename UserType> [[nodiscard]] bool ReadSharedWorkerToken(UserType* output) const
    {

        CHECK(is_shared_worker_token());
        return mojo::internal::Deserialize<::blink::mojom::SharedWorkerTokenDataView>(data_->data.f_shared_worker_token.Get(), output, message_);
    }

private:
    internal::WorkerToken_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class WorkletTokenDataView {
public:
    using Tag = internal::WorkletToken_Data::WorkletToken_Tag;

    WorkletTokenDataView() = default;

    WorkletTokenDataView(internal::WorkletToken_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        // For inlined unions, |data_| is always non-null. In that case we need to
        // check |data_->is_null()|.
        return !data_ || data_->is_null();
    }

    Tag tag() const
    {
        return data_->tag;
    }
    bool is_animation_worklet_token() const
    {
        return data_->tag == Tag::kAnimationWorkletToken;
    }
    inline void GetAnimationWorkletTokenDataView(AnimationWorkletTokenDataView* output) const;

    template <typename UserType> [[nodiscard]] bool ReadAnimationWorkletToken(UserType* output) const
    {

        CHECK(is_animation_worklet_token());
        return mojo::internal::Deserialize<::blink::mojom::AnimationWorkletTokenDataView>(data_->data.f_animation_worklet_token.Get(), output, message_);
    }
    bool is_audio_worklet_token() const
    {
        return data_->tag == Tag::kAudioWorkletToken;
    }
    inline void GetAudioWorkletTokenDataView(AudioWorkletTokenDataView* output) const;

    template <typename UserType> [[nodiscard]] bool ReadAudioWorkletToken(UserType* output) const
    {

        CHECK(is_audio_worklet_token());
        return mojo::internal::Deserialize<::blink::mojom::AudioWorkletTokenDataView>(data_->data.f_audio_worklet_token.Get(), output, message_);
    }
    bool is_layout_worklet_token() const
    {
        return data_->tag == Tag::kLayoutWorkletToken;
    }
    inline void GetLayoutWorkletTokenDataView(LayoutWorkletTokenDataView* output) const;

    template <typename UserType> [[nodiscard]] bool ReadLayoutWorkletToken(UserType* output) const
    {

        CHECK(is_layout_worklet_token());
        return mojo::internal::Deserialize<::blink::mojom::LayoutWorkletTokenDataView>(data_->data.f_layout_worklet_token.Get(), output, message_);
    }
    bool is_paint_worklet_token() const
    {
        return data_->tag == Tag::kPaintWorkletToken;
    }
    inline void GetPaintWorkletTokenDataView(PaintWorkletTokenDataView* output) const;

    template <typename UserType> [[nodiscard]] bool ReadPaintWorkletToken(UserType* output) const
    {

        CHECK(is_paint_worklet_token());
        return mojo::internal::Deserialize<::blink::mojom::PaintWorkletTokenDataView>(data_->data.f_paint_worklet_token.Get(), output, message_);
    }
    bool is_shared_storage_worklet_token() const
    {
        return data_->tag == Tag::kSharedStorageWorkletToken;
    }
    inline void GetSharedStorageWorkletTokenDataView(SharedStorageWorkletTokenDataView* output) const;

    template <typename UserType> [[nodiscard]] bool ReadSharedStorageWorkletToken(UserType* output) const
    {

        CHECK(is_shared_storage_worklet_token());
        return mojo::internal::Deserialize<::blink::mojom::SharedStorageWorkletTokenDataView>(
            data_->data.f_shared_storage_worklet_token.Get(), output, message_);
    }

private:
    internal::WorkletToken_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class ExecutionContextTokenDataView {
public:
    using Tag = internal::ExecutionContextToken_Data::ExecutionContextToken_Tag;

    ExecutionContextTokenDataView() = default;

    ExecutionContextTokenDataView(internal::ExecutionContextToken_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        // For inlined unions, |data_| is always non-null. In that case we need to
        // check |data_->is_null()|.
        return !data_ || data_->is_null();
    }

    Tag tag() const
    {
        return data_->tag;
    }
    bool is_local_frame_token() const
    {
        return data_->tag == Tag::kLocalFrameToken;
    }
    inline void GetLocalFrameTokenDataView(LocalFrameTokenDataView* output) const;

    template <typename UserType> [[nodiscard]] bool ReadLocalFrameToken(UserType* output) const
    {

        CHECK(is_local_frame_token());
        return mojo::internal::Deserialize<::blink::mojom::LocalFrameTokenDataView>(data_->data.f_local_frame_token.Get(), output, message_);
    }
    bool is_dedicated_worker_token() const
    {
        return data_->tag == Tag::kDedicatedWorkerToken;
    }
    inline void GetDedicatedWorkerTokenDataView(DedicatedWorkerTokenDataView* output) const;

    template <typename UserType> [[nodiscard]] bool ReadDedicatedWorkerToken(UserType* output) const
    {

        CHECK(is_dedicated_worker_token());
        return mojo::internal::Deserialize<::blink::mojom::DedicatedWorkerTokenDataView>(data_->data.f_dedicated_worker_token.Get(), output, message_);
    }
    bool is_service_worker_token() const
    {
        return data_->tag == Tag::kServiceWorkerToken;
    }
    inline void GetServiceWorkerTokenDataView(ServiceWorkerTokenDataView* output) const;

    template <typename UserType> [[nodiscard]] bool ReadServiceWorkerToken(UserType* output) const
    {

        CHECK(is_service_worker_token());
        return mojo::internal::Deserialize<::blink::mojom::ServiceWorkerTokenDataView>(data_->data.f_service_worker_token.Get(), output, message_);
    }
    bool is_shared_worker_token() const
    {
        return data_->tag == Tag::kSharedWorkerToken;
    }
    inline void GetSharedWorkerTokenDataView(SharedWorkerTokenDataView* output) const;

    template <typename UserType> [[nodiscard]] bool ReadSharedWorkerToken(UserType* output) const
    {

        CHECK(is_shared_worker_token());
        return mojo::internal::Deserialize<::blink::mojom::SharedWorkerTokenDataView>(data_->data.f_shared_worker_token.Get(), output, message_);
    }
    bool is_animation_worklet_token() const
    {
        return data_->tag == Tag::kAnimationWorkletToken;
    }
    inline void GetAnimationWorkletTokenDataView(AnimationWorkletTokenDataView* output) const;

    template <typename UserType> [[nodiscard]] bool ReadAnimationWorkletToken(UserType* output) const
    {

        CHECK(is_animation_worklet_token());
        return mojo::internal::Deserialize<::blink::mojom::AnimationWorkletTokenDataView>(data_->data.f_animation_worklet_token.Get(), output, message_);
    }
    bool is_audio_worklet_token() const
    {
        return data_->tag == Tag::kAudioWorkletToken;
    }
    inline void GetAudioWorkletTokenDataView(AudioWorkletTokenDataView* output) const;

    template <typename UserType> [[nodiscard]] bool ReadAudioWorkletToken(UserType* output) const
    {

        CHECK(is_audio_worklet_token());
        return mojo::internal::Deserialize<::blink::mojom::AudioWorkletTokenDataView>(data_->data.f_audio_worklet_token.Get(), output, message_);
    }
    bool is_layout_worklet_token() const
    {
        return data_->tag == Tag::kLayoutWorkletToken;
    }
    inline void GetLayoutWorkletTokenDataView(LayoutWorkletTokenDataView* output) const;

    template <typename UserType> [[nodiscard]] bool ReadLayoutWorkletToken(UserType* output) const
    {

        CHECK(is_layout_worklet_token());
        return mojo::internal::Deserialize<::blink::mojom::LayoutWorkletTokenDataView>(data_->data.f_layout_worklet_token.Get(), output, message_);
    }
    bool is_paint_worklet_token() const
    {
        return data_->tag == Tag::kPaintWorkletToken;
    }
    inline void GetPaintWorkletTokenDataView(PaintWorkletTokenDataView* output) const;

    template <typename UserType> [[nodiscard]] bool ReadPaintWorkletToken(UserType* output) const
    {

        CHECK(is_paint_worklet_token());
        return mojo::internal::Deserialize<::blink::mojom::PaintWorkletTokenDataView>(data_->data.f_paint_worklet_token.Get(), output, message_);
    }
    bool is_shared_storage_worklet_token() const
    {
        return data_->tag == Tag::kSharedStorageWorkletToken;
    }
    inline void GetSharedStorageWorkletTokenDataView(SharedStorageWorkletTokenDataView* output) const;

    template <typename UserType> [[nodiscard]] bool ReadSharedStorageWorkletToken(UserType* output) const
    {

        CHECK(is_shared_storage_worklet_token());
        return mojo::internal::Deserialize<::blink::mojom::SharedStorageWorkletTokenDataView>(
            data_->data.f_shared_storage_worklet_token.Get(), output, message_);
    }
    bool is_shadow_realm_token() const
    {
        return data_->tag == Tag::kShadowRealmToken;
    }
    inline void GetShadowRealmTokenDataView(ShadowRealmTokenDataView* output) const;

    template <typename UserType> [[nodiscard]] bool ReadShadowRealmToken(UserType* output) const
    {

        CHECK(is_shadow_realm_token());
        return mojo::internal::Deserialize<::blink::mojom::ShadowRealmTokenDataView>(data_->data.f_shadow_realm_token.Get(), output, message_);
    }

private:
    internal::ExecutionContextToken_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class WebGPUExecutionContextTokenDataView {
public:
    using Tag = internal::WebGPUExecutionContextToken_Data::WebGPUExecutionContextToken_Tag;

    WebGPUExecutionContextTokenDataView() = default;

    WebGPUExecutionContextTokenDataView(internal::WebGPUExecutionContextToken_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        // For inlined unions, |data_| is always non-null. In that case we need to
        // check |data_->is_null()|.
        return !data_ || data_->is_null();
    }

    Tag tag() const
    {
        return data_->tag;
    }
    bool is_document_token() const
    {
        return data_->tag == Tag::kDocumentToken;
    }
    inline void GetDocumentTokenDataView(DocumentTokenDataView* output) const;

    template <typename UserType> [[nodiscard]] bool ReadDocumentToken(UserType* output) const
    {

        CHECK(is_document_token());
        return mojo::internal::Deserialize<::blink::mojom::DocumentTokenDataView>(data_->data.f_document_token.Get(), output, message_);
    }
    bool is_dedicated_worker_token() const
    {
        return data_->tag == Tag::kDedicatedWorkerToken;
    }
    inline void GetDedicatedWorkerTokenDataView(DedicatedWorkerTokenDataView* output) const;

    template <typename UserType> [[nodiscard]] bool ReadDedicatedWorkerToken(UserType* output) const
    {

        CHECK(is_dedicated_worker_token());
        return mojo::internal::Deserialize<::blink::mojom::DedicatedWorkerTokenDataView>(data_->data.f_dedicated_worker_token.Get(), output, message_);
    }
    bool is_shared_worker_token() const
    {
        return data_->tag == Tag::kSharedWorkerToken;
    }
    inline void GetSharedWorkerTokenDataView(SharedWorkerTokenDataView* output) const;

    template <typename UserType> [[nodiscard]] bool ReadSharedWorkerToken(UserType* output) const
    {

        CHECK(is_shared_worker_token());
        return mojo::internal::Deserialize<::blink::mojom::SharedWorkerTokenDataView>(data_->data.f_shared_worker_token.Get(), output, message_);
    }
    bool is_service_worker_token() const
    {
        return data_->tag == Tag::kServiceWorkerToken;
    }
    inline void GetServiceWorkerTokenDataView(ServiceWorkerTokenDataView* output) const;

    template <typename UserType> [[nodiscard]] bool ReadServiceWorkerToken(UserType* output) const
    {

        CHECK(is_service_worker_token());
        return mojo::internal::Deserialize<::blink::mojom::ServiceWorkerTokenDataView>(data_->data.f_service_worker_token.Get(), output, message_);
    }

private:
    internal::WebGPUExecutionContextToken_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

} // blink::mojom

namespace std {

} // namespace std

namespace mojo {

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::DocumentTokenDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::blink::mojom::DocumentTokenDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::blink::mojom::internal::DocumentToken_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::value(input)) in_value = Traits::value(input);
        mojo::internal::MessageFragment<typename decltype(fragment->value)::BaseType> value_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::UnguessableTokenDataView>(in_value, value_fragment);
        fragment->value.Set(value_fragment.is_null() ? nullptr : value_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->value.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null value in DocumentToken struct");
    }

    static bool Deserialize(::blink::mojom::internal::DocumentToken_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::blink::mojom::DocumentTokenDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::LocalFrameTokenDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::blink::mojom::LocalFrameTokenDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::blink::mojom::internal::LocalFrameToken_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::value(input)) in_value = Traits::value(input);
        mojo::internal::MessageFragment<typename decltype(fragment->value)::BaseType> value_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::UnguessableTokenDataView>(in_value, value_fragment);
        fragment->value.Set(value_fragment.is_null() ? nullptr : value_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->value.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null value in LocalFrameToken struct");
    }

    static bool Deserialize(::blink::mojom::internal::LocalFrameToken_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::blink::mojom::LocalFrameTokenDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::RemoteFrameTokenDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::blink::mojom::RemoteFrameTokenDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::blink::mojom::internal::RemoteFrameToken_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::value(input)) in_value = Traits::value(input);
        mojo::internal::MessageFragment<typename decltype(fragment->value)::BaseType> value_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::UnguessableTokenDataView>(in_value, value_fragment);
        fragment->value.Set(value_fragment.is_null() ? nullptr : value_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->value.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null value in RemoteFrameToken struct");
    }

    static bool Deserialize(::blink::mojom::internal::RemoteFrameToken_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::blink::mojom::RemoteFrameTokenDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::DedicatedWorkerTokenDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::blink::mojom::DedicatedWorkerTokenDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::blink::mojom::internal::DedicatedWorkerToken_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::value(input)) in_value = Traits::value(input);
        mojo::internal::MessageFragment<typename decltype(fragment->value)::BaseType> value_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::UnguessableTokenDataView>(in_value, value_fragment);
        fragment->value.Set(value_fragment.is_null() ? nullptr : value_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->value.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null value in DedicatedWorkerToken struct");
    }

    static bool Deserialize(::blink::mojom::internal::DedicatedWorkerToken_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::blink::mojom::DedicatedWorkerTokenDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::ServiceWorkerTokenDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::blink::mojom::ServiceWorkerTokenDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::blink::mojom::internal::ServiceWorkerToken_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::value(input)) in_value = Traits::value(input);
        mojo::internal::MessageFragment<typename decltype(fragment->value)::BaseType> value_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::UnguessableTokenDataView>(in_value, value_fragment);
        fragment->value.Set(value_fragment.is_null() ? nullptr : value_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->value.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null value in ServiceWorkerToken struct");
    }

    static bool Deserialize(::blink::mojom::internal::ServiceWorkerToken_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::blink::mojom::ServiceWorkerTokenDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::SharedWorkerTokenDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::blink::mojom::SharedWorkerTokenDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::blink::mojom::internal::SharedWorkerToken_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::value(input)) in_value = Traits::value(input);
        mojo::internal::MessageFragment<typename decltype(fragment->value)::BaseType> value_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::UnguessableTokenDataView>(in_value, value_fragment);
        fragment->value.Set(value_fragment.is_null() ? nullptr : value_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->value.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null value in SharedWorkerToken struct");
    }

    static bool Deserialize(::blink::mojom::internal::SharedWorkerToken_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::blink::mojom::SharedWorkerTokenDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::AnimationWorkletTokenDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::blink::mojom::AnimationWorkletTokenDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::blink::mojom::internal::AnimationWorkletToken_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::value(input)) in_value = Traits::value(input);
        mojo::internal::MessageFragment<typename decltype(fragment->value)::BaseType> value_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::UnguessableTokenDataView>(in_value, value_fragment);
        fragment->value.Set(value_fragment.is_null() ? nullptr : value_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->value.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null value in AnimationWorkletToken struct");
    }

    static bool Deserialize(::blink::mojom::internal::AnimationWorkletToken_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::blink::mojom::AnimationWorkletTokenDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::AudioWorkletTokenDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::blink::mojom::AudioWorkletTokenDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::blink::mojom::internal::AudioWorkletToken_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::value(input)) in_value = Traits::value(input);
        mojo::internal::MessageFragment<typename decltype(fragment->value)::BaseType> value_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::UnguessableTokenDataView>(in_value, value_fragment);
        fragment->value.Set(value_fragment.is_null() ? nullptr : value_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->value.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null value in AudioWorkletToken struct");
    }

    static bool Deserialize(::blink::mojom::internal::AudioWorkletToken_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::blink::mojom::AudioWorkletTokenDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::LayoutWorkletTokenDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::blink::mojom::LayoutWorkletTokenDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::blink::mojom::internal::LayoutWorkletToken_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::value(input)) in_value = Traits::value(input);
        mojo::internal::MessageFragment<typename decltype(fragment->value)::BaseType> value_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::UnguessableTokenDataView>(in_value, value_fragment);
        fragment->value.Set(value_fragment.is_null() ? nullptr : value_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->value.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null value in LayoutWorkletToken struct");
    }

    static bool Deserialize(::blink::mojom::internal::LayoutWorkletToken_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::blink::mojom::LayoutWorkletTokenDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::PaintWorkletTokenDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::blink::mojom::PaintWorkletTokenDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::blink::mojom::internal::PaintWorkletToken_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::value(input)) in_value = Traits::value(input);
        mojo::internal::MessageFragment<typename decltype(fragment->value)::BaseType> value_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::UnguessableTokenDataView>(in_value, value_fragment);
        fragment->value.Set(value_fragment.is_null() ? nullptr : value_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->value.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null value in PaintWorkletToken struct");
    }

    static bool Deserialize(::blink::mojom::internal::PaintWorkletToken_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::blink::mojom::PaintWorkletTokenDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::SharedStorageWorkletTokenDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::blink::mojom::SharedStorageWorkletTokenDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::blink::mojom::internal::SharedStorageWorkletToken_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::value(input)) in_value = Traits::value(input);
        mojo::internal::MessageFragment<typename decltype(fragment->value)::BaseType> value_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::UnguessableTokenDataView>(in_value, value_fragment);
        fragment->value.Set(value_fragment.is_null() ? nullptr : value_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->value.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null value in SharedStorageWorkletToken struct");
    }

    static bool Deserialize(::blink::mojom::internal::SharedStorageWorkletToken_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::blink::mojom::SharedStorageWorkletTokenDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::ShadowRealmTokenDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::blink::mojom::ShadowRealmTokenDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::blink::mojom::internal::ShadowRealmToken_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::value(input)) in_value = Traits::value(input);
        mojo::internal::MessageFragment<typename decltype(fragment->value)::BaseType> value_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::UnguessableTokenDataView>(in_value, value_fragment);
        fragment->value.Set(value_fragment.is_null() ? nullptr : value_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->value.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null value in ShadowRealmToken struct");
    }

    static bool Deserialize(::blink::mojom::internal::ShadowRealmToken_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::blink::mojom::ShadowRealmTokenDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::AttributionSrcTokenDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::blink::mojom::AttributionSrcTokenDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::blink::mojom::internal::AttributionSrcToken_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::value(input)) in_value = Traits::value(input);
        mojo::internal::MessageFragment<typename decltype(fragment->value)::BaseType> value_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::UnguessableTokenDataView>(in_value, value_fragment);
        fragment->value.Set(value_fragment.is_null() ? nullptr : value_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->value.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null value in AttributionSrcToken struct");
    }

    static bool Deserialize(::blink::mojom::internal::AttributionSrcToken_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::blink::mojom::AttributionSrcTokenDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::ClipboardSequenceNumberTokenDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::blink::mojom::ClipboardSequenceNumberTokenDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::blink::mojom::internal::ClipboardSequenceNumberToken_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::value(input)) in_value = Traits::value(input);
        mojo::internal::MessageFragment<typename decltype(fragment->value)::BaseType> value_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::UnguessableTokenDataView>(in_value, value_fragment);
        fragment->value.Set(value_fragment.is_null() ? nullptr : value_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->value.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null value in ClipboardSequenceNumberToken struct");
    }

    static bool Deserialize(::blink::mojom::internal::ClipboardSequenceNumberToken_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::blink::mojom::ClipboardSequenceNumberTokenDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::SameDocNavigationScreenshotDestinationTokenDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::blink::mojom::SameDocNavigationScreenshotDestinationTokenDataView, UserType>;

    static void Serialize(
        MaybeConstUserType& input, mojo::internal::MessageFragment<::blink::mojom::internal::SameDocNavigationScreenshotDestinationToken_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::value(input)) in_value = Traits::value(input);
        mojo::internal::MessageFragment<typename decltype(fragment->value)::BaseType> value_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::UnguessableTokenDataView>(in_value, value_fragment);
        fragment->value.Set(value_fragment.is_null() ? nullptr : value_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(fragment->value.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null value in SameDocNavigationScreenshotDestinationToken struct");
    }

    static bool Deserialize(::blink::mojom::internal::SameDocNavigationScreenshotDestinationToken_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::blink::mojom::SameDocNavigationScreenshotDestinationTokenDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::V8ContextTokenDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::blink::mojom::V8ContextTokenDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::blink::mojom::internal::V8ContextToken_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::value(input)) in_value = Traits::value(input);
        mojo::internal::MessageFragment<typename decltype(fragment->value)::BaseType> value_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::UnguessableTokenDataView>(in_value, value_fragment);
        fragment->value.Set(value_fragment.is_null() ? nullptr : value_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->value.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null value in V8ContextToken struct");
    }

    static bool Deserialize(::blink::mojom::internal::V8ContextToken_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::blink::mojom::V8ContextTokenDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::ViewTransitionTokenDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::blink::mojom::ViewTransitionTokenDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::blink::mojom::internal::ViewTransitionToken_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::value(input)) in_value = Traits::value(input);
        mojo::internal::MessageFragment<typename decltype(fragment->value)::BaseType> value_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::UnguessableTokenDataView>(in_value, value_fragment);
        fragment->value.Set(value_fragment.is_null() ? nullptr : value_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->value.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null value in ViewTransitionToken struct");
    }

    static bool Deserialize(::blink::mojom::internal::ViewTransitionToken_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::blink::mojom::ViewTransitionTokenDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::WebNNContextTokenDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::blink::mojom::WebNNContextTokenDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::blink::mojom::internal::WebNNContextToken_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::value(input)) in_value = Traits::value(input);
        mojo::internal::MessageFragment<typename decltype(fragment->value)::BaseType> value_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::UnguessableTokenDataView>(in_value, value_fragment);
        fragment->value.Set(value_fragment.is_null() ? nullptr : value_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->value.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null value in WebNNContextToken struct");
    }

    static bool Deserialize(::blink::mojom::internal::WebNNContextToken_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::blink::mojom::WebNNContextTokenDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::WebNNTensorTokenDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::blink::mojom::WebNNTensorTokenDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::blink::mojom::internal::WebNNTensorToken_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::value(input)) in_value = Traits::value(input);
        mojo::internal::MessageFragment<typename decltype(fragment->value)::BaseType> value_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::UnguessableTokenDataView>(in_value, value_fragment);
        fragment->value.Set(value_fragment.is_null() ? nullptr : value_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->value.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null value in WebNNTensorToken struct");
    }

    static bool Deserialize(::blink::mojom::internal::WebNNTensorToken_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::blink::mojom::WebNNTensorTokenDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::FrameTokenDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = UnionTraits<::blink::mojom::FrameTokenDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, MessageFragment<::blink::mojom::internal::FrameToken_Data>& fragment, bool inlined)
    {
        if (CallIsNullIfExists<Traits>(input)) {
            if (inlined)
                fragment->set_null();
            return;
        }

        if (!inlined)
            fragment.Allocate();

        // TODO(azani): Handle unknown and objects.
        // Set the not-null flag.
        fragment->size = kUnionDataSize;
        fragment->tag = Traits::GetTag(input);
        switch (fragment->tag) {
        case ::blink::mojom::FrameTokenDataView::Tag::kLocalFrameToken: {
            decltype(Traits::local_frame_token(input)) in_local_frame_token = Traits::local_frame_token(input);
            mojo::internal::MessageFragment<typename decltype(fragment->data.f_local_frame_token)::BaseType> value_fragment(fragment.message());
            mojo::internal::Serialize<::blink::mojom::LocalFrameTokenDataView>(in_local_frame_token, value_fragment);
            MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
                value_fragment.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null local_frame_token in FrameToken union");
            fragment->data.f_local_frame_token.Set(value_fragment.is_null() ? nullptr : value_fragment.data());
            break;
        }
        case ::blink::mojom::FrameTokenDataView::Tag::kRemoteFrameToken: {
            decltype(Traits::remote_frame_token(input)) in_remote_frame_token = Traits::remote_frame_token(input);
            mojo::internal::MessageFragment<typename decltype(fragment->data.f_remote_frame_token)::BaseType> value_fragment(fragment.message());
            mojo::internal::Serialize<::blink::mojom::RemoteFrameTokenDataView>(in_remote_frame_token, value_fragment);
            MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
                value_fragment.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null remote_frame_token in FrameToken union");
            fragment->data.f_remote_frame_token.Set(value_fragment.is_null() ? nullptr : value_fragment.data());
            break;
        }
        }
    }

    static bool Deserialize(::blink::mojom::internal::FrameToken_Data* input, UserType* output, Message* message)
    {
        if (!input || input->is_null())
            return CallSetToNullIfExists<Traits>(output);

        ::blink::mojom::FrameTokenDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::WorkerTokenDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = UnionTraits<::blink::mojom::WorkerTokenDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, MessageFragment<::blink::mojom::internal::WorkerToken_Data>& fragment, bool inlined)
    {
        if (CallIsNullIfExists<Traits>(input)) {
            if (inlined)
                fragment->set_null();
            return;
        }

        if (!inlined)
            fragment.Allocate();

        // TODO(azani): Handle unknown and objects.
        // Set the not-null flag.
        fragment->size = kUnionDataSize;
        fragment->tag = Traits::GetTag(input);
        switch (fragment->tag) {
        case ::blink::mojom::WorkerTokenDataView::Tag::kDedicatedWorkerToken: {
            decltype(Traits::dedicated_worker_token(input)) in_dedicated_worker_token = Traits::dedicated_worker_token(input);
            mojo::internal::MessageFragment<typename decltype(fragment->data.f_dedicated_worker_token)::BaseType> value_fragment(fragment.message());
            mojo::internal::Serialize<::blink::mojom::DedicatedWorkerTokenDataView>(in_dedicated_worker_token, value_fragment);
            MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
                value_fragment.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null dedicated_worker_token in WorkerToken union");
            fragment->data.f_dedicated_worker_token.Set(value_fragment.is_null() ? nullptr : value_fragment.data());
            break;
        }
        case ::blink::mojom::WorkerTokenDataView::Tag::kServiceWorkerToken: {
            decltype(Traits::service_worker_token(input)) in_service_worker_token = Traits::service_worker_token(input);
            mojo::internal::MessageFragment<typename decltype(fragment->data.f_service_worker_token)::BaseType> value_fragment(fragment.message());
            mojo::internal::Serialize<::blink::mojom::ServiceWorkerTokenDataView>(in_service_worker_token, value_fragment);
            MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
                value_fragment.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null service_worker_token in WorkerToken union");
            fragment->data.f_service_worker_token.Set(value_fragment.is_null() ? nullptr : value_fragment.data());
            break;
        }
        case ::blink::mojom::WorkerTokenDataView::Tag::kSharedWorkerToken: {
            decltype(Traits::shared_worker_token(input)) in_shared_worker_token = Traits::shared_worker_token(input);
            mojo::internal::MessageFragment<typename decltype(fragment->data.f_shared_worker_token)::BaseType> value_fragment(fragment.message());
            mojo::internal::Serialize<::blink::mojom::SharedWorkerTokenDataView>(in_shared_worker_token, value_fragment);
            MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
                value_fragment.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null shared_worker_token in WorkerToken union");
            fragment->data.f_shared_worker_token.Set(value_fragment.is_null() ? nullptr : value_fragment.data());
            break;
        }
        }
    }

    static bool Deserialize(::blink::mojom::internal::WorkerToken_Data* input, UserType* output, Message* message)
    {
        if (!input || input->is_null())
            return CallSetToNullIfExists<Traits>(output);

        ::blink::mojom::WorkerTokenDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::WorkletTokenDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = UnionTraits<::blink::mojom::WorkletTokenDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, MessageFragment<::blink::mojom::internal::WorkletToken_Data>& fragment, bool inlined)
    {
        if (CallIsNullIfExists<Traits>(input)) {
            if (inlined)
                fragment->set_null();
            return;
        }

        if (!inlined)
            fragment.Allocate();

        // TODO(azani): Handle unknown and objects.
        // Set the not-null flag.
        fragment->size = kUnionDataSize;
        fragment->tag = Traits::GetTag(input);
        switch (fragment->tag) {
        case ::blink::mojom::WorkletTokenDataView::Tag::kAnimationWorkletToken: {
            decltype(Traits::animation_worklet_token(input)) in_animation_worklet_token = Traits::animation_worklet_token(input);
            mojo::internal::MessageFragment<typename decltype(fragment->data.f_animation_worklet_token)::BaseType> value_fragment(fragment.message());
            mojo::internal::Serialize<::blink::mojom::AnimationWorkletTokenDataView>(in_animation_worklet_token, value_fragment);
            MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
                value_fragment.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null animation_worklet_token in WorkletToken union");
            fragment->data.f_animation_worklet_token.Set(value_fragment.is_null() ? nullptr : value_fragment.data());
            break;
        }
        case ::blink::mojom::WorkletTokenDataView::Tag::kAudioWorkletToken: {
            decltype(Traits::audio_worklet_token(input)) in_audio_worklet_token = Traits::audio_worklet_token(input);
            mojo::internal::MessageFragment<typename decltype(fragment->data.f_audio_worklet_token)::BaseType> value_fragment(fragment.message());
            mojo::internal::Serialize<::blink::mojom::AudioWorkletTokenDataView>(in_audio_worklet_token, value_fragment);
            MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
                value_fragment.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null audio_worklet_token in WorkletToken union");
            fragment->data.f_audio_worklet_token.Set(value_fragment.is_null() ? nullptr : value_fragment.data());
            break;
        }
        case ::blink::mojom::WorkletTokenDataView::Tag::kLayoutWorkletToken: {
            decltype(Traits::layout_worklet_token(input)) in_layout_worklet_token = Traits::layout_worklet_token(input);
            mojo::internal::MessageFragment<typename decltype(fragment->data.f_layout_worklet_token)::BaseType> value_fragment(fragment.message());
            mojo::internal::Serialize<::blink::mojom::LayoutWorkletTokenDataView>(in_layout_worklet_token, value_fragment);
            MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
                value_fragment.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null layout_worklet_token in WorkletToken union");
            fragment->data.f_layout_worklet_token.Set(value_fragment.is_null() ? nullptr : value_fragment.data());
            break;
        }
        case ::blink::mojom::WorkletTokenDataView::Tag::kPaintWorkletToken: {
            decltype(Traits::paint_worklet_token(input)) in_paint_worklet_token = Traits::paint_worklet_token(input);
            mojo::internal::MessageFragment<typename decltype(fragment->data.f_paint_worklet_token)::BaseType> value_fragment(fragment.message());
            mojo::internal::Serialize<::blink::mojom::PaintWorkletTokenDataView>(in_paint_worklet_token, value_fragment);
            MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
                value_fragment.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null paint_worklet_token in WorkletToken union");
            fragment->data.f_paint_worklet_token.Set(value_fragment.is_null() ? nullptr : value_fragment.data());
            break;
        }
        case ::blink::mojom::WorkletTokenDataView::Tag::kSharedStorageWorkletToken: {
            decltype(Traits::shared_storage_worklet_token(input)) in_shared_storage_worklet_token = Traits::shared_storage_worklet_token(input);
            mojo::internal::MessageFragment<typename decltype(fragment->data.f_shared_storage_worklet_token)::BaseType> value_fragment(fragment.message());
            mojo::internal::Serialize<::blink::mojom::SharedStorageWorkletTokenDataView>(in_shared_storage_worklet_token, value_fragment);
            MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
                value_fragment.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null shared_storage_worklet_token in WorkletToken union");
            fragment->data.f_shared_storage_worklet_token.Set(value_fragment.is_null() ? nullptr : value_fragment.data());
            break;
        }
        }
    }

    static bool Deserialize(::blink::mojom::internal::WorkletToken_Data* input, UserType* output, Message* message)
    {
        if (!input || input->is_null())
            return CallSetToNullIfExists<Traits>(output);

        ::blink::mojom::WorkletTokenDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::ExecutionContextTokenDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = UnionTraits<::blink::mojom::ExecutionContextTokenDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, MessageFragment<::blink::mojom::internal::ExecutionContextToken_Data>& fragment, bool inlined)
    {
        if (CallIsNullIfExists<Traits>(input)) {
            if (inlined)
                fragment->set_null();
            return;
        }

        if (!inlined)
            fragment.Allocate();

        // TODO(azani): Handle unknown and objects.
        // Set the not-null flag.
        fragment->size = kUnionDataSize;
        fragment->tag = Traits::GetTag(input);
        switch (fragment->tag) {
        case ::blink::mojom::ExecutionContextTokenDataView::Tag::kLocalFrameToken: {
            decltype(Traits::local_frame_token(input)) in_local_frame_token = Traits::local_frame_token(input);
            mojo::internal::MessageFragment<typename decltype(fragment->data.f_local_frame_token)::BaseType> value_fragment(fragment.message());
            mojo::internal::Serialize<::blink::mojom::LocalFrameTokenDataView>(in_local_frame_token, value_fragment);
            MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
                value_fragment.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null local_frame_token in ExecutionContextToken union");
            fragment->data.f_local_frame_token.Set(value_fragment.is_null() ? nullptr : value_fragment.data());
            break;
        }
        case ::blink::mojom::ExecutionContextTokenDataView::Tag::kDedicatedWorkerToken: {
            decltype(Traits::dedicated_worker_token(input)) in_dedicated_worker_token = Traits::dedicated_worker_token(input);
            mojo::internal::MessageFragment<typename decltype(fragment->data.f_dedicated_worker_token)::BaseType> value_fragment(fragment.message());
            mojo::internal::Serialize<::blink::mojom::DedicatedWorkerTokenDataView>(in_dedicated_worker_token, value_fragment);
            MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(value_fragment.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
                "null dedicated_worker_token in ExecutionContextToken union");
            fragment->data.f_dedicated_worker_token.Set(value_fragment.is_null() ? nullptr : value_fragment.data());
            break;
        }
        case ::blink::mojom::ExecutionContextTokenDataView::Tag::kServiceWorkerToken: {
            decltype(Traits::service_worker_token(input)) in_service_worker_token = Traits::service_worker_token(input);
            mojo::internal::MessageFragment<typename decltype(fragment->data.f_service_worker_token)::BaseType> value_fragment(fragment.message());
            mojo::internal::Serialize<::blink::mojom::ServiceWorkerTokenDataView>(in_service_worker_token, value_fragment);
            MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
                value_fragment.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null service_worker_token in ExecutionContextToken union");
            fragment->data.f_service_worker_token.Set(value_fragment.is_null() ? nullptr : value_fragment.data());
            break;
        }
        case ::blink::mojom::ExecutionContextTokenDataView::Tag::kSharedWorkerToken: {
            decltype(Traits::shared_worker_token(input)) in_shared_worker_token = Traits::shared_worker_token(input);
            mojo::internal::MessageFragment<typename decltype(fragment->data.f_shared_worker_token)::BaseType> value_fragment(fragment.message());
            mojo::internal::Serialize<::blink::mojom::SharedWorkerTokenDataView>(in_shared_worker_token, value_fragment);
            MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
                value_fragment.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null shared_worker_token in ExecutionContextToken union");
            fragment->data.f_shared_worker_token.Set(value_fragment.is_null() ? nullptr : value_fragment.data());
            break;
        }
        case ::blink::mojom::ExecutionContextTokenDataView::Tag::kAnimationWorkletToken: {
            decltype(Traits::animation_worklet_token(input)) in_animation_worklet_token = Traits::animation_worklet_token(input);
            mojo::internal::MessageFragment<typename decltype(fragment->data.f_animation_worklet_token)::BaseType> value_fragment(fragment.message());
            mojo::internal::Serialize<::blink::mojom::AnimationWorkletTokenDataView>(in_animation_worklet_token, value_fragment);
            MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(value_fragment.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
                "null animation_worklet_token in ExecutionContextToken union");
            fragment->data.f_animation_worklet_token.Set(value_fragment.is_null() ? nullptr : value_fragment.data());
            break;
        }
        case ::blink::mojom::ExecutionContextTokenDataView::Tag::kAudioWorkletToken: {
            decltype(Traits::audio_worklet_token(input)) in_audio_worklet_token = Traits::audio_worklet_token(input);
            mojo::internal::MessageFragment<typename decltype(fragment->data.f_audio_worklet_token)::BaseType> value_fragment(fragment.message());
            mojo::internal::Serialize<::blink::mojom::AudioWorkletTokenDataView>(in_audio_worklet_token, value_fragment);
            MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
                value_fragment.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null audio_worklet_token in ExecutionContextToken union");
            fragment->data.f_audio_worklet_token.Set(value_fragment.is_null() ? nullptr : value_fragment.data());
            break;
        }
        case ::blink::mojom::ExecutionContextTokenDataView::Tag::kLayoutWorkletToken: {
            decltype(Traits::layout_worklet_token(input)) in_layout_worklet_token = Traits::layout_worklet_token(input);
            mojo::internal::MessageFragment<typename decltype(fragment->data.f_layout_worklet_token)::BaseType> value_fragment(fragment.message());
            mojo::internal::Serialize<::blink::mojom::LayoutWorkletTokenDataView>(in_layout_worklet_token, value_fragment);
            MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
                value_fragment.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null layout_worklet_token in ExecutionContextToken union");
            fragment->data.f_layout_worklet_token.Set(value_fragment.is_null() ? nullptr : value_fragment.data());
            break;
        }
        case ::blink::mojom::ExecutionContextTokenDataView::Tag::kPaintWorkletToken: {
            decltype(Traits::paint_worklet_token(input)) in_paint_worklet_token = Traits::paint_worklet_token(input);
            mojo::internal::MessageFragment<typename decltype(fragment->data.f_paint_worklet_token)::BaseType> value_fragment(fragment.message());
            mojo::internal::Serialize<::blink::mojom::PaintWorkletTokenDataView>(in_paint_worklet_token, value_fragment);
            MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
                value_fragment.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null paint_worklet_token in ExecutionContextToken union");
            fragment->data.f_paint_worklet_token.Set(value_fragment.is_null() ? nullptr : value_fragment.data());
            break;
        }
        case ::blink::mojom::ExecutionContextTokenDataView::Tag::kSharedStorageWorkletToken: {
            decltype(Traits::shared_storage_worklet_token(input)) in_shared_storage_worklet_token = Traits::shared_storage_worklet_token(input);
            mojo::internal::MessageFragment<typename decltype(fragment->data.f_shared_storage_worklet_token)::BaseType> value_fragment(fragment.message());
            mojo::internal::Serialize<::blink::mojom::SharedStorageWorkletTokenDataView>(in_shared_storage_worklet_token, value_fragment);
            MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(value_fragment.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
                "null shared_storage_worklet_token in ExecutionContextToken union");
            fragment->data.f_shared_storage_worklet_token.Set(value_fragment.is_null() ? nullptr : value_fragment.data());
            break;
        }
        case ::blink::mojom::ExecutionContextTokenDataView::Tag::kShadowRealmToken: {
            decltype(Traits::shadow_realm_token(input)) in_shadow_realm_token = Traits::shadow_realm_token(input);
            mojo::internal::MessageFragment<typename decltype(fragment->data.f_shadow_realm_token)::BaseType> value_fragment(fragment.message());
            mojo::internal::Serialize<::blink::mojom::ShadowRealmTokenDataView>(in_shadow_realm_token, value_fragment);
            MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
                value_fragment.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null shadow_realm_token in ExecutionContextToken union");
            fragment->data.f_shadow_realm_token.Set(value_fragment.is_null() ? nullptr : value_fragment.data());
            break;
        }
        }
    }

    static bool Deserialize(::blink::mojom::internal::ExecutionContextToken_Data* input, UserType* output, Message* message)
    {
        if (!input || input->is_null())
            return CallSetToNullIfExists<Traits>(output);

        ::blink::mojom::ExecutionContextTokenDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::WebGPUExecutionContextTokenDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = UnionTraits<::blink::mojom::WebGPUExecutionContextTokenDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, MessageFragment<::blink::mojom::internal::WebGPUExecutionContextToken_Data>& fragment, bool inlined)
    {
        if (CallIsNullIfExists<Traits>(input)) {
            if (inlined)
                fragment->set_null();
            return;
        }

        if (!inlined)
            fragment.Allocate();

        // TODO(azani): Handle unknown and objects.
        // Set the not-null flag.
        fragment->size = kUnionDataSize;
        fragment->tag = Traits::GetTag(input);
        switch (fragment->tag) {
        case ::blink::mojom::WebGPUExecutionContextTokenDataView::Tag::kDocumentToken: {
            decltype(Traits::document_token(input)) in_document_token = Traits::document_token(input);
            mojo::internal::MessageFragment<typename decltype(fragment->data.f_document_token)::BaseType> value_fragment(fragment.message());
            mojo::internal::Serialize<::blink::mojom::DocumentTokenDataView>(in_document_token, value_fragment);
            MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
                value_fragment.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null document_token in WebGPUExecutionContextToken union");
            fragment->data.f_document_token.Set(value_fragment.is_null() ? nullptr : value_fragment.data());
            break;
        }
        case ::blink::mojom::WebGPUExecutionContextTokenDataView::Tag::kDedicatedWorkerToken: {
            decltype(Traits::dedicated_worker_token(input)) in_dedicated_worker_token = Traits::dedicated_worker_token(input);
            mojo::internal::MessageFragment<typename decltype(fragment->data.f_dedicated_worker_token)::BaseType> value_fragment(fragment.message());
            mojo::internal::Serialize<::blink::mojom::DedicatedWorkerTokenDataView>(in_dedicated_worker_token, value_fragment);
            MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(value_fragment.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
                "null dedicated_worker_token in WebGPUExecutionContextToken union");
            fragment->data.f_dedicated_worker_token.Set(value_fragment.is_null() ? nullptr : value_fragment.data());
            break;
        }
        case ::blink::mojom::WebGPUExecutionContextTokenDataView::Tag::kSharedWorkerToken: {
            decltype(Traits::shared_worker_token(input)) in_shared_worker_token = Traits::shared_worker_token(input);
            mojo::internal::MessageFragment<typename decltype(fragment->data.f_shared_worker_token)::BaseType> value_fragment(fragment.message());
            mojo::internal::Serialize<::blink::mojom::SharedWorkerTokenDataView>(in_shared_worker_token, value_fragment);
            MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(value_fragment.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
                "null shared_worker_token in WebGPUExecutionContextToken union");
            fragment->data.f_shared_worker_token.Set(value_fragment.is_null() ? nullptr : value_fragment.data());
            break;
        }
        case ::blink::mojom::WebGPUExecutionContextTokenDataView::Tag::kServiceWorkerToken: {
            decltype(Traits::service_worker_token(input)) in_service_worker_token = Traits::service_worker_token(input);
            mojo::internal::MessageFragment<typename decltype(fragment->data.f_service_worker_token)::BaseType> value_fragment(fragment.message());
            mojo::internal::Serialize<::blink::mojom::ServiceWorkerTokenDataView>(in_service_worker_token, value_fragment);
            MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(value_fragment.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
                "null service_worker_token in WebGPUExecutionContextToken union");
            fragment->data.f_service_worker_token.Set(value_fragment.is_null() ? nullptr : value_fragment.data());
            break;
        }
        }
    }

    static bool Deserialize(::blink::mojom::internal::WebGPUExecutionContextToken_Data* input, UserType* output, Message* message)
    {
        if (!input || input->is_null())
            return CallSetToNullIfExists<Traits>(output);

        ::blink::mojom::WebGPUExecutionContextTokenDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

} // namespace mojo

namespace blink::mojom {

inline void DocumentTokenDataView::GetValueDataView(::mojo_base::mojom::UnguessableTokenDataView* output)
{
    auto pointer = data_->value.Get();
    *output = ::mojo_base::mojom::UnguessableTokenDataView(pointer, message_);
}

inline void LocalFrameTokenDataView::GetValueDataView(::mojo_base::mojom::UnguessableTokenDataView* output)
{
    auto pointer = data_->value.Get();
    *output = ::mojo_base::mojom::UnguessableTokenDataView(pointer, message_);
}

inline void RemoteFrameTokenDataView::GetValueDataView(::mojo_base::mojom::UnguessableTokenDataView* output)
{
    auto pointer = data_->value.Get();
    *output = ::mojo_base::mojom::UnguessableTokenDataView(pointer, message_);
}

inline void DedicatedWorkerTokenDataView::GetValueDataView(::mojo_base::mojom::UnguessableTokenDataView* output)
{
    auto pointer = data_->value.Get();
    *output = ::mojo_base::mojom::UnguessableTokenDataView(pointer, message_);
}

inline void ServiceWorkerTokenDataView::GetValueDataView(::mojo_base::mojom::UnguessableTokenDataView* output)
{
    auto pointer = data_->value.Get();
    *output = ::mojo_base::mojom::UnguessableTokenDataView(pointer, message_);
}

inline void SharedWorkerTokenDataView::GetValueDataView(::mojo_base::mojom::UnguessableTokenDataView* output)
{
    auto pointer = data_->value.Get();
    *output = ::mojo_base::mojom::UnguessableTokenDataView(pointer, message_);
}

inline void AnimationWorkletTokenDataView::GetValueDataView(::mojo_base::mojom::UnguessableTokenDataView* output)
{
    auto pointer = data_->value.Get();
    *output = ::mojo_base::mojom::UnguessableTokenDataView(pointer, message_);
}

inline void AudioWorkletTokenDataView::GetValueDataView(::mojo_base::mojom::UnguessableTokenDataView* output)
{
    auto pointer = data_->value.Get();
    *output = ::mojo_base::mojom::UnguessableTokenDataView(pointer, message_);
}

inline void LayoutWorkletTokenDataView::GetValueDataView(::mojo_base::mojom::UnguessableTokenDataView* output)
{
    auto pointer = data_->value.Get();
    *output = ::mojo_base::mojom::UnguessableTokenDataView(pointer, message_);
}

inline void PaintWorkletTokenDataView::GetValueDataView(::mojo_base::mojom::UnguessableTokenDataView* output)
{
    auto pointer = data_->value.Get();
    *output = ::mojo_base::mojom::UnguessableTokenDataView(pointer, message_);
}

inline void SharedStorageWorkletTokenDataView::GetValueDataView(::mojo_base::mojom::UnguessableTokenDataView* output)
{
    auto pointer = data_->value.Get();
    *output = ::mojo_base::mojom::UnguessableTokenDataView(pointer, message_);
}

inline void ShadowRealmTokenDataView::GetValueDataView(::mojo_base::mojom::UnguessableTokenDataView* output)
{
    auto pointer = data_->value.Get();
    *output = ::mojo_base::mojom::UnguessableTokenDataView(pointer, message_);
}

inline void AttributionSrcTokenDataView::GetValueDataView(::mojo_base::mojom::UnguessableTokenDataView* output)
{
    auto pointer = data_->value.Get();
    *output = ::mojo_base::mojom::UnguessableTokenDataView(pointer, message_);
}

inline void ClipboardSequenceNumberTokenDataView::GetValueDataView(::mojo_base::mojom::UnguessableTokenDataView* output)
{
    auto pointer = data_->value.Get();
    *output = ::mojo_base::mojom::UnguessableTokenDataView(pointer, message_);
}

inline void SameDocNavigationScreenshotDestinationTokenDataView::GetValueDataView(::mojo_base::mojom::UnguessableTokenDataView* output)
{
    auto pointer = data_->value.Get();
    *output = ::mojo_base::mojom::UnguessableTokenDataView(pointer, message_);
}

inline void V8ContextTokenDataView::GetValueDataView(::mojo_base::mojom::UnguessableTokenDataView* output)
{
    auto pointer = data_->value.Get();
    *output = ::mojo_base::mojom::UnguessableTokenDataView(pointer, message_);
}

inline void ViewTransitionTokenDataView::GetValueDataView(::mojo_base::mojom::UnguessableTokenDataView* output)
{
    auto pointer = data_->value.Get();
    *output = ::mojo_base::mojom::UnguessableTokenDataView(pointer, message_);
}

inline void WebNNContextTokenDataView::GetValueDataView(::mojo_base::mojom::UnguessableTokenDataView* output)
{
    auto pointer = data_->value.Get();
    *output = ::mojo_base::mojom::UnguessableTokenDataView(pointer, message_);
}

inline void WebNNTensorTokenDataView::GetValueDataView(::mojo_base::mojom::UnguessableTokenDataView* output)
{
    auto pointer = data_->value.Get();
    *output = ::mojo_base::mojom::UnguessableTokenDataView(pointer, message_);
}

inline void FrameTokenDataView::GetLocalFrameTokenDataView(LocalFrameTokenDataView* output) const
{
    CHECK(is_local_frame_token());
    *output = LocalFrameTokenDataView(data_->data.f_local_frame_token.Get(), message_);
}
inline void FrameTokenDataView::GetRemoteFrameTokenDataView(RemoteFrameTokenDataView* output) const
{
    CHECK(is_remote_frame_token());
    *output = RemoteFrameTokenDataView(data_->data.f_remote_frame_token.Get(), message_);
}

inline void WorkerTokenDataView::GetDedicatedWorkerTokenDataView(DedicatedWorkerTokenDataView* output) const
{
    CHECK(is_dedicated_worker_token());
    *output = DedicatedWorkerTokenDataView(data_->data.f_dedicated_worker_token.Get(), message_);
}
inline void WorkerTokenDataView::GetServiceWorkerTokenDataView(ServiceWorkerTokenDataView* output) const
{
    CHECK(is_service_worker_token());
    *output = ServiceWorkerTokenDataView(data_->data.f_service_worker_token.Get(), message_);
}
inline void WorkerTokenDataView::GetSharedWorkerTokenDataView(SharedWorkerTokenDataView* output) const
{
    CHECK(is_shared_worker_token());
    *output = SharedWorkerTokenDataView(data_->data.f_shared_worker_token.Get(), message_);
}

inline void WorkletTokenDataView::GetAnimationWorkletTokenDataView(AnimationWorkletTokenDataView* output) const
{
    CHECK(is_animation_worklet_token());
    *output = AnimationWorkletTokenDataView(data_->data.f_animation_worklet_token.Get(), message_);
}
inline void WorkletTokenDataView::GetAudioWorkletTokenDataView(AudioWorkletTokenDataView* output) const
{
    CHECK(is_audio_worklet_token());
    *output = AudioWorkletTokenDataView(data_->data.f_audio_worklet_token.Get(), message_);
}
inline void WorkletTokenDataView::GetLayoutWorkletTokenDataView(LayoutWorkletTokenDataView* output) const
{
    CHECK(is_layout_worklet_token());
    *output = LayoutWorkletTokenDataView(data_->data.f_layout_worklet_token.Get(), message_);
}
inline void WorkletTokenDataView::GetPaintWorkletTokenDataView(PaintWorkletTokenDataView* output) const
{
    CHECK(is_paint_worklet_token());
    *output = PaintWorkletTokenDataView(data_->data.f_paint_worklet_token.Get(), message_);
}
inline void WorkletTokenDataView::GetSharedStorageWorkletTokenDataView(SharedStorageWorkletTokenDataView* output) const
{
    CHECK(is_shared_storage_worklet_token());
    *output = SharedStorageWorkletTokenDataView(data_->data.f_shared_storage_worklet_token.Get(), message_);
}

inline void ExecutionContextTokenDataView::GetLocalFrameTokenDataView(LocalFrameTokenDataView* output) const
{
    CHECK(is_local_frame_token());
    *output = LocalFrameTokenDataView(data_->data.f_local_frame_token.Get(), message_);
}
inline void ExecutionContextTokenDataView::GetDedicatedWorkerTokenDataView(DedicatedWorkerTokenDataView* output) const
{
    CHECK(is_dedicated_worker_token());
    *output = DedicatedWorkerTokenDataView(data_->data.f_dedicated_worker_token.Get(), message_);
}
inline void ExecutionContextTokenDataView::GetServiceWorkerTokenDataView(ServiceWorkerTokenDataView* output) const
{
    CHECK(is_service_worker_token());
    *output = ServiceWorkerTokenDataView(data_->data.f_service_worker_token.Get(), message_);
}
inline void ExecutionContextTokenDataView::GetSharedWorkerTokenDataView(SharedWorkerTokenDataView* output) const
{
    CHECK(is_shared_worker_token());
    *output = SharedWorkerTokenDataView(data_->data.f_shared_worker_token.Get(), message_);
}
inline void ExecutionContextTokenDataView::GetAnimationWorkletTokenDataView(AnimationWorkletTokenDataView* output) const
{
    CHECK(is_animation_worklet_token());
    *output = AnimationWorkletTokenDataView(data_->data.f_animation_worklet_token.Get(), message_);
}
inline void ExecutionContextTokenDataView::GetAudioWorkletTokenDataView(AudioWorkletTokenDataView* output) const
{
    CHECK(is_audio_worklet_token());
    *output = AudioWorkletTokenDataView(data_->data.f_audio_worklet_token.Get(), message_);
}
inline void ExecutionContextTokenDataView::GetLayoutWorkletTokenDataView(LayoutWorkletTokenDataView* output) const
{
    CHECK(is_layout_worklet_token());
    *output = LayoutWorkletTokenDataView(data_->data.f_layout_worklet_token.Get(), message_);
}
inline void ExecutionContextTokenDataView::GetPaintWorkletTokenDataView(PaintWorkletTokenDataView* output) const
{
    CHECK(is_paint_worklet_token());
    *output = PaintWorkletTokenDataView(data_->data.f_paint_worklet_token.Get(), message_);
}
inline void ExecutionContextTokenDataView::GetSharedStorageWorkletTokenDataView(SharedStorageWorkletTokenDataView* output) const
{
    CHECK(is_shared_storage_worklet_token());
    *output = SharedStorageWorkletTokenDataView(data_->data.f_shared_storage_worklet_token.Get(), message_);
}
inline void ExecutionContextTokenDataView::GetShadowRealmTokenDataView(ShadowRealmTokenDataView* output) const
{
    CHECK(is_shadow_realm_token());
    *output = ShadowRealmTokenDataView(data_->data.f_shadow_realm_token.Get(), message_);
}

inline void WebGPUExecutionContextTokenDataView::GetDocumentTokenDataView(DocumentTokenDataView* output) const
{
    CHECK(is_document_token());
    *output = DocumentTokenDataView(data_->data.f_document_token.Get(), message_);
}
inline void WebGPUExecutionContextTokenDataView::GetDedicatedWorkerTokenDataView(DedicatedWorkerTokenDataView* output) const
{
    CHECK(is_dedicated_worker_token());
    *output = DedicatedWorkerTokenDataView(data_->data.f_dedicated_worker_token.Get(), message_);
}
inline void WebGPUExecutionContextTokenDataView::GetSharedWorkerTokenDataView(SharedWorkerTokenDataView* output) const
{
    CHECK(is_shared_worker_token());
    *output = SharedWorkerTokenDataView(data_->data.f_shared_worker_token.Get(), message_);
}
inline void WebGPUExecutionContextTokenDataView::GetServiceWorkerTokenDataView(ServiceWorkerTokenDataView* output) const
{
    CHECK(is_service_worker_token());
    *output = ServiceWorkerTokenDataView(data_->data.f_service_worker_token.Get(), message_);
}

} // blink::mojom

// Declare TraceFormatTraits for enums, which should be defined in ::perfetto
// namespace.

#endif // THIRD_PARTY_BLINK_PUBLIC_MOJOM_TOKENS_TOKENS_MOJOM_SHARED_H_
