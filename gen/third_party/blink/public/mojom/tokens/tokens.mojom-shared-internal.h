// third_party/blink/public/mojom/tokens/tokens.mojom-shared-internal.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef THIRD_PARTY_BLINK_PUBLIC_MOJOM_TOKENS_TOKENS_MOJOM_SHARED_INTERNAL_H_
#define THIRD_PARTY_BLINK_PUBLIC_MOJOM_TOKENS_TOKENS_MOJOM_SHARED_INTERNAL_H_
#include "mojo/public/cpp/bindings/lib/array_internal.h"
#include "mojo/public/cpp/bindings/lib/bindings_internal.h"
#include "mojo/public/cpp/bindings/lib/map_data_internal.h"
#include "mojo/public/cpp/bindings/lib/buffer.h"
#include "mojo/public/mojom/base/unguessable_token.mojom-shared-internal.h"
#include "mojo/public/cpp/bindings/lib/native_enum_data.h"
#include "mojo/public/interfaces/bindings/native_struct.mojom-shared-internal.h"
#include "base/component_export.h"

namespace mojo {
namespace internal {
class ValidationContext;
}
}

namespace blink::mojom {
namespace internal {
class DocumentToken_Data;
class LocalFrameToken_Data;
class RemoteFrameToken_Data;
class DedicatedWorkerToken_Data;
class ServiceWorkerToken_Data;
class SharedWorkerToken_Data;
class AnimationWorkletToken_Data;
class AudioWorkletToken_Data;
class LayoutWorkletToken_Data;
class PaintWorkletToken_Data;
class SharedStorageWorkletToken_Data;
class ShadowRealmToken_Data;
class AttributionSrcToken_Data;
class ClipboardSequenceNumberToken_Data;
class SameDocNavigationScreenshotDestinationToken_Data;
class V8ContextToken_Data;
class ViewTransitionToken_Data;
class WebNNContextToken_Data;
class WebNNTensorToken_Data;
class FrameToken_Data;
class WorkerToken_Data;
class WorkletToken_Data;
class ExecutionContextToken_Data;
class WebGPUExecutionContextToken_Data;

#pragma pack(push, 1)

class COMPONENT_EXPORT(TOKENS_MOJOM_SHARED) FrameToken_Data {
public:
    // Used to identify Mojom Union Data Classes.
    typedef void MojomUnionDataType;

    FrameToken_Data() = default;
    // Do nothing in the destructor since it won't be called when it is a
    // non-inlined union.
    ~FrameToken_Data() = default;

    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context, bool inlined);

    bool is_null() const
    {
        return size == 0;
    }

    void set_null()
    {
        size = 0U;
        tag = static_cast<FrameToken_Tag>(0);
        data.unknown = 0U;
    }

    // TODO(crbug.com/40731316): SHOUTY_CASE values are being deprecated per C++ code style
    // guidelines (https://google.github.io/styleguide/cppguide.html#Enumerator_Names),
    // please use kCamelCase values instead.  Cleanup NULL_VALUE, BOOL_VALUE, INT_VALUE, etc.
    // generation once codebase is transitioned to kNullValue, kBoolValue, kIntValue, etc.
    enum class FrameToken_Tag : uint32_t {

        kLocalFrameToken,

        kRemoteFrameToken,
    };

    // A note on layout:
    // "Each non-static data member is allocated as if it were the sole member of
    // a struct." - Section 9.5.2 ISO/IEC 14882:2011 (The C++ Spec)
    union MOJO_ALIGNAS(8) Union_ {
        Union_()
            : unknown(0)
        {
        }
        mojo::internal::Pointer<internal::LocalFrameToken_Data> f_local_frame_token;
        mojo::internal::Pointer<internal::RemoteFrameToken_Data> f_remote_frame_token;
        uint64_t unknown;
    };

    uint32_t size;
    FrameToken_Tag tag;
    Union_ data;
};
static_assert(sizeof(FrameToken_Data) == mojo::internal::kUnionDataSize, "Bad sizeof(FrameToken_Data)");

class COMPONENT_EXPORT(TOKENS_MOJOM_SHARED) WorkerToken_Data {
public:
    // Used to identify Mojom Union Data Classes.
    typedef void MojomUnionDataType;

    WorkerToken_Data() = default;
    // Do nothing in the destructor since it won't be called when it is a
    // non-inlined union.
    ~WorkerToken_Data() = default;

    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context, bool inlined);

    bool is_null() const
    {
        return size == 0;
    }

    void set_null()
    {
        size = 0U;
        tag = static_cast<WorkerToken_Tag>(0);
        data.unknown = 0U;
    }

    // TODO(crbug.com/40731316): SHOUTY_CASE values are being deprecated per C++ code style
    // guidelines (https://google.github.io/styleguide/cppguide.html#Enumerator_Names),
    // please use kCamelCase values instead.  Cleanup NULL_VALUE, BOOL_VALUE, INT_VALUE, etc.
    // generation once codebase is transitioned to kNullValue, kBoolValue, kIntValue, etc.
    enum class WorkerToken_Tag : uint32_t {

        kDedicatedWorkerToken,

        kServiceWorkerToken,

        kSharedWorkerToken,
    };

    // A note on layout:
    // "Each non-static data member is allocated as if it were the sole member of
    // a struct." - Section 9.5.2 ISO/IEC 14882:2011 (The C++ Spec)
    union MOJO_ALIGNAS(8) Union_ {
        Union_()
            : unknown(0)
        {
        }
        mojo::internal::Pointer<internal::DedicatedWorkerToken_Data> f_dedicated_worker_token;
        mojo::internal::Pointer<internal::ServiceWorkerToken_Data> f_service_worker_token;
        mojo::internal::Pointer<internal::SharedWorkerToken_Data> f_shared_worker_token;
        uint64_t unknown;
    };

    uint32_t size;
    WorkerToken_Tag tag;
    Union_ data;
};
static_assert(sizeof(WorkerToken_Data) == mojo::internal::kUnionDataSize, "Bad sizeof(WorkerToken_Data)");

class COMPONENT_EXPORT(TOKENS_MOJOM_SHARED) WorkletToken_Data {
public:
    // Used to identify Mojom Union Data Classes.
    typedef void MojomUnionDataType;

    WorkletToken_Data() = default;
    // Do nothing in the destructor since it won't be called when it is a
    // non-inlined union.
    ~WorkletToken_Data() = default;

    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context, bool inlined);

    bool is_null() const
    {
        return size == 0;
    }

    void set_null()
    {
        size = 0U;
        tag = static_cast<WorkletToken_Tag>(0);
        data.unknown = 0U;
    }

    // TODO(crbug.com/40731316): SHOUTY_CASE values are being deprecated per C++ code style
    // guidelines (https://google.github.io/styleguide/cppguide.html#Enumerator_Names),
    // please use kCamelCase values instead.  Cleanup NULL_VALUE, BOOL_VALUE, INT_VALUE, etc.
    // generation once codebase is transitioned to kNullValue, kBoolValue, kIntValue, etc.
    enum class WorkletToken_Tag : uint32_t {

        kAnimationWorkletToken,

        kAudioWorkletToken,

        kLayoutWorkletToken,

        kPaintWorkletToken,

        kSharedStorageWorkletToken,
    };

    // A note on layout:
    // "Each non-static data member is allocated as if it were the sole member of
    // a struct." - Section 9.5.2 ISO/IEC 14882:2011 (The C++ Spec)
    union MOJO_ALIGNAS(8) Union_ {
        Union_()
            : unknown(0)
        {
        }
        mojo::internal::Pointer<internal::AnimationWorkletToken_Data> f_animation_worklet_token;
        mojo::internal::Pointer<internal::AudioWorkletToken_Data> f_audio_worklet_token;
        mojo::internal::Pointer<internal::LayoutWorkletToken_Data> f_layout_worklet_token;
        mojo::internal::Pointer<internal::PaintWorkletToken_Data> f_paint_worklet_token;
        mojo::internal::Pointer<internal::SharedStorageWorkletToken_Data> f_shared_storage_worklet_token;
        uint64_t unknown;
    };

    uint32_t size;
    WorkletToken_Tag tag;
    Union_ data;
};
static_assert(sizeof(WorkletToken_Data) == mojo::internal::kUnionDataSize, "Bad sizeof(WorkletToken_Data)");

class COMPONENT_EXPORT(TOKENS_MOJOM_SHARED) ExecutionContextToken_Data {
public:
    // Used to identify Mojom Union Data Classes.
    typedef void MojomUnionDataType;

    ExecutionContextToken_Data() = default;
    // Do nothing in the destructor since it won't be called when it is a
    // non-inlined union.
    ~ExecutionContextToken_Data() = default;

    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context, bool inlined);

    bool is_null() const
    {
        return size == 0;
    }

    void set_null()
    {
        size = 0U;
        tag = static_cast<ExecutionContextToken_Tag>(0);
        data.unknown = 0U;
    }

    // TODO(crbug.com/40731316): SHOUTY_CASE values are being deprecated per C++ code style
    // guidelines (https://google.github.io/styleguide/cppguide.html#Enumerator_Names),
    // please use kCamelCase values instead.  Cleanup NULL_VALUE, BOOL_VALUE, INT_VALUE, etc.
    // generation once codebase is transitioned to kNullValue, kBoolValue, kIntValue, etc.
    enum class ExecutionContextToken_Tag : uint32_t {

        kLocalFrameToken,

        kDedicatedWorkerToken,

        kServiceWorkerToken,

        kSharedWorkerToken,

        kAnimationWorkletToken,

        kAudioWorkletToken,

        kLayoutWorkletToken,

        kPaintWorkletToken,

        kSharedStorageWorkletToken,

        kShadowRealmToken,
    };

    // A note on layout:
    // "Each non-static data member is allocated as if it were the sole member of
    // a struct." - Section 9.5.2 ISO/IEC 14882:2011 (The C++ Spec)
    union MOJO_ALIGNAS(8) Union_ {
        Union_()
            : unknown(0)
        {
        }
        mojo::internal::Pointer<internal::LocalFrameToken_Data> f_local_frame_token;
        mojo::internal::Pointer<internal::DedicatedWorkerToken_Data> f_dedicated_worker_token;
        mojo::internal::Pointer<internal::ServiceWorkerToken_Data> f_service_worker_token;
        mojo::internal::Pointer<internal::SharedWorkerToken_Data> f_shared_worker_token;
        mojo::internal::Pointer<internal::AnimationWorkletToken_Data> f_animation_worklet_token;
        mojo::internal::Pointer<internal::AudioWorkletToken_Data> f_audio_worklet_token;
        mojo::internal::Pointer<internal::LayoutWorkletToken_Data> f_layout_worklet_token;
        mojo::internal::Pointer<internal::PaintWorkletToken_Data> f_paint_worklet_token;
        mojo::internal::Pointer<internal::SharedStorageWorkletToken_Data> f_shared_storage_worklet_token;
        mojo::internal::Pointer<internal::ShadowRealmToken_Data> f_shadow_realm_token;
        uint64_t unknown;
    };

    uint32_t size;
    ExecutionContextToken_Tag tag;
    Union_ data;
};
static_assert(sizeof(ExecutionContextToken_Data) == mojo::internal::kUnionDataSize, "Bad sizeof(ExecutionContextToken_Data)");

class COMPONENT_EXPORT(TOKENS_MOJOM_SHARED) WebGPUExecutionContextToken_Data {
public:
    // Used to identify Mojom Union Data Classes.
    typedef void MojomUnionDataType;

    WebGPUExecutionContextToken_Data() = default;
    // Do nothing in the destructor since it won't be called when it is a
    // non-inlined union.
    ~WebGPUExecutionContextToken_Data() = default;

    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context, bool inlined);

    bool is_null() const
    {
        return size == 0;
    }

    void set_null()
    {
        size = 0U;
        tag = static_cast<WebGPUExecutionContextToken_Tag>(0);
        data.unknown = 0U;
    }

    // TODO(crbug.com/40731316): SHOUTY_CASE values are being deprecated per C++ code style
    // guidelines (https://google.github.io/styleguide/cppguide.html#Enumerator_Names),
    // please use kCamelCase values instead.  Cleanup NULL_VALUE, BOOL_VALUE, INT_VALUE, etc.
    // generation once codebase is transitioned to kNullValue, kBoolValue, kIntValue, etc.
    enum class WebGPUExecutionContextToken_Tag : uint32_t {

        kDocumentToken,

        kDedicatedWorkerToken,

        kSharedWorkerToken,

        kServiceWorkerToken,
    };

    // A note on layout:
    // "Each non-static data member is allocated as if it were the sole member of
    // a struct." - Section 9.5.2 ISO/IEC 14882:2011 (The C++ Spec)
    union MOJO_ALIGNAS(8) Union_ {
        Union_()
            : unknown(0)
        {
        }
        mojo::internal::Pointer<internal::DocumentToken_Data> f_document_token;
        mojo::internal::Pointer<internal::DedicatedWorkerToken_Data> f_dedicated_worker_token;
        mojo::internal::Pointer<internal::SharedWorkerToken_Data> f_shared_worker_token;
        mojo::internal::Pointer<internal::ServiceWorkerToken_Data> f_service_worker_token;
        uint64_t unknown;
    };

    uint32_t size;
    WebGPUExecutionContextToken_Tag tag;
    Union_ data;
};
static_assert(sizeof(WebGPUExecutionContextToken_Data) == mojo::internal::kUnionDataSize, "Bad sizeof(WebGPUExecutionContextToken_Data)");
class COMPONENT_EXPORT(TOKENS_MOJOM_SHARED) DocumentToken_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    mojo::internal::Pointer<::mojo_base::mojom::internal::UnguessableToken_Data> value;

private:
    friend class mojo::internal::MessageFragment<DocumentToken_Data>;

    DocumentToken_Data();
    ~DocumentToken_Data() = delete;
};
static_assert(sizeof(DocumentToken_Data) == 16, "Bad sizeof(DocumentToken_Data)");
// Used by DocumentToken::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct DocumentToken_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    DocumentToken_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~DocumentToken_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<DocumentToken_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag DocumentToken_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class COMPONENT_EXPORT(TOKENS_MOJOM_SHARED) LocalFrameToken_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    mojo::internal::Pointer<::mojo_base::mojom::internal::UnguessableToken_Data> value;

private:
    friend class mojo::internal::MessageFragment<LocalFrameToken_Data>;

    LocalFrameToken_Data();
    ~LocalFrameToken_Data() = delete;
};
static_assert(sizeof(LocalFrameToken_Data) == 16, "Bad sizeof(LocalFrameToken_Data)");
// Used by LocalFrameToken::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct LocalFrameToken_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    LocalFrameToken_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~LocalFrameToken_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<LocalFrameToken_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag LocalFrameToken_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class COMPONENT_EXPORT(TOKENS_MOJOM_SHARED) RemoteFrameToken_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    mojo::internal::Pointer<::mojo_base::mojom::internal::UnguessableToken_Data> value;

private:
    friend class mojo::internal::MessageFragment<RemoteFrameToken_Data>;

    RemoteFrameToken_Data();
    ~RemoteFrameToken_Data() = delete;
};
static_assert(sizeof(RemoteFrameToken_Data) == 16, "Bad sizeof(RemoteFrameToken_Data)");
// Used by RemoteFrameToken::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct RemoteFrameToken_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    RemoteFrameToken_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~RemoteFrameToken_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<RemoteFrameToken_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag RemoteFrameToken_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class COMPONENT_EXPORT(TOKENS_MOJOM_SHARED) DedicatedWorkerToken_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    mojo::internal::Pointer<::mojo_base::mojom::internal::UnguessableToken_Data> value;

private:
    friend class mojo::internal::MessageFragment<DedicatedWorkerToken_Data>;

    DedicatedWorkerToken_Data();
    ~DedicatedWorkerToken_Data() = delete;
};
static_assert(sizeof(DedicatedWorkerToken_Data) == 16, "Bad sizeof(DedicatedWorkerToken_Data)");
// Used by DedicatedWorkerToken::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct DedicatedWorkerToken_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    DedicatedWorkerToken_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~DedicatedWorkerToken_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<DedicatedWorkerToken_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag DedicatedWorkerToken_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class COMPONENT_EXPORT(TOKENS_MOJOM_SHARED) ServiceWorkerToken_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    mojo::internal::Pointer<::mojo_base::mojom::internal::UnguessableToken_Data> value;

private:
    friend class mojo::internal::MessageFragment<ServiceWorkerToken_Data>;

    ServiceWorkerToken_Data();
    ~ServiceWorkerToken_Data() = delete;
};
static_assert(sizeof(ServiceWorkerToken_Data) == 16, "Bad sizeof(ServiceWorkerToken_Data)");
// Used by ServiceWorkerToken::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct ServiceWorkerToken_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    ServiceWorkerToken_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~ServiceWorkerToken_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<ServiceWorkerToken_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag ServiceWorkerToken_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class COMPONENT_EXPORT(TOKENS_MOJOM_SHARED) SharedWorkerToken_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    mojo::internal::Pointer<::mojo_base::mojom::internal::UnguessableToken_Data> value;

private:
    friend class mojo::internal::MessageFragment<SharedWorkerToken_Data>;

    SharedWorkerToken_Data();
    ~SharedWorkerToken_Data() = delete;
};
static_assert(sizeof(SharedWorkerToken_Data) == 16, "Bad sizeof(SharedWorkerToken_Data)");
// Used by SharedWorkerToken::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct SharedWorkerToken_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    SharedWorkerToken_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~SharedWorkerToken_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<SharedWorkerToken_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag SharedWorkerToken_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class COMPONENT_EXPORT(TOKENS_MOJOM_SHARED) AnimationWorkletToken_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    mojo::internal::Pointer<::mojo_base::mojom::internal::UnguessableToken_Data> value;

private:
    friend class mojo::internal::MessageFragment<AnimationWorkletToken_Data>;

    AnimationWorkletToken_Data();
    ~AnimationWorkletToken_Data() = delete;
};
static_assert(sizeof(AnimationWorkletToken_Data) == 16, "Bad sizeof(AnimationWorkletToken_Data)");
// Used by AnimationWorkletToken::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct AnimationWorkletToken_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    AnimationWorkletToken_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~AnimationWorkletToken_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<AnimationWorkletToken_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag AnimationWorkletToken_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class COMPONENT_EXPORT(TOKENS_MOJOM_SHARED) AudioWorkletToken_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    mojo::internal::Pointer<::mojo_base::mojom::internal::UnguessableToken_Data> value;

private:
    friend class mojo::internal::MessageFragment<AudioWorkletToken_Data>;

    AudioWorkletToken_Data();
    ~AudioWorkletToken_Data() = delete;
};
static_assert(sizeof(AudioWorkletToken_Data) == 16, "Bad sizeof(AudioWorkletToken_Data)");
// Used by AudioWorkletToken::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct AudioWorkletToken_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    AudioWorkletToken_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~AudioWorkletToken_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<AudioWorkletToken_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag AudioWorkletToken_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class COMPONENT_EXPORT(TOKENS_MOJOM_SHARED) LayoutWorkletToken_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    mojo::internal::Pointer<::mojo_base::mojom::internal::UnguessableToken_Data> value;

private:
    friend class mojo::internal::MessageFragment<LayoutWorkletToken_Data>;

    LayoutWorkletToken_Data();
    ~LayoutWorkletToken_Data() = delete;
};
static_assert(sizeof(LayoutWorkletToken_Data) == 16, "Bad sizeof(LayoutWorkletToken_Data)");
// Used by LayoutWorkletToken::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct LayoutWorkletToken_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    LayoutWorkletToken_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~LayoutWorkletToken_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<LayoutWorkletToken_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag LayoutWorkletToken_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class COMPONENT_EXPORT(TOKENS_MOJOM_SHARED) PaintWorkletToken_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    mojo::internal::Pointer<::mojo_base::mojom::internal::UnguessableToken_Data> value;

private:
    friend class mojo::internal::MessageFragment<PaintWorkletToken_Data>;

    PaintWorkletToken_Data();
    ~PaintWorkletToken_Data() = delete;
};
static_assert(sizeof(PaintWorkletToken_Data) == 16, "Bad sizeof(PaintWorkletToken_Data)");
// Used by PaintWorkletToken::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct PaintWorkletToken_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    PaintWorkletToken_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~PaintWorkletToken_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<PaintWorkletToken_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag PaintWorkletToken_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class COMPONENT_EXPORT(TOKENS_MOJOM_SHARED) SharedStorageWorkletToken_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    mojo::internal::Pointer<::mojo_base::mojom::internal::UnguessableToken_Data> value;

private:
    friend class mojo::internal::MessageFragment<SharedStorageWorkletToken_Data>;

    SharedStorageWorkletToken_Data();
    ~SharedStorageWorkletToken_Data() = delete;
};
static_assert(sizeof(SharedStorageWorkletToken_Data) == 16, "Bad sizeof(SharedStorageWorkletToken_Data)");
// Used by SharedStorageWorkletToken::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct SharedStorageWorkletToken_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    SharedStorageWorkletToken_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~SharedStorageWorkletToken_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<SharedStorageWorkletToken_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag SharedStorageWorkletToken_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class COMPONENT_EXPORT(TOKENS_MOJOM_SHARED) ShadowRealmToken_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    mojo::internal::Pointer<::mojo_base::mojom::internal::UnguessableToken_Data> value;

private:
    friend class mojo::internal::MessageFragment<ShadowRealmToken_Data>;

    ShadowRealmToken_Data();
    ~ShadowRealmToken_Data() = delete;
};
static_assert(sizeof(ShadowRealmToken_Data) == 16, "Bad sizeof(ShadowRealmToken_Data)");
// Used by ShadowRealmToken::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct ShadowRealmToken_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    ShadowRealmToken_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~ShadowRealmToken_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<ShadowRealmToken_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag ShadowRealmToken_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class COMPONENT_EXPORT(TOKENS_MOJOM_SHARED) AttributionSrcToken_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    mojo::internal::Pointer<::mojo_base::mojom::internal::UnguessableToken_Data> value;

private:
    friend class mojo::internal::MessageFragment<AttributionSrcToken_Data>;

    AttributionSrcToken_Data();
    ~AttributionSrcToken_Data() = delete;
};
static_assert(sizeof(AttributionSrcToken_Data) == 16, "Bad sizeof(AttributionSrcToken_Data)");
// Used by AttributionSrcToken::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct AttributionSrcToken_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    AttributionSrcToken_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~AttributionSrcToken_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<AttributionSrcToken_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag AttributionSrcToken_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class COMPONENT_EXPORT(TOKENS_MOJOM_SHARED) ClipboardSequenceNumberToken_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    mojo::internal::Pointer<::mojo_base::mojom::internal::UnguessableToken_Data> value;

private:
    friend class mojo::internal::MessageFragment<ClipboardSequenceNumberToken_Data>;

    ClipboardSequenceNumberToken_Data();
    ~ClipboardSequenceNumberToken_Data() = delete;
};
static_assert(sizeof(ClipboardSequenceNumberToken_Data) == 16, "Bad sizeof(ClipboardSequenceNumberToken_Data)");
// Used by ClipboardSequenceNumberToken::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct ClipboardSequenceNumberToken_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    ClipboardSequenceNumberToken_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~ClipboardSequenceNumberToken_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<ClipboardSequenceNumberToken_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag ClipboardSequenceNumberToken_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class COMPONENT_EXPORT(TOKENS_MOJOM_SHARED) SameDocNavigationScreenshotDestinationToken_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    mojo::internal::Pointer<::mojo_base::mojom::internal::UnguessableToken_Data> value;

private:
    friend class mojo::internal::MessageFragment<SameDocNavigationScreenshotDestinationToken_Data>;

    SameDocNavigationScreenshotDestinationToken_Data();
    ~SameDocNavigationScreenshotDestinationToken_Data() = delete;
};
static_assert(sizeof(SameDocNavigationScreenshotDestinationToken_Data) == 16, "Bad sizeof(SameDocNavigationScreenshotDestinationToken_Data)");
// Used by SameDocNavigationScreenshotDestinationToken::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct SameDocNavigationScreenshotDestinationToken_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    SameDocNavigationScreenshotDestinationToken_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~SameDocNavigationScreenshotDestinationToken_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<SameDocNavigationScreenshotDestinationToken_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag SameDocNavigationScreenshotDestinationToken_UnserializedMessageContext<UserType, DataView>::kMessageTag
    = {};
class COMPONENT_EXPORT(TOKENS_MOJOM_SHARED) V8ContextToken_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    mojo::internal::Pointer<::mojo_base::mojom::internal::UnguessableToken_Data> value;

private:
    friend class mojo::internal::MessageFragment<V8ContextToken_Data>;

    V8ContextToken_Data();
    ~V8ContextToken_Data() = delete;
};
static_assert(sizeof(V8ContextToken_Data) == 16, "Bad sizeof(V8ContextToken_Data)");
// Used by V8ContextToken::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct V8ContextToken_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    V8ContextToken_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~V8ContextToken_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<V8ContextToken_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag V8ContextToken_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class COMPONENT_EXPORT(TOKENS_MOJOM_SHARED) ViewTransitionToken_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    mojo::internal::Pointer<::mojo_base::mojom::internal::UnguessableToken_Data> value;

private:
    friend class mojo::internal::MessageFragment<ViewTransitionToken_Data>;

    ViewTransitionToken_Data();
    ~ViewTransitionToken_Data() = delete;
};
static_assert(sizeof(ViewTransitionToken_Data) == 16, "Bad sizeof(ViewTransitionToken_Data)");
// Used by ViewTransitionToken::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct ViewTransitionToken_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    ViewTransitionToken_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~ViewTransitionToken_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<ViewTransitionToken_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag ViewTransitionToken_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class COMPONENT_EXPORT(TOKENS_MOJOM_SHARED) WebNNContextToken_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    mojo::internal::Pointer<::mojo_base::mojom::internal::UnguessableToken_Data> value;

private:
    friend class mojo::internal::MessageFragment<WebNNContextToken_Data>;

    WebNNContextToken_Data();
    ~WebNNContextToken_Data() = delete;
};
static_assert(sizeof(WebNNContextToken_Data) == 16, "Bad sizeof(WebNNContextToken_Data)");
// Used by WebNNContextToken::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct WebNNContextToken_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    WebNNContextToken_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~WebNNContextToken_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<WebNNContextToken_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag WebNNContextToken_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class COMPONENT_EXPORT(TOKENS_MOJOM_SHARED) WebNNTensorToken_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    mojo::internal::Pointer<::mojo_base::mojom::internal::UnguessableToken_Data> value;

private:
    friend class mojo::internal::MessageFragment<WebNNTensorToken_Data>;

    WebNNTensorToken_Data();
    ~WebNNTensorToken_Data() = delete;
};
static_assert(sizeof(WebNNTensorToken_Data) == 16, "Bad sizeof(WebNNTensorToken_Data)");
// Used by WebNNTensorToken::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct WebNNTensorToken_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    WebNNTensorToken_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~WebNNTensorToken_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<WebNNTensorToken_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag WebNNTensorToken_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};

#pragma pack(pop)

} // namespace internal

} // blink::mojom

#endif // THIRD_PARTY_BLINK_PUBLIC_MOJOM_TOKENS_TOKENS_MOJOM_SHARED_INTERNAL_H_
