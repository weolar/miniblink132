// third_party/blink/public/mojom/tokens/tokens.mojom.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif

#include "third_party/blink/public/mojom/tokens/tokens.mojom.h"

#include <math.h>
#include <stdint.h>
#include <utility>

#include "base/debug/alias.h"
#include "base/hash/md5_constexpr.h"
#include "base/run_loop.h"
#include "base/strings/string_number_conversions.h"
#include "base/task/thread_pool/thread_pool_instance.h"
#include "base/trace_event/trace_event.h"
#include "base/trace_event/typed_macros.h"
#include "mojo/public/cpp/bindings/features.h"
#include "mojo/public/cpp/bindings/lib/default_construct_tag_internal.h"
#include "mojo/public/cpp/bindings/lib/generated_code_util.h"
#include "mojo/public/cpp/bindings/lib/message_internal.h"
#include "mojo/public/cpp/bindings/lib/proxy_to_responder.h"
#include "mojo/public/cpp/bindings/lib/send_message_helper.h"
#include "mojo/public/cpp/bindings/lib/serialization_util.h"
#include "mojo/public/cpp/bindings/lib/unserialized_message_context.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/mojo_buildflags.h"
#include "mojo/public/cpp/bindings/urgent_message_scope.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"
#include "third_party/perfetto/include/perfetto/tracing/traced_value.h"

#include "third_party/blink/public/mojom/tokens/tokens.mojom-params-data.h"
#include "third_party/blink/public/mojom/tokens/tokens.mojom-shared-message-ids.h"

#include "third_party/blink/public/mojom/tokens/tokens.mojom-import-headers.h"
#include "third_party/blink/public/mojom/tokens/tokens.mojom-test-utils.h"

namespace blink::mojom {
DocumentToken::DocumentToken()
    : value()
{
}

DocumentToken::DocumentToken(const ::base::UnguessableToken& value_in)
    : value(std::move(value_in))
{
}

DocumentToken::~DocumentToken() = default;

void DocumentToken::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("value"), this->value,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const ::base::UnguessableToken&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool DocumentToken::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
LocalFrameToken::LocalFrameToken()
    : value()
{
}

LocalFrameToken::LocalFrameToken(const ::base::UnguessableToken& value_in)
    : value(std::move(value_in))
{
}

LocalFrameToken::~LocalFrameToken() = default;

void LocalFrameToken::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("value"), this->value,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const ::base::UnguessableToken&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool LocalFrameToken::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
RemoteFrameToken::RemoteFrameToken()
    : value()
{
}

RemoteFrameToken::RemoteFrameToken(const ::base::UnguessableToken& value_in)
    : value(std::move(value_in))
{
}

RemoteFrameToken::~RemoteFrameToken() = default;

void RemoteFrameToken::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("value"), this->value,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const ::base::UnguessableToken&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool RemoteFrameToken::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
DedicatedWorkerToken::DedicatedWorkerToken()
    : value()
{
}

DedicatedWorkerToken::DedicatedWorkerToken(const ::base::UnguessableToken& value_in)
    : value(std::move(value_in))
{
}

DedicatedWorkerToken::~DedicatedWorkerToken() = default;

void DedicatedWorkerToken::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("value"), this->value,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const ::base::UnguessableToken&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool DedicatedWorkerToken::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
ServiceWorkerToken::ServiceWorkerToken()
    : value()
{
}

ServiceWorkerToken::ServiceWorkerToken(const ::base::UnguessableToken& value_in)
    : value(std::move(value_in))
{
}

ServiceWorkerToken::~ServiceWorkerToken() = default;

void ServiceWorkerToken::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("value"), this->value,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const ::base::UnguessableToken&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool ServiceWorkerToken::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
SharedWorkerToken::SharedWorkerToken()
    : value()
{
}

SharedWorkerToken::SharedWorkerToken(const ::base::UnguessableToken& value_in)
    : value(std::move(value_in))
{
}

SharedWorkerToken::~SharedWorkerToken() = default;

void SharedWorkerToken::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("value"), this->value,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const ::base::UnguessableToken&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool SharedWorkerToken::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
AnimationWorkletToken::AnimationWorkletToken()
    : value()
{
}

AnimationWorkletToken::AnimationWorkletToken(const ::base::UnguessableToken& value_in)
    : value(std::move(value_in))
{
}

AnimationWorkletToken::~AnimationWorkletToken() = default;

void AnimationWorkletToken::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("value"), this->value,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const ::base::UnguessableToken&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool AnimationWorkletToken::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
AudioWorkletToken::AudioWorkletToken()
    : value()
{
}

AudioWorkletToken::AudioWorkletToken(const ::base::UnguessableToken& value_in)
    : value(std::move(value_in))
{
}

AudioWorkletToken::~AudioWorkletToken() = default;

void AudioWorkletToken::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("value"), this->value,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const ::base::UnguessableToken&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool AudioWorkletToken::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
LayoutWorkletToken::LayoutWorkletToken()
    : value()
{
}

LayoutWorkletToken::LayoutWorkletToken(const ::base::UnguessableToken& value_in)
    : value(std::move(value_in))
{
}

LayoutWorkletToken::~LayoutWorkletToken() = default;

void LayoutWorkletToken::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("value"), this->value,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const ::base::UnguessableToken&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool LayoutWorkletToken::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
PaintWorkletToken::PaintWorkletToken()
    : value()
{
}

PaintWorkletToken::PaintWorkletToken(const ::base::UnguessableToken& value_in)
    : value(std::move(value_in))
{
}

PaintWorkletToken::~PaintWorkletToken() = default;

void PaintWorkletToken::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("value"), this->value,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const ::base::UnguessableToken&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool PaintWorkletToken::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
SharedStorageWorkletToken::SharedStorageWorkletToken()
    : value()
{
}

SharedStorageWorkletToken::SharedStorageWorkletToken(const ::base::UnguessableToken& value_in)
    : value(std::move(value_in))
{
}

SharedStorageWorkletToken::~SharedStorageWorkletToken() = default;

void SharedStorageWorkletToken::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("value"), this->value,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const ::base::UnguessableToken&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool SharedStorageWorkletToken::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
ShadowRealmToken::ShadowRealmToken()
    : value()
{
}

ShadowRealmToken::ShadowRealmToken(const ::base::UnguessableToken& value_in)
    : value(std::move(value_in))
{
}

ShadowRealmToken::~ShadowRealmToken() = default;

void ShadowRealmToken::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("value"), this->value,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const ::base::UnguessableToken&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool ShadowRealmToken::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
AttributionSrcToken::AttributionSrcToken()
    : value()
{
}

AttributionSrcToken::AttributionSrcToken(const ::base::UnguessableToken& value_in)
    : value(std::move(value_in))
{
}

AttributionSrcToken::~AttributionSrcToken() = default;

void AttributionSrcToken::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("value"), this->value,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const ::base::UnguessableToken&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool AttributionSrcToken::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
ClipboardSequenceNumberToken::ClipboardSequenceNumberToken()
    : value()
{
}

ClipboardSequenceNumberToken::ClipboardSequenceNumberToken(const ::base::UnguessableToken& value_in)
    : value(std::move(value_in))
{
}

ClipboardSequenceNumberToken::~ClipboardSequenceNumberToken() = default;

void ClipboardSequenceNumberToken::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("value"), this->value,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const ::base::UnguessableToken&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool ClipboardSequenceNumberToken::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
SameDocNavigationScreenshotDestinationToken::SameDocNavigationScreenshotDestinationToken()
    : value()
{
}

SameDocNavigationScreenshotDestinationToken::SameDocNavigationScreenshotDestinationToken(const ::base::UnguessableToken& value_in)
    : value(std::move(value_in))
{
}

SameDocNavigationScreenshotDestinationToken::~SameDocNavigationScreenshotDestinationToken() = default;

void SameDocNavigationScreenshotDestinationToken::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("value"), this->value,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const ::base::UnguessableToken&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool SameDocNavigationScreenshotDestinationToken::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
V8ContextToken::V8ContextToken()
    : value()
{
}

V8ContextToken::V8ContextToken(const ::base::UnguessableToken& value_in)
    : value(std::move(value_in))
{
}

V8ContextToken::~V8ContextToken() = default;

void V8ContextToken::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("value"), this->value,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const ::base::UnguessableToken&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool V8ContextToken::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
ViewTransitionToken::ViewTransitionToken()
    : value()
{
}

ViewTransitionToken::ViewTransitionToken(const ::base::UnguessableToken& value_in)
    : value(std::move(value_in))
{
}

ViewTransitionToken::~ViewTransitionToken() = default;

void ViewTransitionToken::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("value"), this->value,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const ::base::UnguessableToken&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool ViewTransitionToken::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
WebNNContextToken::WebNNContextToken()
    : value()
{
}

WebNNContextToken::WebNNContextToken(const ::base::UnguessableToken& value_in)
    : value(std::move(value_in))
{
}

WebNNContextToken::~WebNNContextToken() = default;

void WebNNContextToken::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("value"), this->value,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const ::base::UnguessableToken&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool WebNNContextToken::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
WebNNTensorToken::WebNNTensorToken()
    : value()
{
}

WebNNTensorToken::WebNNTensorToken(const ::base::UnguessableToken& value_in)
    : value(std::move(value_in))
{
}

WebNNTensorToken::~WebNNTensorToken() = default;

void WebNNTensorToken::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("value"), this->value,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const ::base::UnguessableToken&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool WebNNTensorToken::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
FrameToken::FrameToken()
    : tag_(Tag::kLocalFrameToken)
{
    data_.local_frame_token = new ::blink::LocalFrameToken;
}

FrameToken::~FrameToken()
{
    DestroyActive();
}

void FrameToken::set_local_frame_token(const ::blink::LocalFrameToken& local_frame_token)
{
    if (tag_ == Tag::kLocalFrameToken) {
        *(data_.local_frame_token) = std::move(local_frame_token);
    } else {
        DestroyActive();
        tag_ = Tag::kLocalFrameToken;
        data_.local_frame_token = new ::blink::LocalFrameToken(std::move(local_frame_token));
    }
}
void FrameToken::set_remote_frame_token(const ::blink::RemoteFrameToken& remote_frame_token)
{
    if (tag_ == Tag::kRemoteFrameToken) {
        *(data_.remote_frame_token) = std::move(remote_frame_token);
    } else {
        DestroyActive();
        tag_ = Tag::kRemoteFrameToken;
        data_.remote_frame_token = new ::blink::RemoteFrameToken(std::move(remote_frame_token));
    }
}

void FrameToken::DestroyActive()
{
    switch (tag_) {

    case Tag::kLocalFrameToken:

        delete data_.local_frame_token;
        break;
    case Tag::kRemoteFrameToken:

        delete data_.remote_frame_token;
        break;
    }
}

bool FrameToken::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context, false);
}
WorkerToken::WorkerToken()
    : tag_(Tag::kDedicatedWorkerToken)
{
    data_.dedicated_worker_token = new ::blink::DedicatedWorkerToken;
}

WorkerToken::~WorkerToken()
{
    DestroyActive();
}

void WorkerToken::set_dedicated_worker_token(const ::blink::DedicatedWorkerToken& dedicated_worker_token)
{
    if (tag_ == Tag::kDedicatedWorkerToken) {
        *(data_.dedicated_worker_token) = std::move(dedicated_worker_token);
    } else {
        DestroyActive();
        tag_ = Tag::kDedicatedWorkerToken;
        data_.dedicated_worker_token = new ::blink::DedicatedWorkerToken(std::move(dedicated_worker_token));
    }
}
void WorkerToken::set_service_worker_token(const ::blink::ServiceWorkerToken& service_worker_token)
{
    if (tag_ == Tag::kServiceWorkerToken) {
        *(data_.service_worker_token) = std::move(service_worker_token);
    } else {
        DestroyActive();
        tag_ = Tag::kServiceWorkerToken;
        data_.service_worker_token = new ::blink::ServiceWorkerToken(std::move(service_worker_token));
    }
}
void WorkerToken::set_shared_worker_token(const ::blink::SharedWorkerToken& shared_worker_token)
{
    if (tag_ == Tag::kSharedWorkerToken) {
        *(data_.shared_worker_token) = std::move(shared_worker_token);
    } else {
        DestroyActive();
        tag_ = Tag::kSharedWorkerToken;
        data_.shared_worker_token = new ::blink::SharedWorkerToken(std::move(shared_worker_token));
    }
}

void WorkerToken::DestroyActive()
{
    switch (tag_) {

    case Tag::kDedicatedWorkerToken:

        delete data_.dedicated_worker_token;
        break;
    case Tag::kServiceWorkerToken:

        delete data_.service_worker_token;
        break;
    case Tag::kSharedWorkerToken:

        delete data_.shared_worker_token;
        break;
    }
}

bool WorkerToken::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context, false);
}
WorkletToken::WorkletToken()
    : tag_(Tag::kAnimationWorkletToken)
{
    data_.animation_worklet_token = new ::blink::AnimationWorkletToken;
}

WorkletToken::~WorkletToken()
{
    DestroyActive();
}

void WorkletToken::set_animation_worklet_token(const ::blink::AnimationWorkletToken& animation_worklet_token)
{
    if (tag_ == Tag::kAnimationWorkletToken) {
        *(data_.animation_worklet_token) = std::move(animation_worklet_token);
    } else {
        DestroyActive();
        tag_ = Tag::kAnimationWorkletToken;
        data_.animation_worklet_token = new ::blink::AnimationWorkletToken(std::move(animation_worklet_token));
    }
}
void WorkletToken::set_audio_worklet_token(const ::blink::AudioWorkletToken& audio_worklet_token)
{
    if (tag_ == Tag::kAudioWorkletToken) {
        *(data_.audio_worklet_token) = std::move(audio_worklet_token);
    } else {
        DestroyActive();
        tag_ = Tag::kAudioWorkletToken;
        data_.audio_worklet_token = new ::blink::AudioWorkletToken(std::move(audio_worklet_token));
    }
}
void WorkletToken::set_layout_worklet_token(LayoutWorkletTokenPtr layout_worklet_token)
{
    if (tag_ == Tag::kLayoutWorkletToken) {
        *(data_.layout_worklet_token) = std::move(layout_worklet_token);
    } else {
        DestroyActive();
        tag_ = Tag::kLayoutWorkletToken;
        data_.layout_worklet_token = new LayoutWorkletTokenPtr(std::move(layout_worklet_token));
    }
}
void WorkletToken::set_paint_worklet_token(const ::blink::PaintWorkletToken& paint_worklet_token)
{
    if (tag_ == Tag::kPaintWorkletToken) {
        *(data_.paint_worklet_token) = std::move(paint_worklet_token);
    } else {
        DestroyActive();
        tag_ = Tag::kPaintWorkletToken;
        data_.paint_worklet_token = new ::blink::PaintWorkletToken(std::move(paint_worklet_token));
    }
}
void WorkletToken::set_shared_storage_worklet_token(SharedStorageWorkletTokenPtr shared_storage_worklet_token)
{
    if (tag_ == Tag::kSharedStorageWorkletToken) {
        *(data_.shared_storage_worklet_token) = std::move(shared_storage_worklet_token);
    } else {
        DestroyActive();
        tag_ = Tag::kSharedStorageWorkletToken;
        data_.shared_storage_worklet_token = new SharedStorageWorkletTokenPtr(std::move(shared_storage_worklet_token));
    }
}

void WorkletToken::DestroyActive()
{
    switch (tag_) {

    case Tag::kAnimationWorkletToken:

        delete data_.animation_worklet_token;
        break;
    case Tag::kAudioWorkletToken:

        delete data_.audio_worklet_token;
        break;
    case Tag::kLayoutWorkletToken:

        delete data_.layout_worklet_token;
        break;
    case Tag::kPaintWorkletToken:

        delete data_.paint_worklet_token;
        break;
    case Tag::kSharedStorageWorkletToken:

        delete data_.shared_storage_worklet_token;
        break;
    }
}

bool WorkletToken::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context, false);
}
ExecutionContextToken::ExecutionContextToken()
    : tag_(Tag::kLocalFrameToken)
{
    data_.local_frame_token = new ::blink::LocalFrameToken;
}

ExecutionContextToken::~ExecutionContextToken()
{
    DestroyActive();
}

void ExecutionContextToken::set_local_frame_token(const ::blink::LocalFrameToken& local_frame_token)
{
    if (tag_ == Tag::kLocalFrameToken) {
        *(data_.local_frame_token) = std::move(local_frame_token);
    } else {
        DestroyActive();
        tag_ = Tag::kLocalFrameToken;
        data_.local_frame_token = new ::blink::LocalFrameToken(std::move(local_frame_token));
    }
}
void ExecutionContextToken::set_dedicated_worker_token(const ::blink::DedicatedWorkerToken& dedicated_worker_token)
{
    if (tag_ == Tag::kDedicatedWorkerToken) {
        *(data_.dedicated_worker_token) = std::move(dedicated_worker_token);
    } else {
        DestroyActive();
        tag_ = Tag::kDedicatedWorkerToken;
        data_.dedicated_worker_token = new ::blink::DedicatedWorkerToken(std::move(dedicated_worker_token));
    }
}
void ExecutionContextToken::set_service_worker_token(const ::blink::ServiceWorkerToken& service_worker_token)
{
    if (tag_ == Tag::kServiceWorkerToken) {
        *(data_.service_worker_token) = std::move(service_worker_token);
    } else {
        DestroyActive();
        tag_ = Tag::kServiceWorkerToken;
        data_.service_worker_token = new ::blink::ServiceWorkerToken(std::move(service_worker_token));
    }
}
void ExecutionContextToken::set_shared_worker_token(const ::blink::SharedWorkerToken& shared_worker_token)
{
    if (tag_ == Tag::kSharedWorkerToken) {
        *(data_.shared_worker_token) = std::move(shared_worker_token);
    } else {
        DestroyActive();
        tag_ = Tag::kSharedWorkerToken;
        data_.shared_worker_token = new ::blink::SharedWorkerToken(std::move(shared_worker_token));
    }
}
void ExecutionContextToken::set_animation_worklet_token(const ::blink::AnimationWorkletToken& animation_worklet_token)
{
    if (tag_ == Tag::kAnimationWorkletToken) {
        *(data_.animation_worklet_token) = std::move(animation_worklet_token);
    } else {
        DestroyActive();
        tag_ = Tag::kAnimationWorkletToken;
        data_.animation_worklet_token = new ::blink::AnimationWorkletToken(std::move(animation_worklet_token));
    }
}
void ExecutionContextToken::set_audio_worklet_token(const ::blink::AudioWorkletToken& audio_worklet_token)
{
    if (tag_ == Tag::kAudioWorkletToken) {
        *(data_.audio_worklet_token) = std::move(audio_worklet_token);
    } else {
        DestroyActive();
        tag_ = Tag::kAudioWorkletToken;
        data_.audio_worklet_token = new ::blink::AudioWorkletToken(std::move(audio_worklet_token));
    }
}
void ExecutionContextToken::set_layout_worklet_token(LayoutWorkletTokenPtr layout_worklet_token)
{
    if (tag_ == Tag::kLayoutWorkletToken) {
        *(data_.layout_worklet_token) = std::move(layout_worklet_token);
    } else {
        DestroyActive();
        tag_ = Tag::kLayoutWorkletToken;
        data_.layout_worklet_token = new LayoutWorkletTokenPtr(std::move(layout_worklet_token));
    }
}
void ExecutionContextToken::set_paint_worklet_token(const ::blink::PaintWorkletToken& paint_worklet_token)
{
    if (tag_ == Tag::kPaintWorkletToken) {
        *(data_.paint_worklet_token) = std::move(paint_worklet_token);
    } else {
        DestroyActive();
        tag_ = Tag::kPaintWorkletToken;
        data_.paint_worklet_token = new ::blink::PaintWorkletToken(std::move(paint_worklet_token));
    }
}
void ExecutionContextToken::set_shared_storage_worklet_token(SharedStorageWorkletTokenPtr shared_storage_worklet_token)
{
    if (tag_ == Tag::kSharedStorageWorkletToken) {
        *(data_.shared_storage_worklet_token) = std::move(shared_storage_worklet_token);
    } else {
        DestroyActive();
        tag_ = Tag::kSharedStorageWorkletToken;
        data_.shared_storage_worklet_token = new SharedStorageWorkletTokenPtr(std::move(shared_storage_worklet_token));
    }
}
void ExecutionContextToken::set_shadow_realm_token(const ::blink::ShadowRealmToken& shadow_realm_token)
{
    if (tag_ == Tag::kShadowRealmToken) {
        *(data_.shadow_realm_token) = std::move(shadow_realm_token);
    } else {
        DestroyActive();
        tag_ = Tag::kShadowRealmToken;
        data_.shadow_realm_token = new ::blink::ShadowRealmToken(std::move(shadow_realm_token));
    }
}

void ExecutionContextToken::DestroyActive()
{
    switch (tag_) {

    case Tag::kLocalFrameToken:

        delete data_.local_frame_token;
        break;
    case Tag::kDedicatedWorkerToken:

        delete data_.dedicated_worker_token;
        break;
    case Tag::kServiceWorkerToken:

        delete data_.service_worker_token;
        break;
    case Tag::kSharedWorkerToken:

        delete data_.shared_worker_token;
        break;
    case Tag::kAnimationWorkletToken:

        delete data_.animation_worklet_token;
        break;
    case Tag::kAudioWorkletToken:

        delete data_.audio_worklet_token;
        break;
    case Tag::kLayoutWorkletToken:

        delete data_.layout_worklet_token;
        break;
    case Tag::kPaintWorkletToken:

        delete data_.paint_worklet_token;
        break;
    case Tag::kSharedStorageWorkletToken:

        delete data_.shared_storage_worklet_token;
        break;
    case Tag::kShadowRealmToken:

        delete data_.shadow_realm_token;
        break;
    }
}

bool ExecutionContextToken::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context, false);
}
WebGPUExecutionContextToken::WebGPUExecutionContextToken()
    : tag_(Tag::kDocumentToken)
{
    data_.document_token = new ::blink::DocumentToken;
}

WebGPUExecutionContextToken::~WebGPUExecutionContextToken()
{
    DestroyActive();
}

void WebGPUExecutionContextToken::set_document_token(const ::blink::DocumentToken& document_token)
{
    if (tag_ == Tag::kDocumentToken) {
        *(data_.document_token) = std::move(document_token);
    } else {
        DestroyActive();
        tag_ = Tag::kDocumentToken;
        data_.document_token = new ::blink::DocumentToken(std::move(document_token));
    }
}
void WebGPUExecutionContextToken::set_dedicated_worker_token(const ::blink::DedicatedWorkerToken& dedicated_worker_token)
{
    if (tag_ == Tag::kDedicatedWorkerToken) {
        *(data_.dedicated_worker_token) = std::move(dedicated_worker_token);
    } else {
        DestroyActive();
        tag_ = Tag::kDedicatedWorkerToken;
        data_.dedicated_worker_token = new ::blink::DedicatedWorkerToken(std::move(dedicated_worker_token));
    }
}
void WebGPUExecutionContextToken::set_shared_worker_token(const ::blink::SharedWorkerToken& shared_worker_token)
{
    if (tag_ == Tag::kSharedWorkerToken) {
        *(data_.shared_worker_token) = std::move(shared_worker_token);
    } else {
        DestroyActive();
        tag_ = Tag::kSharedWorkerToken;
        data_.shared_worker_token = new ::blink::SharedWorkerToken(std::move(shared_worker_token));
    }
}
void WebGPUExecutionContextToken::set_service_worker_token(const ::blink::ServiceWorkerToken& service_worker_token)
{
    if (tag_ == Tag::kServiceWorkerToken) {
        *(data_.service_worker_token) = std::move(service_worker_token);
    } else {
        DestroyActive();
        tag_ = Tag::kServiceWorkerToken;
        data_.service_worker_token = new ::blink::ServiceWorkerToken(std::move(service_worker_token));
    }
}

void WebGPUExecutionContextToken::DestroyActive()
{
    switch (tag_) {

    case Tag::kDocumentToken:

        delete data_.document_token;
        break;
    case Tag::kDedicatedWorkerToken:

        delete data_.dedicated_worker_token;
        break;
    case Tag::kSharedWorkerToken:

        delete data_.shared_worker_token;
        break;
    case Tag::kServiceWorkerToken:

        delete data_.service_worker_token;
        break;
    }
}

bool WebGPUExecutionContextToken::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context, false);
}

} // blink::mojom

namespace mojo {

// static
bool StructTraits<::blink::mojom::DocumentToken::DataView, ::blink::mojom::DocumentTokenPtr>::Read(
    ::blink::mojom::DocumentToken::DataView input, ::blink::mojom::DocumentTokenPtr* output)
{
    bool success = true;
    ::blink::mojom::DocumentTokenPtr result(::blink::mojom::DocumentToken::New());

    if (success && !input.ReadValue(&result->value))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::blink::mojom::LocalFrameToken::DataView, ::blink::mojom::LocalFrameTokenPtr>::Read(
    ::blink::mojom::LocalFrameToken::DataView input, ::blink::mojom::LocalFrameTokenPtr* output)
{
    bool success = true;
    ::blink::mojom::LocalFrameTokenPtr result(::blink::mojom::LocalFrameToken::New());

    if (success && !input.ReadValue(&result->value))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::blink::mojom::RemoteFrameToken::DataView, ::blink::mojom::RemoteFrameTokenPtr>::Read(
    ::blink::mojom::RemoteFrameToken::DataView input, ::blink::mojom::RemoteFrameTokenPtr* output)
{
    bool success = true;
    ::blink::mojom::RemoteFrameTokenPtr result(::blink::mojom::RemoteFrameToken::New());

    if (success && !input.ReadValue(&result->value))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::blink::mojom::DedicatedWorkerToken::DataView, ::blink::mojom::DedicatedWorkerTokenPtr>::Read(
    ::blink::mojom::DedicatedWorkerToken::DataView input, ::blink::mojom::DedicatedWorkerTokenPtr* output)
{
    bool success = true;
    ::blink::mojom::DedicatedWorkerTokenPtr result(::blink::mojom::DedicatedWorkerToken::New());

    if (success && !input.ReadValue(&result->value))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::blink::mojom::ServiceWorkerToken::DataView, ::blink::mojom::ServiceWorkerTokenPtr>::Read(
    ::blink::mojom::ServiceWorkerToken::DataView input, ::blink::mojom::ServiceWorkerTokenPtr* output)
{
    bool success = true;
    ::blink::mojom::ServiceWorkerTokenPtr result(::blink::mojom::ServiceWorkerToken::New());

    if (success && !input.ReadValue(&result->value))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::blink::mojom::SharedWorkerToken::DataView, ::blink::mojom::SharedWorkerTokenPtr>::Read(
    ::blink::mojom::SharedWorkerToken::DataView input, ::blink::mojom::SharedWorkerTokenPtr* output)
{
    bool success = true;
    ::blink::mojom::SharedWorkerTokenPtr result(::blink::mojom::SharedWorkerToken::New());

    if (success && !input.ReadValue(&result->value))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::blink::mojom::AnimationWorkletToken::DataView, ::blink::mojom::AnimationWorkletTokenPtr>::Read(
    ::blink::mojom::AnimationWorkletToken::DataView input, ::blink::mojom::AnimationWorkletTokenPtr* output)
{
    bool success = true;
    ::blink::mojom::AnimationWorkletTokenPtr result(::blink::mojom::AnimationWorkletToken::New());

    if (success && !input.ReadValue(&result->value))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::blink::mojom::AudioWorkletToken::DataView, ::blink::mojom::AudioWorkletTokenPtr>::Read(
    ::blink::mojom::AudioWorkletToken::DataView input, ::blink::mojom::AudioWorkletTokenPtr* output)
{
    bool success = true;
    ::blink::mojom::AudioWorkletTokenPtr result(::blink::mojom::AudioWorkletToken::New());

    if (success && !input.ReadValue(&result->value))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::blink::mojom::LayoutWorkletToken::DataView, ::blink::mojom::LayoutWorkletTokenPtr>::Read(
    ::blink::mojom::LayoutWorkletToken::DataView input, ::blink::mojom::LayoutWorkletTokenPtr* output)
{
    bool success = true;
    ::blink::mojom::LayoutWorkletTokenPtr result(::blink::mojom::LayoutWorkletToken::New());

    if (success && !input.ReadValue(&result->value))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::blink::mojom::PaintWorkletToken::DataView, ::blink::mojom::PaintWorkletTokenPtr>::Read(
    ::blink::mojom::PaintWorkletToken::DataView input, ::blink::mojom::PaintWorkletTokenPtr* output)
{
    bool success = true;
    ::blink::mojom::PaintWorkletTokenPtr result(::blink::mojom::PaintWorkletToken::New());

    if (success && !input.ReadValue(&result->value))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::blink::mojom::SharedStorageWorkletToken::DataView, ::blink::mojom::SharedStorageWorkletTokenPtr>::Read(
    ::blink::mojom::SharedStorageWorkletToken::DataView input, ::blink::mojom::SharedStorageWorkletTokenPtr* output)
{
    bool success = true;
    ::blink::mojom::SharedStorageWorkletTokenPtr result(::blink::mojom::SharedStorageWorkletToken::New());

    if (success && !input.ReadValue(&result->value))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::blink::mojom::ShadowRealmToken::DataView, ::blink::mojom::ShadowRealmTokenPtr>::Read(
    ::blink::mojom::ShadowRealmToken::DataView input, ::blink::mojom::ShadowRealmTokenPtr* output)
{
    bool success = true;
    ::blink::mojom::ShadowRealmTokenPtr result(::blink::mojom::ShadowRealmToken::New());

    if (success && !input.ReadValue(&result->value))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::blink::mojom::AttributionSrcToken::DataView, ::blink::mojom::AttributionSrcTokenPtr>::Read(
    ::blink::mojom::AttributionSrcToken::DataView input, ::blink::mojom::AttributionSrcTokenPtr* output)
{
    bool success = true;
    ::blink::mojom::AttributionSrcTokenPtr result(::blink::mojom::AttributionSrcToken::New());

    if (success && !input.ReadValue(&result->value))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::blink::mojom::ClipboardSequenceNumberToken::DataView, ::blink::mojom::ClipboardSequenceNumberTokenPtr>::Read(
    ::blink::mojom::ClipboardSequenceNumberToken::DataView input, ::blink::mojom::ClipboardSequenceNumberTokenPtr* output)
{
    bool success = true;
    ::blink::mojom::ClipboardSequenceNumberTokenPtr result(::blink::mojom::ClipboardSequenceNumberToken::New());

    if (success && !input.ReadValue(&result->value))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::blink::mojom::SameDocNavigationScreenshotDestinationToken::DataView, ::blink::mojom::SameDocNavigationScreenshotDestinationTokenPtr>::Read(
    ::blink::mojom::SameDocNavigationScreenshotDestinationToken::DataView input, ::blink::mojom::SameDocNavigationScreenshotDestinationTokenPtr* output)
{
    bool success = true;
    ::blink::mojom::SameDocNavigationScreenshotDestinationTokenPtr result(::blink::mojom::SameDocNavigationScreenshotDestinationToken::New());

    if (success && !input.ReadValue(&result->value))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::blink::mojom::V8ContextToken::DataView, ::blink::mojom::V8ContextTokenPtr>::Read(
    ::blink::mojom::V8ContextToken::DataView input, ::blink::mojom::V8ContextTokenPtr* output)
{
    bool success = true;
    ::blink::mojom::V8ContextTokenPtr result(::blink::mojom::V8ContextToken::New());

    if (success && !input.ReadValue(&result->value))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::blink::mojom::ViewTransitionToken::DataView, ::blink::mojom::ViewTransitionTokenPtr>::Read(
    ::blink::mojom::ViewTransitionToken::DataView input, ::blink::mojom::ViewTransitionTokenPtr* output)
{
    bool success = true;
    ::blink::mojom::ViewTransitionTokenPtr result(::blink::mojom::ViewTransitionToken::New());

    if (success && !input.ReadValue(&result->value))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::blink::mojom::WebNNContextToken::DataView, ::blink::mojom::WebNNContextTokenPtr>::Read(
    ::blink::mojom::WebNNContextToken::DataView input, ::blink::mojom::WebNNContextTokenPtr* output)
{
    bool success = true;
    ::blink::mojom::WebNNContextTokenPtr result(::blink::mojom::WebNNContextToken::New());

    if (success && !input.ReadValue(&result->value))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::blink::mojom::WebNNTensorToken::DataView, ::blink::mojom::WebNNTensorTokenPtr>::Read(
    ::blink::mojom::WebNNTensorToken::DataView input, ::blink::mojom::WebNNTensorTokenPtr* output)
{
    bool success = true;
    ::blink::mojom::WebNNTensorTokenPtr result(::blink::mojom::WebNNTensorToken::New());

    if (success && !input.ReadValue(&result->value))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool UnionTraits<::blink::mojom::FrameToken::DataView, ::blink::mojom::FrameTokenPtr>::Read(
    ::blink::mojom::FrameToken::DataView input, ::blink::mojom::FrameTokenPtr* output)
{
    using UnionType = ::blink::mojom::FrameToken;
    using Tag = UnionType::Tag;

    switch (input.tag()) {
    case Tag::kLocalFrameToken: {
        ::blink::LocalFrameToken result_local_frame_token;
        if (!input.ReadLocalFrameToken(&result_local_frame_token))
            return false;

        *output = UnionType::NewLocalFrameToken(std::move(result_local_frame_token));
        break;
    }
    case Tag::kRemoteFrameToken: {
        ::blink::RemoteFrameToken result_remote_frame_token;
        if (!input.ReadRemoteFrameToken(&result_remote_frame_token))
            return false;

        *output = UnionType::NewRemoteFrameToken(std::move(result_remote_frame_token));
        break;
    }
    default:

        return false;
    }
    return true;
}

// static
bool UnionTraits<::blink::mojom::WorkerToken::DataView, ::blink::mojom::WorkerTokenPtr>::Read(
    ::blink::mojom::WorkerToken::DataView input, ::blink::mojom::WorkerTokenPtr* output)
{
    using UnionType = ::blink::mojom::WorkerToken;
    using Tag = UnionType::Tag;

    switch (input.tag()) {
    case Tag::kDedicatedWorkerToken: {
        ::blink::DedicatedWorkerToken result_dedicated_worker_token;
        if (!input.ReadDedicatedWorkerToken(&result_dedicated_worker_token))
            return false;

        *output = UnionType::NewDedicatedWorkerToken(std::move(result_dedicated_worker_token));
        break;
    }
    case Tag::kServiceWorkerToken: {
        ::blink::ServiceWorkerToken result_service_worker_token;
        if (!input.ReadServiceWorkerToken(&result_service_worker_token))
            return false;

        *output = UnionType::NewServiceWorkerToken(std::move(result_service_worker_token));
        break;
    }
    case Tag::kSharedWorkerToken: {
        ::blink::SharedWorkerToken result_shared_worker_token;
        if (!input.ReadSharedWorkerToken(&result_shared_worker_token))
            return false;

        *output = UnionType::NewSharedWorkerToken(std::move(result_shared_worker_token));
        break;
    }
    default:

        return false;
    }
    return true;
}

// static
bool UnionTraits<::blink::mojom::WorkletToken::DataView, ::blink::mojom::WorkletTokenPtr>::Read(
    ::blink::mojom::WorkletToken::DataView input, ::blink::mojom::WorkletTokenPtr* output)
{
    using UnionType = ::blink::mojom::WorkletToken;
    using Tag = UnionType::Tag;

    switch (input.tag()) {
    case Tag::kAnimationWorkletToken: {
        ::blink::AnimationWorkletToken result_animation_worklet_token;
        if (!input.ReadAnimationWorkletToken(&result_animation_worklet_token))
            return false;

        *output = UnionType::NewAnimationWorkletToken(std::move(result_animation_worklet_token));
        break;
    }
    case Tag::kAudioWorkletToken: {
        ::blink::AudioWorkletToken result_audio_worklet_token;
        if (!input.ReadAudioWorkletToken(&result_audio_worklet_token))
            return false;

        *output = UnionType::NewAudioWorkletToken(std::move(result_audio_worklet_token));
        break;
    }
    case Tag::kLayoutWorkletToken: {
        ::blink::mojom::LayoutWorkletTokenPtr result_layout_worklet_token;
        if (!input.ReadLayoutWorkletToken(&result_layout_worklet_token))
            return false;

        *output = UnionType::NewLayoutWorkletToken(std::move(result_layout_worklet_token));
        break;
    }
    case Tag::kPaintWorkletToken: {
        ::blink::PaintWorkletToken result_paint_worklet_token;
        if (!input.ReadPaintWorkletToken(&result_paint_worklet_token))
            return false;

        *output = UnionType::NewPaintWorkletToken(std::move(result_paint_worklet_token));
        break;
    }
    case Tag::kSharedStorageWorkletToken: {
        ::blink::mojom::SharedStorageWorkletTokenPtr result_shared_storage_worklet_token;
        if (!input.ReadSharedStorageWorkletToken(&result_shared_storage_worklet_token))
            return false;

        *output = UnionType::NewSharedStorageWorkletToken(std::move(result_shared_storage_worklet_token));
        break;
    }
    default:

        return false;
    }
    return true;
}

// static
bool UnionTraits<::blink::mojom::ExecutionContextToken::DataView, ::blink::mojom::ExecutionContextTokenPtr>::Read(
    ::blink::mojom::ExecutionContextToken::DataView input, ::blink::mojom::ExecutionContextTokenPtr* output)
{
    using UnionType = ::blink::mojom::ExecutionContextToken;
    using Tag = UnionType::Tag;

    switch (input.tag()) {
    case Tag::kLocalFrameToken: {
        ::blink::LocalFrameToken result_local_frame_token;
        if (!input.ReadLocalFrameToken(&result_local_frame_token))
            return false;

        *output = UnionType::NewLocalFrameToken(std::move(result_local_frame_token));
        break;
    }
    case Tag::kDedicatedWorkerToken: {
        ::blink::DedicatedWorkerToken result_dedicated_worker_token;
        if (!input.ReadDedicatedWorkerToken(&result_dedicated_worker_token))
            return false;

        *output = UnionType::NewDedicatedWorkerToken(std::move(result_dedicated_worker_token));
        break;
    }
    case Tag::kServiceWorkerToken: {
        ::blink::ServiceWorkerToken result_service_worker_token;
        if (!input.ReadServiceWorkerToken(&result_service_worker_token))
            return false;

        *output = UnionType::NewServiceWorkerToken(std::move(result_service_worker_token));
        break;
    }
    case Tag::kSharedWorkerToken: {
        ::blink::SharedWorkerToken result_shared_worker_token;
        if (!input.ReadSharedWorkerToken(&result_shared_worker_token))
            return false;

        *output = UnionType::NewSharedWorkerToken(std::move(result_shared_worker_token));
        break;
    }
    case Tag::kAnimationWorkletToken: {
        ::blink::AnimationWorkletToken result_animation_worklet_token;
        if (!input.ReadAnimationWorkletToken(&result_animation_worklet_token))
            return false;

        *output = UnionType::NewAnimationWorkletToken(std::move(result_animation_worklet_token));
        break;
    }
    case Tag::kAudioWorkletToken: {
        ::blink::AudioWorkletToken result_audio_worklet_token;
        if (!input.ReadAudioWorkletToken(&result_audio_worklet_token))
            return false;

        *output = UnionType::NewAudioWorkletToken(std::move(result_audio_worklet_token));
        break;
    }
    case Tag::kLayoutWorkletToken: {
        ::blink::mojom::LayoutWorkletTokenPtr result_layout_worklet_token;
        if (!input.ReadLayoutWorkletToken(&result_layout_worklet_token))
            return false;

        *output = UnionType::NewLayoutWorkletToken(std::move(result_layout_worklet_token));
        break;
    }
    case Tag::kPaintWorkletToken: {
        ::blink::PaintWorkletToken result_paint_worklet_token;
        if (!input.ReadPaintWorkletToken(&result_paint_worklet_token))
            return false;

        *output = UnionType::NewPaintWorkletToken(std::move(result_paint_worklet_token));
        break;
    }
    case Tag::kSharedStorageWorkletToken: {
        ::blink::mojom::SharedStorageWorkletTokenPtr result_shared_storage_worklet_token;
        if (!input.ReadSharedStorageWorkletToken(&result_shared_storage_worklet_token))
            return false;

        *output = UnionType::NewSharedStorageWorkletToken(std::move(result_shared_storage_worklet_token));
        break;
    }
    case Tag::kShadowRealmToken: {
        ::blink::ShadowRealmToken result_shadow_realm_token;
        if (!input.ReadShadowRealmToken(&result_shadow_realm_token))
            return false;

        *output = UnionType::NewShadowRealmToken(std::move(result_shadow_realm_token));
        break;
    }
    default:

        return false;
    }
    return true;
}

// static
bool UnionTraits<::blink::mojom::WebGPUExecutionContextToken::DataView, ::blink::mojom::WebGPUExecutionContextTokenPtr>::Read(
    ::blink::mojom::WebGPUExecutionContextToken::DataView input, ::blink::mojom::WebGPUExecutionContextTokenPtr* output)
{
    using UnionType = ::blink::mojom::WebGPUExecutionContextToken;
    using Tag = UnionType::Tag;

    switch (input.tag()) {
    case Tag::kDocumentToken: {
        ::blink::DocumentToken result_document_token;
        if (!input.ReadDocumentToken(&result_document_token))
            return false;

        *output = UnionType::NewDocumentToken(std::move(result_document_token));
        break;
    }
    case Tag::kDedicatedWorkerToken: {
        ::blink::DedicatedWorkerToken result_dedicated_worker_token;
        if (!input.ReadDedicatedWorkerToken(&result_dedicated_worker_token))
            return false;

        *output = UnionType::NewDedicatedWorkerToken(std::move(result_dedicated_worker_token));
        break;
    }
    case Tag::kSharedWorkerToken: {
        ::blink::SharedWorkerToken result_shared_worker_token;
        if (!input.ReadSharedWorkerToken(&result_shared_worker_token))
            return false;

        *output = UnionType::NewSharedWorkerToken(std::move(result_shared_worker_token));
        break;
    }
    case Tag::kServiceWorkerToken: {
        ::blink::ServiceWorkerToken result_service_worker_token;
        if (!input.ReadServiceWorkerToken(&result_service_worker_token))
            return false;

        *output = UnionType::NewServiceWorkerToken(std::move(result_service_worker_token));
        break;
    }
    default:

        return false;
    }
    return true;
}

} // namespace mojo

// Symbols declared in the -test-utils.h header are defined here instead of a
// separate .cc file to save compile time.

namespace blink::mojom {

} // blink::mojom

#if defined(__clang__)
#pragma clang diagnostic pop
#endif