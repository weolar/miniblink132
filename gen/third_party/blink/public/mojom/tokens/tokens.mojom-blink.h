// third_party/blink/public/mojom/tokens/tokens.mojom-blink.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef THIRD_PARTY_BLINK_PUBLIC_MOJOM_TOKENS_TOKENS_MOJOM_BLINK_H_
#define THIRD_PARTY_BLINK_PUBLIC_MOJOM_TOKENS_TOKENS_MOJOM_BLINK_H_

#include <stdint.h>

#include <limits>
#include <optional>
#include <type_traits>
#include <utility>

#include "base/types/cxx23_to_underlying.h"
#include "mojo/public/cpp/bindings/clone_traits.h"
#include "mojo/public/cpp/bindings/equals_traits.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/struct_ptr.h"
#include "mojo/public/cpp/bindings/struct_traits.h"
#include "mojo/public/cpp/bindings/union_traits.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "third_party/blink/public/mojom/tokens/tokens.mojom-features.h" // IWYU pragma: export
#include "third_party/blink/public/mojom/tokens/tokens.mojom-shared.h" // IWYU pragma: export
#include "third_party/blink/public/mojom/tokens/tokens.mojom-blink-forward.h" // IWYU pragma: export
#include "mojo/public/mojom/base/unguessable_token.mojom-blink.h"

#include "mojo/public/cpp/bindings/lib/wtf_clone_equals_util.h"
#include "mojo/public/cpp/bindings/lib/wtf_hash_util.h"
#include "third_party/blink/renderer/platform/wtf/hash_functions.h"
#include "third_party/blink/renderer/platform/wtf/text/wtf_string.h"

#include "third_party/blink/public/common/tokens/token_mojom_traits_helper.h"
#include "third_party/blink/public/common/tokens/tokens_mojom_traits.h"
#include "third_party/blink/renderer/platform/platform_export.h"
#if !BLINK_MOJO_IMPL && !INSIDE_BLINK
#error "File must only be imported inside blink"
#endif

namespace blink::mojom::blink {

class PLATFORM_EXPORT FrameToken {
public:
    using DataView = FrameTokenDataView;
    using Data_ = internal::FrameToken_Data;
    using Tag = Data_::FrameToken_Tag;

    template <typename... Args> static FrameTokenPtr New(Args&&... args)
    {
        static_assert(sizeof...(args) < 0,
            "Do not use Union::New(); to create a union of a given subtype, use "
            "New<SubType>(), not New() followed by set_<sub_type>(). To represent "
            "an empty union, mark the field or parameter as nullable in the mojom "
            "definition.");
        return nullptr;
    }
    // Construct an instance holding |local_frame_token|.
    static FrameTokenPtr NewLocalFrameToken(const ::blink::LocalFrameToken& value)
    {
        auto result = FrameTokenPtr(std::in_place);
        result->set_local_frame_token(std::move(value));
        return result;
    }
    // Construct an instance holding |remote_frame_token|.
    static FrameTokenPtr NewRemoteFrameToken(const ::blink::RemoteFrameToken& value)
    {
        auto result = FrameTokenPtr(std::in_place);
        result->set_remote_frame_token(std::move(value));
        return result;
    }

    template <typename U> static FrameTokenPtr From(const U& u)
    {
        return mojo::TypeConverter<FrameTokenPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, FrameToken>::Convert(*this);
    }

    FrameToken()
    : tag_(Tag::kLocalFrameToken)
{
    data_.local_frame_token = new ::blink::LocalFrameToken;
}
    ~FrameToken(){
    DestroyActive();
}
    // Delete the copy constructor and copy assignment operators because `data_`
    // contains raw pointers that must not be copied.
    FrameToken(const FrameToken& other) = delete;
    FrameToken& operator=(const FrameToken& other) = delete;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename UnionPtrType = FrameTokenPtr> FrameTokenPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, typename std::enable_if<std::is_same<T, FrameToken>::value>::type* = nullptr> bool Equals(const T& other) const;

    template <typename T, typename std::enable_if<std::is_same<T, FrameToken>::value>::type* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    Tag which() const
    {
        return tag_;
    }

    bool is_local_frame_token() const
    {
        return tag_ == Tag::kLocalFrameToken;
    }

    ::blink::LocalFrameToken& get_local_frame_token() const
    {
        CHECK(tag_ == Tag::kLocalFrameToken);
        return *(data_.local_frame_token);
    }

    void set_local_frame_token(const ::blink::LocalFrameToken& local_frame_token);

    bool is_remote_frame_token() const
    {
        return tag_ == Tag::kRemoteFrameToken;
    }

    ::blink::RemoteFrameToken& get_remote_frame_token() const
    {
        CHECK(tag_ == Tag::kRemoteFrameToken);
        return *(data_.remote_frame_token);
    }

    void set_remote_frame_token(const ::blink::RemoteFrameToken& remote_frame_token);

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<FrameToken::DataView>(input);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        return mojo::internal::DeserializeImpl<FrameToken::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

private:
    union Union_ {
        Union_() = default;
        ~Union_() = default;
        ::blink::LocalFrameToken* local_frame_token;
        ::blink::RemoteFrameToken* remote_frame_token;
    };

    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    void DestroyActive();
    Tag tag_;
    Union_ data_;
};

class PLATFORM_EXPORT WorkerToken {
public:
    using DataView = WorkerTokenDataView;
    using Data_ = internal::WorkerToken_Data;
    using Tag = Data_::WorkerToken_Tag;

    template <typename... Args> static WorkerTokenPtr New(Args&&... args)
    {
        static_assert(sizeof...(args) < 0,
            "Do not use Union::New(); to create a union of a given subtype, use "
            "New<SubType>(), not New() followed by set_<sub_type>(). To represent "
            "an empty union, mark the field or parameter as nullable in the mojom "
            "definition.");
        return nullptr;
    }
    // Construct an instance holding |dedicated_worker_token|.
    static WorkerTokenPtr NewDedicatedWorkerToken(const ::blink::DedicatedWorkerToken& value)
    {
        auto result = WorkerTokenPtr(std::in_place);
        result->set_dedicated_worker_token(std::move(value));
        return result;
    }
    // Construct an instance holding |service_worker_token|.
    static WorkerTokenPtr NewServiceWorkerToken(const ::blink::ServiceWorkerToken& value)
    {
        auto result = WorkerTokenPtr(std::in_place);
        result->set_service_worker_token(std::move(value));
        return result;
    }
    // Construct an instance holding |shared_worker_token|.
    static WorkerTokenPtr NewSharedWorkerToken(const ::blink::SharedWorkerToken& value)
    {
        auto result = WorkerTokenPtr(std::in_place);
        result->set_shared_worker_token(std::move(value));
        return result;
    }

    template <typename U> static WorkerTokenPtr From(const U& u)
    {
        return mojo::TypeConverter<WorkerTokenPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, WorkerToken>::Convert(*this);
    }

    WorkerToken()
    : tag_(Tag::kDedicatedWorkerToken)
{
    data_.dedicated_worker_token = new ::blink::DedicatedWorkerToken;
}
    ~WorkerToken(){
    DestroyActive();
}
    // Delete the copy constructor and copy assignment operators because `data_`
    // contains raw pointers that must not be copied.
    WorkerToken(const WorkerToken& other) = delete;
    WorkerToken& operator=(const WorkerToken& other) = delete;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename UnionPtrType = WorkerTokenPtr> WorkerTokenPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, typename std::enable_if<std::is_same<T, WorkerToken>::value>::type* = nullptr> bool Equals(const T& other) const;

    template <typename T, typename std::enable_if<std::is_same<T, WorkerToken>::value>::type* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    Tag which() const
    {
        return tag_;
    }

    bool is_dedicated_worker_token() const
    {
        return tag_ == Tag::kDedicatedWorkerToken;
    }

    ::blink::DedicatedWorkerToken& get_dedicated_worker_token() const
    {
        CHECK(tag_ == Tag::kDedicatedWorkerToken);
        return *(data_.dedicated_worker_token);
    }

    void set_dedicated_worker_token(const ::blink::DedicatedWorkerToken& dedicated_worker_token);

    bool is_service_worker_token() const
    {
        return tag_ == Tag::kServiceWorkerToken;
    }

    ::blink::ServiceWorkerToken& get_service_worker_token() const
    {
        CHECK(tag_ == Tag::kServiceWorkerToken);
        return *(data_.service_worker_token);
    }

    void set_service_worker_token(const ::blink::ServiceWorkerToken& service_worker_token);

    bool is_shared_worker_token() const
    {
        return tag_ == Tag::kSharedWorkerToken;
    }

    ::blink::SharedWorkerToken& get_shared_worker_token() const
    {
        CHECK(tag_ == Tag::kSharedWorkerToken);
        return *(data_.shared_worker_token);
    }

    void set_shared_worker_token(const ::blink::SharedWorkerToken& shared_worker_token);

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<WorkerToken::DataView>(input);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        return mojo::internal::DeserializeImpl<WorkerToken::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

private:
    union Union_ {
        Union_() = default;
        ~Union_() = default;
        ::blink::DedicatedWorkerToken* dedicated_worker_token;
        ::blink::ServiceWorkerToken* service_worker_token;
        ::blink::SharedWorkerToken* shared_worker_token;
    };

    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    void DestroyActive();
    Tag tag_;
    Union_ data_;
};

class PLATFORM_EXPORT WorkletToken {
public:
    using DataView = WorkletTokenDataView;
    using Data_ = internal::WorkletToken_Data;
    using Tag = Data_::WorkletToken_Tag;

    template <typename... Args> static WorkletTokenPtr New(Args&&... args)
    {
        static_assert(sizeof...(args) < 0,
            "Do not use Union::New(); to create a union of a given subtype, use "
            "New<SubType>(), not New() followed by set_<sub_type>(). To represent "
            "an empty union, mark the field or parameter as nullable in the mojom "
            "definition.");
        return nullptr;
    }
    // Construct an instance holding |animation_worklet_token|.
    static WorkletTokenPtr NewAnimationWorkletToken(const ::blink::AnimationWorkletToken& value)
    {
        auto result = WorkletTokenPtr(std::in_place);
        result->set_animation_worklet_token(std::move(value));
        return result;
    }
    // Construct an instance holding |audio_worklet_token|.
    static WorkletTokenPtr NewAudioWorkletToken(const ::blink::AudioWorkletToken& value)
    {
        auto result = WorkletTokenPtr(std::in_place);
        result->set_audio_worklet_token(std::move(value));
        return result;
    }
    // Construct an instance holding |layout_worklet_token|.
    static WorkletTokenPtr NewLayoutWorkletToken(LayoutWorkletTokenPtr value)
    {
        auto result = WorkletTokenPtr(std::in_place);
        result->set_layout_worklet_token(std::move(value));
        return result;
    }
    // Construct an instance holding |paint_worklet_token|.
    static WorkletTokenPtr NewPaintWorkletToken(const ::blink::PaintWorkletToken& value)
    {
        auto result = WorkletTokenPtr(std::in_place);
        result->set_paint_worklet_token(std::move(value));
        return result;
    }
    // Construct an instance holding |shared_storage_worklet_token|.
    static WorkletTokenPtr NewSharedStorageWorkletToken(SharedStorageWorkletTokenPtr value)
    {
        auto result = WorkletTokenPtr(std::in_place);
        result->set_shared_storage_worklet_token(std::move(value));
        return result;
    }

    template <typename U> static WorkletTokenPtr From(const U& u)
    {
        return mojo::TypeConverter<WorkletTokenPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, WorkletToken>::Convert(*this);
    }

    WorkletToken()
    : tag_(Tag::kAnimationWorkletToken)
{
    data_.animation_worklet_token = new ::blink::AnimationWorkletToken;
}
    ~WorkletToken(){
    DestroyActive();
}
    // Delete the copy constructor and copy assignment operators because `data_`
    // contains raw pointers that must not be copied.
    WorkletToken(const WorkletToken& other) = delete;
    WorkletToken& operator=(const WorkletToken& other) = delete;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename UnionPtrType = WorkletTokenPtr> WorkletTokenPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, typename std::enable_if<std::is_same<T, WorkletToken>::value>::type* = nullptr> bool Equals(const T& other) const;

    template <typename T, typename std::enable_if<std::is_same<T, WorkletToken>::value>::type* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    Tag which() const
    {
        return tag_;
    }

    bool is_animation_worklet_token() const
    {
        return tag_ == Tag::kAnimationWorkletToken;
    }

    ::blink::AnimationWorkletToken& get_animation_worklet_token() const
    {
        CHECK(tag_ == Tag::kAnimationWorkletToken);
        return *(data_.animation_worklet_token);
    }

    void set_animation_worklet_token(const ::blink::AnimationWorkletToken& animation_worklet_token);

    bool is_audio_worklet_token() const
    {
        return tag_ == Tag::kAudioWorkletToken;
    }

    ::blink::AudioWorkletToken& get_audio_worklet_token() const
    {
        CHECK(tag_ == Tag::kAudioWorkletToken);
        return *(data_.audio_worklet_token);
    }

    void set_audio_worklet_token(const ::blink::AudioWorkletToken& audio_worklet_token);

    bool is_layout_worklet_token() const
    {
        return tag_ == Tag::kLayoutWorkletToken;
    }

    LayoutWorkletTokenPtr& get_layout_worklet_token() const
    {
        CHECK(tag_ == Tag::kLayoutWorkletToken);
        return *(data_.layout_worklet_token);
    }

    void set_layout_worklet_token(LayoutWorkletTokenPtr layout_worklet_token);

    bool is_paint_worklet_token() const
    {
        return tag_ == Tag::kPaintWorkletToken;
    }

    ::blink::PaintWorkletToken& get_paint_worklet_token() const
    {
        CHECK(tag_ == Tag::kPaintWorkletToken);
        return *(data_.paint_worklet_token);
    }

    void set_paint_worklet_token(const ::blink::PaintWorkletToken& paint_worklet_token);

    bool is_shared_storage_worklet_token() const
    {
        return tag_ == Tag::kSharedStorageWorkletToken;
    }

    SharedStorageWorkletTokenPtr& get_shared_storage_worklet_token() const
    {
        CHECK(tag_ == Tag::kSharedStorageWorkletToken);
        return *(data_.shared_storage_worklet_token);
    }

    void set_shared_storage_worklet_token(SharedStorageWorkletTokenPtr shared_storage_worklet_token);

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<WorkletToken::DataView>(input);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        return mojo::internal::DeserializeImpl<WorkletToken::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

private:
    union Union_ {
        Union_() = default;
        ~Union_() = default;
        ::blink::AnimationWorkletToken* animation_worklet_token;
        ::blink::AudioWorkletToken* audio_worklet_token;
        LayoutWorkletTokenPtr* layout_worklet_token;
        ::blink::PaintWorkletToken* paint_worklet_token;
        SharedStorageWorkletTokenPtr* shared_storage_worklet_token;
    };

    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    void DestroyActive();
    Tag tag_;
    Union_ data_;
};

class PLATFORM_EXPORT ExecutionContextToken {
public:
    using DataView = ExecutionContextTokenDataView;
    using Data_ = internal::ExecutionContextToken_Data;
    using Tag = Data_::ExecutionContextToken_Tag;

    template <typename... Args> static ExecutionContextTokenPtr New(Args&&... args)
    {
        static_assert(sizeof...(args) < 0,
            "Do not use Union::New(); to create a union of a given subtype, use "
            "New<SubType>(), not New() followed by set_<sub_type>(). To represent "
            "an empty union, mark the field or parameter as nullable in the mojom "
            "definition.");
        return nullptr;
    }
    // Construct an instance holding |local_frame_token|.
    static ExecutionContextTokenPtr NewLocalFrameToken(const ::blink::LocalFrameToken& value)
    {
        auto result = ExecutionContextTokenPtr(std::in_place);
        result->set_local_frame_token(std::move(value));
        return result;
    }
    // Construct an instance holding |dedicated_worker_token|.
    static ExecutionContextTokenPtr NewDedicatedWorkerToken(const ::blink::DedicatedWorkerToken& value)
    {
        auto result = ExecutionContextTokenPtr(std::in_place);
        result->set_dedicated_worker_token(std::move(value));
        return result;
    }
    // Construct an instance holding |service_worker_token|.
    static ExecutionContextTokenPtr NewServiceWorkerToken(const ::blink::ServiceWorkerToken& value)
    {
        auto result = ExecutionContextTokenPtr(std::in_place);
        result->set_service_worker_token(std::move(value));
        return result;
    }
    // Construct an instance holding |shared_worker_token|.
    static ExecutionContextTokenPtr NewSharedWorkerToken(const ::blink::SharedWorkerToken& value)
    {
        auto result = ExecutionContextTokenPtr(std::in_place);
        result->set_shared_worker_token(std::move(value));
        return result;
    }
    // Construct an instance holding |animation_worklet_token|.
    static ExecutionContextTokenPtr NewAnimationWorkletToken(const ::blink::AnimationWorkletToken& value)
    {
        auto result = ExecutionContextTokenPtr(std::in_place);
        result->set_animation_worklet_token(std::move(value));
        return result;
    }
    // Construct an instance holding |audio_worklet_token|.
    static ExecutionContextTokenPtr NewAudioWorkletToken(const ::blink::AudioWorkletToken& value)
    {
        auto result = ExecutionContextTokenPtr(std::in_place);
        result->set_audio_worklet_token(std::move(value));
        return result;
    }
    // Construct an instance holding |layout_worklet_token|.
    static ExecutionContextTokenPtr NewLayoutWorkletToken(LayoutWorkletTokenPtr value)
    {
        auto result = ExecutionContextTokenPtr(std::in_place);
        result->set_layout_worklet_token(std::move(value));
        return result;
    }
    // Construct an instance holding |paint_worklet_token|.
    static ExecutionContextTokenPtr NewPaintWorkletToken(const ::blink::PaintWorkletToken& value)
    {
        auto result = ExecutionContextTokenPtr(std::in_place);
        result->set_paint_worklet_token(std::move(value));
        return result;
    }
    // Construct an instance holding |shared_storage_worklet_token|.
    static ExecutionContextTokenPtr NewSharedStorageWorkletToken(SharedStorageWorkletTokenPtr value)
    {
        auto result = ExecutionContextTokenPtr(std::in_place);
        result->set_shared_storage_worklet_token(std::move(value));
        return result;
    }
    // Construct an instance holding |shadow_realm_token|.
    static ExecutionContextTokenPtr NewShadowRealmToken(const ::blink::ShadowRealmToken& value)
    {
        auto result = ExecutionContextTokenPtr(std::in_place);
        result->set_shadow_realm_token(std::move(value));
        return result;
    }

    template <typename U> static ExecutionContextTokenPtr From(const U& u)
    {
        return mojo::TypeConverter<ExecutionContextTokenPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, ExecutionContextToken>::Convert(*this);
    }

    ExecutionContextToken()
    : tag_(Tag::kLocalFrameToken)
{
    data_.local_frame_token = new ::blink::LocalFrameToken;
}
    ~ExecutionContextToken(){
    DestroyActive();
}
    // Delete the copy constructor and copy assignment operators because `data_`
    // contains raw pointers that must not be copied.
    ExecutionContextToken(const ExecutionContextToken& other) = delete;
    ExecutionContextToken& operator=(const ExecutionContextToken& other) = delete;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename UnionPtrType = ExecutionContextTokenPtr> ExecutionContextTokenPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, typename std::enable_if<std::is_same<T, ExecutionContextToken>::value>::type* = nullptr> bool Equals(const T& other) const;

    template <typename T, typename std::enable_if<std::is_same<T, ExecutionContextToken>::value>::type* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    Tag which() const
    {
        return tag_;
    }

    bool is_local_frame_token() const
    {
        return tag_ == Tag::kLocalFrameToken;
    }

    ::blink::LocalFrameToken& get_local_frame_token() const
    {
        CHECK(tag_ == Tag::kLocalFrameToken);
        return *(data_.local_frame_token);
    }

    void set_local_frame_token(const ::blink::LocalFrameToken& local_frame_token);

    bool is_dedicated_worker_token() const
    {
        return tag_ == Tag::kDedicatedWorkerToken;
    }

    ::blink::DedicatedWorkerToken& get_dedicated_worker_token() const
    {
        CHECK(tag_ == Tag::kDedicatedWorkerToken);
        return *(data_.dedicated_worker_token);
    }

    void set_dedicated_worker_token(const ::blink::DedicatedWorkerToken& dedicated_worker_token);

    bool is_service_worker_token() const
    {
        return tag_ == Tag::kServiceWorkerToken;
    }

    ::blink::ServiceWorkerToken& get_service_worker_token() const
    {
        CHECK(tag_ == Tag::kServiceWorkerToken);
        return *(data_.service_worker_token);
    }

    void set_service_worker_token(const ::blink::ServiceWorkerToken& service_worker_token);

    bool is_shared_worker_token() const
    {
        return tag_ == Tag::kSharedWorkerToken;
    }

    ::blink::SharedWorkerToken& get_shared_worker_token() const
    {
        CHECK(tag_ == Tag::kSharedWorkerToken);
        return *(data_.shared_worker_token);
    }

    void set_shared_worker_token(const ::blink::SharedWorkerToken& shared_worker_token);

    bool is_animation_worklet_token() const
    {
        return tag_ == Tag::kAnimationWorkletToken;
    }

    ::blink::AnimationWorkletToken& get_animation_worklet_token() const
    {
        CHECK(tag_ == Tag::kAnimationWorkletToken);
        return *(data_.animation_worklet_token);
    }

    void set_animation_worklet_token(const ::blink::AnimationWorkletToken& animation_worklet_token);

    bool is_audio_worklet_token() const
    {
        return tag_ == Tag::kAudioWorkletToken;
    }

    ::blink::AudioWorkletToken& get_audio_worklet_token() const
    {
        CHECK(tag_ == Tag::kAudioWorkletToken);
        return *(data_.audio_worklet_token);
    }

    void set_audio_worklet_token(const ::blink::AudioWorkletToken& audio_worklet_token);

    bool is_layout_worklet_token() const
    {
        return tag_ == Tag::kLayoutWorkletToken;
    }

    LayoutWorkletTokenPtr& get_layout_worklet_token() const
    {
        CHECK(tag_ == Tag::kLayoutWorkletToken);
        return *(data_.layout_worklet_token);
    }

    void set_layout_worklet_token(LayoutWorkletTokenPtr layout_worklet_token);

    bool is_paint_worklet_token() const
    {
        return tag_ == Tag::kPaintWorkletToken;
    }

    ::blink::PaintWorkletToken& get_paint_worklet_token() const
    {
        CHECK(tag_ == Tag::kPaintWorkletToken);
        return *(data_.paint_worklet_token);
    }

    void set_paint_worklet_token(const ::blink::PaintWorkletToken& paint_worklet_token);

    bool is_shared_storage_worklet_token() const
    {
        return tag_ == Tag::kSharedStorageWorkletToken;
    }

    SharedStorageWorkletTokenPtr& get_shared_storage_worklet_token() const
    {
        CHECK(tag_ == Tag::kSharedStorageWorkletToken);
        return *(data_.shared_storage_worklet_token);
    }

    void set_shared_storage_worklet_token(SharedStorageWorkletTokenPtr shared_storage_worklet_token);

    bool is_shadow_realm_token() const
    {
        return tag_ == Tag::kShadowRealmToken;
    }

    ::blink::ShadowRealmToken& get_shadow_realm_token() const
    {
        CHECK(tag_ == Tag::kShadowRealmToken);
        return *(data_.shadow_realm_token);
    }

    void set_shadow_realm_token(const ::blink::ShadowRealmToken& shadow_realm_token);

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<ExecutionContextToken::DataView>(input);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        return mojo::internal::DeserializeImpl<ExecutionContextToken::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

private:
    union Union_ {
        Union_() = default;
        ~Union_() = default;
        ::blink::LocalFrameToken* local_frame_token;
        ::blink::DedicatedWorkerToken* dedicated_worker_token;
        ::blink::ServiceWorkerToken* service_worker_token;
        ::blink::SharedWorkerToken* shared_worker_token;
        ::blink::AnimationWorkletToken* animation_worklet_token;
        ::blink::AudioWorkletToken* audio_worklet_token;
        LayoutWorkletTokenPtr* layout_worklet_token;
        ::blink::PaintWorkletToken* paint_worklet_token;
        SharedStorageWorkletTokenPtr* shared_storage_worklet_token;
        ::blink::ShadowRealmToken* shadow_realm_token;
    };

    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    void DestroyActive();
    Tag tag_;
    Union_ data_;
};

class PLATFORM_EXPORT WebGPUExecutionContextToken {
public:
    using DataView = WebGPUExecutionContextTokenDataView;
    using Data_ = internal::WebGPUExecutionContextToken_Data;
    using Tag = Data_::WebGPUExecutionContextToken_Tag;

    template <typename... Args> static WebGPUExecutionContextTokenPtr New(Args&&... args)
    {
        static_assert(sizeof...(args) < 0,
            "Do not use Union::New(); to create a union of a given subtype, use "
            "New<SubType>(), not New() followed by set_<sub_type>(). To represent "
            "an empty union, mark the field or parameter as nullable in the mojom "
            "definition.");
        return nullptr;
    }
    // Construct an instance holding |document_token|.
    static WebGPUExecutionContextTokenPtr NewDocumentToken(const ::blink::DocumentToken& value)
    {
        auto result = WebGPUExecutionContextTokenPtr(std::in_place);
        result->set_document_token(std::move(value));
        return result;
    }
    // Construct an instance holding |dedicated_worker_token|.
    static WebGPUExecutionContextTokenPtr NewDedicatedWorkerToken(const ::blink::DedicatedWorkerToken& value)
    {
        auto result = WebGPUExecutionContextTokenPtr(std::in_place);
        result->set_dedicated_worker_token(std::move(value));
        return result;
    }
    // Construct an instance holding |shared_worker_token|.
    static WebGPUExecutionContextTokenPtr NewSharedWorkerToken(const ::blink::SharedWorkerToken& value)
    {
        auto result = WebGPUExecutionContextTokenPtr(std::in_place);
        result->set_shared_worker_token(std::move(value));
        return result;
    }
    // Construct an instance holding |service_worker_token|.
    static WebGPUExecutionContextTokenPtr NewServiceWorkerToken(const ::blink::ServiceWorkerToken& value)
    {
        auto result = WebGPUExecutionContextTokenPtr(std::in_place);
        result->set_service_worker_token(std::move(value));
        return result;
    }

    template <typename U> static WebGPUExecutionContextTokenPtr From(const U& u)
    {
        return mojo::TypeConverter<WebGPUExecutionContextTokenPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, WebGPUExecutionContextToken>::Convert(*this);
    }

    WebGPUExecutionContextToken()
    : tag_(Tag::kDocumentToken)
{
    data_.document_token = new ::blink::DocumentToken;
}
    ~WebGPUExecutionContextToken(){
    DestroyActive();
}
    // Delete the copy constructor and copy assignment operators because `data_`
    // contains raw pointers that must not be copied.
    WebGPUExecutionContextToken(const WebGPUExecutionContextToken& other) = delete;
    WebGPUExecutionContextToken& operator=(const WebGPUExecutionContextToken& other) = delete;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename UnionPtrType = WebGPUExecutionContextTokenPtr> WebGPUExecutionContextTokenPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, typename std::enable_if<std::is_same<T, WebGPUExecutionContextToken>::value>::type* = nullptr> bool Equals(const T& other) const;

    template <typename T, typename std::enable_if<std::is_same<T, WebGPUExecutionContextToken>::value>::type* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    Tag which() const
    {
        return tag_;
    }

    bool is_document_token() const
    {
        return tag_ == Tag::kDocumentToken;
    }

    ::blink::DocumentToken& get_document_token() const
    {
        CHECK(tag_ == Tag::kDocumentToken);
        return *(data_.document_token);
    }

    void set_document_token(const ::blink::DocumentToken& document_token);

    bool is_dedicated_worker_token() const
    {
        return tag_ == Tag::kDedicatedWorkerToken;
    }

    ::blink::DedicatedWorkerToken& get_dedicated_worker_token() const
    {
        CHECK(tag_ == Tag::kDedicatedWorkerToken);
        return *(data_.dedicated_worker_token);
    }

    void set_dedicated_worker_token(const ::blink::DedicatedWorkerToken& dedicated_worker_token);

    bool is_shared_worker_token() const
    {
        return tag_ == Tag::kSharedWorkerToken;
    }

    ::blink::SharedWorkerToken& get_shared_worker_token() const
    {
        CHECK(tag_ == Tag::kSharedWorkerToken);
        return *(data_.shared_worker_token);
    }

    void set_shared_worker_token(const ::blink::SharedWorkerToken& shared_worker_token);

    bool is_service_worker_token() const
    {
        return tag_ == Tag::kServiceWorkerToken;
    }

    ::blink::ServiceWorkerToken& get_service_worker_token() const
    {
        CHECK(tag_ == Tag::kServiceWorkerToken);
        return *(data_.service_worker_token);
    }

    void set_service_worker_token(const ::blink::ServiceWorkerToken& service_worker_token);

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<WebGPUExecutionContextToken::DataView>(input);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        return mojo::internal::DeserializeImpl<WebGPUExecutionContextToken::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

private:
    union Union_ {
        Union_() = default;
        ~Union_() = default;
        ::blink::DocumentToken* document_token;
        ::blink::DedicatedWorkerToken* dedicated_worker_token;
        ::blink::SharedWorkerToken* shared_worker_token;
        ::blink::ServiceWorkerToken* service_worker_token;
    };

    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    void DestroyActive();
    Tag tag_;
    Union_ data_;
};

class PLATFORM_EXPORT DocumentToken {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<DocumentToken, T>::value>;
    using DataView = DocumentTokenDataView;
    using Data_ = internal::DocumentToken_Data;

    template <typename... Args> static DocumentTokenPtr New(Args&&... args)
    {
        return DocumentTokenPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static DocumentTokenPtr From(const U& u)
    {
        return mojo::TypeConverter<DocumentTokenPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, DocumentToken>::Convert(*this);
    }

    DocumentToken()
    : value()
{
}

    explicit DocumentToken(const ::base::UnguessableToken& value_in)
    : value(std::move(value_in)){
}

    ~DocumentToken() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = DocumentTokenPtr> DocumentTokenPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, DocumentToken::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, DocumentToken::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, DocumentToken::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<DocumentToken::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<DocumentToken::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(std::make_unique<internal::DocumentToken_UnserializedMessageContext<UserType, DocumentToken::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<DocumentToken::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return DocumentToken::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::DocumentToken_UnserializedMessageContext<UserType, DocumentToken::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<DocumentToken::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    ::base::UnguessableToken value;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, DocumentToken::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, DocumentToken::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, DocumentToken::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, DocumentToken::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class PLATFORM_EXPORT LocalFrameToken {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<LocalFrameToken, T>::value>;
    using DataView = LocalFrameTokenDataView;
    using Data_ = internal::LocalFrameToken_Data;

    template <typename... Args> static LocalFrameTokenPtr New(Args&&... args)
    {
        return LocalFrameTokenPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static LocalFrameTokenPtr From(const U& u)
    {
        return mojo::TypeConverter<LocalFrameTokenPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, LocalFrameToken>::Convert(*this);
    }

    LocalFrameToken()
    : value()
{
}

    explicit LocalFrameToken(const ::base::UnguessableToken& value_in)
    : value(std::move(value_in)){
}

    ~LocalFrameToken() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = LocalFrameTokenPtr> LocalFrameTokenPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, LocalFrameToken::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, LocalFrameToken::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, LocalFrameToken::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<LocalFrameToken::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<LocalFrameToken::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::LocalFrameToken_UnserializedMessageContext<UserType, LocalFrameToken::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<LocalFrameToken::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return LocalFrameToken::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::LocalFrameToken_UnserializedMessageContext<UserType, LocalFrameToken::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<LocalFrameToken::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    ::base::UnguessableToken value;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, LocalFrameToken::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, LocalFrameToken::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, LocalFrameToken::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, LocalFrameToken::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class PLATFORM_EXPORT RemoteFrameToken {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<RemoteFrameToken, T>::value>;
    using DataView = RemoteFrameTokenDataView;
    using Data_ = internal::RemoteFrameToken_Data;

    template <typename... Args> static RemoteFrameTokenPtr New(Args&&... args)
    {
        return RemoteFrameTokenPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static RemoteFrameTokenPtr From(const U& u)
    {
        return mojo::TypeConverter<RemoteFrameTokenPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, RemoteFrameToken>::Convert(*this);
    }

    RemoteFrameToken()
    : value()
{
}

    explicit RemoteFrameToken(const ::base::UnguessableToken& value_in)
    : value(std::move(value_in)){
}

    ~RemoteFrameToken() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = RemoteFrameTokenPtr> RemoteFrameTokenPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, RemoteFrameToken::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, RemoteFrameToken::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, RemoteFrameToken::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<RemoteFrameToken::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<RemoteFrameToken::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::RemoteFrameToken_UnserializedMessageContext<UserType, RemoteFrameToken::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<RemoteFrameToken::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return RemoteFrameToken::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::RemoteFrameToken_UnserializedMessageContext<UserType, RemoteFrameToken::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<RemoteFrameToken::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    ::base::UnguessableToken value;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, RemoteFrameToken::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, RemoteFrameToken::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, RemoteFrameToken::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, RemoteFrameToken::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class PLATFORM_EXPORT DedicatedWorkerToken {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<DedicatedWorkerToken, T>::value>;
    using DataView = DedicatedWorkerTokenDataView;
    using Data_ = internal::DedicatedWorkerToken_Data;

    template <typename... Args> static DedicatedWorkerTokenPtr New(Args&&... args)
    {
        return DedicatedWorkerTokenPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static DedicatedWorkerTokenPtr From(const U& u)
    {
        return mojo::TypeConverter<DedicatedWorkerTokenPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, DedicatedWorkerToken>::Convert(*this);
    }

    DedicatedWorkerToken()
    : value()
{
}

    explicit DedicatedWorkerToken(const ::base::UnguessableToken& value_in)
    : value(std::move(value_in)){
}

    ~DedicatedWorkerToken() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = DedicatedWorkerTokenPtr> DedicatedWorkerTokenPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, DedicatedWorkerToken::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, DedicatedWorkerToken::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, DedicatedWorkerToken::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<DedicatedWorkerToken::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<DedicatedWorkerToken::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::DedicatedWorkerToken_UnserializedMessageContext<UserType, DedicatedWorkerToken::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<DedicatedWorkerToken::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return DedicatedWorkerToken::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::DedicatedWorkerToken_UnserializedMessageContext<UserType, DedicatedWorkerToken::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<DedicatedWorkerToken::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    ::base::UnguessableToken value;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, DedicatedWorkerToken::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, DedicatedWorkerToken::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, DedicatedWorkerToken::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, DedicatedWorkerToken::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class PLATFORM_EXPORT ServiceWorkerToken {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<ServiceWorkerToken, T>::value>;
    using DataView = ServiceWorkerTokenDataView;
    using Data_ = internal::ServiceWorkerToken_Data;

    template <typename... Args> static ServiceWorkerTokenPtr New(Args&&... args)
    {
        return ServiceWorkerTokenPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static ServiceWorkerTokenPtr From(const U& u)
    {
        return mojo::TypeConverter<ServiceWorkerTokenPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, ServiceWorkerToken>::Convert(*this);
    }

    ServiceWorkerToken()
    : value()
{
}

    explicit ServiceWorkerToken(const ::base::UnguessableToken& value_in)
    : value(std::move(value_in)){
}

    ~ServiceWorkerToken() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = ServiceWorkerTokenPtr> ServiceWorkerTokenPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, ServiceWorkerToken::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, ServiceWorkerToken::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, ServiceWorkerToken::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<ServiceWorkerToken::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<ServiceWorkerToken::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::ServiceWorkerToken_UnserializedMessageContext<UserType, ServiceWorkerToken::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<ServiceWorkerToken::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return ServiceWorkerToken::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::ServiceWorkerToken_UnserializedMessageContext<UserType, ServiceWorkerToken::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<ServiceWorkerToken::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    ::base::UnguessableToken value;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, ServiceWorkerToken::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, ServiceWorkerToken::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, ServiceWorkerToken::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, ServiceWorkerToken::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class PLATFORM_EXPORT SharedWorkerToken {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<SharedWorkerToken, T>::value>;
    using DataView = SharedWorkerTokenDataView;
    using Data_ = internal::SharedWorkerToken_Data;

    template <typename... Args> static SharedWorkerTokenPtr New(Args&&... args)
    {
        return SharedWorkerTokenPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static SharedWorkerTokenPtr From(const U& u)
    {
        return mojo::TypeConverter<SharedWorkerTokenPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, SharedWorkerToken>::Convert(*this);
    }

    SharedWorkerToken()
    : value()
{
}

    explicit SharedWorkerToken(const ::base::UnguessableToken& value_in)
    : value(std::move(value_in)){
}

    ~SharedWorkerToken() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = SharedWorkerTokenPtr> SharedWorkerTokenPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, SharedWorkerToken::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, SharedWorkerToken::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, SharedWorkerToken::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<SharedWorkerToken::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<SharedWorkerToken::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::SharedWorkerToken_UnserializedMessageContext<UserType, SharedWorkerToken::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<SharedWorkerToken::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return SharedWorkerToken::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::SharedWorkerToken_UnserializedMessageContext<UserType, SharedWorkerToken::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<SharedWorkerToken::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    ::base::UnguessableToken value;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, SharedWorkerToken::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, SharedWorkerToken::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, SharedWorkerToken::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, SharedWorkerToken::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class PLATFORM_EXPORT AnimationWorkletToken {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<AnimationWorkletToken, T>::value>;
    using DataView = AnimationWorkletTokenDataView;
    using Data_ = internal::AnimationWorkletToken_Data;

    template <typename... Args> static AnimationWorkletTokenPtr New(Args&&... args)
    {
        return AnimationWorkletTokenPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static AnimationWorkletTokenPtr From(const U& u)
    {
        return mojo::TypeConverter<AnimationWorkletTokenPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, AnimationWorkletToken>::Convert(*this);
    }

    AnimationWorkletToken()
    : value()
{
}

    explicit AnimationWorkletToken(const ::base::UnguessableToken& value_in)
    : value(std::move(value_in)){
}

    ~AnimationWorkletToken() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = AnimationWorkletTokenPtr> AnimationWorkletTokenPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, AnimationWorkletToken::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, AnimationWorkletToken::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, AnimationWorkletToken::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<AnimationWorkletToken::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<AnimationWorkletToken::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::AnimationWorkletToken_UnserializedMessageContext<UserType, AnimationWorkletToken::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<AnimationWorkletToken::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return AnimationWorkletToken::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::AnimationWorkletToken_UnserializedMessageContext<UserType, AnimationWorkletToken::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<AnimationWorkletToken::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    ::base::UnguessableToken value;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, AnimationWorkletToken::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, AnimationWorkletToken::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, AnimationWorkletToken::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, AnimationWorkletToken::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class PLATFORM_EXPORT AudioWorkletToken {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<AudioWorkletToken, T>::value>;
    using DataView = AudioWorkletTokenDataView;
    using Data_ = internal::AudioWorkletToken_Data;

    template <typename... Args> static AudioWorkletTokenPtr New(Args&&... args)
    {
        return AudioWorkletTokenPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static AudioWorkletTokenPtr From(const U& u)
    {
        return mojo::TypeConverter<AudioWorkletTokenPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, AudioWorkletToken>::Convert(*this);
    }

    AudioWorkletToken()
    : value()
{
}

    explicit AudioWorkletToken(const ::base::UnguessableToken& value_in)
    : value(std::move(value_in)){
}

    ~AudioWorkletToken() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = AudioWorkletTokenPtr> AudioWorkletTokenPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, AudioWorkletToken::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, AudioWorkletToken::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, AudioWorkletToken::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<AudioWorkletToken::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<AudioWorkletToken::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::AudioWorkletToken_UnserializedMessageContext<UserType, AudioWorkletToken::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<AudioWorkletToken::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return AudioWorkletToken::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::AudioWorkletToken_UnserializedMessageContext<UserType, AudioWorkletToken::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<AudioWorkletToken::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    ::base::UnguessableToken value;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, AudioWorkletToken::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, AudioWorkletToken::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, AudioWorkletToken::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, AudioWorkletToken::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class PLATFORM_EXPORT LayoutWorkletToken {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<LayoutWorkletToken, T>::value>;
    using DataView = LayoutWorkletTokenDataView;
    using Data_ = internal::LayoutWorkletToken_Data;

    template <typename... Args> static LayoutWorkletTokenPtr New(Args&&... args)
    {
        return LayoutWorkletTokenPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static LayoutWorkletTokenPtr From(const U& u)
    {
        return mojo::TypeConverter<LayoutWorkletTokenPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, LayoutWorkletToken>::Convert(*this);
    }

    LayoutWorkletToken()
    : value()
{
}

    explicit LayoutWorkletToken(const ::base::UnguessableToken& value_in)
    : value(std::move(value_in)){
}

    ~LayoutWorkletToken() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = LayoutWorkletTokenPtr> LayoutWorkletTokenPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, LayoutWorkletToken::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, LayoutWorkletToken::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, LayoutWorkletToken::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<LayoutWorkletToken::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<LayoutWorkletToken::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::LayoutWorkletToken_UnserializedMessageContext<UserType, LayoutWorkletToken::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<LayoutWorkletToken::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return LayoutWorkletToken::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::LayoutWorkletToken_UnserializedMessageContext<UserType, LayoutWorkletToken::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<LayoutWorkletToken::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    ::base::UnguessableToken value;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, LayoutWorkletToken::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, LayoutWorkletToken::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, LayoutWorkletToken::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, LayoutWorkletToken::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class PLATFORM_EXPORT PaintWorkletToken {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<PaintWorkletToken, T>::value>;
    using DataView = PaintWorkletTokenDataView;
    using Data_ = internal::PaintWorkletToken_Data;

    template <typename... Args> static PaintWorkletTokenPtr New(Args&&... args)
    {
        return PaintWorkletTokenPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static PaintWorkletTokenPtr From(const U& u)
    {
        return mojo::TypeConverter<PaintWorkletTokenPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, PaintWorkletToken>::Convert(*this);
    }

    PaintWorkletToken()
    : value()
{
}

    explicit PaintWorkletToken(const ::base::UnguessableToken& value_in)
    : value(std::move(value_in)){
}

    ~PaintWorkletToken() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = PaintWorkletTokenPtr> PaintWorkletTokenPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, PaintWorkletToken::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, PaintWorkletToken::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, PaintWorkletToken::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<PaintWorkletToken::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<PaintWorkletToken::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::PaintWorkletToken_UnserializedMessageContext<UserType, PaintWorkletToken::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<PaintWorkletToken::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return PaintWorkletToken::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::PaintWorkletToken_UnserializedMessageContext<UserType, PaintWorkletToken::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<PaintWorkletToken::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    ::base::UnguessableToken value;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, PaintWorkletToken::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, PaintWorkletToken::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, PaintWorkletToken::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, PaintWorkletToken::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class PLATFORM_EXPORT SharedStorageWorkletToken {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<SharedStorageWorkletToken, T>::value>;
    using DataView = SharedStorageWorkletTokenDataView;
    using Data_ = internal::SharedStorageWorkletToken_Data;

    template <typename... Args> static SharedStorageWorkletTokenPtr New(Args&&... args)
    {
        return SharedStorageWorkletTokenPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static SharedStorageWorkletTokenPtr From(const U& u)
    {
        return mojo::TypeConverter<SharedStorageWorkletTokenPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, SharedStorageWorkletToken>::Convert(*this);
    }

    SharedStorageWorkletToken()
    : value()
{
}

    explicit SharedStorageWorkletToken(const ::base::UnguessableToken& value_in)
    : value(std::move(value_in)){
}

    ~SharedStorageWorkletToken() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = SharedStorageWorkletTokenPtr> SharedStorageWorkletTokenPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, SharedStorageWorkletToken::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, SharedStorageWorkletToken::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, SharedStorageWorkletToken::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<SharedStorageWorkletToken::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<SharedStorageWorkletToken::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(std::make_unique<internal::SharedStorageWorkletToken_UnserializedMessageContext<UserType, SharedStorageWorkletToken::DataView>>(
                                 0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<SharedStorageWorkletToken::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return SharedStorageWorkletToken::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context
            = input.TakeUnserializedContext<internal::SharedStorageWorkletToken_UnserializedMessageContext<UserType, SharedStorageWorkletToken::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<SharedStorageWorkletToken::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    ::base::UnguessableToken value;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, SharedStorageWorkletToken::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, SharedStorageWorkletToken::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, SharedStorageWorkletToken::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, SharedStorageWorkletToken::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class PLATFORM_EXPORT ShadowRealmToken {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<ShadowRealmToken, T>::value>;
    using DataView = ShadowRealmTokenDataView;
    using Data_ = internal::ShadowRealmToken_Data;

    template <typename... Args> static ShadowRealmTokenPtr New(Args&&... args)
    {
        return ShadowRealmTokenPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static ShadowRealmTokenPtr From(const U& u)
    {
        return mojo::TypeConverter<ShadowRealmTokenPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, ShadowRealmToken>::Convert(*this);
    }

    ShadowRealmToken()
    : value()
{
}

    explicit ShadowRealmToken(const ::base::UnguessableToken& value_in)
    : value(std::move(value_in)){
}

    ~ShadowRealmToken() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = ShadowRealmTokenPtr> ShadowRealmTokenPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, ShadowRealmToken::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, ShadowRealmToken::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, ShadowRealmToken::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<ShadowRealmToken::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<ShadowRealmToken::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::ShadowRealmToken_UnserializedMessageContext<UserType, ShadowRealmToken::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<ShadowRealmToken::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return ShadowRealmToken::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::ShadowRealmToken_UnserializedMessageContext<UserType, ShadowRealmToken::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<ShadowRealmToken::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    ::base::UnguessableToken value;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, ShadowRealmToken::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, ShadowRealmToken::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, ShadowRealmToken::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, ShadowRealmToken::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class PLATFORM_EXPORT AttributionSrcToken {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<AttributionSrcToken, T>::value>;
    using DataView = AttributionSrcTokenDataView;
    using Data_ = internal::AttributionSrcToken_Data;

    template <typename... Args> static AttributionSrcTokenPtr New(Args&&... args)
    {
        return AttributionSrcTokenPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static AttributionSrcTokenPtr From(const U& u)
    {
        return mojo::TypeConverter<AttributionSrcTokenPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, AttributionSrcToken>::Convert(*this);
    }

    AttributionSrcToken()
    : value()
{
}

    explicit AttributionSrcToken(const ::base::UnguessableToken& value_in)
    : value(std::move(value_in)){
}

    ~AttributionSrcToken() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = AttributionSrcTokenPtr> AttributionSrcTokenPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, AttributionSrcToken::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, AttributionSrcToken::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, AttributionSrcToken::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<AttributionSrcToken::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<AttributionSrcToken::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::AttributionSrcToken_UnserializedMessageContext<UserType, AttributionSrcToken::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<AttributionSrcToken::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return AttributionSrcToken::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::AttributionSrcToken_UnserializedMessageContext<UserType, AttributionSrcToken::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<AttributionSrcToken::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    ::base::UnguessableToken value;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, AttributionSrcToken::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, AttributionSrcToken::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, AttributionSrcToken::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, AttributionSrcToken::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class PLATFORM_EXPORT ClipboardSequenceNumberToken {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<ClipboardSequenceNumberToken, T>::value>;
    using DataView = ClipboardSequenceNumberTokenDataView;
    using Data_ = internal::ClipboardSequenceNumberToken_Data;

    template <typename... Args> static ClipboardSequenceNumberTokenPtr New(Args&&... args)
    {
        return ClipboardSequenceNumberTokenPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static ClipboardSequenceNumberTokenPtr From(const U& u)
    {
        return mojo::TypeConverter<ClipboardSequenceNumberTokenPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, ClipboardSequenceNumberToken>::Convert(*this);
    }

    ClipboardSequenceNumberToken()
    : value()
{
}

    explicit ClipboardSequenceNumberToken(const ::base::UnguessableToken& value_in)
    : value(std::move(value_in)){
}

    ~ClipboardSequenceNumberToken() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = ClipboardSequenceNumberTokenPtr> ClipboardSequenceNumberTokenPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, ClipboardSequenceNumberToken::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, ClipboardSequenceNumberToken::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, ClipboardSequenceNumberToken::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<ClipboardSequenceNumberToken::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<ClipboardSequenceNumberToken::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::ClipboardSequenceNumberToken_UnserializedMessageContext<UserType, ClipboardSequenceNumberToken::DataView>>(
                0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<ClipboardSequenceNumberToken::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return ClipboardSequenceNumberToken::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<
            internal::ClipboardSequenceNumberToken_UnserializedMessageContext<UserType, ClipboardSequenceNumberToken::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<ClipboardSequenceNumberToken::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    ::base::UnguessableToken value;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, ClipboardSequenceNumberToken::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, ClipboardSequenceNumberToken::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, ClipboardSequenceNumberToken::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, ClipboardSequenceNumberToken::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class PLATFORM_EXPORT SameDocNavigationScreenshotDestinationToken {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<SameDocNavigationScreenshotDestinationToken, T>::value>;
    using DataView = SameDocNavigationScreenshotDestinationTokenDataView;
    using Data_ = internal::SameDocNavigationScreenshotDestinationToken_Data;

    template <typename... Args> static SameDocNavigationScreenshotDestinationTokenPtr New(Args&&... args)
    {
        return SameDocNavigationScreenshotDestinationTokenPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static SameDocNavigationScreenshotDestinationTokenPtr From(const U& u)
    {
        return mojo::TypeConverter<SameDocNavigationScreenshotDestinationTokenPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, SameDocNavigationScreenshotDestinationToken>::Convert(*this);
    }

    SameDocNavigationScreenshotDestinationToken()
    : value()
{
}

    explicit SameDocNavigationScreenshotDestinationToken(const ::base::UnguessableToken& value_in)
    : value(std::move(value_in)){
}

    ~SameDocNavigationScreenshotDestinationToken() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = SameDocNavigationScreenshotDestinationTokenPtr> SameDocNavigationScreenshotDestinationTokenPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, SameDocNavigationScreenshotDestinationToken::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, SameDocNavigationScreenshotDestinationToken::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, SameDocNavigationScreenshotDestinationToken::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<SameDocNavigationScreenshotDestinationToken::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<SameDocNavigationScreenshotDestinationToken::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(std::make_unique<internal::SameDocNavigationScreenshotDestinationToken_UnserializedMessageContext<UserType,
                                 SameDocNavigationScreenshotDestinationToken::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<SameDocNavigationScreenshotDestinationToken::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return SameDocNavigationScreenshotDestinationToken::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::SameDocNavigationScreenshotDestinationToken_UnserializedMessageContext<UserType,
            SameDocNavigationScreenshotDestinationToken::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<SameDocNavigationScreenshotDestinationToken::DataView>(
            input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    ::base::UnguessableToken value;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, SameDocNavigationScreenshotDestinationToken::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, SameDocNavigationScreenshotDestinationToken::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, SameDocNavigationScreenshotDestinationToken::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, SameDocNavigationScreenshotDestinationToken::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class PLATFORM_EXPORT V8ContextToken {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<V8ContextToken, T>::value>;
    using DataView = V8ContextTokenDataView;
    using Data_ = internal::V8ContextToken_Data;

    template <typename... Args> static V8ContextTokenPtr New(Args&&... args)
    {
        return V8ContextTokenPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static V8ContextTokenPtr From(const U& u)
    {
        return mojo::TypeConverter<V8ContextTokenPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, V8ContextToken>::Convert(*this);
    }

    V8ContextToken()
    : value()
{
}

    explicit V8ContextToken(const ::base::UnguessableToken& value_in)
    : value(std::move(value_in)){
}

    ~V8ContextToken() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = V8ContextTokenPtr> V8ContextTokenPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, V8ContextToken::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, V8ContextToken::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, V8ContextToken::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<V8ContextToken::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<V8ContextToken::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(std::make_unique<internal::V8ContextToken_UnserializedMessageContext<UserType, V8ContextToken::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<V8ContextToken::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return V8ContextToken::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::V8ContextToken_UnserializedMessageContext<UserType, V8ContextToken::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<V8ContextToken::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    ::base::UnguessableToken value;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, V8ContextToken::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, V8ContextToken::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, V8ContextToken::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, V8ContextToken::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class PLATFORM_EXPORT ViewTransitionToken {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<ViewTransitionToken, T>::value>;
    using DataView = ViewTransitionTokenDataView;
    using Data_ = internal::ViewTransitionToken_Data;

    template <typename... Args> static ViewTransitionTokenPtr New(Args&&... args)
    {
        return ViewTransitionTokenPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static ViewTransitionTokenPtr From(const U& u)
    {
        return mojo::TypeConverter<ViewTransitionTokenPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, ViewTransitionToken>::Convert(*this);
    }

    ViewTransitionToken()
    : value()
{
}

    explicit ViewTransitionToken(const ::base::UnguessableToken& value_in)
    : value(std::move(value_in)){
}

    ~ViewTransitionToken() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = ViewTransitionTokenPtr> ViewTransitionTokenPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, ViewTransitionToken::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, ViewTransitionToken::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, ViewTransitionToken::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<ViewTransitionToken::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<ViewTransitionToken::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::ViewTransitionToken_UnserializedMessageContext<UserType, ViewTransitionToken::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<ViewTransitionToken::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return ViewTransitionToken::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::ViewTransitionToken_UnserializedMessageContext<UserType, ViewTransitionToken::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<ViewTransitionToken::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    ::base::UnguessableToken value;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, ViewTransitionToken::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, ViewTransitionToken::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, ViewTransitionToken::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, ViewTransitionToken::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class PLATFORM_EXPORT WebNNContextToken {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<WebNNContextToken, T>::value>;
    using DataView = WebNNContextTokenDataView;
    using Data_ = internal::WebNNContextToken_Data;

    template <typename... Args> static WebNNContextTokenPtr New(Args&&... args)
    {
        return WebNNContextTokenPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static WebNNContextTokenPtr From(const U& u)
    {
        return mojo::TypeConverter<WebNNContextTokenPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, WebNNContextToken>::Convert(*this);
    }

    WebNNContextToken()
    : value()
{
}

    explicit WebNNContextToken(const ::base::UnguessableToken& value_in)
    : value(std::move(value_in)){
}

    ~WebNNContextToken() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = WebNNContextTokenPtr> WebNNContextTokenPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, WebNNContextToken::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, WebNNContextToken::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, WebNNContextToken::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<WebNNContextToken::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<WebNNContextToken::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::WebNNContextToken_UnserializedMessageContext<UserType, WebNNContextToken::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<WebNNContextToken::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return WebNNContextToken::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::WebNNContextToken_UnserializedMessageContext<UserType, WebNNContextToken::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<WebNNContextToken::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    ::base::UnguessableToken value;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, WebNNContextToken::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, WebNNContextToken::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, WebNNContextToken::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, WebNNContextToken::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class PLATFORM_EXPORT WebNNTensorToken {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<WebNNTensorToken, T>::value>;
    using DataView = WebNNTensorTokenDataView;
    using Data_ = internal::WebNNTensorToken_Data;

    template <typename... Args> static WebNNTensorTokenPtr New(Args&&... args)
    {
        return WebNNTensorTokenPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static WebNNTensorTokenPtr From(const U& u)
    {
        return mojo::TypeConverter<WebNNTensorTokenPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, WebNNTensorToken>::Convert(*this);
    }

    WebNNTensorToken()
    : value()
{
}

    explicit WebNNTensorToken(const ::base::UnguessableToken& value_in)
    : value(std::move(value_in)){
}

    ~WebNNTensorToken() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = WebNNTensorTokenPtr> WebNNTensorTokenPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, WebNNTensorToken::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, WebNNTensorToken::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, WebNNTensorToken::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<WebNNTensorToken::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<WebNNTensorToken::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::WebNNTensorToken_UnserializedMessageContext<UserType, WebNNTensorToken::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<WebNNTensorToken::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return WebNNTensorToken::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::WebNNTensorToken_UnserializedMessageContext<UserType, WebNNTensorToken::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<WebNNTensorToken::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    ::base::UnguessableToken value;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, WebNNTensorToken::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, WebNNTensorToken::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, WebNNTensorToken::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, WebNNTensorToken::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

template <typename UnionPtrType> FrameTokenPtr FrameToken::Clone() const
{
    switch (tag_) {
    case Tag::kLocalFrameToken:
        return NewLocalFrameToken(mojo::Clone(*data_.local_frame_token));
    case Tag::kRemoteFrameToken:
        return NewRemoteFrameToken(mojo::Clone(*data_.remote_frame_token));
    }
    return nullptr;
}

template <typename T, typename std::enable_if<std::is_same<T, FrameToken>::value>::type*> bool FrameToken::Equals(const T& other) const
{
    if (tag_ != other.which())
        return false;

    switch (tag_) {
    case Tag::kLocalFrameToken:
        return mojo::Equals(*(data_.local_frame_token), *(other.data_.local_frame_token));
    case Tag::kRemoteFrameToken:
        return mojo::Equals(*(data_.remote_frame_token), *(other.data_.remote_frame_token));
    }

    return false;
}
template <typename UnionPtrType> WorkerTokenPtr WorkerToken::Clone() const
{
    switch (tag_) {
    case Tag::kDedicatedWorkerToken:
        return NewDedicatedWorkerToken(mojo::Clone(*data_.dedicated_worker_token));
    case Tag::kServiceWorkerToken:
        return NewServiceWorkerToken(mojo::Clone(*data_.service_worker_token));
    case Tag::kSharedWorkerToken:
        return NewSharedWorkerToken(mojo::Clone(*data_.shared_worker_token));
    }
    return nullptr;
}

template <typename T, typename std::enable_if<std::is_same<T, WorkerToken>::value>::type*> bool WorkerToken::Equals(const T& other) const
{
    if (tag_ != other.which())
        return false;

    switch (tag_) {
    case Tag::kDedicatedWorkerToken:
        return mojo::Equals(*(data_.dedicated_worker_token), *(other.data_.dedicated_worker_token));
    case Tag::kServiceWorkerToken:
        return mojo::Equals(*(data_.service_worker_token), *(other.data_.service_worker_token));
    case Tag::kSharedWorkerToken:
        return mojo::Equals(*(data_.shared_worker_token), *(other.data_.shared_worker_token));
    }

    return false;
}
template <typename UnionPtrType> WorkletTokenPtr WorkletToken::Clone() const
{
    switch (tag_) {
    case Tag::kAnimationWorkletToken:
        return NewAnimationWorkletToken(mojo::Clone(*data_.animation_worklet_token));
    case Tag::kAudioWorkletToken:
        return NewAudioWorkletToken(mojo::Clone(*data_.audio_worklet_token));
    case Tag::kLayoutWorkletToken:
        return NewLayoutWorkletToken(mojo::Clone(*data_.layout_worklet_token));
    case Tag::kPaintWorkletToken:
        return NewPaintWorkletToken(mojo::Clone(*data_.paint_worklet_token));
    case Tag::kSharedStorageWorkletToken:
        return NewSharedStorageWorkletToken(mojo::Clone(*data_.shared_storage_worklet_token));
    }
    return nullptr;
}

template <typename T, typename std::enable_if<std::is_same<T, WorkletToken>::value>::type*> bool WorkletToken::Equals(const T& other) const
{
    if (tag_ != other.which())
        return false;

    switch (tag_) {
    case Tag::kAnimationWorkletToken:
        return mojo::Equals(*(data_.animation_worklet_token), *(other.data_.animation_worklet_token));
    case Tag::kAudioWorkletToken:
        return mojo::Equals(*(data_.audio_worklet_token), *(other.data_.audio_worklet_token));
    case Tag::kLayoutWorkletToken:
        return mojo::Equals(*(data_.layout_worklet_token), *(other.data_.layout_worklet_token));
    case Tag::kPaintWorkletToken:
        return mojo::Equals(*(data_.paint_worklet_token), *(other.data_.paint_worklet_token));
    case Tag::kSharedStorageWorkletToken:
        return mojo::Equals(*(data_.shared_storage_worklet_token), *(other.data_.shared_storage_worklet_token));
    }

    return false;
}
template <typename UnionPtrType> ExecutionContextTokenPtr ExecutionContextToken::Clone() const
{
    switch (tag_) {
    case Tag::kLocalFrameToken:
        return NewLocalFrameToken(mojo::Clone(*data_.local_frame_token));
    case Tag::kDedicatedWorkerToken:
        return NewDedicatedWorkerToken(mojo::Clone(*data_.dedicated_worker_token));
    case Tag::kServiceWorkerToken:
        return NewServiceWorkerToken(mojo::Clone(*data_.service_worker_token));
    case Tag::kSharedWorkerToken:
        return NewSharedWorkerToken(mojo::Clone(*data_.shared_worker_token));
    case Tag::kAnimationWorkletToken:
        return NewAnimationWorkletToken(mojo::Clone(*data_.animation_worklet_token));
    case Tag::kAudioWorkletToken:
        return NewAudioWorkletToken(mojo::Clone(*data_.audio_worklet_token));
    case Tag::kLayoutWorkletToken:
        return NewLayoutWorkletToken(mojo::Clone(*data_.layout_worklet_token));
    case Tag::kPaintWorkletToken:
        return NewPaintWorkletToken(mojo::Clone(*data_.paint_worklet_token));
    case Tag::kSharedStorageWorkletToken:
        return NewSharedStorageWorkletToken(mojo::Clone(*data_.shared_storage_worklet_token));
    case Tag::kShadowRealmToken:
        return NewShadowRealmToken(mojo::Clone(*data_.shadow_realm_token));
    }
    return nullptr;
}

template <typename T, typename std::enable_if<std::is_same<T, ExecutionContextToken>::value>::type*> bool ExecutionContextToken::Equals(const T& other) const
{
    if (tag_ != other.which())
        return false;

    switch (tag_) {
    case Tag::kLocalFrameToken:
        return mojo::Equals(*(data_.local_frame_token), *(other.data_.local_frame_token));
    case Tag::kDedicatedWorkerToken:
        return mojo::Equals(*(data_.dedicated_worker_token), *(other.data_.dedicated_worker_token));
    case Tag::kServiceWorkerToken:
        return mojo::Equals(*(data_.service_worker_token), *(other.data_.service_worker_token));
    case Tag::kSharedWorkerToken:
        return mojo::Equals(*(data_.shared_worker_token), *(other.data_.shared_worker_token));
    case Tag::kAnimationWorkletToken:
        return mojo::Equals(*(data_.animation_worklet_token), *(other.data_.animation_worklet_token));
    case Tag::kAudioWorkletToken:
        return mojo::Equals(*(data_.audio_worklet_token), *(other.data_.audio_worklet_token));
    case Tag::kLayoutWorkletToken:
        return mojo::Equals(*(data_.layout_worklet_token), *(other.data_.layout_worklet_token));
    case Tag::kPaintWorkletToken:
        return mojo::Equals(*(data_.paint_worklet_token), *(other.data_.paint_worklet_token));
    case Tag::kSharedStorageWorkletToken:
        return mojo::Equals(*(data_.shared_storage_worklet_token), *(other.data_.shared_storage_worklet_token));
    case Tag::kShadowRealmToken:
        return mojo::Equals(*(data_.shadow_realm_token), *(other.data_.shadow_realm_token));
    }

    return false;
}
template <typename UnionPtrType> WebGPUExecutionContextTokenPtr WebGPUExecutionContextToken::Clone() const
{
    switch (tag_) {
    case Tag::kDocumentToken:
        return NewDocumentToken(mojo::Clone(*data_.document_token));
    case Tag::kDedicatedWorkerToken:
        return NewDedicatedWorkerToken(mojo::Clone(*data_.dedicated_worker_token));
    case Tag::kSharedWorkerToken:
        return NewSharedWorkerToken(mojo::Clone(*data_.shared_worker_token));
    case Tag::kServiceWorkerToken:
        return NewServiceWorkerToken(mojo::Clone(*data_.service_worker_token));
    }
    return nullptr;
}

template <typename T, typename std::enable_if<std::is_same<T, WebGPUExecutionContextToken>::value>::type*>
bool WebGPUExecutionContextToken::Equals(const T& other) const
{
    if (tag_ != other.which())
        return false;

    switch (tag_) {
    case Tag::kDocumentToken:
        return mojo::Equals(*(data_.document_token), *(other.data_.document_token));
    case Tag::kDedicatedWorkerToken:
        return mojo::Equals(*(data_.dedicated_worker_token), *(other.data_.dedicated_worker_token));
    case Tag::kSharedWorkerToken:
        return mojo::Equals(*(data_.shared_worker_token), *(other.data_.shared_worker_token));
    case Tag::kServiceWorkerToken:
        return mojo::Equals(*(data_.service_worker_token), *(other.data_.service_worker_token));
    }

    return false;
}
template <typename StructPtrType> DocumentTokenPtr DocumentToken::Clone() const
{
    return New(mojo::Clone(value));
}

template <typename T, DocumentToken::EnableIfSame<T>*> bool DocumentToken::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->value, other_struct.value))
        return false;
    return true;
}

template <typename T, DocumentToken::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.value < rhs.value)
        return true;
    if (rhs.value < lhs.value)
        return false;
    return false;
}
template <typename StructPtrType> LocalFrameTokenPtr LocalFrameToken::Clone() const
{
    return New(mojo::Clone(value));
}

template <typename T, LocalFrameToken::EnableIfSame<T>*> bool LocalFrameToken::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->value, other_struct.value))
        return false;
    return true;
}

template <typename T, LocalFrameToken::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.value < rhs.value)
        return true;
    if (rhs.value < lhs.value)
        return false;
    return false;
}
template <typename StructPtrType> RemoteFrameTokenPtr RemoteFrameToken::Clone() const
{
    return New(mojo::Clone(value));
}

template <typename T, RemoteFrameToken::EnableIfSame<T>*> bool RemoteFrameToken::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->value, other_struct.value))
        return false;
    return true;
}

template <typename T, RemoteFrameToken::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.value < rhs.value)
        return true;
    if (rhs.value < lhs.value)
        return false;
    return false;
}
template <typename StructPtrType> DedicatedWorkerTokenPtr DedicatedWorkerToken::Clone() const
{
    return New(mojo::Clone(value));
}

template <typename T, DedicatedWorkerToken::EnableIfSame<T>*> bool DedicatedWorkerToken::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->value, other_struct.value))
        return false;
    return true;
}

template <typename T, DedicatedWorkerToken::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.value < rhs.value)
        return true;
    if (rhs.value < lhs.value)
        return false;
    return false;
}
template <typename StructPtrType> ServiceWorkerTokenPtr ServiceWorkerToken::Clone() const
{
    return New(mojo::Clone(value));
}

template <typename T, ServiceWorkerToken::EnableIfSame<T>*> bool ServiceWorkerToken::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->value, other_struct.value))
        return false;
    return true;
}

template <typename T, ServiceWorkerToken::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.value < rhs.value)
        return true;
    if (rhs.value < lhs.value)
        return false;
    return false;
}
template <typename StructPtrType> SharedWorkerTokenPtr SharedWorkerToken::Clone() const
{
    return New(mojo::Clone(value));
}

template <typename T, SharedWorkerToken::EnableIfSame<T>*> bool SharedWorkerToken::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->value, other_struct.value))
        return false;
    return true;
}

template <typename T, SharedWorkerToken::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.value < rhs.value)
        return true;
    if (rhs.value < lhs.value)
        return false;
    return false;
}
template <typename StructPtrType> AnimationWorkletTokenPtr AnimationWorkletToken::Clone() const
{
    return New(mojo::Clone(value));
}

template <typename T, AnimationWorkletToken::EnableIfSame<T>*> bool AnimationWorkletToken::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->value, other_struct.value))
        return false;
    return true;
}

template <typename T, AnimationWorkletToken::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.value < rhs.value)
        return true;
    if (rhs.value < lhs.value)
        return false;
    return false;
}
template <typename StructPtrType> AudioWorkletTokenPtr AudioWorkletToken::Clone() const
{
    return New(mojo::Clone(value));
}

template <typename T, AudioWorkletToken::EnableIfSame<T>*> bool AudioWorkletToken::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->value, other_struct.value))
        return false;
    return true;
}

template <typename T, AudioWorkletToken::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.value < rhs.value)
        return true;
    if (rhs.value < lhs.value)
        return false;
    return false;
}
template <typename StructPtrType> LayoutWorkletTokenPtr LayoutWorkletToken::Clone() const
{
    return New(mojo::Clone(value));
}

template <typename T, LayoutWorkletToken::EnableIfSame<T>*> bool LayoutWorkletToken::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->value, other_struct.value))
        return false;
    return true;
}

template <typename T, LayoutWorkletToken::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.value < rhs.value)
        return true;
    if (rhs.value < lhs.value)
        return false;
    return false;
}
template <typename StructPtrType> PaintWorkletTokenPtr PaintWorkletToken::Clone() const
{
    return New(mojo::Clone(value));
}

template <typename T, PaintWorkletToken::EnableIfSame<T>*> bool PaintWorkletToken::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->value, other_struct.value))
        return false;
    return true;
}

template <typename T, PaintWorkletToken::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.value < rhs.value)
        return true;
    if (rhs.value < lhs.value)
        return false;
    return false;
}
template <typename StructPtrType> SharedStorageWorkletTokenPtr SharedStorageWorkletToken::Clone() const
{
    return New(mojo::Clone(value));
}

template <typename T, SharedStorageWorkletToken::EnableIfSame<T>*> bool SharedStorageWorkletToken::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->value, other_struct.value))
        return false;
    return true;
}

template <typename T, SharedStorageWorkletToken::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.value < rhs.value)
        return true;
    if (rhs.value < lhs.value)
        return false;
    return false;
}
template <typename StructPtrType> ShadowRealmTokenPtr ShadowRealmToken::Clone() const
{
    return New(mojo::Clone(value));
}

template <typename T, ShadowRealmToken::EnableIfSame<T>*> bool ShadowRealmToken::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->value, other_struct.value))
        return false;
    return true;
}

template <typename T, ShadowRealmToken::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.value < rhs.value)
        return true;
    if (rhs.value < lhs.value)
        return false;
    return false;
}
template <typename StructPtrType> AttributionSrcTokenPtr AttributionSrcToken::Clone() const
{
    return New(mojo::Clone(value));
}

template <typename T, AttributionSrcToken::EnableIfSame<T>*> bool AttributionSrcToken::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->value, other_struct.value))
        return false;
    return true;
}

template <typename T, AttributionSrcToken::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.value < rhs.value)
        return true;
    if (rhs.value < lhs.value)
        return false;
    return false;
}
template <typename StructPtrType> ClipboardSequenceNumberTokenPtr ClipboardSequenceNumberToken::Clone() const
{
    return New(mojo::Clone(value));
}

template <typename T, ClipboardSequenceNumberToken::EnableIfSame<T>*> bool ClipboardSequenceNumberToken::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->value, other_struct.value))
        return false;
    return true;
}

template <typename T, ClipboardSequenceNumberToken::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.value < rhs.value)
        return true;
    if (rhs.value < lhs.value)
        return false;
    return false;
}
template <typename StructPtrType> SameDocNavigationScreenshotDestinationTokenPtr SameDocNavigationScreenshotDestinationToken::Clone() const
{
    return New(mojo::Clone(value));
}

template <typename T, SameDocNavigationScreenshotDestinationToken::EnableIfSame<T>*>
bool SameDocNavigationScreenshotDestinationToken::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->value, other_struct.value))
        return false;
    return true;
}

template <typename T, SameDocNavigationScreenshotDestinationToken::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.value < rhs.value)
        return true;
    if (rhs.value < lhs.value)
        return false;
    return false;
}
template <typename StructPtrType> V8ContextTokenPtr V8ContextToken::Clone() const
{
    return New(mojo::Clone(value));
}

template <typename T, V8ContextToken::EnableIfSame<T>*> bool V8ContextToken::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->value, other_struct.value))
        return false;
    return true;
}

template <typename T, V8ContextToken::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.value < rhs.value)
        return true;
    if (rhs.value < lhs.value)
        return false;
    return false;
}
template <typename StructPtrType> ViewTransitionTokenPtr ViewTransitionToken::Clone() const
{
    return New(mojo::Clone(value));
}

template <typename T, ViewTransitionToken::EnableIfSame<T>*> bool ViewTransitionToken::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->value, other_struct.value))
        return false;
    return true;
}

template <typename T, ViewTransitionToken::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.value < rhs.value)
        return true;
    if (rhs.value < lhs.value)
        return false;
    return false;
}
template <typename StructPtrType> WebNNContextTokenPtr WebNNContextToken::Clone() const
{
    return New(mojo::Clone(value));
}

template <typename T, WebNNContextToken::EnableIfSame<T>*> bool WebNNContextToken::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->value, other_struct.value))
        return false;
    return true;
}

template <typename T, WebNNContextToken::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.value < rhs.value)
        return true;
    if (rhs.value < lhs.value)
        return false;
    return false;
}
template <typename StructPtrType> WebNNTensorTokenPtr WebNNTensorToken::Clone() const
{
    return New(mojo::Clone(value));
}

template <typename T, WebNNTensorToken::EnableIfSame<T>*> bool WebNNTensorToken::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->value, other_struct.value))
        return false;
    return true;
}

template <typename T, WebNNTensorToken::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.value < rhs.value)
        return true;
    if (rhs.value < lhs.value)
        return false;
    return false;
}

} // blink::mojom::blink

namespace mojo {

template <> struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::DocumentToken::DataView, ::blink::mojom::blink::DocumentTokenPtr> {
    static bool IsNull(const ::blink::mojom::blink::DocumentTokenPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::blink::DocumentTokenPtr* output)
    {
        output->reset();
    }

    static const decltype(::blink::mojom::blink::DocumentToken::value)& value(const ::blink::mojom::blink::DocumentTokenPtr& input)
    {
        return input->value;
    }

    static bool Read(::blink::mojom::blink::DocumentToken::DataView input, ::blink::mojom::blink::DocumentTokenPtr* output);
};

template <> struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::LocalFrameToken::DataView, ::blink::mojom::blink::LocalFrameTokenPtr> {
    static bool IsNull(const ::blink::mojom::blink::LocalFrameTokenPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::blink::LocalFrameTokenPtr* output)
    {
        output->reset();
    }

    static const decltype(::blink::mojom::blink::LocalFrameToken::value)& value(const ::blink::mojom::blink::LocalFrameTokenPtr& input)
    {
        return input->value;
    }

    static bool Read(::blink::mojom::blink::LocalFrameToken::DataView input, ::blink::mojom::blink::LocalFrameTokenPtr* output);
};

template <> struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::RemoteFrameToken::DataView, ::blink::mojom::blink::RemoteFrameTokenPtr> {
    static bool IsNull(const ::blink::mojom::blink::RemoteFrameTokenPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::blink::RemoteFrameTokenPtr* output)
    {
        output->reset();
    }

    static const decltype(::blink::mojom::blink::RemoteFrameToken::value)& value(const ::blink::mojom::blink::RemoteFrameTokenPtr& input)
    {
        return input->value;
    }

    static bool Read(::blink::mojom::blink::RemoteFrameToken::DataView input, ::blink::mojom::blink::RemoteFrameTokenPtr* output);
};

template <> struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::DedicatedWorkerToken::DataView, ::blink::mojom::blink::DedicatedWorkerTokenPtr> {
    static bool IsNull(const ::blink::mojom::blink::DedicatedWorkerTokenPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::blink::DedicatedWorkerTokenPtr* output)
    {
        output->reset();
    }

    static const decltype(::blink::mojom::blink::DedicatedWorkerToken::value)& value(const ::blink::mojom::blink::DedicatedWorkerTokenPtr& input)
    {
        return input->value;
    }

    static bool Read(::blink::mojom::blink::DedicatedWorkerToken::DataView input, ::blink::mojom::blink::DedicatedWorkerTokenPtr* output);
};

template <> struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::ServiceWorkerToken::DataView, ::blink::mojom::blink::ServiceWorkerTokenPtr> {
    static bool IsNull(const ::blink::mojom::blink::ServiceWorkerTokenPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::blink::ServiceWorkerTokenPtr* output)
    {
        output->reset();
    }

    static const decltype(::blink::mojom::blink::ServiceWorkerToken::value)& value(const ::blink::mojom::blink::ServiceWorkerTokenPtr& input)
    {
        return input->value;
    }

    static bool Read(::blink::mojom::blink::ServiceWorkerToken::DataView input, ::blink::mojom::blink::ServiceWorkerTokenPtr* output);
};

template <> struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::SharedWorkerToken::DataView, ::blink::mojom::blink::SharedWorkerTokenPtr> {
    static bool IsNull(const ::blink::mojom::blink::SharedWorkerTokenPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::blink::SharedWorkerTokenPtr* output)
    {
        output->reset();
    }

    static const decltype(::blink::mojom::blink::SharedWorkerToken::value)& value(const ::blink::mojom::blink::SharedWorkerTokenPtr& input)
    {
        return input->value;
    }

    static bool Read(::blink::mojom::blink::SharedWorkerToken::DataView input, ::blink::mojom::blink::SharedWorkerTokenPtr* output);
};

template <> struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::AnimationWorkletToken::DataView, ::blink::mojom::blink::AnimationWorkletTokenPtr> {
    static bool IsNull(const ::blink::mojom::blink::AnimationWorkletTokenPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::blink::AnimationWorkletTokenPtr* output)
    {
        output->reset();
    }

    static const decltype(::blink::mojom::blink::AnimationWorkletToken::value)& value(const ::blink::mojom::blink::AnimationWorkletTokenPtr& input)
    {
        return input->value;
    }

    static bool Read(::blink::mojom::blink::AnimationWorkletToken::DataView input, ::blink::mojom::blink::AnimationWorkletTokenPtr* output);
};

template <> struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::AudioWorkletToken::DataView, ::blink::mojom::blink::AudioWorkletTokenPtr> {
    static bool IsNull(const ::blink::mojom::blink::AudioWorkletTokenPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::blink::AudioWorkletTokenPtr* output)
    {
        output->reset();
    }

    static const decltype(::blink::mojom::blink::AudioWorkletToken::value)& value(const ::blink::mojom::blink::AudioWorkletTokenPtr& input)
    {
        return input->value;
    }

    static bool Read(::blink::mojom::blink::AudioWorkletToken::DataView input, ::blink::mojom::blink::AudioWorkletTokenPtr* output);
};

template <> struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::LayoutWorkletToken::DataView, ::blink::mojom::blink::LayoutWorkletTokenPtr> {
    static bool IsNull(const ::blink::mojom::blink::LayoutWorkletTokenPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::blink::LayoutWorkletTokenPtr* output)
    {
        output->reset();
    }

    static const decltype(::blink::mojom::blink::LayoutWorkletToken::value)& value(const ::blink::mojom::blink::LayoutWorkletTokenPtr& input)
    {
        return input->value;
    }

    static bool Read(::blink::mojom::blink::LayoutWorkletToken::DataView input, ::blink::mojom::blink::LayoutWorkletTokenPtr* output);
};

template <> struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::PaintWorkletToken::DataView, ::blink::mojom::blink::PaintWorkletTokenPtr> {
    static bool IsNull(const ::blink::mojom::blink::PaintWorkletTokenPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::blink::PaintWorkletTokenPtr* output)
    {
        output->reset();
    }

    static const decltype(::blink::mojom::blink::PaintWorkletToken::value)& value(const ::blink::mojom::blink::PaintWorkletTokenPtr& input)
    {
        return input->value;
    }

    static bool Read(::blink::mojom::blink::PaintWorkletToken::DataView input, ::blink::mojom::blink::PaintWorkletTokenPtr* output);
};

template <>
struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::SharedStorageWorkletToken::DataView, ::blink::mojom::blink::SharedStorageWorkletTokenPtr> {
    static bool IsNull(const ::blink::mojom::blink::SharedStorageWorkletTokenPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::blink::SharedStorageWorkletTokenPtr* output)
    {
        output->reset();
    }

    static const decltype(::blink::mojom::blink::SharedStorageWorkletToken::value)& value(const ::blink::mojom::blink::SharedStorageWorkletTokenPtr& input)
    {
        return input->value;
    }

    static bool Read(::blink::mojom::blink::SharedStorageWorkletToken::DataView input, ::blink::mojom::blink::SharedStorageWorkletTokenPtr* output);
};

template <> struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::ShadowRealmToken::DataView, ::blink::mojom::blink::ShadowRealmTokenPtr> {
    static bool IsNull(const ::blink::mojom::blink::ShadowRealmTokenPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::blink::ShadowRealmTokenPtr* output)
    {
        output->reset();
    }

    static const decltype(::blink::mojom::blink::ShadowRealmToken::value)& value(const ::blink::mojom::blink::ShadowRealmTokenPtr& input)
    {
        return input->value;
    }

    static bool Read(::blink::mojom::blink::ShadowRealmToken::DataView input, ::blink::mojom::blink::ShadowRealmTokenPtr* output);
};

template <> struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::AttributionSrcToken::DataView, ::blink::mojom::blink::AttributionSrcTokenPtr> {
    static bool IsNull(const ::blink::mojom::blink::AttributionSrcTokenPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::blink::AttributionSrcTokenPtr* output)
    {
        output->reset();
    }

    static const decltype(::blink::mojom::blink::AttributionSrcToken::value)& value(const ::blink::mojom::blink::AttributionSrcTokenPtr& input)
    {
        return input->value;
    }

    static bool Read(::blink::mojom::blink::AttributionSrcToken::DataView input, ::blink::mojom::blink::AttributionSrcTokenPtr* output);
};

template <>
struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::ClipboardSequenceNumberToken::DataView, ::blink::mojom::blink::ClipboardSequenceNumberTokenPtr> {
    static bool IsNull(const ::blink::mojom::blink::ClipboardSequenceNumberTokenPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::blink::ClipboardSequenceNumberTokenPtr* output)
    {
        output->reset();
    }

    static const decltype(::blink::mojom::blink::ClipboardSequenceNumberToken::value)& value(
        const ::blink::mojom::blink::ClipboardSequenceNumberTokenPtr& input)
    {
        return input->value;
    }

    static bool Read(::blink::mojom::blink::ClipboardSequenceNumberToken::DataView input, ::blink::mojom::blink::ClipboardSequenceNumberTokenPtr* output);
};

template <>
struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::SameDocNavigationScreenshotDestinationToken::DataView,
    ::blink::mojom::blink::SameDocNavigationScreenshotDestinationTokenPtr> {
    static bool IsNull(const ::blink::mojom::blink::SameDocNavigationScreenshotDestinationTokenPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::blink::SameDocNavigationScreenshotDestinationTokenPtr* output)
    {
        output->reset();
    }

    static const decltype(::blink::mojom::blink::SameDocNavigationScreenshotDestinationToken::value)& value(
        const ::blink::mojom::blink::SameDocNavigationScreenshotDestinationTokenPtr& input)
    {
        return input->value;
    }

    static bool Read(::blink::mojom::blink::SameDocNavigationScreenshotDestinationToken::DataView input,
        ::blink::mojom::blink::SameDocNavigationScreenshotDestinationTokenPtr* output);
};

template <> struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::V8ContextToken::DataView, ::blink::mojom::blink::V8ContextTokenPtr> {
    static bool IsNull(const ::blink::mojom::blink::V8ContextTokenPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::blink::V8ContextTokenPtr* output)
    {
        output->reset();
    }

    static const decltype(::blink::mojom::blink::V8ContextToken::value)& value(const ::blink::mojom::blink::V8ContextTokenPtr& input)
    {
        return input->value;
    }

    static bool Read(::blink::mojom::blink::V8ContextToken::DataView input, ::blink::mojom::blink::V8ContextTokenPtr* output);
};

template <> struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::ViewTransitionToken::DataView, ::blink::mojom::blink::ViewTransitionTokenPtr> {
    static bool IsNull(const ::blink::mojom::blink::ViewTransitionTokenPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::blink::ViewTransitionTokenPtr* output)
    {
        output->reset();
    }

    static const decltype(::blink::mojom::blink::ViewTransitionToken::value)& value(const ::blink::mojom::blink::ViewTransitionTokenPtr& input)
    {
        return input->value;
    }

    static bool Read(::blink::mojom::blink::ViewTransitionToken::DataView input, ::blink::mojom::blink::ViewTransitionTokenPtr* output);
};

template <> struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::WebNNContextToken::DataView, ::blink::mojom::blink::WebNNContextTokenPtr> {
    static bool IsNull(const ::blink::mojom::blink::WebNNContextTokenPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::blink::WebNNContextTokenPtr* output)
    {
        output->reset();
    }

    static const decltype(::blink::mojom::blink::WebNNContextToken::value)& value(const ::blink::mojom::blink::WebNNContextTokenPtr& input)
    {
        return input->value;
    }

    static bool Read(::blink::mojom::blink::WebNNContextToken::DataView input, ::blink::mojom::blink::WebNNContextTokenPtr* output);
};

template <> struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::WebNNTensorToken::DataView, ::blink::mojom::blink::WebNNTensorTokenPtr> {
    static bool IsNull(const ::blink::mojom::blink::WebNNTensorTokenPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::blink::WebNNTensorTokenPtr* output)
    {
        output->reset();
    }

    static const decltype(::blink::mojom::blink::WebNNTensorToken::value)& value(const ::blink::mojom::blink::WebNNTensorTokenPtr& input)
    {
        return input->value;
    }

    static bool Read(::blink::mojom::blink::WebNNTensorToken::DataView input, ::blink::mojom::blink::WebNNTensorTokenPtr* output);
};

template <> struct PLATFORM_EXPORT UnionTraits<::blink::mojom::blink::FrameToken::DataView, ::blink::mojom::blink::FrameTokenPtr> {
    static bool IsNull(const ::blink::mojom::blink::FrameTokenPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::blink::FrameTokenPtr* output)
    {
        output->reset();
    }

    static ::blink::mojom::blink::FrameToken::Tag GetTag(const ::blink::mojom::blink::FrameTokenPtr& input)
    {
        return input->which();
    }

    static const ::blink::LocalFrameToken& local_frame_token(const ::blink::mojom::blink::FrameTokenPtr& input)
    {
        return input->get_local_frame_token();
    }

    static const ::blink::RemoteFrameToken& remote_frame_token(const ::blink::mojom::blink::FrameTokenPtr& input)
    {
        return input->get_remote_frame_token();
    }

    static bool Read(::blink::mojom::blink::FrameToken::DataView input, ::blink::mojom::blink::FrameTokenPtr* output);
};

template <> struct PLATFORM_EXPORT UnionTraits<::blink::mojom::blink::WorkerToken::DataView, ::blink::mojom::blink::WorkerTokenPtr> {
    static bool IsNull(const ::blink::mojom::blink::WorkerTokenPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::blink::WorkerTokenPtr* output)
    {
        output->reset();
    }

    static ::blink::mojom::blink::WorkerToken::Tag GetTag(const ::blink::mojom::blink::WorkerTokenPtr& input)
    {
        return input->which();
    }

    static const ::blink::DedicatedWorkerToken& dedicated_worker_token(const ::blink::mojom::blink::WorkerTokenPtr& input)
    {
        return input->get_dedicated_worker_token();
    }

    static const ::blink::ServiceWorkerToken& service_worker_token(const ::blink::mojom::blink::WorkerTokenPtr& input)
    {
        return input->get_service_worker_token();
    }

    static const ::blink::SharedWorkerToken& shared_worker_token(const ::blink::mojom::blink::WorkerTokenPtr& input)
    {
        return input->get_shared_worker_token();
    }

    static bool Read(::blink::mojom::blink::WorkerToken::DataView input, ::blink::mojom::blink::WorkerTokenPtr* output);
};

template <> struct PLATFORM_EXPORT UnionTraits<::blink::mojom::blink::WorkletToken::DataView, ::blink::mojom::blink::WorkletTokenPtr> {
    static bool IsNull(const ::blink::mojom::blink::WorkletTokenPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::blink::WorkletTokenPtr* output)
    {
        output->reset();
    }

    static ::blink::mojom::blink::WorkletToken::Tag GetTag(const ::blink::mojom::blink::WorkletTokenPtr& input)
    {
        return input->which();
    }

    static const ::blink::AnimationWorkletToken& animation_worklet_token(const ::blink::mojom::blink::WorkletTokenPtr& input)
    {
        return input->get_animation_worklet_token();
    }

    static const ::blink::AudioWorkletToken& audio_worklet_token(const ::blink::mojom::blink::WorkletTokenPtr& input)
    {
        return input->get_audio_worklet_token();
    }

    static const ::blink::mojom::blink::LayoutWorkletTokenPtr& layout_worklet_token(const ::blink::mojom::blink::WorkletTokenPtr& input)
    {
        return input->get_layout_worklet_token();
    }

    static const ::blink::PaintWorkletToken& paint_worklet_token(const ::blink::mojom::blink::WorkletTokenPtr& input)
    {
        return input->get_paint_worklet_token();
    }

    static const ::blink::mojom::blink::SharedStorageWorkletTokenPtr& shared_storage_worklet_token(const ::blink::mojom::blink::WorkletTokenPtr& input)
    {
        return input->get_shared_storage_worklet_token();
    }

    static bool Read(::blink::mojom::blink::WorkletToken::DataView input, ::blink::mojom::blink::WorkletTokenPtr* output);
};

template <> struct PLATFORM_EXPORT UnionTraits<::blink::mojom::blink::ExecutionContextToken::DataView, ::blink::mojom::blink::ExecutionContextTokenPtr> {
    static bool IsNull(const ::blink::mojom::blink::ExecutionContextTokenPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::blink::ExecutionContextTokenPtr* output)
    {
        output->reset();
    }

    static ::blink::mojom::blink::ExecutionContextToken::Tag GetTag(const ::blink::mojom::blink::ExecutionContextTokenPtr& input)
    {
        return input->which();
    }

    static const ::blink::LocalFrameToken& local_frame_token(const ::blink::mojom::blink::ExecutionContextTokenPtr& input)
    {
        return input->get_local_frame_token();
    }

    static const ::blink::DedicatedWorkerToken& dedicated_worker_token(const ::blink::mojom::blink::ExecutionContextTokenPtr& input)
    {
        return input->get_dedicated_worker_token();
    }

    static const ::blink::ServiceWorkerToken& service_worker_token(const ::blink::mojom::blink::ExecutionContextTokenPtr& input)
    {
        return input->get_service_worker_token();
    }

    static const ::blink::SharedWorkerToken& shared_worker_token(const ::blink::mojom::blink::ExecutionContextTokenPtr& input)
    {
        return input->get_shared_worker_token();
    }

    static const ::blink::AnimationWorkletToken& animation_worklet_token(const ::blink::mojom::blink::ExecutionContextTokenPtr& input)
    {
        return input->get_animation_worklet_token();
    }

    static const ::blink::AudioWorkletToken& audio_worklet_token(const ::blink::mojom::blink::ExecutionContextTokenPtr& input)
    {
        return input->get_audio_worklet_token();
    }

    static const ::blink::mojom::blink::LayoutWorkletTokenPtr& layout_worklet_token(const ::blink::mojom::blink::ExecutionContextTokenPtr& input)
    {
        return input->get_layout_worklet_token();
    }

    static const ::blink::PaintWorkletToken& paint_worklet_token(const ::blink::mojom::blink::ExecutionContextTokenPtr& input)
    {
        return input->get_paint_worklet_token();
    }

    static const ::blink::mojom::blink::SharedStorageWorkletTokenPtr& shared_storage_worklet_token(const ::blink::mojom::blink::ExecutionContextTokenPtr& input)
    {
        return input->get_shared_storage_worklet_token();
    }

    static const ::blink::ShadowRealmToken& shadow_realm_token(const ::blink::mojom::blink::ExecutionContextTokenPtr& input)
    {
        return input->get_shadow_realm_token();
    }

    static bool Read(::blink::mojom::blink::ExecutionContextToken::DataView input, ::blink::mojom::blink::ExecutionContextTokenPtr* output);
};

template <>
struct PLATFORM_EXPORT UnionTraits<::blink::mojom::blink::WebGPUExecutionContextToken::DataView, ::blink::mojom::blink::WebGPUExecutionContextTokenPtr> {
    static bool IsNull(const ::blink::mojom::blink::WebGPUExecutionContextTokenPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::blink::WebGPUExecutionContextTokenPtr* output)
    {
        output->reset();
    }

    static ::blink::mojom::blink::WebGPUExecutionContextToken::Tag GetTag(const ::blink::mojom::blink::WebGPUExecutionContextTokenPtr& input)
    {
        return input->which();
    }

    static const ::blink::DocumentToken& document_token(const ::blink::mojom::blink::WebGPUExecutionContextTokenPtr& input)
    {
        return input->get_document_token();
    }

    static const ::blink::DedicatedWorkerToken& dedicated_worker_token(const ::blink::mojom::blink::WebGPUExecutionContextTokenPtr& input)
    {
        return input->get_dedicated_worker_token();
    }

    static const ::blink::SharedWorkerToken& shared_worker_token(const ::blink::mojom::blink::WebGPUExecutionContextTokenPtr& input)
    {
        return input->get_shared_worker_token();
    }

    static const ::blink::ServiceWorkerToken& service_worker_token(const ::blink::mojom::blink::WebGPUExecutionContextTokenPtr& input)
    {
        return input->get_service_worker_token();
    }

    static bool Read(::blink::mojom::blink::WebGPUExecutionContextToken::DataView input, ::blink::mojom::blink::WebGPUExecutionContextTokenPtr* output);
};

} // namespace mojo

#endif // THIRD_PARTY_BLINK_PUBLIC_MOJOM_TOKENS_TOKENS_MOJOM_BLINK_H_
