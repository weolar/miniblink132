// third_party/blink/public/mojom/filesystem/file_system.mojom-blink.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef THIRD_PARTY_BLINK_PUBLIC_MOJOM_FILESYSTEM_FILE_SYSTEM_MOJOM_BLINK_H_
#define THIRD_PARTY_BLINK_PUBLIC_MOJOM_FILESYSTEM_FILE_SYSTEM_MOJOM_BLINK_H_

#include <stdint.h>

#include <limits>
#include <optional>
#include <type_traits>
#include <utility>

#include "base/types/cxx23_to_underlying.h"
#include "mojo/public/cpp/bindings/clone_traits.h"
#include "mojo/public/cpp/bindings/equals_traits.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/struct_ptr.h"
#include "mojo/public/cpp/bindings/struct_traits.h"
#include "mojo/public/cpp/bindings/union_traits.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "third_party/blink/public/mojom/filesystem/file_system.mojom-features.h" // IWYU pragma: export
#include "third_party/blink/public/mojom/filesystem/file_system.mojom-shared.h" // IWYU pragma: export
#include "third_party/blink/public/mojom/filesystem/file_system.mojom-blink-forward.h" // IWYU pragma: export
#include "components/services/filesystem/public/mojom/types.mojom-blink-forward.h"
#include "url/mojom/origin.mojom-blink.h"
#include "url/mojom/url.mojom-blink.h"
#include "mojo/public/mojom/base/file_error.mojom-blink.h"
#include "mojo/public/mojom/base/file_path.mojom-blink.h"
#include "mojo/public/mojom/base/file_info.mojom-blink.h"
#include "mojo/public/mojom/base/time.mojom-blink.h"
#include "third_party/blink/public/mojom/blob/serialized_blob.mojom-blink.h"
#include "third_party/blink/public/mojom/blob/blob.mojom-blink-forward.h"

#include "mojo/public/cpp/bindings/lib/wtf_clone_equals_util.h"
#include "mojo/public/cpp/bindings/lib/wtf_hash_util.h"
#include "third_party/blink/renderer/platform/wtf/hash_functions.h"
#include "third_party/blink/renderer/platform/wtf/text/wtf_string.h"

#include "mojo/public/cpp/bindings/lib/control_message_handler.h"
#include "mojo/public/cpp/bindings/lib/message_size_estimator.h"
#include "mojo/public/cpp/bindings/raw_ptr_impl_ref_traits.h"

#include "third_party/blink/renderer/platform/platform_export.h"
#if !BLINK_MOJO_IMPL && !INSIDE_BLINK
#error "File must only be imported inside blink"
#endif

namespace blink::mojom::blink {

class FileSystemCancellableOperationProxy;

template <typename ImplRefTraits> class FileSystemCancellableOperationStub;

class FileSystemCancellableOperationRequestValidator;
class FileSystemCancellableOperationResponseValidator;

class PLATFORM_EXPORT FileSystemCancellableOperation : public FileSystemCancellableOperationInterfaceBase {
public:
    using IPCStableHashFunction = uint32_t (*)();

    static const char Name_[];
    static IPCStableHashFunction MessageToMethodInfo_(mojo::Message& message);
    static const char* MessageToMethodName_(mojo::Message& message);
    static constexpr uint32_t Version_ = 0;
    static constexpr bool PassesAssociatedKinds_ = false;
    static constexpr bool HasUninterruptableMethods_ = false;

    using Base_ = FileSystemCancellableOperationInterfaceBase;
    using Proxy_ = FileSystemCancellableOperationProxy;

    template <typename ImplRefTraits> using Stub_ = FileSystemCancellableOperationStub<ImplRefTraits>;

    using RequestValidator_ = FileSystemCancellableOperationRequestValidator;
    using ResponseValidator_ = FileSystemCancellableOperationResponseValidator;
    enum MethodMinVersions : uint32_t {
        kCancelMinVersion = 0,
    };

// crbug.com/1340245 - this causes binary size bloat on Fuchsia, and we're OK
// with not having this data in traces there.
#if !BUILDFLAG(IS_FUCHSIA)
    struct Cancel_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
#endif // !BUILDFLAG(IS_FUCHSIA)
    virtual ~FileSystemCancellableOperation() = default;

    using CancelCallback = base::OnceCallback<void(::base::File::Error)>;

    virtual void Cancel(CancelCallback callback) = 0;
};

class FileSystemOperationListenerProxy;

template <typename ImplRefTraits> class FileSystemOperationListenerStub;

class FileSystemOperationListenerRequestValidator;

class PLATFORM_EXPORT FileSystemOperationListener : public FileSystemOperationListenerInterfaceBase {
public:
    using IPCStableHashFunction = uint32_t (*)();

    static const char Name_[];
    static IPCStableHashFunction MessageToMethodInfo_(mojo::Message& message);
    static const char* MessageToMethodName_(mojo::Message& message);
    static constexpr uint32_t Version_ = 0;
    static constexpr bool PassesAssociatedKinds_ = false;
    static constexpr bool HasUninterruptableMethods_ = false;

    using Base_ = FileSystemOperationListenerInterfaceBase;
    using Proxy_ = FileSystemOperationListenerProxy;

    template <typename ImplRefTraits> using Stub_ = FileSystemOperationListenerStub<ImplRefTraits>;

    using RequestValidator_ = FileSystemOperationListenerRequestValidator;
    using ResponseValidator_ = mojo::PassThroughFilter;
    enum MethodMinVersions : uint32_t {
        kResultsRetrievedMinVersion = 0,
        kDidWriteMinVersion = 0,
        kErrorOccurredMinVersion = 0,
    };

// crbug.com/1340245 - this causes binary size bloat on Fuchsia, and we're OK
// with not having this data in traces there.
#if !BUILDFLAG(IS_FUCHSIA)
    struct ResultsRetrieved_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct DidWrite_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct ErrorOccurred_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
#endif // !BUILDFLAG(IS_FUCHSIA)
    virtual ~FileSystemOperationListener() = default;

    virtual void ResultsRetrieved(WTF::Vector<::filesystem::mojom::blink::DirectoryEntryPtr> entries, bool has_more) = 0;

    virtual void DidWrite(int64_t byte_count, bool complete) = 0;

    virtual void ErrorOccurred(::base::File::Error error_code) = 0;
};

class ReceivedSnapshotListenerProxy;

template <typename ImplRefTraits> class ReceivedSnapshotListenerStub;

class ReceivedSnapshotListenerRequestValidator;

class PLATFORM_EXPORT ReceivedSnapshotListener : public ReceivedSnapshotListenerInterfaceBase {
public:
    using IPCStableHashFunction = uint32_t (*)();

    static const char Name_[];
    static IPCStableHashFunction MessageToMethodInfo_(mojo::Message& message);
    static const char* MessageToMethodName_(mojo::Message& message);
    static constexpr uint32_t Version_ = 0;
    static constexpr bool PassesAssociatedKinds_ = false;
    static constexpr bool HasUninterruptableMethods_ = false;

    using Base_ = ReceivedSnapshotListenerInterfaceBase;
    using Proxy_ = ReceivedSnapshotListenerProxy;

    template <typename ImplRefTraits> using Stub_ = ReceivedSnapshotListenerStub<ImplRefTraits>;

    using RequestValidator_ = ReceivedSnapshotListenerRequestValidator;
    using ResponseValidator_ = mojo::PassThroughFilter;
    enum MethodMinVersions : uint32_t {
        kDidReceiveSnapshotFileMinVersion = 0,
    };

// crbug.com/1340245 - this causes binary size bloat on Fuchsia, and we're OK
// with not having this data in traces there.
#if !BUILDFLAG(IS_FUCHSIA)
    struct DidReceiveSnapshotFile_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
#endif // !BUILDFLAG(IS_FUCHSIA)
    virtual ~ReceivedSnapshotListener() = default;

    virtual void DidReceiveSnapshotFile() = 0;
};

class FileSystemManagerProxy;

template <typename ImplRefTraits> class FileSystemManagerStub;

class FileSystemManagerRequestValidator;
class FileSystemManagerResponseValidator;

class PLATFORM_EXPORT FileSystemManager : public FileSystemManagerInterfaceBase {
public:
    using IPCStableHashFunction = uint32_t (*)();

    static const char Name_[];
    static IPCStableHashFunction MessageToMethodInfo_(mojo::Message& message);
    static const char* MessageToMethodName_(mojo::Message& message);
    static constexpr uint32_t Version_ = 0;
    static constexpr bool PassesAssociatedKinds_ = false;
    static inline constexpr uint32_t kSyncMethodOrdinals[] = { 0, 1, 2, 3, 4, 5, 6, 7, 9, 11, 13, 14, 15, 16 };
    static constexpr bool HasUninterruptableMethods_ = false;

    using Base_ = FileSystemManagerInterfaceBase;
    using Proxy_ = FileSystemManagerProxy;

    template <typename ImplRefTraits> using Stub_ = FileSystemManagerStub<ImplRefTraits>;

    using RequestValidator_ = FileSystemManagerRequestValidator;
    using ResponseValidator_ = FileSystemManagerResponseValidator;
    enum MethodMinVersions : uint32_t {
        kOpenMinVersion = 0,
        kResolveURLMinVersion = 0,
        kMoveMinVersion = 0,
        kCopyMinVersion = 0,
        kRemoveMinVersion = 0,
        kReadMetadataMinVersion = 0,
        kCreateMinVersion = 0,
        kExistsMinVersion = 0,
        kReadDirectoryMinVersion = 0,
        kReadDirectorySyncMinVersion = 0,
        kWriteMinVersion = 0,
        kWriteSyncMinVersion = 0,
        kTruncateMinVersion = 0,
        kTruncateSyncMinVersion = 0,
        kCreateSnapshotFileMinVersion = 0,
        kGetPlatformPathMinVersion = 0,
        kRegisterBlobMinVersion = 0,
    };

// crbug.com/1340245 - this causes binary size bloat on Fuchsia, and we're OK
// with not having this data in traces there.
#if !BUILDFLAG(IS_FUCHSIA)
    struct Open_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct ResolveURL_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct Move_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct Copy_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct Remove_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct ReadMetadata_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct Create_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct Exists_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct ReadDirectory_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct ReadDirectorySync_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct Write_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct WriteSync_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct Truncate_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct TruncateSync_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct CreateSnapshotFile_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct GetPlatformPath_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct RegisterBlob_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
#endif // !BUILDFLAG(IS_FUCHSIA)
    virtual ~FileSystemManager() = default;

    // Sync method. This signature is used by the client side; the service side
    // should implement the signature with callback below.

    virtual bool Open(const ::scoped_refptr<const ::blink::SecurityOrigin>& origin, FileSystemType file_system_type, WTF::String* out_name,
        ::blink::KURL* out_root_url, ::base::File::Error* out_error_code);

    using OpenCallback = base::OnceCallback<void(const WTF::String&, const ::blink::KURL&, ::base::File::Error)>;

    virtual void Open(const ::scoped_refptr<const ::blink::SecurityOrigin>& origin, FileSystemType file_system_type, OpenCallback callback) = 0;

    // Sync method. This signature is used by the client side; the service side
    // should implement the signature with callback below.

    virtual bool ResolveURL(const ::blink::KURL& filesystem_url, FileSystemInfoPtr* out_info, ::base::FilePath* out_file_path, bool* out_is_directory,
        ::base::File::Error* out_error_code);

    using ResolveURLCallback = base::OnceCallback<void(FileSystemInfoPtr, const ::base::FilePath&, bool, ::base::File::Error)>;

    virtual void ResolveURL(const ::blink::KURL& filesystem_url, ResolveURLCallback callback) = 0;

    // Sync method. This signature is used by the client side; the service side
    // should implement the signature with callback below.

    virtual bool Move(const ::blink::KURL& src_path, const ::blink::KURL& dest_path, ::base::File::Error* out_error_code);

    using MoveCallback = base::OnceCallback<void(::base::File::Error)>;

    virtual void Move(const ::blink::KURL& src_path, const ::blink::KURL& dest_path, MoveCallback callback) = 0;

    // Sync method. This signature is used by the client side; the service side
    // should implement the signature with callback below.

    virtual bool Copy(const ::blink::KURL& src_path, const ::blink::KURL& dest_path, ::base::File::Error* out_error_code);

    using CopyCallback = base::OnceCallback<void(::base::File::Error)>;

    virtual void Copy(const ::blink::KURL& src_path, const ::blink::KURL& dest_path, CopyCallback callback) = 0;

    // Sync method. This signature is used by the client side; the service side
    // should implement the signature with callback below.

    virtual bool Remove(const ::blink::KURL& path, bool recursive, ::base::File::Error* out_error_code);

    using RemoveCallback = base::OnceCallback<void(::base::File::Error)>;

    virtual void Remove(const ::blink::KURL& path, bool recursive, RemoveCallback callback) = 0;

    // Sync method. This signature is used by the client side; the service side
    // should implement the signature with callback below.

    virtual bool ReadMetadata(const ::blink::KURL& path, ::base::File::Info* out_file_info, ::base::File::Error* out_error_code);

    using ReadMetadataCallback = base::OnceCallback<void(const ::base::File::Info&, ::base::File::Error)>;

    virtual void ReadMetadata(const ::blink::KURL& path, ReadMetadataCallback callback) = 0;

    // Sync method. This signature is used by the client side; the service side
    // should implement the signature with callback below.

    virtual bool Create(const ::blink::KURL& path, bool exclusive, bool is_directory, bool recursive, ::base::File::Error* out_error_code);

    using CreateCallback = base::OnceCallback<void(::base::File::Error)>;

    virtual void Create(const ::blink::KURL& path, bool exclusive, bool is_directory, bool recursive, CreateCallback callback) = 0;

    // Sync method. This signature is used by the client side; the service side
    // should implement the signature with callback below.

    virtual bool Exists(const ::blink::KURL& path, bool is_directory, ::base::File::Error* out_error_code);

    using ExistsCallback = base::OnceCallback<void(::base::File::Error)>;

    virtual void Exists(const ::blink::KURL& path, bool is_directory, ExistsCallback callback) = 0;

    virtual void ReadDirectory(const ::blink::KURL& path, ::mojo::PendingRemote<FileSystemOperationListener> listener) = 0;

    // Sync method. This signature is used by the client side; the service side
    // should implement the signature with callback below.

    virtual bool ReadDirectorySync(
        const ::blink::KURL& path, WTF::Vector<::filesystem::mojom::blink::DirectoryEntryPtr>* out_entries, ::base::File::Error* out_error_code);

    using ReadDirectorySyncCallback = base::OnceCallback<void(WTF::Vector<::filesystem::mojom::blink::DirectoryEntryPtr>, ::base::File::Error)>;

    virtual void ReadDirectorySync(const ::blink::KURL& path, ReadDirectorySyncCallback callback) = 0;

    virtual void Write(const ::blink::KURL& file_path, ::mojo::PendingRemote<::blink::mojom::blink::Blob> blob, int64_t position,
        ::mojo::PendingReceiver<FileSystemCancellableOperation> op_receiver, ::mojo::PendingRemote<FileSystemOperationListener> listener)
        = 0;

    // Sync method. This signature is used by the client side; the service side
    // should implement the signature with callback below.

    virtual bool WriteSync(const ::blink::KURL& file_path, ::mojo::PendingRemote<::blink::mojom::blink::Blob> blob, int64_t position, int64_t* out_byte_count,
        ::base::File::Error* out_error_code);

    using WriteSyncCallback = base::OnceCallback<void(int64_t, ::base::File::Error)>;

    virtual void WriteSync(
        const ::blink::KURL& file_path, ::mojo::PendingRemote<::blink::mojom::blink::Blob> blob, int64_t position, WriteSyncCallback callback)
        = 0;

    using TruncateCallback = base::OnceCallback<void(::base::File::Error)>;

    virtual void Truncate(
        const ::blink::KURL& file_path, int64_t length, ::mojo::PendingReceiver<FileSystemCancellableOperation> op_receiver, TruncateCallback callback)
        = 0;

    // Sync method. This signature is used by the client side; the service side
    // should implement the signature with callback below.

    virtual bool TruncateSync(const ::blink::KURL& file_path, int64_t length, ::base::File::Error* out_error_code);

    using TruncateSyncCallback = base::OnceCallback<void(::base::File::Error)>;

    virtual void TruncateSync(const ::blink::KURL& file_path, int64_t length, TruncateSyncCallback callback) = 0;

    // Sync method. This signature is used by the client side; the service side
    // should implement the signature with callback below.

    virtual bool CreateSnapshotFile(const ::blink::KURL& file_path, ::base::File::Info* out_file_info, ::base::FilePath* out_platform_path,
        ::base::File::Error* out_error_code, ::mojo::PendingRemote<ReceivedSnapshotListener>* out_snapshot_listener);

    using CreateSnapshotFileCallback
        = base::OnceCallback<void(const ::base::File::Info&, const ::base::FilePath&, ::base::File::Error, ::mojo::PendingRemote<ReceivedSnapshotListener>)>;

    virtual void CreateSnapshotFile(const ::blink::KURL& file_path, CreateSnapshotFileCallback callback) = 0;

    // Sync method. This signature is used by the client side; the service side
    // should implement the signature with callback below.

    virtual bool GetPlatformPath(const ::blink::KURL& file_path, ::base::FilePath* out_platform_path);

    using GetPlatformPathCallback = base::OnceCallback<void(const ::base::FilePath&)>;

    virtual void GetPlatformPath(const ::blink::KURL& file_path, GetPlatformPathCallback callback) = 0;

    // Sync method. This signature is used by the client side; the service side
    // should implement the signature with callback below.

    virtual bool RegisterBlob(const WTF::String& content_type, const ::blink::KURL& url, uint64_t length,
        std::optional<::base::Time> expected_modification_time, ::scoped_refptr<::blink::BlobDataHandle>* out_blob);

    using RegisterBlobCallback = base::OnceCallback<void(const ::scoped_refptr<::blink::BlobDataHandle>&)>;

    virtual void RegisterBlob(const WTF::String& content_type, const ::blink::KURL& url, uint64_t length,
        std::optional<::base::Time> expected_modification_time, RegisterBlobCallback callback)
        = 0;
};

//class PLATFORM_EXPORT FileSystemCancellableOperationProxy : public FileSystemCancellableOperation {
//public:
//    using InterfaceType = FileSystemCancellableOperation;
//
//    explicit FileSystemCancellableOperationProxy(mojo::MessageReceiverWithResponder* receiver);
//
//    void Cancel(CancelCallback callback) final;
//
//private:
//    mojo::MessageReceiverWithResponder* receiver_;
//};

//class PLATFORM_EXPORT FileSystemOperationListenerProxy : public FileSystemOperationListener {
//public:
//    using InterfaceType = FileSystemOperationListener;
//
//    explicit FileSystemOperationListenerProxy(mojo::MessageReceiverWithResponder* receiver);
//
//    void ResultsRetrieved(WTF::Vector<::filesystem::mojom::blink::DirectoryEntryPtr> entries, bool has_more) final;
//
//    void DidWrite(int64_t byte_count, bool complete) final;
//
//    void ErrorOccurred(::base::File::Error error_code) final;
//
//private:
//    mojo::MessageReceiverWithResponder* receiver_;
//};

//class PLATFORM_EXPORT ReceivedSnapshotListenerProxy : public ReceivedSnapshotListener {
//public:
//    using InterfaceType = ReceivedSnapshotListener;
//
//    explicit ReceivedSnapshotListenerProxy(mojo::MessageReceiverWithResponder* receiver);
//
//    void DidReceiveSnapshotFile() final;
//
//private:
//    mojo::MessageReceiverWithResponder* receiver_;
//};

//class PLATFORM_EXPORT FileSystemManagerProxy : public FileSystemManager {
//public:
//    using InterfaceType = FileSystemManager;
//
//    explicit FileSystemManagerProxy(mojo::MessageReceiverWithResponder* receiver);
//
//    bool Open(const ::scoped_refptr<const ::blink::SecurityOrigin>& origin, FileSystemType file_system_type, WTF::String* out_name, ::blink::KURL* out_root_url,
//        ::base::File::Error* out_error_code) final;
//
//    void Open(const ::scoped_refptr<const ::blink::SecurityOrigin>& origin, FileSystemType file_system_type, OpenCallback callback) final;
//
//    bool ResolveURL(const ::blink::KURL& filesystem_url, FileSystemInfoPtr* out_info, ::base::FilePath* out_file_path, bool* out_is_directory,
//        ::base::File::Error* out_error_code) final;
//
//    void ResolveURL(const ::blink::KURL& filesystem_url, ResolveURLCallback callback) final;
//
//    bool Move(const ::blink::KURL& src_path, const ::blink::KURL& dest_path, ::base::File::Error* out_error_code) final;
//
//    void Move(const ::blink::KURL& src_path, const ::blink::KURL& dest_path, MoveCallback callback) final;
//
//    bool Copy(const ::blink::KURL& src_path, const ::blink::KURL& dest_path, ::base::File::Error* out_error_code) final;
//
//    void Copy(const ::blink::KURL& src_path, const ::blink::KURL& dest_path, CopyCallback callback) final;
//
//    bool Remove(const ::blink::KURL& path, bool recursive, ::base::File::Error* out_error_code) final;
//
//    void Remove(const ::blink::KURL& path, bool recursive, RemoveCallback callback) final;
//
//    bool ReadMetadata(const ::blink::KURL& path, ::base::File::Info* out_file_info, ::base::File::Error* out_error_code) final;
//
//    void ReadMetadata(const ::blink::KURL& path, ReadMetadataCallback callback) final;
//
//    bool Create(const ::blink::KURL& path, bool exclusive, bool is_directory, bool recursive, ::base::File::Error* out_error_code) final;
//
//    void Create(const ::blink::KURL& path, bool exclusive, bool is_directory, bool recursive, CreateCallback callback) final;
//
//    bool Exists(const ::blink::KURL& path, bool is_directory, ::base::File::Error* out_error_code) final;
//
//    void Exists(const ::blink::KURL& path, bool is_directory, ExistsCallback callback) final;
//
//    void ReadDirectory(const ::blink::KURL& path, ::mojo::PendingRemote<FileSystemOperationListener> listener) final;
//
//    bool ReadDirectorySync(
//        const ::blink::KURL& path, WTF::Vector<::filesystem::mojom::blink::DirectoryEntryPtr>* out_entries, ::base::File::Error* out_error_code) final;
//
//    void ReadDirectorySync(const ::blink::KURL& path, ReadDirectorySyncCallback callback) final;
//
//    void Write(const ::blink::KURL& file_path, ::mojo::PendingRemote<::blink::mojom::blink::Blob> blob, int64_t position,
//        ::mojo::PendingReceiver<FileSystemCancellableOperation> op_receiver, ::mojo::PendingRemote<FileSystemOperationListener> listener) final;
//
//    bool WriteSync(const ::blink::KURL& file_path, ::mojo::PendingRemote<::blink::mojom::blink::Blob> blob, int64_t position, int64_t* out_byte_count,
//        ::base::File::Error* out_error_code) final;
//
//    void WriteSync(const ::blink::KURL& file_path, ::mojo::PendingRemote<::blink::mojom::blink::Blob> blob, int64_t position, WriteSyncCallback callback) final;
//
//    void Truncate(
//        const ::blink::KURL& file_path, int64_t length, ::mojo::PendingReceiver<FileSystemCancellableOperation> op_receiver, TruncateCallback callback) final;
//
//    bool TruncateSync(const ::blink::KURL& file_path, int64_t length, ::base::File::Error* out_error_code) final;
//
//    void TruncateSync(const ::blink::KURL& file_path, int64_t length, TruncateSyncCallback callback) final;
//
//    bool CreateSnapshotFile(const ::blink::KURL& file_path, ::base::File::Info* out_file_info, ::base::FilePath* out_platform_path,
//        ::base::File::Error* out_error_code, ::mojo::PendingRemote<ReceivedSnapshotListener>* out_snapshot_listener) final;
//
//    void CreateSnapshotFile(const ::blink::KURL& file_path, CreateSnapshotFileCallback callback) final;
//
//    bool GetPlatformPath(const ::blink::KURL& file_path, ::base::FilePath* out_platform_path) final;
//
//    void GetPlatformPath(const ::blink::KURL& file_path, GetPlatformPathCallback callback) final;
//
//    bool RegisterBlob(const WTF::String& content_type, const ::blink::KURL& url, uint64_t length, std::optional<::base::Time> expected_modification_time,
//        ::scoped_refptr<::blink::BlobDataHandle>* out_blob) final;
//
//    void RegisterBlob(const WTF::String& content_type, const ::blink::KURL& url, uint64_t length, std::optional<::base::Time> expected_modification_time,
//        RegisterBlobCallback callback) final;
//
//private:
//    mojo::MessageReceiverWithResponder* receiver_;
//};
//class PLATFORM_EXPORT FileSystemCancellableOperationStubDispatch {
//public:
//    static bool Accept(FileSystemCancellableOperation* impl, mojo::Message* message);
//    static bool AcceptWithResponder(FileSystemCancellableOperation* impl, mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
//};

//template <typename ImplRefTraits = mojo::RawPtrImplRefTraits<FileSystemCancellableOperation>>
//class FileSystemCancellableOperationStub : public mojo::MessageReceiverWithResponderStatus {
//public:
//    using ImplPointerType = typename ImplRefTraits::PointerType;
//
//    FileSystemCancellableOperationStub() = default;
//    ~FileSystemCancellableOperationStub() override = default;
//
//    void set_sink(ImplPointerType sink)
//    {
//        sink_ = std::move(sink);
//    }
//    ImplPointerType& sink()
//    {
//        return sink_;
//    }
//
//    bool Accept(mojo::Message* message) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return FileSystemCancellableOperationStubDispatch::Accept(ImplRefTraits::GetRawPointer(&sink_), message);
//    }
//
//    bool AcceptWithResponder(mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return FileSystemCancellableOperationStubDispatch::AcceptWithResponder(ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
//    }
//
//private:
//    ImplPointerType sink_;
//};
//class PLATFORM_EXPORT FileSystemOperationListenerStubDispatch {
//public:
//    static bool Accept(FileSystemOperationListener* impl, mojo::Message* message);
//    static bool AcceptWithResponder(FileSystemOperationListener* impl, mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
//};

//template <typename ImplRefTraits = mojo::RawPtrImplRefTraits<FileSystemOperationListener>>
//class FileSystemOperationListenerStub : public mojo::MessageReceiverWithResponderStatus {
//public:
//    using ImplPointerType = typename ImplRefTraits::PointerType;
//
//    FileSystemOperationListenerStub() = default;
//    ~FileSystemOperationListenerStub() override = default;
//
//    void set_sink(ImplPointerType sink)
//    {
//        sink_ = std::move(sink);
//    }
//    ImplPointerType& sink()
//    {
//        return sink_;
//    }
//
//    bool Accept(mojo::Message* message) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return FileSystemOperationListenerStubDispatch::Accept(ImplRefTraits::GetRawPointer(&sink_), message);
//    }
//
//    bool AcceptWithResponder(mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return FileSystemOperationListenerStubDispatch::AcceptWithResponder(ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
//    }
//
//private:
//    ImplPointerType sink_;
//};
//class PLATFORM_EXPORT ReceivedSnapshotListenerStubDispatch {
//public:
//    static bool Accept(ReceivedSnapshotListener* impl, mojo::Message* message);
//    static bool AcceptWithResponder(ReceivedSnapshotListener* impl, mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
//};

//template <typename ImplRefTraits = mojo::RawPtrImplRefTraits<ReceivedSnapshotListener>>
//class ReceivedSnapshotListenerStub : public mojo::MessageReceiverWithResponderStatus {
//public:
//    using ImplPointerType = typename ImplRefTraits::PointerType;
//
//    ReceivedSnapshotListenerStub() = default;
//    ~ReceivedSnapshotListenerStub() override = default;
//
//    void set_sink(ImplPointerType sink)
//    {
//        sink_ = std::move(sink);
//    }
//    ImplPointerType& sink()
//    {
//        return sink_;
//    }
//
//    bool Accept(mojo::Message* message) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return ReceivedSnapshotListenerStubDispatch::Accept(ImplRefTraits::GetRawPointer(&sink_), message);
//    }
//
//    bool AcceptWithResponder(mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return ReceivedSnapshotListenerStubDispatch::AcceptWithResponder(ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
//    }
//
//private:
//    ImplPointerType sink_;
//};
//class PLATFORM_EXPORT FileSystemManagerStubDispatch {
//public:
//    static bool Accept(FileSystemManager* impl, mojo::Message* message);
//    static bool AcceptWithResponder(FileSystemManager* impl, mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
//};

//template <typename ImplRefTraits = mojo::RawPtrImplRefTraits<FileSystemManager>> class FileSystemManagerStub : public mojo::MessageReceiverWithResponderStatus {
//public:
//    using ImplPointerType = typename ImplRefTraits::PointerType;
//
//    FileSystemManagerStub() = default;
//    ~FileSystemManagerStub() override = default;
//
//    void set_sink(ImplPointerType sink)
//    {
//        sink_ = std::move(sink);
//    }
//    ImplPointerType& sink()
//    {
//        return sink_;
//    }
//
//    bool Accept(mojo::Message* message) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return FileSystemManagerStubDispatch::Accept(ImplRefTraits::GetRawPointer(&sink_), message);
//    }
//
//    bool AcceptWithResponder(mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return FileSystemManagerStubDispatch::AcceptWithResponder(ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
//    }
//
//private:
//    ImplPointerType sink_;
//};
//class PLATFORM_EXPORT FileSystemCancellableOperationRequestValidator : public mojo::MessageReceiver {
//public:
//    bool Accept(mojo::Message* message) override;
//};
//class PLATFORM_EXPORT FileSystemOperationListenerRequestValidator : public mojo::MessageReceiver {
//public:
//    bool Accept(mojo::Message* message) override;
//};
//class PLATFORM_EXPORT ReceivedSnapshotListenerRequestValidator : public mojo::MessageReceiver {
//public:
//    bool Accept(mojo::Message* message) override;
//};
//class PLATFORM_EXPORT FileSystemManagerRequestValidator : public mojo::MessageReceiver {
//public:
//    bool Accept(mojo::Message* message) override;
//};
//class PLATFORM_EXPORT FileSystemCancellableOperationResponseValidator : public mojo::MessageReceiver {
//public:
//    bool Accept(mojo::Message* message) override;
//};
//class PLATFORM_EXPORT FileSystemManagerResponseValidator : public mojo::MessageReceiver {
//public:
//    bool Accept(mojo::Message* message) override;
//};

class PLATFORM_EXPORT FileSystemInfo {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<FileSystemInfo, T>::value>;
    using DataView = FileSystemInfoDataView;
    using Data_ = internal::FileSystemInfo_Data;

    template <typename... Args> static FileSystemInfoPtr New(Args&&... args)
    {
        return FileSystemInfoPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static FileSystemInfoPtr From(const U& u)
    {
        return mojo::TypeConverter<FileSystemInfoPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, FileSystemInfo>::Convert(*this);
    }

    FileSystemInfo()
    : name()
    , root_url()
    , mount_type(FileSystemType::kTemporary)
{
}

    FileSystemInfo(const WTF::String& name_in, const ::blink::KURL& root_url_in, FileSystemType mount_type_in)
    : name(std::move(name_in))
    , root_url(std::move(root_url_in))
    , mount_type(std::move(mount_type_in)){
}

    ~FileSystemInfo() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = FileSystemInfoPtr> FileSystemInfoPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, FileSystemInfo::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, FileSystemInfo::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, FileSystemInfo::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<FileSystemInfo::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<FileSystemInfo::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(std::make_unique<internal::FileSystemInfo_UnserializedMessageContext<UserType, FileSystemInfo::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<FileSystemInfo::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return FileSystemInfo::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::FileSystemInfo_UnserializedMessageContext<UserType, FileSystemInfo::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<FileSystemInfo::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    WTF::String name;

    ::blink::KURL root_url;

    FileSystemType mount_type;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, FileSystemInfo::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, FileSystemInfo::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, FileSystemInfo::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, FileSystemInfo::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

template <typename StructPtrType> FileSystemInfoPtr FileSystemInfo::Clone() const
{
    return New(mojo::Clone(name), mojo::Clone(root_url), mojo::Clone(mount_type));
}

template <typename T, FileSystemInfo::EnableIfSame<T>*> bool FileSystemInfo::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->name, other_struct.name))
        return false;
    if (!mojo::Equals(this->root_url, other_struct.root_url))
        return false;
    if (!mojo::Equals(this->mount_type, other_struct.mount_type))
        return false;
    return true;
}

template <typename T, FileSystemInfo::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.name < rhs.name)
        return true;
    if (rhs.name < lhs.name)
        return false;
    if (lhs.root_url < rhs.root_url)
        return true;
    if (rhs.root_url < lhs.root_url)
        return false;
    if (lhs.mount_type < rhs.mount_type)
        return true;
    if (rhs.mount_type < lhs.mount_type)
        return false;
    return false;
}

} // blink::mojom::blink

namespace mojo {

template <> struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::FileSystemInfo::DataView, ::blink::mojom::blink::FileSystemInfoPtr> {
    static bool IsNull(const ::blink::mojom::blink::FileSystemInfoPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::blink::FileSystemInfoPtr* output)
    {
        output->reset();
    }

    static const decltype(::blink::mojom::blink::FileSystemInfo::name)& name(const ::blink::mojom::blink::FileSystemInfoPtr& input)
    {
        return input->name;
    }

    static const decltype(::blink::mojom::blink::FileSystemInfo::root_url)& root_url(const ::blink::mojom::blink::FileSystemInfoPtr& input)
    {
        return input->root_url;
    }

    static decltype(::blink::mojom::blink::FileSystemInfo::mount_type) mount_type(const ::blink::mojom::blink::FileSystemInfoPtr& input)
    {
        return input->mount_type;
    }

    static bool Read(::blink::mojom::blink::FileSystemInfo::DataView input, ::blink::mojom::blink::FileSystemInfoPtr* output);
};

} // namespace mojo

#endif // THIRD_PARTY_BLINK_PUBLIC_MOJOM_FILESYSTEM_FILE_SYSTEM_MOJOM_BLINK_H_
