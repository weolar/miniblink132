// third_party/blink/public/mojom/blob/blob_url_store.mojom-blink-test-utils.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2019 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef THIRD_PARTY_BLINK_PUBLIC_MOJOM_BLOB_BLOB_URL_STORE_MOJOM_BLINK_TEST_UTILS_H_
#define THIRD_PARTY_BLINK_PUBLIC_MOJOM_BLOB_BLOB_URL_STORE_MOJOM_BLINK_TEST_UTILS_H_

#include "third_party/blink/public/mojom/blob/blob_url_store.mojom-blink.h"
#include "third_party/blink/renderer/platform/platform_export.h"

namespace blink::mojom::blink {

class PLATFORM_EXPORT BlobURLStoreInterceptorForTesting : public BlobURLStore {
    virtual BlobURLStore* GetForwardingInterface() = 0;
    void Register(::mojo::PendingRemote<::blink::mojom::blink::Blob> blob, const ::blink::KURL& url, const ::base::UnguessableToken& unsafe_agent_cluster_id,
        const std::optional<::blink::BlinkSchemefulSite>& unsafe_top_level_site, RegisterCallback callback) override;
    void Revoke(const ::blink::KURL& url) override;
    void ResolveAsURLLoaderFactory(const ::blink::KURL& url, ::mojo::PendingReceiver<::network::mojom::blink::URLLoaderFactory> factory,
        ResolveAsURLLoaderFactoryCallback callback) override;
    void ResolveForNavigation(const ::blink::KURL& url, ::mojo::PendingReceiver<BlobURLToken> token, ResolveForNavigationCallback callback) override;
    void ResolveForWorkerScriptFetch(
        const ::blink::KURL& url, ::mojo::PendingReceiver<BlobURLToken> token, ResolveForWorkerScriptFetchCallback callback) override;
};
class PLATFORM_EXPORT BlobURLStoreAsyncWaiter {
public:
    explicit BlobURLStoreAsyncWaiter(BlobURLStore* proxy);

    BlobURLStoreAsyncWaiter(const BlobURLStoreAsyncWaiter&) = delete;
    BlobURLStoreAsyncWaiter& operator=(const BlobURLStoreAsyncWaiter&) = delete;

    ~BlobURLStoreAsyncWaiter();
    void Register(::mojo::PendingRemote<::blink::mojom::blink::Blob> blob, const ::blink::KURL& url, const ::base::UnguessableToken& unsafe_agent_cluster_id,
        const std::optional<::blink::BlinkSchemefulSite>& unsafe_top_level_site);

    void ResolveAsURLLoaderFactory(const ::blink::KURL& url, ::mojo::PendingReceiver<::network::mojom::blink::URLLoaderFactory> factory,
        std::optional<::base::UnguessableToken>* out_unsafe_agent_cluster_id, std::optional<::blink::BlinkSchemefulSite>* out_unsafe_top_level_site);

    void ResolveForNavigation(
        const ::blink::KURL& url, ::mojo::PendingReceiver<BlobURLToken> token, std::optional<::base::UnguessableToken>* out_unsafe_agent_cluster_id);
    std::optional<::base::UnguessableToken> ResolveForNavigation(const ::blink::KURL& url, ::mojo::PendingReceiver<BlobURLToken> token);
    void ResolveForWorkerScriptFetch(
        const ::blink::KURL& url, ::mojo::PendingReceiver<BlobURLToken> token, std::optional<::base::UnguessableToken>* out_unsafe_agent_cluster_id);
    std::optional<::base::UnguessableToken> ResolveForWorkerScriptFetch(const ::blink::KURL& url, ::mojo::PendingReceiver<BlobURLToken> token);

private:
    BlobURLStore* const proxy_;
};

class PLATFORM_EXPORT BlobURLTokenInterceptorForTesting : public BlobURLToken {
    virtual BlobURLToken* GetForwardingInterface() = 0;
    void Clone(::mojo::PendingReceiver<BlobURLToken> token) override;
    void GetToken(GetTokenCallback callback) override;
};
class PLATFORM_EXPORT BlobURLTokenAsyncWaiter {
public:
    explicit BlobURLTokenAsyncWaiter(BlobURLToken* proxy);

    BlobURLTokenAsyncWaiter(const BlobURLTokenAsyncWaiter&) = delete;
    BlobURLTokenAsyncWaiter& operator=(const BlobURLTokenAsyncWaiter&) = delete;

    ~BlobURLTokenAsyncWaiter();
    void GetToken(::base::UnguessableToken* out_token);
    ::base::UnguessableToken GetToken();

private:
    BlobURLToken* const proxy_;
};

} // blink::mojom::blink

#endif // THIRD_PARTY_BLINK_PUBLIC_MOJOM_BLOB_BLOB_URL_STORE_MOJOM_BLINK_TEST_UTILS_H_
