// third_party/blink/public/mojom/fenced_frame/fenced_frame_config.mojom.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif

#include "third_party/blink/public/mojom/fenced_frame/fenced_frame_config.mojom.h"

#include <math.h>
#include <stdint.h>
#include <utility>

#include "base/debug/alias.h"
#include "base/hash/md5_constexpr.h"
#include "base/run_loop.h"
#include "base/strings/string_number_conversions.h"
#include "base/task/thread_pool/thread_pool_instance.h"
#include "base/trace_event/trace_event.h"
#include "base/trace_event/typed_macros.h"
#include "mojo/public/cpp/bindings/features.h"
#include "mojo/public/cpp/bindings/lib/default_construct_tag_internal.h"
#include "mojo/public/cpp/bindings/lib/generated_code_util.h"
#include "mojo/public/cpp/bindings/lib/message_internal.h"
#include "mojo/public/cpp/bindings/lib/proxy_to_responder.h"
#include "mojo/public/cpp/bindings/lib/send_message_helper.h"
#include "mojo/public/cpp/bindings/lib/serialization_util.h"
#include "mojo/public/cpp/bindings/lib/unserialized_message_context.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/mojo_buildflags.h"
#include "mojo/public/cpp/bindings/urgent_message_scope.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"
#include "third_party/perfetto/include/perfetto/tracing/traced_value.h"

#include "third_party/blink/public/mojom/fenced_frame/fenced_frame_config.mojom-params-data.h"
#include "third_party/blink/public/mojom/fenced_frame/fenced_frame_config.mojom-shared-message-ids.h"

#include "third_party/blink/public/mojom/fenced_frame/fenced_frame_config.mojom-import-headers.h"
#include "third_party/blink/public/mojom/fenced_frame/fenced_frame_config.mojom-test-utils.h"
#include "third_party/blink/common/permissions_policy/permissions_policy_mojom_traits.h"

namespace blink::mojom {
AdAuctionData::AdAuctionData()
    : interest_group_owner()
    , interest_group_name()
{
}

AdAuctionData::AdAuctionData(const ::url::Origin& interest_group_owner_in, const std::string& interest_group_name_in)
    : interest_group_owner(std::move(interest_group_owner_in))
    , interest_group_name(std::move(interest_group_name_in))
{
}

AdAuctionData::~AdAuctionData() = default;

void AdAuctionData::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("interest_group_owner"), this->interest_group_owner,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const ::url::Origin&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("interest_group_name"), this->interest_group_name,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool AdAuctionData::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
URNConfigPair::URNConfigPair()
    : urn()
    , config()
{
}

URNConfigPair::URNConfigPair(const ::GURL& urn_in, const ::blink::FencedFrame::RedactedFencedFrameConfig& config_in)
    : urn(std::move(urn_in))
    , config(std::move(config_in))
{
}

URNConfigPair::~URNConfigPair() = default;

void URNConfigPair::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("urn"), this->urn,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const ::GURL&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("config"), this->config,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const ::blink::FencedFrame::RedactedFencedFrameConfig&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool URNConfigPair::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
SharedStorageBudgetMetadata::SharedStorageBudgetMetadata()
    : site()
    , budget_to_charge()
    , top_navigated()
{
}

SharedStorageBudgetMetadata::SharedStorageBudgetMetadata(const ::net::SchemefulSite& site_in, double budget_to_charge_in, bool top_navigated_in)
    : site(std::move(site_in))
    , budget_to_charge(std::move(budget_to_charge_in))
    , top_navigated(std::move(top_navigated_in))
{
}

SharedStorageBudgetMetadata::~SharedStorageBudgetMetadata() = default;

void SharedStorageBudgetMetadata::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("site"), this->site,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const ::net::SchemefulSite&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("budget_to_charge"), this->budget_to_charge,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type double>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("top_navigated"), this->top_navigated,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type bool>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool SharedStorageBudgetMetadata::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
ParentPermissionsInfo::ParentPermissionsInfo()
    : parsed_permissions_policy()
    , origin()
{
}

ParentPermissionsInfo::ParentPermissionsInfo(
    std::vector<::blink::ParsedPermissionsPolicyDeclaration> parsed_permissions_policy_in, const ::url::Origin& origin_in)
    : parsed_permissions_policy(std::move(parsed_permissions_policy_in))
    , origin(std::move(origin_in))
{
}

ParentPermissionsInfo::~ParentPermissionsInfo() = default;

void ParentPermissionsInfo::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("parsed_permissions_policy"), this->parsed_permissions_policy,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::vector<::blink::ParsedPermissionsPolicyDeclaration>&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("origin"), this->origin,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const ::url::Origin&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool ParentPermissionsInfo::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
FencedFrameConfig::FencedFrameConfig()
    : mapped_url()
    , container_size()
    , content_size()
    , deprecated_should_freeze_initial_size()
    , ad_auction_data()
    , nested_configs()
    , shared_storage_budget_metadata()
    , urn_uuid()
    , mode()
    , effective_enabled_permissions()
    , parent_permissions_info()
{
}

FencedFrameConfig::FencedFrameConfig(const std::optional<::blink::FencedFrame::RedactedFencedFrameProperty<GURL>>& mapped_url_in,
    const std::optional<::blink::FencedFrame::RedactedFencedFrameProperty<::gfx::Size>>& container_size_in,
    const std::optional<::blink::FencedFrame::RedactedFencedFrameProperty<::gfx::Size>>& content_size_in,
    const std::optional<::blink::FencedFrame::RedactedFencedFrameProperty<bool>>& deprecated_should_freeze_initial_size_in,
    const std::optional<::blink::FencedFrame::RedactedFencedFrameProperty<::blink::FencedFrame::AdAuctionData>>& ad_auction_data_in,
    const std::optional<::blink::FencedFrame::RedactedFencedFrameProperty<std::vector<::blink::FencedFrame::RedactedFencedFrameConfig>>>& nested_configs_in,
    const std::optional<::blink::FencedFrame::RedactedFencedFrameProperty<::blink::FencedFrame::SharedStorageBudgetMetadata>>&
        shared_storage_budget_metadata_in,
    const ::GURL& urn_uuid_in, ::blink::FencedFrame::DeprecatedFencedFrameMode mode_in,
    std::vector<::blink::mojom::PermissionsPolicyFeature> effective_enabled_permissions_in, ParentPermissionsInfoPtr parent_permissions_info_in)
    : mapped_url(std::move(mapped_url_in))
    , container_size(std::move(container_size_in))
    , content_size(std::move(content_size_in))
    , deprecated_should_freeze_initial_size(std::move(deprecated_should_freeze_initial_size_in))
    , ad_auction_data(std::move(ad_auction_data_in))
    , nested_configs(std::move(nested_configs_in))
    , shared_storage_budget_metadata(std::move(shared_storage_budget_metadata_in))
    , urn_uuid(std::move(urn_uuid_in))
    , mode(std::move(mode_in))
    , effective_enabled_permissions(std::move(effective_enabled_permissions_in))
    , parent_permissions_info(std::move(parent_permissions_info_in))
{
}

FencedFrameConfig::~FencedFrameConfig() = default;

void FencedFrameConfig::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("mapped_url"), this->mapped_url,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::optional<::blink::FencedFrame::RedactedFencedFrameProperty<GURL>>&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("container_size"), this->container_size,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::optional<::blink::FencedFrame::RedactedFencedFrameProperty<::gfx::Size>>&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("content_size"), this->content_size,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::optional<::blink::FencedFrame::RedactedFencedFrameProperty<::gfx::Size>>&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("deprecated_should_freeze_initial_size"), this->deprecated_should_freeze_initial_size,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::optional<::blink::FencedFrame::RedactedFencedFrameProperty<bool>>&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("ad_auction_data"), this->ad_auction_data,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::optional<::blink::FencedFrame::RedactedFencedFrameProperty<::blink::FencedFrame::AdAuctionData>>&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("nested_configs"), this->nested_configs,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::optional<::blink::FencedFrame::RedactedFencedFrameProperty<std::vector<::blink::FencedFrame::RedactedFencedFrameConfig>>>&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("shared_storage_budget_metadata"), this->shared_storage_budget_metadata,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::optional<::blink::FencedFrame::RedactedFencedFrameProperty<::blink::FencedFrame::SharedStorageBudgetMetadata>>&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("urn_uuid"), this->urn_uuid,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const ::GURL&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("mode"), this->mode,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type ::blink::FencedFrame::DeprecatedFencedFrameMode>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("effective_enabled_permissions"), this->effective_enabled_permissions,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::vector<::blink::mojom::PermissionsPolicyFeature>&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("parent_permissions_info"), this->parent_permissions_info,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type ParentPermissionsInfoPtr>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool FencedFrameConfig::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
FencedFrameProperties::FencedFrameProperties()
    : mapped_url()
    , container_size()
    , content_size()
    , deprecated_should_freeze_initial_size()
    , ad_auction_data()
    , nested_urn_config_pairs()
    , shared_storage_budget_metadata()
    , has_fenced_frame_reporting()
    , mode()
    , effective_enabled_permissions()
    , parent_permissions_info()
    , can_disable_untrusted_network()
    , is_cross_origin_content()
    , allow_cross_origin_event_reporting()
{
}

FencedFrameProperties::FencedFrameProperties(const std::optional<::blink::FencedFrame::RedactedFencedFrameProperty<GURL>>& mapped_url_in,
    const std::optional<::blink::FencedFrame::RedactedFencedFrameProperty<::gfx::Size>>& container_size_in,
    const std::optional<::blink::FencedFrame::RedactedFencedFrameProperty<::gfx::Size>>& content_size_in,
    const std::optional<::blink::FencedFrame::RedactedFencedFrameProperty<bool>>& deprecated_should_freeze_initial_size_in,
    const std::optional<::blink::FencedFrame::RedactedFencedFrameProperty<::blink::FencedFrame::AdAuctionData>>& ad_auction_data_in,
    PotentiallyOpaqueURNConfigVectorPtr nested_urn_config_pairs_in,
    const std::optional<::blink::FencedFrame::RedactedFencedFrameProperty<::blink::FencedFrame::SharedStorageBudgetMetadata>>&
        shared_storage_budget_metadata_in,
    bool has_fenced_frame_reporting_in, ::blink::FencedFrame::DeprecatedFencedFrameMode mode_in,
    std::vector<::blink::mojom::PermissionsPolicyFeature> effective_enabled_permissions_in, ParentPermissionsInfoPtr parent_permissions_info_in,
    bool can_disable_untrusted_network_in, bool is_cross_origin_content_in, bool allow_cross_origin_event_reporting_in)
    : mapped_url(std::move(mapped_url_in))
    , container_size(std::move(container_size_in))
    , content_size(std::move(content_size_in))
    , deprecated_should_freeze_initial_size(std::move(deprecated_should_freeze_initial_size_in))
    , ad_auction_data(std::move(ad_auction_data_in))
    , nested_urn_config_pairs(std::move(nested_urn_config_pairs_in))
    , shared_storage_budget_metadata(std::move(shared_storage_budget_metadata_in))
    , has_fenced_frame_reporting(std::move(has_fenced_frame_reporting_in))
    , mode(std::move(mode_in))
    , effective_enabled_permissions(std::move(effective_enabled_permissions_in))
    , parent_permissions_info(std::move(parent_permissions_info_in))
    , can_disable_untrusted_network(std::move(can_disable_untrusted_network_in))
    , is_cross_origin_content(std::move(is_cross_origin_content_in))
    , allow_cross_origin_event_reporting(std::move(allow_cross_origin_event_reporting_in))
{
}

FencedFrameProperties::~FencedFrameProperties() = default;

void FencedFrameProperties::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("mapped_url"), this->mapped_url,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::optional<::blink::FencedFrame::RedactedFencedFrameProperty<GURL>>&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("container_size"), this->container_size,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::optional<::blink::FencedFrame::RedactedFencedFrameProperty<::gfx::Size>>&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("content_size"), this->content_size,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::optional<::blink::FencedFrame::RedactedFencedFrameProperty<::gfx::Size>>&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("deprecated_should_freeze_initial_size"), this->deprecated_should_freeze_initial_size,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::optional<::blink::FencedFrame::RedactedFencedFrameProperty<bool>>&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("ad_auction_data"), this->ad_auction_data,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::optional<::blink::FencedFrame::RedactedFencedFrameProperty<::blink::FencedFrame::AdAuctionData>>&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("nested_urn_config_pairs"), this->nested_urn_config_pairs,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type PotentiallyOpaqueURNConfigVectorPtr>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("shared_storage_budget_metadata"), this->shared_storage_budget_metadata,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::optional<::blink::FencedFrame::RedactedFencedFrameProperty<::blink::FencedFrame::SharedStorageBudgetMetadata>>&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("has_fenced_frame_reporting"), this->has_fenced_frame_reporting,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type bool>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("mode"), this->mode,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type ::blink::FencedFrame::DeprecatedFencedFrameMode>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("effective_enabled_permissions"), this->effective_enabled_permissions,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::vector<::blink::mojom::PermissionsPolicyFeature>&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("parent_permissions_info"), this->parent_permissions_info,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type ParentPermissionsInfoPtr>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("can_disable_untrusted_network"), this->can_disable_untrusted_network,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type bool>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("is_cross_origin_content"), this->is_cross_origin_content,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type bool>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("allow_cross_origin_event_reporting"), this->allow_cross_origin_event_reporting,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type bool>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool FencedFrameProperties::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
PotentiallyOpaqueURL::PotentiallyOpaqueURL()
    : tag_(Tag::kTransparent)
{
    data_.transparent = new ::GURL;
}

PotentiallyOpaqueURL::~PotentiallyOpaqueURL()
{
    DestroyActive();
}

void PotentiallyOpaqueURL::set_transparent(const ::GURL& transparent)
{
    if (tag_ == Tag::kTransparent) {
        *(data_.transparent) = std::move(transparent);
    } else {
        DestroyActive();
        tag_ = Tag::kTransparent;
        data_.transparent = new ::GURL(std::move(transparent));
    }
}
void PotentiallyOpaqueURL::set_opaque(::blink::FencedFrame::Opaque opaque)
{
    if (tag_ != Tag::kOpaque) {
        DestroyActive();
        tag_ = Tag::kOpaque;
    }
    data_.opaque = opaque;
}

void PotentiallyOpaqueURL::DestroyActive()
{
    switch (tag_) {

    case Tag::kTransparent:

        delete data_.transparent;
        break;
    case Tag::kOpaque:

        break;
    }
}

bool PotentiallyOpaqueURL::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context, false);
}
PotentiallyOpaqueSize::PotentiallyOpaqueSize()
    : tag_(Tag::kTransparent)
{
    data_.transparent = new ::gfx::Size;
}

PotentiallyOpaqueSize::~PotentiallyOpaqueSize()
{
    DestroyActive();
}

void PotentiallyOpaqueSize::set_transparent(const ::gfx::Size& transparent)
{
    if (tag_ == Tag::kTransparent) {
        *(data_.transparent) = std::move(transparent);
    } else {
        DestroyActive();
        tag_ = Tag::kTransparent;
        data_.transparent = new ::gfx::Size(std::move(transparent));
    }
}
void PotentiallyOpaqueSize::set_opaque(::blink::FencedFrame::Opaque opaque)
{
    if (tag_ != Tag::kOpaque) {
        DestroyActive();
        tag_ = Tag::kOpaque;
    }
    data_.opaque = opaque;
}

void PotentiallyOpaqueSize::DestroyActive()
{
    switch (tag_) {

    case Tag::kTransparent:

        delete data_.transparent;
        break;
    case Tag::kOpaque:

        break;
    }
}

bool PotentiallyOpaqueSize::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context, false);
}
PotentiallyOpaqueBool::PotentiallyOpaqueBool()
    : tag_(Tag::kTransparent)
{
    data_.transparent = bool();
}

PotentiallyOpaqueBool::~PotentiallyOpaqueBool()
{
    DestroyActive();
}

void PotentiallyOpaqueBool::set_transparent(bool transparent)
{
    if (tag_ != Tag::kTransparent) {
        DestroyActive();
        tag_ = Tag::kTransparent;
    }
    data_.transparent = transparent;
}
void PotentiallyOpaqueBool::set_opaque(::blink::FencedFrame::Opaque opaque)
{
    if (tag_ != Tag::kOpaque) {
        DestroyActive();
        tag_ = Tag::kOpaque;
    }
    data_.opaque = opaque;
}

void PotentiallyOpaqueBool::DestroyActive()
{
    switch (tag_) {

    case Tag::kTransparent:

        break;
    case Tag::kOpaque:

        break;
    }
}

bool PotentiallyOpaqueBool::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context, false);
}
PotentiallyOpaqueAdAuctionData::PotentiallyOpaqueAdAuctionData()
    : tag_(Tag::kTransparent)
{
    data_.transparent = new ::blink::FencedFrame::AdAuctionData;
}

PotentiallyOpaqueAdAuctionData::~PotentiallyOpaqueAdAuctionData()
{
    DestroyActive();
}

void PotentiallyOpaqueAdAuctionData::set_transparent(const ::blink::FencedFrame::AdAuctionData& transparent)
{
    if (tag_ == Tag::kTransparent) {
        *(data_.transparent) = std::move(transparent);
    } else {
        DestroyActive();
        tag_ = Tag::kTransparent;
        data_.transparent = new ::blink::FencedFrame::AdAuctionData(std::move(transparent));
    }
}
void PotentiallyOpaqueAdAuctionData::set_opaque(::blink::FencedFrame::Opaque opaque)
{
    if (tag_ != Tag::kOpaque) {
        DestroyActive();
        tag_ = Tag::kOpaque;
    }
    data_.opaque = opaque;
}

void PotentiallyOpaqueAdAuctionData::DestroyActive()
{
    switch (tag_) {

    case Tag::kTransparent:

        delete data_.transparent;
        break;
    case Tag::kOpaque:

        break;
    }
}

bool PotentiallyOpaqueAdAuctionData::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context, false);
}
PotentiallyOpaqueConfigVector::PotentiallyOpaqueConfigVector()
    : tag_(Tag::kTransparent)
{
    data_.transparent = new std::vector<::blink::FencedFrame::RedactedFencedFrameConfig>;
}

PotentiallyOpaqueConfigVector::~PotentiallyOpaqueConfigVector()
{
    DestroyActive();
}

void PotentiallyOpaqueConfigVector::set_transparent(std::vector<::blink::FencedFrame::RedactedFencedFrameConfig> transparent)
{
    if (tag_ == Tag::kTransparent) {
        *(data_.transparent) = std::move(transparent);
    } else {
        DestroyActive();
        tag_ = Tag::kTransparent;
        data_.transparent = new std::vector<::blink::FencedFrame::RedactedFencedFrameConfig>(std::move(transparent));
    }
}
void PotentiallyOpaqueConfigVector::set_opaque(::blink::FencedFrame::Opaque opaque)
{
    if (tag_ != Tag::kOpaque) {
        DestroyActive();
        tag_ = Tag::kOpaque;
    }
    data_.opaque = opaque;
}

void PotentiallyOpaqueConfigVector::DestroyActive()
{
    switch (tag_) {

    case Tag::kTransparent:

        delete data_.transparent;
        break;
    case Tag::kOpaque:

        break;
    }
}

bool PotentiallyOpaqueConfigVector::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context, false);
}
PotentiallyOpaqueURNConfigVector::PotentiallyOpaqueURNConfigVector()
    : tag_(Tag::kTransparent)
{
    data_.transparent = new std::vector<URNConfigPairPtr>;
}

PotentiallyOpaqueURNConfigVector::~PotentiallyOpaqueURNConfigVector()
{
    DestroyActive();
}

void PotentiallyOpaqueURNConfigVector::set_transparent(std::vector<URNConfigPairPtr> transparent)
{
    if (tag_ == Tag::kTransparent) {
        *(data_.transparent) = std::move(transparent);
    } else {
        DestroyActive();
        tag_ = Tag::kTransparent;
        data_.transparent = new std::vector<URNConfigPairPtr>(std::move(transparent));
    }
}
void PotentiallyOpaqueURNConfigVector::set_opaque(::blink::FencedFrame::Opaque opaque)
{
    if (tag_ != Tag::kOpaque) {
        DestroyActive();
        tag_ = Tag::kOpaque;
    }
    data_.opaque = opaque;
}

void PotentiallyOpaqueURNConfigVector::DestroyActive()
{
    switch (tag_) {

    case Tag::kTransparent:

        delete data_.transparent;
        break;
    case Tag::kOpaque:

        break;
    }
}

bool PotentiallyOpaqueURNConfigVector::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context, false);
}
PotentiallyOpaqueSharedStorageBudgetMetadata::PotentiallyOpaqueSharedStorageBudgetMetadata()
    : tag_(Tag::kTransparent)
{
    data_.transparent = new ::blink::FencedFrame::SharedStorageBudgetMetadata;
}

PotentiallyOpaqueSharedStorageBudgetMetadata::~PotentiallyOpaqueSharedStorageBudgetMetadata()
{
    DestroyActive();
}

void PotentiallyOpaqueSharedStorageBudgetMetadata::set_transparent(const ::blink::FencedFrame::SharedStorageBudgetMetadata& transparent)
{
    if (tag_ == Tag::kTransparent) {
        *(data_.transparent) = std::move(transparent);
    } else {
        DestroyActive();
        tag_ = Tag::kTransparent;
        data_.transparent = new ::blink::FencedFrame::SharedStorageBudgetMetadata(std::move(transparent));
    }
}
void PotentiallyOpaqueSharedStorageBudgetMetadata::set_opaque(::blink::FencedFrame::Opaque opaque)
{
    if (tag_ != Tag::kOpaque) {
        DestroyActive();
        tag_ = Tag::kOpaque;
    }
    data_.opaque = opaque;
}

void PotentiallyOpaqueSharedStorageBudgetMetadata::DestroyActive()
{
    switch (tag_) {

    case Tag::kTransparent:

        delete data_.transparent;
        break;
    case Tag::kOpaque:

        break;
    }
}

bool PotentiallyOpaqueSharedStorageBudgetMetadata::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context, false);
}

} // blink::mojom

namespace mojo {

// static
bool StructTraits<::blink::mojom::AdAuctionData::DataView, ::blink::mojom::AdAuctionDataPtr>::Read(
    ::blink::mojom::AdAuctionData::DataView input, ::blink::mojom::AdAuctionDataPtr* output)
{
    bool success = true;
    ::blink::mojom::AdAuctionDataPtr result(::blink::mojom::AdAuctionData::New());

    if (success && !input.ReadInterestGroupOwner(&result->interest_group_owner))
        success = false;
    if (success && !input.ReadInterestGroupName(&result->interest_group_name))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::blink::mojom::URNConfigPair::DataView, ::blink::mojom::URNConfigPairPtr>::Read(
    ::blink::mojom::URNConfigPair::DataView input, ::blink::mojom::URNConfigPairPtr* output)
{
    bool success = true;
    ::blink::mojom::URNConfigPairPtr result(::blink::mojom::URNConfigPair::New());

    if (success && !input.ReadUrn(&result->urn))
        success = false;
    if (success && !input.ReadConfig(&result->config))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::blink::mojom::SharedStorageBudgetMetadata::DataView, ::blink::mojom::SharedStorageBudgetMetadataPtr>::Read(
    ::blink::mojom::SharedStorageBudgetMetadata::DataView input, ::blink::mojom::SharedStorageBudgetMetadataPtr* output)
{
    bool success = true;
    ::blink::mojom::SharedStorageBudgetMetadataPtr result(::blink::mojom::SharedStorageBudgetMetadata::New());

    if (success && !input.ReadSite(&result->site))
        success = false;
    if (success)
        result->budget_to_charge = input.budget_to_charge();
    if (success)
        result->top_navigated = input.top_navigated();
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::blink::mojom::ParentPermissionsInfo::DataView, ::blink::mojom::ParentPermissionsInfoPtr>::Read(
    ::blink::mojom::ParentPermissionsInfo::DataView input, ::blink::mojom::ParentPermissionsInfoPtr* output)
{
    bool success = true;
    ::blink::mojom::ParentPermissionsInfoPtr result(::blink::mojom::ParentPermissionsInfo::New());

    if (success && !input.ReadParsedPermissionsPolicy(&result->parsed_permissions_policy))
        success = false;
    if (success && !input.ReadOrigin(&result->origin))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::blink::mojom::FencedFrameConfig::DataView, ::blink::mojom::FencedFrameConfigPtr>::Read(
    ::blink::mojom::FencedFrameConfig::DataView input, ::blink::mojom::FencedFrameConfigPtr* output)
{
    bool success = true;
    ::blink::mojom::FencedFrameConfigPtr result(::blink::mojom::FencedFrameConfig::New());

    if (success && !input.ReadMappedUrl(&result->mapped_url))
        success = false;
    if (success && !input.ReadContainerSize(&result->container_size))
        success = false;
    if (success && !input.ReadContentSize(&result->content_size))
        success = false;
    if (success && !input.ReadDeprecatedShouldFreezeInitialSize(&result->deprecated_should_freeze_initial_size))
        success = false;
    if (success && !input.ReadAdAuctionData(&result->ad_auction_data))
        success = false;
    if (success && !input.ReadNestedConfigs(&result->nested_configs))
        success = false;
    if (success && !input.ReadSharedStorageBudgetMetadata(&result->shared_storage_budget_metadata))
        success = false;
    if (success && !input.ReadUrnUuid(&result->urn_uuid))
        success = false;
    if (success && !input.ReadMode(&result->mode))
        success = false;
    if (success && !input.ReadEffectiveEnabledPermissions(&result->effective_enabled_permissions))
        success = false;
    if (success && !input.ReadParentPermissionsInfo(&result->parent_permissions_info))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::blink::mojom::FencedFrameProperties::DataView, ::blink::mojom::FencedFramePropertiesPtr>::Read(
    ::blink::mojom::FencedFrameProperties::DataView input, ::blink::mojom::FencedFramePropertiesPtr* output)
{
    bool success = true;
    ::blink::mojom::FencedFramePropertiesPtr result(::blink::mojom::FencedFrameProperties::New());

    if (success && !input.ReadMappedUrl(&result->mapped_url))
        success = false;
    if (success && !input.ReadContainerSize(&result->container_size))
        success = false;
    if (success && !input.ReadContentSize(&result->content_size))
        success = false;
    if (success && !input.ReadDeprecatedShouldFreezeInitialSize(&result->deprecated_should_freeze_initial_size))
        success = false;
    if (success && !input.ReadAdAuctionData(&result->ad_auction_data))
        success = false;
    if (success && !input.ReadNestedUrnConfigPairs(&result->nested_urn_config_pairs))
        success = false;
    if (success && !input.ReadSharedStorageBudgetMetadata(&result->shared_storage_budget_metadata))
        success = false;
    if (success)
        result->has_fenced_frame_reporting = input.has_fenced_frame_reporting();
    if (success && !input.ReadMode(&result->mode))
        success = false;
    if (success && !input.ReadEffectiveEnabledPermissions(&result->effective_enabled_permissions))
        success = false;
    if (success && !input.ReadParentPermissionsInfo(&result->parent_permissions_info))
        success = false;
    if (success)
        result->can_disable_untrusted_network = input.can_disable_untrusted_network();
    if (success)
        result->is_cross_origin_content = input.is_cross_origin_content();
    if (success)
        result->allow_cross_origin_event_reporting = input.allow_cross_origin_event_reporting();
    *output = std::move(result);
    return success;
}

// static
bool UnionTraits<::blink::mojom::PotentiallyOpaqueURL::DataView, ::blink::mojom::PotentiallyOpaqueURLPtr>::Read(
    ::blink::mojom::PotentiallyOpaqueURL::DataView input, ::blink::mojom::PotentiallyOpaqueURLPtr* output)
{
    using UnionType = ::blink::mojom::PotentiallyOpaqueURL;
    using Tag = UnionType::Tag;

    switch (input.tag()) {
    case Tag::kTransparent: {
        ::GURL result_transparent;
        if (!input.ReadTransparent(&result_transparent))
            return false;

        *output = UnionType::NewTransparent(std::move(result_transparent));
        break;
    }
    case Tag::kOpaque: {
        ::blink::FencedFrame::Opaque result_opaque;
        if (!input.ReadOpaque(&result_opaque))
            return false;

        *output = UnionType::NewOpaque(result_opaque);
        break;
    }
    default:

        return false;
    }
    return true;
}

// static
bool UnionTraits<::blink::mojom::PotentiallyOpaqueSize::DataView, ::blink::mojom::PotentiallyOpaqueSizePtr>::Read(
    ::blink::mojom::PotentiallyOpaqueSize::DataView input, ::blink::mojom::PotentiallyOpaqueSizePtr* output)
{
    using UnionType = ::blink::mojom::PotentiallyOpaqueSize;
    using Tag = UnionType::Tag;

    switch (input.tag()) {
    case Tag::kTransparent: {
        ::gfx::Size result_transparent;
        if (!input.ReadTransparent(&result_transparent))
            return false;

        *output = UnionType::NewTransparent(std::move(result_transparent));
        break;
    }
    case Tag::kOpaque: {
        ::blink::FencedFrame::Opaque result_opaque;
        if (!input.ReadOpaque(&result_opaque))
            return false;

        *output = UnionType::NewOpaque(result_opaque);
        break;
    }
    default:

        return false;
    }
    return true;
}

// static
bool UnionTraits<::blink::mojom::PotentiallyOpaqueBool::DataView, ::blink::mojom::PotentiallyOpaqueBoolPtr>::Read(
    ::blink::mojom::PotentiallyOpaqueBool::DataView input, ::blink::mojom::PotentiallyOpaqueBoolPtr* output)
{
    using UnionType = ::blink::mojom::PotentiallyOpaqueBool;
    using Tag = UnionType::Tag;

    switch (input.tag()) {
    case Tag::kTransparent: {
        *output = UnionType::NewTransparent(input.transparent());
        break;
    }
    case Tag::kOpaque: {
        ::blink::FencedFrame::Opaque result_opaque;
        if (!input.ReadOpaque(&result_opaque))
            return false;

        *output = UnionType::NewOpaque(result_opaque);
        break;
    }
    default:

        return false;
    }
    return true;
}

// static
bool UnionTraits<::blink::mojom::PotentiallyOpaqueAdAuctionData::DataView, ::blink::mojom::PotentiallyOpaqueAdAuctionDataPtr>::Read(
    ::blink::mojom::PotentiallyOpaqueAdAuctionData::DataView input, ::blink::mojom::PotentiallyOpaqueAdAuctionDataPtr* output)
{
    using UnionType = ::blink::mojom::PotentiallyOpaqueAdAuctionData;
    using Tag = UnionType::Tag;

    switch (input.tag()) {
    case Tag::kTransparent: {
        ::blink::FencedFrame::AdAuctionData result_transparent;
        if (!input.ReadTransparent(&result_transparent))
            return false;

        *output = UnionType::NewTransparent(std::move(result_transparent));
        break;
    }
    case Tag::kOpaque: {
        ::blink::FencedFrame::Opaque result_opaque;
        if (!input.ReadOpaque(&result_opaque))
            return false;

        *output = UnionType::NewOpaque(result_opaque);
        break;
    }
    default:

        return false;
    }
    return true;
}

// static
bool UnionTraits<::blink::mojom::PotentiallyOpaqueConfigVector::DataView, ::blink::mojom::PotentiallyOpaqueConfigVectorPtr>::Read(
    ::blink::mojom::PotentiallyOpaqueConfigVector::DataView input, ::blink::mojom::PotentiallyOpaqueConfigVectorPtr* output)
{
    using UnionType = ::blink::mojom::PotentiallyOpaqueConfigVector;
    using Tag = UnionType::Tag;

    switch (input.tag()) {
    case Tag::kTransparent: {
        std::vector<::blink::FencedFrame::RedactedFencedFrameConfig> result_transparent;
        if (!input.ReadTransparent(&result_transparent))
            return false;

        *output = UnionType::NewTransparent(std::move(result_transparent));
        break;
    }
    case Tag::kOpaque: {
        ::blink::FencedFrame::Opaque result_opaque;
        if (!input.ReadOpaque(&result_opaque))
            return false;

        *output = UnionType::NewOpaque(result_opaque);
        break;
    }
    default:

        return false;
    }
    return true;
}

// static
bool UnionTraits<::blink::mojom::PotentiallyOpaqueURNConfigVector::DataView, ::blink::mojom::PotentiallyOpaqueURNConfigVectorPtr>::Read(
    ::blink::mojom::PotentiallyOpaqueURNConfigVector::DataView input, ::blink::mojom::PotentiallyOpaqueURNConfigVectorPtr* output)
{
    using UnionType = ::blink::mojom::PotentiallyOpaqueURNConfigVector;
    using Tag = UnionType::Tag;

    switch (input.tag()) {
    case Tag::kTransparent: {
        std::vector<::blink::mojom::URNConfigPairPtr> result_transparent;
        if (!input.ReadTransparent(&result_transparent))
            return false;

        *output = UnionType::NewTransparent(std::move(result_transparent));
        break;
    }
    case Tag::kOpaque: {
        ::blink::FencedFrame::Opaque result_opaque;
        if (!input.ReadOpaque(&result_opaque))
            return false;

        *output = UnionType::NewOpaque(result_opaque);
        break;
    }
    default:

        return false;
    }
    return true;
}

// static
bool UnionTraits<::blink::mojom::PotentiallyOpaqueSharedStorageBudgetMetadata::DataView, ::blink::mojom::PotentiallyOpaqueSharedStorageBudgetMetadataPtr>::Read(
    ::blink::mojom::PotentiallyOpaqueSharedStorageBudgetMetadata::DataView input, ::blink::mojom::PotentiallyOpaqueSharedStorageBudgetMetadataPtr* output)
{
    using UnionType = ::blink::mojom::PotentiallyOpaqueSharedStorageBudgetMetadata;
    using Tag = UnionType::Tag;

    switch (input.tag()) {
    case Tag::kTransparent: {
        ::blink::FencedFrame::SharedStorageBudgetMetadata result_transparent;
        if (!input.ReadTransparent(&result_transparent))
            return false;

        *output = UnionType::NewTransparent(std::move(result_transparent));
        break;
    }
    case Tag::kOpaque: {
        ::blink::FencedFrame::Opaque result_opaque;
        if (!input.ReadOpaque(&result_opaque))
            return false;

        *output = UnionType::NewOpaque(result_opaque);
        break;
    }
    default:

        return false;
    }
    return true;
}

} // namespace mojo

// Symbols declared in the -test-utils.h header are defined here instead of a
// separate .cc file to save compile time.

namespace blink::mojom {

} // blink::mojom

#if defined(__clang__)
#pragma clang diagnostic pop
#endif