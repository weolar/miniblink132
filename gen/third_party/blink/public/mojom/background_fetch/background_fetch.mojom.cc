// third_party/blink/public/mojom/background_fetch/background_fetch.mojom.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif

#include "third_party/blink/public/mojom/background_fetch/background_fetch.mojom.h"

#include <math.h>
#include <stdint.h>
#include <utility>

#include "base/debug/alias.h"
#include "base/hash/md5_constexpr.h"
#include "base/run_loop.h"
#include "base/strings/string_number_conversions.h"
#include "base/task/thread_pool/thread_pool_instance.h"
#include "base/trace_event/trace_event.h"
#include "base/trace_event/typed_macros.h"
#include "mojo/public/cpp/bindings/features.h"
#include "mojo/public/cpp/bindings/lib/default_construct_tag_internal.h"
#include "mojo/public/cpp/bindings/lib/generated_code_util.h"
#include "mojo/public/cpp/bindings/lib/message_internal.h"
#include "mojo/public/cpp/bindings/lib/proxy_to_responder.h"
#include "mojo/public/cpp/bindings/lib/send_message_helper.h"
#include "mojo/public/cpp/bindings/lib/serialization_util.h"
#include "mojo/public/cpp/bindings/lib/unserialized_message_context.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/mojo_buildflags.h"
#include "mojo/public/cpp/bindings/urgent_message_scope.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"
#include "third_party/perfetto/include/perfetto/tracing/traced_value.h"

#include "third_party/blink/public/mojom/background_fetch/background_fetch.mojom-params-data.h"
#include "third_party/blink/public/mojom/background_fetch/background_fetch.mojom-shared-message-ids.h"

#include "third_party/blink/public/mojom/background_fetch/background_fetch.mojom-import-headers.h"
#include "third_party/blink/public/mojom/background_fetch/background_fetch.mojom-test-utils.h"
#include "services/network/public/mojom/cookie_access_observer.mojom.h"
#include "services/network/public/mojom/devtools_observer.mojom.h"
#include "services/network/public/mojom/trust_token_access_observer.mojom.h"
#include "third_party/blink/public/common/manifest/manifest_mojom_traits.h"

namespace blink::mojom {
BackgroundFetchSettledFetch::BackgroundFetchSettledFetch()
    : request()
    , response()
{
}

BackgroundFetchSettledFetch::BackgroundFetchSettledFetch(::blink::mojom::FetchAPIRequestPtr request_in, ::blink::mojom::FetchAPIResponsePtr response_in)
    : request(std::move(request_in))
    , response(std::move(response_in))
{
}

BackgroundFetchSettledFetch::~BackgroundFetchSettledFetch() = default;

void BackgroundFetchSettledFetch::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("request"), this->request,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type ::blink::mojom::FetchAPIRequestPtr>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("response"), this->response,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type ::blink::mojom::FetchAPIResponsePtr>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool BackgroundFetchSettledFetch::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
BackgroundFetchOptions::BackgroundFetchOptions()
    : icons()
    , download_total()
    , title()
{
}

BackgroundFetchOptions::BackgroundFetchOptions(std::vector<::blink::Manifest::ImageResource> icons_in, uint64_t download_total_in, const std::string& title_in)
    : icons(std::move(icons_in))
    , download_total(std::move(download_total_in))
    , title(std::move(title_in))
{
}

BackgroundFetchOptions::~BackgroundFetchOptions() = default;

void BackgroundFetchOptions::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("icons"), this->icons,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::vector<::blink::Manifest::ImageResource>&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("download_total"), this->download_total,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("title"), this->title,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool BackgroundFetchOptions::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
BackgroundFetchRegistrationData::BackgroundFetchRegistrationData()
    : developer_id()
    , upload_total()
    , uploaded()
    , download_total()
    , downloaded()
    , result(BackgroundFetchResult::UNSET)
    , failure_reason(BackgroundFetchFailureReason::NONE)
{
}

BackgroundFetchRegistrationData::BackgroundFetchRegistrationData(const std::string& developer_id_in, uint64_t upload_total_in, uint64_t uploaded_in,
    uint64_t download_total_in, uint64_t downloaded_in, BackgroundFetchResult result_in, BackgroundFetchFailureReason failure_reason_in)
    : developer_id(std::move(developer_id_in))
    , upload_total(std::move(upload_total_in))
    , uploaded(std::move(uploaded_in))
    , download_total(std::move(download_total_in))
    , downloaded(std::move(downloaded_in))
    , result(std::move(result_in))
    , failure_reason(std::move(failure_reason_in))
{
}

BackgroundFetchRegistrationData::~BackgroundFetchRegistrationData() = default;
size_t BackgroundFetchRegistrationData::Hash(size_t seed) const
{
    seed = mojo::internal::Hash(seed, this->developer_id);
    seed = mojo::internal::Hash(seed, this->upload_total);
    seed = mojo::internal::Hash(seed, this->uploaded);
    seed = mojo::internal::Hash(seed, this->download_total);
    seed = mojo::internal::Hash(seed, this->downloaded);
    seed = mojo::internal::Hash(seed, this->result);
    seed = mojo::internal::Hash(seed, this->failure_reason);
    return seed;
}

void BackgroundFetchRegistrationData::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("developer_id"), this->developer_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("upload_total"), this->upload_total,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("uploaded"), this->uploaded,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("download_total"), this->download_total,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("downloaded"), this->downloaded,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("result"), this->result,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type BackgroundFetchResult>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("failure_reason"), this->failure_reason,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type BackgroundFetchFailureReason>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool BackgroundFetchRegistrationData::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
BackgroundFetchRegistration::BackgroundFetchRegistration()
    : registration_data()
    , registration_interface()
{
}

BackgroundFetchRegistration::BackgroundFetchRegistration(
    BackgroundFetchRegistrationDataPtr registration_data_in, ::mojo::PendingRemote<BackgroundFetchRegistrationService> registration_interface_in)
    : registration_data(std::move(registration_data_in))
    , registration_interface(std::move(registration_interface_in))
{
}

BackgroundFetchRegistration::~BackgroundFetchRegistration() = default;

void BackgroundFetchRegistration::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("registration_data"), this->registration_data,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type BackgroundFetchRegistrationDataPtr>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("registration_interface"), this->registration_interface,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type ::mojo::PendingRemote<BackgroundFetchRegistrationService>>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool BackgroundFetchRegistration::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
BackgroundFetchUkmData::BackgroundFetchUkmData()
    : ideal_to_chosen_icon_size(-1)
{
}

BackgroundFetchUkmData::BackgroundFetchUkmData(int64_t ideal_to_chosen_icon_size_in)
    : ideal_to_chosen_icon_size(std::move(ideal_to_chosen_icon_size_in))
{
}

BackgroundFetchUkmData::~BackgroundFetchUkmData() = default;
size_t BackgroundFetchUkmData::Hash(size_t seed) const
{
    seed = mojo::internal::Hash(seed, this->ideal_to_chosen_icon_size);
    return seed;
}

void BackgroundFetchUkmData::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("ideal_to_chosen_icon_size"), this->ideal_to_chosen_icon_size,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type int64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool BackgroundFetchUkmData::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
const char BackgroundFetchRegistrationObserver::Name_[] = "blink.mojom.BackgroundFetchRegistrationObserver";

BackgroundFetchRegistrationObserver::IPCStableHashFunction BackgroundFetchRegistrationObserver::MessageToMethodInfo_(mojo::Message& message)
{
#if !BUILDFLAG(IS_FUCHSIA)
    switch (static_cast<messages::BackgroundFetchRegistrationObserver>(message.name())) {
    case messages::BackgroundFetchRegistrationObserver::kOnProgress: {
        return &BackgroundFetchRegistrationObserver::OnProgress_Sym::IPCStableHash;
    }
    case messages::BackgroundFetchRegistrationObserver::kOnRecordsUnavailable: {
        return &BackgroundFetchRegistrationObserver::OnRecordsUnavailable_Sym::IPCStableHash;
    }
    case messages::BackgroundFetchRegistrationObserver::kOnRequestCompleted: {
        return &BackgroundFetchRegistrationObserver::OnRequestCompleted_Sym::IPCStableHash;
    }
    }
#endif // !BUILDFLAG(IS_FUCHSIA)
    return nullptr;
}

const char* BackgroundFetchRegistrationObserver::MessageToMethodName_(mojo::Message& message)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
    if (!is_response) {
        switch (static_cast<messages::BackgroundFetchRegistrationObserver>(message.name())) {
        case messages::BackgroundFetchRegistrationObserver::kOnProgress:
            return "Receive blink::mojom::BackgroundFetchRegistrationObserver::OnProgress";
        case messages::BackgroundFetchRegistrationObserver::kOnRecordsUnavailable:
            return "Receive blink::mojom::BackgroundFetchRegistrationObserver::OnRecordsUnavailable";
        case messages::BackgroundFetchRegistrationObserver::kOnRequestCompleted:
            return "Receive blink::mojom::BackgroundFetchRegistrationObserver::OnRequestCompleted";
        }
    } else {
        switch (static_cast<messages::BackgroundFetchRegistrationObserver>(message.name())) {
        case messages::BackgroundFetchRegistrationObserver::kOnProgress:
            return "Receive reply blink::mojom::BackgroundFetchRegistrationObserver::OnProgress";
        case messages::BackgroundFetchRegistrationObserver::kOnRecordsUnavailable:
            return "Receive reply blink::mojom::BackgroundFetchRegistrationObserver::OnRecordsUnavailable";
        case messages::BackgroundFetchRegistrationObserver::kOnRequestCompleted:
            return "Receive reply blink::mojom::BackgroundFetchRegistrationObserver::OnRequestCompleted";
        }
    }
    return "Receive unknown mojo message";
#else
    bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
    if (is_response) {
        return "Receive mojo reply";
    } else {
        return "Receive mojo message";
    }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t BackgroundFetchRegistrationObserver::OnProgress_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::BackgroundFetchRegistrationObserver::OnProgress");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t BackgroundFetchRegistrationObserver::OnRecordsUnavailable_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::BackgroundFetchRegistrationObserver::OnRecordsUnavailable");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t BackgroundFetchRegistrationObserver::OnRequestCompleted_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::BackgroundFetchRegistrationObserver::OnRequestCompleted");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
#endif // !BUILDFLAG(IS_FUCHSIA)

BackgroundFetchRegistrationObserverProxy::BackgroundFetchRegistrationObserverProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver)
{
}

void BackgroundFetchRegistrationObserverProxy::OnProgress(uint64_t in_upload_total, uint64_t in_uploaded, uint64_t in_download_total, uint64_t in_downloaded,
    BackgroundFetchResult in_result, BackgroundFetchFailureReason in_failure_reason)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::BackgroundFetchRegistrationObserver::OnProgress", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("upload_total"), in_upload_total, "<value of type uint64_t>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("uploaded"), in_uploaded, "<value of type uint64_t>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("download_total"), in_download_total, "<value of type uint64_t>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("downloaded"), in_downloaded, "<value of type uint64_t>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("result"), in_result, "<value of type BackgroundFetchResult>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("failure_reason"), in_failure_reason, "<value of type BackgroundFetchFailureReason>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::BackgroundFetchRegistrationObserver::kOnProgress), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::BackgroundFetchRegistrationObserver_OnProgress_Params_Data> params(message);
    params.Allocate();
    params->upload_total = in_upload_total;
    params->uploaded = in_uploaded;
    params->download_total = in_download_total;
    params->downloaded = in_downloaded;
    mojo::internal::Serialize<::blink::mojom::BackgroundFetchResult>(in_result, &params->result);
    mojo::internal::Serialize<::blink::mojom::BackgroundFetchFailureReason>(in_failure_reason, &params->failure_reason);

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(BackgroundFetchRegistrationObserver::Name_);
    message.set_method_name("OnProgress");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void BackgroundFetchRegistrationObserverProxy::OnRecordsUnavailable()
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT0("mojom", "Send blink::mojom::BackgroundFetchRegistrationObserver::OnRecordsUnavailable");
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::BackgroundFetchRegistrationObserver::kOnRecordsUnavailable), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::BackgroundFetchRegistrationObserver_OnRecordsUnavailable_Params_Data> params(message);
    params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(BackgroundFetchRegistrationObserver::Name_);
    message.set_method_name("OnRecordsUnavailable");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void BackgroundFetchRegistrationObserverProxy::OnRequestCompleted(
    ::blink::mojom::FetchAPIRequestPtr in_request, ::blink::mojom::FetchAPIResponsePtr in_response)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::BackgroundFetchRegistrationObserver::OnRequestCompleted", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("request"), in_request, "<value of type ::blink::mojom::FetchAPIRequestPtr>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("response"), in_response, "<value of type ::blink::mojom::FetchAPIResponsePtr>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::BackgroundFetchRegistrationObserver::kOnRequestCompleted), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::BackgroundFetchRegistrationObserver_OnRequestCompleted_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->request)::BaseType> request_fragment(params.message());
    mojo::internal::Serialize<::blink::mojom::FetchAPIRequestDataView>(in_request, request_fragment);
    params->request.Set(request_fragment.is_null() ? nullptr : request_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->request.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null request in BackgroundFetchRegistrationObserver.OnRequestCompleted request");
    mojo::internal::MessageFragment<typename decltype(params->response)::BaseType> response_fragment(params.message());
    mojo::internal::Serialize<::blink::mojom::FetchAPIResponseDataView>(in_response, response_fragment);
    params->response.Set(response_fragment.is_null() ? nullptr : response_fragment.data());

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(BackgroundFetchRegistrationObserver::Name_);
    message.set_method_name("OnRequestCompleted");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

// static
bool BackgroundFetchRegistrationObserverStubDispatch::Accept(BackgroundFetchRegistrationObserver* impl, mojo::Message* message)
{
    switch (static_cast<messages::BackgroundFetchRegistrationObserver>(message->header()->name)) {
    case messages::BackgroundFetchRegistrationObserver::kOnProgress: {
        DCHECK(message->is_serialized());
        internal::BackgroundFetchRegistrationObserver_OnProgress_Params_Data* params
            = reinterpret_cast<internal::BackgroundFetchRegistrationObserver_OnProgress_Params_Data*>(message->mutable_payload());

        // Validation for BackgroundFetchRegistrationObserver.0
        bool success = true;
        uint64_t p_upload_total {};
        uint64_t p_uploaded {};
        uint64_t p_download_total {};
        uint64_t p_downloaded {};
        BackgroundFetchResult p_result {};
        BackgroundFetchFailureReason p_failure_reason {};
        BackgroundFetchRegistrationObserver_OnProgress_ParamsDataView input_data_view(params, message);

        if (success)
            p_upload_total = input_data_view.upload_total();
        if (success)
            p_uploaded = input_data_view.uploaded();
        if (success)
            p_download_total = input_data_view.download_total();
        if (success)
            p_downloaded = input_data_view.downloaded();
        if (success && !input_data_view.ReadResult(&p_result))
            success = false;
        if (success && !input_data_view.ReadFailureReason(&p_failure_reason))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(
                message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, BackgroundFetchRegistrationObserver::Name_, 0, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->OnProgress(std::move(p_upload_total), std::move(p_uploaded), std::move(p_download_total), std::move(p_downloaded), std::move(p_result),
            std::move(p_failure_reason));
        return true;
    }
    case messages::BackgroundFetchRegistrationObserver::kOnRecordsUnavailable: {
        DCHECK(message->is_serialized());
        internal::BackgroundFetchRegistrationObserver_OnRecordsUnavailable_Params_Data* params
            = reinterpret_cast<internal::BackgroundFetchRegistrationObserver_OnRecordsUnavailable_Params_Data*>(message->mutable_payload());

        // Validation for BackgroundFetchRegistrationObserver.1
        bool success = true;
        BackgroundFetchRegistrationObserver_OnRecordsUnavailable_ParamsDataView input_data_view(params, message);

        if (!success) {
            ReportValidationErrorForMessage(
                message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, BackgroundFetchRegistrationObserver::Name_, 1, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->OnRecordsUnavailable();
        return true;
    }
    case messages::BackgroundFetchRegistrationObserver::kOnRequestCompleted: {
        DCHECK(message->is_serialized());
        internal::BackgroundFetchRegistrationObserver_OnRequestCompleted_Params_Data* params
            = reinterpret_cast<internal::BackgroundFetchRegistrationObserver_OnRequestCompleted_Params_Data*>(message->mutable_payload());

        // Validation for BackgroundFetchRegistrationObserver.2
        bool success = true;
        ::blink::mojom::FetchAPIRequestPtr p_request {};
        ::blink::mojom::FetchAPIResponsePtr p_response {};
        BackgroundFetchRegistrationObserver_OnRequestCompleted_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadRequest(&p_request))
            success = false;
        if (success && !input_data_view.ReadResponse(&p_response))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(
                message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, BackgroundFetchRegistrationObserver::Name_, 2, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->OnRequestCompleted(std::move(p_request), std::move(p_response));
        return true;
    }
    }
    return false;
}

// static
bool BackgroundFetchRegistrationObserverStubDispatch::AcceptWithResponder(
    BackgroundFetchRegistrationObserver* impl, mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
{
    [[maybe_unused]] const bool message_is_sync = message->has_flag(mojo::Message::kFlagIsSync);
    [[maybe_unused]] const uint64_t request_id = message->request_id();
    switch (static_cast<messages::BackgroundFetchRegistrationObserver>(message->header()->name)) {
    case messages::BackgroundFetchRegistrationObserver::kOnProgress: {
        break;
    }
    case messages::BackgroundFetchRegistrationObserver::kOnRecordsUnavailable: {
        break;
    }
    case messages::BackgroundFetchRegistrationObserver::kOnRequestCompleted: {
        break;
    }
    }
    return false;
}
namespace {
} // namespace
static const mojo::internal::GenericValidationInfo kBackgroundFetchRegistrationObserverValidationInfo[] = {
    { &internal::BackgroundFetchRegistrationObserver_OnProgress_Params_Data::Validate, nullptr /* no response */ },
    { &internal::BackgroundFetchRegistrationObserver_OnRecordsUnavailable_Params_Data::Validate, nullptr /* no response */ },
    { &internal::BackgroundFetchRegistrationObserver_OnRequestCompleted_Params_Data::Validate, nullptr /* no response */ },
};

bool BackgroundFetchRegistrationObserverRequestValidator::Accept(mojo::Message* message)
{
    const char* name = ::blink::mojom::BackgroundFetchRegistrationObserver::Name_;
    return mojo::internal::ValidateRequestGenericPacked(message, name, kBackgroundFetchRegistrationObserverValidationInfo);
}

const char BackgroundFetchService::Name_[] = "blink.mojom.BackgroundFetchService";

BackgroundFetchService::IPCStableHashFunction BackgroundFetchService::MessageToMethodInfo_(mojo::Message& message)
{
#if !BUILDFLAG(IS_FUCHSIA)
    switch (static_cast<messages::BackgroundFetchService>(message.name())) {
    case messages::BackgroundFetchService::kFetch: {
        return &BackgroundFetchService::Fetch_Sym::IPCStableHash;
    }
    case messages::BackgroundFetchService::kGetRegistration: {
        return &BackgroundFetchService::GetRegistration_Sym::IPCStableHash;
    }
    case messages::BackgroundFetchService::kGetDeveloperIds: {
        return &BackgroundFetchService::GetDeveloperIds_Sym::IPCStableHash;
    }
    case messages::BackgroundFetchService::kGetIconDisplaySize: {
        return &BackgroundFetchService::GetIconDisplaySize_Sym::IPCStableHash;
    }
    }
#endif // !BUILDFLAG(IS_FUCHSIA)
    return nullptr;
}

const char* BackgroundFetchService::MessageToMethodName_(mojo::Message& message)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
    if (!is_response) {
        switch (static_cast<messages::BackgroundFetchService>(message.name())) {
        case messages::BackgroundFetchService::kFetch:
            return "Receive blink::mojom::BackgroundFetchService::Fetch";
        case messages::BackgroundFetchService::kGetRegistration:
            return "Receive blink::mojom::BackgroundFetchService::GetRegistration";
        case messages::BackgroundFetchService::kGetDeveloperIds:
            return "Receive blink::mojom::BackgroundFetchService::GetDeveloperIds";
        case messages::BackgroundFetchService::kGetIconDisplaySize:
            return "Receive blink::mojom::BackgroundFetchService::GetIconDisplaySize";
        }
    } else {
        switch (static_cast<messages::BackgroundFetchService>(message.name())) {
        case messages::BackgroundFetchService::kFetch:
            return "Receive reply blink::mojom::BackgroundFetchService::Fetch";
        case messages::BackgroundFetchService::kGetRegistration:
            return "Receive reply blink::mojom::BackgroundFetchService::GetRegistration";
        case messages::BackgroundFetchService::kGetDeveloperIds:
            return "Receive reply blink::mojom::BackgroundFetchService::GetDeveloperIds";
        case messages::BackgroundFetchService::kGetIconDisplaySize:
            return "Receive reply blink::mojom::BackgroundFetchService::GetIconDisplaySize";
        }
    }
    return "Receive unknown mojo message";
#else
    bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
    if (is_response) {
        return "Receive mojo reply";
    } else {
        return "Receive mojo message";
    }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t BackgroundFetchService::Fetch_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::BackgroundFetchService::Fetch");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t BackgroundFetchService::GetRegistration_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::BackgroundFetchService::GetRegistration");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t BackgroundFetchService::GetDeveloperIds_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::BackgroundFetchService::GetDeveloperIds");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t BackgroundFetchService::GetIconDisplaySize_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::BackgroundFetchService::GetIconDisplaySize");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
#endif // !BUILDFLAG(IS_FUCHSIA)

class BackgroundFetchService_Fetch_ForwardToCallback : public mojo::MessageReceiver {
public:
    BackgroundFetchService_Fetch_ForwardToCallback(BackgroundFetchService::FetchCallback callback)
        : callback_(std::move(callback))
    {
    }

    BackgroundFetchService_Fetch_ForwardToCallback(const BackgroundFetchService_Fetch_ForwardToCallback&) = delete;
    BackgroundFetchService_Fetch_ForwardToCallback& operator=(const BackgroundFetchService_Fetch_ForwardToCallback&) = delete;

    bool Accept(mojo::Message* message) override;

private:
    BackgroundFetchService::FetchCallback callback_;
};

class BackgroundFetchService_GetRegistration_ForwardToCallback : public mojo::MessageReceiver {
public:
    BackgroundFetchService_GetRegistration_ForwardToCallback(BackgroundFetchService::GetRegistrationCallback callback)
        : callback_(std::move(callback))
    {
    }

    BackgroundFetchService_GetRegistration_ForwardToCallback(const BackgroundFetchService_GetRegistration_ForwardToCallback&) = delete;
    BackgroundFetchService_GetRegistration_ForwardToCallback& operator=(const BackgroundFetchService_GetRegistration_ForwardToCallback&) = delete;

    bool Accept(mojo::Message* message) override;

private:
    BackgroundFetchService::GetRegistrationCallback callback_;
};

class BackgroundFetchService_GetDeveloperIds_ForwardToCallback : public mojo::MessageReceiver {
public:
    BackgroundFetchService_GetDeveloperIds_ForwardToCallback(BackgroundFetchService::GetDeveloperIdsCallback callback)
        : callback_(std::move(callback))
    {
    }

    BackgroundFetchService_GetDeveloperIds_ForwardToCallback(const BackgroundFetchService_GetDeveloperIds_ForwardToCallback&) = delete;
    BackgroundFetchService_GetDeveloperIds_ForwardToCallback& operator=(const BackgroundFetchService_GetDeveloperIds_ForwardToCallback&) = delete;

    bool Accept(mojo::Message* message) override;

private:
    BackgroundFetchService::GetDeveloperIdsCallback callback_;
};

class BackgroundFetchService_GetIconDisplaySize_ForwardToCallback : public mojo::MessageReceiver {
public:
    BackgroundFetchService_GetIconDisplaySize_ForwardToCallback(BackgroundFetchService::GetIconDisplaySizeCallback callback)
        : callback_(std::move(callback))
    {
    }

    BackgroundFetchService_GetIconDisplaySize_ForwardToCallback(const BackgroundFetchService_GetIconDisplaySize_ForwardToCallback&) = delete;
    BackgroundFetchService_GetIconDisplaySize_ForwardToCallback& operator=(const BackgroundFetchService_GetIconDisplaySize_ForwardToCallback&) = delete;

    bool Accept(mojo::Message* message) override;

private:
    BackgroundFetchService::GetIconDisplaySizeCallback callback_;
};

BackgroundFetchServiceProxy::BackgroundFetchServiceProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver)
{
}

void BackgroundFetchServiceProxy::Fetch(int64_t in_service_worker_registration_id, const std::string& in_developer_id,
    std::vector<::blink::mojom::FetchAPIRequestPtr> in_requests, BackgroundFetchOptionsPtr in_options, const ::SkBitmap& in_icon,
    BackgroundFetchUkmDataPtr in_ukm_data, FetchCallback callback)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::BackgroundFetchService::Fetch", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(
            dict.AddItem("service_worker_registration_id"), in_service_worker_registration_id, "<value of type int64_t>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("developer_id"), in_developer_id, "<value of type const std::string&>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("requests"), in_requests, "<value of type std::vector<::blink::mojom::FetchAPIRequestPtr>>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("options"), in_options, "<value of type BackgroundFetchOptionsPtr>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("icon"), in_icon, "<value of type const ::SkBitmap&>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("ukm_data"), in_ukm_data, "<value of type BackgroundFetchUkmDataPtr>");
    });
#endif

    const bool kExpectsResponse = true;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::BackgroundFetchService::kFetch), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::BackgroundFetchService_Fetch_Params_Data> params(message);
    params.Allocate();
    params->service_worker_registration_id = in_service_worker_registration_id;
    mojo::internal::MessageFragment<typename decltype(params->developer_id)::BaseType> developer_id_fragment(params.message());
    mojo::internal::Serialize<mojo::StringDataView>(in_developer_id, developer_id_fragment);
    params->developer_id.Set(developer_id_fragment.is_null() ? nullptr : developer_id_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->developer_id.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null developer_id in BackgroundFetchService.Fetch request");
    mojo::internal::MessageFragment<typename decltype(params->requests)::BaseType> requests_fragment(params.message());
    constexpr const mojo::internal::ContainerValidateParams& requests_validate_params = mojo::internal::GetArrayValidator<0, false, nullptr>();
    mojo::internal::Serialize<mojo::ArrayDataView<::blink::mojom::FetchAPIRequestDataView>>(in_requests, requests_fragment, &requests_validate_params);
    params->requests.Set(requests_fragment.is_null() ? nullptr : requests_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->requests.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null requests in BackgroundFetchService.Fetch request");
    mojo::internal::MessageFragment<typename decltype(params->options)::BaseType> options_fragment(params.message());
    mojo::internal::Serialize<::blink::mojom::BackgroundFetchOptionsDataView>(in_options, options_fragment);
    params->options.Set(options_fragment.is_null() ? nullptr : options_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->options.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null options in BackgroundFetchService.Fetch request");
    mojo::internal::MessageFragment<typename decltype(params->icon)::BaseType> icon_fragment(params.message());
    mojo::internal::Serialize<::skia::mojom::BitmapN32DataView>(in_icon, icon_fragment);
    params->icon.Set(icon_fragment.is_null() ? nullptr : icon_fragment.data());
    mojo::internal::MessageFragment<typename decltype(params->ukm_data)::BaseType> ukm_data_fragment(params.message());
    mojo::internal::Serialize<::blink::mojom::BackgroundFetchUkmDataDataView>(in_ukm_data, ukm_data_fragment);
    params->ukm_data.Set(ukm_data_fragment.is_null() ? nullptr : ukm_data_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->ukm_data.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null ukm_data in BackgroundFetchService.Fetch request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(BackgroundFetchService::Name_);
    message.set_method_name("Fetch");
#endif
    std::unique_ptr<mojo::MessageReceiver> responder(new BackgroundFetchService_Fetch_ForwardToCallback(std::move(callback)));
    ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void BackgroundFetchServiceProxy::GetRegistration(
    int64_t in_service_worker_registration_id, const std::string& in_developer_id, GetRegistrationCallback callback)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::BackgroundFetchService::GetRegistration", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(
            dict.AddItem("service_worker_registration_id"), in_service_worker_registration_id, "<value of type int64_t>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("developer_id"), in_developer_id, "<value of type const std::string&>");
    });
#endif

    const bool kExpectsResponse = true;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::BackgroundFetchService::kGetRegistration), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::BackgroundFetchService_GetRegistration_Params_Data> params(message);
    params.Allocate();
    params->service_worker_registration_id = in_service_worker_registration_id;
    mojo::internal::MessageFragment<typename decltype(params->developer_id)::BaseType> developer_id_fragment(params.message());
    mojo::internal::Serialize<mojo::StringDataView>(in_developer_id, developer_id_fragment);
    params->developer_id.Set(developer_id_fragment.is_null() ? nullptr : developer_id_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->developer_id.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null developer_id in BackgroundFetchService.GetRegistration request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(BackgroundFetchService::Name_);
    message.set_method_name("GetRegistration");
#endif
    std::unique_ptr<mojo::MessageReceiver> responder(new BackgroundFetchService_GetRegistration_ForwardToCallback(std::move(callback)));
    ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void BackgroundFetchServiceProxy::GetDeveloperIds(int64_t in_service_worker_registration_id, GetDeveloperIdsCallback callback)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::BackgroundFetchService::GetDeveloperIds", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(
            dict.AddItem("service_worker_registration_id"), in_service_worker_registration_id, "<value of type int64_t>");
    });
#endif

    const bool kExpectsResponse = true;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::BackgroundFetchService::kGetDeveloperIds), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::BackgroundFetchService_GetDeveloperIds_Params_Data> params(message);
    params.Allocate();
    params->service_worker_registration_id = in_service_worker_registration_id;

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(BackgroundFetchService::Name_);
    message.set_method_name("GetDeveloperIds");
#endif
    std::unique_ptr<mojo::MessageReceiver> responder(new BackgroundFetchService_GetDeveloperIds_ForwardToCallback(std::move(callback)));
    ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void BackgroundFetchServiceProxy::GetIconDisplaySize(GetIconDisplaySizeCallback callback)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT0("mojom", "Send blink::mojom::BackgroundFetchService::GetIconDisplaySize");
#endif

    const bool kExpectsResponse = true;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::BackgroundFetchService::kGetIconDisplaySize), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::BackgroundFetchService_GetIconDisplaySize_Params_Data> params(message);
    params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(BackgroundFetchService::Name_);
    message.set_method_name("GetIconDisplaySize");
#endif
    std::unique_ptr<mojo::MessageReceiver> responder(new BackgroundFetchService_GetIconDisplaySize_ForwardToCallback(std::move(callback)));
    ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}
class BackgroundFetchService_Fetch_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
public:
    static BackgroundFetchService::FetchCallback CreateCallback(::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
    {
        std::unique_ptr<BackgroundFetchService_Fetch_ProxyToResponder> proxy(new BackgroundFetchService_Fetch_ProxyToResponder(message, std::move(responder)));
        return base::BindOnce(&BackgroundFetchService_Fetch_ProxyToResponder::Run, std::move(proxy));
    }

    ~BackgroundFetchService_Fetch_ProxyToResponder()
    {
#if DCHECK_IS_ON()
        if (responder_) {
            // If we're being destroyed without being run, we want to ensure the
            // binding endpoint has been closed. This checks for that asynchronously.
            // We pass a bound generated callback to handle the response so that any
            // resulting DCHECK stack will have useful interface type information.
            // Instantiate a ScopedFizzleBlockShutdownTasks to allow this request to
            // fizzle if this happens after shutdown and the endpoint is bound to a
            // BLOCK_SHUTDOWN sequence.
            base::ThreadPoolInstance::ScopedFizzleBlockShutdownTasks fizzler;
            responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
        }
#endif
    }

private:
    BackgroundFetchService_Fetch_ProxyToResponder(::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
        : ::mojo::internal::ProxyToResponder(message, std::move(responder))
    {
    }

#if DCHECK_IS_ON()
    static void OnIsConnectedComplete(bool connected)
    {
        DCHECK(!connected) << "BackgroundFetchService::FetchCallback was destroyed without "
                           << "first either being run or its corresponding binding being closed. "
                           << "It is an error to drop response callbacks which still correspond "
                           << "to an open interface pipe.";
    }
#endif

    void Run(BackgroundFetchError in_error, BackgroundFetchRegistrationPtr in_registration);
};

bool BackgroundFetchService_Fetch_ForwardToCallback::Accept(mojo::Message* message)
{
    DCHECK(message->is_serialized());
    internal::BackgroundFetchService_Fetch_ResponseParams_Data* params
        = reinterpret_cast<internal::BackgroundFetchService_Fetch_ResponseParams_Data*>(message->mutable_payload());

    // Validation for BackgroundFetchService.0
    bool success = true;
    BackgroundFetchError p_error {};
    BackgroundFetchRegistrationPtr p_registration {};
    BackgroundFetchService_Fetch_ResponseParamsDataView input_data_view(params, message);

    if (success && !input_data_view.ReadError(&p_error))
        success = false;
    if (success && !input_data_view.ReadRegistration(&p_registration))
        success = false;
    if (!success) {
        ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, BackgroundFetchService::Name_, 0, true);
        return false;
    }
    if (!callback_.is_null())
        std::move(callback_).Run(std::move(p_error), std::move(p_registration));
    return true;
}

void BackgroundFetchService_Fetch_ProxyToResponder::Run(BackgroundFetchError in_error, BackgroundFetchRegistrationPtr in_registration)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send reply blink::mojom::BackgroundFetchService::Fetch", "async_response_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("error"), in_error, "<value of type BackgroundFetchError>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("registration"), in_registration, "<value of type BackgroundFetchRegistrationPtr>");
    });
#endif

    const uint32_t kFlags = mojo::Message::kFlagIsResponse | ((is_sync_) ? mojo::Message::kFlagIsSync : 0) | ((true) ? 0 : mojo::Message::kFlagNoInterrupt)
        | ((false) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::BackgroundFetchService::kFetch), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::BackgroundFetchService_Fetch_ResponseParams_Data> params(message);
    params.Allocate();
    mojo::internal::Serialize<::blink::mojom::BackgroundFetchError>(in_error, &params->error);
    mojo::internal::MessageFragment<typename decltype(params->registration)::BaseType> registration_fragment(params.message());
    mojo::internal::Serialize<::blink::mojom::BackgroundFetchRegistrationDataView>(in_registration, registration_fragment);
    params->registration.Set(registration_fragment.is_null() ? nullptr : registration_fragment.data());

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(BackgroundFetchService::Name_);
    message.set_method_name("Fetch");
#endif

    message.set_request_id(request_id_);
    message.set_trace_nonce(trace_nonce_);
    ::mojo::internal::SendMojoMessage(*responder_, message);
    // SendMojoMessage() fails silently if the responder connection is closed,
    // or if the message is malformed.
    //
    // TODO(darin): If Accept() returns false due to a malformed message, that
    // may be good reason to close the connection. However, we don't have a
    // way to do that from here. We should add a way.
    responder_ = nullptr;
}
class BackgroundFetchService_GetRegistration_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
public:
    static BackgroundFetchService::GetRegistrationCallback CreateCallback(::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
    {
        std::unique_ptr<BackgroundFetchService_GetRegistration_ProxyToResponder> proxy(
            new BackgroundFetchService_GetRegistration_ProxyToResponder(message, std::move(responder)));
        return base::BindOnce(&BackgroundFetchService_GetRegistration_ProxyToResponder::Run, std::move(proxy));
    }

    ~BackgroundFetchService_GetRegistration_ProxyToResponder()
    {
#if DCHECK_IS_ON()
        if (responder_) {
            // If we're being destroyed without being run, we want to ensure the
            // binding endpoint has been closed. This checks for that asynchronously.
            // We pass a bound generated callback to handle the response so that any
            // resulting DCHECK stack will have useful interface type information.
            // Instantiate a ScopedFizzleBlockShutdownTasks to allow this request to
            // fizzle if this happens after shutdown and the endpoint is bound to a
            // BLOCK_SHUTDOWN sequence.
            base::ThreadPoolInstance::ScopedFizzleBlockShutdownTasks fizzler;
            responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
        }
#endif
    }

private:
    BackgroundFetchService_GetRegistration_ProxyToResponder(::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
        : ::mojo::internal::ProxyToResponder(message, std::move(responder))
    {
    }

#if DCHECK_IS_ON()
    static void OnIsConnectedComplete(bool connected)
    {
        DCHECK(!connected) << "BackgroundFetchService::GetRegistrationCallback was destroyed without "
                           << "first either being run or its corresponding binding being closed. "
                           << "It is an error to drop response callbacks which still correspond "
                           << "to an open interface pipe.";
    }
#endif

    void Run(BackgroundFetchError in_error, BackgroundFetchRegistrationPtr in_registration);
};

bool BackgroundFetchService_GetRegistration_ForwardToCallback::Accept(mojo::Message* message)
{
    DCHECK(message->is_serialized());
    internal::BackgroundFetchService_GetRegistration_ResponseParams_Data* params
        = reinterpret_cast<internal::BackgroundFetchService_GetRegistration_ResponseParams_Data*>(message->mutable_payload());

    // Validation for BackgroundFetchService.1
    bool success = true;
    BackgroundFetchError p_error {};
    BackgroundFetchRegistrationPtr p_registration {};
    BackgroundFetchService_GetRegistration_ResponseParamsDataView input_data_view(params, message);

    if (success && !input_data_view.ReadError(&p_error))
        success = false;
    if (success && !input_data_view.ReadRegistration(&p_registration))
        success = false;
    if (!success) {
        ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, BackgroundFetchService::Name_, 1, true);
        return false;
    }
    if (!callback_.is_null())
        std::move(callback_).Run(std::move(p_error), std::move(p_registration));
    return true;
}

void BackgroundFetchService_GetRegistration_ProxyToResponder::Run(BackgroundFetchError in_error, BackgroundFetchRegistrationPtr in_registration)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send reply blink::mojom::BackgroundFetchService::GetRegistration", "async_response_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("error"), in_error, "<value of type BackgroundFetchError>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("registration"), in_registration, "<value of type BackgroundFetchRegistrationPtr>");
    });
#endif

    const uint32_t kFlags = mojo::Message::kFlagIsResponse | ((is_sync_) ? mojo::Message::kFlagIsSync : 0) | ((true) ? 0 : mojo::Message::kFlagNoInterrupt)
        | ((false) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::BackgroundFetchService::kGetRegistration), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::BackgroundFetchService_GetRegistration_ResponseParams_Data> params(message);
    params.Allocate();
    mojo::internal::Serialize<::blink::mojom::BackgroundFetchError>(in_error, &params->error);
    mojo::internal::MessageFragment<typename decltype(params->registration)::BaseType> registration_fragment(params.message());
    mojo::internal::Serialize<::blink::mojom::BackgroundFetchRegistrationDataView>(in_registration, registration_fragment);
    params->registration.Set(registration_fragment.is_null() ? nullptr : registration_fragment.data());

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(BackgroundFetchService::Name_);
    message.set_method_name("GetRegistration");
#endif

    message.set_request_id(request_id_);
    message.set_trace_nonce(trace_nonce_);
    ::mojo::internal::SendMojoMessage(*responder_, message);
    // SendMojoMessage() fails silently if the responder connection is closed,
    // or if the message is malformed.
    //
    // TODO(darin): If Accept() returns false due to a malformed message, that
    // may be good reason to close the connection. However, we don't have a
    // way to do that from here. We should add a way.
    responder_ = nullptr;
}
class BackgroundFetchService_GetDeveloperIds_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
public:
    static BackgroundFetchService::GetDeveloperIdsCallback CreateCallback(::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
    {
        std::unique_ptr<BackgroundFetchService_GetDeveloperIds_ProxyToResponder> proxy(
            new BackgroundFetchService_GetDeveloperIds_ProxyToResponder(message, std::move(responder)));
        return base::BindOnce(&BackgroundFetchService_GetDeveloperIds_ProxyToResponder::Run, std::move(proxy));
    }

    ~BackgroundFetchService_GetDeveloperIds_ProxyToResponder()
    {
#if DCHECK_IS_ON()
        if (responder_) {
            // If we're being destroyed without being run, we want to ensure the
            // binding endpoint has been closed. This checks for that asynchronously.
            // We pass a bound generated callback to handle the response so that any
            // resulting DCHECK stack will have useful interface type information.
            // Instantiate a ScopedFizzleBlockShutdownTasks to allow this request to
            // fizzle if this happens after shutdown and the endpoint is bound to a
            // BLOCK_SHUTDOWN sequence.
            base::ThreadPoolInstance::ScopedFizzleBlockShutdownTasks fizzler;
            responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
        }
#endif
    }

private:
    BackgroundFetchService_GetDeveloperIds_ProxyToResponder(::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
        : ::mojo::internal::ProxyToResponder(message, std::move(responder))
    {
    }

#if DCHECK_IS_ON()
    static void OnIsConnectedComplete(bool connected)
    {
        DCHECK(!connected) << "BackgroundFetchService::GetDeveloperIdsCallback was destroyed without "
                           << "first either being run or its corresponding binding being closed. "
                           << "It is an error to drop response callbacks which still correspond "
                           << "to an open interface pipe.";
    }
#endif

    void Run(BackgroundFetchError in_error, const std::vector<std::string>& in_developer_ids);
};

bool BackgroundFetchService_GetDeveloperIds_ForwardToCallback::Accept(mojo::Message* message)
{
    DCHECK(message->is_serialized());
    internal::BackgroundFetchService_GetDeveloperIds_ResponseParams_Data* params
        = reinterpret_cast<internal::BackgroundFetchService_GetDeveloperIds_ResponseParams_Data*>(message->mutable_payload());

    // Validation for BackgroundFetchService.2
    bool success = true;
    BackgroundFetchError p_error {};
    std::vector<std::string> p_developer_ids {};
    BackgroundFetchService_GetDeveloperIds_ResponseParamsDataView input_data_view(params, message);

    if (success && !input_data_view.ReadError(&p_error))
        success = false;
    if (success && !input_data_view.ReadDeveloperIds(&p_developer_ids))
        success = false;
    if (!success) {
        ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, BackgroundFetchService::Name_, 2, true);
        return false;
    }
    if (!callback_.is_null())
        std::move(callback_).Run(std::move(p_error), std::move(p_developer_ids));
    return true;
}

void BackgroundFetchService_GetDeveloperIds_ProxyToResponder::Run(BackgroundFetchError in_error, const std::vector<std::string>& in_developer_ids)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send reply blink::mojom::BackgroundFetchService::GetDeveloperIds", "async_response_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("error"), in_error, "<value of type BackgroundFetchError>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("developer_ids"), in_developer_ids, "<value of type const std::vector<std::string>&>");
    });
#endif

    const uint32_t kFlags = mojo::Message::kFlagIsResponse | ((is_sync_) ? mojo::Message::kFlagIsSync : 0) | ((true) ? 0 : mojo::Message::kFlagNoInterrupt)
        | ((false) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::BackgroundFetchService::kGetDeveloperIds), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::BackgroundFetchService_GetDeveloperIds_ResponseParams_Data> params(message);
    params.Allocate();
    mojo::internal::Serialize<::blink::mojom::BackgroundFetchError>(in_error, &params->error);
    mojo::internal::MessageFragment<typename decltype(params->developer_ids)::BaseType> developer_ids_fragment(params.message());
    constexpr const mojo::internal::ContainerValidateParams& developer_ids_validate_params
        = mojo::internal::GetArrayValidator<0, false, &mojo::internal::GetArrayValidator<0, false, nullptr>()>();
    mojo::internal::Serialize<mojo::ArrayDataView<mojo::StringDataView>>(in_developer_ids, developer_ids_fragment, &developer_ids_validate_params);
    params->developer_ids.Set(developer_ids_fragment.is_null() ? nullptr : developer_ids_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->developer_ids.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null developer_ids in ");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(BackgroundFetchService::Name_);
    message.set_method_name("GetDeveloperIds");
#endif

    message.set_request_id(request_id_);
    message.set_trace_nonce(trace_nonce_);
    ::mojo::internal::SendMojoMessage(*responder_, message);
    // SendMojoMessage() fails silently if the responder connection is closed,
    // or if the message is malformed.
    //
    // TODO(darin): If Accept() returns false due to a malformed message, that
    // may be good reason to close the connection. However, we don't have a
    // way to do that from here. We should add a way.
    responder_ = nullptr;
}
class BackgroundFetchService_GetIconDisplaySize_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
public:
    static BackgroundFetchService::GetIconDisplaySizeCallback CreateCallback(
        ::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
    {
        std::unique_ptr<BackgroundFetchService_GetIconDisplaySize_ProxyToResponder> proxy(
            new BackgroundFetchService_GetIconDisplaySize_ProxyToResponder(message, std::move(responder)));
        return base::BindOnce(&BackgroundFetchService_GetIconDisplaySize_ProxyToResponder::Run, std::move(proxy));
    }

    ~BackgroundFetchService_GetIconDisplaySize_ProxyToResponder()
    {
#if DCHECK_IS_ON()
        if (responder_) {
            // If we're being destroyed without being run, we want to ensure the
            // binding endpoint has been closed. This checks for that asynchronously.
            // We pass a bound generated callback to handle the response so that any
            // resulting DCHECK stack will have useful interface type information.
            // Instantiate a ScopedFizzleBlockShutdownTasks to allow this request to
            // fizzle if this happens after shutdown and the endpoint is bound to a
            // BLOCK_SHUTDOWN sequence.
            base::ThreadPoolInstance::ScopedFizzleBlockShutdownTasks fizzler;
            responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
        }
#endif
    }

private:
    BackgroundFetchService_GetIconDisplaySize_ProxyToResponder(::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
        : ::mojo::internal::ProxyToResponder(message, std::move(responder))
    {
    }

#if DCHECK_IS_ON()
    static void OnIsConnectedComplete(bool connected)
    {
        DCHECK(!connected) << "BackgroundFetchService::GetIconDisplaySizeCallback was destroyed without "
                           << "first either being run or its corresponding binding being closed. "
                           << "It is an error to drop response callbacks which still correspond "
                           << "to an open interface pipe.";
    }
#endif

    void Run(const ::gfx::Size& in_icon_size_pixels);
};

bool BackgroundFetchService_GetIconDisplaySize_ForwardToCallback::Accept(mojo::Message* message)
{
    DCHECK(message->is_serialized());
    internal::BackgroundFetchService_GetIconDisplaySize_ResponseParams_Data* params
        = reinterpret_cast<internal::BackgroundFetchService_GetIconDisplaySize_ResponseParams_Data*>(message->mutable_payload());

    // Validation for BackgroundFetchService.3
    bool success = true;
    ::gfx::Size p_icon_size_pixels {};
    BackgroundFetchService_GetIconDisplaySize_ResponseParamsDataView input_data_view(params, message);

    if (success && !input_data_view.ReadIconSizePixels(&p_icon_size_pixels))
        success = false;
    if (!success) {
        ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, BackgroundFetchService::Name_, 3, true);
        return false;
    }
    if (!callback_.is_null())
        std::move(callback_).Run(std::move(p_icon_size_pixels));
    return true;
}

void BackgroundFetchService_GetIconDisplaySize_ProxyToResponder::Run(const ::gfx::Size& in_icon_size_pixels)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1(
        "mojom", "Send reply blink::mojom::BackgroundFetchService::GetIconDisplaySize", "async_response_parameters", [&](perfetto::TracedValue context) {
            auto dict = std::move(context).WriteDictionary();
            perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("icon_size_pixels"), in_icon_size_pixels, "<value of type const ::gfx::Size&>");
        });
#endif

    const uint32_t kFlags = mojo::Message::kFlagIsResponse | ((is_sync_) ? mojo::Message::kFlagIsSync : 0) | ((true) ? 0 : mojo::Message::kFlagNoInterrupt)
        | ((false) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::BackgroundFetchService::kGetIconDisplaySize), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::BackgroundFetchService_GetIconDisplaySize_ResponseParams_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->icon_size_pixels)::BaseType> icon_size_pixels_fragment(params.message());
    mojo::internal::Serialize<::gfx::mojom::SizeDataView>(in_icon_size_pixels, icon_size_pixels_fragment);
    params->icon_size_pixels.Set(icon_size_pixels_fragment.is_null() ? nullptr : icon_size_pixels_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->icon_size_pixels.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null icon_size_pixels in ");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(BackgroundFetchService::Name_);
    message.set_method_name("GetIconDisplaySize");
#endif

    message.set_request_id(request_id_);
    message.set_trace_nonce(trace_nonce_);
    ::mojo::internal::SendMojoMessage(*responder_, message);
    // SendMojoMessage() fails silently if the responder connection is closed,
    // or if the message is malformed.
    //
    // TODO(darin): If Accept() returns false due to a malformed message, that
    // may be good reason to close the connection. However, we don't have a
    // way to do that from here. We should add a way.
    responder_ = nullptr;
}

// static
bool BackgroundFetchServiceStubDispatch::Accept(BackgroundFetchService* impl, mojo::Message* message)
{
    switch (static_cast<messages::BackgroundFetchService>(message->header()->name)) {
    case messages::BackgroundFetchService::kFetch: {
        break;
    }
    case messages::BackgroundFetchService::kGetRegistration: {
        break;
    }
    case messages::BackgroundFetchService::kGetDeveloperIds: {
        break;
    }
    case messages::BackgroundFetchService::kGetIconDisplaySize: {
        break;
    }
    }
    return false;
}

// static
bool BackgroundFetchServiceStubDispatch::AcceptWithResponder(
    BackgroundFetchService* impl, mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
{
    [[maybe_unused]] const bool message_is_sync = message->has_flag(mojo::Message::kFlagIsSync);
    [[maybe_unused]] const uint64_t request_id = message->request_id();
    switch (static_cast<messages::BackgroundFetchService>(message->header()->name)) {
    case messages::BackgroundFetchService::kFetch: {
        internal::BackgroundFetchService_Fetch_Params_Data* params
            = reinterpret_cast<internal::BackgroundFetchService_Fetch_Params_Data*>(message->mutable_payload());

        // Validation for BackgroundFetchService.0
        bool success = true;
        int64_t p_service_worker_registration_id {};
        std::string p_developer_id {};
        std::vector<::blink::mojom::FetchAPIRequestPtr> p_requests {};
        BackgroundFetchOptionsPtr p_options {};
        ::SkBitmap p_icon {};
        BackgroundFetchUkmDataPtr p_ukm_data {};
        BackgroundFetchService_Fetch_ParamsDataView input_data_view(params, message);

        if (success)
            p_service_worker_registration_id = input_data_view.service_worker_registration_id();
        if (success && !input_data_view.ReadDeveloperId(&p_developer_id))
            success = false;
        if (success && !input_data_view.ReadRequests(&p_requests))
            success = false;
        if (success && !input_data_view.ReadOptions(&p_options))
            success = false;
        if (success && !input_data_view.ReadIcon(&p_icon))
            success = false;
        if (success && !input_data_view.ReadUkmData(&p_ukm_data))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, BackgroundFetchService::Name_, 0, false);
            return false;
        }
        BackgroundFetchService::FetchCallback callback = BackgroundFetchService_Fetch_ProxyToResponder::CreateCallback(*message, std::move(responder));
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->Fetch(std::move(p_service_worker_registration_id), std::move(p_developer_id), std::move(p_requests), std::move(p_options), std::move(p_icon),
            std::move(p_ukm_data), std::move(callback));
        return true;
    }
    case messages::BackgroundFetchService::kGetRegistration: {
        internal::BackgroundFetchService_GetRegistration_Params_Data* params
            = reinterpret_cast<internal::BackgroundFetchService_GetRegistration_Params_Data*>(message->mutable_payload());

        // Validation for BackgroundFetchService.1
        bool success = true;
        int64_t p_service_worker_registration_id {};
        std::string p_developer_id {};
        BackgroundFetchService_GetRegistration_ParamsDataView input_data_view(params, message);

        if (success)
            p_service_worker_registration_id = input_data_view.service_worker_registration_id();
        if (success && !input_data_view.ReadDeveloperId(&p_developer_id))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, BackgroundFetchService::Name_, 1, false);
            return false;
        }
        BackgroundFetchService::GetRegistrationCallback callback
            = BackgroundFetchService_GetRegistration_ProxyToResponder::CreateCallback(*message, std::move(responder));
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->GetRegistration(std::move(p_service_worker_registration_id), std::move(p_developer_id), std::move(callback));
        return true;
    }
    case messages::BackgroundFetchService::kGetDeveloperIds: {
        internal::BackgroundFetchService_GetDeveloperIds_Params_Data* params
            = reinterpret_cast<internal::BackgroundFetchService_GetDeveloperIds_Params_Data*>(message->mutable_payload());

        // Validation for BackgroundFetchService.2
        bool success = true;
        int64_t p_service_worker_registration_id {};
        BackgroundFetchService_GetDeveloperIds_ParamsDataView input_data_view(params, message);

        if (success)
            p_service_worker_registration_id = input_data_view.service_worker_registration_id();
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, BackgroundFetchService::Name_, 2, false);
            return false;
        }
        BackgroundFetchService::GetDeveloperIdsCallback callback
            = BackgroundFetchService_GetDeveloperIds_ProxyToResponder::CreateCallback(*message, std::move(responder));
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->GetDeveloperIds(std::move(p_service_worker_registration_id), std::move(callback));
        return true;
    }
    case messages::BackgroundFetchService::kGetIconDisplaySize: {
        internal::BackgroundFetchService_GetIconDisplaySize_Params_Data* params
            = reinterpret_cast<internal::BackgroundFetchService_GetIconDisplaySize_Params_Data*>(message->mutable_payload());

        // Validation for BackgroundFetchService.3
        bool success = true;
        BackgroundFetchService_GetIconDisplaySize_ParamsDataView input_data_view(params, message);

        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, BackgroundFetchService::Name_, 3, false);
            return false;
        }
        BackgroundFetchService::GetIconDisplaySizeCallback callback
            = BackgroundFetchService_GetIconDisplaySize_ProxyToResponder::CreateCallback(*message, std::move(responder));
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->GetIconDisplaySize(std::move(callback));
        return true;
    }
    }
    return false;
}
namespace {
} // namespace
static const mojo::internal::GenericValidationInfo kBackgroundFetchServiceValidationInfo[] = {
    { &internal::BackgroundFetchService_Fetch_Params_Data::Validate, &internal::BackgroundFetchService_Fetch_ResponseParams_Data::Validate },
    { &internal::BackgroundFetchService_GetRegistration_Params_Data::Validate,
        &internal::BackgroundFetchService_GetRegistration_ResponseParams_Data::Validate },
    { &internal::BackgroundFetchService_GetDeveloperIds_Params_Data::Validate,
        &internal::BackgroundFetchService_GetDeveloperIds_ResponseParams_Data::Validate },
    { &internal::BackgroundFetchService_GetIconDisplaySize_Params_Data::Validate,
        &internal::BackgroundFetchService_GetIconDisplaySize_ResponseParams_Data::Validate },
};

bool BackgroundFetchServiceRequestValidator::Accept(mojo::Message* message)
{
    const char* name = ::blink::mojom::BackgroundFetchService::Name_;
    return mojo::internal::ValidateRequestGenericPacked(message, name, kBackgroundFetchServiceValidationInfo);
}

bool BackgroundFetchServiceResponseValidator::Accept(mojo::Message* message)
{
    const char* name = ::blink::mojom::BackgroundFetchService::Name_;
    return mojo::internal::ValidateResponseGenericPacked(message, name, kBackgroundFetchServiceValidationInfo);
}
const char BackgroundFetchRegistrationService::Name_[] = "blink.mojom.BackgroundFetchRegistrationService";

BackgroundFetchRegistrationService::IPCStableHashFunction BackgroundFetchRegistrationService::MessageToMethodInfo_(mojo::Message& message)
{
#if !BUILDFLAG(IS_FUCHSIA)
    switch (static_cast<messages::BackgroundFetchRegistrationService>(message.name())) {
    case messages::BackgroundFetchRegistrationService::kUpdateUI: {
        return &BackgroundFetchRegistrationService::UpdateUI_Sym::IPCStableHash;
    }
    case messages::BackgroundFetchRegistrationService::kAbort: {
        return &BackgroundFetchRegistrationService::Abort_Sym::IPCStableHash;
    }
    case messages::BackgroundFetchRegistrationService::kMatchRequests: {
        return &BackgroundFetchRegistrationService::MatchRequests_Sym::IPCStableHash;
    }
    case messages::BackgroundFetchRegistrationService::kAddRegistrationObserver: {
        return &BackgroundFetchRegistrationService::AddRegistrationObserver_Sym::IPCStableHash;
    }
    }
#endif // !BUILDFLAG(IS_FUCHSIA)
    return nullptr;
}

const char* BackgroundFetchRegistrationService::MessageToMethodName_(mojo::Message& message)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
    if (!is_response) {
        switch (static_cast<messages::BackgroundFetchRegistrationService>(message.name())) {
        case messages::BackgroundFetchRegistrationService::kUpdateUI:
            return "Receive blink::mojom::BackgroundFetchRegistrationService::UpdateUI";
        case messages::BackgroundFetchRegistrationService::kAbort:
            return "Receive blink::mojom::BackgroundFetchRegistrationService::Abort";
        case messages::BackgroundFetchRegistrationService::kMatchRequests:
            return "Receive blink::mojom::BackgroundFetchRegistrationService::MatchRequests";
        case messages::BackgroundFetchRegistrationService::kAddRegistrationObserver:
            return "Receive blink::mojom::BackgroundFetchRegistrationService::AddRegistrationObserver";
        }
    } else {
        switch (static_cast<messages::BackgroundFetchRegistrationService>(message.name())) {
        case messages::BackgroundFetchRegistrationService::kUpdateUI:
            return "Receive reply blink::mojom::BackgroundFetchRegistrationService::UpdateUI";
        case messages::BackgroundFetchRegistrationService::kAbort:
            return "Receive reply blink::mojom::BackgroundFetchRegistrationService::Abort";
        case messages::BackgroundFetchRegistrationService::kMatchRequests:
            return "Receive reply blink::mojom::BackgroundFetchRegistrationService::MatchRequests";
        case messages::BackgroundFetchRegistrationService::kAddRegistrationObserver:
            return "Receive reply blink::mojom::BackgroundFetchRegistrationService::AddRegistrationObserver";
        }
    }
    return "Receive unknown mojo message";
#else
    bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
    if (is_response) {
        return "Receive mojo reply";
    } else {
        return "Receive mojo message";
    }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t BackgroundFetchRegistrationService::UpdateUI_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::BackgroundFetchRegistrationService::UpdateUI");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t BackgroundFetchRegistrationService::Abort_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::BackgroundFetchRegistrationService::Abort");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t BackgroundFetchRegistrationService::MatchRequests_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::BackgroundFetchRegistrationService::MatchRequests");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t BackgroundFetchRegistrationService::AddRegistrationObserver_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)blink::mojom::BackgroundFetchRegistrationService::AddRegistrationObserver");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
#endif // !BUILDFLAG(IS_FUCHSIA)

class BackgroundFetchRegistrationService_UpdateUI_ForwardToCallback : public mojo::MessageReceiver {
public:
    BackgroundFetchRegistrationService_UpdateUI_ForwardToCallback(BackgroundFetchRegistrationService::UpdateUICallback callback)
        : callback_(std::move(callback))
    {
    }

    BackgroundFetchRegistrationService_UpdateUI_ForwardToCallback(const BackgroundFetchRegistrationService_UpdateUI_ForwardToCallback&) = delete;
    BackgroundFetchRegistrationService_UpdateUI_ForwardToCallback& operator=(const BackgroundFetchRegistrationService_UpdateUI_ForwardToCallback&) = delete;

    bool Accept(mojo::Message* message) override;

private:
    BackgroundFetchRegistrationService::UpdateUICallback callback_;
};

class BackgroundFetchRegistrationService_Abort_ForwardToCallback : public mojo::MessageReceiver {
public:
    BackgroundFetchRegistrationService_Abort_ForwardToCallback(BackgroundFetchRegistrationService::AbortCallback callback)
        : callback_(std::move(callback))
    {
    }

    BackgroundFetchRegistrationService_Abort_ForwardToCallback(const BackgroundFetchRegistrationService_Abort_ForwardToCallback&) = delete;
    BackgroundFetchRegistrationService_Abort_ForwardToCallback& operator=(const BackgroundFetchRegistrationService_Abort_ForwardToCallback&) = delete;

    bool Accept(mojo::Message* message) override;

private:
    BackgroundFetchRegistrationService::AbortCallback callback_;
};

class BackgroundFetchRegistrationService_MatchRequests_ForwardToCallback : public mojo::MessageReceiver {
public:
    BackgroundFetchRegistrationService_MatchRequests_ForwardToCallback(BackgroundFetchRegistrationService::MatchRequestsCallback callback)
        : callback_(std::move(callback))
    {
    }

    BackgroundFetchRegistrationService_MatchRequests_ForwardToCallback(const BackgroundFetchRegistrationService_MatchRequests_ForwardToCallback&) = delete;
    BackgroundFetchRegistrationService_MatchRequests_ForwardToCallback& operator=(const BackgroundFetchRegistrationService_MatchRequests_ForwardToCallback&)
        = delete;

    bool Accept(mojo::Message* message) override;

private:
    BackgroundFetchRegistrationService::MatchRequestsCallback callback_;
};

BackgroundFetchRegistrationServiceProxy::BackgroundFetchRegistrationServiceProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver)
{
}

void BackgroundFetchRegistrationServiceProxy::UpdateUI(const std::optional<std::string>& in_title, const ::SkBitmap& in_icon, UpdateUICallback callback)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::BackgroundFetchRegistrationService::UpdateUI", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("title"), in_title, "<value of type const std::optional<std::string>&>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("icon"), in_icon, "<value of type const ::SkBitmap&>");
    });
#endif

    const bool kExpectsResponse = true;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::BackgroundFetchRegistrationService::kUpdateUI), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::BackgroundFetchRegistrationService_UpdateUI_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->title)::BaseType> title_fragment(params.message());
    mojo::internal::Serialize<mojo::StringDataView>(in_title, title_fragment);
    params->title.Set(title_fragment.is_null() ? nullptr : title_fragment.data());
    mojo::internal::MessageFragment<typename decltype(params->icon)::BaseType> icon_fragment(params.message());
    mojo::internal::Serialize<::skia::mojom::BitmapN32DataView>(in_icon, icon_fragment);
    params->icon.Set(icon_fragment.is_null() ? nullptr : icon_fragment.data());

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(BackgroundFetchRegistrationService::Name_);
    message.set_method_name("UpdateUI");
#endif
    std::unique_ptr<mojo::MessageReceiver> responder(new BackgroundFetchRegistrationService_UpdateUI_ForwardToCallback(std::move(callback)));
    ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void BackgroundFetchRegistrationServiceProxy::Abort(AbortCallback callback)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT0("mojom", "Send blink::mojom::BackgroundFetchRegistrationService::Abort");
#endif

    const bool kExpectsResponse = true;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::BackgroundFetchRegistrationService::kAbort), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::BackgroundFetchRegistrationService_Abort_Params_Data> params(message);
    params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(BackgroundFetchRegistrationService::Name_);
    message.set_method_name("Abort");
#endif
    std::unique_ptr<mojo::MessageReceiver> responder(new BackgroundFetchRegistrationService_Abort_ForwardToCallback(std::move(callback)));
    ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void BackgroundFetchRegistrationServiceProxy::MatchRequests(::blink::mojom::FetchAPIRequestPtr in_request_to_match,
    ::blink::mojom::CacheQueryOptionsPtr in_cache_query_options, bool in_match_all, MatchRequestsCallback callback)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send blink::mojom::BackgroundFetchRegistrationService::MatchRequests", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("request_to_match"), in_request_to_match, "<value of type ::blink::mojom::FetchAPIRequestPtr>");
        perfetto::WriteIntoTracedValueWithFallback(
            dict.AddItem("cache_query_options"), in_cache_query_options, "<value of type ::blink::mojom::CacheQueryOptionsPtr>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("match_all"), in_match_all, "<value of type bool>");
    });
#endif

    const bool kExpectsResponse = true;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::BackgroundFetchRegistrationService::kMatchRequests), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::BackgroundFetchRegistrationService_MatchRequests_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->request_to_match)::BaseType> request_to_match_fragment(params.message());
    mojo::internal::Serialize<::blink::mojom::FetchAPIRequestDataView>(in_request_to_match, request_to_match_fragment);
    params->request_to_match.Set(request_to_match_fragment.is_null() ? nullptr : request_to_match_fragment.data());
    mojo::internal::MessageFragment<typename decltype(params->cache_query_options)::BaseType> cache_query_options_fragment(params.message());
    mojo::internal::Serialize<::blink::mojom::CacheQueryOptionsDataView>(in_cache_query_options, cache_query_options_fragment);
    params->cache_query_options.Set(cache_query_options_fragment.is_null() ? nullptr : cache_query_options_fragment.data());
    params->match_all = in_match_all;

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(BackgroundFetchRegistrationService::Name_);
    message.set_method_name("MatchRequests");
#endif
    std::unique_ptr<mojo::MessageReceiver> responder(new BackgroundFetchRegistrationService_MatchRequests_ForwardToCallback(std::move(callback)));
    ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void BackgroundFetchRegistrationServiceProxy::AddRegistrationObserver(::mojo::PendingRemote<BackgroundFetchRegistrationObserver> in_observer)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1(
        "mojom", "Send blink::mojom::BackgroundFetchRegistrationService::AddRegistrationObserver", "input_parameters", [&](perfetto::TracedValue context) {
            auto dict = std::move(context).WriteDictionary();
            perfetto::WriteIntoTracedValueWithFallback(
                dict.AddItem("observer"), in_observer, "<value of type ::mojo::PendingRemote<BackgroundFetchRegistrationObserver>>");
        });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::BackgroundFetchRegistrationService::kAddRegistrationObserver), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::BackgroundFetchRegistrationService_AddRegistrationObserver_Params_Data> params(message);
    params.Allocate();
    mojo::internal::Serialize<mojo::InterfacePtrDataView<::blink::mojom::BackgroundFetchRegistrationObserverInterfaceBase>>(
        in_observer, &params->observer, &params.message());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(!mojo::internal::IsHandleOrInterfaceValid(params->observer),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE, "invalid observer in BackgroundFetchRegistrationService.AddRegistrationObserver request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(BackgroundFetchRegistrationService::Name_);
    message.set_method_name("AddRegistrationObserver");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}
class BackgroundFetchRegistrationService_UpdateUI_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
public:
    static BackgroundFetchRegistrationService::UpdateUICallback CreateCallback(
        ::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
    {
        std::unique_ptr<BackgroundFetchRegistrationService_UpdateUI_ProxyToResponder> proxy(
            new BackgroundFetchRegistrationService_UpdateUI_ProxyToResponder(message, std::move(responder)));
        return base::BindOnce(&BackgroundFetchRegistrationService_UpdateUI_ProxyToResponder::Run, std::move(proxy));
    }

    ~BackgroundFetchRegistrationService_UpdateUI_ProxyToResponder()
    {
#if DCHECK_IS_ON()
        if (responder_) {
            // If we're being destroyed without being run, we want to ensure the
            // binding endpoint has been closed. This checks for that asynchronously.
            // We pass a bound generated callback to handle the response so that any
            // resulting DCHECK stack will have useful interface type information.
            // Instantiate a ScopedFizzleBlockShutdownTasks to allow this request to
            // fizzle if this happens after shutdown and the endpoint is bound to a
            // BLOCK_SHUTDOWN sequence.
            base::ThreadPoolInstance::ScopedFizzleBlockShutdownTasks fizzler;
            responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
        }
#endif
    }

private:
    BackgroundFetchRegistrationService_UpdateUI_ProxyToResponder(::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
        : ::mojo::internal::ProxyToResponder(message, std::move(responder))
    {
    }

#if DCHECK_IS_ON()
    static void OnIsConnectedComplete(bool connected)
    {
        DCHECK(!connected) << "BackgroundFetchRegistrationService::UpdateUICallback was destroyed without "
                           << "first either being run or its corresponding binding being closed. "
                           << "It is an error to drop response callbacks which still correspond "
                           << "to an open interface pipe.";
    }
#endif

    void Run(BackgroundFetchError in_error);
};

bool BackgroundFetchRegistrationService_UpdateUI_ForwardToCallback::Accept(mojo::Message* message)
{
    DCHECK(message->is_serialized());
    internal::BackgroundFetchRegistrationService_UpdateUI_ResponseParams_Data* params
        = reinterpret_cast<internal::BackgroundFetchRegistrationService_UpdateUI_ResponseParams_Data*>(message->mutable_payload());

    // Validation for BackgroundFetchRegistrationService.0
    bool success = true;
    BackgroundFetchError p_error {};
    BackgroundFetchRegistrationService_UpdateUI_ResponseParamsDataView input_data_view(params, message);

    if (success && !input_data_view.ReadError(&p_error))
        success = false;
    if (!success) {
        ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, BackgroundFetchRegistrationService::Name_, 0, true);
        return false;
    }
    if (!callback_.is_null())
        std::move(callback_).Run(std::move(p_error));
    return true;
}

void BackgroundFetchRegistrationService_UpdateUI_ProxyToResponder::Run(BackgroundFetchError in_error)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1(
        "mojom", "Send reply blink::mojom::BackgroundFetchRegistrationService::UpdateUI", "async_response_parameters", [&](perfetto::TracedValue context) {
            auto dict = std::move(context).WriteDictionary();
            perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("error"), in_error, "<value of type BackgroundFetchError>");
        });
#endif

    const uint32_t kFlags = mojo::Message::kFlagIsResponse | ((is_sync_) ? mojo::Message::kFlagIsSync : 0) | ((true) ? 0 : mojo::Message::kFlagNoInterrupt)
        | ((false) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::BackgroundFetchRegistrationService::kUpdateUI), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::BackgroundFetchRegistrationService_UpdateUI_ResponseParams_Data> params(message);
    params.Allocate();
    mojo::internal::Serialize<::blink::mojom::BackgroundFetchError>(in_error, &params->error);

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(BackgroundFetchRegistrationService::Name_);
    message.set_method_name("UpdateUI");
#endif

    message.set_request_id(request_id_);
    message.set_trace_nonce(trace_nonce_);
    ::mojo::internal::SendMojoMessage(*responder_, message);
    // SendMojoMessage() fails silently if the responder connection is closed,
    // or if the message is malformed.
    //
    // TODO(darin): If Accept() returns false due to a malformed message, that
    // may be good reason to close the connection. However, we don't have a
    // way to do that from here. We should add a way.
    responder_ = nullptr;
}
class BackgroundFetchRegistrationService_Abort_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
public:
    static BackgroundFetchRegistrationService::AbortCallback CreateCallback(
        ::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
    {
        std::unique_ptr<BackgroundFetchRegistrationService_Abort_ProxyToResponder> proxy(
            new BackgroundFetchRegistrationService_Abort_ProxyToResponder(message, std::move(responder)));
        return base::BindOnce(&BackgroundFetchRegistrationService_Abort_ProxyToResponder::Run, std::move(proxy));
    }

    ~BackgroundFetchRegistrationService_Abort_ProxyToResponder()
    {
#if DCHECK_IS_ON()
        if (responder_) {
            // If we're being destroyed without being run, we want to ensure the
            // binding endpoint has been closed. This checks for that asynchronously.
            // We pass a bound generated callback to handle the response so that any
            // resulting DCHECK stack will have useful interface type information.
            // Instantiate a ScopedFizzleBlockShutdownTasks to allow this request to
            // fizzle if this happens after shutdown and the endpoint is bound to a
            // BLOCK_SHUTDOWN sequence.
            base::ThreadPoolInstance::ScopedFizzleBlockShutdownTasks fizzler;
            responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
        }
#endif
    }

private:
    BackgroundFetchRegistrationService_Abort_ProxyToResponder(::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
        : ::mojo::internal::ProxyToResponder(message, std::move(responder))
    {
    }

#if DCHECK_IS_ON()
    static void OnIsConnectedComplete(bool connected)
    {
        DCHECK(!connected) << "BackgroundFetchRegistrationService::AbortCallback was destroyed without "
                           << "first either being run or its corresponding binding being closed. "
                           << "It is an error to drop response callbacks which still correspond "
                           << "to an open interface pipe.";
    }
#endif

    void Run(BackgroundFetchError in_error);
};

bool BackgroundFetchRegistrationService_Abort_ForwardToCallback::Accept(mojo::Message* message)
{
    DCHECK(message->is_serialized());
    internal::BackgroundFetchRegistrationService_Abort_ResponseParams_Data* params
        = reinterpret_cast<internal::BackgroundFetchRegistrationService_Abort_ResponseParams_Data*>(message->mutable_payload());

    // Validation for BackgroundFetchRegistrationService.1
    bool success = true;
    BackgroundFetchError p_error {};
    BackgroundFetchRegistrationService_Abort_ResponseParamsDataView input_data_view(params, message);

    if (success && !input_data_view.ReadError(&p_error))
        success = false;
    if (!success) {
        ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, BackgroundFetchRegistrationService::Name_, 1, true);
        return false;
    }
    if (!callback_.is_null())
        std::move(callback_).Run(std::move(p_error));
    return true;
}

void BackgroundFetchRegistrationService_Abort_ProxyToResponder::Run(BackgroundFetchError in_error)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1(
        "mojom", "Send reply blink::mojom::BackgroundFetchRegistrationService::Abort", "async_response_parameters", [&](perfetto::TracedValue context) {
            auto dict = std::move(context).WriteDictionary();
            perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("error"), in_error, "<value of type BackgroundFetchError>");
        });
#endif

    const uint32_t kFlags = mojo::Message::kFlagIsResponse | ((is_sync_) ? mojo::Message::kFlagIsSync : 0) | ((true) ? 0 : mojo::Message::kFlagNoInterrupt)
        | ((false) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::BackgroundFetchRegistrationService::kAbort), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::BackgroundFetchRegistrationService_Abort_ResponseParams_Data> params(message);
    params.Allocate();
    mojo::internal::Serialize<::blink::mojom::BackgroundFetchError>(in_error, &params->error);

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(BackgroundFetchRegistrationService::Name_);
    message.set_method_name("Abort");
#endif

    message.set_request_id(request_id_);
    message.set_trace_nonce(trace_nonce_);
    ::mojo::internal::SendMojoMessage(*responder_, message);
    // SendMojoMessage() fails silently if the responder connection is closed,
    // or if the message is malformed.
    //
    // TODO(darin): If Accept() returns false due to a malformed message, that
    // may be good reason to close the connection. However, we don't have a
    // way to do that from here. We should add a way.
    responder_ = nullptr;
}
class BackgroundFetchRegistrationService_MatchRequests_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
public:
    static BackgroundFetchRegistrationService::MatchRequestsCallback CreateCallback(
        ::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
    {
        std::unique_ptr<BackgroundFetchRegistrationService_MatchRequests_ProxyToResponder> proxy(
            new BackgroundFetchRegistrationService_MatchRequests_ProxyToResponder(message, std::move(responder)));
        return base::BindOnce(&BackgroundFetchRegistrationService_MatchRequests_ProxyToResponder::Run, std::move(proxy));
    }

    ~BackgroundFetchRegistrationService_MatchRequests_ProxyToResponder()
    {
#if DCHECK_IS_ON()
        if (responder_) {
            // If we're being destroyed without being run, we want to ensure the
            // binding endpoint has been closed. This checks for that asynchronously.
            // We pass a bound generated callback to handle the response so that any
            // resulting DCHECK stack will have useful interface type information.
            // Instantiate a ScopedFizzleBlockShutdownTasks to allow this request to
            // fizzle if this happens after shutdown and the endpoint is bound to a
            // BLOCK_SHUTDOWN sequence.
            base::ThreadPoolInstance::ScopedFizzleBlockShutdownTasks fizzler;
            responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
        }
#endif
    }

private:
    BackgroundFetchRegistrationService_MatchRequests_ProxyToResponder(::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
        : ::mojo::internal::ProxyToResponder(message, std::move(responder))
    {
    }

#if DCHECK_IS_ON()
    static void OnIsConnectedComplete(bool connected)
    {
        DCHECK(!connected) << "BackgroundFetchRegistrationService::MatchRequestsCallback was destroyed without "
                           << "first either being run or its corresponding binding being closed. "
                           << "It is an error to drop response callbacks which still correspond "
                           << "to an open interface pipe.";
    }
#endif

    void Run(std::vector<BackgroundFetchSettledFetchPtr> in_fetches);
};

bool BackgroundFetchRegistrationService_MatchRequests_ForwardToCallback::Accept(mojo::Message* message)
{
    DCHECK(message->is_serialized());
    internal::BackgroundFetchRegistrationService_MatchRequests_ResponseParams_Data* params
        = reinterpret_cast<internal::BackgroundFetchRegistrationService_MatchRequests_ResponseParams_Data*>(message->mutable_payload());

    // Validation for BackgroundFetchRegistrationService.2
    bool success = true;
    std::vector<BackgroundFetchSettledFetchPtr> p_fetches {};
    BackgroundFetchRegistrationService_MatchRequests_ResponseParamsDataView input_data_view(params, message);

    if (success && !input_data_view.ReadFetches(&p_fetches))
        success = false;
    if (!success) {
        ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, BackgroundFetchRegistrationService::Name_, 2, true);
        return false;
    }
    if (!callback_.is_null())
        std::move(callback_).Run(std::move(p_fetches));
    return true;
}

void BackgroundFetchRegistrationService_MatchRequests_ProxyToResponder::Run(std::vector<BackgroundFetchSettledFetchPtr> in_fetches)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1(
        "mojom", "Send reply blink::mojom::BackgroundFetchRegistrationService::MatchRequests", "async_response_parameters", [&](perfetto::TracedValue context) {
            auto dict = std::move(context).WriteDictionary();
            perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("fetches"), in_fetches, "<value of type std::vector<BackgroundFetchSettledFetchPtr>>");
        });
#endif

    const uint32_t kFlags = mojo::Message::kFlagIsResponse | ((is_sync_) ? mojo::Message::kFlagIsSync : 0) | ((true) ? 0 : mojo::Message::kFlagNoInterrupt)
        | ((false) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::BackgroundFetchRegistrationService::kMatchRequests), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::blink::mojom::internal::BackgroundFetchRegistrationService_MatchRequests_ResponseParams_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->fetches)::BaseType> fetches_fragment(params.message());
    constexpr const mojo::internal::ContainerValidateParams& fetches_validate_params = mojo::internal::GetArrayValidator<0, false, nullptr>();
    mojo::internal::Serialize<mojo::ArrayDataView<::blink::mojom::BackgroundFetchSettledFetchDataView>>(in_fetches, fetches_fragment, &fetches_validate_params);
    params->fetches.Set(fetches_fragment.is_null() ? nullptr : fetches_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->fetches.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null fetches in ");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(BackgroundFetchRegistrationService::Name_);
    message.set_method_name("MatchRequests");
#endif

    message.set_request_id(request_id_);
    message.set_trace_nonce(trace_nonce_);
    ::mojo::internal::SendMojoMessage(*responder_, message);
    // SendMojoMessage() fails silently if the responder connection is closed,
    // or if the message is malformed.
    //
    // TODO(darin): If Accept() returns false due to a malformed message, that
    // may be good reason to close the connection. However, we don't have a
    // way to do that from here. We should add a way.
    responder_ = nullptr;
}

// static
bool BackgroundFetchRegistrationServiceStubDispatch::Accept(BackgroundFetchRegistrationService* impl, mojo::Message* message)
{
    switch (static_cast<messages::BackgroundFetchRegistrationService>(message->header()->name)) {
    case messages::BackgroundFetchRegistrationService::kUpdateUI: {
        break;
    }
    case messages::BackgroundFetchRegistrationService::kAbort: {
        break;
    }
    case messages::BackgroundFetchRegistrationService::kMatchRequests: {
        break;
    }
    case messages::BackgroundFetchRegistrationService::kAddRegistrationObserver: {
        DCHECK(message->is_serialized());
        internal::BackgroundFetchRegistrationService_AddRegistrationObserver_Params_Data* params
            = reinterpret_cast<internal::BackgroundFetchRegistrationService_AddRegistrationObserver_Params_Data*>(message->mutable_payload());

        // Validation for BackgroundFetchRegistrationService.3
        bool success = true;
        ::mojo::PendingRemote<BackgroundFetchRegistrationObserver> p_observer {};
        BackgroundFetchRegistrationService_AddRegistrationObserver_ParamsDataView input_data_view(params, message);

        if (success) {
            p_observer = input_data_view.TakeObserver<decltype(p_observer)>();
        }
        if (!success) {
            ReportValidationErrorForMessage(
                message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, BackgroundFetchRegistrationService::Name_, 3, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->AddRegistrationObserver(std::move(p_observer));
        return true;
    }
    }
    return false;
}

// static
bool BackgroundFetchRegistrationServiceStubDispatch::AcceptWithResponder(
    BackgroundFetchRegistrationService* impl, mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
{
    [[maybe_unused]] const bool message_is_sync = message->has_flag(mojo::Message::kFlagIsSync);
    [[maybe_unused]] const uint64_t request_id = message->request_id();
    switch (static_cast<messages::BackgroundFetchRegistrationService>(message->header()->name)) {
    case messages::BackgroundFetchRegistrationService::kUpdateUI: {
        internal::BackgroundFetchRegistrationService_UpdateUI_Params_Data* params
            = reinterpret_cast<internal::BackgroundFetchRegistrationService_UpdateUI_Params_Data*>(message->mutable_payload());

        // Validation for BackgroundFetchRegistrationService.0
        bool success = true;
        std::optional<std::string> p_title {};
        ::SkBitmap p_icon {};
        BackgroundFetchRegistrationService_UpdateUI_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadTitle(&p_title))
            success = false;
        if (success && !input_data_view.ReadIcon(&p_icon))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(
                message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, BackgroundFetchRegistrationService::Name_, 0, false);
            return false;
        }
        BackgroundFetchRegistrationService::UpdateUICallback callback
            = BackgroundFetchRegistrationService_UpdateUI_ProxyToResponder::CreateCallback(*message, std::move(responder));
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->UpdateUI(std::move(p_title), std::move(p_icon), std::move(callback));
        return true;
    }
    case messages::BackgroundFetchRegistrationService::kAbort: {
        internal::BackgroundFetchRegistrationService_Abort_Params_Data* params
            = reinterpret_cast<internal::BackgroundFetchRegistrationService_Abort_Params_Data*>(message->mutable_payload());

        // Validation for BackgroundFetchRegistrationService.1
        bool success = true;
        BackgroundFetchRegistrationService_Abort_ParamsDataView input_data_view(params, message);

        if (!success) {
            ReportValidationErrorForMessage(
                message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, BackgroundFetchRegistrationService::Name_, 1, false);
            return false;
        }
        BackgroundFetchRegistrationService::AbortCallback callback
            = BackgroundFetchRegistrationService_Abort_ProxyToResponder::CreateCallback(*message, std::move(responder));
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->Abort(std::move(callback));
        return true;
    }
    case messages::BackgroundFetchRegistrationService::kMatchRequests: {
        internal::BackgroundFetchRegistrationService_MatchRequests_Params_Data* params
            = reinterpret_cast<internal::BackgroundFetchRegistrationService_MatchRequests_Params_Data*>(message->mutable_payload());

        // Validation for BackgroundFetchRegistrationService.2
        bool success = true;
        ::blink::mojom::FetchAPIRequestPtr p_request_to_match {};
        ::blink::mojom::CacheQueryOptionsPtr p_cache_query_options {};
        bool p_match_all {};
        BackgroundFetchRegistrationService_MatchRequests_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadRequestToMatch(&p_request_to_match))
            success = false;
        if (success && !input_data_view.ReadCacheQueryOptions(&p_cache_query_options))
            success = false;
        if (success)
            p_match_all = input_data_view.match_all();
        if (!success) {
            ReportValidationErrorForMessage(
                message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, BackgroundFetchRegistrationService::Name_, 2, false);
            return false;
        }
        BackgroundFetchRegistrationService::MatchRequestsCallback callback
            = BackgroundFetchRegistrationService_MatchRequests_ProxyToResponder::CreateCallback(*message, std::move(responder));
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->MatchRequests(std::move(p_request_to_match), std::move(p_cache_query_options), std::move(p_match_all), std::move(callback));
        return true;
    }
    case messages::BackgroundFetchRegistrationService::kAddRegistrationObserver: {
        break;
    }
    }
    return false;
}
namespace {
} // namespace
static const mojo::internal::GenericValidationInfo kBackgroundFetchRegistrationServiceValidationInfo[] = {
    { &internal::BackgroundFetchRegistrationService_UpdateUI_Params_Data::Validate,
        &internal::BackgroundFetchRegistrationService_UpdateUI_ResponseParams_Data::Validate },
    { &internal::BackgroundFetchRegistrationService_Abort_Params_Data::Validate,
        &internal::BackgroundFetchRegistrationService_Abort_ResponseParams_Data::Validate },
    { &internal::BackgroundFetchRegistrationService_MatchRequests_Params_Data::Validate,
        &internal::BackgroundFetchRegistrationService_MatchRequests_ResponseParams_Data::Validate },
    { &internal::BackgroundFetchRegistrationService_AddRegistrationObserver_Params_Data::Validate, nullptr /* no response */ },
};

bool BackgroundFetchRegistrationServiceRequestValidator::Accept(mojo::Message* message)
{
    const char* name = ::blink::mojom::BackgroundFetchRegistrationService::Name_;
    return mojo::internal::ValidateRequestGenericPacked(message, name, kBackgroundFetchRegistrationServiceValidationInfo);
}

bool BackgroundFetchRegistrationServiceResponseValidator::Accept(mojo::Message* message)
{
    const char* name = ::blink::mojom::BackgroundFetchRegistrationService::Name_;
    return mojo::internal::ValidateResponseGenericPacked(message, name, kBackgroundFetchRegistrationServiceValidationInfo);
}

} // blink::mojom

namespace mojo {

// static
bool StructTraits<::blink::mojom::BackgroundFetchSettledFetch::DataView, ::blink::mojom::BackgroundFetchSettledFetchPtr>::Read(
    ::blink::mojom::BackgroundFetchSettledFetch::DataView input, ::blink::mojom::BackgroundFetchSettledFetchPtr* output)
{
    bool success = true;
    ::blink::mojom::BackgroundFetchSettledFetchPtr result(::blink::mojom::BackgroundFetchSettledFetch::New());

    if (success && !input.ReadRequest(&result->request))
        success = false;
    if (success && !input.ReadResponse(&result->response))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::blink::mojom::BackgroundFetchOptions::DataView, ::blink::mojom::BackgroundFetchOptionsPtr>::Read(
    ::blink::mojom::BackgroundFetchOptions::DataView input, ::blink::mojom::BackgroundFetchOptionsPtr* output)
{
    bool success = true;
    ::blink::mojom::BackgroundFetchOptionsPtr result(::blink::mojom::BackgroundFetchOptions::New());

    if (success && !input.ReadIcons(&result->icons))
        success = false;
    if (success)
        result->download_total = input.download_total();
    if (success && !input.ReadTitle(&result->title))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::blink::mojom::BackgroundFetchRegistrationData::DataView, ::blink::mojom::BackgroundFetchRegistrationDataPtr>::Read(
    ::blink::mojom::BackgroundFetchRegistrationData::DataView input, ::blink::mojom::BackgroundFetchRegistrationDataPtr* output)
{
    bool success = true;
    ::blink::mojom::BackgroundFetchRegistrationDataPtr result(::blink::mojom::BackgroundFetchRegistrationData::New());

    if (success && !input.ReadDeveloperId(&result->developer_id))
        success = false;
    if (success)
        result->upload_total = input.upload_total();
    if (success)
        result->uploaded = input.uploaded();
    if (success)
        result->download_total = input.download_total();
    if (success)
        result->downloaded = input.downloaded();
    if (success && !input.ReadResult(&result->result))
        success = false;
    if (success && !input.ReadFailureReason(&result->failure_reason))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::blink::mojom::BackgroundFetchRegistration::DataView, ::blink::mojom::BackgroundFetchRegistrationPtr>::Read(
    ::blink::mojom::BackgroundFetchRegistration::DataView input, ::blink::mojom::BackgroundFetchRegistrationPtr* output)
{
    bool success = true;
    ::blink::mojom::BackgroundFetchRegistrationPtr result(::blink::mojom::BackgroundFetchRegistration::New());

    if (success && !input.ReadRegistrationData(&result->registration_data))
        success = false;
    if (success) {
        result->registration_interface = input.TakeRegistrationInterface<decltype(result->registration_interface)>();
    }
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::blink::mojom::BackgroundFetchUkmData::DataView, ::blink::mojom::BackgroundFetchUkmDataPtr>::Read(
    ::blink::mojom::BackgroundFetchUkmData::DataView input, ::blink::mojom::BackgroundFetchUkmDataPtr* output)
{
    bool success = true;
    ::blink::mojom::BackgroundFetchUkmDataPtr result(::blink::mojom::BackgroundFetchUkmData::New());

    if (success)
        result->ideal_to_chosen_icon_size = input.ideal_to_chosen_icon_size();
    *output = std::move(result);
    return success;
}

} // namespace mojo

// Symbols declared in the -test-utils.h header are defined here instead of a
// separate .cc file to save compile time.

namespace blink::mojom {

void BackgroundFetchRegistrationObserverInterceptorForTesting::OnProgress(uint64_t upload_total, uint64_t uploaded, uint64_t download_total,
    uint64_t downloaded, BackgroundFetchResult result, BackgroundFetchFailureReason failure_reason)
{
    GetForwardingInterface()->OnProgress(
        std::move(upload_total), std::move(uploaded), std::move(download_total), std::move(downloaded), std::move(result), std::move(failure_reason));
}
void BackgroundFetchRegistrationObserverInterceptorForTesting::OnRecordsUnavailable()
{
    GetForwardingInterface()->OnRecordsUnavailable();
}
void BackgroundFetchRegistrationObserverInterceptorForTesting::OnRequestCompleted(
    ::blink::mojom::FetchAPIRequestPtr request, ::blink::mojom::FetchAPIResponsePtr response)
{
    GetForwardingInterface()->OnRequestCompleted(std::move(request), std::move(response));
}
BackgroundFetchRegistrationObserverAsyncWaiter::BackgroundFetchRegistrationObserverAsyncWaiter(BackgroundFetchRegistrationObserver* proxy)
    : proxy_(proxy)
{
}

BackgroundFetchRegistrationObserverAsyncWaiter::~BackgroundFetchRegistrationObserverAsyncWaiter() = default;

void BackgroundFetchServiceInterceptorForTesting::Fetch(int64_t service_worker_registration_id, const std::string& developer_id,
    std::vector<::blink::mojom::FetchAPIRequestPtr> requests, BackgroundFetchOptionsPtr options, const ::SkBitmap& icon, BackgroundFetchUkmDataPtr ukm_data,
    FetchCallback callback)
{
    GetForwardingInterface()->Fetch(std::move(service_worker_registration_id), std::move(developer_id), std::move(requests), std::move(options),
        std::move(icon), std::move(ukm_data), std::move(callback));
}
void BackgroundFetchServiceInterceptorForTesting::GetRegistration(
    int64_t service_worker_registration_id, const std::string& developer_id, GetRegistrationCallback callback)
{
    GetForwardingInterface()->GetRegistration(std::move(service_worker_registration_id), std::move(developer_id), std::move(callback));
}
void BackgroundFetchServiceInterceptorForTesting::GetDeveloperIds(int64_t service_worker_registration_id, GetDeveloperIdsCallback callback)
{
    GetForwardingInterface()->GetDeveloperIds(std::move(service_worker_registration_id), std::move(callback));
}
void BackgroundFetchServiceInterceptorForTesting::GetIconDisplaySize(GetIconDisplaySizeCallback callback)
{
    GetForwardingInterface()->GetIconDisplaySize(std::move(callback));
}
BackgroundFetchServiceAsyncWaiter::BackgroundFetchServiceAsyncWaiter(BackgroundFetchService* proxy)
    : proxy_(proxy)
{
}

BackgroundFetchServiceAsyncWaiter::~BackgroundFetchServiceAsyncWaiter() = default;

void BackgroundFetchServiceAsyncWaiter::Fetch(int64_t service_worker_registration_id, const std::string& developer_id,
    std::vector<::blink::mojom::FetchAPIRequestPtr> requests, BackgroundFetchOptionsPtr options, const ::SkBitmap& icon, BackgroundFetchUkmDataPtr ukm_data,
    BackgroundFetchError* out_error, BackgroundFetchRegistrationPtr* out_registration)
{
    base::RunLoop loop;
    proxy_->Fetch(std::move(service_worker_registration_id), std::move(developer_id), std::move(requests), std::move(options), std::move(icon),
        std::move(ukm_data),
        base::BindOnce(
            [](base::RunLoop* loop, BackgroundFetchError* out_error, BackgroundFetchRegistrationPtr* out_registration, BackgroundFetchError error,
                BackgroundFetchRegistrationPtr registration) {
                *out_error = std::move(error);
                *out_registration = std::move(registration);
                loop->Quit();
            },
            &loop, out_error, out_registration));
    loop.Run();
}

void BackgroundFetchServiceAsyncWaiter::GetRegistration(
    int64_t service_worker_registration_id, const std::string& developer_id, BackgroundFetchError* out_error, BackgroundFetchRegistrationPtr* out_registration)
{
    base::RunLoop loop;
    proxy_->GetRegistration(std::move(service_worker_registration_id), std::move(developer_id),
        base::BindOnce(
            [](base::RunLoop* loop, BackgroundFetchError* out_error, BackgroundFetchRegistrationPtr* out_registration, BackgroundFetchError error,
                BackgroundFetchRegistrationPtr registration) {
                *out_error = std::move(error);
                *out_registration = std::move(registration);
                loop->Quit();
            },
            &loop, out_error, out_registration));
    loop.Run();
}

void BackgroundFetchServiceAsyncWaiter::GetDeveloperIds(
    int64_t service_worker_registration_id, BackgroundFetchError* out_error, std::vector<std::string>* out_developer_ids)
{
    base::RunLoop loop;
    proxy_->GetDeveloperIds(std::move(service_worker_registration_id),
        base::BindOnce(
            [](base::RunLoop* loop, BackgroundFetchError* out_error, std::vector<std::string>* out_developer_ids, BackgroundFetchError error,
                const std::vector<std::string>& developer_ids) {
                *out_error = std::move(error);
                *out_developer_ids = std::move(developer_ids);
                loop->Quit();
            },
            &loop, out_error, out_developer_ids));
    loop.Run();
}

void BackgroundFetchServiceAsyncWaiter::GetIconDisplaySize(::gfx::Size* out_icon_size_pixels)
{
    base::RunLoop loop;
    proxy_->GetIconDisplaySize(base::BindOnce(
        [](base::RunLoop* loop, ::gfx::Size* out_icon_size_pixels, const ::gfx::Size& icon_size_pixels) {
            *out_icon_size_pixels = std::move(icon_size_pixels);
            loop->Quit();
        },
        &loop, out_icon_size_pixels));
    loop.Run();
}

::gfx::Size BackgroundFetchServiceAsyncWaiter::GetIconDisplaySize()
{
    ::gfx::Size async_wait_result;
    GetIconDisplaySize(&async_wait_result);
    return async_wait_result;
}

void BackgroundFetchRegistrationServiceInterceptorForTesting::UpdateUI(
    const std::optional<std::string>& title, const ::SkBitmap& icon, UpdateUICallback callback)
{
    GetForwardingInterface()->UpdateUI(std::move(title), std::move(icon), std::move(callback));
}
void BackgroundFetchRegistrationServiceInterceptorForTesting::Abort(AbortCallback callback)
{
    GetForwardingInterface()->Abort(std::move(callback));
}
void BackgroundFetchRegistrationServiceInterceptorForTesting::MatchRequests(::blink::mojom::FetchAPIRequestPtr request_to_match,
    ::blink::mojom::CacheQueryOptionsPtr cache_query_options, bool match_all, MatchRequestsCallback callback)
{
    GetForwardingInterface()->MatchRequests(std::move(request_to_match), std::move(cache_query_options), std::move(match_all), std::move(callback));
}
void BackgroundFetchRegistrationServiceInterceptorForTesting::AddRegistrationObserver(::mojo::PendingRemote<BackgroundFetchRegistrationObserver> observer)
{
    GetForwardingInterface()->AddRegistrationObserver(std::move(observer));
}
BackgroundFetchRegistrationServiceAsyncWaiter::BackgroundFetchRegistrationServiceAsyncWaiter(BackgroundFetchRegistrationService* proxy)
    : proxy_(proxy)
{
}

BackgroundFetchRegistrationServiceAsyncWaiter::~BackgroundFetchRegistrationServiceAsyncWaiter() = default;

void BackgroundFetchRegistrationServiceAsyncWaiter::UpdateUI(const std::optional<std::string>& title, const ::SkBitmap& icon, BackgroundFetchError* out_error)
{
    base::RunLoop loop;
    proxy_->UpdateUI(std::move(title), std::move(icon),
        base::BindOnce(
            [](base::RunLoop* loop, BackgroundFetchError* out_error, BackgroundFetchError error) {
                *out_error = std::move(error);
                loop->Quit();
            },
            &loop, out_error));
    loop.Run();
}

BackgroundFetchError BackgroundFetchRegistrationServiceAsyncWaiter::UpdateUI(const std::optional<std::string>& title, const ::SkBitmap& icon)
{
    BackgroundFetchError async_wait_result;
    UpdateUI(std::move(title), std::move(icon), &async_wait_result);
    return async_wait_result;
}

void BackgroundFetchRegistrationServiceAsyncWaiter::Abort(BackgroundFetchError* out_error)
{
    base::RunLoop loop;
    proxy_->Abort(base::BindOnce(
        [](base::RunLoop* loop, BackgroundFetchError* out_error, BackgroundFetchError error) {
            *out_error = std::move(error);
            loop->Quit();
        },
        &loop, out_error));
    loop.Run();
}

BackgroundFetchError BackgroundFetchRegistrationServiceAsyncWaiter::Abort()
{
    BackgroundFetchError async_wait_result;
    Abort(&async_wait_result);
    return async_wait_result;
}

void BackgroundFetchRegistrationServiceAsyncWaiter::MatchRequests(::blink::mojom::FetchAPIRequestPtr request_to_match,
    ::blink::mojom::CacheQueryOptionsPtr cache_query_options, bool match_all, std::vector<BackgroundFetchSettledFetchPtr>* out_fetches)
{
    base::RunLoop loop;
    proxy_->MatchRequests(std::move(request_to_match), std::move(cache_query_options), std::move(match_all),
        base::BindOnce(
            [](base::RunLoop* loop, std::vector<BackgroundFetchSettledFetchPtr>* out_fetches, std::vector<BackgroundFetchSettledFetchPtr> fetches) {
                *out_fetches = std::move(fetches);
                loop->Quit();
            },
            &loop, out_fetches));
    loop.Run();
}

std::vector<BackgroundFetchSettledFetchPtr> BackgroundFetchRegistrationServiceAsyncWaiter::MatchRequests(
    ::blink::mojom::FetchAPIRequestPtr request_to_match, ::blink::mojom::CacheQueryOptionsPtr cache_query_options, bool match_all)
{
    std::vector<BackgroundFetchSettledFetchPtr> async_wait_result;
    MatchRequests(std::move(request_to_match), std::move(cache_query_options), std::move(match_all), &async_wait_result);
    return async_wait_result;
}

} // blink::mojom

#if defined(__clang__)
#pragma clang diagnostic pop
#endif