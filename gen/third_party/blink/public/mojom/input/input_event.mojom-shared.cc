// third_party/blink/public/mojom/input/input_event.mojom-shared.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "third_party/blink/public/mojom/input/input_event.mojom-shared.h"

// Used to support stream output operator for enums.
// TODO(dcheng): Consider omitting this somehow if not needed.
#include <ostream>
#include <utility>

#include "base/strings/stringprintf.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/lib/validation_util.h"
#include "third_party/perfetto/include/perfetto/tracing/traced_value.h"

#include "third_party/blink/public/mojom/input/input_event.mojom-params-data.h"
namespace blink {
namespace mojom {

NOINLINE static const char* ButtonToStringHelper(Button value)
{
    // Defined in a helper function to ensure that Clang generates a lookup table.
    switch (value) {
    case Button::kNoButton:
        return "kNoButton";
    case Button::kLeft:
        return "kLeft";
    case Button::kMiddle:
        return "kMiddle";
    case Button::kRight:
        return "{kRight, kBarrel}";
    case Button::kBack:
        return "kBack";
    case Button::kForward:
        return "kForward";
    case Button::kEraser:
        return "kEraser";
    default:
        return nullptr;
    }
}

std::string ButtonToString(Button value)
{
    const char* str = ButtonToStringHelper(value);
    if (!str) {
        return base::StringPrintf("Unknown Button value: %i", static_cast<int32_t>(value));
    }
    return str;
}

std::ostream& operator<<(std::ostream& os, Button value)
{
    return os << ButtonToString(value);
}

NOINLINE static const char* DispatchTypeToStringHelper(DispatchType value)
{
    // Defined in a helper function to ensure that Clang generates a lookup table.
    switch (value) {
    case DispatchType::kBlocking:
        return "kBlocking";
    case DispatchType::kEventNonBlocking:
        return "kEventNonBlocking";
    case DispatchType::kListenersNonBlockingPassive:
        return "kListenersNonBlockingPassive";
    case DispatchType::kListenersForcedNonBlockingDueToFling:
        return "kListenersForcedNonBlockingDueToFling";
    default:
        return nullptr;
    }
}

std::string DispatchTypeToString(DispatchType value)
{
    const char* str = DispatchTypeToStringHelper(value);
    if (!str) {
        return base::StringPrintf("Unknown DispatchType value: %i", static_cast<int32_t>(value));
    }
    return str;
}

std::ostream& operator<<(std::ostream& os, DispatchType value)
{
    return os << DispatchTypeToString(value);
}

NOINLINE static const char* EventTypeToStringHelper(EventType value)
{
    // Defined in a helper function to ensure that Clang generates a lookup table.
    switch (value) {
    case EventType::kUndefined:
        return "{kUndefined, kTypeFirst}";
    case EventType::kMouseDown:
        return "{kMouseDown, kMouseTypeFirst}";
    case EventType::kMouseUp:
        return "kMouseUp";
    case EventType::kMouseMove:
        return "kMouseMove";
    case EventType::kMouseEnter:
        return "kMouseEnter";
    case EventType::kMouseLeave:
        return "kMouseLeave";
    case EventType::kContextMenu:
        return "{kContextMenu, kMouseTypeLast}";
    case EventType::kMouseWheel:
        return "kMouseWheel";
    case EventType::kRawKeyDown:
        return "{kRawKeyDown, kKeyboardTypeFirst}";
    case EventType::kKeyDown:
        return "kKeyDown";
    case EventType::kKeyUp:
        return "kKeyUp";
    case EventType::kChar:
        return "{kChar, kKeyboardTypeLast}";
    case EventType::kGestureScrollBegin:
        return "{kGestureScrollBegin, kGestureTypeFirst}";
    case EventType::kGestureScrollEnd:
        return "kGestureScrollEnd";
    case EventType::kGestureScrollUpdate:
        return "kGestureScrollUpdate";
    case EventType::kGestureFlingStart:
        return "kGestureFlingStart";
    case EventType::kGestureFlingCancel:
        return "kGestureFlingCancel";
    case EventType::kGesturePinchBegin:
        return "{kGesturePinchBegin, kGesturePinchTypeFirst}";
    case EventType::kGesturePinchEnd:
        return "kGesturePinchEnd";
    case EventType::kGesturePinchUpdate:
        return "{kGesturePinchUpdate, kGesturePinchTypeLast}";
    case EventType::kGestureBegin:
        return "kGestureBegin";
    case EventType::kGestureTapDown:
        return "kGestureTapDown";
    case EventType::kGestureShowPress:
        return "kGestureShowPress";
    case EventType::kGestureTap:
        return "kGestureTap";
    case EventType::kGestureTapCancel:
        return "kGestureTapCancel";
    case EventType::kGestureShortPress:
        return "kGestureShortPress";
    case EventType::kGestureLongPress:
        return "kGestureLongPress";
    case EventType::kGestureLongTap:
        return "kGestureLongTap";
    case EventType::kGestureTwoFingerTap:
        return "kGestureTwoFingerTap";
    case EventType::kGestureTapUnconfirmed:
        return "kGestureTapUnconfirmed";
    case EventType::kGestureDoubleTap:
        return "kGestureDoubleTap";
    case EventType::kGestureEnd:
        return "{kGestureEnd, kGestureTypeLast}";
    case EventType::kTouchStart:
        return "{kTouchStart, kTouchTypeFirst}";
    case EventType::kTouchMove:
        return "kTouchMove";
    case EventType::kTouchEnd:
        return "kTouchEnd";
    case EventType::kTouchCancel:
        return "kTouchCancel";
    case EventType::kTouchScrollStarted:
        return "{kTouchScrollStarted, kTouchTypeLast}";
    case EventType::kPointerDown:
        return "{kPointerDown, kPointerTypeFirst}";
    case EventType::kPointerUp:
        return "kPointerUp";
    case EventType::kPointerMove:
        return "kPointerMove";
    case EventType::kPointerRawUpdate:
        return "kPointerRawUpdate";
    case EventType::kPointerCancel:
        return "kPointerCancel";
    case EventType::kPointerCausedUaAction:
        return "{kPointerCausedUaAction, kPointerTypeLast, kTypeLast}";
    default:
        return nullptr;
    }
}

std::string EventTypeToString(EventType value)
{
    const char* str = EventTypeToStringHelper(value);
    if (!str) {
        return base::StringPrintf("Unknown EventType value: %i", static_cast<int32_t>(value));
    }
    return str;
}

std::ostream& operator<<(std::ostream& os, EventType value)
{
    return os << EventTypeToString(value);
}

namespace internal {

} // namespace internal
} // namespace mojom
} // namespace blink

namespace perfetto {

// static
void TraceFormatTraits<::blink::mojom::Button>::WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::Button value)
{
    return std::move(context).WriteString(::blink::mojom::ButtonToString(value));
}

} // namespace perfetto

namespace perfetto {

// static
void TraceFormatTraits<::blink::mojom::DispatchType>::WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::DispatchType value)
{
    return std::move(context).WriteString(::blink::mojom::DispatchTypeToString(value));
}

} // namespace perfetto

namespace perfetto {

// static
void TraceFormatTraits<::blink::mojom::EventType>::WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::EventType value)
{
    return std::move(context).WriteString(::blink::mojom::EventTypeToString(value));
}

} // namespace perfetto