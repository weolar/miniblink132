// third_party/blink/public/mojom/input/input_handler.mojom.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef THIRD_PARTY_BLINK_PUBLIC_MOJOM_INPUT_INPUT_HANDLER_MOJOM_H_
#define THIRD_PARTY_BLINK_PUBLIC_MOJOM_INPUT_INPUT_HANDLER_MOJOM_H_

#include <stdint.h>

#include <limits>
#include <optional>
#include <type_traits>
#include <utility>

#include "base/types/cxx23_to_underlying.h"
#include "mojo/public/cpp/bindings/clone_traits.h"
#include "mojo/public/cpp/bindings/equals_traits.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/struct_ptr.h"
#include "mojo/public/cpp/bindings/struct_traits.h"
#include "mojo/public/cpp/bindings/union_traits.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "third_party/blink/public/mojom/input/input_handler.mojom-features.h" // IWYU pragma: export
#include "third_party/blink/public/mojom/input/input_handler.mojom-shared.h" // IWYU pragma: export
#include "third_party/blink/public/mojom/input/input_handler.mojom-forward.h" // IWYU pragma: export
#include "cc/mojom/browser_controls_offset_tags_info.mojom.h"
#include "cc/mojom/browser_controls_state.mojom.h"
#include "cc/mojom/overscroll_behavior.mojom.h"
#include "cc/mojom/touch_action.mojom.h"
#include "mojo/public/mojom/base/string16.mojom.h"
#include "mojo/public/mojom/base/time.mojom.h"
#include "third_party/blink/public/mojom/input/gesture_event.mojom-forward.h"
#include "third_party/blink/public/mojom/input/handwriting_gesture_result.mojom-forward.h"
#include "third_party/blink/public/mojom/input/input_event_result.mojom-forward.h"
#include "third_party/blink/public/mojom/input/input_event.mojom-forward.h"
#include "third_party/blink/public/mojom/input/pointer_lock_context.mojom-forward.h"
#include "third_party/blink/public/mojom/input/pointer_lock_result.mojom-forward.h"
#include "third_party/blink/public/mojom/input/stylus_writing_gesture.mojom-forward.h"
#include "third_party/blink/public/mojom/input/touch_event.mojom-forward.h"
#include "third_party/blink/public/mojom/selection_menu/selection_menu_behavior.mojom-forward.h"
#include "ui/base/ime/mojom/ime_types.mojom.h"
#include "ui/events/mojom/event_constants.mojom.h"
#include "ui/events/mojom/event_latency_metadata.mojom.h"
#include "ui/events/mojom/event.mojom-forward.h"
#include "ui/events/mojom/scroll_granularity.mojom.h"
#include "ui/gfx/geometry/mojom/geometry.mojom.h"
#include "ui/gfx/range/mojom/range.mojom.h"
#include "ui/latency/mojom/latency_info.mojom.h"
#include <string>
#include <vector>

#include "mojo/public/cpp/bindings/lib/control_message_handler.h"
#include "mojo/public/cpp/bindings/lib/message_size_estimator.h"
#include "mojo/public/cpp/bindings/raw_ptr_impl_ref_traits.h"

#include "mojo/public/cpp/bindings/lib/native_enum_serialization.h"
#include "mojo/public/cpp/bindings/lib/native_struct_serialization.h"
#include "third_party/blink/public/common/input/web_coalesced_input_event_mojom_traits.h"
#include "third_party/blink/public/common/common_export.h"

namespace blink::mojom {

class WidgetInputHandlerHostProxy;

template <typename ImplRefTraits> class WidgetInputHandlerHostStub;

class WidgetInputHandlerHostRequestValidator;
class WidgetInputHandlerHostResponseValidator;

class BLINK_COMMON_EXPORT WidgetInputHandlerHost : public WidgetInputHandlerHostInterfaceBase {
public:
    using IPCStableHashFunction = uint32_t (*)();

    static const char Name_[];
    static IPCStableHashFunction MessageToMethodInfo_(mojo::Message& message);
    static const char* MessageToMethodName_(mojo::Message& message);
    static constexpr uint32_t Version_ = 0;
    static constexpr bool PassesAssociatedKinds_ = false;
    static constexpr bool HasUninterruptableMethods_ = false;

    using Base_ = WidgetInputHandlerHostInterfaceBase;
    using Proxy_ = WidgetInputHandlerHostProxy;

    template <typename ImplRefTraits> using Stub_ = WidgetInputHandlerHostStub<ImplRefTraits>;

    using RequestValidator_ = WidgetInputHandlerHostRequestValidator;
    using ResponseValidator_ = WidgetInputHandlerHostResponseValidator;
    enum MethodMinVersions : uint32_t {
        kSetTouchActionFromMainMinVersion = 0,
        kSetPanActionMinVersion = 0,
        kDidOverscrollMinVersion = 0,
        kDidStartScrollingViewportMinVersion = 0,
        kImeCancelCompositionMinVersion = 0,
        kImeCompositionRangeChangedMinVersion = 0,
        kSetMouseCaptureMinVersion = 0,
        kSetAutoscrollSelectionActiveInMainFrameMinVersion = 0,
        kRequestMouseLockMinVersion = 0,
    };

// crbug.com/1340245 - this causes binary size bloat on Fuchsia, and we're OK
// with not having this data in traces there.
#if !BUILDFLAG(IS_FUCHSIA)
    struct SetTouchActionFromMain_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct SetPanAction_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct DidOverscroll_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct DidStartScrollingViewport_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct ImeCancelComposition_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct ImeCompositionRangeChanged_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct SetMouseCapture_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct SetAutoscrollSelectionActiveInMainFrame_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct RequestMouseLock_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
#endif // !BUILDFLAG(IS_FUCHSIA)
    virtual ~WidgetInputHandlerHost() = default;

    virtual void SetTouchActionFromMain(::cc::TouchAction touch_action) = 0;

    virtual void SetPanAction(PanAction pan_action) = 0;

    virtual void DidOverscroll(DidOverscrollParamsPtr params) = 0;

    virtual void DidStartScrollingViewport() = 0;

    virtual void ImeCancelComposition() = 0;

    virtual void ImeCompositionRangeChanged(
        const ::gfx::Range& range, const std::optional<std::vector<::gfx::Rect>>& character_bounds, const std::optional<std::vector<::gfx::Rect>>& line_bounds)
        = 0;

    virtual void SetMouseCapture(bool capture) = 0;

    virtual void SetAutoscrollSelectionActiveInMainFrame(bool autoscroll_selection) = 0;

    using RequestMouseLockCallback = base::OnceCallback<void(::blink::mojom::PointerLockResult, ::mojo::PendingRemote<::blink::mojom::PointerLockContext>)>;

    virtual void RequestMouseLock(bool from_user_gesture, bool unadjusted_movement, RequestMouseLockCallback callback) = 0;
};

class FrameWidgetInputHandlerProxy;

template <typename ImplRefTraits> class FrameWidgetInputHandlerStub;

class FrameWidgetInputHandlerRequestValidator;
class FrameWidgetInputHandlerResponseValidator;

class BLINK_COMMON_EXPORT FrameWidgetInputHandler : public FrameWidgetInputHandlerInterfaceBase {
public:
    using IPCStableHashFunction = uint32_t (*)();

    static const char Name_[];
    static IPCStableHashFunction MessageToMethodInfo_(mojo::Message& message);
    static const char* MessageToMethodName_(mojo::Message& message);
    static constexpr uint32_t Version_ = 0;
    static constexpr bool PassesAssociatedKinds_ = false;
    static constexpr bool HasUninterruptableMethods_ = false;

    using Base_ = FrameWidgetInputHandlerInterfaceBase;
    using Proxy_ = FrameWidgetInputHandlerProxy;

    template <typename ImplRefTraits> using Stub_ = FrameWidgetInputHandlerStub<ImplRefTraits>;

    using RequestValidator_ = FrameWidgetInputHandlerRequestValidator;
    using ResponseValidator_ = FrameWidgetInputHandlerResponseValidator;
    enum MethodMinVersions : uint32_t {
        kAddImeTextSpansToExistingTextMinVersion = 0,
        kClearImeTextSpansByTypeMinVersion = 0,
        kSetCompositionFromExistingTextMinVersion = 0,
        kExtendSelectionAndDeleteMinVersion = 0,
        kExtendSelectionAndReplaceMinVersion = 0,
        kDeleteSurroundingTextMinVersion = 0,
        kDeleteSurroundingTextInCodePointsMinVersion = 0,
        kSetEditableSelectionOffsetsMinVersion = 0,
        kHandleStylusWritingGestureActionMinVersion = 0,
        kExecuteEditCommandMinVersion = 0,
        kUndoMinVersion = 0,
        kRedoMinVersion = 0,
        kCutMinVersion = 0,
        kCopyMinVersion = 0,
        kCopyToFindPboardMinVersion = 0,
        kCenterSelectionMinVersion = 0,
        kPasteMinVersion = 0,
        kPasteAndMatchStyleMinVersion = 0,
        kDeleteMinVersion = 0,
        kSelectAllMinVersion = 0,
        kCollapseSelectionMinVersion = 0,
        kReplaceMinVersion = 0,
        kReplaceMisspellingMinVersion = 0,
        kSelectRangeMinVersion = 0,
        kAdjustSelectionByCharacterOffsetMinVersion = 0,
        kSelectAroundCaretMinVersion = 0,
        kMoveRangeSelectionExtentMinVersion = 0,
        kScrollFocusedEditableNodeIntoViewMinVersion = 0,
        kWaitForPageScaleAnimationForTestingMinVersion = 0,
        kMoveCaretMinVersion = 0,
    };

// crbug.com/1340245 - this causes binary size bloat on Fuchsia, and we're OK
// with not having this data in traces there.
#if !BUILDFLAG(IS_FUCHSIA)
    struct AddImeTextSpansToExistingText_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct ClearImeTextSpansByType_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct SetCompositionFromExistingText_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct ExtendSelectionAndDelete_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct ExtendSelectionAndReplace_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct DeleteSurroundingText_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct DeleteSurroundingTextInCodePoints_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct SetEditableSelectionOffsets_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct HandleStylusWritingGestureAction_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct ExecuteEditCommand_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct Undo_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct Redo_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct Cut_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct Copy_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct CopyToFindPboard_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct CenterSelection_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct Paste_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct PasteAndMatchStyle_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct Delete_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct SelectAll_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct CollapseSelection_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct Replace_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct ReplaceMisspelling_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct SelectRange_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct AdjustSelectionByCharacterOffset_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct SelectAroundCaret_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct MoveRangeSelectionExtent_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct ScrollFocusedEditableNodeIntoView_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct WaitForPageScaleAnimationForTesting_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct MoveCaret_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
#endif // !BUILDFLAG(IS_FUCHSIA)
    virtual ~FrameWidgetInputHandler() = default;

    virtual void AddImeTextSpansToExistingText(uint32_t start, uint32_t end, const std::vector<::ui::ImeTextSpan>& ime_text_spans) = 0;

    virtual void ClearImeTextSpansByType(uint32_t start, uint32_t end, ::ui::ImeTextSpan::Type type) = 0;

    virtual void SetCompositionFromExistingText(int32_t start, int32_t end, const std::vector<::ui::ImeTextSpan>& ime_text_spans) = 0;

    virtual void ExtendSelectionAndDelete(int32_t before, int32_t after) = 0;

    virtual void ExtendSelectionAndReplace(uint32_t before, uint32_t after, const ::std::u16string& replacement_text) = 0;

    virtual void DeleteSurroundingText(int32_t before, int32_t after) = 0;

    virtual void DeleteSurroundingTextInCodePoints(int32_t before, int32_t after) = 0;

    virtual void SetEditableSelectionOffsets(int32_t start, int32_t end) = 0;

    using HandleStylusWritingGestureActionCallback = base::OnceCallback<void(::blink::mojom::HandwritingGestureResult)>;

    virtual void HandleStylusWritingGestureAction(::blink::mojom::StylusWritingGestureDataPtr gesture_data, HandleStylusWritingGestureActionCallback callback)
        = 0;

    virtual void ExecuteEditCommand(const std::string& command, const std::optional<::std::u16string>& value) = 0;

    virtual void Undo() = 0;

    virtual void Redo() = 0;

    virtual void Cut() = 0;

    virtual void Copy() = 0;

    virtual void CopyToFindPboard() = 0;

    virtual void CenterSelection() = 0;

    virtual void Paste() = 0;

    virtual void PasteAndMatchStyle() = 0;

    virtual void Delete() = 0;

    virtual void SelectAll() = 0;

    virtual void CollapseSelection() = 0;

    virtual void Replace(const ::std::u16string& word) = 0;

    virtual void ReplaceMisspelling(const ::std::u16string& word) = 0;

    virtual void SelectRange(const ::gfx::Point& base, const ::gfx::Point& extent) = 0;

    virtual void AdjustSelectionByCharacterOffset(int32_t start, int32_t end, ::blink::mojom::SelectionMenuBehavior behavior) = 0;

    using SelectAroundCaretCallback = base::OnceCallback<void(SelectAroundCaretResultPtr)>;

    virtual void SelectAroundCaret(SelectionGranularity granularity, bool should_show_handle, bool should_show_context_menu, SelectAroundCaretCallback callback)
        = 0;

    virtual void MoveRangeSelectionExtent(const ::gfx::Point& extent) = 0;

    virtual void ScrollFocusedEditableNodeIntoView() = 0;

    using WaitForPageScaleAnimationForTestingCallback = base::OnceCallback<void()>;

    virtual void WaitForPageScaleAnimationForTesting(WaitForPageScaleAnimationForTestingCallback callback) = 0;

    virtual void MoveCaret(const ::gfx::Point& point) = 0;
};

class WidgetInputHandlerProxy;

template <typename ImplRefTraits> class WidgetInputHandlerStub;

class WidgetInputHandlerRequestValidator;
class WidgetInputHandlerResponseValidator;

class BLINK_COMMON_EXPORT WidgetInputHandler : public WidgetInputHandlerInterfaceBase {
public:
    using IPCStableHashFunction = uint32_t (*)();

    static const char Name_[];
    static IPCStableHashFunction MessageToMethodInfo_(mojo::Message& message);
    static const char* MessageToMethodName_(mojo::Message& message);
    static constexpr uint32_t Version_ = 0;
    static constexpr bool PassesAssociatedKinds_ = true;
    static constexpr bool HasUninterruptableMethods_ = false;

    using Base_ = WidgetInputHandlerInterfaceBase;
    using Proxy_ = WidgetInputHandlerProxy;

    template <typename ImplRefTraits> using Stub_ = WidgetInputHandlerStub<ImplRefTraits>;

    using RequestValidator_ = WidgetInputHandlerRequestValidator;
    using ResponseValidator_ = WidgetInputHandlerResponseValidator;
    enum MethodMinVersions : uint32_t {
        kSetFocusMinVersion = 0,
        kMouseCaptureLostMinVersion = 0,
        kSetEditCommandsForNextKeyEventMinVersion = 0,
        kCursorVisibilityChangedMinVersion = 0,
        kImeSetCompositionMinVersion = 0,
        kImeCommitTextMinVersion = 0,
        kImeFinishComposingTextMinVersion = 0,
        kRequestTextInputStateUpdateMinVersion = 0,
        kRequestCompositionUpdatesMinVersion = 0,
        kDispatchEventMinVersion = 0,
        kDispatchNonBlockingEventMinVersion = 0,
        kWaitForInputProcessedMinVersion = 0,
        kGetFrameWidgetInputHandlerMinVersion = 0,
        kUpdateBrowserControlsStateMinVersion = 0,
    };

// crbug.com/1340245 - this causes binary size bloat on Fuchsia, and we're OK
// with not having this data in traces there.
#if !BUILDFLAG(IS_FUCHSIA)
    struct SetFocus_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct MouseCaptureLost_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct SetEditCommandsForNextKeyEvent_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct CursorVisibilityChanged_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct ImeSetComposition_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct ImeCommitText_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct ImeFinishComposingText_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct RequestTextInputStateUpdate_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct RequestCompositionUpdates_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct DispatchEvent_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct DispatchNonBlockingEvent_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct WaitForInputProcessed_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct GetFrameWidgetInputHandler_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct UpdateBrowserControlsState_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
#endif // !BUILDFLAG(IS_FUCHSIA)
    virtual ~WidgetInputHandler() = default;

    virtual void SetFocus(FocusState state) = 0;

    virtual void MouseCaptureLost() = 0;

    virtual void SetEditCommandsForNextKeyEvent(std::vector<EditCommandPtr> commands) = 0;

    virtual void CursorVisibilityChanged(bool visible) = 0;

    using ImeSetCompositionCallback = base::OnceCallback<void()>;

    virtual void ImeSetComposition(const ::std::u16string& text, const std::vector<::ui::ImeTextSpan>& ime_text_spans, const ::gfx::Range& range, int32_t start,
        int32_t end, ImeSetCompositionCallback callback)
        = 0;

    using ImeCommitTextCallback = base::OnceCallback<void()>;

    virtual void ImeCommitText(const ::std::u16string& text, const std::vector<::ui::ImeTextSpan>& ime_text_spans, const ::gfx::Range& range,
        int32_t relative_cursor_position, ImeCommitTextCallback callback)
        = 0;

    virtual void ImeFinishComposingText(bool keep_selection) = 0;

    virtual void RequestTextInputStateUpdate() = 0;

    virtual void RequestCompositionUpdates(bool immediate_request, bool monitor_request) = 0;

    using DispatchEventCallback = base::OnceCallback<void(::blink::mojom::InputEventResultSource, const ::ui::LatencyInfo&,
        ::blink::mojom::InputEventResultState, DidOverscrollParamsPtr, TouchActionOptionalPtr)>;

    virtual void DispatchEvent(::std::unique_ptr<::blink::WebCoalescedInputEvent> event, DispatchEventCallback callback) = 0;

    virtual void DispatchNonBlockingEvent(::std::unique_ptr<::blink::WebCoalescedInputEvent> event) = 0;

    using WaitForInputProcessedCallback = base::OnceCallback<void()>;

    virtual void WaitForInputProcessed(WaitForInputProcessedCallback callback) = 0;

    virtual void GetFrameWidgetInputHandler(::mojo::PendingAssociatedReceiver<FrameWidgetInputHandler> interface_request) = 0;

    virtual void UpdateBrowserControlsState(::cc::BrowserControlsState constraints, ::cc::BrowserControlsState current, bool animate,
        const std::optional<::cc::BrowserControlsOffsetTagsInfo>& offset_tags_info)
        = 0;
};

//class BLINK_COMMON_EXPORT WidgetInputHandlerHostProxy : public WidgetInputHandlerHost {
//public:
//    using InterfaceType = WidgetInputHandlerHost;
//
//    explicit WidgetInputHandlerHostProxy(mojo::MessageReceiverWithResponder* receiver);
//
//    void SetTouchActionFromMain(::cc::TouchAction touch_action) final;
//
//    void SetPanAction(PanAction pan_action) final;
//
//    void DidOverscroll(DidOverscrollParamsPtr params) final;
//
//    void DidStartScrollingViewport() final;
//
//    void ImeCancelComposition() final;
//
//    void ImeCompositionRangeChanged(const ::gfx::Range& range, const std::optional<std::vector<::gfx::Rect>>& character_bounds,
//        const std::optional<std::vector<::gfx::Rect>>& line_bounds) final;
//
//    void SetMouseCapture(bool capture) final;
//
//    void SetAutoscrollSelectionActiveInMainFrame(bool autoscroll_selection) final;
//
//    void RequestMouseLock(bool from_user_gesture, bool unadjusted_movement, RequestMouseLockCallback callback) final;
//
//private:
//    mojo::MessageReceiverWithResponder* receiver_;
//};

//class BLINK_COMMON_EXPORT FrameWidgetInputHandlerProxy : public FrameWidgetInputHandler {
//public:
//    using InterfaceType = FrameWidgetInputHandler;
//
//    explicit FrameWidgetInputHandlerProxy(mojo::MessageReceiverWithResponder* receiver);
//
//    void AddImeTextSpansToExistingText(uint32_t start, uint32_t end, const std::vector<::ui::ImeTextSpan>& ime_text_spans) final;
//
//    void ClearImeTextSpansByType(uint32_t start, uint32_t end, ::ui::ImeTextSpan::Type type) final;
//
//    void SetCompositionFromExistingText(int32_t start, int32_t end, const std::vector<::ui::ImeTextSpan>& ime_text_spans) final;
//
//    void ExtendSelectionAndDelete(int32_t before, int32_t after) final;
//
//    void ExtendSelectionAndReplace(uint32_t before, uint32_t after, const ::std::u16string& replacement_text) final;
//
//    void DeleteSurroundingText(int32_t before, int32_t after) final;
//
//    void DeleteSurroundingTextInCodePoints(int32_t before, int32_t after) final;
//
//    void SetEditableSelectionOffsets(int32_t start, int32_t end) final;
//
//    void HandleStylusWritingGestureAction(::blink::mojom::StylusWritingGestureDataPtr gesture_data, HandleStylusWritingGestureActionCallback callback) final;
//
//    void ExecuteEditCommand(const std::string& command, const std::optional<::std::u16string>& value) final;
//
//    void Undo() final;
//
//    void Redo() final;
//
//    void Cut() final;
//
//    void Copy() final;
//
//    void CopyToFindPboard() final;
//
//    void CenterSelection() final;
//
//    void Paste() final;
//
//    void PasteAndMatchStyle() final;
//
//    void Delete() final;
//
//    void SelectAll() final;
//
//    void CollapseSelection() final;
//
//    void Replace(const ::std::u16string& word) final;
//
//    void ReplaceMisspelling(const ::std::u16string& word) final;
//
//    void SelectRange(const ::gfx::Point& base, const ::gfx::Point& extent) final;
//
//    void AdjustSelectionByCharacterOffset(int32_t start, int32_t end, ::blink::mojom::SelectionMenuBehavior behavior) final;
//
//    void SelectAroundCaret(SelectionGranularity granularity, bool should_show_handle, bool should_show_context_menu, SelectAroundCaretCallback callback) final;
//
//    void MoveRangeSelectionExtent(const ::gfx::Point& extent) final;
//
//    void ScrollFocusedEditableNodeIntoView() final;
//
//    void WaitForPageScaleAnimationForTesting(WaitForPageScaleAnimationForTestingCallback callback) final;
//
//    void MoveCaret(const ::gfx::Point& point) final;
//
//private:
//    mojo::MessageReceiverWithResponder* receiver_;
//};

//class BLINK_COMMON_EXPORT WidgetInputHandlerProxy : public WidgetInputHandler {
//public:
//    using InterfaceType = WidgetInputHandler;
//
//    explicit WidgetInputHandlerProxy(mojo::MessageReceiverWithResponder* receiver);
//
//    void SetFocus(FocusState state) final;
//
//    void MouseCaptureLost() final;
//
//    void SetEditCommandsForNextKeyEvent(std::vector<EditCommandPtr> commands) final;
//
//    void CursorVisibilityChanged(bool visible) final;
//
//    void ImeSetComposition(const ::std::u16string& text, const std::vector<::ui::ImeTextSpan>& ime_text_spans, const ::gfx::Range& range, int32_t start,
//        int32_t end, ImeSetCompositionCallback callback) final;
//
//    void ImeCommitText(const ::std::u16string& text, const std::vector<::ui::ImeTextSpan>& ime_text_spans, const ::gfx::Range& range,
//        int32_t relative_cursor_position, ImeCommitTextCallback callback) final;
//
//    void ImeFinishComposingText(bool keep_selection) final;
//
//    void RequestTextInputStateUpdate() final;
//
//    void RequestCompositionUpdates(bool immediate_request, bool monitor_request) final;
//
//    void DispatchEvent(::std::unique_ptr<::blink::WebCoalescedInputEvent> event, DispatchEventCallback callback) final;
//
//    void DispatchNonBlockingEvent(::std::unique_ptr<::blink::WebCoalescedInputEvent> event) final;
//
//    void WaitForInputProcessed(WaitForInputProcessedCallback callback) final;
//
//    void GetFrameWidgetInputHandler(::mojo::PendingAssociatedReceiver<FrameWidgetInputHandler> interface_request) final;
//
//    void UpdateBrowserControlsState(::cc::BrowserControlsState constraints, ::cc::BrowserControlsState current, bool animate,
//        const std::optional<::cc::BrowserControlsOffsetTagsInfo>& offset_tags_info) final;
//
//private:
//    mojo::MessageReceiverWithResponder* receiver_;
//};
//class BLINK_COMMON_EXPORT WidgetInputHandlerHostStubDispatch {
//public:
//    static bool Accept(WidgetInputHandlerHost* impl, mojo::Message* message);
//    static bool AcceptWithResponder(WidgetInputHandlerHost* impl, mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
//};

//template <typename ImplRefTraits = mojo::RawPtrImplRefTraits<WidgetInputHandlerHost>>
//class WidgetInputHandlerHostStub : public mojo::MessageReceiverWithResponderStatus {
//public:
//    using ImplPointerType = typename ImplRefTraits::PointerType;
//
//    WidgetInputHandlerHostStub() = default;
//    ~WidgetInputHandlerHostStub() override = default;
//
//    void set_sink(ImplPointerType sink)
//    {
//        sink_ = std::move(sink);
//    }
//    ImplPointerType& sink()
//    {
//        return sink_;
//    }
//
//    bool Accept(mojo::Message* message) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return WidgetInputHandlerHostStubDispatch::Accept(ImplRefTraits::GetRawPointer(&sink_), message);
//    }
//
//    bool AcceptWithResponder(mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return WidgetInputHandlerHostStubDispatch::AcceptWithResponder(ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
//    }
//
//private:
//    ImplPointerType sink_;
//};
//class BLINK_COMMON_EXPORT FrameWidgetInputHandlerStubDispatch {
//public:
//    static bool Accept(FrameWidgetInputHandler* impl, mojo::Message* message);
//    static bool AcceptWithResponder(FrameWidgetInputHandler* impl, mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
//};

//template <typename ImplRefTraits = mojo::RawPtrImplRefTraits<FrameWidgetInputHandler>>
//class FrameWidgetInputHandlerStub : public mojo::MessageReceiverWithResponderStatus {
//public:
//    using ImplPointerType = typename ImplRefTraits::PointerType;
//
//    FrameWidgetInputHandlerStub() = default;
//    ~FrameWidgetInputHandlerStub() override = default;
//
//    void set_sink(ImplPointerType sink)
//    {
//        sink_ = std::move(sink);
//    }
//    ImplPointerType& sink()
//    {
//        return sink_;
//    }
//
//    bool Accept(mojo::Message* message) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return FrameWidgetInputHandlerStubDispatch::Accept(ImplRefTraits::GetRawPointer(&sink_), message);
//    }
//
//    bool AcceptWithResponder(mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return FrameWidgetInputHandlerStubDispatch::AcceptWithResponder(ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
//    }
//
//private:
//    ImplPointerType sink_;
//};
//class BLINK_COMMON_EXPORT WidgetInputHandlerStubDispatch {
//public:
//    static bool Accept(WidgetInputHandler* impl, mojo::Message* message);
//    static bool AcceptWithResponder(WidgetInputHandler* impl, mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
//};

//template <typename ImplRefTraits = mojo::RawPtrImplRefTraits<WidgetInputHandler>>
//class WidgetInputHandlerStub : public mojo::MessageReceiverWithResponderStatus {
//public:
//    using ImplPointerType = typename ImplRefTraits::PointerType;
//
//    WidgetInputHandlerStub() = default;
//    ~WidgetInputHandlerStub() override = default;
//
//    void set_sink(ImplPointerType sink)
//    {
//        sink_ = std::move(sink);
//    }
//    ImplPointerType& sink()
//    {
//        return sink_;
//    }
//
//    bool Accept(mojo::Message* message) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return WidgetInputHandlerStubDispatch::Accept(ImplRefTraits::GetRawPointer(&sink_), message);
//    }
//
//    bool AcceptWithResponder(mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return WidgetInputHandlerStubDispatch::AcceptWithResponder(ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
//    }
//
//private:
//    ImplPointerType sink_;
//};
//class BLINK_COMMON_EXPORT WidgetInputHandlerHostRequestValidator : public mojo::MessageReceiver {
//public:
//    bool Accept(mojo::Message* message) override;
//};
//class BLINK_COMMON_EXPORT FrameWidgetInputHandlerRequestValidator : public mojo::MessageReceiver {
//public:
//    bool Accept(mojo::Message* message) override;
//};
//class BLINK_COMMON_EXPORT WidgetInputHandlerRequestValidator : public mojo::MessageReceiver {
//public:
//    bool Accept(mojo::Message* message) override;
//};
//class BLINK_COMMON_EXPORT WidgetInputHandlerHostResponseValidator : public mojo::MessageReceiver {
//public:
//    bool Accept(mojo::Message* message) override;
//};
//class BLINK_COMMON_EXPORT FrameWidgetInputHandlerResponseValidator : public mojo::MessageReceiver {
//public:
//    bool Accept(mojo::Message* message) override;
//};
//class BLINK_COMMON_EXPORT WidgetInputHandlerResponseValidator : public mojo::MessageReceiver {
//public:
//    bool Accept(mojo::Message* message) override;
//};

class BLINK_COMMON_EXPORT PinchBeginData {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<PinchBeginData, T>::value>;
    using DataView = PinchBeginDataDataView;
    using Data_ = internal::PinchBeginData_Data;

    template <typename... Args> static PinchBeginDataPtr New(Args&&... args)
    {
        return PinchBeginDataPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static PinchBeginDataPtr From(const U& u)
    {
        return mojo::TypeConverter<PinchBeginDataPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, PinchBeginData>::Convert(*this);
    }

    PinchBeginData()
    : needs_wheel_event()
{
}

    explicit PinchBeginData(bool needs_wheel_event_in)
    : needs_wheel_event(std::move(needs_wheel_event_in)){
}

    ~PinchBeginData() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = PinchBeginDataPtr> PinchBeginDataPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, PinchBeginData::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, PinchBeginData::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, PinchBeginData::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static std::vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<PinchBeginData::DataView, std::vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<PinchBeginData::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(std::make_unique<internal::PinchBeginData_UnserializedMessageContext<UserType, PinchBeginData::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<PinchBeginData::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return PinchBeginData::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::PinchBeginData_UnserializedMessageContext<UserType, PinchBeginData::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<PinchBeginData::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    bool needs_wheel_event;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, PinchBeginData::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, PinchBeginData::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, PinchBeginData::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, PinchBeginData::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class BLINK_COMMON_EXPORT PinchUpdateData {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<PinchUpdateData, T>::value>;
    using DataView = PinchUpdateDataDataView;
    using Data_ = internal::PinchUpdateData_Data;

    template <typename... Args> static PinchUpdateDataPtr New(Args&&... args)
    {
        return PinchUpdateDataPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static PinchUpdateDataPtr From(const U& u)
    {
        return mojo::TypeConverter<PinchUpdateDataPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, PinchUpdateData>::Convert(*this);
    }

    PinchUpdateData()
    : scale()
    , zoom_disabled()
    , needs_wheel_event()
{
}

    PinchUpdateData(float scale_in, bool zoom_disabled_in, bool needs_wheel_event_in)
    : scale(std::move(scale_in))
    , zoom_disabled(std::move(zoom_disabled_in))
    , needs_wheel_event(std::move(needs_wheel_event_in)){
}

    ~PinchUpdateData() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = PinchUpdateDataPtr> PinchUpdateDataPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, PinchUpdateData::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, PinchUpdateData::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, PinchUpdateData::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static std::vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<PinchUpdateData::DataView, std::vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<PinchUpdateData::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::PinchUpdateData_UnserializedMessageContext<UserType, PinchUpdateData::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<PinchUpdateData::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return PinchUpdateData::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::PinchUpdateData_UnserializedMessageContext<UserType, PinchUpdateData::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<PinchUpdateData::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    float scale;

    bool zoom_disabled;

    bool needs_wheel_event;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, PinchUpdateData::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, PinchUpdateData::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, PinchUpdateData::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, PinchUpdateData::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class BLINK_COMMON_EXPORT PinchEndData {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<PinchEndData, T>::value>;
    using DataView = PinchEndDataDataView;
    using Data_ = internal::PinchEndData_Data;

    template <typename... Args> static PinchEndDataPtr New(Args&&... args)
    {
        return PinchEndDataPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static PinchEndDataPtr From(const U& u)
    {
        return mojo::TypeConverter<PinchEndDataPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, PinchEndData>::Convert(*this);
    }

    PinchEndData()
    : needs_wheel_event()
{
}

    explicit PinchEndData(bool needs_wheel_event_in)
    : needs_wheel_event(std::move(needs_wheel_event_in)){
}

    ~PinchEndData() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = PinchEndDataPtr> PinchEndDataPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, PinchEndData::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, PinchEndData::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, PinchEndData::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static std::vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<PinchEndData::DataView, std::vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<PinchEndData::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(std::make_unique<internal::PinchEndData_UnserializedMessageContext<UserType, PinchEndData::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<PinchEndData::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return PinchEndData::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::PinchEndData_UnserializedMessageContext<UserType, PinchEndData::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<PinchEndData::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    bool needs_wheel_event;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, PinchEndData::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, PinchEndData::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, PinchEndData::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, PinchEndData::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class BLINK_COMMON_EXPORT FlingData {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<FlingData, T>::value>;
    using DataView = FlingDataDataView;
    using Data_ = internal::FlingData_Data;

    template <typename... Args> static FlingDataPtr New(Args&&... args)
    {
        return FlingDataPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static FlingDataPtr From(const U& u)
    {
        return mojo::TypeConverter<FlingDataPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, FlingData>::Convert(*this);
    }

    FlingData()
    : velocity_x()
    , velocity_y()
    , target_viewport()
    , prevent_boosting()
{
}

    FlingData(float velocity_x_in, float velocity_y_in, bool target_viewport_in, bool prevent_boosting_in)
    : velocity_x(std::move(velocity_x_in))
    , velocity_y(std::move(velocity_y_in))
    , target_viewport(std::move(target_viewport_in))
    , prevent_boosting(std::move(prevent_boosting_in)){
}

    ~FlingData() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = FlingDataPtr> FlingDataPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, FlingData::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, FlingData::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, FlingData::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static std::vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<FlingData::DataView, std::vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<FlingData::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(std::make_unique<internal::FlingData_UnserializedMessageContext<UserType, FlingData::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<FlingData::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return FlingData::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::FlingData_UnserializedMessageContext<UserType, FlingData::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<FlingData::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    float velocity_x;

    float velocity_y;

    bool target_viewport;

    bool prevent_boosting;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, FlingData::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, FlingData::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, FlingData::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, FlingData::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class BLINK_COMMON_EXPORT TapData {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<TapData, T>::value>;
    using DataView = TapDataDataView;
    using Data_ = internal::TapData_Data;

    template <typename... Args> static TapDataPtr New(Args&&... args)
    {
        return TapDataPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static TapDataPtr From(const U& u)
    {
        return mojo::TypeConverter<TapDataPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, TapData>::Convert(*this);
    }

    TapData()
    : tap_count()
    , needs_wheel_event()
{
}

    TapData(int32_t tap_count_in, bool needs_wheel_event_in)
    : tap_count(std::move(tap_count_in))
    , needs_wheel_event(std::move(needs_wheel_event_in)){
}

    ~TapData() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = TapDataPtr> TapDataPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, TapData::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, TapData::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, TapData::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static std::vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<TapData::DataView, std::vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<TapData::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::TapData_UnserializedMessageContext<UserType, TapData::DataView>>(0, 0, std::move(input)), MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<TapData::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return TapData::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::TapData_UnserializedMessageContext<UserType, TapData::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<TapData::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    int32_t tap_count;

    bool needs_wheel_event;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, TapData::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, TapData::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, TapData::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, TapData::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class BLINK_COMMON_EXPORT TapDownData {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<TapDownData, T>::value>;
    using DataView = TapDownDataDataView;
    using Data_ = internal::TapDownData_Data;

    template <typename... Args> static TapDownDataPtr New(Args&&... args)
    {
        return TapDownDataPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static TapDownDataPtr From(const U& u)
    {
        return mojo::TypeConverter<TapDownDataPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, TapDownData>::Convert(*this);
    }

    TapDownData()
    : tap_down_count()
{
}

    explicit TapDownData(int32_t tap_down_count_in)
    : tap_down_count(std::move(tap_down_count_in)){
}

    ~TapDownData() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = TapDownDataPtr> TapDownDataPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, TapDownData::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, TapDownData::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, TapDownData::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static std::vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<TapDownData::DataView, std::vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<TapDownData::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(std::make_unique<internal::TapDownData_UnserializedMessageContext<UserType, TapDownData::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<TapDownData::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return TapDownData::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::TapDownData_UnserializedMessageContext<UserType, TapDownData::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<TapDownData::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    int32_t tap_down_count;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, TapDownData::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, TapDownData::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, TapDownData::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, TapDownData::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class BLINK_COMMON_EXPORT TouchActionOptional {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<TouchActionOptional, T>::value>;
    using DataView = TouchActionOptionalDataView;
    using Data_ = internal::TouchActionOptional_Data;

    template <typename... Args> static TouchActionOptionalPtr New(Args&&... args)
    {
        return TouchActionOptionalPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static TouchActionOptionalPtr From(const U& u)
    {
        return mojo::TypeConverter<TouchActionOptionalPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, TouchActionOptional>::Convert(*this);
    }

    TouchActionOptional()
    : touch_action()
{
}

    explicit TouchActionOptional(::cc::TouchAction touch_action_in)
    : touch_action(std::move(touch_action_in)){
}

    ~TouchActionOptional() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = TouchActionOptionalPtr> TouchActionOptionalPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, TouchActionOptional::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, TouchActionOptional::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, TouchActionOptional::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static std::vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<TouchActionOptional::DataView, std::vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<TouchActionOptional::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::TouchActionOptional_UnserializedMessageContext<UserType, TouchActionOptional::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<TouchActionOptional::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return TouchActionOptional::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::TouchActionOptional_UnserializedMessageContext<UserType, TouchActionOptional::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<TouchActionOptional::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    ::cc::TouchAction touch_action;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, TouchActionOptional::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, TouchActionOptional::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, TouchActionOptional::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, TouchActionOptional::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class BLINK_COMMON_EXPORT EditCommand {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<EditCommand, T>::value>;
    using DataView = EditCommandDataView;
    using Data_ = internal::EditCommand_Data;

    template <typename... Args> static EditCommandPtr New(Args&&... args)
    {
        return EditCommandPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static EditCommandPtr From(const U& u)
    {
        return mojo::TypeConverter<EditCommandPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, EditCommand>::Convert(*this);
    }

    EditCommand()
    : name()
    , value()
{
}

    EditCommand(const std::string& name_in, const std::string& value_in)
    : name(std::move(name_in))
    , value(std::move(value_in)){
}

    ~EditCommand() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = EditCommandPtr> EditCommandPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, EditCommand::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, EditCommand::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, EditCommand::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static std::vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<EditCommand::DataView, std::vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<EditCommand::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(std::make_unique<internal::EditCommand_UnserializedMessageContext<UserType, EditCommand::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<EditCommand::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return EditCommand::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::EditCommand_UnserializedMessageContext<UserType, EditCommand::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<EditCommand::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    std::string name;

    std::string value;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, EditCommand::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, EditCommand::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, EditCommand::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, EditCommand::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class BLINK_COMMON_EXPORT SelectAroundCaretResult {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<SelectAroundCaretResult, T>::value>;
    using DataView = SelectAroundCaretResultDataView;
    using Data_ = internal::SelectAroundCaretResult_Data;

    template <typename... Args> static SelectAroundCaretResultPtr New(Args&&... args)
    {
        return SelectAroundCaretResultPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static SelectAroundCaretResultPtr From(const U& u)
    {
        return mojo::TypeConverter<SelectAroundCaretResultPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, SelectAroundCaretResult>::Convert(*this);
    }

    SelectAroundCaretResult()
    : extended_start_adjust()
    , extended_end_adjust()
    , word_start_adjust()
    , word_end_adjust()
{
}

    SelectAroundCaretResult(
    int32_t extended_start_adjust_in, int32_t extended_end_adjust_in, int32_t word_start_adjust_in, int32_t word_end_adjust_in)
    : extended_start_adjust(std::move(extended_start_adjust_in))
    , extended_end_adjust(std::move(extended_end_adjust_in))
    , word_start_adjust(std::move(word_start_adjust_in))
    , word_end_adjust(std::move(word_end_adjust_in)){
}

    ~SelectAroundCaretResult() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = SelectAroundCaretResultPtr> SelectAroundCaretResultPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, SelectAroundCaretResult::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, SelectAroundCaretResult::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, SelectAroundCaretResult::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static std::vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<SelectAroundCaretResult::DataView, std::vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<SelectAroundCaretResult::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::SelectAroundCaretResult_UnserializedMessageContext<UserType, SelectAroundCaretResult::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<SelectAroundCaretResult::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return SelectAroundCaretResult::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context
            = input.TakeUnserializedContext<internal::SelectAroundCaretResult_UnserializedMessageContext<UserType, SelectAroundCaretResult::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<SelectAroundCaretResult::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    int32_t extended_start_adjust;

    int32_t extended_end_adjust;

    int32_t word_start_adjust;

    int32_t word_end_adjust;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, SelectAroundCaretResult::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, SelectAroundCaretResult::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, SelectAroundCaretResult::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, SelectAroundCaretResult::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class BLINK_COMMON_EXPORT KeyData {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<KeyData, T>::value>;
    using DataView = KeyDataDataView;
    using Data_ = internal::KeyData_Data;

    template <typename... Args> static KeyDataPtr New(Args&&... args)
    {
        return KeyDataPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static KeyDataPtr From(const U& u)
    {
        return mojo::TypeConverter<KeyDataPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, KeyData>::Convert(*this);
    }

    KeyData()
    : dom_key()
    , dom_code()
    , windows_key_code()
    , native_key_code()
    , is_system_key()
    , is_browser_shortcut()
    , text()
    , unmodified_text()
{
}

    KeyData(int32_t dom_key_in, int32_t dom_code_in, int32_t windows_key_code_in, int32_t native_key_code_in, bool is_system_key_in,
    bool is_browser_shortcut_in, const ::std::u16string& text_in, const ::std::u16string& unmodified_text_in)
    : dom_key(std::move(dom_key_in))
    , dom_code(std::move(dom_code_in))
    , windows_key_code(std::move(windows_key_code_in))
    , native_key_code(std::move(native_key_code_in))
    , is_system_key(std::move(is_system_key_in))
    , is_browser_shortcut(std::move(is_browser_shortcut_in))
    , text(std::move(text_in))
    , unmodified_text(std::move(unmodified_text_in)){
}

    ~KeyData() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = KeyDataPtr> KeyDataPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, KeyData::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, KeyData::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, KeyData::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static std::vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<KeyData::DataView, std::vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<KeyData::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::KeyData_UnserializedMessageContext<UserType, KeyData::DataView>>(0, 0, std::move(input)), MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<KeyData::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return KeyData::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::KeyData_UnserializedMessageContext<UserType, KeyData::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<KeyData::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    int32_t dom_key;

    int32_t dom_code;

    int32_t windows_key_code;

    int32_t native_key_code;

    bool is_system_key;

    bool is_browser_shortcut;

    ::std::u16string text;

    ::std::u16string unmodified_text;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, KeyData::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, KeyData::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, KeyData::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, KeyData::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class BLINK_COMMON_EXPORT PointerData {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<PointerData, T>::value>;
    using DataView = PointerDataDataView;
    using Data_ = internal::PointerData_Data;

    template <typename... Args> static PointerDataPtr New(Args&&... args)
    {
        return PointerDataPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static PointerDataPtr From(const U& u)
    {
        return mojo::TypeConverter<PointerDataPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, PointerData>::Convert(*this);
    }

    PointerData()
    : pointer_id()
    , force()
    , tilt_x()
    , tilt_y()
    , tangential_pressure()
    , twist()
    , button()
    , pointer_type()
    , movement_x()
    , movement_y()
    , is_raw_movement_event()
    , widget_position()
    , screen_position()
    , mouse_data()
    , device_id()
{
}

    PointerData(int32_t pointer_id_in, float force_in, double tilt_x_in, double tilt_y_in, float tangential_pressure_in, int32_t twist_in,
    ::blink::mojom::Button button_in, ::ui::EventPointerType pointer_type_in, int32_t movement_x_in, int32_t movement_y_in, bool is_raw_movement_event_in,
    const ::gfx::PointF& widget_position_in, const ::gfx::PointF& screen_position_in, MouseDataPtr mouse_data_in, int32_t device_id_in)
    : pointer_id(std::move(pointer_id_in))
    , force(std::move(force_in))
    , tilt_x(std::move(tilt_x_in))
    , tilt_y(std::move(tilt_y_in))
    , tangential_pressure(std::move(tangential_pressure_in))
    , twist(std::move(twist_in))
    , button(std::move(button_in))
    , pointer_type(std::move(pointer_type_in))
    , movement_x(std::move(movement_x_in))
    , movement_y(std::move(movement_y_in))
    , is_raw_movement_event(std::move(is_raw_movement_event_in))
    , widget_position(std::move(widget_position_in))
    , screen_position(std::move(screen_position_in))
    , mouse_data(std::move(mouse_data_in))
    , device_id(std::move(device_id_in)){
}

    PointerData(const PointerData&) = delete;
    PointerData& operator=(const PointerData&) = delete;

    ~PointerData() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = PointerDataPtr> PointerDataPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, PointerData::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, PointerData::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, PointerData::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static std::vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<PointerData::DataView, std::vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<PointerData::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(std::make_unique<internal::PointerData_UnserializedMessageContext<UserType, PointerData::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<PointerData::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return PointerData::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::PointerData_UnserializedMessageContext<UserType, PointerData::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<PointerData::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    int32_t pointer_id;

    float force;

    double tilt_x;

    double tilt_y;

    float tangential_pressure;

    int32_t twist;

    ::blink::mojom::Button button;

    ::ui::EventPointerType pointer_type;

    int32_t movement_x;

    int32_t movement_y;

    bool is_raw_movement_event;

    ::gfx::PointF widget_position;

    ::gfx::PointF screen_position;

    MouseDataPtr mouse_data;

    int32_t device_id;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, PointerData::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, PointerData::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, PointerData::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, PointerData::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class BLINK_COMMON_EXPORT WheelData {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<WheelData, T>::value>;
    using DataView = WheelDataDataView;
    using Data_ = internal::WheelData_Data;

    template <typename... Args> static WheelDataPtr New(Args&&... args)
    {
        return WheelDataPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static WheelDataPtr From(const U& u)
    {
        return mojo::TypeConverter<WheelDataPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, WheelData>::Convert(*this);
    }

    WheelData()
    : delta_x()
    , delta_y()
    , wheel_ticks_x()
    , wheel_ticks_y()
    , acceleration_ratio_x()
    , acceleration_ratio_y()
    , phase()
    , momentum_phase()
    , cancelable()
    , event_action()
    , delta_units()
{
}

    WheelData(float delta_x_in, float delta_y_in, float wheel_ticks_x_in, float wheel_ticks_y_in, float acceleration_ratio_x_in,
    float acceleration_ratio_y_in, uint8_t phase_in, uint8_t momentum_phase_in, ::blink::mojom::DispatchType cancelable_in, uint8_t event_action_in,
    uint8_t delta_units_in)
    : delta_x(std::move(delta_x_in))
    , delta_y(std::move(delta_y_in))
    , wheel_ticks_x(std::move(wheel_ticks_x_in))
    , wheel_ticks_y(std::move(wheel_ticks_y_in))
    , acceleration_ratio_x(std::move(acceleration_ratio_x_in))
    , acceleration_ratio_y(std::move(acceleration_ratio_y_in))
    , phase(std::move(phase_in))
    , momentum_phase(std::move(momentum_phase_in))
    , cancelable(std::move(cancelable_in))
    , event_action(std::move(event_action_in))
    , delta_units(std::move(delta_units_in)){
}

    ~WheelData() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = WheelDataPtr> WheelDataPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, WheelData::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, WheelData::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, WheelData::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static std::vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<WheelData::DataView, std::vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<WheelData::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(std::make_unique<internal::WheelData_UnserializedMessageContext<UserType, WheelData::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<WheelData::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return WheelData::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::WheelData_UnserializedMessageContext<UserType, WheelData::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<WheelData::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    float delta_x;

    float delta_y;

    float wheel_ticks_x;

    float wheel_ticks_y;

    float acceleration_ratio_x;

    float acceleration_ratio_y;

    uint8_t phase;

    uint8_t momentum_phase;

    ::blink::mojom::DispatchType cancelable;

    uint8_t event_action;

    uint8_t delta_units;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, WheelData::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, WheelData::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, WheelData::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, WheelData::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class BLINK_COMMON_EXPORT MouseData {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<MouseData, T>::value>;
    using DataView = MouseDataDataView;
    using Data_ = internal::MouseData_Data;

    template <typename... Args> static MouseDataPtr New(Args&&... args)
    {
        return MouseDataPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static MouseDataPtr From(const U& u)
    {
        return mojo::TypeConverter<MouseDataPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, MouseData>::Convert(*this);
    }

    MouseData()
    : click_count()
    , wheel_data()
{
}

    MouseData(int32_t click_count_in, WheelDataPtr wheel_data_in)
    : click_count(std::move(click_count_in))
    , wheel_data(std::move(wheel_data_in)){
}

    MouseData(const MouseData&) = delete;
    MouseData& operator=(const MouseData&) = delete;

    ~MouseData() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = MouseDataPtr> MouseDataPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, MouseData::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, MouseData::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, MouseData::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static std::vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<MouseData::DataView, std::vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<MouseData::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(std::make_unique<internal::MouseData_UnserializedMessageContext<UserType, MouseData::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<MouseData::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return MouseData::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::MouseData_UnserializedMessageContext<UserType, MouseData::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<MouseData::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    int32_t click_count;

    WheelDataPtr wheel_data;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, MouseData::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, MouseData::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, MouseData::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, MouseData::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class BLINK_COMMON_EXPORT ScrollData {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<ScrollData, T>::value>;
    using DataView = ScrollDataDataView;
    using Data_ = internal::ScrollData_Data;

    template <typename... Args> static ScrollDataPtr New(Args&&... args)
    {
        return ScrollDataPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static ScrollDataPtr From(const U& u)
    {
        return mojo::TypeConverter<ScrollDataPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, ScrollData>::Convert(*this);
    }

    ScrollData()
    : delta_x()
    , delta_y()
    , delta_units()
    , target_viewport()
    , inertial_phase()
    , synthetic()
    , pointer_count()
    , cursor_control()
{
}

    ScrollData(float delta_x_in, float delta_y_in, ::ui::ScrollGranularity delta_units_in, bool target_viewport_in,
    ::blink::mojom::InertialPhaseState inertial_phase_in, bool synthetic_in, int32_t pointer_count_in, bool cursor_control_in)
    : delta_x(std::move(delta_x_in))
    , delta_y(std::move(delta_y_in))
    , delta_units(std::move(delta_units_in))
    , target_viewport(std::move(target_viewport_in))
    , inertial_phase(std::move(inertial_phase_in))
    , synthetic(std::move(synthetic_in))
    , pointer_count(std::move(pointer_count_in))
    , cursor_control(std::move(cursor_control_in)){
}

    ~ScrollData() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = ScrollDataPtr> ScrollDataPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, ScrollData::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, ScrollData::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, ScrollData::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static std::vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<ScrollData::DataView, std::vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<ScrollData::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(std::make_unique<internal::ScrollData_UnserializedMessageContext<UserType, ScrollData::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<ScrollData::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return ScrollData::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::ScrollData_UnserializedMessageContext<UserType, ScrollData::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<ScrollData::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    float delta_x;

    float delta_y;

    ::ui::ScrollGranularity delta_units;

    bool target_viewport;

    ::blink::mojom::InertialPhaseState inertial_phase;

    bool synthetic;

    int32_t pointer_count;

    bool cursor_control;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, ScrollData::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, ScrollData::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, ScrollData::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, ScrollData::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class BLINK_COMMON_EXPORT GestureData {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<GestureData, T>::value>;
    using DataView = GestureDataDataView;
    using Data_ = internal::GestureData_Data;

    template <typename... Args> static GestureDataPtr New(Args&&... args)
    {
        return GestureDataPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static GestureDataPtr From(const U& u)
    {
        return mojo::TypeConverter<GestureDataPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, GestureData>::Convert(*this);
    }

    GestureData()
    : screen_position()
    , widget_position()
    , source_device()
    , is_source_touch_event_set_blocking()
    , primary_pointer_type()
    , primary_unique_touch_event_id()
    , unique_touch_event_id()
    , contact_size()
    , scroll_data()
    , pinch_begin_data()
    , pinch_update_data()
    , pinch_end_data()
    , tap_data()
    , tap_down_data()
    , fling_data()
{
}

    GestureData(const ::gfx::PointF& screen_position_in, const ::gfx::PointF& widget_position_in, ::blink::mojom::GestureDevice source_device_in,
    bool is_source_touch_event_set_blocking_in, ::ui::EventPointerType primary_pointer_type_in, int32_t primary_unique_touch_event_id_in,
    int32_t unique_touch_event_id_in, const std::optional<::gfx::Size>& contact_size_in, ScrollDataPtr scroll_data_in, PinchBeginDataPtr pinch_begin_data_in,
    PinchUpdateDataPtr pinch_update_data_in, PinchEndDataPtr pinch_end_data_in, TapDataPtr tap_data_in, TapDownDataPtr tap_down_data_in,
    FlingDataPtr fling_data_in)
    : screen_position(std::move(screen_position_in))
    , widget_position(std::move(widget_position_in))
    , source_device(std::move(source_device_in))
    , is_source_touch_event_set_blocking(std::move(is_source_touch_event_set_blocking_in))
    , primary_pointer_type(std::move(primary_pointer_type_in))
    , primary_unique_touch_event_id(std::move(primary_unique_touch_event_id_in))
    , unique_touch_event_id(std::move(unique_touch_event_id_in))
    , contact_size(std::move(contact_size_in))
    , scroll_data(std::move(scroll_data_in))
    , pinch_begin_data(std::move(pinch_begin_data_in))
    , pinch_update_data(std::move(pinch_update_data_in))
    , pinch_end_data(std::move(pinch_end_data_in))
    , tap_data(std::move(tap_data_in))
    , tap_down_data(std::move(tap_down_data_in))
    , fling_data(std::move(fling_data_in)){
}

    GestureData(const GestureData&) = delete;
    GestureData& operator=(const GestureData&) = delete;

    ~GestureData() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = GestureDataPtr> GestureDataPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, GestureData::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, GestureData::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, GestureData::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static std::vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<GestureData::DataView, std::vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<GestureData::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(std::make_unique<internal::GestureData_UnserializedMessageContext<UserType, GestureData::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<GestureData::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return GestureData::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::GestureData_UnserializedMessageContext<UserType, GestureData::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<GestureData::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    ::gfx::PointF screen_position;

    ::gfx::PointF widget_position;

    ::blink::mojom::GestureDevice source_device;

    bool is_source_touch_event_set_blocking;

    ::ui::EventPointerType primary_pointer_type;

    int32_t primary_unique_touch_event_id;

    int32_t unique_touch_event_id;

    std::optional<::gfx::Size> contact_size;

    ScrollDataPtr scroll_data;

    PinchBeginDataPtr pinch_begin_data;

    PinchUpdateDataPtr pinch_update_data;

    PinchEndDataPtr pinch_end_data;

    TapDataPtr tap_data;

    TapDownDataPtr tap_down_data;

    FlingDataPtr fling_data;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, GestureData::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, GestureData::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, GestureData::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, GestureData::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class BLINK_COMMON_EXPORT TouchPoint {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<TouchPoint, T>::value>;
    using DataView = TouchPointDataView;
    using Data_ = internal::TouchPoint_Data;

    template <typename... Args> static TouchPointPtr New(Args&&... args)
    {
        return TouchPointPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static TouchPointPtr From(const U& u)
    {
        return mojo::TypeConverter<TouchPointPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, TouchPoint>::Convert(*this);
    }

    TouchPoint()
    : state()
    , radius_x()
    , radius_y()
    , rotation_angle()
    , pointer_data()
{
}

    TouchPoint(::blink::mojom::TouchState state_in, float radius_x_in, float radius_y_in, float rotation_angle_in, PointerDataPtr pointer_data_in)
    : state(std::move(state_in))
    , radius_x(std::move(radius_x_in))
    , radius_y(std::move(radius_y_in))
    , rotation_angle(std::move(rotation_angle_in))
    , pointer_data(std::move(pointer_data_in)){
}

    TouchPoint(const TouchPoint&) = delete;
    TouchPoint& operator=(const TouchPoint&) = delete;

    ~TouchPoint() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = TouchPointPtr> TouchPointPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, TouchPoint::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, TouchPoint::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, TouchPoint::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static std::vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<TouchPoint::DataView, std::vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<TouchPoint::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(std::make_unique<internal::TouchPoint_UnserializedMessageContext<UserType, TouchPoint::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<TouchPoint::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return TouchPoint::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::TouchPoint_UnserializedMessageContext<UserType, TouchPoint::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<TouchPoint::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    ::blink::mojom::TouchState state;

    float radius_x;

    float radius_y;

    float rotation_angle;

    PointerDataPtr pointer_data;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, TouchPoint::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, TouchPoint::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, TouchPoint::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, TouchPoint::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class BLINK_COMMON_EXPORT TouchData {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<TouchData, T>::value>;
    using DataView = TouchDataDataView;
    using Data_ = internal::TouchData_Data;

    template <typename... Args> static TouchDataPtr New(Args&&... args)
    {
        return TouchDataPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static TouchDataPtr From(const U& u)
    {
        return mojo::TypeConverter<TouchDataPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, TouchData>::Convert(*this);
    }

    TouchData()
    : cancelable()
    , moved_beyond_slop_region()
    , touch_start_or_first_move()
    , hovering()
    , unique_touch_event_id()
    , touches()
{
}

    TouchData(::blink::mojom::DispatchType cancelable_in, bool moved_beyond_slop_region_in, bool touch_start_or_first_move_in, bool hovering_in,
    uint32_t unique_touch_event_id_in, std::vector<TouchPointPtr> touches_in)
    : cancelable(std::move(cancelable_in))
    , moved_beyond_slop_region(std::move(moved_beyond_slop_region_in))
    , touch_start_or_first_move(std::move(touch_start_or_first_move_in))
    , hovering(std::move(hovering_in))
    , unique_touch_event_id(std::move(unique_touch_event_id_in))
    , touches(std::move(touches_in)){
}

    TouchData(const TouchData&) = delete;
    TouchData& operator=(const TouchData&) = delete;

    ~TouchData() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = TouchDataPtr> TouchDataPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, TouchData::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, TouchData::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, TouchData::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static std::vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<TouchData::DataView, std::vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<TouchData::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(std::make_unique<internal::TouchData_UnserializedMessageContext<UserType, TouchData::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<TouchData::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return TouchData::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::TouchData_UnserializedMessageContext<UserType, TouchData::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<TouchData::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    ::blink::mojom::DispatchType cancelable;

    bool moved_beyond_slop_region;

    bool touch_start_or_first_move;

    bool hovering;

    uint32_t unique_touch_event_id;

    std::vector<TouchPointPtr> touches;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, TouchData::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, TouchData::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, TouchData::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, TouchData::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class BLINK_COMMON_EXPORT Event {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<Event, T>::value>;
    using DataView = EventDataView;
    using Data_ = internal::Event_Data;

    template <typename... Args> static EventPtr New(Args&&... args)
    {
        return EventPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static EventPtr From(const U& u)
    {
        return mojo::TypeConverter<EventPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, Event>::Convert(*this);
    }

    Event()
    : type()
    , modifiers()
    , timestamp()
    , latency()
    , event_latency_metadata()
    , key_data()
    , pointer_data()
    , gesture_data()
    , touch_data()
{
}

    Event(::blink::mojom::EventType type_in, int32_t modifiers_in, ::base::TimeTicks timestamp_in, const ::ui::LatencyInfo& latency_in,
    const ::ui::EventLatencyMetadata& event_latency_metadata_in, KeyDataPtr key_data_in, PointerDataPtr pointer_data_in, GestureDataPtr gesture_data_in,
    TouchDataPtr touch_data_in)
    : type(std::move(type_in))
    , modifiers(std::move(modifiers_in))
    , timestamp(std::move(timestamp_in))
    , latency(std::move(latency_in))
    , event_latency_metadata(std::move(event_latency_metadata_in))
    , key_data(std::move(key_data_in))
    , pointer_data(std::move(pointer_data_in))
    , gesture_data(std::move(gesture_data_in))
    , touch_data(std::move(touch_data_in)){
}

    Event(const Event&) = delete;
    Event& operator=(const Event&) = delete;

    ~Event() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = EventPtr> EventPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, Event::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, Event::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, Event::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static std::vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<Event::DataView, std::vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<Event::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::Event_UnserializedMessageContext<UserType, Event::DataView>>(0, 0, std::move(input)), MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<Event::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return Event::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::Event_UnserializedMessageContext<UserType, Event::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<Event::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    ::blink::mojom::EventType type;

    int32_t modifiers;

    ::base::TimeTicks timestamp;

    ::ui::LatencyInfo latency;

    ::ui::EventLatencyMetadata event_latency_metadata;

    KeyDataPtr key_data;

    PointerDataPtr pointer_data;

    GestureDataPtr gesture_data;

    TouchDataPtr touch_data;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, Event::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, Event::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, Event::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, Event::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class BLINK_COMMON_EXPORT DidOverscrollParams {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<DidOverscrollParams, T>::value>;
    using DataView = DidOverscrollParamsDataView;
    using Data_ = internal::DidOverscrollParams_Data;

    template <typename... Args> static DidOverscrollParamsPtr New(Args&&... args)
    {
        return DidOverscrollParamsPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static DidOverscrollParamsPtr From(const U& u)
    {
        return mojo::TypeConverter<DidOverscrollParamsPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, DidOverscrollParams>::Convert(*this);
    }

    DidOverscrollParams()
    : accumulated_overscroll()
    , latest_overscroll_delta()
    , current_fling_velocity()
    , causal_event_viewport_point()
    , overscroll_behavior()
{
}

    DidOverscrollParams(const ::gfx::Vector2dF& accumulated_overscroll_in, const ::gfx::Vector2dF& latest_overscroll_delta_in,
    const ::gfx::Vector2dF& current_fling_velocity_in, const ::gfx::PointF& causal_event_viewport_point_in,
    const ::cc::OverscrollBehavior& overscroll_behavior_in)
    : accumulated_overscroll(std::move(accumulated_overscroll_in))
    , latest_overscroll_delta(std::move(latest_overscroll_delta_in))
    , current_fling_velocity(std::move(current_fling_velocity_in))
    , causal_event_viewport_point(std::move(causal_event_viewport_point_in))
    , overscroll_behavior(std::move(overscroll_behavior_in)){
}

    ~DidOverscrollParams() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = DidOverscrollParamsPtr> DidOverscrollParamsPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, DidOverscrollParams::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, DidOverscrollParams::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, DidOverscrollParams::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static std::vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<DidOverscrollParams::DataView, std::vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<DidOverscrollParams::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::DidOverscrollParams_UnserializedMessageContext<UserType, DidOverscrollParams::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<DidOverscrollParams::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return DidOverscrollParams::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::DidOverscrollParams_UnserializedMessageContext<UserType, DidOverscrollParams::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<DidOverscrollParams::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    ::gfx::Vector2dF accumulated_overscroll;

    ::gfx::Vector2dF latest_overscroll_delta;

    ::gfx::Vector2dF current_fling_velocity;

    ::gfx::PointF causal_event_viewport_point;

    ::cc::OverscrollBehavior overscroll_behavior;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, DidOverscrollParams::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, DidOverscrollParams::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, DidOverscrollParams::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, DidOverscrollParams::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

template <typename StructPtrType> KeyDataPtr KeyData::Clone() const
{
    return New(mojo::Clone(dom_key), mojo::Clone(dom_code), mojo::Clone(windows_key_code), mojo::Clone(native_key_code), mojo::Clone(is_system_key),
        mojo::Clone(is_browser_shortcut), mojo::Clone(text), mojo::Clone(unmodified_text));
}

template <typename T, KeyData::EnableIfSame<T>*> bool KeyData::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->dom_key, other_struct.dom_key))
        return false;
    if (!mojo::Equals(this->dom_code, other_struct.dom_code))
        return false;
    if (!mojo::Equals(this->windows_key_code, other_struct.windows_key_code))
        return false;
    if (!mojo::Equals(this->native_key_code, other_struct.native_key_code))
        return false;
    if (!mojo::Equals(this->is_system_key, other_struct.is_system_key))
        return false;
    if (!mojo::Equals(this->is_browser_shortcut, other_struct.is_browser_shortcut))
        return false;
    if (!mojo::Equals(this->text, other_struct.text))
        return false;
    if (!mojo::Equals(this->unmodified_text, other_struct.unmodified_text))
        return false;
    return true;
}

template <typename T, KeyData::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.dom_key < rhs.dom_key)
        return true;
    if (rhs.dom_key < lhs.dom_key)
        return false;
    if (lhs.dom_code < rhs.dom_code)
        return true;
    if (rhs.dom_code < lhs.dom_code)
        return false;
    if (lhs.windows_key_code < rhs.windows_key_code)
        return true;
    if (rhs.windows_key_code < lhs.windows_key_code)
        return false;
    if (lhs.native_key_code < rhs.native_key_code)
        return true;
    if (rhs.native_key_code < lhs.native_key_code)
        return false;
    if (lhs.is_system_key < rhs.is_system_key)
        return true;
    if (rhs.is_system_key < lhs.is_system_key)
        return false;
    if (lhs.is_browser_shortcut < rhs.is_browser_shortcut)
        return true;
    if (rhs.is_browser_shortcut < lhs.is_browser_shortcut)
        return false;
    if (lhs.text < rhs.text)
        return true;
    if (rhs.text < lhs.text)
        return false;
    if (lhs.unmodified_text < rhs.unmodified_text)
        return true;
    if (rhs.unmodified_text < lhs.unmodified_text)
        return false;
    return false;
}
template <typename StructPtrType> PointerDataPtr PointerData::Clone() const
{
    return New(mojo::Clone(pointer_id), mojo::Clone(force), mojo::Clone(tilt_x), mojo::Clone(tilt_y), mojo::Clone(tangential_pressure), mojo::Clone(twist),
        mojo::Clone(button), mojo::Clone(pointer_type), mojo::Clone(movement_x), mojo::Clone(movement_y), mojo::Clone(is_raw_movement_event),
        mojo::Clone(widget_position), mojo::Clone(screen_position), mojo::Clone(mouse_data), mojo::Clone(device_id));
}

template <typename T, PointerData::EnableIfSame<T>*> bool PointerData::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->pointer_id, other_struct.pointer_id))
        return false;
    if (!mojo::Equals(this->force, other_struct.force))
        return false;
    if (!mojo::Equals(this->tilt_x, other_struct.tilt_x))
        return false;
    if (!mojo::Equals(this->tilt_y, other_struct.tilt_y))
        return false;
    if (!mojo::Equals(this->tangential_pressure, other_struct.tangential_pressure))
        return false;
    if (!mojo::Equals(this->twist, other_struct.twist))
        return false;
    if (!mojo::Equals(this->button, other_struct.button))
        return false;
    if (!mojo::Equals(this->pointer_type, other_struct.pointer_type))
        return false;
    if (!mojo::Equals(this->movement_x, other_struct.movement_x))
        return false;
    if (!mojo::Equals(this->movement_y, other_struct.movement_y))
        return false;
    if (!mojo::Equals(this->is_raw_movement_event, other_struct.is_raw_movement_event))
        return false;
    if (!mojo::Equals(this->widget_position, other_struct.widget_position))
        return false;
    if (!mojo::Equals(this->screen_position, other_struct.screen_position))
        return false;
    if (!mojo::Equals(this->mouse_data, other_struct.mouse_data))
        return false;
    if (!mojo::Equals(this->device_id, other_struct.device_id))
        return false;
    return true;
}

template <typename T, PointerData::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.pointer_id < rhs.pointer_id)
        return true;
    if (rhs.pointer_id < lhs.pointer_id)
        return false;
    if (lhs.force < rhs.force)
        return true;
    if (rhs.force < lhs.force)
        return false;
    if (lhs.tilt_x < rhs.tilt_x)
        return true;
    if (rhs.tilt_x < lhs.tilt_x)
        return false;
    if (lhs.tilt_y < rhs.tilt_y)
        return true;
    if (rhs.tilt_y < lhs.tilt_y)
        return false;
    if (lhs.tangential_pressure < rhs.tangential_pressure)
        return true;
    if (rhs.tangential_pressure < lhs.tangential_pressure)
        return false;
    if (lhs.twist < rhs.twist)
        return true;
    if (rhs.twist < lhs.twist)
        return false;
    if (lhs.button < rhs.button)
        return true;
    if (rhs.button < lhs.button)
        return false;
    if (lhs.pointer_type < rhs.pointer_type)
        return true;
    if (rhs.pointer_type < lhs.pointer_type)
        return false;
    if (lhs.movement_x < rhs.movement_x)
        return true;
    if (rhs.movement_x < lhs.movement_x)
        return false;
    if (lhs.movement_y < rhs.movement_y)
        return true;
    if (rhs.movement_y < lhs.movement_y)
        return false;
    if (lhs.is_raw_movement_event < rhs.is_raw_movement_event)
        return true;
    if (rhs.is_raw_movement_event < lhs.is_raw_movement_event)
        return false;
    if (lhs.widget_position < rhs.widget_position)
        return true;
    if (rhs.widget_position < lhs.widget_position)
        return false;
    if (lhs.screen_position < rhs.screen_position)
        return true;
    if (rhs.screen_position < lhs.screen_position)
        return false;
    if (lhs.mouse_data < rhs.mouse_data)
        return true;
    if (rhs.mouse_data < lhs.mouse_data)
        return false;
    if (lhs.device_id < rhs.device_id)
        return true;
    if (rhs.device_id < lhs.device_id)
        return false;
    return false;
}
template <typename StructPtrType> WheelDataPtr WheelData::Clone() const
{
    return New(mojo::Clone(delta_x), mojo::Clone(delta_y), mojo::Clone(wheel_ticks_x), mojo::Clone(wheel_ticks_y), mojo::Clone(acceleration_ratio_x),
        mojo::Clone(acceleration_ratio_y), mojo::Clone(phase), mojo::Clone(momentum_phase), mojo::Clone(cancelable), mojo::Clone(event_action),
        mojo::Clone(delta_units));
}

template <typename T, WheelData::EnableIfSame<T>*> bool WheelData::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->delta_x, other_struct.delta_x))
        return false;
    if (!mojo::Equals(this->delta_y, other_struct.delta_y))
        return false;
    if (!mojo::Equals(this->wheel_ticks_x, other_struct.wheel_ticks_x))
        return false;
    if (!mojo::Equals(this->wheel_ticks_y, other_struct.wheel_ticks_y))
        return false;
    if (!mojo::Equals(this->acceleration_ratio_x, other_struct.acceleration_ratio_x))
        return false;
    if (!mojo::Equals(this->acceleration_ratio_y, other_struct.acceleration_ratio_y))
        return false;
    if (!mojo::Equals(this->phase, other_struct.phase))
        return false;
    if (!mojo::Equals(this->momentum_phase, other_struct.momentum_phase))
        return false;
    if (!mojo::Equals(this->cancelable, other_struct.cancelable))
        return false;
    if (!mojo::Equals(this->event_action, other_struct.event_action))
        return false;
    if (!mojo::Equals(this->delta_units, other_struct.delta_units))
        return false;
    return true;
}

template <typename T, WheelData::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.delta_x < rhs.delta_x)
        return true;
    if (rhs.delta_x < lhs.delta_x)
        return false;
    if (lhs.delta_y < rhs.delta_y)
        return true;
    if (rhs.delta_y < lhs.delta_y)
        return false;
    if (lhs.wheel_ticks_x < rhs.wheel_ticks_x)
        return true;
    if (rhs.wheel_ticks_x < lhs.wheel_ticks_x)
        return false;
    if (lhs.wheel_ticks_y < rhs.wheel_ticks_y)
        return true;
    if (rhs.wheel_ticks_y < lhs.wheel_ticks_y)
        return false;
    if (lhs.acceleration_ratio_x < rhs.acceleration_ratio_x)
        return true;
    if (rhs.acceleration_ratio_x < lhs.acceleration_ratio_x)
        return false;
    if (lhs.acceleration_ratio_y < rhs.acceleration_ratio_y)
        return true;
    if (rhs.acceleration_ratio_y < lhs.acceleration_ratio_y)
        return false;
    if (lhs.phase < rhs.phase)
        return true;
    if (rhs.phase < lhs.phase)
        return false;
    if (lhs.momentum_phase < rhs.momentum_phase)
        return true;
    if (rhs.momentum_phase < lhs.momentum_phase)
        return false;
    if (lhs.cancelable < rhs.cancelable)
        return true;
    if (rhs.cancelable < lhs.cancelable)
        return false;
    if (lhs.event_action < rhs.event_action)
        return true;
    if (rhs.event_action < lhs.event_action)
        return false;
    if (lhs.delta_units < rhs.delta_units)
        return true;
    if (rhs.delta_units < lhs.delta_units)
        return false;
    return false;
}
template <typename StructPtrType> MouseDataPtr MouseData::Clone() const
{
    return New(mojo::Clone(click_count), mojo::Clone(wheel_data));
}

template <typename T, MouseData::EnableIfSame<T>*> bool MouseData::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->click_count, other_struct.click_count))
        return false;
    if (!mojo::Equals(this->wheel_data, other_struct.wheel_data))
        return false;
    return true;
}

template <typename T, MouseData::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.click_count < rhs.click_count)
        return true;
    if (rhs.click_count < lhs.click_count)
        return false;
    if (lhs.wheel_data < rhs.wheel_data)
        return true;
    if (rhs.wheel_data < lhs.wheel_data)
        return false;
    return false;
}
template <typename StructPtrType> ScrollDataPtr ScrollData::Clone() const
{
    return New(mojo::Clone(delta_x), mojo::Clone(delta_y), mojo::Clone(delta_units), mojo::Clone(target_viewport), mojo::Clone(inertial_phase),
        mojo::Clone(synthetic), mojo::Clone(pointer_count), mojo::Clone(cursor_control));
}

template <typename T, ScrollData::EnableIfSame<T>*> bool ScrollData::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->delta_x, other_struct.delta_x))
        return false;
    if (!mojo::Equals(this->delta_y, other_struct.delta_y))
        return false;
    if (!mojo::Equals(this->delta_units, other_struct.delta_units))
        return false;
    if (!mojo::Equals(this->target_viewport, other_struct.target_viewport))
        return false;
    if (!mojo::Equals(this->inertial_phase, other_struct.inertial_phase))
        return false;
    if (!mojo::Equals(this->synthetic, other_struct.synthetic))
        return false;
    if (!mojo::Equals(this->pointer_count, other_struct.pointer_count))
        return false;
    if (!mojo::Equals(this->cursor_control, other_struct.cursor_control))
        return false;
    return true;
}

template <typename T, ScrollData::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.delta_x < rhs.delta_x)
        return true;
    if (rhs.delta_x < lhs.delta_x)
        return false;
    if (lhs.delta_y < rhs.delta_y)
        return true;
    if (rhs.delta_y < lhs.delta_y)
        return false;
    if (lhs.delta_units < rhs.delta_units)
        return true;
    if (rhs.delta_units < lhs.delta_units)
        return false;
    if (lhs.target_viewport < rhs.target_viewport)
        return true;
    if (rhs.target_viewport < lhs.target_viewport)
        return false;
    if (lhs.inertial_phase < rhs.inertial_phase)
        return true;
    if (rhs.inertial_phase < lhs.inertial_phase)
        return false;
    if (lhs.synthetic < rhs.synthetic)
        return true;
    if (rhs.synthetic < lhs.synthetic)
        return false;
    if (lhs.pointer_count < rhs.pointer_count)
        return true;
    if (rhs.pointer_count < lhs.pointer_count)
        return false;
    if (lhs.cursor_control < rhs.cursor_control)
        return true;
    if (rhs.cursor_control < lhs.cursor_control)
        return false;
    return false;
}
template <typename StructPtrType> PinchBeginDataPtr PinchBeginData::Clone() const
{
    return New(mojo::Clone(needs_wheel_event));
}

template <typename T, PinchBeginData::EnableIfSame<T>*> bool PinchBeginData::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->needs_wheel_event, other_struct.needs_wheel_event))
        return false;
    return true;
}

template <typename T, PinchBeginData::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.needs_wheel_event < rhs.needs_wheel_event)
        return true;
    if (rhs.needs_wheel_event < lhs.needs_wheel_event)
        return false;
    return false;
}
template <typename StructPtrType> PinchUpdateDataPtr PinchUpdateData::Clone() const
{
    return New(mojo::Clone(scale), mojo::Clone(zoom_disabled), mojo::Clone(needs_wheel_event));
}

template <typename T, PinchUpdateData::EnableIfSame<T>*> bool PinchUpdateData::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->scale, other_struct.scale))
        return false;
    if (!mojo::Equals(this->zoom_disabled, other_struct.zoom_disabled))
        return false;
    if (!mojo::Equals(this->needs_wheel_event, other_struct.needs_wheel_event))
        return false;
    return true;
}

template <typename T, PinchUpdateData::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.scale < rhs.scale)
        return true;
    if (rhs.scale < lhs.scale)
        return false;
    if (lhs.zoom_disabled < rhs.zoom_disabled)
        return true;
    if (rhs.zoom_disabled < lhs.zoom_disabled)
        return false;
    if (lhs.needs_wheel_event < rhs.needs_wheel_event)
        return true;
    if (rhs.needs_wheel_event < lhs.needs_wheel_event)
        return false;
    return false;
}
template <typename StructPtrType> PinchEndDataPtr PinchEndData::Clone() const
{
    return New(mojo::Clone(needs_wheel_event));
}

template <typename T, PinchEndData::EnableIfSame<T>*> bool PinchEndData::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->needs_wheel_event, other_struct.needs_wheel_event))
        return false;
    return true;
}

template <typename T, PinchEndData::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.needs_wheel_event < rhs.needs_wheel_event)
        return true;
    if (rhs.needs_wheel_event < lhs.needs_wheel_event)
        return false;
    return false;
}
template <typename StructPtrType> FlingDataPtr FlingData::Clone() const
{
    return New(mojo::Clone(velocity_x), mojo::Clone(velocity_y), mojo::Clone(target_viewport), mojo::Clone(prevent_boosting));
}

template <typename T, FlingData::EnableIfSame<T>*> bool FlingData::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->velocity_x, other_struct.velocity_x))
        return false;
    if (!mojo::Equals(this->velocity_y, other_struct.velocity_y))
        return false;
    if (!mojo::Equals(this->target_viewport, other_struct.target_viewport))
        return false;
    if (!mojo::Equals(this->prevent_boosting, other_struct.prevent_boosting))
        return false;
    return true;
}

template <typename T, FlingData::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.velocity_x < rhs.velocity_x)
        return true;
    if (rhs.velocity_x < lhs.velocity_x)
        return false;
    if (lhs.velocity_y < rhs.velocity_y)
        return true;
    if (rhs.velocity_y < lhs.velocity_y)
        return false;
    if (lhs.target_viewport < rhs.target_viewport)
        return true;
    if (rhs.target_viewport < lhs.target_viewport)
        return false;
    if (lhs.prevent_boosting < rhs.prevent_boosting)
        return true;
    if (rhs.prevent_boosting < lhs.prevent_boosting)
        return false;
    return false;
}
template <typename StructPtrType> TapDataPtr TapData::Clone() const
{
    return New(mojo::Clone(tap_count), mojo::Clone(needs_wheel_event));
}

template <typename T, TapData::EnableIfSame<T>*> bool TapData::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->tap_count, other_struct.tap_count))
        return false;
    if (!mojo::Equals(this->needs_wheel_event, other_struct.needs_wheel_event))
        return false;
    return true;
}

template <typename T, TapData::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.tap_count < rhs.tap_count)
        return true;
    if (rhs.tap_count < lhs.tap_count)
        return false;
    if (lhs.needs_wheel_event < rhs.needs_wheel_event)
        return true;
    if (rhs.needs_wheel_event < lhs.needs_wheel_event)
        return false;
    return false;
}
template <typename StructPtrType> TapDownDataPtr TapDownData::Clone() const
{
    return New(mojo::Clone(tap_down_count));
}

template <typename T, TapDownData::EnableIfSame<T>*> bool TapDownData::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->tap_down_count, other_struct.tap_down_count))
        return false;
    return true;
}

template <typename T, TapDownData::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.tap_down_count < rhs.tap_down_count)
        return true;
    if (rhs.tap_down_count < lhs.tap_down_count)
        return false;
    return false;
}
template <typename StructPtrType> GestureDataPtr GestureData::Clone() const
{
    return New(mojo::Clone(screen_position), mojo::Clone(widget_position), mojo::Clone(source_device), mojo::Clone(is_source_touch_event_set_blocking),
        mojo::Clone(primary_pointer_type), mojo::Clone(primary_unique_touch_event_id), mojo::Clone(unique_touch_event_id), mojo::Clone(contact_size),
        mojo::Clone(scroll_data), mojo::Clone(pinch_begin_data), mojo::Clone(pinch_update_data), mojo::Clone(pinch_end_data), mojo::Clone(tap_data),
        mojo::Clone(tap_down_data), mojo::Clone(fling_data));
}

template <typename T, GestureData::EnableIfSame<T>*> bool GestureData::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->screen_position, other_struct.screen_position))
        return false;
    if (!mojo::Equals(this->widget_position, other_struct.widget_position))
        return false;
    if (!mojo::Equals(this->source_device, other_struct.source_device))
        return false;
    if (!mojo::Equals(this->is_source_touch_event_set_blocking, other_struct.is_source_touch_event_set_blocking))
        return false;
    if (!mojo::Equals(this->primary_pointer_type, other_struct.primary_pointer_type))
        return false;
    if (!mojo::Equals(this->primary_unique_touch_event_id, other_struct.primary_unique_touch_event_id))
        return false;
    if (!mojo::Equals(this->unique_touch_event_id, other_struct.unique_touch_event_id))
        return false;
    if (!mojo::Equals(this->contact_size, other_struct.contact_size))
        return false;
    if (!mojo::Equals(this->scroll_data, other_struct.scroll_data))
        return false;
    if (!mojo::Equals(this->pinch_begin_data, other_struct.pinch_begin_data))
        return false;
    if (!mojo::Equals(this->pinch_update_data, other_struct.pinch_update_data))
        return false;
    if (!mojo::Equals(this->pinch_end_data, other_struct.pinch_end_data))
        return false;
    if (!mojo::Equals(this->tap_data, other_struct.tap_data))
        return false;
    if (!mojo::Equals(this->tap_down_data, other_struct.tap_down_data))
        return false;
    if (!mojo::Equals(this->fling_data, other_struct.fling_data))
        return false;
    return true;
}

template <typename T, GestureData::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.screen_position < rhs.screen_position)
        return true;
    if (rhs.screen_position < lhs.screen_position)
        return false;
    if (lhs.widget_position < rhs.widget_position)
        return true;
    if (rhs.widget_position < lhs.widget_position)
        return false;
    if (lhs.source_device < rhs.source_device)
        return true;
    if (rhs.source_device < lhs.source_device)
        return false;
    if (lhs.is_source_touch_event_set_blocking < rhs.is_source_touch_event_set_blocking)
        return true;
    if (rhs.is_source_touch_event_set_blocking < lhs.is_source_touch_event_set_blocking)
        return false;
    if (lhs.primary_pointer_type < rhs.primary_pointer_type)
        return true;
    if (rhs.primary_pointer_type < lhs.primary_pointer_type)
        return false;
    if (lhs.primary_unique_touch_event_id < rhs.primary_unique_touch_event_id)
        return true;
    if (rhs.primary_unique_touch_event_id < lhs.primary_unique_touch_event_id)
        return false;
    if (lhs.unique_touch_event_id < rhs.unique_touch_event_id)
        return true;
    if (rhs.unique_touch_event_id < lhs.unique_touch_event_id)
        return false;
    if (lhs.contact_size < rhs.contact_size)
        return true;
    if (rhs.contact_size < lhs.contact_size)
        return false;
    if (lhs.scroll_data < rhs.scroll_data)
        return true;
    if (rhs.scroll_data < lhs.scroll_data)
        return false;
    if (lhs.pinch_begin_data < rhs.pinch_begin_data)
        return true;
    if (rhs.pinch_begin_data < lhs.pinch_begin_data)
        return false;
    if (lhs.pinch_update_data < rhs.pinch_update_data)
        return true;
    if (rhs.pinch_update_data < lhs.pinch_update_data)
        return false;
    if (lhs.pinch_end_data < rhs.pinch_end_data)
        return true;
    if (rhs.pinch_end_data < lhs.pinch_end_data)
        return false;
    if (lhs.tap_data < rhs.tap_data)
        return true;
    if (rhs.tap_data < lhs.tap_data)
        return false;
    if (lhs.tap_down_data < rhs.tap_down_data)
        return true;
    if (rhs.tap_down_data < lhs.tap_down_data)
        return false;
    if (lhs.fling_data < rhs.fling_data)
        return true;
    if (rhs.fling_data < lhs.fling_data)
        return false;
    return false;
}
template <typename StructPtrType> TouchPointPtr TouchPoint::Clone() const
{
    return New(mojo::Clone(state), mojo::Clone(radius_x), mojo::Clone(radius_y), mojo::Clone(rotation_angle), mojo::Clone(pointer_data));
}

template <typename T, TouchPoint::EnableIfSame<T>*> bool TouchPoint::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->state, other_struct.state))
        return false;
    if (!mojo::Equals(this->radius_x, other_struct.radius_x))
        return false;
    if (!mojo::Equals(this->radius_y, other_struct.radius_y))
        return false;
    if (!mojo::Equals(this->rotation_angle, other_struct.rotation_angle))
        return false;
    if (!mojo::Equals(this->pointer_data, other_struct.pointer_data))
        return false;
    return true;
}

template <typename T, TouchPoint::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.state < rhs.state)
        return true;
    if (rhs.state < lhs.state)
        return false;
    if (lhs.radius_x < rhs.radius_x)
        return true;
    if (rhs.radius_x < lhs.radius_x)
        return false;
    if (lhs.radius_y < rhs.radius_y)
        return true;
    if (rhs.radius_y < lhs.radius_y)
        return false;
    if (lhs.rotation_angle < rhs.rotation_angle)
        return true;
    if (rhs.rotation_angle < lhs.rotation_angle)
        return false;
    if (lhs.pointer_data < rhs.pointer_data)
        return true;
    if (rhs.pointer_data < lhs.pointer_data)
        return false;
    return false;
}
template <typename StructPtrType> TouchDataPtr TouchData::Clone() const
{
    return New(mojo::Clone(cancelable), mojo::Clone(moved_beyond_slop_region), mojo::Clone(touch_start_or_first_move), mojo::Clone(hovering),
        mojo::Clone(unique_touch_event_id), mojo::Clone(touches));
}

template <typename T, TouchData::EnableIfSame<T>*> bool TouchData::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->cancelable, other_struct.cancelable))
        return false;
    if (!mojo::Equals(this->moved_beyond_slop_region, other_struct.moved_beyond_slop_region))
        return false;
    if (!mojo::Equals(this->touch_start_or_first_move, other_struct.touch_start_or_first_move))
        return false;
    if (!mojo::Equals(this->hovering, other_struct.hovering))
        return false;
    if (!mojo::Equals(this->unique_touch_event_id, other_struct.unique_touch_event_id))
        return false;
    if (!mojo::Equals(this->touches, other_struct.touches))
        return false;
    return true;
}

template <typename T, TouchData::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.cancelable < rhs.cancelable)
        return true;
    if (rhs.cancelable < lhs.cancelable)
        return false;
    if (lhs.moved_beyond_slop_region < rhs.moved_beyond_slop_region)
        return true;
    if (rhs.moved_beyond_slop_region < lhs.moved_beyond_slop_region)
        return false;
    if (lhs.touch_start_or_first_move < rhs.touch_start_or_first_move)
        return true;
    if (rhs.touch_start_or_first_move < lhs.touch_start_or_first_move)
        return false;
    if (lhs.hovering < rhs.hovering)
        return true;
    if (rhs.hovering < lhs.hovering)
        return false;
    if (lhs.unique_touch_event_id < rhs.unique_touch_event_id)
        return true;
    if (rhs.unique_touch_event_id < lhs.unique_touch_event_id)
        return false;
    if (lhs.touches < rhs.touches)
        return true;
    if (rhs.touches < lhs.touches)
        return false;
    return false;
}
template <typename StructPtrType> EventPtr Event::Clone() const
{
    return New(mojo::Clone(type), mojo::Clone(modifiers), mojo::Clone(timestamp), mojo::Clone(latency), mojo::Clone(event_latency_metadata),
        mojo::Clone(key_data), mojo::Clone(pointer_data), mojo::Clone(gesture_data), mojo::Clone(touch_data));
}

template <typename T, Event::EnableIfSame<T>*> bool Event::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->type, other_struct.type))
        return false;
    if (!mojo::Equals(this->modifiers, other_struct.modifiers))
        return false;
    if (!mojo::Equals(this->timestamp, other_struct.timestamp))
        return false;
    if (!mojo::Equals(this->latency, other_struct.latency))
        return false;
    if (!mojo::Equals(this->event_latency_metadata, other_struct.event_latency_metadata))
        return false;
    if (!mojo::Equals(this->key_data, other_struct.key_data))
        return false;
    if (!mojo::Equals(this->pointer_data, other_struct.pointer_data))
        return false;
    if (!mojo::Equals(this->gesture_data, other_struct.gesture_data))
        return false;
    if (!mojo::Equals(this->touch_data, other_struct.touch_data))
        return false;
    return true;
}

template <typename T, Event::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.type < rhs.type)
        return true;
    if (rhs.type < lhs.type)
        return false;
    if (lhs.modifiers < rhs.modifiers)
        return true;
    if (rhs.modifiers < lhs.modifiers)
        return false;
    if (lhs.timestamp < rhs.timestamp)
        return true;
    if (rhs.timestamp < lhs.timestamp)
        return false;
    if (lhs.latency < rhs.latency)
        return true;
    if (rhs.latency < lhs.latency)
        return false;
    if (lhs.event_latency_metadata < rhs.event_latency_metadata)
        return true;
    if (rhs.event_latency_metadata < lhs.event_latency_metadata)
        return false;
    if (lhs.key_data < rhs.key_data)
        return true;
    if (rhs.key_data < lhs.key_data)
        return false;
    if (lhs.pointer_data < rhs.pointer_data)
        return true;
    if (rhs.pointer_data < lhs.pointer_data)
        return false;
    if (lhs.gesture_data < rhs.gesture_data)
        return true;
    if (rhs.gesture_data < lhs.gesture_data)
        return false;
    if (lhs.touch_data < rhs.touch_data)
        return true;
    if (rhs.touch_data < lhs.touch_data)
        return false;
    return false;
}
template <typename StructPtrType> DidOverscrollParamsPtr DidOverscrollParams::Clone() const
{
    return New(mojo::Clone(accumulated_overscroll), mojo::Clone(latest_overscroll_delta), mojo::Clone(current_fling_velocity),
        mojo::Clone(causal_event_viewport_point), mojo::Clone(overscroll_behavior));
}

template <typename T, DidOverscrollParams::EnableIfSame<T>*> bool DidOverscrollParams::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->accumulated_overscroll, other_struct.accumulated_overscroll))
        return false;
    if (!mojo::Equals(this->latest_overscroll_delta, other_struct.latest_overscroll_delta))
        return false;
    if (!mojo::Equals(this->current_fling_velocity, other_struct.current_fling_velocity))
        return false;
    if (!mojo::Equals(this->causal_event_viewport_point, other_struct.causal_event_viewport_point))
        return false;
    if (!mojo::Equals(this->overscroll_behavior, other_struct.overscroll_behavior))
        return false;
    return true;
}

template <typename T, DidOverscrollParams::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.accumulated_overscroll < rhs.accumulated_overscroll)
        return true;
    if (rhs.accumulated_overscroll < lhs.accumulated_overscroll)
        return false;
    if (lhs.latest_overscroll_delta < rhs.latest_overscroll_delta)
        return true;
    if (rhs.latest_overscroll_delta < lhs.latest_overscroll_delta)
        return false;
    if (lhs.current_fling_velocity < rhs.current_fling_velocity)
        return true;
    if (rhs.current_fling_velocity < lhs.current_fling_velocity)
        return false;
    if (lhs.causal_event_viewport_point < rhs.causal_event_viewport_point)
        return true;
    if (rhs.causal_event_viewport_point < lhs.causal_event_viewport_point)
        return false;
    if (lhs.overscroll_behavior < rhs.overscroll_behavior)
        return true;
    if (rhs.overscroll_behavior < lhs.overscroll_behavior)
        return false;
    return false;
}
template <typename StructPtrType> TouchActionOptionalPtr TouchActionOptional::Clone() const
{
    return New(mojo::Clone(touch_action));
}

template <typename T, TouchActionOptional::EnableIfSame<T>*> bool TouchActionOptional::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->touch_action, other_struct.touch_action))
        return false;
    return true;
}

template <typename T, TouchActionOptional::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.touch_action < rhs.touch_action)
        return true;
    if (rhs.touch_action < lhs.touch_action)
        return false;
    return false;
}
template <typename StructPtrType> EditCommandPtr EditCommand::Clone() const
{
    return New(mojo::Clone(name), mojo::Clone(value));
}

template <typename T, EditCommand::EnableIfSame<T>*> bool EditCommand::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->name, other_struct.name))
        return false;
    if (!mojo::Equals(this->value, other_struct.value))
        return false;
    return true;
}

template <typename T, EditCommand::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.name < rhs.name)
        return true;
    if (rhs.name < lhs.name)
        return false;
    if (lhs.value < rhs.value)
        return true;
    if (rhs.value < lhs.value)
        return false;
    return false;
}
template <typename StructPtrType> SelectAroundCaretResultPtr SelectAroundCaretResult::Clone() const
{
    return New(mojo::Clone(extended_start_adjust), mojo::Clone(extended_end_adjust), mojo::Clone(word_start_adjust), mojo::Clone(word_end_adjust));
}

template <typename T, SelectAroundCaretResult::EnableIfSame<T>*> bool SelectAroundCaretResult::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->extended_start_adjust, other_struct.extended_start_adjust))
        return false;
    if (!mojo::Equals(this->extended_end_adjust, other_struct.extended_end_adjust))
        return false;
    if (!mojo::Equals(this->word_start_adjust, other_struct.word_start_adjust))
        return false;
    if (!mojo::Equals(this->word_end_adjust, other_struct.word_end_adjust))
        return false;
    return true;
}

template <typename T, SelectAroundCaretResult::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.extended_start_adjust < rhs.extended_start_adjust)
        return true;
    if (rhs.extended_start_adjust < lhs.extended_start_adjust)
        return false;
    if (lhs.extended_end_adjust < rhs.extended_end_adjust)
        return true;
    if (rhs.extended_end_adjust < lhs.extended_end_adjust)
        return false;
    if (lhs.word_start_adjust < rhs.word_start_adjust)
        return true;
    if (rhs.word_start_adjust < lhs.word_start_adjust)
        return false;
    if (lhs.word_end_adjust < rhs.word_end_adjust)
        return true;
    if (rhs.word_end_adjust < lhs.word_end_adjust)
        return false;
    return false;
}

} // blink::mojom

namespace mojo {

template <> struct BLINK_COMMON_EXPORT StructTraits<::blink::mojom::KeyData::DataView, ::blink::mojom::KeyDataPtr> {
    static bool IsNull(const ::blink::mojom::KeyDataPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::KeyDataPtr* output)
    {
        output->reset();
    }

    static decltype(::blink::mojom::KeyData::dom_key) dom_key(const ::blink::mojom::KeyDataPtr& input)
    {
        return input->dom_key;
    }

    static decltype(::blink::mojom::KeyData::dom_code) dom_code(const ::blink::mojom::KeyDataPtr& input)
    {
        return input->dom_code;
    }

    static decltype(::blink::mojom::KeyData::windows_key_code) windows_key_code(const ::blink::mojom::KeyDataPtr& input)
    {
        return input->windows_key_code;
    }

    static decltype(::blink::mojom::KeyData::native_key_code) native_key_code(const ::blink::mojom::KeyDataPtr& input)
    {
        return input->native_key_code;
    }

    static decltype(::blink::mojom::KeyData::is_system_key) is_system_key(const ::blink::mojom::KeyDataPtr& input)
    {
        return input->is_system_key;
    }

    static decltype(::blink::mojom::KeyData::is_browser_shortcut) is_browser_shortcut(const ::blink::mojom::KeyDataPtr& input)
    {
        return input->is_browser_shortcut;
    }

    static const decltype(::blink::mojom::KeyData::text)& text(const ::blink::mojom::KeyDataPtr& input)
    {
        return input->text;
    }

    static const decltype(::blink::mojom::KeyData::unmodified_text)& unmodified_text(const ::blink::mojom::KeyDataPtr& input)
    {
        return input->unmodified_text;
    }

    static bool Read(::blink::mojom::KeyData::DataView input, ::blink::mojom::KeyDataPtr* output);
};

template <> struct BLINK_COMMON_EXPORT StructTraits<::blink::mojom::PointerData::DataView, ::blink::mojom::PointerDataPtr> {
    static bool IsNull(const ::blink::mojom::PointerDataPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::PointerDataPtr* output)
    {
        output->reset();
    }

    static decltype(::blink::mojom::PointerData::pointer_id) pointer_id(const ::blink::mojom::PointerDataPtr& input)
    {
        return input->pointer_id;
    }

    static decltype(::blink::mojom::PointerData::force) force(const ::blink::mojom::PointerDataPtr& input)
    {
        return input->force;
    }

    static decltype(::blink::mojom::PointerData::tilt_x) tilt_x(const ::blink::mojom::PointerDataPtr& input)
    {
        return input->tilt_x;
    }

    static decltype(::blink::mojom::PointerData::tilt_y) tilt_y(const ::blink::mojom::PointerDataPtr& input)
    {
        return input->tilt_y;
    }

    static decltype(::blink::mojom::PointerData::tangential_pressure) tangential_pressure(const ::blink::mojom::PointerDataPtr& input)
    {
        return input->tangential_pressure;
    }

    static decltype(::blink::mojom::PointerData::twist) twist(const ::blink::mojom::PointerDataPtr& input)
    {
        return input->twist;
    }

    static decltype(::blink::mojom::PointerData::button) button(const ::blink::mojom::PointerDataPtr& input)
    {
        return input->button;
    }

    static decltype(::blink::mojom::PointerData::pointer_type) pointer_type(const ::blink::mojom::PointerDataPtr& input)
    {
        return input->pointer_type;
    }

    static decltype(::blink::mojom::PointerData::movement_x) movement_x(const ::blink::mojom::PointerDataPtr& input)
    {
        return input->movement_x;
    }

    static decltype(::blink::mojom::PointerData::movement_y) movement_y(const ::blink::mojom::PointerDataPtr& input)
    {
        return input->movement_y;
    }

    static decltype(::blink::mojom::PointerData::is_raw_movement_event) is_raw_movement_event(const ::blink::mojom::PointerDataPtr& input)
    {
        return input->is_raw_movement_event;
    }

    static const decltype(::blink::mojom::PointerData::widget_position)& widget_position(const ::blink::mojom::PointerDataPtr& input)
    {
        return input->widget_position;
    }

    static const decltype(::blink::mojom::PointerData::screen_position)& screen_position(const ::blink::mojom::PointerDataPtr& input)
    {
        return input->screen_position;
    }

    static const decltype(::blink::mojom::PointerData::mouse_data)& mouse_data(const ::blink::mojom::PointerDataPtr& input)
    {
        return input->mouse_data;
    }

    static decltype(::blink::mojom::PointerData::device_id) device_id(const ::blink::mojom::PointerDataPtr& input)
    {
        return input->device_id;
    }

    static bool Read(::blink::mojom::PointerData::DataView input, ::blink::mojom::PointerDataPtr* output);
};

template <> struct BLINK_COMMON_EXPORT StructTraits<::blink::mojom::WheelData::DataView, ::blink::mojom::WheelDataPtr> {
    static bool IsNull(const ::blink::mojom::WheelDataPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::WheelDataPtr* output)
    {
        output->reset();
    }

    static decltype(::blink::mojom::WheelData::delta_x) delta_x(const ::blink::mojom::WheelDataPtr& input)
    {
        return input->delta_x;
    }

    static decltype(::blink::mojom::WheelData::delta_y) delta_y(const ::blink::mojom::WheelDataPtr& input)
    {
        return input->delta_y;
    }

    static decltype(::blink::mojom::WheelData::wheel_ticks_x) wheel_ticks_x(const ::blink::mojom::WheelDataPtr& input)
    {
        return input->wheel_ticks_x;
    }

    static decltype(::blink::mojom::WheelData::wheel_ticks_y) wheel_ticks_y(const ::blink::mojom::WheelDataPtr& input)
    {
        return input->wheel_ticks_y;
    }

    static decltype(::blink::mojom::WheelData::acceleration_ratio_x) acceleration_ratio_x(const ::blink::mojom::WheelDataPtr& input)
    {
        return input->acceleration_ratio_x;
    }

    static decltype(::blink::mojom::WheelData::acceleration_ratio_y) acceleration_ratio_y(const ::blink::mojom::WheelDataPtr& input)
    {
        return input->acceleration_ratio_y;
    }

    static decltype(::blink::mojom::WheelData::phase) phase(const ::blink::mojom::WheelDataPtr& input)
    {
        return input->phase;
    }

    static decltype(::blink::mojom::WheelData::momentum_phase) momentum_phase(const ::blink::mojom::WheelDataPtr& input)
    {
        return input->momentum_phase;
    }

    static decltype(::blink::mojom::WheelData::cancelable) cancelable(const ::blink::mojom::WheelDataPtr& input)
    {
        return input->cancelable;
    }

    static decltype(::blink::mojom::WheelData::event_action) event_action(const ::blink::mojom::WheelDataPtr& input)
    {
        return input->event_action;
    }

    static decltype(::blink::mojom::WheelData::delta_units) delta_units(const ::blink::mojom::WheelDataPtr& input)
    {
        return input->delta_units;
    }

    static bool Read(::blink::mojom::WheelData::DataView input, ::blink::mojom::WheelDataPtr* output);
};

template <> struct BLINK_COMMON_EXPORT StructTraits<::blink::mojom::MouseData::DataView, ::blink::mojom::MouseDataPtr> {
    static bool IsNull(const ::blink::mojom::MouseDataPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::MouseDataPtr* output)
    {
        output->reset();
    }

    static decltype(::blink::mojom::MouseData::click_count) click_count(const ::blink::mojom::MouseDataPtr& input)
    {
        return input->click_count;
    }

    static const decltype(::blink::mojom::MouseData::wheel_data)& wheel_data(const ::blink::mojom::MouseDataPtr& input)
    {
        return input->wheel_data;
    }

    static bool Read(::blink::mojom::MouseData::DataView input, ::blink::mojom::MouseDataPtr* output);
};

template <> struct BLINK_COMMON_EXPORT StructTraits<::blink::mojom::ScrollData::DataView, ::blink::mojom::ScrollDataPtr> {
    static bool IsNull(const ::blink::mojom::ScrollDataPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::ScrollDataPtr* output)
    {
        output->reset();
    }

    static decltype(::blink::mojom::ScrollData::delta_x) delta_x(const ::blink::mojom::ScrollDataPtr& input)
    {
        return input->delta_x;
    }

    static decltype(::blink::mojom::ScrollData::delta_y) delta_y(const ::blink::mojom::ScrollDataPtr& input)
    {
        return input->delta_y;
    }

    static decltype(::blink::mojom::ScrollData::delta_units) delta_units(const ::blink::mojom::ScrollDataPtr& input)
    {
        return input->delta_units;
    }

    static decltype(::blink::mojom::ScrollData::target_viewport) target_viewport(const ::blink::mojom::ScrollDataPtr& input)
    {
        return input->target_viewport;
    }

    static decltype(::blink::mojom::ScrollData::inertial_phase) inertial_phase(const ::blink::mojom::ScrollDataPtr& input)
    {
        return input->inertial_phase;
    }

    static decltype(::blink::mojom::ScrollData::synthetic) synthetic(const ::blink::mojom::ScrollDataPtr& input)
    {
        return input->synthetic;
    }

    static decltype(::blink::mojom::ScrollData::pointer_count) pointer_count(const ::blink::mojom::ScrollDataPtr& input)
    {
        return input->pointer_count;
    }

    static decltype(::blink::mojom::ScrollData::cursor_control) cursor_control(const ::blink::mojom::ScrollDataPtr& input)
    {
        return input->cursor_control;
    }

    static bool Read(::blink::mojom::ScrollData::DataView input, ::blink::mojom::ScrollDataPtr* output);
};

template <> struct BLINK_COMMON_EXPORT StructTraits<::blink::mojom::PinchBeginData::DataView, ::blink::mojom::PinchBeginDataPtr> {
    static bool IsNull(const ::blink::mojom::PinchBeginDataPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::PinchBeginDataPtr* output)
    {
        output->reset();
    }

    static decltype(::blink::mojom::PinchBeginData::needs_wheel_event) needs_wheel_event(const ::blink::mojom::PinchBeginDataPtr& input)
    {
        return input->needs_wheel_event;
    }

    static bool Read(::blink::mojom::PinchBeginData::DataView input, ::blink::mojom::PinchBeginDataPtr* output);
};

template <> struct BLINK_COMMON_EXPORT StructTraits<::blink::mojom::PinchUpdateData::DataView, ::blink::mojom::PinchUpdateDataPtr> {
    static bool IsNull(const ::blink::mojom::PinchUpdateDataPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::PinchUpdateDataPtr* output)
    {
        output->reset();
    }

    static decltype(::blink::mojom::PinchUpdateData::scale) scale(const ::blink::mojom::PinchUpdateDataPtr& input)
    {
        return input->scale;
    }

    static decltype(::blink::mojom::PinchUpdateData::zoom_disabled) zoom_disabled(const ::blink::mojom::PinchUpdateDataPtr& input)
    {
        return input->zoom_disabled;
    }

    static decltype(::blink::mojom::PinchUpdateData::needs_wheel_event) needs_wheel_event(const ::blink::mojom::PinchUpdateDataPtr& input)
    {
        return input->needs_wheel_event;
    }

    static bool Read(::blink::mojom::PinchUpdateData::DataView input, ::blink::mojom::PinchUpdateDataPtr* output);
};

template <> struct BLINK_COMMON_EXPORT StructTraits<::blink::mojom::PinchEndData::DataView, ::blink::mojom::PinchEndDataPtr> {
    static bool IsNull(const ::blink::mojom::PinchEndDataPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::PinchEndDataPtr* output)
    {
        output->reset();
    }

    static decltype(::blink::mojom::PinchEndData::needs_wheel_event) needs_wheel_event(const ::blink::mojom::PinchEndDataPtr& input)
    {
        return input->needs_wheel_event;
    }

    static bool Read(::blink::mojom::PinchEndData::DataView input, ::blink::mojom::PinchEndDataPtr* output);
};

template <> struct BLINK_COMMON_EXPORT StructTraits<::blink::mojom::FlingData::DataView, ::blink::mojom::FlingDataPtr> {
    static bool IsNull(const ::blink::mojom::FlingDataPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::FlingDataPtr* output)
    {
        output->reset();
    }

    static decltype(::blink::mojom::FlingData::velocity_x) velocity_x(const ::blink::mojom::FlingDataPtr& input)
    {
        return input->velocity_x;
    }

    static decltype(::blink::mojom::FlingData::velocity_y) velocity_y(const ::blink::mojom::FlingDataPtr& input)
    {
        return input->velocity_y;
    }

    static decltype(::blink::mojom::FlingData::target_viewport) target_viewport(const ::blink::mojom::FlingDataPtr& input)
    {
        return input->target_viewport;
    }

    static decltype(::blink::mojom::FlingData::prevent_boosting) prevent_boosting(const ::blink::mojom::FlingDataPtr& input)
    {
        return input->prevent_boosting;
    }

    static bool Read(::blink::mojom::FlingData::DataView input, ::blink::mojom::FlingDataPtr* output);
};

template <> struct BLINK_COMMON_EXPORT StructTraits<::blink::mojom::TapData::DataView, ::blink::mojom::TapDataPtr> {
    static bool IsNull(const ::blink::mojom::TapDataPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::TapDataPtr* output)
    {
        output->reset();
    }

    static decltype(::blink::mojom::TapData::tap_count) tap_count(const ::blink::mojom::TapDataPtr& input)
    {
        return input->tap_count;
    }

    static decltype(::blink::mojom::TapData::needs_wheel_event) needs_wheel_event(const ::blink::mojom::TapDataPtr& input)
    {
        return input->needs_wheel_event;
    }

    static bool Read(::blink::mojom::TapData::DataView input, ::blink::mojom::TapDataPtr* output);
};

template <> struct BLINK_COMMON_EXPORT StructTraits<::blink::mojom::TapDownData::DataView, ::blink::mojom::TapDownDataPtr> {
    static bool IsNull(const ::blink::mojom::TapDownDataPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::TapDownDataPtr* output)
    {
        output->reset();
    }

    static decltype(::blink::mojom::TapDownData::tap_down_count) tap_down_count(const ::blink::mojom::TapDownDataPtr& input)
    {
        return input->tap_down_count;
    }

    static bool Read(::blink::mojom::TapDownData::DataView input, ::blink::mojom::TapDownDataPtr* output);
};

template <> struct BLINK_COMMON_EXPORT StructTraits<::blink::mojom::GestureData::DataView, ::blink::mojom::GestureDataPtr> {
    static bool IsNull(const ::blink::mojom::GestureDataPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::GestureDataPtr* output)
    {
        output->reset();
    }

    static const decltype(::blink::mojom::GestureData::screen_position)& screen_position(const ::blink::mojom::GestureDataPtr& input)
    {
        return input->screen_position;
    }

    static const decltype(::blink::mojom::GestureData::widget_position)& widget_position(const ::blink::mojom::GestureDataPtr& input)
    {
        return input->widget_position;
    }

    static decltype(::blink::mojom::GestureData::source_device) source_device(const ::blink::mojom::GestureDataPtr& input)
    {
        return input->source_device;
    }

    static decltype(::blink::mojom::GestureData::is_source_touch_event_set_blocking) is_source_touch_event_set_blocking(
        const ::blink::mojom::GestureDataPtr& input)
    {
        return input->is_source_touch_event_set_blocking;
    }

    static decltype(::blink::mojom::GestureData::primary_pointer_type) primary_pointer_type(const ::blink::mojom::GestureDataPtr& input)
    {
        return input->primary_pointer_type;
    }

    static decltype(::blink::mojom::GestureData::primary_unique_touch_event_id) primary_unique_touch_event_id(const ::blink::mojom::GestureDataPtr& input)
    {
        return input->primary_unique_touch_event_id;
    }

    static decltype(::blink::mojom::GestureData::unique_touch_event_id) unique_touch_event_id(const ::blink::mojom::GestureDataPtr& input)
    {
        return input->unique_touch_event_id;
    }

    static const decltype(::blink::mojom::GestureData::contact_size)& contact_size(const ::blink::mojom::GestureDataPtr& input)
    {
        return input->contact_size;
    }

    static const decltype(::blink::mojom::GestureData::scroll_data)& scroll_data(const ::blink::mojom::GestureDataPtr& input)
    {
        return input->scroll_data;
    }

    static const decltype(::blink::mojom::GestureData::pinch_begin_data)& pinch_begin_data(const ::blink::mojom::GestureDataPtr& input)
    {
        return input->pinch_begin_data;
    }

    static const decltype(::blink::mojom::GestureData::pinch_update_data)& pinch_update_data(const ::blink::mojom::GestureDataPtr& input)
    {
        return input->pinch_update_data;
    }

    static const decltype(::blink::mojom::GestureData::pinch_end_data)& pinch_end_data(const ::blink::mojom::GestureDataPtr& input)
    {
        return input->pinch_end_data;
    }

    static const decltype(::blink::mojom::GestureData::tap_data)& tap_data(const ::blink::mojom::GestureDataPtr& input)
    {
        return input->tap_data;
    }

    static const decltype(::blink::mojom::GestureData::tap_down_data)& tap_down_data(const ::blink::mojom::GestureDataPtr& input)
    {
        return input->tap_down_data;
    }

    static const decltype(::blink::mojom::GestureData::fling_data)& fling_data(const ::blink::mojom::GestureDataPtr& input)
    {
        return input->fling_data;
    }

    static bool Read(::blink::mojom::GestureData::DataView input, ::blink::mojom::GestureDataPtr* output);
};

template <> struct BLINK_COMMON_EXPORT StructTraits<::blink::mojom::TouchPoint::DataView, ::blink::mojom::TouchPointPtr> {
    static bool IsNull(const ::blink::mojom::TouchPointPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::TouchPointPtr* output)
    {
        output->reset();
    }

    static decltype(::blink::mojom::TouchPoint::state) state(const ::blink::mojom::TouchPointPtr& input)
    {
        return input->state;
    }

    static decltype(::blink::mojom::TouchPoint::radius_x) radius_x(const ::blink::mojom::TouchPointPtr& input)
    {
        return input->radius_x;
    }

    static decltype(::blink::mojom::TouchPoint::radius_y) radius_y(const ::blink::mojom::TouchPointPtr& input)
    {
        return input->radius_y;
    }

    static decltype(::blink::mojom::TouchPoint::rotation_angle) rotation_angle(const ::blink::mojom::TouchPointPtr& input)
    {
        return input->rotation_angle;
    }

    static const decltype(::blink::mojom::TouchPoint::pointer_data)& pointer_data(const ::blink::mojom::TouchPointPtr& input)
    {
        return input->pointer_data;
    }

    static bool Read(::blink::mojom::TouchPoint::DataView input, ::blink::mojom::TouchPointPtr* output);
};

template <> struct BLINK_COMMON_EXPORT StructTraits<::blink::mojom::TouchData::DataView, ::blink::mojom::TouchDataPtr> {
    static bool IsNull(const ::blink::mojom::TouchDataPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::TouchDataPtr* output)
    {
        output->reset();
    }

    static decltype(::blink::mojom::TouchData::cancelable) cancelable(const ::blink::mojom::TouchDataPtr& input)
    {
        return input->cancelable;
    }

    static decltype(::blink::mojom::TouchData::moved_beyond_slop_region) moved_beyond_slop_region(const ::blink::mojom::TouchDataPtr& input)
    {
        return input->moved_beyond_slop_region;
    }

    static decltype(::blink::mojom::TouchData::touch_start_or_first_move) touch_start_or_first_move(const ::blink::mojom::TouchDataPtr& input)
    {
        return input->touch_start_or_first_move;
    }

    static decltype(::blink::mojom::TouchData::hovering) hovering(const ::blink::mojom::TouchDataPtr& input)
    {
        return input->hovering;
    }

    static decltype(::blink::mojom::TouchData::unique_touch_event_id) unique_touch_event_id(const ::blink::mojom::TouchDataPtr& input)
    {
        return input->unique_touch_event_id;
    }

    static const decltype(::blink::mojom::TouchData::touches)& touches(const ::blink::mojom::TouchDataPtr& input)
    {
        return input->touches;
    }

    static bool Read(::blink::mojom::TouchData::DataView input, ::blink::mojom::TouchDataPtr* output);
};

template <> struct BLINK_COMMON_EXPORT StructTraits<::blink::mojom::Event::DataView, ::blink::mojom::EventPtr> {
    static bool IsNull(const ::blink::mojom::EventPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::EventPtr* output)
    {
        output->reset();
    }

    static decltype(::blink::mojom::Event::type) type(const ::blink::mojom::EventPtr& input)
    {
        return input->type;
    }

    static decltype(::blink::mojom::Event::modifiers) modifiers(const ::blink::mojom::EventPtr& input)
    {
        return input->modifiers;
    }

    static const decltype(::blink::mojom::Event::timestamp)& timestamp(const ::blink::mojom::EventPtr& input)
    {
        return input->timestamp;
    }

    static const decltype(::blink::mojom::Event::latency)& latency(const ::blink::mojom::EventPtr& input)
    {
        return input->latency;
    }

    static const decltype(::blink::mojom::Event::event_latency_metadata)& event_latency_metadata(const ::blink::mojom::EventPtr& input)
    {
        return input->event_latency_metadata;
    }

    static const decltype(::blink::mojom::Event::key_data)& key_data(const ::blink::mojom::EventPtr& input)
    {
        return input->key_data;
    }

    static const decltype(::blink::mojom::Event::pointer_data)& pointer_data(const ::blink::mojom::EventPtr& input)
    {
        return input->pointer_data;
    }

    static const decltype(::blink::mojom::Event::gesture_data)& gesture_data(const ::blink::mojom::EventPtr& input)
    {
        return input->gesture_data;
    }

    static const decltype(::blink::mojom::Event::touch_data)& touch_data(const ::blink::mojom::EventPtr& input)
    {
        return input->touch_data;
    }

    static bool Read(::blink::mojom::Event::DataView input, ::blink::mojom::EventPtr* output);
};

template <> struct BLINK_COMMON_EXPORT StructTraits<::blink::mojom::DidOverscrollParams::DataView, ::blink::mojom::DidOverscrollParamsPtr> {
    static bool IsNull(const ::blink::mojom::DidOverscrollParamsPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::DidOverscrollParamsPtr* output)
    {
        output->reset();
    }

    static const decltype(::blink::mojom::DidOverscrollParams::accumulated_overscroll)& accumulated_overscroll(
        const ::blink::mojom::DidOverscrollParamsPtr& input)
    {
        return input->accumulated_overscroll;
    }

    static const decltype(::blink::mojom::DidOverscrollParams::latest_overscroll_delta)& latest_overscroll_delta(
        const ::blink::mojom::DidOverscrollParamsPtr& input)
    {
        return input->latest_overscroll_delta;
    }

    static const decltype(::blink::mojom::DidOverscrollParams::current_fling_velocity)& current_fling_velocity(
        const ::blink::mojom::DidOverscrollParamsPtr& input)
    {
        return input->current_fling_velocity;
    }

    static const decltype(::blink::mojom::DidOverscrollParams::causal_event_viewport_point)& causal_event_viewport_point(
        const ::blink::mojom::DidOverscrollParamsPtr& input)
    {
        return input->causal_event_viewport_point;
    }

    static const decltype(::blink::mojom::DidOverscrollParams::overscroll_behavior)& overscroll_behavior(const ::blink::mojom::DidOverscrollParamsPtr& input)
    {
        return input->overscroll_behavior;
    }

    static bool Read(::blink::mojom::DidOverscrollParams::DataView input, ::blink::mojom::DidOverscrollParamsPtr* output);
};

template <> struct BLINK_COMMON_EXPORT StructTraits<::blink::mojom::TouchActionOptional::DataView, ::blink::mojom::TouchActionOptionalPtr> {
    static bool IsNull(const ::blink::mojom::TouchActionOptionalPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::TouchActionOptionalPtr* output)
    {
        output->reset();
    }

    static decltype(::blink::mojom::TouchActionOptional::touch_action) touch_action(const ::blink::mojom::TouchActionOptionalPtr& input)
    {
        return input->touch_action;
    }

    static bool Read(::blink::mojom::TouchActionOptional::DataView input, ::blink::mojom::TouchActionOptionalPtr* output);
};

template <> struct BLINK_COMMON_EXPORT StructTraits<::blink::mojom::EditCommand::DataView, ::blink::mojom::EditCommandPtr> {
    static bool IsNull(const ::blink::mojom::EditCommandPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::EditCommandPtr* output)
    {
        output->reset();
    }

    static const decltype(::blink::mojom::EditCommand::name)& name(const ::blink::mojom::EditCommandPtr& input)
    {
        return input->name;
    }

    static const decltype(::blink::mojom::EditCommand::value)& value(const ::blink::mojom::EditCommandPtr& input)
    {
        return input->value;
    }

    static bool Read(::blink::mojom::EditCommand::DataView input, ::blink::mojom::EditCommandPtr* output);
};

template <> struct BLINK_COMMON_EXPORT StructTraits<::blink::mojom::SelectAroundCaretResult::DataView, ::blink::mojom::SelectAroundCaretResultPtr> {
    static bool IsNull(const ::blink::mojom::SelectAroundCaretResultPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::SelectAroundCaretResultPtr* output)
    {
        output->reset();
    }

    static decltype(::blink::mojom::SelectAroundCaretResult::extended_start_adjust) extended_start_adjust(
        const ::blink::mojom::SelectAroundCaretResultPtr& input)
    {
        return input->extended_start_adjust;
    }

    static decltype(::blink::mojom::SelectAroundCaretResult::extended_end_adjust) extended_end_adjust(const ::blink::mojom::SelectAroundCaretResultPtr& input)
    {
        return input->extended_end_adjust;
    }

    static decltype(::blink::mojom::SelectAroundCaretResult::word_start_adjust) word_start_adjust(const ::blink::mojom::SelectAroundCaretResultPtr& input)
    {
        return input->word_start_adjust;
    }

    static decltype(::blink::mojom::SelectAroundCaretResult::word_end_adjust) word_end_adjust(const ::blink::mojom::SelectAroundCaretResultPtr& input)
    {
        return input->word_end_adjust;
    }

    static bool Read(::blink::mojom::SelectAroundCaretResult::DataView input, ::blink::mojom::SelectAroundCaretResultPtr* output);
};

} // namespace mojo

#endif // THIRD_PARTY_BLINK_PUBLIC_MOJOM_INPUT_INPUT_HANDLER_MOJOM_H_
