// third_party/blink/public/mojom/mediastream/media_stream.mojom-blink.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef THIRD_PARTY_BLINK_PUBLIC_MOJOM_MEDIASTREAM_MEDIA_STREAM_MOJOM_BLINK_H_
#define THIRD_PARTY_BLINK_PUBLIC_MOJOM_MEDIASTREAM_MEDIA_STREAM_MOJOM_BLINK_H_

#include <stdint.h>

#include <limits>
#include <optional>
#include <type_traits>
#include <utility>

#include "base/types/cxx23_to_underlying.h"
#include "mojo/public/cpp/bindings/clone_traits.h"
#include "mojo/public/cpp/bindings/equals_traits.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/struct_ptr.h"
#include "mojo/public/cpp/bindings/struct_traits.h"
#include "mojo/public/cpp/bindings/union_traits.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "third_party/blink/public/mojom/mediastream/media_stream.mojom-features.h" // IWYU pragma: export
#include "third_party/blink/public/mojom/mediastream/media_stream.mojom-shared.h" // IWYU pragma: export
#include "third_party/blink/public/mojom/mediastream/media_stream.mojom-blink-forward.h" // IWYU pragma: export
#include "media/capture/mojom/video_capture_types.mojom-blink.h"
#include "media/mojo/mojom/audio_parameters.mojom-blink.h"
#include "media/mojo/mojom/display_media_information.mojom-blink.h"
#include "mojo/public/mojom/base/token.mojom-blink.h"
#include "mojo/public/mojom/base/unguessable_token.mojom-blink.h"
#include "third_party/blink/public/mojom/mediastream/media_devices.mojom-blink-forward.h"

#include "mojo/public/cpp/bindings/lib/wtf_clone_equals_util.h"
#include "mojo/public/cpp/bindings/lib/wtf_hash_util.h"
#include "third_party/blink/renderer/platform/wtf/hash_functions.h"
#include "third_party/blink/renderer/platform/wtf/text/wtf_string.h"

#include "mojo/public/cpp/bindings/lib/control_message_handler.h"
#include "mojo/public/cpp/bindings/lib/message_size_estimator.h"
#include "mojo/public/cpp/bindings/raw_ptr_impl_ref_traits.h"

#include "mojo/public/cpp/bindings/lib/native_enum_serialization.h"
#include "mojo/public/cpp/bindings/lib/native_struct_serialization.h"
#include "third_party/blink/public/common/mediastream/media_stream_mojom_traits.h"
#include "third_party/blink/renderer/platform/platform_export.h"
#if !BLINK_MOJO_IMPL && !INSIDE_BLINK
#error "File must only be imported inside blink"
#endif

namespace blink::mojom::blink {

class MediaStreamDeviceObserverProxy;

template <typename ImplRefTraits> class MediaStreamDeviceObserverStub;

class MediaStreamDeviceObserverRequestValidator;

class PLATFORM_EXPORT MediaStreamDeviceObserver : public MediaStreamDeviceObserverInterfaceBase {
public:
    using IPCStableHashFunction = uint32_t (*)();

    static const char Name_[];
    static IPCStableHashFunction MessageToMethodInfo_(mojo::Message& message);
    static const char* MessageToMethodName_(mojo::Message& message);
    static constexpr uint32_t Version_ = 0;
    static constexpr bool PassesAssociatedKinds_ = false;
    static constexpr bool HasUninterruptableMethods_ = false;

    using Base_ = MediaStreamDeviceObserverInterfaceBase;
    using Proxy_ = MediaStreamDeviceObserverProxy;

    template <typename ImplRefTraits> using Stub_ = MediaStreamDeviceObserverStub<ImplRefTraits>;

    using RequestValidator_ = MediaStreamDeviceObserverRequestValidator;
    using ResponseValidator_ = mojo::PassThroughFilter;
    enum MethodMinVersions : uint32_t {
        kOnDeviceStoppedMinVersion = 0,
        kOnDeviceChangedMinVersion = 0,
        kOnDeviceRequestStateChangeMinVersion = 0,
        kOnDeviceCaptureConfigurationChangeMinVersion = 0,
        kOnDeviceCaptureHandleChangeMinVersion = 0,
        kOnZoomLevelChangeMinVersion = 0,
    };

// crbug.com/1340245 - this causes binary size bloat on Fuchsia, and we're OK
// with not having this data in traces there.
#if !BUILDFLAG(IS_FUCHSIA)
    struct OnDeviceStopped_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct OnDeviceChanged_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct OnDeviceRequestStateChange_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct OnDeviceCaptureConfigurationChange_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct OnDeviceCaptureHandleChange_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct OnZoomLevelChange_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
#endif // !BUILDFLAG(IS_FUCHSIA)
    virtual ~MediaStreamDeviceObserver() = default;

    virtual void OnDeviceStopped(const WTF::String& label, const ::blink::MediaStreamDevice& device) = 0;

    virtual void OnDeviceChanged(const WTF::String& label, const ::blink::MediaStreamDevice& old_device, const ::blink::MediaStreamDevice& new_device) = 0;

    virtual void OnDeviceRequestStateChange(const WTF::String& label, const ::blink::MediaStreamDevice& device, MediaStreamStateChange new_state) = 0;

    virtual void OnDeviceCaptureConfigurationChange(const WTF::String& label, const ::blink::MediaStreamDevice& device) = 0;

    virtual void OnDeviceCaptureHandleChange(const WTF::String& label, const ::blink::MediaStreamDevice& device) = 0;

    virtual void OnZoomLevelChange(const WTF::String& label, const ::blink::MediaStreamDevice& device, int32_t zoom_level) = 0;
};

class MediaStreamDispatcherHostProxy;

template <typename ImplRefTraits> class MediaStreamDispatcherHostStub;

class MediaStreamDispatcherHostRequestValidator;
class MediaStreamDispatcherHostResponseValidator;

class PLATFORM_EXPORT MediaStreamDispatcherHost : public MediaStreamDispatcherHostInterfaceBase {
public:
    using IPCStableHashFunction = uint32_t (*)();

    static const char Name_[];
    static IPCStableHashFunction MessageToMethodInfo_(mojo::Message& message);
    static const char* MessageToMethodName_(mojo::Message& message);
    static constexpr uint32_t Version_ = 0;
    static constexpr bool PassesAssociatedKinds_ = false;
    static inline constexpr uint32_t kSyncMethodOrdinals[] = { 11 };
    static constexpr bool HasUninterruptableMethods_ = false;

    using Base_ = MediaStreamDispatcherHostInterfaceBase;
    using Proxy_ = MediaStreamDispatcherHostProxy;

    template <typename ImplRefTraits> using Stub_ = MediaStreamDispatcherHostStub<ImplRefTraits>;

    using RequestValidator_ = MediaStreamDispatcherHostRequestValidator;
    using ResponseValidator_ = MediaStreamDispatcherHostResponseValidator;
    enum MethodMinVersions : uint32_t {
        kGenerateStreamsMinVersion = 0,
        kFocusCapturedSurfaceMinVersion = 0,
        kCancelRequestMinVersion = 0,
        kStopStreamDeviceMinVersion = 0,
        kOpenDeviceMinVersion = 0,
        kCloseDeviceMinVersion = 0,
        kSetCapturingLinkSecuredMinVersion = 0,
        kApplySubCaptureTargetMinVersion = 0,
        kSendWheelMinVersion = 0,
        kSetZoomLevelMinVersion = 0,
        kRequestCapturedSurfaceControlPermissionMinVersion = 0,
        kGetOpenDeviceMinVersion = 0,
        kKeepDeviceAliveForTransferMinVersion = 0,
    };

// crbug.com/1340245 - this causes binary size bloat on Fuchsia, and we're OK
// with not having this data in traces there.
#if !BUILDFLAG(IS_FUCHSIA)
    struct GenerateStreams_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct FocusCapturedSurface_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct CancelRequest_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct StopStreamDevice_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct OpenDevice_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct CloseDevice_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct SetCapturingLinkSecured_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct ApplySubCaptureTarget_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct SendWheel_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct SetZoomLevel_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct RequestCapturedSurfaceControlPermission_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct GetOpenDevice_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct KeepDeviceAliveForTransfer_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
#endif // !BUILDFLAG(IS_FUCHSIA)
    virtual ~MediaStreamDispatcherHost() = default;

    using GenerateStreamsCallback = base::OnceCallback<void(MediaStreamRequestResult, const WTF::String&, StreamDevicesSetPtr, bool)>;

    virtual void GenerateStreams(int32_t request_id, const ::blink::StreamControls& controls, bool user_gesture,
        StreamSelectionInfoPtr audio_stream_selection_info, GenerateStreamsCallback callback)
        = 0;

    virtual void FocusCapturedSurface(const WTF::String& label, bool focus) = 0;

    virtual void CancelRequest(int32_t request_id) = 0;

    virtual void StopStreamDevice(const WTF::String& device_id, const std::optional<::base::UnguessableToken>& session_id) = 0;

    using OpenDeviceCallback = base::OnceCallback<void(bool, const WTF::String&, const ::blink::MediaStreamDevice&)>;

    virtual void OpenDevice(int32_t request_id, const WTF::String& device_id, MediaStreamType type, OpenDeviceCallback callback) = 0;

    virtual void CloseDevice(const WTF::String& label) = 0;

    virtual void SetCapturingLinkSecured(const std::optional<::base::UnguessableToken>& session_id, MediaStreamType type, bool is_secure) = 0;

    using ApplySubCaptureTargetCallback = base::OnceCallback<void(::media::mojom::blink::ApplySubCaptureTargetResult)>;

    virtual void ApplySubCaptureTarget(const ::base::UnguessableToken& session_id, ::media::mojom::blink::SubCaptureTargetType type,
        const ::base::Token& sub_capture_target, uint32_t sub_capture_target_version, ApplySubCaptureTargetCallback callback)
        = 0;

    using SendWheelCallback = base::OnceCallback<void(CapturedSurfaceControlResult)>;

    virtual void SendWheel(const ::base::UnguessableToken& session_id, CapturedWheelActionPtr action, SendWheelCallback callback) = 0;

    using SetZoomLevelCallback = base::OnceCallback<void(CapturedSurfaceControlResult)>;

    virtual void SetZoomLevel(const ::base::UnguessableToken& session_id, int32_t zoom_level, SetZoomLevelCallback callback) = 0;

    using RequestCapturedSurfaceControlPermissionCallback = base::OnceCallback<void(CapturedSurfaceControlResult)>;

    virtual void RequestCapturedSurfaceControlPermission(const ::base::UnguessableToken& session_id, RequestCapturedSurfaceControlPermissionCallback callback)
        = 0;

    // Sync method. This signature is used by the client side; the service side
    // should implement the signature with callback below.

    virtual bool GetOpenDevice(int32_t request_id, const ::base::UnguessableToken& session_id, const ::base::UnguessableToken& transfer_id,
        MediaStreamRequestResult* out_result, GetOpenDeviceResponsePtr* out_response);

    using GetOpenDeviceCallback = base::OnceCallback<void(MediaStreamRequestResult, GetOpenDeviceResponsePtr)>;

    virtual void GetOpenDevice(
        int32_t request_id, const ::base::UnguessableToken& session_id, const ::base::UnguessableToken& transfer_id, GetOpenDeviceCallback callback)
        = 0;

    using KeepDeviceAliveForTransferCallback = base::OnceCallback<void(bool)>;

    virtual void KeepDeviceAliveForTransfer(
        const ::base::UnguessableToken& session_id, const ::base::UnguessableToken& transfer_id, KeepDeviceAliveForTransferCallback callback)
        = 0;
};

class MediaStreamTrackMetricsHostProxy;

template <typename ImplRefTraits> class MediaStreamTrackMetricsHostStub;

class MediaStreamTrackMetricsHostRequestValidator;

class PLATFORM_EXPORT MediaStreamTrackMetricsHost : public MediaStreamTrackMetricsHostInterfaceBase {
public:
    using IPCStableHashFunction = uint32_t (*)();

    static const char Name_[];
    static IPCStableHashFunction MessageToMethodInfo_(mojo::Message& message);
    static const char* MessageToMethodName_(mojo::Message& message);
    static constexpr uint32_t Version_ = 0;
    static constexpr bool PassesAssociatedKinds_ = false;
    static constexpr bool HasUninterruptableMethods_ = false;

    using Base_ = MediaStreamTrackMetricsHostInterfaceBase;
    using Proxy_ = MediaStreamTrackMetricsHostProxy;

    template <typename ImplRefTraits> using Stub_ = MediaStreamTrackMetricsHostStub<ImplRefTraits>;

    using RequestValidator_ = MediaStreamTrackMetricsHostRequestValidator;
    using ResponseValidator_ = mojo::PassThroughFilter;
    enum MethodMinVersions : uint32_t {
        kAddTrackMinVersion = 0,
        kRemoveTrackMinVersion = 0,
    };

// crbug.com/1340245 - this causes binary size bloat on Fuchsia, and we're OK
// with not having this data in traces there.
#if !BUILDFLAG(IS_FUCHSIA)
    struct AddTrack_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct RemoveTrack_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
#endif // !BUILDFLAG(IS_FUCHSIA)
    virtual ~MediaStreamTrackMetricsHost() = default;

    virtual void AddTrack(uint64_t id, bool is_audio, bool is_remote) = 0;

    virtual void RemoveTrack(uint64_t id) = 0;
};

//class PLATFORM_EXPORT MediaStreamDeviceObserverProxy : public MediaStreamDeviceObserver {
//public:
//    using InterfaceType = MediaStreamDeviceObserver;
//
//    explicit MediaStreamDeviceObserverProxy(mojo::MessageReceiverWithResponder* receiver);
//
//    void OnDeviceStopped(const WTF::String& label, const ::blink::MediaStreamDevice& device) final;
//
//    void OnDeviceChanged(const WTF::String& label, const ::blink::MediaStreamDevice& old_device, const ::blink::MediaStreamDevice& new_device) final;
//
//    void OnDeviceRequestStateChange(const WTF::String& label, const ::blink::MediaStreamDevice& device, MediaStreamStateChange new_state) final;
//
//    void OnDeviceCaptureConfigurationChange(const WTF::String& label, const ::blink::MediaStreamDevice& device) final;
//
//    void OnDeviceCaptureHandleChange(const WTF::String& label, const ::blink::MediaStreamDevice& device) final;
//
//    void OnZoomLevelChange(const WTF::String& label, const ::blink::MediaStreamDevice& device, int32_t zoom_level) final;
//
//private:
//    mojo::MessageReceiverWithResponder* receiver_;
//};

//class PLATFORM_EXPORT MediaStreamDispatcherHostProxy : public MediaStreamDispatcherHost {
//public:
//    using InterfaceType = MediaStreamDispatcherHost;
//
//    explicit MediaStreamDispatcherHostProxy(mojo::MessageReceiverWithResponder* receiver);
//
//    void GenerateStreams(int32_t request_id, const ::blink::StreamControls& controls, bool user_gesture, StreamSelectionInfoPtr audio_stream_selection_info,
//        GenerateStreamsCallback callback) final;
//
//    void FocusCapturedSurface(const WTF::String& label, bool focus) final;
//
//    void CancelRequest(int32_t request_id) final;
//
//    void StopStreamDevice(const WTF::String& device_id, const std::optional<::base::UnguessableToken>& session_id) final;
//
//    void OpenDevice(int32_t request_id, const WTF::String& device_id, MediaStreamType type, OpenDeviceCallback callback) final;
//
//    void CloseDevice(const WTF::String& label) final;
//
//    void SetCapturingLinkSecured(const std::optional<::base::UnguessableToken>& session_id, MediaStreamType type, bool is_secure) final;
//
//    void ApplySubCaptureTarget(const ::base::UnguessableToken& session_id, ::media::mojom::blink::SubCaptureTargetType type,
//        const ::base::Token& sub_capture_target, uint32_t sub_capture_target_version, ApplySubCaptureTargetCallback callback) final;
//
//    void SendWheel(const ::base::UnguessableToken& session_id, CapturedWheelActionPtr action, SendWheelCallback callback) final;
//
//    void SetZoomLevel(const ::base::UnguessableToken& session_id, int32_t zoom_level, SetZoomLevelCallback callback) final;
//
//    void RequestCapturedSurfaceControlPermission(const ::base::UnguessableToken& session_id, RequestCapturedSurfaceControlPermissionCallback callback) final;
//
//    bool GetOpenDevice(int32_t request_id, const ::base::UnguessableToken& session_id, const ::base::UnguessableToken& transfer_id,
//        MediaStreamRequestResult* out_result, GetOpenDeviceResponsePtr* out_response) final;
//
//    void GetOpenDevice(
//        int32_t request_id, const ::base::UnguessableToken& session_id, const ::base::UnguessableToken& transfer_id, GetOpenDeviceCallback callback) final;
//
//    void KeepDeviceAliveForTransfer(
//        const ::base::UnguessableToken& session_id, const ::base::UnguessableToken& transfer_id, KeepDeviceAliveForTransferCallback callback) final;
//
//private:
//    mojo::MessageReceiverWithResponder* receiver_;
//};

//class PLATFORM_EXPORT MediaStreamTrackMetricsHostProxy : public MediaStreamTrackMetricsHost {
//public:
//    using InterfaceType = MediaStreamTrackMetricsHost;
//
//    explicit MediaStreamTrackMetricsHostProxy(mojo::MessageReceiverWithResponder* receiver);
//
//    void AddTrack(uint64_t id, bool is_audio, bool is_remote) final;
//
//    void RemoveTrack(uint64_t id) final;
//
//private:
//    mojo::MessageReceiverWithResponder* receiver_;
//};
//class PLATFORM_EXPORT MediaStreamDeviceObserverStubDispatch {
//public:
//    static bool Accept(MediaStreamDeviceObserver* impl, mojo::Message* message);
//    static bool AcceptWithResponder(MediaStreamDeviceObserver* impl, mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
//};

//template <typename ImplRefTraits = mojo::RawPtrImplRefTraits<MediaStreamDeviceObserver>>
//class MediaStreamDeviceObserverStub : public mojo::MessageReceiverWithResponderStatus {
//public:
//    using ImplPointerType = typename ImplRefTraits::PointerType;
//
//    MediaStreamDeviceObserverStub() = default;
//    ~MediaStreamDeviceObserverStub() override = default;
//
//    void set_sink(ImplPointerType sink)
//    {
//        sink_ = std::move(sink);
//    }
//    ImplPointerType& sink()
//    {
//        return sink_;
//    }
//
//    bool Accept(mojo::Message* message) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return MediaStreamDeviceObserverStubDispatch::Accept(ImplRefTraits::GetRawPointer(&sink_), message);
//    }
//
//    bool AcceptWithResponder(mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return MediaStreamDeviceObserverStubDispatch::AcceptWithResponder(ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
//    }
//
//private:
//    ImplPointerType sink_;
//};
//class PLATFORM_EXPORT MediaStreamDispatcherHostStubDispatch {
//public:
//    static bool Accept(MediaStreamDispatcherHost* impl, mojo::Message* message);
//    static bool AcceptWithResponder(MediaStreamDispatcherHost* impl, mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
//};

//template <typename ImplRefTraits = mojo::RawPtrImplRefTraits<MediaStreamDispatcherHost>>
//class MediaStreamDispatcherHostStub : public mojo::MessageReceiverWithResponderStatus {
//public:
//    using ImplPointerType = typename ImplRefTraits::PointerType;
//
//    MediaStreamDispatcherHostStub() = default;
//    ~MediaStreamDispatcherHostStub() override = default;
//
//    void set_sink(ImplPointerType sink)
//    {
//        sink_ = std::move(sink);
//    }
//    ImplPointerType& sink()
//    {
//        return sink_;
//    }
//
//    bool Accept(mojo::Message* message) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return MediaStreamDispatcherHostStubDispatch::Accept(ImplRefTraits::GetRawPointer(&sink_), message);
//    }
//
//    bool AcceptWithResponder(mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return MediaStreamDispatcherHostStubDispatch::AcceptWithResponder(ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
//    }
//
//private:
//    ImplPointerType sink_;
//};
//class PLATFORM_EXPORT MediaStreamTrackMetricsHostStubDispatch {
//public:
//    static bool Accept(MediaStreamTrackMetricsHost* impl, mojo::Message* message);
//    static bool AcceptWithResponder(MediaStreamTrackMetricsHost* impl, mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
//};

//template <typename ImplRefTraits = mojo::RawPtrImplRefTraits<MediaStreamTrackMetricsHost>>
//class MediaStreamTrackMetricsHostStub : public mojo::MessageReceiverWithResponderStatus {
//public:
//    using ImplPointerType = typename ImplRefTraits::PointerType;
//
//    MediaStreamTrackMetricsHostStub() = default;
//    ~MediaStreamTrackMetricsHostStub() override = default;
//
//    void set_sink(ImplPointerType sink)
//    {
//        sink_ = std::move(sink);
//    }
//    ImplPointerType& sink()
//    {
//        return sink_;
//    }
//
//    bool Accept(mojo::Message* message) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return MediaStreamTrackMetricsHostStubDispatch::Accept(ImplRefTraits::GetRawPointer(&sink_), message);
//    }
//
//    bool AcceptWithResponder(mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return MediaStreamTrackMetricsHostStubDispatch::AcceptWithResponder(ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
//    }
//
//private:
//    ImplPointerType sink_;
//};
//class PLATFORM_EXPORT MediaStreamDeviceObserverRequestValidator : public mojo::MessageReceiver {
//public:
//    bool Accept(mojo::Message* message) override;
//};
//class PLATFORM_EXPORT MediaStreamDispatcherHostRequestValidator : public mojo::MessageReceiver {
//public:
//    bool Accept(mojo::Message* message) override;
//};
//class PLATFORM_EXPORT MediaStreamTrackMetricsHostRequestValidator : public mojo::MessageReceiver {
//public:
//    bool Accept(mojo::Message* message) override;
//};
//class PLATFORM_EXPORT MediaStreamDispatcherHostResponseValidator : public mojo::MessageReceiver {
//public:
//    bool Accept(mojo::Message* message) override;
//};

class PLATFORM_EXPORT SearchOnlyByDeviceId {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<SearchOnlyByDeviceId, T>::value>;
    using DataView = SearchOnlyByDeviceIdDataView;
    using Data_ = internal::SearchOnlyByDeviceId_Data;

    template <typename... Args> static SearchOnlyByDeviceIdPtr New(Args&&... args)
    {
        return SearchOnlyByDeviceIdPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static SearchOnlyByDeviceIdPtr From(const U& u)
    {
        return mojo::TypeConverter<SearchOnlyByDeviceIdPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, SearchOnlyByDeviceId>::Convert(*this);
    }

    SearchOnlyByDeviceId()
{
}

    ~SearchOnlyByDeviceId() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = SearchOnlyByDeviceIdPtr> SearchOnlyByDeviceIdPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, SearchOnlyByDeviceId::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, SearchOnlyByDeviceId::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, SearchOnlyByDeviceId::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<SearchOnlyByDeviceId::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<SearchOnlyByDeviceId::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::SearchOnlyByDeviceId_UnserializedMessageContext<UserType, SearchOnlyByDeviceId::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<SearchOnlyByDeviceId::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return SearchOnlyByDeviceId::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::SearchOnlyByDeviceId_UnserializedMessageContext<UserType, SearchOnlyByDeviceId::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<SearchOnlyByDeviceId::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, SearchOnlyByDeviceId::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, SearchOnlyByDeviceId::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, SearchOnlyByDeviceId::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, SearchOnlyByDeviceId::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class PLATFORM_EXPORT CapturedWheelAction {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<CapturedWheelAction, T>::value>;
    using DataView = CapturedWheelActionDataView;
    using Data_ = internal::CapturedWheelAction_Data;

    template <typename... Args> static CapturedWheelActionPtr New(Args&&... args)
    {
        return CapturedWheelActionPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static CapturedWheelActionPtr From(const U& u)
    {
        return mojo::TypeConverter<CapturedWheelActionPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, CapturedWheelAction>::Convert(*this);
    }

    CapturedWheelAction()
    : relative_x()
    , relative_y()
    , wheel_delta_x()
    , wheel_delta_y()
{
}

    CapturedWheelAction(double relative_x_in, double relative_y_in, int32_t wheel_delta_x_in, int32_t wheel_delta_y_in)
    : relative_x(std::move(relative_x_in))
    , relative_y(std::move(relative_y_in))
    , wheel_delta_x(std::move(wheel_delta_x_in))
    , wheel_delta_y(std::move(wheel_delta_y_in)){
}

    ~CapturedWheelAction() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = CapturedWheelActionPtr> CapturedWheelActionPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, CapturedWheelAction::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, CapturedWheelAction::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, CapturedWheelAction::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<CapturedWheelAction::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<CapturedWheelAction::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::CapturedWheelAction_UnserializedMessageContext<UserType, CapturedWheelAction::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<CapturedWheelAction::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return CapturedWheelAction::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::CapturedWheelAction_UnserializedMessageContext<UserType, CapturedWheelAction::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<CapturedWheelAction::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    double relative_x;

    double relative_y;

    int32_t wheel_delta_x;

    int32_t wheel_delta_y;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, CapturedWheelAction::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, CapturedWheelAction::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, CapturedWheelAction::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, CapturedWheelAction::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class PLATFORM_EXPORT StreamSelectionInfo {
public:
    using DataView = StreamSelectionInfoDataView;
    using Data_ = internal::StreamSelectionInfo_Data;
    using Tag = Data_::StreamSelectionInfo_Tag;

    template <typename... Args> static StreamSelectionInfoPtr New(Args&&... args)
    {
        static_assert(sizeof...(args) < 0,
            "Do not use Union::New(); to create a union of a given subtype, use "
            "New<SubType>(), not New() followed by set_<sub_type>(). To represent "
            "an empty union, mark the field or parameter as nullable in the mojom "
            "definition.");
        return nullptr;
    }
    // Construct an instance holding |search_only_by_device_id|.
    static StreamSelectionInfoPtr NewSearchOnlyByDeviceId(SearchOnlyByDeviceIdPtr value)
    {
        auto result = StreamSelectionInfoPtr(std::in_place);
        result->set_search_only_by_device_id(std::move(value));
        return result;
    }
    // Construct an instance holding |search_by_session_id|.
    static StreamSelectionInfoPtr NewSearchBySessionId(SearchBySessionIdPtr value)
    {
        auto result = StreamSelectionInfoPtr(std::in_place);
        result->set_search_by_session_id(std::move(value));
        return result;
    }

    template <typename U> static StreamSelectionInfoPtr From(const U& u)
    {
        return mojo::TypeConverter<StreamSelectionInfoPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, StreamSelectionInfo>::Convert(*this);
    }

    StreamSelectionInfo()
    : tag_(Tag::kSearchOnlyByDeviceId)
{
    data_.search_only_by_device_id = new SearchOnlyByDeviceIdPtr;
}
    ~StreamSelectionInfo(){
    DestroyActive();
}
    // Delete the copy constructor and copy assignment operators because `data_`
    // contains raw pointers that must not be copied.
    StreamSelectionInfo(const StreamSelectionInfo& other) = delete;
    StreamSelectionInfo& operator=(const StreamSelectionInfo& other) = delete;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename UnionPtrType = StreamSelectionInfoPtr> StreamSelectionInfoPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, typename std::enable_if<std::is_same<T, StreamSelectionInfo>::value>::type* = nullptr> bool Equals(const T& other) const;

    template <typename T, typename std::enable_if<std::is_same<T, StreamSelectionInfo>::value>::type* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    Tag which() const
    {
        return tag_;
    }

    bool is_search_only_by_device_id() const
    {
        return tag_ == Tag::kSearchOnlyByDeviceId;
    }

    SearchOnlyByDeviceIdPtr& get_search_only_by_device_id() const
    {
        CHECK(tag_ == Tag::kSearchOnlyByDeviceId);
        return *(data_.search_only_by_device_id);
    }

    void set_search_only_by_device_id(SearchOnlyByDeviceIdPtr search_only_by_device_id);

    bool is_search_by_session_id() const
    {
        return tag_ == Tag::kSearchBySessionId;
    }

    SearchBySessionIdPtr& get_search_by_session_id() const
    {
        CHECK(tag_ == Tag::kSearchBySessionId);
        return *(data_.search_by_session_id);
    }

    void set_search_by_session_id(SearchBySessionIdPtr search_by_session_id);

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<StreamSelectionInfo::DataView>(input);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        return mojo::internal::DeserializeImpl<StreamSelectionInfo::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

private:
    union Union_ {
        Union_() = default;
        ~Union_() = default;
        SearchOnlyByDeviceIdPtr* search_only_by_device_id;
        SearchBySessionIdPtr* search_by_session_id;
    };

    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    void DestroyActive();
    Tag tag_;
    Union_ data_;
};

class PLATFORM_EXPORT SearchBySessionId {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<SearchBySessionId, T>::value>;
    using DataView = SearchBySessionIdDataView;
    using Data_ = internal::SearchBySessionId_Data;

    template <typename... Args> static SearchBySessionIdPtr New(Args&&... args)
    {
        return SearchBySessionIdPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static SearchBySessionIdPtr From(const U& u)
    {
        return mojo::TypeConverter<SearchBySessionIdPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, SearchBySessionId>::Convert(*this);
    }

    SearchBySessionId()
    : session_id_map()
{
}

    explicit SearchBySessionId(const WTF::HashMap<WTF::String, ::base::UnguessableToken>& session_id_map_in)
    : session_id_map(std::move(session_id_map_in)){
}

    ~SearchBySessionId() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = SearchBySessionIdPtr> SearchBySessionIdPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, SearchBySessionId::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, SearchBySessionId::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, SearchBySessionId::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<SearchBySessionId::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<SearchBySessionId::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::SearchBySessionId_UnserializedMessageContext<UserType, SearchBySessionId::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<SearchBySessionId::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return SearchBySessionId::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::SearchBySessionId_UnserializedMessageContext<UserType, SearchBySessionId::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<SearchBySessionId::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    WTF::HashMap<WTF::String, ::base::UnguessableToken> session_id_map;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, SearchBySessionId::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, SearchBySessionId::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, SearchBySessionId::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, SearchBySessionId::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class PLATFORM_EXPORT MediaStreamDevice {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<MediaStreamDevice, T>::value>;
    using DataView = MediaStreamDeviceDataView;
    using Data_ = internal::MediaStreamDevice_Data;

    template <typename... Args> static MediaStreamDevicePtr New(Args&&... args)
    {
        return MediaStreamDevicePtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static MediaStreamDevicePtr From(const U& u)
    {
        return mojo::TypeConverter<MediaStreamDevicePtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, MediaStreamDevice>::Convert(*this);
    }

    MediaStreamDevice()
    : type()
    , id()
    , display_id()
    , video_facing()
    , group_id()
    , matched_output_device_id()
    , name()
    , input()
    , session_id()
    , display_media_info()
{
}

    MediaStreamDevice(MediaStreamType type_in, const WTF::String& id_in, int64_t display_id_in, ::media::VideoFacingMode video_facing_in,
    const WTF::String& group_id_in, const WTF::String& matched_output_device_id_in, const WTF::String& name_in, const ::media::AudioParameters& input_in,
    const std::optional<::base::UnguessableToken>& session_id_in, ::media::mojom::blink::DisplayMediaInformationPtr display_media_info_in)
    : type(std::move(type_in))
    , id(std::move(id_in))
    , display_id(std::move(display_id_in))
    , video_facing(std::move(video_facing_in))
    , group_id(std::move(group_id_in))
    , matched_output_device_id(std::move(matched_output_device_id_in))
    , name(std::move(name_in))
    , input(std::move(input_in))
    , session_id(std::move(session_id_in))
    , display_media_info(std::move(display_media_info_in)){
}

    MediaStreamDevice(const MediaStreamDevice&) = delete;
    MediaStreamDevice& operator=(const MediaStreamDevice&) = delete;

    ~MediaStreamDevice() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = MediaStreamDevicePtr> MediaStreamDevicePtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, MediaStreamDevice::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, MediaStreamDevice::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, MediaStreamDevice::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<MediaStreamDevice::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<MediaStreamDevice::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::MediaStreamDevice_UnserializedMessageContext<UserType, MediaStreamDevice::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<MediaStreamDevice::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return MediaStreamDevice::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::MediaStreamDevice_UnserializedMessageContext<UserType, MediaStreamDevice::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<MediaStreamDevice::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    MediaStreamType type;

    WTF::String id;

    int64_t display_id;

    ::media::VideoFacingMode video_facing;

    WTF::String group_id;

    WTF::String matched_output_device_id;

    WTF::String name;

    ::media::AudioParameters input;

    std::optional<::base::UnguessableToken> session_id;

    ::media::mojom::blink::DisplayMediaInformationPtr display_media_info;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, MediaStreamDevice::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, MediaStreamDevice::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, MediaStreamDevice::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, MediaStreamDevice::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class PLATFORM_EXPORT TrackControls {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<TrackControls, T>::value>;
    using DataView = TrackControlsDataView;
    using Data_ = internal::TrackControls_Data;

    template <typename... Args> static TrackControlsPtr New(Args&&... args)
    {
        return TrackControlsPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static TrackControlsPtr From(const U& u)
    {
        return mojo::TypeConverter<TrackControlsPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, TrackControls>::Convert(*this);
    }

    TrackControls()
    : stream_type()
    , device_ids()
{
}

    TrackControls(MediaStreamType stream_type_in, WTF::Vector<WTF::String> device_ids_in)
    : stream_type(std::move(stream_type_in))
    , device_ids(std::move(device_ids_in)){
}

    ~TrackControls() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = TrackControlsPtr> TrackControlsPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, TrackControls::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, TrackControls::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, TrackControls::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<TrackControls::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<TrackControls::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(std::make_unique<internal::TrackControls_UnserializedMessageContext<UserType, TrackControls::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<TrackControls::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return TrackControls::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::TrackControls_UnserializedMessageContext<UserType, TrackControls::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<TrackControls::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    MediaStreamType stream_type;

    WTF::Vector<WTF::String> device_ids;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, TrackControls::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, TrackControls::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, TrackControls::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, TrackControls::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class PLATFORM_EXPORT StreamControls {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<StreamControls, T>::value>;
    using DataView = StreamControlsDataView;
    using Data_ = internal::StreamControls_Data;

    template <typename... Args> static StreamControlsPtr New(Args&&... args)
    {
        return StreamControlsPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static StreamControlsPtr From(const U& u)
    {
        return mojo::TypeConverter<StreamControlsPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, StreamControls>::Convert(*this);
    }

    StreamControls()
    : audio()
    , video()
    , hotword_enabled()
    , disable_local_echo()
    , suppress_local_audio_playback()
    , exclude_system_audio()
    , exclude_self_browser_surface()
    , request_pan_tilt_zoom_permission()
    , request_all_screens()
    , preferred_display_surface()
    , dynamic_surface_switching_requested()
    , exclude_monitor_type_surfaces()
{
}

    StreamControls(const ::blink::TrackControls& audio_in, const ::blink::TrackControls& video_in, bool hotword_enabled_in,
    bool disable_local_echo_in, bool suppress_local_audio_playback_in, bool exclude_system_audio_in, bool exclude_self_browser_surface_in,
    bool request_pan_tilt_zoom_permission_in, bool request_all_screens_in, PreferredDisplaySurface preferred_display_surface_in,
    bool dynamic_surface_switching_requested_in, bool exclude_monitor_type_surfaces_in)
    : audio(std::move(audio_in))
    , video(std::move(video_in))
    , hotword_enabled(std::move(hotword_enabled_in))
    , disable_local_echo(std::move(disable_local_echo_in))
    , suppress_local_audio_playback(std::move(suppress_local_audio_playback_in))
    , exclude_system_audio(std::move(exclude_system_audio_in))
    , exclude_self_browser_surface(std::move(exclude_self_browser_surface_in))
    , request_pan_tilt_zoom_permission(std::move(request_pan_tilt_zoom_permission_in))
    , request_all_screens(std::move(request_all_screens_in))
    , preferred_display_surface(std::move(preferred_display_surface_in))
    , dynamic_surface_switching_requested(std::move(dynamic_surface_switching_requested_in))
    , exclude_monitor_type_surfaces(std::move(exclude_monitor_type_surfaces_in)){
}

    ~StreamControls() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = StreamControlsPtr> StreamControlsPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, StreamControls::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, StreamControls::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, StreamControls::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<StreamControls::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<StreamControls::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(std::make_unique<internal::StreamControls_UnserializedMessageContext<UserType, StreamControls::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<StreamControls::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return StreamControls::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::StreamControls_UnserializedMessageContext<UserType, StreamControls::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<StreamControls::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    ::blink::TrackControls audio;

    ::blink::TrackControls video;

    bool hotword_enabled;

    bool disable_local_echo;

    bool suppress_local_audio_playback;

    bool exclude_system_audio;

    bool exclude_self_browser_surface;

    bool request_pan_tilt_zoom_permission;

    bool request_all_screens;

    PreferredDisplaySurface preferred_display_surface;

    bool dynamic_surface_switching_requested;

    bool exclude_monitor_type_surfaces;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, StreamControls::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, StreamControls::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, StreamControls::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, StreamControls::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class PLATFORM_EXPORT GetOpenDeviceResponse {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<GetOpenDeviceResponse, T>::value>;
    using DataView = GetOpenDeviceResponseDataView;
    using Data_ = internal::GetOpenDeviceResponse_Data;

    template <typename... Args> static GetOpenDeviceResponsePtr New(Args&&... args)
    {
        return GetOpenDeviceResponsePtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static GetOpenDeviceResponsePtr From(const U& u)
    {
        return mojo::TypeConverter<GetOpenDeviceResponsePtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, GetOpenDeviceResponse>::Convert(*this);
    }

    GetOpenDeviceResponse()
    : label()
    , device()
    , pan_tilt_zoom_allowed()
{
}

    GetOpenDeviceResponse(const WTF::String& label_in, const ::blink::MediaStreamDevice& device_in, bool pan_tilt_zoom_allowed_in)
    : label(std::move(label_in))
    , device(std::move(device_in))
    , pan_tilt_zoom_allowed(std::move(pan_tilt_zoom_allowed_in)){
}

    ~GetOpenDeviceResponse() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = GetOpenDeviceResponsePtr> GetOpenDeviceResponsePtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, GetOpenDeviceResponse::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, GetOpenDeviceResponse::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, GetOpenDeviceResponse::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<GetOpenDeviceResponse::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<GetOpenDeviceResponse::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::GetOpenDeviceResponse_UnserializedMessageContext<UserType, GetOpenDeviceResponse::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<GetOpenDeviceResponse::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return GetOpenDeviceResponse::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::GetOpenDeviceResponse_UnserializedMessageContext<UserType, GetOpenDeviceResponse::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<GetOpenDeviceResponse::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    WTF::String label;

    ::blink::MediaStreamDevice device;

    bool pan_tilt_zoom_allowed;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, GetOpenDeviceResponse::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, GetOpenDeviceResponse::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, GetOpenDeviceResponse::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, GetOpenDeviceResponse::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class PLATFORM_EXPORT StreamDevices {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<StreamDevices, T>::value>;
    using DataView = StreamDevicesDataView;
    using Data_ = internal::StreamDevices_Data;

    template <typename... Args> static StreamDevicesPtr New(Args&&... args)
    {
        return StreamDevicesPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static StreamDevicesPtr From(const U& u)
    {
        return mojo::TypeConverter<StreamDevicesPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, StreamDevices>::Convert(*this);
    }

    StreamDevices()
    : audio_device()
    , video_device()
{
}

    StreamDevices(const std::optional<::blink::MediaStreamDevice>& audio_device_in, const std::optional<::blink::MediaStreamDevice>& video_device_in)
    : audio_device(std::move(audio_device_in))
    , video_device(std::move(video_device_in)){
}

    ~StreamDevices() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = StreamDevicesPtr> StreamDevicesPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, StreamDevices::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, StreamDevices::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, StreamDevices::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<StreamDevices::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<StreamDevices::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(std::make_unique<internal::StreamDevices_UnserializedMessageContext<UserType, StreamDevices::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<StreamDevices::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return StreamDevices::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::StreamDevices_UnserializedMessageContext<UserType, StreamDevices::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<StreamDevices::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    std::optional<::blink::MediaStreamDevice> audio_device;

    std::optional<::blink::MediaStreamDevice> video_device;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, StreamDevices::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, StreamDevices::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, StreamDevices::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, StreamDevices::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class PLATFORM_EXPORT StreamDevicesSet {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<StreamDevicesSet, T>::value>;
    using DataView = StreamDevicesSetDataView;
    using Data_ = internal::StreamDevicesSet_Data;

    template <typename... Args> static StreamDevicesSetPtr New(Args&&... args)
    {
        return StreamDevicesSetPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static StreamDevicesSetPtr From(const U& u)
    {
        return mojo::TypeConverter<StreamDevicesSetPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, StreamDevicesSet>::Convert(*this);
    }

    StreamDevicesSet()
    : stream_devices()
{
}

    explicit StreamDevicesSet(WTF::Vector<StreamDevicesPtr> stream_devices_in)
    : stream_devices(std::move(stream_devices_in)){
}

    StreamDevicesSet(const StreamDevicesSet&) = delete;
    StreamDevicesSet& operator=(const StreamDevicesSet&) = delete;

    ~StreamDevicesSet() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = StreamDevicesSetPtr> StreamDevicesSetPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, StreamDevicesSet::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, StreamDevicesSet::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, StreamDevicesSet::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<StreamDevicesSet::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<StreamDevicesSet::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::StreamDevicesSet_UnserializedMessageContext<UserType, StreamDevicesSet::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<StreamDevicesSet::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return StreamDevicesSet::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::StreamDevicesSet_UnserializedMessageContext<UserType, StreamDevicesSet::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<StreamDevicesSet::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    WTF::Vector<StreamDevicesPtr> stream_devices;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, StreamDevicesSet::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, StreamDevicesSet::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, StreamDevicesSet::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, StreamDevicesSet::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

template <typename UnionPtrType> StreamSelectionInfoPtr StreamSelectionInfo::Clone() const
{
    switch (tag_) {
    case Tag::kSearchOnlyByDeviceId:
        return NewSearchOnlyByDeviceId(mojo::Clone(*data_.search_only_by_device_id));
    case Tag::kSearchBySessionId:
        return NewSearchBySessionId(mojo::Clone(*data_.search_by_session_id));
    }
    return nullptr;
}

template <typename T, typename std::enable_if<std::is_same<T, StreamSelectionInfo>::value>::type*> bool StreamSelectionInfo::Equals(const T& other) const
{
    if (tag_ != other.which())
        return false;

    switch (tag_) {
    case Tag::kSearchOnlyByDeviceId:
        return mojo::Equals(*(data_.search_only_by_device_id), *(other.data_.search_only_by_device_id));
    case Tag::kSearchBySessionId:
        return mojo::Equals(*(data_.search_by_session_id), *(other.data_.search_by_session_id));
    }

    return false;
}
template <typename StructPtrType> SearchOnlyByDeviceIdPtr SearchOnlyByDeviceId::Clone() const
{
    return New();
}

template <typename T, SearchOnlyByDeviceId::EnableIfSame<T>*> bool SearchOnlyByDeviceId::Equals(const T& other_struct) const
{
    return true;
}

template <typename T, SearchOnlyByDeviceId::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    return false;
}
template <typename StructPtrType> SearchBySessionIdPtr SearchBySessionId::Clone() const
{
    return New(mojo::Clone(session_id_map));
}

template <typename T, SearchBySessionId::EnableIfSame<T>*> bool SearchBySessionId::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->session_id_map, other_struct.session_id_map))
        return false;
    return true;
}

template <typename T, SearchBySessionId::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.session_id_map < rhs.session_id_map)
        return true;
    if (rhs.session_id_map < lhs.session_id_map)
        return false;
    return false;
}
template <typename StructPtrType> MediaStreamDevicePtr MediaStreamDevice::Clone() const
{
    return New(mojo::Clone(type), mojo::Clone(id), mojo::Clone(display_id), mojo::Clone(video_facing), mojo::Clone(group_id),
        mojo::Clone(matched_output_device_id), mojo::Clone(name), mojo::Clone(input), mojo::Clone(session_id), mojo::Clone(display_media_info));
}

template <typename T, MediaStreamDevice::EnableIfSame<T>*> bool MediaStreamDevice::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->type, other_struct.type))
        return false;
    if (!mojo::Equals(this->id, other_struct.id))
        return false;
    if (!mojo::Equals(this->display_id, other_struct.display_id))
        return false;
    if (!mojo::Equals(this->video_facing, other_struct.video_facing))
        return false;
    if (!mojo::Equals(this->group_id, other_struct.group_id))
        return false;
    if (!mojo::Equals(this->matched_output_device_id, other_struct.matched_output_device_id))
        return false;
    if (!mojo::Equals(this->name, other_struct.name))
        return false;
    if (!mojo::Equals(this->input, other_struct.input))
        return false;
    if (!mojo::Equals(this->session_id, other_struct.session_id))
        return false;
    if (!mojo::Equals(this->display_media_info, other_struct.display_media_info))
        return false;
    return true;
}

template <typename T, MediaStreamDevice::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.type < rhs.type)
        return true;
    if (rhs.type < lhs.type)
        return false;
    if (lhs.id < rhs.id)
        return true;
    if (rhs.id < lhs.id)
        return false;
    if (lhs.display_id < rhs.display_id)
        return true;
    if (rhs.display_id < lhs.display_id)
        return false;
    if (lhs.video_facing < rhs.video_facing)
        return true;
    if (rhs.video_facing < lhs.video_facing)
        return false;
    if (lhs.group_id < rhs.group_id)
        return true;
    if (rhs.group_id < lhs.group_id)
        return false;
    if (lhs.matched_output_device_id < rhs.matched_output_device_id)
        return true;
    if (rhs.matched_output_device_id < lhs.matched_output_device_id)
        return false;
    if (lhs.name < rhs.name)
        return true;
    if (rhs.name < lhs.name)
        return false;
    if (lhs.input < rhs.input)
        return true;
    if (rhs.input < lhs.input)
        return false;
    if (lhs.session_id < rhs.session_id)
        return true;
    if (rhs.session_id < lhs.session_id)
        return false;
    if (lhs.display_media_info < rhs.display_media_info)
        return true;
    if (rhs.display_media_info < lhs.display_media_info)
        return false;
    return false;
}
template <typename StructPtrType> TrackControlsPtr TrackControls::Clone() const
{
    return New(mojo::Clone(stream_type), mojo::Clone(device_ids));
}

template <typename T, TrackControls::EnableIfSame<T>*> bool TrackControls::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->stream_type, other_struct.stream_type))
        return false;
    if (!mojo::Equals(this->device_ids, other_struct.device_ids))
        return false;
    return true;
}

template <typename T, TrackControls::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.stream_type < rhs.stream_type)
        return true;
    if (rhs.stream_type < lhs.stream_type)
        return false;
    if (lhs.device_ids < rhs.device_ids)
        return true;
    if (rhs.device_ids < lhs.device_ids)
        return false;
    return false;
}
template <typename StructPtrType> StreamControlsPtr StreamControls::Clone() const
{
    return New(mojo::Clone(audio), mojo::Clone(video), mojo::Clone(hotword_enabled), mojo::Clone(disable_local_echo),
        mojo::Clone(suppress_local_audio_playback), mojo::Clone(exclude_system_audio), mojo::Clone(exclude_self_browser_surface),
        mojo::Clone(request_pan_tilt_zoom_permission), mojo::Clone(request_all_screens), mojo::Clone(preferred_display_surface),
        mojo::Clone(dynamic_surface_switching_requested), mojo::Clone(exclude_monitor_type_surfaces));
}

template <typename T, StreamControls::EnableIfSame<T>*> bool StreamControls::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->audio, other_struct.audio))
        return false;
    if (!mojo::Equals(this->video, other_struct.video))
        return false;
    if (!mojo::Equals(this->hotword_enabled, other_struct.hotword_enabled))
        return false;
    if (!mojo::Equals(this->disable_local_echo, other_struct.disable_local_echo))
        return false;
    if (!mojo::Equals(this->suppress_local_audio_playback, other_struct.suppress_local_audio_playback))
        return false;
    if (!mojo::Equals(this->exclude_system_audio, other_struct.exclude_system_audio))
        return false;
    if (!mojo::Equals(this->exclude_self_browser_surface, other_struct.exclude_self_browser_surface))
        return false;
    if (!mojo::Equals(this->request_pan_tilt_zoom_permission, other_struct.request_pan_tilt_zoom_permission))
        return false;
    if (!mojo::Equals(this->request_all_screens, other_struct.request_all_screens))
        return false;
    if (!mojo::Equals(this->preferred_display_surface, other_struct.preferred_display_surface))
        return false;
    if (!mojo::Equals(this->dynamic_surface_switching_requested, other_struct.dynamic_surface_switching_requested))
        return false;
    if (!mojo::Equals(this->exclude_monitor_type_surfaces, other_struct.exclude_monitor_type_surfaces))
        return false;
    return true;
}

template <typename T, StreamControls::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.audio < rhs.audio)
        return true;
    if (rhs.audio < lhs.audio)
        return false;
    if (lhs.video < rhs.video)
        return true;
    if (rhs.video < lhs.video)
        return false;
    if (lhs.hotword_enabled < rhs.hotword_enabled)
        return true;
    if (rhs.hotword_enabled < lhs.hotword_enabled)
        return false;
    if (lhs.disable_local_echo < rhs.disable_local_echo)
        return true;
    if (rhs.disable_local_echo < lhs.disable_local_echo)
        return false;
    if (lhs.suppress_local_audio_playback < rhs.suppress_local_audio_playback)
        return true;
    if (rhs.suppress_local_audio_playback < lhs.suppress_local_audio_playback)
        return false;
    if (lhs.exclude_system_audio < rhs.exclude_system_audio)
        return true;
    if (rhs.exclude_system_audio < lhs.exclude_system_audio)
        return false;
    if (lhs.exclude_self_browser_surface < rhs.exclude_self_browser_surface)
        return true;
    if (rhs.exclude_self_browser_surface < lhs.exclude_self_browser_surface)
        return false;
    if (lhs.request_pan_tilt_zoom_permission < rhs.request_pan_tilt_zoom_permission)
        return true;
    if (rhs.request_pan_tilt_zoom_permission < lhs.request_pan_tilt_zoom_permission)
        return false;
    if (lhs.request_all_screens < rhs.request_all_screens)
        return true;
    if (rhs.request_all_screens < lhs.request_all_screens)
        return false;
    if (lhs.preferred_display_surface < rhs.preferred_display_surface)
        return true;
    if (rhs.preferred_display_surface < lhs.preferred_display_surface)
        return false;
    if (lhs.dynamic_surface_switching_requested < rhs.dynamic_surface_switching_requested)
        return true;
    if (rhs.dynamic_surface_switching_requested < lhs.dynamic_surface_switching_requested)
        return false;
    if (lhs.exclude_monitor_type_surfaces < rhs.exclude_monitor_type_surfaces)
        return true;
    if (rhs.exclude_monitor_type_surfaces < lhs.exclude_monitor_type_surfaces)
        return false;
    return false;
}
template <typename StructPtrType> GetOpenDeviceResponsePtr GetOpenDeviceResponse::Clone() const
{
    return New(mojo::Clone(label), mojo::Clone(device), mojo::Clone(pan_tilt_zoom_allowed));
}

template <typename T, GetOpenDeviceResponse::EnableIfSame<T>*> bool GetOpenDeviceResponse::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->label, other_struct.label))
        return false;
    if (!mojo::Equals(this->device, other_struct.device))
        return false;
    if (!mojo::Equals(this->pan_tilt_zoom_allowed, other_struct.pan_tilt_zoom_allowed))
        return false;
    return true;
}

template <typename T, GetOpenDeviceResponse::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.label < rhs.label)
        return true;
    if (rhs.label < lhs.label)
        return false;
    if (lhs.device < rhs.device)
        return true;
    if (rhs.device < lhs.device)
        return false;
    if (lhs.pan_tilt_zoom_allowed < rhs.pan_tilt_zoom_allowed)
        return true;
    if (rhs.pan_tilt_zoom_allowed < lhs.pan_tilt_zoom_allowed)
        return false;
    return false;
}
template <typename StructPtrType> CapturedWheelActionPtr CapturedWheelAction::Clone() const
{
    return New(mojo::Clone(relative_x), mojo::Clone(relative_y), mojo::Clone(wheel_delta_x), mojo::Clone(wheel_delta_y));
}

template <typename T, CapturedWheelAction::EnableIfSame<T>*> bool CapturedWheelAction::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->relative_x, other_struct.relative_x))
        return false;
    if (!mojo::Equals(this->relative_y, other_struct.relative_y))
        return false;
    if (!mojo::Equals(this->wheel_delta_x, other_struct.wheel_delta_x))
        return false;
    if (!mojo::Equals(this->wheel_delta_y, other_struct.wheel_delta_y))
        return false;
    return true;
}

template <typename T, CapturedWheelAction::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.relative_x < rhs.relative_x)
        return true;
    if (rhs.relative_x < lhs.relative_x)
        return false;
    if (lhs.relative_y < rhs.relative_y)
        return true;
    if (rhs.relative_y < lhs.relative_y)
        return false;
    if (lhs.wheel_delta_x < rhs.wheel_delta_x)
        return true;
    if (rhs.wheel_delta_x < lhs.wheel_delta_x)
        return false;
    if (lhs.wheel_delta_y < rhs.wheel_delta_y)
        return true;
    if (rhs.wheel_delta_y < lhs.wheel_delta_y)
        return false;
    return false;
}
template <typename StructPtrType> StreamDevicesPtr StreamDevices::Clone() const
{
    return New(mojo::Clone(audio_device), mojo::Clone(video_device));
}

template <typename T, StreamDevices::EnableIfSame<T>*> bool StreamDevices::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->audio_device, other_struct.audio_device))
        return false;
    if (!mojo::Equals(this->video_device, other_struct.video_device))
        return false;
    return true;
}

template <typename T, StreamDevices::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.audio_device < rhs.audio_device)
        return true;
    if (rhs.audio_device < lhs.audio_device)
        return false;
    if (lhs.video_device < rhs.video_device)
        return true;
    if (rhs.video_device < lhs.video_device)
        return false;
    return false;
}
template <typename StructPtrType> StreamDevicesSetPtr StreamDevicesSet::Clone() const
{
    return New(mojo::Clone(stream_devices));
}

template <typename T, StreamDevicesSet::EnableIfSame<T>*> bool StreamDevicesSet::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->stream_devices, other_struct.stream_devices))
        return false;
    return true;
}

template <typename T, StreamDevicesSet::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.stream_devices < rhs.stream_devices)
        return true;
    if (rhs.stream_devices < lhs.stream_devices)
        return false;
    return false;
}

} // blink::mojom::blink

namespace mojo {

template <> struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::SearchOnlyByDeviceId::DataView, ::blink::mojom::blink::SearchOnlyByDeviceIdPtr> {
    static bool IsNull(const ::blink::mojom::blink::SearchOnlyByDeviceIdPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::blink::SearchOnlyByDeviceIdPtr* output)
    {
        output->reset();
    }

    static bool Read(::blink::mojom::blink::SearchOnlyByDeviceId::DataView input, ::blink::mojom::blink::SearchOnlyByDeviceIdPtr* output);
};

template <> struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::SearchBySessionId::DataView, ::blink::mojom::blink::SearchBySessionIdPtr> {
    static bool IsNull(const ::blink::mojom::blink::SearchBySessionIdPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::blink::SearchBySessionIdPtr* output)
    {
        output->reset();
    }

    static const decltype(::blink::mojom::blink::SearchBySessionId::session_id_map)& session_id_map(const ::blink::mojom::blink::SearchBySessionIdPtr& input)
    {
        return input->session_id_map;
    }

    static bool Read(::blink::mojom::blink::SearchBySessionId::DataView input, ::blink::mojom::blink::SearchBySessionIdPtr* output);
};

template <> struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::MediaStreamDevice::DataView, ::blink::mojom::blink::MediaStreamDevicePtr> {
    static bool IsNull(const ::blink::mojom::blink::MediaStreamDevicePtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::blink::MediaStreamDevicePtr* output)
    {
        output->reset();
    }

    static decltype(::blink::mojom::blink::MediaStreamDevice::type) type(const ::blink::mojom::blink::MediaStreamDevicePtr& input)
    {
        return input->type;
    }

    static const decltype(::blink::mojom::blink::MediaStreamDevice::id)& id(const ::blink::mojom::blink::MediaStreamDevicePtr& input)
    {
        return input->id;
    }

    static decltype(::blink::mojom::blink::MediaStreamDevice::display_id) display_id(const ::blink::mojom::blink::MediaStreamDevicePtr& input)
    {
        return input->display_id;
    }

    static decltype(::blink::mojom::blink::MediaStreamDevice::video_facing) video_facing(const ::blink::mojom::blink::MediaStreamDevicePtr& input)
    {
        return input->video_facing;
    }

    static const decltype(::blink::mojom::blink::MediaStreamDevice::group_id)& group_id(const ::blink::mojom::blink::MediaStreamDevicePtr& input)
    {
        return input->group_id;
    }

    static const decltype(::blink::mojom::blink::MediaStreamDevice::matched_output_device_id)& matched_output_device_id(
        const ::blink::mojom::blink::MediaStreamDevicePtr& input)
    {
        return input->matched_output_device_id;
    }

    static const decltype(::blink::mojom::blink::MediaStreamDevice::name)& name(const ::blink::mojom::blink::MediaStreamDevicePtr& input)
    {
        return input->name;
    }

    static const decltype(::blink::mojom::blink::MediaStreamDevice::input)& input(const ::blink::mojom::blink::MediaStreamDevicePtr& input)
    {
        return input->input;
    }

    static const decltype(::blink::mojom::blink::MediaStreamDevice::session_id)& session_id(const ::blink::mojom::blink::MediaStreamDevicePtr& input)
    {
        return input->session_id;
    }

    static const decltype(::blink::mojom::blink::MediaStreamDevice::display_media_info)& display_media_info(
        const ::blink::mojom::blink::MediaStreamDevicePtr& input)
    {
        return input->display_media_info;
    }

    static bool Read(::blink::mojom::blink::MediaStreamDevice::DataView input, ::blink::mojom::blink::MediaStreamDevicePtr* output);
};

template <> struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::TrackControls::DataView, ::blink::mojom::blink::TrackControlsPtr> {
    static bool IsNull(const ::blink::mojom::blink::TrackControlsPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::blink::TrackControlsPtr* output)
    {
        output->reset();
    }

    static decltype(::blink::mojom::blink::TrackControls::stream_type) stream_type(const ::blink::mojom::blink::TrackControlsPtr& input)
    {
        return input->stream_type;
    }

    static const decltype(::blink::mojom::blink::TrackControls::device_ids)& device_ids(const ::blink::mojom::blink::TrackControlsPtr& input)
    {
        return input->device_ids;
    }

    static bool Read(::blink::mojom::blink::TrackControls::DataView input, ::blink::mojom::blink::TrackControlsPtr* output);
};

template <> struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::StreamControls::DataView, ::blink::mojom::blink::StreamControlsPtr> {
    static bool IsNull(const ::blink::mojom::blink::StreamControlsPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::blink::StreamControlsPtr* output)
    {
        output->reset();
    }

    static const decltype(::blink::mojom::blink::StreamControls::audio)& audio(const ::blink::mojom::blink::StreamControlsPtr& input)
    {
        return input->audio;
    }

    static const decltype(::blink::mojom::blink::StreamControls::video)& video(const ::blink::mojom::blink::StreamControlsPtr& input)
    {
        return input->video;
    }

    static decltype(::blink::mojom::blink::StreamControls::hotword_enabled) hotword_enabled(const ::blink::mojom::blink::StreamControlsPtr& input)
    {
        return input->hotword_enabled;
    }

    static decltype(::blink::mojom::blink::StreamControls::disable_local_echo) disable_local_echo(const ::blink::mojom::blink::StreamControlsPtr& input)
    {
        return input->disable_local_echo;
    }

    static decltype(::blink::mojom::blink::StreamControls::suppress_local_audio_playback) suppress_local_audio_playback(
        const ::blink::mojom::blink::StreamControlsPtr& input)
    {
        return input->suppress_local_audio_playback;
    }

    static decltype(::blink::mojom::blink::StreamControls::exclude_system_audio) exclude_system_audio(const ::blink::mojom::blink::StreamControlsPtr& input)
    {
        return input->exclude_system_audio;
    }

    static decltype(::blink::mojom::blink::StreamControls::exclude_self_browser_surface) exclude_self_browser_surface(
        const ::blink::mojom::blink::StreamControlsPtr& input)
    {
        return input->exclude_self_browser_surface;
    }

    static decltype(::blink::mojom::blink::StreamControls::request_pan_tilt_zoom_permission) request_pan_tilt_zoom_permission(
        const ::blink::mojom::blink::StreamControlsPtr& input)
    {
        return input->request_pan_tilt_zoom_permission;
    }

    static decltype(::blink::mojom::blink::StreamControls::request_all_screens) request_all_screens(const ::blink::mojom::blink::StreamControlsPtr& input)
    {
        return input->request_all_screens;
    }

    static decltype(::blink::mojom::blink::StreamControls::preferred_display_surface) preferred_display_surface(
        const ::blink::mojom::blink::StreamControlsPtr& input)
    {
        return input->preferred_display_surface;
    }

    static decltype(::blink::mojom::blink::StreamControls::dynamic_surface_switching_requested) dynamic_surface_switching_requested(
        const ::blink::mojom::blink::StreamControlsPtr& input)
    {
        return input->dynamic_surface_switching_requested;
    }

    static decltype(::blink::mojom::blink::StreamControls::exclude_monitor_type_surfaces) exclude_monitor_type_surfaces(
        const ::blink::mojom::blink::StreamControlsPtr& input)
    {
        return input->exclude_monitor_type_surfaces;
    }

    static bool Read(::blink::mojom::blink::StreamControls::DataView input, ::blink::mojom::blink::StreamControlsPtr* output);
};

template <> struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::GetOpenDeviceResponse::DataView, ::blink::mojom::blink::GetOpenDeviceResponsePtr> {
    static bool IsNull(const ::blink::mojom::blink::GetOpenDeviceResponsePtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::blink::GetOpenDeviceResponsePtr* output)
    {
        output->reset();
    }

    static const decltype(::blink::mojom::blink::GetOpenDeviceResponse::label)& label(const ::blink::mojom::blink::GetOpenDeviceResponsePtr& input)
    {
        return input->label;
    }

    static const decltype(::blink::mojom::blink::GetOpenDeviceResponse::device)& device(const ::blink::mojom::blink::GetOpenDeviceResponsePtr& input)
    {
        return input->device;
    }

    static decltype(::blink::mojom::blink::GetOpenDeviceResponse::pan_tilt_zoom_allowed) pan_tilt_zoom_allowed(
        const ::blink::mojom::blink::GetOpenDeviceResponsePtr& input)
    {
        return input->pan_tilt_zoom_allowed;
    }

    static bool Read(::blink::mojom::blink::GetOpenDeviceResponse::DataView input, ::blink::mojom::blink::GetOpenDeviceResponsePtr* output);
};

template <> struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::CapturedWheelAction::DataView, ::blink::mojom::blink::CapturedWheelActionPtr> {
    static bool IsNull(const ::blink::mojom::blink::CapturedWheelActionPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::blink::CapturedWheelActionPtr* output)
    {
        output->reset();
    }

    static decltype(::blink::mojom::blink::CapturedWheelAction::relative_x) relative_x(const ::blink::mojom::blink::CapturedWheelActionPtr& input)
    {
        return input->relative_x;
    }

    static decltype(::blink::mojom::blink::CapturedWheelAction::relative_y) relative_y(const ::blink::mojom::blink::CapturedWheelActionPtr& input)
    {
        return input->relative_y;
    }

    static decltype(::blink::mojom::blink::CapturedWheelAction::wheel_delta_x) wheel_delta_x(const ::blink::mojom::blink::CapturedWheelActionPtr& input)
    {
        return input->wheel_delta_x;
    }

    static decltype(::blink::mojom::blink::CapturedWheelAction::wheel_delta_y) wheel_delta_y(const ::blink::mojom::blink::CapturedWheelActionPtr& input)
    {
        return input->wheel_delta_y;
    }

    static bool Read(::blink::mojom::blink::CapturedWheelAction::DataView input, ::blink::mojom::blink::CapturedWheelActionPtr* output);
};

template <> struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::StreamDevices::DataView, ::blink::mojom::blink::StreamDevicesPtr> {
    static bool IsNull(const ::blink::mojom::blink::StreamDevicesPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::blink::StreamDevicesPtr* output)
    {
        output->reset();
    }

    static const decltype(::blink::mojom::blink::StreamDevices::audio_device)& audio_device(const ::blink::mojom::blink::StreamDevicesPtr& input)
    {
        return input->audio_device;
    }

    static const decltype(::blink::mojom::blink::StreamDevices::video_device)& video_device(const ::blink::mojom::blink::StreamDevicesPtr& input)
    {
        return input->video_device;
    }

    static bool Read(::blink::mojom::blink::StreamDevices::DataView input, ::blink::mojom::blink::StreamDevicesPtr* output);
};

template <> struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::StreamDevicesSet::DataView, ::blink::mojom::blink::StreamDevicesSetPtr> {
    static bool IsNull(const ::blink::mojom::blink::StreamDevicesSetPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::blink::StreamDevicesSetPtr* output)
    {
        output->reset();
    }

    static const decltype(::blink::mojom::blink::StreamDevicesSet::stream_devices)& stream_devices(const ::blink::mojom::blink::StreamDevicesSetPtr& input)
    {
        return input->stream_devices;
    }

    static bool Read(::blink::mojom::blink::StreamDevicesSet::DataView input, ::blink::mojom::blink::StreamDevicesSetPtr* output);
};

template <> struct PLATFORM_EXPORT UnionTraits<::blink::mojom::blink::StreamSelectionInfo::DataView, ::blink::mojom::blink::StreamSelectionInfoPtr> {
    static bool IsNull(const ::blink::mojom::blink::StreamSelectionInfoPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::blink::StreamSelectionInfoPtr* output)
    {
        output->reset();
    }

    static ::blink::mojom::blink::StreamSelectionInfo::Tag GetTag(const ::blink::mojom::blink::StreamSelectionInfoPtr& input)
    {
        return input->which();
    }

    static const ::blink::mojom::blink::SearchOnlyByDeviceIdPtr& search_only_by_device_id(const ::blink::mojom::blink::StreamSelectionInfoPtr& input)
    {
        return input->get_search_only_by_device_id();
    }

    static const ::blink::mojom::blink::SearchBySessionIdPtr& search_by_session_id(const ::blink::mojom::blink::StreamSelectionInfoPtr& input)
    {
        return input->get_search_by_session_id();
    }

    static bool Read(::blink::mojom::blink::StreamSelectionInfo::DataView input, ::blink::mojom::blink::StreamSelectionInfoPtr* output);
};

} // namespace mojo

#endif // THIRD_PARTY_BLINK_PUBLIC_MOJOM_MEDIASTREAM_MEDIA_STREAM_MOJOM_BLINK_H_
