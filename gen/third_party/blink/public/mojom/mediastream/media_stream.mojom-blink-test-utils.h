// third_party/blink/public/mojom/mediastream/media_stream.mojom-blink-test-utils.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2019 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef THIRD_PARTY_BLINK_PUBLIC_MOJOM_MEDIASTREAM_MEDIA_STREAM_MOJOM_BLINK_TEST_UTILS_H_
#define THIRD_PARTY_BLINK_PUBLIC_MOJOM_MEDIASTREAM_MEDIA_STREAM_MOJOM_BLINK_TEST_UTILS_H_

#include "third_party/blink/public/mojom/mediastream/media_stream.mojom-blink.h"
#include "third_party/blink/renderer/platform/platform_export.h"

namespace blink::mojom::blink {

class PLATFORM_EXPORT MediaStreamDeviceObserverInterceptorForTesting : public MediaStreamDeviceObserver {
    virtual MediaStreamDeviceObserver* GetForwardingInterface() = 0;
    void OnDeviceStopped(const WTF::String& label, const ::blink::MediaStreamDevice& device) override;
    void OnDeviceChanged(const WTF::String& label, const ::blink::MediaStreamDevice& old_device, const ::blink::MediaStreamDevice& new_device) override;
    void OnDeviceRequestStateChange(const WTF::String& label, const ::blink::MediaStreamDevice& device, MediaStreamStateChange new_state) override;
    void OnDeviceCaptureConfigurationChange(const WTF::String& label, const ::blink::MediaStreamDevice& device) override;
    void OnDeviceCaptureHandleChange(const WTF::String& label, const ::blink::MediaStreamDevice& device) override;
    void OnZoomLevelChange(const WTF::String& label, const ::blink::MediaStreamDevice& device, int32_t zoom_level) override;
};
class PLATFORM_EXPORT MediaStreamDeviceObserverAsyncWaiter {
public:
    explicit MediaStreamDeviceObserverAsyncWaiter(MediaStreamDeviceObserver* proxy);

    MediaStreamDeviceObserverAsyncWaiter(const MediaStreamDeviceObserverAsyncWaiter&) = delete;
    MediaStreamDeviceObserverAsyncWaiter& operator=(const MediaStreamDeviceObserverAsyncWaiter&) = delete;

    ~MediaStreamDeviceObserverAsyncWaiter();

private:
    MediaStreamDeviceObserver* const proxy_;
};

class PLATFORM_EXPORT MediaStreamDispatcherHostInterceptorForTesting : public MediaStreamDispatcherHost {
    virtual MediaStreamDispatcherHost* GetForwardingInterface() = 0;
    void GenerateStreams(int32_t request_id, const ::blink::StreamControls& controls, bool user_gesture, StreamSelectionInfoPtr audio_stream_selection_info,
        GenerateStreamsCallback callback) override;
    void FocusCapturedSurface(const WTF::String& label, bool focus) override;
    void CancelRequest(int32_t request_id) override;
    void StopStreamDevice(const WTF::String& device_id, const std::optional<::base::UnguessableToken>& session_id) override;
    void OpenDevice(int32_t request_id, const WTF::String& device_id, MediaStreamType type, OpenDeviceCallback callback) override;
    void CloseDevice(const WTF::String& label) override;
    void SetCapturingLinkSecured(const std::optional<::base::UnguessableToken>& session_id, MediaStreamType type, bool is_secure) override;
    void ApplySubCaptureTarget(const ::base::UnguessableToken& session_id, ::media::mojom::blink::SubCaptureTargetType type,
        const ::base::Token& sub_capture_target, uint32_t sub_capture_target_version, ApplySubCaptureTargetCallback callback) override;
    void SendWheel(const ::base::UnguessableToken& session_id, CapturedWheelActionPtr action, SendWheelCallback callback) override;
    void SetZoomLevel(const ::base::UnguessableToken& session_id, int32_t zoom_level, SetZoomLevelCallback callback) override;
    void RequestCapturedSurfaceControlPermission(const ::base::UnguessableToken& session_id, RequestCapturedSurfaceControlPermissionCallback callback) override;
    void GetOpenDevice(
        int32_t request_id, const ::base::UnguessableToken& session_id, const ::base::UnguessableToken& transfer_id, GetOpenDeviceCallback callback) override;
    void KeepDeviceAliveForTransfer(
        const ::base::UnguessableToken& session_id, const ::base::UnguessableToken& transfer_id, KeepDeviceAliveForTransferCallback callback) override;
};
class PLATFORM_EXPORT MediaStreamDispatcherHostAsyncWaiter {
public:
    explicit MediaStreamDispatcherHostAsyncWaiter(MediaStreamDispatcherHost* proxy);

    MediaStreamDispatcherHostAsyncWaiter(const MediaStreamDispatcherHostAsyncWaiter&) = delete;
    MediaStreamDispatcherHostAsyncWaiter& operator=(const MediaStreamDispatcherHostAsyncWaiter&) = delete;

    ~MediaStreamDispatcherHostAsyncWaiter();
    void GenerateStreams(int32_t request_id, const ::blink::StreamControls& controls, bool user_gesture, StreamSelectionInfoPtr audio_stream_selection_info,
        MediaStreamRequestResult* out_result, WTF::String* out_label, StreamDevicesSetPtr* out_stream_devices, bool* out_pan_tilt_zoom_allowed);

    void OpenDevice(int32_t request_id, const WTF::String& device_id, MediaStreamType type, bool* out_success, WTF::String* out_label,
        ::blink::MediaStreamDevice* out_device);

    void ApplySubCaptureTarget(const ::base::UnguessableToken& session_id, ::media::mojom::blink::SubCaptureTargetType type,
        const ::base::Token& sub_capture_target, uint32_t sub_capture_target_version, ::media::mojom::blink::ApplySubCaptureTargetResult* out_result);
    ::media::mojom::blink::ApplySubCaptureTargetResult ApplySubCaptureTarget(const ::base::UnguessableToken& session_id,
        ::media::mojom::blink::SubCaptureTargetType type, const ::base::Token& sub_capture_target, uint32_t sub_capture_target_version);
    void SendWheel(const ::base::UnguessableToken& session_id, CapturedWheelActionPtr action, CapturedSurfaceControlResult* out_result);
    CapturedSurfaceControlResult SendWheel(const ::base::UnguessableToken& session_id, CapturedWheelActionPtr action);
    void SetZoomLevel(const ::base::UnguessableToken& session_id, int32_t zoom_level, CapturedSurfaceControlResult* out_result);
    CapturedSurfaceControlResult SetZoomLevel(const ::base::UnguessableToken& session_id, int32_t zoom_level);
    void RequestCapturedSurfaceControlPermission(const ::base::UnguessableToken& session_id, CapturedSurfaceControlResult* out_result);
    CapturedSurfaceControlResult RequestCapturedSurfaceControlPermission(const ::base::UnguessableToken& session_id);
    void GetOpenDevice(int32_t request_id, const ::base::UnguessableToken& session_id, const ::base::UnguessableToken& transfer_id,
        MediaStreamRequestResult* out_result, GetOpenDeviceResponsePtr* out_response);

    void KeepDeviceAliveForTransfer(const ::base::UnguessableToken& session_id, const ::base::UnguessableToken& transfer_id, bool* out_device_found);
    bool KeepDeviceAliveForTransfer(const ::base::UnguessableToken& session_id, const ::base::UnguessableToken& transfer_id);

private:
    MediaStreamDispatcherHost* const proxy_;
};

class PLATFORM_EXPORT MediaStreamTrackMetricsHostInterceptorForTesting : public MediaStreamTrackMetricsHost {
    virtual MediaStreamTrackMetricsHost* GetForwardingInterface() = 0;
    void AddTrack(uint64_t id, bool is_audio, bool is_remote) override;
    void RemoveTrack(uint64_t id) override;
};
class PLATFORM_EXPORT MediaStreamTrackMetricsHostAsyncWaiter {
public:
    explicit MediaStreamTrackMetricsHostAsyncWaiter(MediaStreamTrackMetricsHost* proxy);

    MediaStreamTrackMetricsHostAsyncWaiter(const MediaStreamTrackMetricsHostAsyncWaiter&) = delete;
    MediaStreamTrackMetricsHostAsyncWaiter& operator=(const MediaStreamTrackMetricsHostAsyncWaiter&) = delete;

    ~MediaStreamTrackMetricsHostAsyncWaiter();

private:
    MediaStreamTrackMetricsHost* const proxy_;
};

} // blink::mojom::blink

#endif // THIRD_PARTY_BLINK_PUBLIC_MOJOM_MEDIASTREAM_MEDIA_STREAM_MOJOM_BLINK_TEST_UTILS_H_
