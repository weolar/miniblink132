// third_party/blink/public/mojom/loader/navigation_predictor.mojom-shared.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef THIRD_PARTY_BLINK_PUBLIC_MOJOM_LOADER_NAVIGATION_PREDICTOR_MOJOM_SHARED_H_
#define THIRD_PARTY_BLINK_PUBLIC_MOJOM_LOADER_NAVIGATION_PREDICTOR_MOJOM_SHARED_H_

#include <stdint.h>

#include <functional>
#include <iosfwd>
#include <type_traits>
#include <utility>
#include "mojo/public/cpp/bindings/array_data_view.h"
#include "mojo/public/cpp/bindings/enum_traits.h"
#include "mojo/public/cpp/bindings/interface_data_view.h"
#include "mojo/public/cpp/bindings/lib/bindings_internal.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/map_data_view.h"
#include "mojo/public/cpp/bindings/string_data_view.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "third_party/blink/public/mojom/loader/navigation_predictor.mojom-shared-internal.h"
#include "mojo/public/mojom/base/time.mojom-shared.h"
#include "url/mojom/url.mojom-shared.h"
#include "ui/gfx/geometry/mojom/geometry.mojom-shared.h"
#include "third_party/blink/public/mojom/preloading/anchor_element_interaction_host.mojom-shared.h"
#include "mojo/public/cpp/bindings/lib/interface_serialization.h"
#include "mojo/public/cpp/system/data_pipe.h"

#include "base/component_export.h"

namespace blink::mojom {
class AnchorElementMetricsDataView;

class AnchorElementClickDataView;

class AnchorElementPointerDataOnHoverTimerFiredDataView;

class AnchorElementEnteredViewportDataView;

class AnchorElementLeftViewportDataView;

class AnchorElementPointerOverDataView;

class AnchorElementPointerOutDataView;

class AnchorElementPointerEventForMLModelDataView;

class AnchorElementPointerDownDataView;

class AnchorElementPositionUpdateDataView;

} // blink::mojom

namespace mojo {
namespace internal {

template <> struct MojomTypeTraits<::blink::mojom::AnchorElementMetricsDataView> {
    using Data = ::blink::mojom::internal::AnchorElementMetrics_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::blink::mojom::AnchorElementClickDataView> {
    using Data = ::blink::mojom::internal::AnchorElementClick_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::blink::mojom::AnchorElementPointerDataOnHoverTimerFiredDataView> {
    using Data = ::blink::mojom::internal::AnchorElementPointerDataOnHoverTimerFired_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::blink::mojom::AnchorElementEnteredViewportDataView> {
    using Data = ::blink::mojom::internal::AnchorElementEnteredViewport_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::blink::mojom::AnchorElementLeftViewportDataView> {
    using Data = ::blink::mojom::internal::AnchorElementLeftViewport_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::blink::mojom::AnchorElementPointerOverDataView> {
    using Data = ::blink::mojom::internal::AnchorElementPointerOver_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::blink::mojom::AnchorElementPointerOutDataView> {
    using Data = ::blink::mojom::internal::AnchorElementPointerOut_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::blink::mojom::AnchorElementPointerEventForMLModelDataView> {
    using Data = ::blink::mojom::internal::AnchorElementPointerEventForMLModel_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::blink::mojom::AnchorElementPointerDownDataView> {
    using Data = ::blink::mojom::internal::AnchorElementPointerDown_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::blink::mojom::AnchorElementPositionUpdateDataView> {
    using Data = ::blink::mojom::internal::AnchorElementPositionUpdate_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

} // namespace internal
} // namespace mojo

namespace blink::mojom {

enum class AnchorElementUserInteractionEventForMLModelType : int32_t {

    kPointerOver = 0,

    kPointerOut = 1,

    kEnteredViewport = 2,

    kLeftViewport = 3,

    kUnknown = 4,
    kMinValue = 0,
    kMaxValue = 4,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, AnchorElementUserInteractionEventForMLModelType value);
inline bool IsKnownEnumValue(AnchorElementUserInteractionEventForMLModelType value)
{
    return internal::AnchorElementUserInteractionEventForMLModelType_Data::IsKnownValue(static_cast<int32_t>(value));
}
// Interface base classes. They are used for type safety check.
class AnchorElementMetricsHostInterfaceBase { };

using AnchorElementMetricsHostPtrDataView = mojo::InterfacePtrDataView<AnchorElementMetricsHostInterfaceBase>;
using AnchorElementMetricsHostRequestDataView = mojo::InterfaceRequestDataView<AnchorElementMetricsHostInterfaceBase>;
using AnchorElementMetricsHostAssociatedPtrInfoDataView = mojo::AssociatedInterfacePtrInfoDataView<AnchorElementMetricsHostInterfaceBase>;
using AnchorElementMetricsHostAssociatedRequestDataView = mojo::AssociatedInterfaceRequestDataView<AnchorElementMetricsHostInterfaceBase>;

class AnchorElementMetricsDataView {
public:
    AnchorElementMetricsDataView() = default;

    AnchorElementMetricsDataView(internal::AnchorElementMetrics_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    uint32_t anchor_id() const
    {
        return data_->anchor_id;
    }
    float ratio_area() const
    {
        return data_->ratio_area;
    }
    float ratio_distance_top_to_visible_top() const
    {
        return data_->ratio_distance_top_to_visible_top;
    }
    float ratio_distance_root_top() const
    {
        return data_->ratio_distance_root_top;
    }
    bool is_in_iframe() const
    {
        return data_->is_in_iframe;
    }
    bool contains_image() const
    {
        return data_->contains_image;
    }
    bool is_same_host() const
    {
        return data_->is_same_host;
    }
    bool is_url_incremented_by_one() const
    {
        return data_->is_url_incremented_by_one;
    }
    bool has_text_sibling() const
    {
        return data_->has_text_sibling;
    }
    uint32_t font_size_px() const
    {
        return data_->font_size_px;
    }
    uint32_t font_weight() const
    {
        return data_->font_weight;
    }
    inline void GetTargetUrlDataView(::url::mojom::UrlDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadTargetUrl(UserType* output)
    {

        auto* pointer = data_->target_url.Get();
        return mojo::internal::Deserialize<::url::mojom::UrlDataView>(pointer, output, message_);
    }
    inline void GetViewportSizeDataView(::gfx::mojom::SizeDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadViewportSize(UserType* output)
    {

        auto* pointer = data_->viewport_size.Get();
        return mojo::internal::Deserialize<::gfx::mojom::SizeDataView>(pointer, output, message_);
    }

private:
    internal::AnchorElementMetrics_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class AnchorElementClickDataView {
public:
    AnchorElementClickDataView() = default;

    AnchorElementClickDataView(internal::AnchorElementClick_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    uint32_t anchor_id() const
    {
        return data_->anchor_id;
    }
    inline void GetTargetUrlDataView(::url::mojom::UrlDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadTargetUrl(UserType* output)
    {

        auto* pointer = data_->target_url.Get();
        return mojo::internal::Deserialize<::url::mojom::UrlDataView>(pointer, output, message_);
    }
    inline void GetNavigationStartToClickDataView(::mojo_base::mojom::TimeDeltaDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadNavigationStartToClick(UserType* output)
    {

        auto* pointer = data_->navigation_start_to_click.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(pointer, output, message_);
    }

private:
    internal::AnchorElementClick_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class AnchorElementPointerDataOnHoverTimerFiredDataView {
public:
    AnchorElementPointerDataOnHoverTimerFiredDataView() = default;

    AnchorElementPointerDataOnHoverTimerFiredDataView(internal::AnchorElementPointerDataOnHoverTimerFired_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    uint32_t anchor_id() const
    {
        return data_->anchor_id;
    }
    inline void GetPointerDataDataView(::blink::mojom::AnchorElementPointerDataDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadPointerData(UserType* output)
    {

        auto* pointer = data_->pointer_data.Get();
        return mojo::internal::Deserialize<::blink::mojom::AnchorElementPointerDataDataView>(pointer, output, message_);
    }

private:
    internal::AnchorElementPointerDataOnHoverTimerFired_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class AnchorElementEnteredViewportDataView {
public:
    AnchorElementEnteredViewportDataView() = default;

    AnchorElementEnteredViewportDataView(internal::AnchorElementEnteredViewport_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    uint32_t anchor_id() const
    {
        return data_->anchor_id;
    }
    inline void GetNavigationStartToEnteredViewportDataView(::mojo_base::mojom::TimeDeltaDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadNavigationStartToEnteredViewport(UserType* output)
    {

        auto* pointer = data_->navigation_start_to_entered_viewport.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(pointer, output, message_);
    }

private:
    internal::AnchorElementEnteredViewport_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class AnchorElementLeftViewportDataView {
public:
    AnchorElementLeftViewportDataView() = default;

    AnchorElementLeftViewportDataView(internal::AnchorElementLeftViewport_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    uint32_t anchor_id() const
    {
        return data_->anchor_id;
    }
    inline void GetTimeInViewportDataView(::mojo_base::mojom::TimeDeltaDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadTimeInViewport(UserType* output)
    {

        auto* pointer = data_->time_in_viewport.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(pointer, output, message_);
    }

private:
    internal::AnchorElementLeftViewport_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class AnchorElementPointerOverDataView {
public:
    AnchorElementPointerOverDataView() = default;

    AnchorElementPointerOverDataView(internal::AnchorElementPointerOver_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    uint32_t anchor_id() const
    {
        return data_->anchor_id;
    }
    inline void GetNavigationStartToPointerOverDataView(::mojo_base::mojom::TimeDeltaDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadNavigationStartToPointerOver(UserType* output)
    {

        auto* pointer = data_->navigation_start_to_pointer_over.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(pointer, output, message_);
    }

private:
    internal::AnchorElementPointerOver_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class AnchorElementPointerOutDataView {
public:
    AnchorElementPointerOutDataView() = default;

    AnchorElementPointerOutDataView(internal::AnchorElementPointerOut_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    uint32_t anchor_id() const
    {
        return data_->anchor_id;
    }
    inline void GetHoverDwellTimeDataView(::mojo_base::mojom::TimeDeltaDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadHoverDwellTime(UserType* output)
    {

        auto* pointer = data_->hover_dwell_time.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(pointer, output, message_);
    }

private:
    internal::AnchorElementPointerOut_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class AnchorElementPointerEventForMLModelDataView {
public:
    AnchorElementPointerEventForMLModelDataView() = default;

    AnchorElementPointerEventForMLModelDataView(internal::AnchorElementPointerEventForMLModel_Data* data, mojo::Message* message)
        : data_(data)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    uint32_t anchor_id() const
    {
        return data_->anchor_id;
    }
    bool is_mouse() const
    {
        return data_->is_mouse;
    }
    template <typename UserType> [[nodiscard]] bool ReadUserInteractionEventType(UserType* output) const
    {
        auto data_value = data_->user_interaction_event_type;
        return mojo::internal::Deserialize<::blink::mojom::AnchorElementUserInteractionEventForMLModelType>(data_value, output);
    }
    AnchorElementUserInteractionEventForMLModelType user_interaction_event_type() const
    {
        return ::mojo::internal::ToKnownEnumValueHelper(
            static_cast<::blink::mojom::AnchorElementUserInteractionEventForMLModelType>(data_->user_interaction_event_type));
    }

private:
    internal::AnchorElementPointerEventForMLModel_Data* data_ = nullptr;
};

class AnchorElementPointerDownDataView {
public:
    AnchorElementPointerDownDataView() = default;

    AnchorElementPointerDownDataView(internal::AnchorElementPointerDown_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    uint32_t anchor_id() const
    {
        return data_->anchor_id;
    }
    inline void GetNavigationStartToPointerDownDataView(::mojo_base::mojom::TimeDeltaDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadNavigationStartToPointerDown(UserType* output)
    {

        auto* pointer = data_->navigation_start_to_pointer_down.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(pointer, output, message_);
    }

private:
    internal::AnchorElementPointerDown_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class AnchorElementPositionUpdateDataView {
public:
    AnchorElementPositionUpdateDataView() = default;

    AnchorElementPositionUpdateDataView(internal::AnchorElementPositionUpdate_Data* data, mojo::Message* message)
        : data_(data)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    uint32_t anchor_id() const
    {
        return data_->anchor_id;
    }
    float vertical_position_ratio() const
    {
        return data_->vertical_position_ratio;
    }
    std::optional<float> distance_from_pointer_down_ratio() const
    {

        return data_->distance_from_pointer_down_ratio_$flag ? std::make_optional(data_->distance_from_pointer_down_ratio_$value) : std::nullopt;
    }

private:
    internal::AnchorElementPositionUpdate_Data* data_ = nullptr;
};

} // blink::mojom

namespace std {

template <>
struct hash<::blink::mojom::AnchorElementUserInteractionEventForMLModelType>
    : public mojo::internal::EnumHashImpl<::blink::mojom::AnchorElementUserInteractionEventForMLModelType> { };

} // namespace std

namespace mojo {

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::AnchorElementUserInteractionEventForMLModelType, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = EnumTraits<::blink::mojom::AnchorElementUserInteractionEventForMLModelType, UserType>;

    static void Serialize(UserType input, int32_t* output)
    {
        *output = static_cast<int32_t>(Traits::ToMojom(input));
    }

    static bool Deserialize(int32_t input, UserType* output)
    {
        return Traits::FromMojom(
            ::mojo::internal::ToKnownEnumValueHelper(static_cast<::blink::mojom::AnchorElementUserInteractionEventForMLModelType>(input)), output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::AnchorElementMetricsDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::blink::mojom::AnchorElementMetricsDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::blink::mojom::internal::AnchorElementMetrics_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        fragment->anchor_id = Traits::anchor_id(input);
        fragment->ratio_area = Traits::ratio_area(input);
        fragment->ratio_distance_top_to_visible_top = Traits::ratio_distance_top_to_visible_top(input);
        fragment->ratio_distance_root_top = Traits::ratio_distance_root_top(input);
        fragment->is_in_iframe = Traits::is_in_iframe(input);
        fragment->contains_image = Traits::contains_image(input);
        fragment->is_same_host = Traits::is_same_host(input);
        fragment->is_url_incremented_by_one = Traits::is_url_incremented_by_one(input);
        fragment->has_text_sibling = Traits::has_text_sibling(input);
        fragment->font_size_px = Traits::font_size_px(input);
        fragment->font_weight = Traits::font_weight(input);
        decltype(Traits::target_url(input)) in_target_url = Traits::target_url(input);
        mojo::internal::MessageFragment<typename decltype(fragment->target_url)::BaseType> target_url_fragment(fragment.message());
        mojo::internal::Serialize<::url::mojom::UrlDataView>(in_target_url, target_url_fragment);
        fragment->target_url.Set(target_url_fragment.is_null() ? nullptr : target_url_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->target_url.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null target_url in AnchorElementMetrics struct");
        decltype(Traits::viewport_size(input)) in_viewport_size = Traits::viewport_size(input);
        mojo::internal::MessageFragment<typename decltype(fragment->viewport_size)::BaseType> viewport_size_fragment(fragment.message());
        mojo::internal::Serialize<::gfx::mojom::SizeDataView>(in_viewport_size, viewport_size_fragment);
        fragment->viewport_size.Set(viewport_size_fragment.is_null() ? nullptr : viewport_size_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->viewport_size.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null viewport_size in AnchorElementMetrics struct");
    }

    static bool Deserialize(::blink::mojom::internal::AnchorElementMetrics_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::blink::mojom::AnchorElementMetricsDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::AnchorElementClickDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::blink::mojom::AnchorElementClickDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::blink::mojom::internal::AnchorElementClick_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        fragment->anchor_id = Traits::anchor_id(input);
        decltype(Traits::target_url(input)) in_target_url = Traits::target_url(input);
        mojo::internal::MessageFragment<typename decltype(fragment->target_url)::BaseType> target_url_fragment(fragment.message());
        mojo::internal::Serialize<::url::mojom::UrlDataView>(in_target_url, target_url_fragment);
        fragment->target_url.Set(target_url_fragment.is_null() ? nullptr : target_url_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->target_url.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null target_url in AnchorElementClick struct");
        decltype(Traits::navigation_start_to_click(input)) in_navigation_start_to_click = Traits::navigation_start_to_click(input);
        mojo::internal::MessageFragment<typename decltype(fragment->navigation_start_to_click)::BaseType> navigation_start_to_click_fragment(
            fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(in_navigation_start_to_click, navigation_start_to_click_fragment);
        fragment->navigation_start_to_click.Set(navigation_start_to_click_fragment.is_null() ? nullptr : navigation_start_to_click_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(fragment->navigation_start_to_click.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null navigation_start_to_click in AnchorElementClick struct");
    }

    static bool Deserialize(::blink::mojom::internal::AnchorElementClick_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::blink::mojom::AnchorElementClickDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::AnchorElementPointerDataOnHoverTimerFiredDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::blink::mojom::AnchorElementPointerDataOnHoverTimerFiredDataView, UserType>;

    static void Serialize(
        MaybeConstUserType& input, mojo::internal::MessageFragment<::blink::mojom::internal::AnchorElementPointerDataOnHoverTimerFired_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        fragment->anchor_id = Traits::anchor_id(input);
        decltype(Traits::pointer_data(input)) in_pointer_data = Traits::pointer_data(input);
        mojo::internal::MessageFragment<typename decltype(fragment->pointer_data)::BaseType> pointer_data_fragment(fragment.message());
        mojo::internal::Serialize<::blink::mojom::AnchorElementPointerDataDataView>(in_pointer_data, pointer_data_fragment);
        fragment->pointer_data.Set(pointer_data_fragment.is_null() ? nullptr : pointer_data_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(fragment->pointer_data.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null pointer_data in AnchorElementPointerDataOnHoverTimerFired struct");
    }

    static bool Deserialize(::blink::mojom::internal::AnchorElementPointerDataOnHoverTimerFired_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::blink::mojom::AnchorElementPointerDataOnHoverTimerFiredDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::AnchorElementEnteredViewportDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::blink::mojom::AnchorElementEnteredViewportDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::blink::mojom::internal::AnchorElementEnteredViewport_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        fragment->anchor_id = Traits::anchor_id(input);
        decltype(Traits::navigation_start_to_entered_viewport(input)) in_navigation_start_to_entered_viewport
            = Traits::navigation_start_to_entered_viewport(input);
        mojo::internal::MessageFragment<typename decltype(fragment->navigation_start_to_entered_viewport)::BaseType>
            navigation_start_to_entered_viewport_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
            in_navigation_start_to_entered_viewport, navigation_start_to_entered_viewport_fragment);
        fragment->navigation_start_to_entered_viewport.Set(
            navigation_start_to_entered_viewport_fragment.is_null() ? nullptr : navigation_start_to_entered_viewport_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(fragment->navigation_start_to_entered_viewport.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null navigation_start_to_entered_viewport in AnchorElementEnteredViewport struct");
    }

    static bool Deserialize(::blink::mojom::internal::AnchorElementEnteredViewport_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::blink::mojom::AnchorElementEnteredViewportDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::AnchorElementLeftViewportDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::blink::mojom::AnchorElementLeftViewportDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::blink::mojom::internal::AnchorElementLeftViewport_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        fragment->anchor_id = Traits::anchor_id(input);
        decltype(Traits::time_in_viewport(input)) in_time_in_viewport = Traits::time_in_viewport(input);
        mojo::internal::MessageFragment<typename decltype(fragment->time_in_viewport)::BaseType> time_in_viewport_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(in_time_in_viewport, time_in_viewport_fragment);
        fragment->time_in_viewport.Set(time_in_viewport_fragment.is_null() ? nullptr : time_in_viewport_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(fragment->time_in_viewport.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null time_in_viewport in AnchorElementLeftViewport struct");
    }

    static bool Deserialize(::blink::mojom::internal::AnchorElementLeftViewport_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::blink::mojom::AnchorElementLeftViewportDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::AnchorElementPointerOverDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::blink::mojom::AnchorElementPointerOverDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::blink::mojom::internal::AnchorElementPointerOver_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        fragment->anchor_id = Traits::anchor_id(input);
        decltype(Traits::navigation_start_to_pointer_over(input)) in_navigation_start_to_pointer_over = Traits::navigation_start_to_pointer_over(input);
        mojo::internal::MessageFragment<typename decltype(fragment->navigation_start_to_pointer_over)::BaseType> navigation_start_to_pointer_over_fragment(
            fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(in_navigation_start_to_pointer_over, navigation_start_to_pointer_over_fragment);
        fragment->navigation_start_to_pointer_over.Set(
            navigation_start_to_pointer_over_fragment.is_null() ? nullptr : navigation_start_to_pointer_over_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(fragment->navigation_start_to_pointer_over.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null navigation_start_to_pointer_over in AnchorElementPointerOver struct");
    }

    static bool Deserialize(::blink::mojom::internal::AnchorElementPointerOver_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::blink::mojom::AnchorElementPointerOverDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::AnchorElementPointerOutDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::blink::mojom::AnchorElementPointerOutDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::blink::mojom::internal::AnchorElementPointerOut_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        fragment->anchor_id = Traits::anchor_id(input);
        decltype(Traits::hover_dwell_time(input)) in_hover_dwell_time = Traits::hover_dwell_time(input);
        mojo::internal::MessageFragment<typename decltype(fragment->hover_dwell_time)::BaseType> hover_dwell_time_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(in_hover_dwell_time, hover_dwell_time_fragment);
        fragment->hover_dwell_time.Set(hover_dwell_time_fragment.is_null() ? nullptr : hover_dwell_time_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(fragment->hover_dwell_time.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null hover_dwell_time in AnchorElementPointerOut struct");
    }

    static bool Deserialize(::blink::mojom::internal::AnchorElementPointerOut_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::blink::mojom::AnchorElementPointerOutDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::AnchorElementPointerEventForMLModelDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::blink::mojom::AnchorElementPointerEventForMLModelDataView, UserType>;

    static void Serialize(
        MaybeConstUserType& input, mojo::internal::MessageFragment<::blink::mojom::internal::AnchorElementPointerEventForMLModel_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        fragment->anchor_id = Traits::anchor_id(input);
        fragment->is_mouse = Traits::is_mouse(input);
        mojo::internal::Serialize<::blink::mojom::AnchorElementUserInteractionEventForMLModelType>(
            Traits::user_interaction_event_type(input), &fragment->user_interaction_event_type);
    }

    static bool Deserialize(::blink::mojom::internal::AnchorElementPointerEventForMLModel_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::blink::mojom::AnchorElementPointerEventForMLModelDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::AnchorElementPointerDownDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::blink::mojom::AnchorElementPointerDownDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::blink::mojom::internal::AnchorElementPointerDown_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        fragment->anchor_id = Traits::anchor_id(input);
        decltype(Traits::navigation_start_to_pointer_down(input)) in_navigation_start_to_pointer_down = Traits::navigation_start_to_pointer_down(input);
        mojo::internal::MessageFragment<typename decltype(fragment->navigation_start_to_pointer_down)::BaseType> navigation_start_to_pointer_down_fragment(
            fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(in_navigation_start_to_pointer_down, navigation_start_to_pointer_down_fragment);
        fragment->navigation_start_to_pointer_down.Set(
            navigation_start_to_pointer_down_fragment.is_null() ? nullptr : navigation_start_to_pointer_down_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(fragment->navigation_start_to_pointer_down.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null navigation_start_to_pointer_down in AnchorElementPointerDown struct");
    }

    static bool Deserialize(::blink::mojom::internal::AnchorElementPointerDown_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::blink::mojom::AnchorElementPointerDownDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::AnchorElementPositionUpdateDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::blink::mojom::AnchorElementPositionUpdateDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::blink::mojom::internal::AnchorElementPositionUpdate_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        fragment->anchor_id = Traits::anchor_id(input);
        fragment->vertical_position_ratio = Traits::vertical_position_ratio(input);
        fragment->distance_from_pointer_down_ratio_$flag = Traits::distance_from_pointer_down_ratio(input).has_value();
        if (Traits::distance_from_pointer_down_ratio(input).has_value()) {
            fragment->distance_from_pointer_down_ratio_$value = Traits::distance_from_pointer_down_ratio(input).value();
        }
    }

    static bool Deserialize(::blink::mojom::internal::AnchorElementPositionUpdate_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::blink::mojom::AnchorElementPositionUpdateDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

} // namespace mojo

namespace blink::mojom {

inline void AnchorElementMetricsDataView::GetTargetUrlDataView(::url::mojom::UrlDataView* output)
{
    auto pointer = data_->target_url.Get();
    *output = ::url::mojom::UrlDataView(pointer, message_);
}
inline void AnchorElementMetricsDataView::GetViewportSizeDataView(::gfx::mojom::SizeDataView* output)
{
    auto pointer = data_->viewport_size.Get();
    *output = ::gfx::mojom::SizeDataView(pointer, message_);
}

inline void AnchorElementClickDataView::GetTargetUrlDataView(::url::mojom::UrlDataView* output)
{
    auto pointer = data_->target_url.Get();
    *output = ::url::mojom::UrlDataView(pointer, message_);
}
inline void AnchorElementClickDataView::GetNavigationStartToClickDataView(::mojo_base::mojom::TimeDeltaDataView* output)
{
    auto pointer = data_->navigation_start_to_click.Get();
    *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}

inline void AnchorElementPointerDataOnHoverTimerFiredDataView::GetPointerDataDataView(::blink::mojom::AnchorElementPointerDataDataView* output)
{
    auto pointer = data_->pointer_data.Get();
    *output = ::blink::mojom::AnchorElementPointerDataDataView(pointer, message_);
}

inline void AnchorElementEnteredViewportDataView::GetNavigationStartToEnteredViewportDataView(::mojo_base::mojom::TimeDeltaDataView* output)
{
    auto pointer = data_->navigation_start_to_entered_viewport.Get();
    *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}

inline void AnchorElementLeftViewportDataView::GetTimeInViewportDataView(::mojo_base::mojom::TimeDeltaDataView* output)
{
    auto pointer = data_->time_in_viewport.Get();
    *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}

inline void AnchorElementPointerOverDataView::GetNavigationStartToPointerOverDataView(::mojo_base::mojom::TimeDeltaDataView* output)
{
    auto pointer = data_->navigation_start_to_pointer_over.Get();
    *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}

inline void AnchorElementPointerOutDataView::GetHoverDwellTimeDataView(::mojo_base::mojom::TimeDeltaDataView* output)
{
    auto pointer = data_->hover_dwell_time.Get();
    *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}

inline void AnchorElementPointerDownDataView::GetNavigationStartToPointerDownDataView(::mojo_base::mojom::TimeDeltaDataView* output)
{
    auto pointer = data_->navigation_start_to_pointer_down.Get();
    *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}

} // blink::mojom

// Declare TraceFormatTraits for enums, which should be defined in ::perfetto
// namespace.

namespace perfetto {

template <> struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::AnchorElementUserInteractionEventForMLModelType> {
    static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::AnchorElementUserInteractionEventForMLModelType value);
};

} // namespace perfetto

#endif // THIRD_PARTY_BLINK_PUBLIC_MOJOM_LOADER_NAVIGATION_PREDICTOR_MOJOM_SHARED_H_
