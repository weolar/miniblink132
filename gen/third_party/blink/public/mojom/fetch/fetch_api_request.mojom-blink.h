// third_party/blink/public/mojom/fetch/fetch_api_request.mojom-blink.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef THIRD_PARTY_BLINK_PUBLIC_MOJOM_FETCH_FETCH_API_REQUEST_MOJOM_BLINK_H_
#define THIRD_PARTY_BLINK_PUBLIC_MOJOM_FETCH_FETCH_API_REQUEST_MOJOM_BLINK_H_

#include <stdint.h>

#include <limits>
#include <optional>
#include <type_traits>
#include <utility>

#include "base/types/cxx23_to_underlying.h"
#include "mojo/public/cpp/bindings/clone_traits.h"
#include "mojo/public/cpp/bindings/equals_traits.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/struct_ptr.h"
#include "mojo/public/cpp/bindings/struct_traits.h"
#include "mojo/public/cpp/bindings/union_traits.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "third_party/blink/public/mojom/fetch/fetch_api_request.mojom-features.h" // IWYU pragma: export
#include "third_party/blink/public/mojom/fetch/fetch_api_request.mojom-shared.h" // IWYU pragma: export
#include "third_party/blink/public/mojom/fetch/fetch_api_request.mojom-blink-forward.h" // IWYU pragma: export
#include "mojo/public/mojom/base/unguessable_token.mojom-blink.h"
#include "services/network/public/mojom/attribution.mojom-blink-forward.h"
#include "services/network/public/mojom/ip_address_space.mojom-blink-forward.h"
#include "services/network/public/mojom/chunked_data_pipe_getter.mojom-blink-forward.h"
#include "services/network/public/mojom/fetch_api.mojom-blink-forward.h"
#include "services/network/public/mojom/request_priority.mojom-blink.h"
#include "services/network/public/mojom/trust_tokens.mojom-blink.h"
#include "services/network/public/mojom/url_request.mojom-blink.h"
#include "third_party/blink/public/mojom/blob/serialized_blob.mojom-blink.h"
#include "third_party/blink/public/mojom/loader/request_context_frame_type.mojom-blink-forward.h"
#include "third_party/blink/public/mojom/loader/referrer.mojom-blink.h"
#include "url/mojom/origin.mojom-blink.h"
#include "url/mojom/url.mojom-blink.h"

#include "mojo/public/cpp/bindings/lib/wtf_clone_equals_util.h"
#include "mojo/public/cpp/bindings/lib/wtf_hash_util.h"
#include "third_party/blink/renderer/platform/wtf/hash_functions.h"
#include "third_party/blink/renderer/platform/wtf/text/wtf_string.h"

#include "mojo/public/cpp/bindings/lib/control_message_handler.h"
#include "mojo/public/cpp/bindings/lib/message_size_estimator.h"
#include "mojo/public/cpp/bindings/raw_ptr_impl_ref_traits.h"

#include "third_party/blink/renderer/platform/loader/fetch/resource_request.h"
#include "third_party/blink/renderer/platform/mojo/fetch_api_request_headers_mojom_traits.h"
#include "third_party/blink/renderer/platform/platform_export.h"
#if !BLINK_MOJO_IMPL && !INSIDE_BLINK
#error "File must only be imported inside blink"
#endif

namespace blink::mojom::blink {

class PLATFORM_EXPORT FetchAPIRequestHeaders {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<FetchAPIRequestHeaders, T>::value>;
    using DataView = FetchAPIRequestHeadersDataView;
    using Data_ = internal::FetchAPIRequestHeaders_Data;

    template <typename... Args> static FetchAPIRequestHeadersPtr New(Args&&... args)
    {
        return FetchAPIRequestHeadersPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static FetchAPIRequestHeadersPtr From(const U& u)
    {
        return mojo::TypeConverter<FetchAPIRequestHeadersPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, FetchAPIRequestHeaders>::Convert(*this);
    }

    FetchAPIRequestHeaders()
    : headers()
{
}

    explicit FetchAPIRequestHeaders(const WTF::HashMap<WTF::String, WTF::String>& headers_in)
    : headers(std::move(headers_in)){
}

    ~FetchAPIRequestHeaders() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = FetchAPIRequestHeadersPtr> FetchAPIRequestHeadersPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, FetchAPIRequestHeaders::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, FetchAPIRequestHeaders::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, FetchAPIRequestHeaders::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<FetchAPIRequestHeaders::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<FetchAPIRequestHeaders::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::FetchAPIRequestHeaders_UnserializedMessageContext<UserType, FetchAPIRequestHeaders::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<FetchAPIRequestHeaders::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return FetchAPIRequestHeaders::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::FetchAPIRequestHeaders_UnserializedMessageContext<UserType, FetchAPIRequestHeaders::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<FetchAPIRequestHeaders::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    WTF::HashMap<WTF::String, WTF::String> headers;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, FetchAPIRequestHeaders::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, FetchAPIRequestHeaders::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, FetchAPIRequestHeaders::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, FetchAPIRequestHeaders::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class PLATFORM_EXPORT FetchAPIRequestBody {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<FetchAPIRequestBody, T>::value>;
    using DataView = FetchAPIRequestBodyDataView;
    using Data_ = internal::FetchAPIRequestBody_Data;

    template <typename... Args> static FetchAPIRequestBodyPtr New(Args&&... args)
    {
        return FetchAPIRequestBodyPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static FetchAPIRequestBodyPtr From(const U& u)
    {
        return mojo::TypeConverter<FetchAPIRequestBodyPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, FetchAPIRequestBody>::Convert(*this);
    }

    FetchAPIRequestBody()
    : elements()
    , identifier()
    , contains_sensitive_info()
{
}

    FetchAPIRequestBody(WTF::Vector<::network::DataElement> elements_in, uint64_t identifier_in, bool contains_sensitive_info_in)
    : elements(std::move(elements_in))
    , identifier(std::move(identifier_in))
    , contains_sensitive_info(std::move(contains_sensitive_info_in)){
}

    FetchAPIRequestBody(const FetchAPIRequestBody&) = delete;
    FetchAPIRequestBody& operator=(const FetchAPIRequestBody&) = delete;

    ~FetchAPIRequestBody() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = FetchAPIRequestBodyPtr> FetchAPIRequestBodyPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, FetchAPIRequestBody::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, FetchAPIRequestBody::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, FetchAPIRequestBody::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<FetchAPIRequestBody::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::FetchAPIRequestBody_UnserializedMessageContext<UserType, FetchAPIRequestBody::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<FetchAPIRequestBody::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return FetchAPIRequestBody::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::FetchAPIRequestBody_UnserializedMessageContext<UserType, FetchAPIRequestBody::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<FetchAPIRequestBody::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    WTF::Vector<::network::DataElement> elements;

    uint64_t identifier;

    bool contains_sensitive_info;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, FetchAPIRequestBody::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, FetchAPIRequestBody::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, FetchAPIRequestBody::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, FetchAPIRequestBody::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class PLATFORM_EXPORT FetchAPIRequest {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<FetchAPIRequest, T>::value>;
    using DataView = FetchAPIRequestDataView;
    using Data_ = internal::FetchAPIRequest_Data;

    template <typename... Args> static FetchAPIRequestPtr New(Args&&... args)
    {
        return FetchAPIRequestPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static FetchAPIRequestPtr From(const U& u)
    {
        return mojo::TypeConverter<FetchAPIRequestPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, FetchAPIRequest>::Convert(*this);
    }

    FetchAPIRequest()
    : mode(::network::mojom::blink::RequestMode::kNoCors)
    , is_main_resource_load(false)
    , destination(::network::mojom::blink::RequestDestination::kEmpty)
    , frame_type(::blink::mojom::blink::RequestContextFrameType::kNone)
    , url()
    , method()
    , headers()
    , blob()
    , body()
    , request_initiator()
    , navigation_redirect_chain()
    , referrer()
    , credentials_mode(::network::mojom::blink::CredentialsMode::kOmit)
    , cache_mode(FetchCacheMode::kDefault)
    , redirect_mode(::network::mojom::blink::RedirectMode::kFollow)
    , integrity()
    , priority(
          mojo::internal::ConvertEnumValue<::network::mojom::blink::RequestPriority, ::net::RequestPriority>(::network::mojom::blink::RequestPriority::kIdle))
    , fetch_window_id()
    , keepalive(false)
    , is_reload(false)
    , is_history_navigation(false)
    , devtools_stack_id()
    , trust_token_params()
    , target_address_space(::network::mojom::blink::IPAddressSpace::kUnknown)
    , attribution_reporting_eligibility(::network::mojom::blink::AttributionReportingEligibility::kUnset)
    , attribution_reporting_support(::network::mojom::blink::AttributionSupport::kUnset)
    , service_worker_race_network_request_token()
{
}

    FetchAPIRequest(::network::mojom::blink::RequestMode mode_in, bool is_main_resource_load_in,
    ::network::mojom::blink::RequestDestination destination_in, ::blink::mojom::blink::RequestContextFrameType frame_type_in, const ::blink::KURL& url_in,
    const WTF::String& method_in, ::WTF::HashMap<::WTF::String, WTF::String, WTF::CaseFoldingHashTraits<WTF::String>> headers_in,
    const ::scoped_refptr<::blink::BlobDataHandle>& blob_in, ::blink::ResourceRequestBody body_in,
    const ::scoped_refptr<const ::blink::SecurityOrigin>& request_initiator_in, WTF::Vector<::blink::KURL> navigation_redirect_chain_in,
    ::blink::mojom::blink::ReferrerPtr referrer_in, ::network::mojom::blink::CredentialsMode credentials_mode_in, FetchCacheMode cache_mode_in,
    ::network::mojom::blink::RedirectMode redirect_mode_in, const WTF::String& integrity_in, ::net::RequestPriority priority_in,
    const std::optional<::base::UnguessableToken>& fetch_window_id_in, bool keepalive_in, bool is_reload_in, bool is_history_navigation_in,
    const WTF::String& devtools_stack_id_in, ::network::mojom::blink::TrustTokenParamsPtr trust_token_params_in,
    ::network::mojom::blink::IPAddressSpace target_address_space_in,
    ::network::mojom::blink::AttributionReportingEligibility attribution_reporting_eligibility_in,
    ::network::mojom::blink::AttributionSupport attribution_reporting_support_in,
    const std::optional<::base::UnguessableToken>& service_worker_race_network_request_token_in)
    : mode(std::move(mode_in))
    , is_main_resource_load(std::move(is_main_resource_load_in))
    , destination(std::move(destination_in))
    , frame_type(std::move(frame_type_in))
    , url(std::move(url_in))
    , method(std::move(method_in))
    , headers(std::move(headers_in))
    , blob(std::move(blob_in))
    , body(std::move(body_in))
    , request_initiator(std::move(request_initiator_in))
    , navigation_redirect_chain(std::move(navigation_redirect_chain_in))
    , referrer(std::move(referrer_in))
    , credentials_mode(std::move(credentials_mode_in))
    , cache_mode(std::move(cache_mode_in))
    , redirect_mode(std::move(redirect_mode_in))
    , integrity(std::move(integrity_in))
    , priority(std::move(priority_in))
    , fetch_window_id(std::move(fetch_window_id_in))
    , keepalive(std::move(keepalive_in))
    , is_reload(std::move(is_reload_in))
    , is_history_navigation(std::move(is_history_navigation_in))
    , devtools_stack_id(std::move(devtools_stack_id_in))
    , trust_token_params(std::move(trust_token_params_in))
    , target_address_space(std::move(target_address_space_in))
    , attribution_reporting_eligibility(std::move(attribution_reporting_eligibility_in))
    , attribution_reporting_support(std::move(attribution_reporting_support_in))
    , service_worker_race_network_request_token(std::move(service_worker_race_network_request_token_in)){
}

    FetchAPIRequest(const FetchAPIRequest&) = delete;
    FetchAPIRequest& operator=(const FetchAPIRequest&) = delete;

    ~FetchAPIRequest() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = FetchAPIRequestPtr> FetchAPIRequestPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, FetchAPIRequest::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, FetchAPIRequest::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, FetchAPIRequest::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<FetchAPIRequest::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::FetchAPIRequest_UnserializedMessageContext<UserType, FetchAPIRequest::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<FetchAPIRequest::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return FetchAPIRequest::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::FetchAPIRequest_UnserializedMessageContext<UserType, FetchAPIRequest::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<FetchAPIRequest::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    ::network::mojom::blink::RequestMode mode;

    bool is_main_resource_load;

    ::network::mojom::blink::RequestDestination destination;

    ::blink::mojom::blink::RequestContextFrameType frame_type;

    ::blink::KURL url;

    WTF::String method;

    ::WTF::HashMap<::WTF::String, WTF::String, WTF::CaseFoldingHashTraits<WTF::String>> headers;

    ::scoped_refptr<::blink::BlobDataHandle> blob;

    ::blink::ResourceRequestBody body;

    ::scoped_refptr<const ::blink::SecurityOrigin> request_initiator;

    WTF::Vector<::blink::KURL> navigation_redirect_chain;

    ::blink::mojom::blink::ReferrerPtr referrer;

    ::network::mojom::blink::CredentialsMode credentials_mode;

    FetchCacheMode cache_mode;

    ::network::mojom::blink::RedirectMode redirect_mode;

    WTF::String integrity;

    ::net::RequestPriority priority;

    std::optional<::base::UnguessableToken> fetch_window_id;

    bool keepalive;

    bool is_reload;

    bool is_history_navigation;

    WTF::String devtools_stack_id;

    ::network::mojom::blink::TrustTokenParamsPtr trust_token_params;

    ::network::mojom::blink::IPAddressSpace target_address_space;

    ::network::mojom::blink::AttributionReportingEligibility attribution_reporting_eligibility;

    ::network::mojom::blink::AttributionSupport attribution_reporting_support;

    std::optional<::base::UnguessableToken> service_worker_race_network_request_token;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, FetchAPIRequest::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, FetchAPIRequest::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, FetchAPIRequest::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, FetchAPIRequest::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

template <typename StructPtrType> FetchAPIRequestHeadersPtr FetchAPIRequestHeaders::Clone() const
{
    return New(mojo::Clone(headers));
}

template <typename T, FetchAPIRequestHeaders::EnableIfSame<T>*> bool FetchAPIRequestHeaders::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->headers, other_struct.headers))
        return false;
    return true;
}

template <typename T, FetchAPIRequestHeaders::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.headers < rhs.headers)
        return true;
    if (rhs.headers < lhs.headers)
        return false;
    return false;
}
template <typename StructPtrType> FetchAPIRequestBodyPtr FetchAPIRequestBody::Clone() const
{
    return New(mojo::Clone(elements), mojo::Clone(identifier), mojo::Clone(contains_sensitive_info));
}

template <typename T, FetchAPIRequestBody::EnableIfSame<T>*> bool FetchAPIRequestBody::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->elements, other_struct.elements))
        return false;
    if (!mojo::Equals(this->identifier, other_struct.identifier))
        return false;
    if (!mojo::Equals(this->contains_sensitive_info, other_struct.contains_sensitive_info))
        return false;
    return true;
}

template <typename T, FetchAPIRequestBody::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.elements < rhs.elements)
        return true;
    if (rhs.elements < lhs.elements)
        return false;
    if (lhs.identifier < rhs.identifier)
        return true;
    if (rhs.identifier < lhs.identifier)
        return false;
    if (lhs.contains_sensitive_info < rhs.contains_sensitive_info)
        return true;
    if (rhs.contains_sensitive_info < lhs.contains_sensitive_info)
        return false;
    return false;
}
template <typename StructPtrType> FetchAPIRequestPtr FetchAPIRequest::Clone() const
{
    return New(mojo::Clone(mode), mojo::Clone(is_main_resource_load), mojo::Clone(destination), mojo::Clone(frame_type), mojo::Clone(url), mojo::Clone(method),
        mojo::Clone(headers), mojo::Clone(blob), mojo::Clone(body), mojo::Clone(request_initiator), mojo::Clone(navigation_redirect_chain),
        mojo::Clone(referrer), mojo::Clone(credentials_mode), mojo::Clone(cache_mode), mojo::Clone(redirect_mode), mojo::Clone(integrity),
        mojo::Clone(priority), mojo::Clone(fetch_window_id), mojo::Clone(keepalive), mojo::Clone(is_reload), mojo::Clone(is_history_navigation),
        mojo::Clone(devtools_stack_id), mojo::Clone(trust_token_params), mojo::Clone(target_address_space), mojo::Clone(attribution_reporting_eligibility),
        mojo::Clone(attribution_reporting_support), mojo::Clone(service_worker_race_network_request_token));
}

template <typename T, FetchAPIRequest::EnableIfSame<T>*> bool FetchAPIRequest::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->mode, other_struct.mode))
        return false;
    if (!mojo::Equals(this->is_main_resource_load, other_struct.is_main_resource_load))
        return false;
    if (!mojo::Equals(this->destination, other_struct.destination))
        return false;
    if (!mojo::Equals(this->frame_type, other_struct.frame_type))
        return false;
    if (!mojo::Equals(this->url, other_struct.url))
        return false;
    if (!mojo::Equals(this->method, other_struct.method))
        return false;
    if (!mojo::Equals(this->headers, other_struct.headers))
        return false;
    if (!mojo::Equals(this->blob, other_struct.blob))
        return false;
    if (!mojo::Equals(this->body, other_struct.body))
        return false;
    if (!mojo::Equals(this->request_initiator, other_struct.request_initiator))
        return false;
    if (!mojo::Equals(this->navigation_redirect_chain, other_struct.navigation_redirect_chain))
        return false;
    if (!mojo::Equals(this->referrer, other_struct.referrer))
        return false;
    if (!mojo::Equals(this->credentials_mode, other_struct.credentials_mode))
        return false;
    if (!mojo::Equals(this->cache_mode, other_struct.cache_mode))
        return false;
    if (!mojo::Equals(this->redirect_mode, other_struct.redirect_mode))
        return false;
    if (!mojo::Equals(this->integrity, other_struct.integrity))
        return false;
    if (!mojo::Equals(this->priority, other_struct.priority))
        return false;
    if (!mojo::Equals(this->fetch_window_id, other_struct.fetch_window_id))
        return false;
    if (!mojo::Equals(this->keepalive, other_struct.keepalive))
        return false;
    if (!mojo::Equals(this->is_reload, other_struct.is_reload))
        return false;
    if (!mojo::Equals(this->is_history_navigation, other_struct.is_history_navigation))
        return false;
    if (!mojo::Equals(this->devtools_stack_id, other_struct.devtools_stack_id))
        return false;
    if (!mojo::Equals(this->trust_token_params, other_struct.trust_token_params))
        return false;
    if (!mojo::Equals(this->target_address_space, other_struct.target_address_space))
        return false;
    if (!mojo::Equals(this->attribution_reporting_eligibility, other_struct.attribution_reporting_eligibility))
        return false;
    if (!mojo::Equals(this->attribution_reporting_support, other_struct.attribution_reporting_support))
        return false;
    if (!mojo::Equals(this->service_worker_race_network_request_token, other_struct.service_worker_race_network_request_token))
        return false;
    return true;
}

template <typename T, FetchAPIRequest::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.mode < rhs.mode)
        return true;
    if (rhs.mode < lhs.mode)
        return false;
    if (lhs.is_main_resource_load < rhs.is_main_resource_load)
        return true;
    if (rhs.is_main_resource_load < lhs.is_main_resource_load)
        return false;
    if (lhs.destination < rhs.destination)
        return true;
    if (rhs.destination < lhs.destination)
        return false;
    if (lhs.frame_type < rhs.frame_type)
        return true;
    if (rhs.frame_type < lhs.frame_type)
        return false;
    if (lhs.url < rhs.url)
        return true;
    if (rhs.url < lhs.url)
        return false;
    if (lhs.method < rhs.method)
        return true;
    if (rhs.method < lhs.method)
        return false;
    if (lhs.headers < rhs.headers)
        return true;
    if (rhs.headers < lhs.headers)
        return false;
    if (lhs.blob < rhs.blob)
        return true;
    if (rhs.blob < lhs.blob)
        return false;
    if (lhs.body < rhs.body)
        return true;
    if (rhs.body < lhs.body)
        return false;
    if (lhs.request_initiator < rhs.request_initiator)
        return true;
    if (rhs.request_initiator < lhs.request_initiator)
        return false;
    if (lhs.navigation_redirect_chain < rhs.navigation_redirect_chain)
        return true;
    if (rhs.navigation_redirect_chain < lhs.navigation_redirect_chain)
        return false;
    if (lhs.referrer < rhs.referrer)
        return true;
    if (rhs.referrer < lhs.referrer)
        return false;
    if (lhs.credentials_mode < rhs.credentials_mode)
        return true;
    if (rhs.credentials_mode < lhs.credentials_mode)
        return false;
    if (lhs.cache_mode < rhs.cache_mode)
        return true;
    if (rhs.cache_mode < lhs.cache_mode)
        return false;
    if (lhs.redirect_mode < rhs.redirect_mode)
        return true;
    if (rhs.redirect_mode < lhs.redirect_mode)
        return false;
    if (lhs.integrity < rhs.integrity)
        return true;
    if (rhs.integrity < lhs.integrity)
        return false;
    if (lhs.priority < rhs.priority)
        return true;
    if (rhs.priority < lhs.priority)
        return false;
    if (lhs.fetch_window_id < rhs.fetch_window_id)
        return true;
    if (rhs.fetch_window_id < lhs.fetch_window_id)
        return false;
    if (lhs.keepalive < rhs.keepalive)
        return true;
    if (rhs.keepalive < lhs.keepalive)
        return false;
    if (lhs.is_reload < rhs.is_reload)
        return true;
    if (rhs.is_reload < lhs.is_reload)
        return false;
    if (lhs.is_history_navigation < rhs.is_history_navigation)
        return true;
    if (rhs.is_history_navigation < lhs.is_history_navigation)
        return false;
    if (lhs.devtools_stack_id < rhs.devtools_stack_id)
        return true;
    if (rhs.devtools_stack_id < lhs.devtools_stack_id)
        return false;
    if (lhs.trust_token_params < rhs.trust_token_params)
        return true;
    if (rhs.trust_token_params < lhs.trust_token_params)
        return false;
    if (lhs.target_address_space < rhs.target_address_space)
        return true;
    if (rhs.target_address_space < lhs.target_address_space)
        return false;
    if (lhs.attribution_reporting_eligibility < rhs.attribution_reporting_eligibility)
        return true;
    if (rhs.attribution_reporting_eligibility < lhs.attribution_reporting_eligibility)
        return false;
    if (lhs.attribution_reporting_support < rhs.attribution_reporting_support)
        return true;
    if (rhs.attribution_reporting_support < lhs.attribution_reporting_support)
        return false;
    if (lhs.service_worker_race_network_request_token < rhs.service_worker_race_network_request_token)
        return true;
    if (rhs.service_worker_race_network_request_token < lhs.service_worker_race_network_request_token)
        return false;
    return false;
}

} // blink::mojom::blink

namespace mojo {

template <> struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::FetchAPIRequestHeaders::DataView, ::blink::mojom::blink::FetchAPIRequestHeadersPtr> {
    static bool IsNull(const ::blink::mojom::blink::FetchAPIRequestHeadersPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::blink::FetchAPIRequestHeadersPtr* output)
    {
        output->reset();
    }

    static const decltype(::blink::mojom::blink::FetchAPIRequestHeaders::headers)& headers(const ::blink::mojom::blink::FetchAPIRequestHeadersPtr& input)
    {
        return input->headers;
    }

    static bool Read(::blink::mojom::blink::FetchAPIRequestHeaders::DataView input, ::blink::mojom::blink::FetchAPIRequestHeadersPtr* output);
};

template <> struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::FetchAPIRequestBody::DataView, ::blink::mojom::blink::FetchAPIRequestBodyPtr> {
    static bool IsNull(const ::blink::mojom::blink::FetchAPIRequestBodyPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::blink::FetchAPIRequestBodyPtr* output)
    {
        output->reset();
    }

    static decltype(::blink::mojom::blink::FetchAPIRequestBody::elements)& elements(::blink::mojom::blink::FetchAPIRequestBodyPtr& input)
    {
        return input->elements;
    }

    static decltype(::blink::mojom::blink::FetchAPIRequestBody::identifier) identifier(const ::blink::mojom::blink::FetchAPIRequestBodyPtr& input)
    {
        return input->identifier;
    }

    static decltype(::blink::mojom::blink::FetchAPIRequestBody::contains_sensitive_info) contains_sensitive_info(
        const ::blink::mojom::blink::FetchAPIRequestBodyPtr& input)
    {
        return input->contains_sensitive_info;
    }

    static bool Read(::blink::mojom::blink::FetchAPIRequestBody::DataView input, ::blink::mojom::blink::FetchAPIRequestBodyPtr* output);
};

template <> struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::FetchAPIRequest::DataView, ::blink::mojom::blink::FetchAPIRequestPtr> {
    static bool IsNull(const ::blink::mojom::blink::FetchAPIRequestPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::blink::FetchAPIRequestPtr* output)
    {
        output->reset();
    }

    static decltype(::blink::mojom::blink::FetchAPIRequest::mode) mode(const ::blink::mojom::blink::FetchAPIRequestPtr& input)
    {
        return input->mode;
    }

    static decltype(::blink::mojom::blink::FetchAPIRequest::is_main_resource_load) is_main_resource_load(const ::blink::mojom::blink::FetchAPIRequestPtr& input)
    {
        return input->is_main_resource_load;
    }

    static decltype(::blink::mojom::blink::FetchAPIRequest::destination) destination(const ::blink::mojom::blink::FetchAPIRequestPtr& input)
    {
        return input->destination;
    }

    static decltype(::blink::mojom::blink::FetchAPIRequest::frame_type) frame_type(const ::blink::mojom::blink::FetchAPIRequestPtr& input)
    {
        return input->frame_type;
    }

    static const decltype(::blink::mojom::blink::FetchAPIRequest::url)& url(const ::blink::mojom::blink::FetchAPIRequestPtr& input)
    {
        return input->url;
    }

    static const decltype(::blink::mojom::blink::FetchAPIRequest::method)& method(const ::blink::mojom::blink::FetchAPIRequestPtr& input)
    {
        return input->method;
    }

    static const decltype(::blink::mojom::blink::FetchAPIRequest::headers)& headers(const ::blink::mojom::blink::FetchAPIRequestPtr& input)
    {
        return input->headers;
    }

    static decltype(::blink::mojom::blink::FetchAPIRequest::blob)& blob(::blink::mojom::blink::FetchAPIRequestPtr& input)
    {
        return input->blob;
    }

    static decltype(::blink::mojom::blink::FetchAPIRequest::body)& body(::blink::mojom::blink::FetchAPIRequestPtr& input)
    {
        return input->body;
    }

    static const decltype(::blink::mojom::blink::FetchAPIRequest::request_initiator)& request_initiator(const ::blink::mojom::blink::FetchAPIRequestPtr& input)
    {
        return input->request_initiator;
    }

    static const decltype(::blink::mojom::blink::FetchAPIRequest::navigation_redirect_chain)& navigation_redirect_chain(
        const ::blink::mojom::blink::FetchAPIRequestPtr& input)
    {
        return input->navigation_redirect_chain;
    }

    static const decltype(::blink::mojom::blink::FetchAPIRequest::referrer)& referrer(const ::blink::mojom::blink::FetchAPIRequestPtr& input)
    {
        return input->referrer;
    }

    static decltype(::blink::mojom::blink::FetchAPIRequest::credentials_mode) credentials_mode(const ::blink::mojom::blink::FetchAPIRequestPtr& input)
    {
        return input->credentials_mode;
    }

    static decltype(::blink::mojom::blink::FetchAPIRequest::cache_mode) cache_mode(const ::blink::mojom::blink::FetchAPIRequestPtr& input)
    {
        return input->cache_mode;
    }

    static decltype(::blink::mojom::blink::FetchAPIRequest::redirect_mode) redirect_mode(const ::blink::mojom::blink::FetchAPIRequestPtr& input)
    {
        return input->redirect_mode;
    }

    static const decltype(::blink::mojom::blink::FetchAPIRequest::integrity)& integrity(const ::blink::mojom::blink::FetchAPIRequestPtr& input)
    {
        return input->integrity;
    }

    static decltype(::blink::mojom::blink::FetchAPIRequest::priority) priority(const ::blink::mojom::blink::FetchAPIRequestPtr& input)
    {
        return input->priority;
    }

    static const decltype(::blink::mojom::blink::FetchAPIRequest::fetch_window_id)& fetch_window_id(const ::blink::mojom::blink::FetchAPIRequestPtr& input)
    {
        return input->fetch_window_id;
    }

    static decltype(::blink::mojom::blink::FetchAPIRequest::keepalive) keepalive(const ::blink::mojom::blink::FetchAPIRequestPtr& input)
    {
        return input->keepalive;
    }

    static decltype(::blink::mojom::blink::FetchAPIRequest::is_reload) is_reload(const ::blink::mojom::blink::FetchAPIRequestPtr& input)
    {
        return input->is_reload;
    }

    static decltype(::blink::mojom::blink::FetchAPIRequest::is_history_navigation) is_history_navigation(const ::blink::mojom::blink::FetchAPIRequestPtr& input)
    {
        return input->is_history_navigation;
    }

    static const decltype(::blink::mojom::blink::FetchAPIRequest::devtools_stack_id)& devtools_stack_id(const ::blink::mojom::blink::FetchAPIRequestPtr& input)
    {
        return input->devtools_stack_id;
    }

    static const decltype(::blink::mojom::blink::FetchAPIRequest::trust_token_params)& trust_token_params(
        const ::blink::mojom::blink::FetchAPIRequestPtr& input)
    {
        return input->trust_token_params;
    }

    static decltype(::blink::mojom::blink::FetchAPIRequest::target_address_space) target_address_space(const ::blink::mojom::blink::FetchAPIRequestPtr& input)
    {
        return input->target_address_space;
    }

    static decltype(::blink::mojom::blink::FetchAPIRequest::attribution_reporting_eligibility) attribution_reporting_eligibility(
        const ::blink::mojom::blink::FetchAPIRequestPtr& input)
    {
        return input->attribution_reporting_eligibility;
    }

    static decltype(::blink::mojom::blink::FetchAPIRequest::attribution_reporting_support) attribution_reporting_support(
        const ::blink::mojom::blink::FetchAPIRequestPtr& input)
    {
        return input->attribution_reporting_support;
    }

    static const decltype(::blink::mojom::blink::FetchAPIRequest::service_worker_race_network_request_token)& service_worker_race_network_request_token(
        const ::blink::mojom::blink::FetchAPIRequestPtr& input)
    {
        return input->service_worker_race_network_request_token;
    }

    static bool Read(::blink::mojom::blink::FetchAPIRequest::DataView input, ::blink::mojom::blink::FetchAPIRequestPtr* output);
};

} // namespace mojo

#endif // THIRD_PARTY_BLINK_PUBLIC_MOJOM_FETCH_FETCH_API_REQUEST_MOJOM_BLINK_H_
