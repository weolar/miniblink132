// third_party/blink/public/mojom/fetch/fetch_api_response.mojom.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif

#include "third_party/blink/public/mojom/fetch/fetch_api_response.mojom.h"

#include <math.h>
#include <stdint.h>
#include <utility>

#include "base/debug/alias.h"
#include "base/hash/md5_constexpr.h"
#include "base/run_loop.h"
#include "base/strings/string_number_conversions.h"
#include "base/task/thread_pool/thread_pool_instance.h"
#include "base/trace_event/trace_event.h"
#include "base/trace_event/typed_macros.h"
#include "mojo/public/cpp/bindings/features.h"
#include "mojo/public/cpp/bindings/lib/default_construct_tag_internal.h"
#include "mojo/public/cpp/bindings/lib/generated_code_util.h"
#include "mojo/public/cpp/bindings/lib/message_internal.h"
#include "mojo/public/cpp/bindings/lib/proxy_to_responder.h"
#include "mojo/public/cpp/bindings/lib/send_message_helper.h"
#include "mojo/public/cpp/bindings/lib/serialization_util.h"
#include "mojo/public/cpp/bindings/lib/unserialized_message_context.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/mojo_buildflags.h"
#include "mojo/public/cpp/bindings/urgent_message_scope.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"
#include "third_party/perfetto/include/perfetto/tracing/traced_value.h"

#include "third_party/blink/public/mojom/fetch/fetch_api_response.mojom-params-data.h"
#include "third_party/blink/public/mojom/fetch/fetch_api_response.mojom-shared-message-ids.h"

#include "third_party/blink/public/mojom/fetch/fetch_api_response.mojom-import-headers.h"
#include "third_party/blink/public/mojom/fetch/fetch_api_response.mojom-test-utils.h"

namespace blink::mojom {
FetchAPIResponse::FetchAPIResponse()
    : url_list()
    , status_code(0U)
    , status_text()
    , response_type(::network::mojom::FetchResponseType::kDefault)
    , padding(0)
    , response_source(::network::mojom::FetchResponseSource::kUnspecified)
    , headers()
    , mime_type()
    , request_method()
    , blob()
    , error(::blink::mojom::ServiceWorkerResponseError::kUnknown)
    , response_time()
    , cache_storage_cache_name()
    , cors_exposed_header_names()
    , side_data_blob()
    , side_data_blob_for_cache_put()
    , parsed_headers()
    , connection_info()
    , alpn_negotiated_protocol("unknown")
    , was_fetched_via_spdy(false)
    , has_range_requested(false)
    , auth_challenge_info()
    , request_include_credentials(true)
{
}

FetchAPIResponse::FetchAPIResponse(std::vector<::GURL> url_list_in, uint16_t status_code_in, const std::string& status_text_in,
    ::network::mojom::FetchResponseType response_type_in, int64_t padding_in, ::network::mojom::FetchResponseSource response_source_in,
    const base::flat_map<std::string, std::string>& headers_in, const std::optional<std::string>& mime_type_in,
    const std::optional<std::string>& request_method_in, ::blink::mojom::SerializedBlobPtr blob_in, ::blink::mojom::ServiceWorkerResponseError error_in,
    ::base::Time response_time_in, const std::optional<std::string>& cache_storage_cache_name_in, std::vector<std::string> cors_exposed_header_names_in,
    ::blink::mojom::SerializedBlobPtr side_data_blob_in, ::blink::mojom::SerializedBlobPtr side_data_blob_for_cache_put_in,
    ::network::mojom::ParsedHeadersPtr parsed_headers_in, ::net::HttpConnectionInfo connection_info_in, const std::string& alpn_negotiated_protocol_in,
    bool was_fetched_via_spdy_in, bool has_range_requested_in, const std::optional<::net::AuthChallengeInfo>& auth_challenge_info_in,
    bool request_include_credentials_in)
    : url_list(std::move(url_list_in))
    , status_code(std::move(status_code_in))
    , status_text(std::move(status_text_in))
    , response_type(std::move(response_type_in))
    , padding(std::move(padding_in))
    , response_source(std::move(response_source_in))
    , headers(std::move(headers_in))
    , mime_type(std::move(mime_type_in))
    , request_method(std::move(request_method_in))
    , blob(std::move(blob_in))
    , error(std::move(error_in))
    , response_time(std::move(response_time_in))
    , cache_storage_cache_name(std::move(cache_storage_cache_name_in))
    , cors_exposed_header_names(std::move(cors_exposed_header_names_in))
    , side_data_blob(std::move(side_data_blob_in))
    , side_data_blob_for_cache_put(std::move(side_data_blob_for_cache_put_in))
    , parsed_headers(std::move(parsed_headers_in))
    , connection_info(std::move(connection_info_in))
    , alpn_negotiated_protocol(std::move(alpn_negotiated_protocol_in))
    , was_fetched_via_spdy(std::move(was_fetched_via_spdy_in))
    , has_range_requested(std::move(has_range_requested_in))
    , auth_challenge_info(std::move(auth_challenge_info_in))
    , request_include_credentials(std::move(request_include_credentials_in))
{
}

FetchAPIResponse::~FetchAPIResponse() = default;

void FetchAPIResponse::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("url_list"), this->url_list,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::vector<::GURL>&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("status_code"), this->status_code,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint16_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("status_text"), this->status_text,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("response_type"), this->response_type,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type ::network::mojom::FetchResponseType>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("padding"), this->padding,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type int64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("response_source"), this->response_source,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type ::network::mojom::FetchResponseSource>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("headers"), this->headers,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const base::flat_map<std::string, std::string>&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("mime_type"), this->mime_type,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::optional<std::string>&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("request_method"), this->request_method,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::optional<std::string>&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("blob"), this->blob,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type ::blink::mojom::SerializedBlobPtr>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("error"), this->error,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type ::blink::mojom::ServiceWorkerResponseError>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("response_time"), this->response_time,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type ::base::Time>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("cache_storage_cache_name"), this->cache_storage_cache_name,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::optional<std::string>&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("cors_exposed_header_names"), this->cors_exposed_header_names,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::vector<std::string>&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("side_data_blob"), this->side_data_blob,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type ::blink::mojom::SerializedBlobPtr>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("side_data_blob_for_cache_put"), this->side_data_blob_for_cache_put,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type ::blink::mojom::SerializedBlobPtr>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("parsed_headers"), this->parsed_headers,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type ::network::mojom::ParsedHeadersPtr>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("connection_info"), this->connection_info,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type ::net::HttpConnectionInfo>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("alpn_negotiated_protocol"), this->alpn_negotiated_protocol,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("was_fetched_via_spdy"), this->was_fetched_via_spdy,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type bool>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("has_range_requested"), this->has_range_requested,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type bool>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("auth_challenge_info"), this->auth_challenge_info,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::optional<::net::AuthChallengeInfo>&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("request_include_credentials"), this->request_include_credentials,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type bool>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool FetchAPIResponse::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}

} // blink::mojom

namespace mojo {

// static
bool StructTraits<::blink::mojom::FetchAPIResponse::DataView, ::blink::mojom::FetchAPIResponsePtr>::Read(
    ::blink::mojom::FetchAPIResponse::DataView input, ::blink::mojom::FetchAPIResponsePtr* output)
{
    bool success = true;
    ::blink::mojom::FetchAPIResponsePtr result(::blink::mojom::FetchAPIResponse::New());

    if (success && !input.ReadUrlList(&result->url_list))
        success = false;
    if (success)
        result->status_code = input.status_code();
    if (success && !input.ReadStatusText(&result->status_text))
        success = false;
    if (success && !input.ReadResponseType(&result->response_type))
        success = false;
    if (success)
        result->padding = input.padding();
    if (success && !input.ReadResponseSource(&result->response_source))
        success = false;
    if (success && !input.ReadHeaders(&result->headers))
        success = false;
    if (success && !input.ReadMimeType(&result->mime_type))
        success = false;
    if (success && !input.ReadRequestMethod(&result->request_method))
        success = false;
    if (success && !input.ReadBlob(&result->blob))
        success = false;
    if (success && !input.ReadError(&result->error))
        success = false;
    if (success && !input.ReadResponseTime(&result->response_time))
        success = false;
    if (success && !input.ReadCacheStorageCacheName(&result->cache_storage_cache_name))
        success = false;
    if (success && !input.ReadCorsExposedHeaderNames(&result->cors_exposed_header_names))
        success = false;
    if (success && !input.ReadSideDataBlob(&result->side_data_blob))
        success = false;
    if (success && !input.ReadSideDataBlobForCachePut(&result->side_data_blob_for_cache_put))
        success = false;
    if (success && !input.ReadParsedHeaders(&result->parsed_headers))
        success = false;
    if (success && !input.ReadConnectionInfo(&result->connection_info))
        success = false;
    if (success && !input.ReadAlpnNegotiatedProtocol(&result->alpn_negotiated_protocol))
        success = false;
    if (success)
        result->was_fetched_via_spdy = input.was_fetched_via_spdy();
    if (success)
        result->has_range_requested = input.has_range_requested();
    if (success && !input.ReadAuthChallengeInfo(&result->auth_challenge_info))
        success = false;
    if (success)
        result->request_include_credentials = input.request_include_credentials();
    *output = std::move(result);
    return success;
}

} // namespace mojo

// Symbols declared in the -test-utils.h header are defined here instead of a
// separate .cc file to save compile time.

namespace blink::mojom {

} // blink::mojom

#if defined(__clang__)
#pragma clang diagnostic pop
#endif