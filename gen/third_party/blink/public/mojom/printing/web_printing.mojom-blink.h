// third_party/blink/public/mojom/printing/web_printing.mojom-blink.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef THIRD_PARTY_BLINK_PUBLIC_MOJOM_PRINTING_WEB_PRINTING_MOJOM_BLINK_H_
#define THIRD_PARTY_BLINK_PUBLIC_MOJOM_PRINTING_WEB_PRINTING_MOJOM_BLINK_H_

#include <stdint.h>

#include <limits>
#include <optional>
#include <type_traits>
#include <utility>

#include "base/types/cxx23_to_underlying.h"
#include "mojo/public/cpp/bindings/clone_traits.h"
#include "mojo/public/cpp/bindings/equals_traits.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/struct_ptr.h"
#include "mojo/public/cpp/bindings/struct_traits.h"
#include "mojo/public/cpp/bindings/union_traits.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "third_party/blink/public/mojom/printing/web_printing.mojom-features.h" // IWYU pragma: export
#include "third_party/blink/public/mojom/printing/web_printing.mojom-shared.h" // IWYU pragma: export
#include "third_party/blink/public/mojom/printing/web_printing.mojom-blink-forward.h" // IWYU pragma: export
#include "third_party/blink/public/mojom/blob/blob.mojom-blink-forward.h"
#include "ui/gfx/geometry/mojom/geometry.mojom-blink.h"

#include "mojo/public/cpp/bindings/lib/wtf_clone_equals_util.h"
#include "mojo/public/cpp/bindings/lib/wtf_hash_util.h"
#include "third_party/blink/renderer/platform/wtf/hash_functions.h"
#include "third_party/blink/renderer/platform/wtf/text/wtf_string.h"

#include "mojo/public/cpp/bindings/lib/control_message_handler.h"
#include "mojo/public/cpp/bindings/lib/message_size_estimator.h"
#include "mojo/public/cpp/bindings/raw_ptr_impl_ref_traits.h"

#include "third_party/blink/renderer/platform/platform_export.h"
#if !BLINK_MOJO_IMPL && !INSIDE_BLINK
#error "File must only be imported inside blink"
#endif

namespace blink::mojom::blink {

class WebPrintJobStateObserverProxy;

template <typename ImplRefTraits> class WebPrintJobStateObserverStub;

class WebPrintJobStateObserverRequestValidator;

class PLATFORM_EXPORT WebPrintJobStateObserver : public WebPrintJobStateObserverInterfaceBase {
public:
    using IPCStableHashFunction = uint32_t (*)();

    static const char Name_[];
    static IPCStableHashFunction MessageToMethodInfo_(mojo::Message& message);
    static const char* MessageToMethodName_(mojo::Message& message);
    static constexpr uint32_t Version_ = 0;
    static constexpr bool PassesAssociatedKinds_ = false;
    static constexpr bool HasUninterruptableMethods_ = false;

    using Base_ = WebPrintJobStateObserverInterfaceBase;
    using Proxy_ = WebPrintJobStateObserverProxy;

    template <typename ImplRefTraits> using Stub_ = WebPrintJobStateObserverStub<ImplRefTraits>;

    using RequestValidator_ = WebPrintJobStateObserverRequestValidator;
    using ResponseValidator_ = mojo::PassThroughFilter;
    enum MethodMinVersions : uint32_t {
        kOnWebPrintJobUpdateMinVersion = 0,
    };

// crbug.com/1340245 - this causes binary size bloat on Fuchsia, and we're OK
// with not having this data in traces there.
#if !BUILDFLAG(IS_FUCHSIA)
    struct OnWebPrintJobUpdate_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
#endif // !BUILDFLAG(IS_FUCHSIA)
    virtual ~WebPrintJobStateObserver() = default;

    virtual void OnWebPrintJobUpdate(WebPrintJobUpdatePtr update) = 0;
};

class WebPrintJobControllerProxy;

template <typename ImplRefTraits> class WebPrintJobControllerStub;

class WebPrintJobControllerRequestValidator;

class PLATFORM_EXPORT WebPrintJobController : public WebPrintJobControllerInterfaceBase {
public:
    using IPCStableHashFunction = uint32_t (*)();

    static const char Name_[];
    static IPCStableHashFunction MessageToMethodInfo_(mojo::Message& message);
    static const char* MessageToMethodName_(mojo::Message& message);
    static constexpr uint32_t Version_ = 0;
    static constexpr bool PassesAssociatedKinds_ = false;
    static constexpr bool HasUninterruptableMethods_ = false;

    using Base_ = WebPrintJobControllerInterfaceBase;
    using Proxy_ = WebPrintJobControllerProxy;

    template <typename ImplRefTraits> using Stub_ = WebPrintJobControllerStub<ImplRefTraits>;

    using RequestValidator_ = WebPrintJobControllerRequestValidator;
    using ResponseValidator_ = mojo::PassThroughFilter;
    enum MethodMinVersions : uint32_t {
        kCancelMinVersion = 0,
    };

// crbug.com/1340245 - this causes binary size bloat on Fuchsia, and we're OK
// with not having this data in traces there.
#if !BUILDFLAG(IS_FUCHSIA)
    struct Cancel_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
#endif // !BUILDFLAG(IS_FUCHSIA)
    virtual ~WebPrintJobController() = default;

    virtual void Cancel() = 0;
};

class WebPrinterProxy;

template <typename ImplRefTraits> class WebPrinterStub;

class WebPrinterRequestValidator;
class WebPrinterResponseValidator;

class PLATFORM_EXPORT WebPrinter : public WebPrinterInterfaceBase {
public:
    using IPCStableHashFunction = uint32_t (*)();

    static const char Name_[];
    static IPCStableHashFunction MessageToMethodInfo_(mojo::Message& message);
    static const char* MessageToMethodName_(mojo::Message& message);
    static constexpr uint32_t Version_ = 0;
    static constexpr bool PassesAssociatedKinds_ = false;
    static constexpr bool HasUninterruptableMethods_ = false;

    using Base_ = WebPrinterInterfaceBase;
    using Proxy_ = WebPrinterProxy;

    template <typename ImplRefTraits> using Stub_ = WebPrinterStub<ImplRefTraits>;

    using RequestValidator_ = WebPrinterRequestValidator;
    using ResponseValidator_ = WebPrinterResponseValidator;
    enum MethodMinVersions : uint32_t {
        kFetchAttributesMinVersion = 0,
        kPrintMinVersion = 0,
    };

// crbug.com/1340245 - this causes binary size bloat on Fuchsia, and we're OK
// with not having this data in traces there.
#if !BUILDFLAG(IS_FUCHSIA)
    struct FetchAttributes_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct Print_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
#endif // !BUILDFLAG(IS_FUCHSIA)
    virtual ~WebPrinter() = default;

    using FetchAttributesCallback = base::OnceCallback<void(WebPrinterFetchResultPtr)>;

    virtual void FetchAttributes(FetchAttributesCallback callback) = 0;

    using PrintCallback = base::OnceCallback<void(WebPrintResultPtr)>;

    virtual void Print(::mojo::PendingRemote<::blink::mojom::blink::Blob> document, WebPrintJobTemplateAttributesPtr attributes, PrintCallback callback) = 0;
};

class WebPrintingServiceProxy;

template <typename ImplRefTraits> class WebPrintingServiceStub;

class WebPrintingServiceRequestValidator;
class WebPrintingServiceResponseValidator;

class PLATFORM_EXPORT WebPrintingService : public WebPrintingServiceInterfaceBase {
public:
    using IPCStableHashFunction = uint32_t (*)();

    static const char Name_[];
    static IPCStableHashFunction MessageToMethodInfo_(mojo::Message& message);
    static const char* MessageToMethodName_(mojo::Message& message);
    static constexpr uint32_t Version_ = 0;
    static constexpr bool PassesAssociatedKinds_ = false;
    static constexpr bool HasUninterruptableMethods_ = false;

    using Base_ = WebPrintingServiceInterfaceBase;
    using Proxy_ = WebPrintingServiceProxy;

    template <typename ImplRefTraits> using Stub_ = WebPrintingServiceStub<ImplRefTraits>;

    using RequestValidator_ = WebPrintingServiceRequestValidator;
    using ResponseValidator_ = WebPrintingServiceResponseValidator;
    enum MethodMinVersions : uint32_t {
        kGetPrintersMinVersion = 0,
    };

// crbug.com/1340245 - this causes binary size bloat on Fuchsia, and we're OK
// with not having this data in traces there.
#if !BUILDFLAG(IS_FUCHSIA)
    struct GetPrinters_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
#endif // !BUILDFLAG(IS_FUCHSIA)
    virtual ~WebPrintingService() = default;

    using GetPrintersCallback = base::OnceCallback<void(GetPrintersResultPtr)>;

    virtual void GetPrinters(GetPrintersCallback callback) = 0;
};

//class PLATFORM_EXPORT WebPrintJobStateObserverProxy : public WebPrintJobStateObserver {
//public:
//    using InterfaceType = WebPrintJobStateObserver;
//
//    explicit WebPrintJobStateObserverProxy(mojo::MessageReceiverWithResponder* receiver);
//
//    void OnWebPrintJobUpdate(WebPrintJobUpdatePtr update) final;
//
//private:
//    mojo::MessageReceiverWithResponder* receiver_;
//};

//class PLATFORM_EXPORT WebPrintJobControllerProxy : public WebPrintJobController {
//public:
//    using InterfaceType = WebPrintJobController;
//
//    explicit WebPrintJobControllerProxy(mojo::MessageReceiverWithResponder* receiver);
//
//    void Cancel() final;
//
//private:
//    mojo::MessageReceiverWithResponder* receiver_;
//};

//class PLATFORM_EXPORT WebPrinterProxy : public WebPrinter {
//public:
//    using InterfaceType = WebPrinter;
//
//    explicit WebPrinterProxy(mojo::MessageReceiverWithResponder* receiver);
//
//    void FetchAttributes(FetchAttributesCallback callback) final;
//
//    void Print(::mojo::PendingRemote<::blink::mojom::blink::Blob> document, WebPrintJobTemplateAttributesPtr attributes, PrintCallback callback) final;
//
//private:
//    mojo::MessageReceiverWithResponder* receiver_;
//};

//class PLATFORM_EXPORT WebPrintingServiceProxy : public WebPrintingService {
//public:
//    using InterfaceType = WebPrintingService;
//
//    explicit WebPrintingServiceProxy(mojo::MessageReceiverWithResponder* receiver);
//
//    void GetPrinters(GetPrintersCallback callback) final;
//
//private:
//    mojo::MessageReceiverWithResponder* receiver_;
//};
//class PLATFORM_EXPORT WebPrintJobStateObserverStubDispatch {
//public:
//    static bool Accept(WebPrintJobStateObserver* impl, mojo::Message* message);
//    static bool AcceptWithResponder(WebPrintJobStateObserver* impl, mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
//};

//template <typename ImplRefTraits = mojo::RawPtrImplRefTraits<WebPrintJobStateObserver>>
//class WebPrintJobStateObserverStub : public mojo::MessageReceiverWithResponderStatus {
//public:
//    using ImplPointerType = typename ImplRefTraits::PointerType;
//
//    WebPrintJobStateObserverStub() = default;
//    ~WebPrintJobStateObserverStub() override = default;
//
//    void set_sink(ImplPointerType sink)
//    {
//        sink_ = std::move(sink);
//    }
//    ImplPointerType& sink()
//    {
//        return sink_;
//    }
//
//    bool Accept(mojo::Message* message) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return WebPrintJobStateObserverStubDispatch::Accept(ImplRefTraits::GetRawPointer(&sink_), message);
//    }
//
//    bool AcceptWithResponder(mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return WebPrintJobStateObserverStubDispatch::AcceptWithResponder(ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
//    }
//
//private:
//    ImplPointerType sink_;
//};
//class PLATFORM_EXPORT WebPrintJobControllerStubDispatch {
//public:
//    static bool Accept(WebPrintJobController* impl, mojo::Message* message);
//    static bool AcceptWithResponder(WebPrintJobController* impl, mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
//};

//template <typename ImplRefTraits = mojo::RawPtrImplRefTraits<WebPrintJobController>>
//class WebPrintJobControllerStub : public mojo::MessageReceiverWithResponderStatus {
//public:
//    using ImplPointerType = typename ImplRefTraits::PointerType;
//
//    WebPrintJobControllerStub() = default;
//    ~WebPrintJobControllerStub() override = default;
//
//    void set_sink(ImplPointerType sink)
//    {
//        sink_ = std::move(sink);
//    }
//    ImplPointerType& sink()
//    {
//        return sink_;
//    }
//
//    bool Accept(mojo::Message* message) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return WebPrintJobControllerStubDispatch::Accept(ImplRefTraits::GetRawPointer(&sink_), message);
//    }
//
//    bool AcceptWithResponder(mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return WebPrintJobControllerStubDispatch::AcceptWithResponder(ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
//    }
//
//private:
//    ImplPointerType sink_;
//};
//class PLATFORM_EXPORT WebPrinterStubDispatch {
//public:
//    static bool Accept(WebPrinter* impl, mojo::Message* message);
//    static bool AcceptWithResponder(WebPrinter* impl, mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
//};

//template <typename ImplRefTraits = mojo::RawPtrImplRefTraits<WebPrinter>> class WebPrinterStub : public mojo::MessageReceiverWithResponderStatus {
//public:
//    using ImplPointerType = typename ImplRefTraits::PointerType;
//
//    WebPrinterStub() = default;
//    ~WebPrinterStub() override = default;
//
//    void set_sink(ImplPointerType sink)
//    {
//        sink_ = std::move(sink);
//    }
//    ImplPointerType& sink()
//    {
//        return sink_;
//    }
//
//    bool Accept(mojo::Message* message) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return WebPrinterStubDispatch::Accept(ImplRefTraits::GetRawPointer(&sink_), message);
//    }
//
//    bool AcceptWithResponder(mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return WebPrinterStubDispatch::AcceptWithResponder(ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
//    }
//
//private:
//    ImplPointerType sink_;
//};
//class PLATFORM_EXPORT WebPrintingServiceStubDispatch {
//public:
//    static bool Accept(WebPrintingService* impl, mojo::Message* message);
//    static bool AcceptWithResponder(WebPrintingService* impl, mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
//};

//template <typename ImplRefTraits = mojo::RawPtrImplRefTraits<WebPrintingService>>
//class WebPrintingServiceStub : public mojo::MessageReceiverWithResponderStatus {
//public:
//    using ImplPointerType = typename ImplRefTraits::PointerType;
//
//    WebPrintingServiceStub() = default;
//    ~WebPrintingServiceStub() override = default;
//
//    void set_sink(ImplPointerType sink)
//    {
//        sink_ = std::move(sink);
//    }
//    ImplPointerType& sink()
//    {
//        return sink_;
//    }
//
//    bool Accept(mojo::Message* message) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return WebPrintingServiceStubDispatch::Accept(ImplRefTraits::GetRawPointer(&sink_), message);
//    }
//
//    bool AcceptWithResponder(mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return WebPrintingServiceStubDispatch::AcceptWithResponder(ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
//    }
//
//private:
//    ImplPointerType sink_;
//};
//class PLATFORM_EXPORT WebPrintJobStateObserverRequestValidator : public mojo::MessageReceiver {
//public:
//    bool Accept(mojo::Message* message) override;
//};
//class PLATFORM_EXPORT WebPrintJobControllerRequestValidator : public mojo::MessageReceiver {
//public:
//    bool Accept(mojo::Message* message) override;
//};
//class PLATFORM_EXPORT WebPrinterRequestValidator : public mojo::MessageReceiver {
//public:
//    bool Accept(mojo::Message* message) override;
//};
//class PLATFORM_EXPORT WebPrintingServiceRequestValidator : public mojo::MessageReceiver {
//public:
//    bool Accept(mojo::Message* message) override;
//};
//class PLATFORM_EXPORT WebPrinterResponseValidator : public mojo::MessageReceiver {
//public:
//    bool Accept(mojo::Message* message) override;
//};
//class PLATFORM_EXPORT WebPrintingServiceResponseValidator : public mojo::MessageReceiver {
//public:
//    bool Accept(mojo::Message* message) override;
//};

class PLATFORM_EXPORT WebPrintingRange {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<WebPrintingRange, T>::value>;
    using DataView = WebPrintingRangeDataView;
    using Data_ = internal::WebPrintingRange_Data;

    template <typename... Args> static WebPrintingRangePtr New(Args&&... args)
    {
        return WebPrintingRangePtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static WebPrintingRangePtr From(const U& u)
    {
        return mojo::TypeConverter<WebPrintingRangePtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, WebPrintingRange>::Convert(*this);
    }

    WebPrintingRange()
    : from()
    , to()
{
}

    WebPrintingRange(uint32_t from_in, uint32_t to_in)
    : from(std::move(from_in))
    , to(std::move(to_in)){
}

    ~WebPrintingRange() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = WebPrintingRangePtr> WebPrintingRangePtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, WebPrintingRange::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, WebPrintingRange::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, WebPrintingRange::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<WebPrintingRange::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<WebPrintingRange::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::WebPrintingRange_UnserializedMessageContext<UserType, WebPrintingRange::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<WebPrintingRange::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return WebPrintingRange::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::WebPrintingRange_UnserializedMessageContext<UserType, WebPrintingRange::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<WebPrintingRange::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    uint32_t from;

    uint32_t to;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, WebPrintingRange::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, WebPrintingRange::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, WebPrintingRange::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, WebPrintingRange::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class PLATFORM_EXPORT WebPrintJobUpdate {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<WebPrintJobUpdate, T>::value>;
    using DataView = WebPrintJobUpdateDataView;
    using Data_ = internal::WebPrintJobUpdate_Data;

    template <typename... Args> static WebPrintJobUpdatePtr New(Args&&... args)
    {
        return WebPrintJobUpdatePtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static WebPrintJobUpdatePtr From(const U& u)
    {
        return mojo::TypeConverter<WebPrintJobUpdatePtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, WebPrintJobUpdate>::Convert(*this);
    }

    WebPrintJobUpdate()
    : state()
    , pages_printed(0U)
{
}

    WebPrintJobUpdate(WebPrintJobState state_in, uint32_t pages_printed_in)
    : state(std::move(state_in))
    , pages_printed(std::move(pages_printed_in)){
}

    ~WebPrintJobUpdate() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = WebPrintJobUpdatePtr> WebPrintJobUpdatePtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, WebPrintJobUpdate::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, WebPrintJobUpdate::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, WebPrintJobUpdate::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<WebPrintJobUpdate::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<WebPrintJobUpdate::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::WebPrintJobUpdate_UnserializedMessageContext<UserType, WebPrintJobUpdate::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<WebPrintJobUpdate::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return WebPrintJobUpdate::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::WebPrintJobUpdate_UnserializedMessageContext<UserType, WebPrintJobUpdate::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<WebPrintJobUpdate::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    WebPrintJobState state;

    uint32_t pages_printed;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, WebPrintJobUpdate::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, WebPrintJobUpdate::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, WebPrintJobUpdate::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, WebPrintJobUpdate::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class PLATFORM_EXPORT WebPrintingMediaSizeDimension {
public:
    using DataView = WebPrintingMediaSizeDimensionDataView;
    using Data_ = internal::WebPrintingMediaSizeDimension_Data;
    using Tag = Data_::WebPrintingMediaSizeDimension_Tag;

    template <typename... Args> static WebPrintingMediaSizeDimensionPtr New(Args&&... args)
    {
        static_assert(sizeof...(args) < 0,
            "Do not use Union::New(); to create a union of a given subtype, use "
            "New<SubType>(), not New() followed by set_<sub_type>(). To represent "
            "an empty union, mark the field or parameter as nullable in the mojom "
            "definition.");
        return nullptr;
    }
    // Construct an instance holding |range|.
    static WebPrintingMediaSizeDimensionPtr NewRange(WebPrintingRangePtr value)
    {
        auto result = WebPrintingMediaSizeDimensionPtr(std::in_place);
        result->set_range(std::move(value));
        return result;
    }
    // Construct an instance holding |value|.
    static WebPrintingMediaSizeDimensionPtr NewValue(uint32_t value)
    {
        auto result = WebPrintingMediaSizeDimensionPtr(std::in_place);
        result->set_value(std::move(value));
        return result;
    }

    template <typename U> static WebPrintingMediaSizeDimensionPtr From(const U& u)
    {
        return mojo::TypeConverter<WebPrintingMediaSizeDimensionPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, WebPrintingMediaSizeDimension>::Convert(*this);
    }

    WebPrintingMediaSizeDimension()
    : tag_(Tag::kRange)
{
    data_.range = new WebPrintingRangePtr;
}
    ~WebPrintingMediaSizeDimension(){
    DestroyActive();
}
    // Delete the copy constructor and copy assignment operators because `data_`
    // contains raw pointers that must not be copied.
    WebPrintingMediaSizeDimension(const WebPrintingMediaSizeDimension& other) = delete;
    WebPrintingMediaSizeDimension& operator=(const WebPrintingMediaSizeDimension& other) = delete;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename UnionPtrType = WebPrintingMediaSizeDimensionPtr> WebPrintingMediaSizeDimensionPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, typename std::enable_if<std::is_same<T, WebPrintingMediaSizeDimension>::value>::type* = nullptr> bool Equals(const T& other) const;

    template <typename T, typename std::enable_if<std::is_same<T, WebPrintingMediaSizeDimension>::value>::type* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }
    size_t Hash(size_t seed) const;

    Tag which() const
    {
        return tag_;
    }

    bool is_range() const
    {
        return tag_ == Tag::kRange;
    }

    WebPrintingRangePtr& get_range() const
    {
        CHECK(tag_ == Tag::kRange);
        return *(data_.range);
    }

    void set_range(WebPrintingRangePtr range);

    bool is_value() const
    {
        return tag_ == Tag::kValue;
    }

    uint32_t get_value() const
    {
        CHECK(tag_ == Tag::kValue);
        return data_.value;
    }

    void set_value(uint32_t value);

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<WebPrintingMediaSizeDimension::DataView>(input);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        return mojo::internal::DeserializeImpl<WebPrintingMediaSizeDimension::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

private:
    union Union_ {
        Union_() = default;
        ~Union_() = default;
        WebPrintingRangePtr* range;
        uint32_t value;
    };

    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    void DestroyActive();
    Tag tag_;
    Union_ data_;
};

class PLATFORM_EXPORT GetPrintersResult {
public:
    using DataView = GetPrintersResultDataView;
    using Data_ = internal::GetPrintersResult_Data;
    using Tag = Data_::GetPrintersResult_Tag;

    template <typename... Args> static GetPrintersResultPtr New(Args&&... args)
    {
        static_assert(sizeof...(args) < 0,
            "Do not use Union::New(); to create a union of a given subtype, use "
            "New<SubType>(), not New() followed by set_<sub_type>(). To represent "
            "an empty union, mark the field or parameter as nullable in the mojom "
            "definition.");
        return nullptr;
    }
    // Construct an instance holding |printers|.
    static GetPrintersResultPtr NewPrinters(WTF::Vector<WebPrinterInfoPtr> value)
    {
        auto result = GetPrintersResultPtr(std::in_place);
        result->set_printers(std::move(value));
        return result;
    }
    // Construct an instance holding |error|.
    static GetPrintersResultPtr NewError(GetPrintersError value)
    {
        auto result = GetPrintersResultPtr(std::in_place);
        result->set_error(std::move(value));
        return result;
    }

    template <typename U> static GetPrintersResultPtr From(const U& u)
    {
        return mojo::TypeConverter<GetPrintersResultPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, GetPrintersResult>::Convert(*this);
    }

    GetPrintersResult()
    : tag_(Tag::kPrinters)
{
    data_.printers = new WTF::Vector<WebPrinterInfoPtr>;
}
    ~GetPrintersResult(){
    DestroyActive();
}
    // Delete the copy constructor and copy assignment operators because `data_`
    // contains raw pointers that must not be copied.
    GetPrintersResult(const GetPrintersResult& other) = delete;
    GetPrintersResult& operator=(const GetPrintersResult& other) = delete;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename UnionPtrType = GetPrintersResultPtr> GetPrintersResultPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, typename std::enable_if<std::is_same<T, GetPrintersResult>::value>::type* = nullptr> bool Equals(const T& other) const;

    template <typename T, typename std::enable_if<std::is_same<T, GetPrintersResult>::value>::type* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    Tag which() const
    {
        return tag_;
    }

    bool is_printers() const
    {
        return tag_ == Tag::kPrinters;
    }

    WTF::Vector<WebPrinterInfoPtr>& get_printers() const
    {
        CHECK(tag_ == Tag::kPrinters);
        return *(data_.printers);
    }

    void set_printers(WTF::Vector<WebPrinterInfoPtr> printers);

    bool is_error() const
    {
        return tag_ == Tag::kError;
    }

    GetPrintersError get_error() const
    {
        CHECK(tag_ == Tag::kError);
        return data_.error;
    }

    void set_error(GetPrintersError error);

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<GetPrintersResult::DataView>(input);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        return mojo::internal::DeserializeImpl<GetPrintersResult::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

private:
    union Union_ {
        Union_() = default;
        ~Union_() = default;
        WTF::Vector<WebPrinterInfoPtr>* printers;
        GetPrintersError error;
    };

    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    void DestroyActive();
    Tag tag_;
    Union_ data_;
};

class PLATFORM_EXPORT WebPrinterFetchResult {
public:
    using DataView = WebPrinterFetchResultDataView;
    using Data_ = internal::WebPrinterFetchResult_Data;
    using Tag = Data_::WebPrinterFetchResult_Tag;

    template <typename... Args> static WebPrinterFetchResultPtr New(Args&&... args)
    {
        static_assert(sizeof...(args) < 0,
            "Do not use Union::New(); to create a union of a given subtype, use "
            "New<SubType>(), not New() followed by set_<sub_type>(). To represent "
            "an empty union, mark the field or parameter as nullable in the mojom "
            "definition.");
        return nullptr;
    }
    // Construct an instance holding |printer_attributes|.
    static WebPrinterFetchResultPtr NewPrinterAttributes(WebPrinterAttributesPtr value)
    {
        auto result = WebPrinterFetchResultPtr(std::in_place);
        result->set_printer_attributes(std::move(value));
        return result;
    }
    // Construct an instance holding |error|.
    static WebPrinterFetchResultPtr NewError(WebPrinterFetchError value)
    {
        auto result = WebPrinterFetchResultPtr(std::in_place);
        result->set_error(std::move(value));
        return result;
    }

    template <typename U> static WebPrinterFetchResultPtr From(const U& u)
    {
        return mojo::TypeConverter<WebPrinterFetchResultPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, WebPrinterFetchResult>::Convert(*this);
    }

    WebPrinterFetchResult()
    : tag_(Tag::kPrinterAttributes)
{
    data_.printer_attributes = new WebPrinterAttributesPtr;
}
    ~WebPrinterFetchResult(){
    DestroyActive();
}
    // Delete the copy constructor and copy assignment operators because `data_`
    // contains raw pointers that must not be copied.
    WebPrinterFetchResult(const WebPrinterFetchResult& other) = delete;
    WebPrinterFetchResult& operator=(const WebPrinterFetchResult& other) = delete;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename UnionPtrType = WebPrinterFetchResultPtr> WebPrinterFetchResultPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, typename std::enable_if<std::is_same<T, WebPrinterFetchResult>::value>::type* = nullptr> bool Equals(const T& other) const;

    template <typename T, typename std::enable_if<std::is_same<T, WebPrinterFetchResult>::value>::type* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    Tag which() const
    {
        return tag_;
    }

    bool is_printer_attributes() const
    {
        return tag_ == Tag::kPrinterAttributes;
    }

    WebPrinterAttributesPtr& get_printer_attributes() const
    {
        CHECK(tag_ == Tag::kPrinterAttributes);
        return *(data_.printer_attributes);
    }

    void set_printer_attributes(WebPrinterAttributesPtr printer_attributes);

    bool is_error() const
    {
        return tag_ == Tag::kError;
    }

    WebPrinterFetchError get_error() const
    {
        CHECK(tag_ == Tag::kError);
        return data_.error;
    }

    void set_error(WebPrinterFetchError error);

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<WebPrinterFetchResult::DataView>(input);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        return mojo::internal::DeserializeImpl<WebPrinterFetchResult::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

private:
    union Union_ {
        Union_() = default;
        ~Union_() = default;
        WebPrinterAttributesPtr* printer_attributes;
        WebPrinterFetchError error;
    };

    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    void DestroyActive();
    Tag tag_;
    Union_ data_;
};

class PLATFORM_EXPORT WebPrintResult {
public:
    using DataView = WebPrintResultDataView;
    using Data_ = internal::WebPrintResult_Data;
    using Tag = Data_::WebPrintResult_Tag;

    template <typename... Args> static WebPrintResultPtr New(Args&&... args)
    {
        static_assert(sizeof...(args) < 0,
            "Do not use Union::New(); to create a union of a given subtype, use "
            "New<SubType>(), not New() followed by set_<sub_type>(). To represent "
            "an empty union, mark the field or parameter as nullable in the mojom "
            "definition.");
        return nullptr;
    }
    // Construct an instance holding |print_job_info|.
    static WebPrintResultPtr NewPrintJobInfo(WebPrintJobInfoPtr value)
    {
        auto result = WebPrintResultPtr(std::in_place);
        result->set_print_job_info(std::move(value));
        return result;
    }
    // Construct an instance holding |error|.
    static WebPrintResultPtr NewError(WebPrintError value)
    {
        auto result = WebPrintResultPtr(std::in_place);
        result->set_error(std::move(value));
        return result;
    }

    template <typename U> static WebPrintResultPtr From(const U& u)
    {
        return mojo::TypeConverter<WebPrintResultPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, WebPrintResult>::Convert(*this);
    }

    WebPrintResult()
    : tag_(Tag::kPrintJobInfo)
{
    data_.print_job_info = new WebPrintJobInfoPtr;
}
    ~WebPrintResult(){
    DestroyActive();
}
    // Delete the copy constructor and copy assignment operators because `data_`
    // contains raw pointers that must not be copied.
    WebPrintResult(const WebPrintResult& other) = delete;
    WebPrintResult& operator=(const WebPrintResult& other) = delete;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename UnionPtrType = WebPrintResultPtr> WebPrintResultPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, typename std::enable_if<std::is_same<T, WebPrintResult>::value>::type* = nullptr> bool Equals(const T& other) const;

    template <typename T, typename std::enable_if<std::is_same<T, WebPrintResult>::value>::type* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    Tag which() const
    {
        return tag_;
    }

    bool is_print_job_info() const
    {
        return tag_ == Tag::kPrintJobInfo;
    }

    WebPrintJobInfoPtr& get_print_job_info() const
    {
        CHECK(tag_ == Tag::kPrintJobInfo);
        return *(data_.print_job_info);
    }

    void set_print_job_info(WebPrintJobInfoPtr print_job_info);

    bool is_error() const
    {
        return tag_ == Tag::kError;
    }

    WebPrintError get_error() const
    {
        CHECK(tag_ == Tag::kError);
        return data_.error;
    }

    void set_error(WebPrintError error);

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<WebPrintResult::DataView>(input);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        return mojo::internal::DeserializeImpl<WebPrintResult::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

private:
    union Union_ {
        Union_() = default;
        ~Union_() = default;
        WebPrintJobInfoPtr* print_job_info;
        WebPrintError error;
    };

    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    void DestroyActive();
    Tag tag_;
    Union_ data_;
};

class PLATFORM_EXPORT WebPrinterInfo {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<WebPrinterInfo, T>::value>;
    using DataView = WebPrinterInfoDataView;
    using Data_ = internal::WebPrinterInfo_Data;

    template <typename... Args> static WebPrinterInfoPtr New(Args&&... args)
    {
        return WebPrinterInfoPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static WebPrinterInfoPtr From(const U& u)
    {
        return mojo::TypeConverter<WebPrinterInfoPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, WebPrinterInfo>::Convert(*this);
    }

    WebPrinterInfo()
    : printer_name()
    , printer_remote()
{
}

    WebPrinterInfo(const WTF::String& printer_name_in, ::mojo::PendingRemote<WebPrinter> printer_remote_in)
    : printer_name(std::move(printer_name_in))
    , printer_remote(std::move(printer_remote_in)){
}

    WebPrinterInfo(const WebPrinterInfo&) = delete;
    WebPrinterInfo& operator=(const WebPrinterInfo&) = delete;

    ~WebPrinterInfo() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = WebPrinterInfoPtr> WebPrinterInfoPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, WebPrinterInfo::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, WebPrinterInfo::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, WebPrinterInfo::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<WebPrinterInfo::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(std::make_unique<internal::WebPrinterInfo_UnserializedMessageContext<UserType, WebPrinterInfo::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<WebPrinterInfo::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return WebPrinterInfo::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::WebPrinterInfo_UnserializedMessageContext<UserType, WebPrinterInfo::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<WebPrinterInfo::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    WTF::String printer_name;

    ::mojo::PendingRemote<WebPrinter> printer_remote;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, WebPrinterInfo::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, WebPrinterInfo::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, WebPrinterInfo::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, WebPrinterInfo::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class PLATFORM_EXPORT WebPrintingMediaSize {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<WebPrintingMediaSize, T>::value>;
    using DataView = WebPrintingMediaSizeDataView;
    using Data_ = internal::WebPrintingMediaSize_Data;

    template <typename... Args> static WebPrintingMediaSizePtr New(Args&&... args)
    {
        return WebPrintingMediaSizePtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static WebPrintingMediaSizePtr From(const U& u)
    {
        return mojo::TypeConverter<WebPrintingMediaSizePtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, WebPrintingMediaSize>::Convert(*this);
    }

    WebPrintingMediaSize()
    : x_dimension()
    , y_dimension()
{
}

    WebPrintingMediaSize(WebPrintingMediaSizeDimensionPtr x_dimension_in, WebPrintingMediaSizeDimensionPtr y_dimension_in)
    : x_dimension(std::move(x_dimension_in))
    , y_dimension(std::move(y_dimension_in)){
}

    WebPrintingMediaSize(const WebPrintingMediaSize&) = delete;
    WebPrintingMediaSize& operator=(const WebPrintingMediaSize&) = delete;

    ~WebPrintingMediaSize() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = WebPrintingMediaSizePtr> WebPrintingMediaSizePtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, WebPrintingMediaSize::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, WebPrintingMediaSize::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, WebPrintingMediaSize::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<WebPrintingMediaSize::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<WebPrintingMediaSize::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::WebPrintingMediaSize_UnserializedMessageContext<UserType, WebPrintingMediaSize::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<WebPrintingMediaSize::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return WebPrintingMediaSize::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::WebPrintingMediaSize_UnserializedMessageContext<UserType, WebPrintingMediaSize::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<WebPrintingMediaSize::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    WebPrintingMediaSizeDimensionPtr x_dimension;

    WebPrintingMediaSizeDimensionPtr y_dimension;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, WebPrintingMediaSize::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, WebPrintingMediaSize::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, WebPrintingMediaSize::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, WebPrintingMediaSize::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class PLATFORM_EXPORT WebPrintingMediaCollection {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<WebPrintingMediaCollection, T>::value>;
    using DataView = WebPrintingMediaCollectionDataView;
    using Data_ = internal::WebPrintingMediaCollection_Data;

    template <typename... Args> static WebPrintingMediaCollectionPtr New(Args&&... args)
    {
        return WebPrintingMediaCollectionPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static WebPrintingMediaCollectionPtr From(const U& u)
    {
        return mojo::TypeConverter<WebPrintingMediaCollectionPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, WebPrintingMediaCollection>::Convert(*this);
    }

    WebPrintingMediaCollection()
    : media_size()
    , media_size_name()
{
}

    WebPrintingMediaCollection(WebPrintingMediaSizePtr media_size_in, const WTF::String& media_size_name_in)
    : media_size(std::move(media_size_in))
    , media_size_name(std::move(media_size_name_in)){
}

    WebPrintingMediaCollection(const WebPrintingMediaCollection&) = delete;
    WebPrintingMediaCollection& operator=(const WebPrintingMediaCollection&) = delete;

    ~WebPrintingMediaCollection() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = WebPrintingMediaCollectionPtr> WebPrintingMediaCollectionPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, WebPrintingMediaCollection::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, WebPrintingMediaCollection::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, WebPrintingMediaCollection::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<WebPrintingMediaCollection::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<WebPrintingMediaCollection::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(std::make_unique<internal::WebPrintingMediaCollection_UnserializedMessageContext<UserType, WebPrintingMediaCollection::DataView>>(
                                 0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<WebPrintingMediaCollection::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return WebPrintingMediaCollection::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context
            = input.TakeUnserializedContext<internal::WebPrintingMediaCollection_UnserializedMessageContext<UserType, WebPrintingMediaCollection::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<WebPrintingMediaCollection::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    WebPrintingMediaSizePtr media_size;

    WTF::String media_size_name;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, WebPrintingMediaCollection::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, WebPrintingMediaCollection::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, WebPrintingMediaCollection::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, WebPrintingMediaCollection::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class PLATFORM_EXPORT WebPrinterAttributes {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<WebPrinterAttributes, T>::value>;
    using DataView = WebPrinterAttributesDataView;
    using Data_ = internal::WebPrinterAttributes_Data;

    template <typename... Args> static WebPrinterAttributesPtr New(Args&&... args)
    {
        return WebPrinterAttributesPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static WebPrinterAttributesPtr From(const U& u)
    {
        return mojo::TypeConverter<WebPrinterAttributesPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, WebPrinterAttributes>::Convert(*this);
    }

    WebPrinterAttributes()
    : copies_default()
    , copies_supported()
    , media_col_default()
    , media_col_database()
    , media_source_default()
    , media_source_supported()
    , multiple_document_handling_default()
    , multiple_document_handling_supported()
    , orientation_requested_default()
    , orientation_requested_supported()
    , printer_resolution_default()
    , printer_resolution_supported()
    , print_color_mode_default()
    , print_color_mode_supported()
    , printer_state()
    , printer_state_message()
    , printer_state_reasons()
    , sides_default()
    , sides_supported()
{
}

    WebPrinterAttributes(uint32_t copies_default_in, WebPrintingRangePtr copies_supported_in,
    WebPrintingMediaCollectionPtr media_col_default_in, WTF::Vector<WebPrintingMediaCollectionPtr> media_col_database_in,
    const WTF::String& media_source_default_in, WTF::Vector<WTF::String> media_source_supported_in,
    WebPrintingMultipleDocumentHandling multiple_document_handling_default_in,
    WTF::Vector<WebPrintingMultipleDocumentHandling> multiple_document_handling_supported_in, WebPrintingOrientationRequested orientation_requested_default_in,
    WTF::Vector<WebPrintingOrientationRequested> orientation_requested_supported_in, const ::gfx::Size& printer_resolution_default_in,
    WTF::Vector<::gfx::Size> printer_resolution_supported_in, WebPrintColorMode print_color_mode_default_in,
    WTF::Vector<WebPrintColorMode> print_color_mode_supported_in, WebPrinterState printer_state_in, const WTF::String& printer_state_message_in,
    WTF::Vector<WebPrinterStateReason> printer_state_reasons_in, std::optional<WebPrintingSides> sides_default_in,
    WTF::Vector<WebPrintingSides> sides_supported_in)
    : copies_default(std::move(copies_default_in))
    , copies_supported(std::move(copies_supported_in))
    , media_col_default(std::move(media_col_default_in))
    , media_col_database(std::move(media_col_database_in))
    , media_source_default(std::move(media_source_default_in))
    , media_source_supported(std::move(media_source_supported_in))
    , multiple_document_handling_default(std::move(multiple_document_handling_default_in))
    , multiple_document_handling_supported(std::move(multiple_document_handling_supported_in))
    , orientation_requested_default(std::move(orientation_requested_default_in))
    , orientation_requested_supported(std::move(orientation_requested_supported_in))
    , printer_resolution_default(std::move(printer_resolution_default_in))
    , printer_resolution_supported(std::move(printer_resolution_supported_in))
    , print_color_mode_default(std::move(print_color_mode_default_in))
    , print_color_mode_supported(std::move(print_color_mode_supported_in))
    , printer_state(std::move(printer_state_in))
    , printer_state_message(std::move(printer_state_message_in))
    , printer_state_reasons(std::move(printer_state_reasons_in))
    , sides_default(std::move(sides_default_in))
    , sides_supported(std::move(sides_supported_in)){
}

    WebPrinterAttributes(const WebPrinterAttributes&) = delete;
    WebPrinterAttributes& operator=(const WebPrinterAttributes&) = delete;

    ~WebPrinterAttributes() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = WebPrinterAttributesPtr> WebPrinterAttributesPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, WebPrinterAttributes::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, WebPrinterAttributes::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, WebPrinterAttributes::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<WebPrinterAttributes::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<WebPrinterAttributes::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::WebPrinterAttributes_UnserializedMessageContext<UserType, WebPrinterAttributes::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<WebPrinterAttributes::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return WebPrinterAttributes::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::WebPrinterAttributes_UnserializedMessageContext<UserType, WebPrinterAttributes::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<WebPrinterAttributes::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    uint32_t copies_default;

    WebPrintingRangePtr copies_supported;

    WebPrintingMediaCollectionPtr media_col_default;

    WTF::Vector<WebPrintingMediaCollectionPtr> media_col_database;

    WTF::String media_source_default;

    WTF::Vector<WTF::String> media_source_supported;

    WebPrintingMultipleDocumentHandling multiple_document_handling_default;

    WTF::Vector<WebPrintingMultipleDocumentHandling> multiple_document_handling_supported;

    WebPrintingOrientationRequested orientation_requested_default;

    WTF::Vector<WebPrintingOrientationRequested> orientation_requested_supported;

    ::gfx::Size printer_resolution_default;

    WTF::Vector<::gfx::Size> printer_resolution_supported;

    WebPrintColorMode print_color_mode_default;

    WTF::Vector<WebPrintColorMode> print_color_mode_supported;

    WebPrinterState printer_state;

    WTF::String printer_state_message;

    WTF::Vector<WebPrinterStateReason> printer_state_reasons;

    std::optional<WebPrintingSides> sides_default;

    WTF::Vector<WebPrintingSides> sides_supported;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, WebPrinterAttributes::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, WebPrinterAttributes::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, WebPrinterAttributes::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, WebPrinterAttributes::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class PLATFORM_EXPORT WebPrintingMediaCollectionRequested {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<WebPrintingMediaCollectionRequested, T>::value>;
    using DataView = WebPrintingMediaCollectionRequestedDataView;
    using Data_ = internal::WebPrintingMediaCollectionRequested_Data;

    template <typename... Args> static WebPrintingMediaCollectionRequestedPtr New(Args&&... args)
    {
        return WebPrintingMediaCollectionRequestedPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static WebPrintingMediaCollectionRequestedPtr From(const U& u)
    {
        return mojo::TypeConverter<WebPrintingMediaCollectionRequestedPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, WebPrintingMediaCollectionRequested>::Convert(*this);
    }

    WebPrintingMediaCollectionRequested()
    : media_size()
{
}

    explicit WebPrintingMediaCollectionRequested(const ::gfx::Size& media_size_in)
    : media_size(std::move(media_size_in)){
}

    ~WebPrintingMediaCollectionRequested() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = WebPrintingMediaCollectionRequestedPtr> WebPrintingMediaCollectionRequestedPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, WebPrintingMediaCollectionRequested::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, WebPrintingMediaCollectionRequested::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, WebPrintingMediaCollectionRequested::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<WebPrintingMediaCollectionRequested::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<WebPrintingMediaCollectionRequested::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::WebPrintingMediaCollectionRequested_UnserializedMessageContext<UserType, WebPrintingMediaCollectionRequested::DataView>>(
                0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<WebPrintingMediaCollectionRequested::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return WebPrintingMediaCollectionRequested::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<
            internal::WebPrintingMediaCollectionRequested_UnserializedMessageContext<UserType, WebPrintingMediaCollectionRequested::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<WebPrintingMediaCollectionRequested::DataView>(
            input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    ::gfx::Size media_size;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, WebPrintingMediaCollectionRequested::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, WebPrintingMediaCollectionRequested::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, WebPrintingMediaCollectionRequested::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, WebPrintingMediaCollectionRequested::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class PLATFORM_EXPORT WebPrintJobTemplateAttributes {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<WebPrintJobTemplateAttributes, T>::value>;
    using DataView = WebPrintJobTemplateAttributesDataView;
    using Data_ = internal::WebPrintJobTemplateAttributes_Data;

    template <typename... Args> static WebPrintJobTemplateAttributesPtr New(Args&&... args)
    {
        return WebPrintJobTemplateAttributesPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static WebPrintJobTemplateAttributesPtr From(const U& u)
    {
        return mojo::TypeConverter<WebPrintJobTemplateAttributesPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, WebPrintJobTemplateAttributes>::Convert(*this);
    }

    WebPrintJobTemplateAttributes()
    : job_name()
    , copies()
    , media_col()
    , media_source()
    , multiple_document_handling()
    , orientation_requested()
    , printer_resolution()
    , print_color_mode()
    , sides()
{
}

    WebPrintJobTemplateAttributes(const WTF::String& job_name_in, uint32_t copies_in,
    WebPrintingMediaCollectionRequestedPtr media_col_in, const WTF::String& media_source_in,
    std::optional<WebPrintingMultipleDocumentHandling> multiple_document_handling_in, std::optional<WebPrintingOrientationRequested> orientation_requested_in,
    const std::optional<::gfx::Size>& printer_resolution_in, std::optional<WebPrintColorMode> print_color_mode_in, std::optional<WebPrintingSides> sides_in)
    : job_name(std::move(job_name_in))
    , copies(std::move(copies_in))
    , media_col(std::move(media_col_in))
    , media_source(std::move(media_source_in))
    , multiple_document_handling(std::move(multiple_document_handling_in))
    , orientation_requested(std::move(orientation_requested_in))
    , printer_resolution(std::move(printer_resolution_in))
    , print_color_mode(std::move(print_color_mode_in))
    , sides(std::move(sides_in)){
}

    WebPrintJobTemplateAttributes(const WebPrintJobTemplateAttributes&) = delete;
    WebPrintJobTemplateAttributes& operator=(const WebPrintJobTemplateAttributes&) = delete;

    ~WebPrintJobTemplateAttributes() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = WebPrintJobTemplateAttributesPtr> WebPrintJobTemplateAttributesPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, WebPrintJobTemplateAttributes::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, WebPrintJobTemplateAttributes::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, WebPrintJobTemplateAttributes::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<WebPrintJobTemplateAttributes::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<WebPrintJobTemplateAttributes::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::WebPrintJobTemplateAttributes_UnserializedMessageContext<UserType, WebPrintJobTemplateAttributes::DataView>>(
                0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<WebPrintJobTemplateAttributes::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return WebPrintJobTemplateAttributes::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<
            internal::WebPrintJobTemplateAttributes_UnserializedMessageContext<UserType, WebPrintJobTemplateAttributes::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<WebPrintJobTemplateAttributes::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    WTF::String job_name;

    uint32_t copies;

    WebPrintingMediaCollectionRequestedPtr media_col;

    WTF::String media_source;

    std::optional<WebPrintingMultipleDocumentHandling> multiple_document_handling;

    std::optional<WebPrintingOrientationRequested> orientation_requested;

    std::optional<::gfx::Size> printer_resolution;

    std::optional<WebPrintColorMode> print_color_mode;

    std::optional<WebPrintingSides> sides;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, WebPrintJobTemplateAttributes::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, WebPrintJobTemplateAttributes::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, WebPrintJobTemplateAttributes::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, WebPrintJobTemplateAttributes::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class PLATFORM_EXPORT WebPrintJobInfo {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<WebPrintJobInfo, T>::value>;
    using DataView = WebPrintJobInfoDataView;
    using Data_ = internal::WebPrintJobInfo_Data;

    template <typename... Args> static WebPrintJobInfoPtr New(Args&&... args)
    {
        return WebPrintJobInfoPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static WebPrintJobInfoPtr From(const U& u)
    {
        return mojo::TypeConverter<WebPrintJobInfoPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, WebPrintJobInfo>::Convert(*this);
    }

    WebPrintJobInfo()
    : job_name()
    , job_pages()
    , observer()
    , controller()
{
}

    WebPrintJobInfo(const WTF::String& job_name_in, uint32_t job_pages_in, ::mojo::PendingReceiver<WebPrintJobStateObserver> observer_in,
    ::mojo::PendingRemote<WebPrintJobController> controller_in)
    : job_name(std::move(job_name_in))
    , job_pages(std::move(job_pages_in))
    , observer(std::move(observer_in))
    , controller(std::move(controller_in)){
}

    WebPrintJobInfo(const WebPrintJobInfo&) = delete;
    WebPrintJobInfo& operator=(const WebPrintJobInfo&) = delete;

    ~WebPrintJobInfo() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = WebPrintJobInfoPtr> WebPrintJobInfoPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, WebPrintJobInfo::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, WebPrintJobInfo::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, WebPrintJobInfo::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<WebPrintJobInfo::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::WebPrintJobInfo_UnserializedMessageContext<UserType, WebPrintJobInfo::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<WebPrintJobInfo::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return WebPrintJobInfo::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::WebPrintJobInfo_UnserializedMessageContext<UserType, WebPrintJobInfo::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<WebPrintJobInfo::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    WTF::String job_name;

    uint32_t job_pages;

    ::mojo::PendingReceiver<WebPrintJobStateObserver> observer;

    ::mojo::PendingRemote<WebPrintJobController> controller;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, WebPrintJobInfo::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, WebPrintJobInfo::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, WebPrintJobInfo::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, WebPrintJobInfo::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

template <typename UnionPtrType> WebPrintingMediaSizeDimensionPtr WebPrintingMediaSizeDimension::Clone() const
{
    switch (tag_) {
    case Tag::kRange:
        return NewRange(mojo::Clone(*data_.range));
    case Tag::kValue:
        return NewValue(mojo::Clone(data_.value));
    }
    return nullptr;
}

template <typename T, typename std::enable_if<std::is_same<T, WebPrintingMediaSizeDimension>::value>::type*>
bool WebPrintingMediaSizeDimension::Equals(const T& other) const
{
    if (tag_ != other.which())
        return false;

    switch (tag_) {
    case Tag::kRange:
        return mojo::Equals(*(data_.range), *(other.data_.range));
    case Tag::kValue:
        return mojo::Equals(data_.value, other.data_.value);
    }

    return false;
}
template <typename UnionPtrType> GetPrintersResultPtr GetPrintersResult::Clone() const
{
    switch (tag_) {
    case Tag::kPrinters:
        return NewPrinters(mojo::Clone(*data_.printers));
    case Tag::kError:
        return NewError(mojo::Clone(data_.error));
    }
    return nullptr;
}

template <typename T, typename std::enable_if<std::is_same<T, GetPrintersResult>::value>::type*> bool GetPrintersResult::Equals(const T& other) const
{
    if (tag_ != other.which())
        return false;

    switch (tag_) {
    case Tag::kPrinters:
        return mojo::Equals(*(data_.printers), *(other.data_.printers));
    case Tag::kError:
        return mojo::Equals(data_.error, other.data_.error);
    }

    return false;
}
template <typename UnionPtrType> WebPrinterFetchResultPtr WebPrinterFetchResult::Clone() const
{
    switch (tag_) {
    case Tag::kPrinterAttributes:
        return NewPrinterAttributes(mojo::Clone(*data_.printer_attributes));
    case Tag::kError:
        return NewError(mojo::Clone(data_.error));
    }
    return nullptr;
}

template <typename T, typename std::enable_if<std::is_same<T, WebPrinterFetchResult>::value>::type*> bool WebPrinterFetchResult::Equals(const T& other) const
{
    if (tag_ != other.which())
        return false;

    switch (tag_) {
    case Tag::kPrinterAttributes:
        return mojo::Equals(*(data_.printer_attributes), *(other.data_.printer_attributes));
    case Tag::kError:
        return mojo::Equals(data_.error, other.data_.error);
    }

    return false;
}
template <typename UnionPtrType> WebPrintResultPtr WebPrintResult::Clone() const
{
    switch (tag_) {
    case Tag::kPrintJobInfo:
        return NewPrintJobInfo(mojo::Clone(*data_.print_job_info));
    case Tag::kError:
        return NewError(mojo::Clone(data_.error));
    }
    return nullptr;
}

template <typename T, typename std::enable_if<std::is_same<T, WebPrintResult>::value>::type*> bool WebPrintResult::Equals(const T& other) const
{
    if (tag_ != other.which())
        return false;

    switch (tag_) {
    case Tag::kPrintJobInfo:
        return mojo::Equals(*(data_.print_job_info), *(other.data_.print_job_info));
    case Tag::kError:
        return mojo::Equals(data_.error, other.data_.error);
    }

    return false;
}
template <typename StructPtrType> WebPrinterInfoPtr WebPrinterInfo::Clone() const
{
    return New(mojo::Clone(printer_name), mojo::Clone(printer_remote));
}

template <typename T, WebPrinterInfo::EnableIfSame<T>*> bool WebPrinterInfo::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->printer_name, other_struct.printer_name))
        return false;
    if (!mojo::Equals(this->printer_remote, other_struct.printer_remote))
        return false;
    return true;
}

template <typename T, WebPrinterInfo::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.printer_name < rhs.printer_name)
        return true;
    if (rhs.printer_name < lhs.printer_name)
        return false;
    if (lhs.printer_remote < rhs.printer_remote)
        return true;
    if (rhs.printer_remote < lhs.printer_remote)
        return false;
    return false;
}
template <typename StructPtrType> WebPrintingRangePtr WebPrintingRange::Clone() const
{
    return New(mojo::Clone(from), mojo::Clone(to));
}

template <typename T, WebPrintingRange::EnableIfSame<T>*> bool WebPrintingRange::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->from, other_struct.from))
        return false;
    if (!mojo::Equals(this->to, other_struct.to))
        return false;
    return true;
}

template <typename T, WebPrintingRange::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.from < rhs.from)
        return true;
    if (rhs.from < lhs.from)
        return false;
    if (lhs.to < rhs.to)
        return true;
    if (rhs.to < lhs.to)
        return false;
    return false;
}
template <typename StructPtrType> WebPrintingMediaSizePtr WebPrintingMediaSize::Clone() const
{
    return New(mojo::Clone(x_dimension), mojo::Clone(y_dimension));
}

template <typename T, WebPrintingMediaSize::EnableIfSame<T>*> bool WebPrintingMediaSize::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->x_dimension, other_struct.x_dimension))
        return false;
    if (!mojo::Equals(this->y_dimension, other_struct.y_dimension))
        return false;
    return true;
}

template <typename T, WebPrintingMediaSize::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.x_dimension < rhs.x_dimension)
        return true;
    if (rhs.x_dimension < lhs.x_dimension)
        return false;
    if (lhs.y_dimension < rhs.y_dimension)
        return true;
    if (rhs.y_dimension < lhs.y_dimension)
        return false;
    return false;
}
template <typename StructPtrType> WebPrintingMediaCollectionPtr WebPrintingMediaCollection::Clone() const
{
    return New(mojo::Clone(media_size), mojo::Clone(media_size_name));
}

template <typename T, WebPrintingMediaCollection::EnableIfSame<T>*> bool WebPrintingMediaCollection::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->media_size, other_struct.media_size))
        return false;
    if (!mojo::Equals(this->media_size_name, other_struct.media_size_name))
        return false;
    return true;
}

template <typename T, WebPrintingMediaCollection::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.media_size < rhs.media_size)
        return true;
    if (rhs.media_size < lhs.media_size)
        return false;
    if (lhs.media_size_name < rhs.media_size_name)
        return true;
    if (rhs.media_size_name < lhs.media_size_name)
        return false;
    return false;
}
template <typename StructPtrType> WebPrinterAttributesPtr WebPrinterAttributes::Clone() const
{
    return New(mojo::Clone(copies_default), mojo::Clone(copies_supported), mojo::Clone(media_col_default), mojo::Clone(media_col_database),
        mojo::Clone(media_source_default), mojo::Clone(media_source_supported), mojo::Clone(multiple_document_handling_default),
        mojo::Clone(multiple_document_handling_supported), mojo::Clone(orientation_requested_default), mojo::Clone(orientation_requested_supported),
        mojo::Clone(printer_resolution_default), mojo::Clone(printer_resolution_supported), mojo::Clone(print_color_mode_default),
        mojo::Clone(print_color_mode_supported), mojo::Clone(printer_state), mojo::Clone(printer_state_message), mojo::Clone(printer_state_reasons),
        mojo::Clone(sides_default), mojo::Clone(sides_supported));
}

template <typename T, WebPrinterAttributes::EnableIfSame<T>*> bool WebPrinterAttributes::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->copies_default, other_struct.copies_default))
        return false;
    if (!mojo::Equals(this->copies_supported, other_struct.copies_supported))
        return false;
    if (!mojo::Equals(this->media_col_default, other_struct.media_col_default))
        return false;
    if (!mojo::Equals(this->media_col_database, other_struct.media_col_database))
        return false;
    if (!mojo::Equals(this->media_source_default, other_struct.media_source_default))
        return false;
    if (!mojo::Equals(this->media_source_supported, other_struct.media_source_supported))
        return false;
    if (!mojo::Equals(this->multiple_document_handling_default, other_struct.multiple_document_handling_default))
        return false;
    if (!mojo::Equals(this->multiple_document_handling_supported, other_struct.multiple_document_handling_supported))
        return false;
    if (!mojo::Equals(this->orientation_requested_default, other_struct.orientation_requested_default))
        return false;
    if (!mojo::Equals(this->orientation_requested_supported, other_struct.orientation_requested_supported))
        return false;
    if (!mojo::Equals(this->printer_resolution_default, other_struct.printer_resolution_default))
        return false;
    if (!mojo::Equals(this->printer_resolution_supported, other_struct.printer_resolution_supported))
        return false;
    if (!mojo::Equals(this->print_color_mode_default, other_struct.print_color_mode_default))
        return false;
    if (!mojo::Equals(this->print_color_mode_supported, other_struct.print_color_mode_supported))
        return false;
    if (!mojo::Equals(this->printer_state, other_struct.printer_state))
        return false;
    if (!mojo::Equals(this->printer_state_message, other_struct.printer_state_message))
        return false;
    if (!mojo::Equals(this->printer_state_reasons, other_struct.printer_state_reasons))
        return false;
    if (!mojo::Equals(this->sides_default, other_struct.sides_default))
        return false;
    if (!mojo::Equals(this->sides_supported, other_struct.sides_supported))
        return false;
    return true;
}

template <typename T, WebPrinterAttributes::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.copies_default < rhs.copies_default)
        return true;
    if (rhs.copies_default < lhs.copies_default)
        return false;
    if (lhs.copies_supported < rhs.copies_supported)
        return true;
    if (rhs.copies_supported < lhs.copies_supported)
        return false;
    if (lhs.media_col_default < rhs.media_col_default)
        return true;
    if (rhs.media_col_default < lhs.media_col_default)
        return false;
    if (lhs.media_col_database < rhs.media_col_database)
        return true;
    if (rhs.media_col_database < lhs.media_col_database)
        return false;
    if (lhs.media_source_default < rhs.media_source_default)
        return true;
    if (rhs.media_source_default < lhs.media_source_default)
        return false;
    if (lhs.media_source_supported < rhs.media_source_supported)
        return true;
    if (rhs.media_source_supported < lhs.media_source_supported)
        return false;
    if (lhs.multiple_document_handling_default < rhs.multiple_document_handling_default)
        return true;
    if (rhs.multiple_document_handling_default < lhs.multiple_document_handling_default)
        return false;
    if (lhs.multiple_document_handling_supported < rhs.multiple_document_handling_supported)
        return true;
    if (rhs.multiple_document_handling_supported < lhs.multiple_document_handling_supported)
        return false;
    if (lhs.orientation_requested_default < rhs.orientation_requested_default)
        return true;
    if (rhs.orientation_requested_default < lhs.orientation_requested_default)
        return false;
    if (lhs.orientation_requested_supported < rhs.orientation_requested_supported)
        return true;
    if (rhs.orientation_requested_supported < lhs.orientation_requested_supported)
        return false;
    if (lhs.printer_resolution_default < rhs.printer_resolution_default)
        return true;
    if (rhs.printer_resolution_default < lhs.printer_resolution_default)
        return false;
    if (lhs.printer_resolution_supported < rhs.printer_resolution_supported)
        return true;
    if (rhs.printer_resolution_supported < lhs.printer_resolution_supported)
        return false;
    if (lhs.print_color_mode_default < rhs.print_color_mode_default)
        return true;
    if (rhs.print_color_mode_default < lhs.print_color_mode_default)
        return false;
    if (lhs.print_color_mode_supported < rhs.print_color_mode_supported)
        return true;
    if (rhs.print_color_mode_supported < lhs.print_color_mode_supported)
        return false;
    if (lhs.printer_state < rhs.printer_state)
        return true;
    if (rhs.printer_state < lhs.printer_state)
        return false;
    if (lhs.printer_state_message < rhs.printer_state_message)
        return true;
    if (rhs.printer_state_message < lhs.printer_state_message)
        return false;
    if (lhs.printer_state_reasons < rhs.printer_state_reasons)
        return true;
    if (rhs.printer_state_reasons < lhs.printer_state_reasons)
        return false;
    if (lhs.sides_default < rhs.sides_default)
        return true;
    if (rhs.sides_default < lhs.sides_default)
        return false;
    if (lhs.sides_supported < rhs.sides_supported)
        return true;
    if (rhs.sides_supported < lhs.sides_supported)
        return false;
    return false;
}
template <typename StructPtrType> WebPrintingMediaCollectionRequestedPtr WebPrintingMediaCollectionRequested::Clone() const
{
    return New(mojo::Clone(media_size));
}

template <typename T, WebPrintingMediaCollectionRequested::EnableIfSame<T>*> bool WebPrintingMediaCollectionRequested::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->media_size, other_struct.media_size))
        return false;
    return true;
}

template <typename T, WebPrintingMediaCollectionRequested::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.media_size < rhs.media_size)
        return true;
    if (rhs.media_size < lhs.media_size)
        return false;
    return false;
}
template <typename StructPtrType> WebPrintJobTemplateAttributesPtr WebPrintJobTemplateAttributes::Clone() const
{
    return New(mojo::Clone(job_name), mojo::Clone(copies), mojo::Clone(media_col), mojo::Clone(media_source), mojo::Clone(multiple_document_handling),
        mojo::Clone(orientation_requested), mojo::Clone(printer_resolution), mojo::Clone(print_color_mode), mojo::Clone(sides));
}

template <typename T, WebPrintJobTemplateAttributes::EnableIfSame<T>*> bool WebPrintJobTemplateAttributes::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->job_name, other_struct.job_name))
        return false;
    if (!mojo::Equals(this->copies, other_struct.copies))
        return false;
    if (!mojo::Equals(this->media_col, other_struct.media_col))
        return false;
    if (!mojo::Equals(this->media_source, other_struct.media_source))
        return false;
    if (!mojo::Equals(this->multiple_document_handling, other_struct.multiple_document_handling))
        return false;
    if (!mojo::Equals(this->orientation_requested, other_struct.orientation_requested))
        return false;
    if (!mojo::Equals(this->printer_resolution, other_struct.printer_resolution))
        return false;
    if (!mojo::Equals(this->print_color_mode, other_struct.print_color_mode))
        return false;
    if (!mojo::Equals(this->sides, other_struct.sides))
        return false;
    return true;
}

template <typename T, WebPrintJobTemplateAttributes::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.job_name < rhs.job_name)
        return true;
    if (rhs.job_name < lhs.job_name)
        return false;
    if (lhs.copies < rhs.copies)
        return true;
    if (rhs.copies < lhs.copies)
        return false;
    if (lhs.media_col < rhs.media_col)
        return true;
    if (rhs.media_col < lhs.media_col)
        return false;
    if (lhs.media_source < rhs.media_source)
        return true;
    if (rhs.media_source < lhs.media_source)
        return false;
    if (lhs.multiple_document_handling < rhs.multiple_document_handling)
        return true;
    if (rhs.multiple_document_handling < lhs.multiple_document_handling)
        return false;
    if (lhs.orientation_requested < rhs.orientation_requested)
        return true;
    if (rhs.orientation_requested < lhs.orientation_requested)
        return false;
    if (lhs.printer_resolution < rhs.printer_resolution)
        return true;
    if (rhs.printer_resolution < lhs.printer_resolution)
        return false;
    if (lhs.print_color_mode < rhs.print_color_mode)
        return true;
    if (rhs.print_color_mode < lhs.print_color_mode)
        return false;
    if (lhs.sides < rhs.sides)
        return true;
    if (rhs.sides < lhs.sides)
        return false;
    return false;
}
template <typename StructPtrType> WebPrintJobUpdatePtr WebPrintJobUpdate::Clone() const
{
    return New(mojo::Clone(state), mojo::Clone(pages_printed));
}

template <typename T, WebPrintJobUpdate::EnableIfSame<T>*> bool WebPrintJobUpdate::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->state, other_struct.state))
        return false;
    if (!mojo::Equals(this->pages_printed, other_struct.pages_printed))
        return false;
    return true;
}

template <typename T, WebPrintJobUpdate::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.state < rhs.state)
        return true;
    if (rhs.state < lhs.state)
        return false;
    if (lhs.pages_printed < rhs.pages_printed)
        return true;
    if (rhs.pages_printed < lhs.pages_printed)
        return false;
    return false;
}
template <typename StructPtrType> WebPrintJobInfoPtr WebPrintJobInfo::Clone() const
{
    return New(mojo::Clone(job_name), mojo::Clone(job_pages), mojo::Clone(observer), mojo::Clone(controller));
}

template <typename T, WebPrintJobInfo::EnableIfSame<T>*> bool WebPrintJobInfo::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->job_name, other_struct.job_name))
        return false;
    if (!mojo::Equals(this->job_pages, other_struct.job_pages))
        return false;
    if (!mojo::Equals(this->observer, other_struct.observer))
        return false;
    if (!mojo::Equals(this->controller, other_struct.controller))
        return false;
    return true;
}

template <typename T, WebPrintJobInfo::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.job_name < rhs.job_name)
        return true;
    if (rhs.job_name < lhs.job_name)
        return false;
    if (lhs.job_pages < rhs.job_pages)
        return true;
    if (rhs.job_pages < lhs.job_pages)
        return false;
    if (lhs.observer < rhs.observer)
        return true;
    if (rhs.observer < lhs.observer)
        return false;
    if (lhs.controller < rhs.controller)
        return true;
    if (rhs.controller < lhs.controller)
        return false;
    return false;
}

} // blink::mojom::blink

namespace mojo {

template <> struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::WebPrinterInfo::DataView, ::blink::mojom::blink::WebPrinterInfoPtr> {
    static bool IsNull(const ::blink::mojom::blink::WebPrinterInfoPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::blink::WebPrinterInfoPtr* output)
    {
        output->reset();
    }

    static const decltype(::blink::mojom::blink::WebPrinterInfo::printer_name)& printer_name(const ::blink::mojom::blink::WebPrinterInfoPtr& input)
    {
        return input->printer_name;
    }

    static decltype(::blink::mojom::blink::WebPrinterInfo::printer_remote)& printer_remote(::blink::mojom::blink::WebPrinterInfoPtr& input)
    {
        return input->printer_remote;
    }

    static bool Read(::blink::mojom::blink::WebPrinterInfo::DataView input, ::blink::mojom::blink::WebPrinterInfoPtr* output);
};

template <> struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::WebPrintingRange::DataView, ::blink::mojom::blink::WebPrintingRangePtr> {
    static bool IsNull(const ::blink::mojom::blink::WebPrintingRangePtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::blink::WebPrintingRangePtr* output)
    {
        output->reset();
    }

    static decltype(::blink::mojom::blink::WebPrintingRange::from) from(const ::blink::mojom::blink::WebPrintingRangePtr& input)
    {
        return input->from;
    }

    static decltype(::blink::mojom::blink::WebPrintingRange::to) to(const ::blink::mojom::blink::WebPrintingRangePtr& input)
    {
        return input->to;
    }

    static bool Read(::blink::mojom::blink::WebPrintingRange::DataView input, ::blink::mojom::blink::WebPrintingRangePtr* output);
};

template <> struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::WebPrintingMediaSize::DataView, ::blink::mojom::blink::WebPrintingMediaSizePtr> {
    static bool IsNull(const ::blink::mojom::blink::WebPrintingMediaSizePtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::blink::WebPrintingMediaSizePtr* output)
    {
        output->reset();
    }

    static const decltype(::blink::mojom::blink::WebPrintingMediaSize::x_dimension)& x_dimension(const ::blink::mojom::blink::WebPrintingMediaSizePtr& input)
    {
        return input->x_dimension;
    }

    static const decltype(::blink::mojom::blink::WebPrintingMediaSize::y_dimension)& y_dimension(const ::blink::mojom::blink::WebPrintingMediaSizePtr& input)
    {
        return input->y_dimension;
    }

    static bool Read(::blink::mojom::blink::WebPrintingMediaSize::DataView input, ::blink::mojom::blink::WebPrintingMediaSizePtr* output);
};

template <>
struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::WebPrintingMediaCollection::DataView, ::blink::mojom::blink::WebPrintingMediaCollectionPtr> {
    static bool IsNull(const ::blink::mojom::blink::WebPrintingMediaCollectionPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::blink::WebPrintingMediaCollectionPtr* output)
    {
        output->reset();
    }

    static const decltype(::blink::mojom::blink::WebPrintingMediaCollection::media_size)& media_size(
        const ::blink::mojom::blink::WebPrintingMediaCollectionPtr& input)
    {
        return input->media_size;
    }

    static const decltype(::blink::mojom::blink::WebPrintingMediaCollection::media_size_name)& media_size_name(
        const ::blink::mojom::blink::WebPrintingMediaCollectionPtr& input)
    {
        return input->media_size_name;
    }

    static bool Read(::blink::mojom::blink::WebPrintingMediaCollection::DataView input, ::blink::mojom::blink::WebPrintingMediaCollectionPtr* output);
};

template <> struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::WebPrinterAttributes::DataView, ::blink::mojom::blink::WebPrinterAttributesPtr> {
    static bool IsNull(const ::blink::mojom::blink::WebPrinterAttributesPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::blink::WebPrinterAttributesPtr* output)
    {
        output->reset();
    }

    static decltype(::blink::mojom::blink::WebPrinterAttributes::copies_default) copies_default(const ::blink::mojom::blink::WebPrinterAttributesPtr& input)
    {
        return input->copies_default;
    }

    static const decltype(::blink::mojom::blink::WebPrinterAttributes::copies_supported)& copies_supported(
        const ::blink::mojom::blink::WebPrinterAttributesPtr& input)
    {
        return input->copies_supported;
    }

    static const decltype(::blink::mojom::blink::WebPrinterAttributes::media_col_default)& media_col_default(
        const ::blink::mojom::blink::WebPrinterAttributesPtr& input)
    {
        return input->media_col_default;
    }

    static const decltype(::blink::mojom::blink::WebPrinterAttributes::media_col_database)& media_col_database(
        const ::blink::mojom::blink::WebPrinterAttributesPtr& input)
    {
        return input->media_col_database;
    }

    static const decltype(::blink::mojom::blink::WebPrinterAttributes::media_source_default)& media_source_default(
        const ::blink::mojom::blink::WebPrinterAttributesPtr& input)
    {
        return input->media_source_default;
    }

    static const decltype(::blink::mojom::blink::WebPrinterAttributes::media_source_supported)& media_source_supported(
        const ::blink::mojom::blink::WebPrinterAttributesPtr& input)
    {
        return input->media_source_supported;
    }

    static decltype(::blink::mojom::blink::WebPrinterAttributes::multiple_document_handling_default) multiple_document_handling_default(
        const ::blink::mojom::blink::WebPrinterAttributesPtr& input)
    {
        return input->multiple_document_handling_default;
    }

    static const decltype(::blink::mojom::blink::WebPrinterAttributes::multiple_document_handling_supported)& multiple_document_handling_supported(
        const ::blink::mojom::blink::WebPrinterAttributesPtr& input)
    {
        return input->multiple_document_handling_supported;
    }

    static decltype(::blink::mojom::blink::WebPrinterAttributes::orientation_requested_default) orientation_requested_default(
        const ::blink::mojom::blink::WebPrinterAttributesPtr& input)
    {
        return input->orientation_requested_default;
    }

    static const decltype(::blink::mojom::blink::WebPrinterAttributes::orientation_requested_supported)& orientation_requested_supported(
        const ::blink::mojom::blink::WebPrinterAttributesPtr& input)
    {
        return input->orientation_requested_supported;
    }

    static const decltype(::blink::mojom::blink::WebPrinterAttributes::printer_resolution_default)& printer_resolution_default(
        const ::blink::mojom::blink::WebPrinterAttributesPtr& input)
    {
        return input->printer_resolution_default;
    }

    static const decltype(::blink::mojom::blink::WebPrinterAttributes::printer_resolution_supported)& printer_resolution_supported(
        const ::blink::mojom::blink::WebPrinterAttributesPtr& input)
    {
        return input->printer_resolution_supported;
    }

    static decltype(::blink::mojom::blink::WebPrinterAttributes::print_color_mode_default) print_color_mode_default(
        const ::blink::mojom::blink::WebPrinterAttributesPtr& input)
    {
        return input->print_color_mode_default;
    }

    static const decltype(::blink::mojom::blink::WebPrinterAttributes::print_color_mode_supported)& print_color_mode_supported(
        const ::blink::mojom::blink::WebPrinterAttributesPtr& input)
    {
        return input->print_color_mode_supported;
    }

    static decltype(::blink::mojom::blink::WebPrinterAttributes::printer_state) printer_state(const ::blink::mojom::blink::WebPrinterAttributesPtr& input)
    {
        return input->printer_state;
    }

    static const decltype(::blink::mojom::blink::WebPrinterAttributes::printer_state_message)& printer_state_message(
        const ::blink::mojom::blink::WebPrinterAttributesPtr& input)
    {
        return input->printer_state_message;
    }

    static const decltype(::blink::mojom::blink::WebPrinterAttributes::printer_state_reasons)& printer_state_reasons(
        const ::blink::mojom::blink::WebPrinterAttributesPtr& input)
    {
        return input->printer_state_reasons;
    }

    static decltype(::blink::mojom::blink::WebPrinterAttributes::sides_default) sides_default(const ::blink::mojom::blink::WebPrinterAttributesPtr& input)
    {
        return input->sides_default;
    }

    static const decltype(::blink::mojom::blink::WebPrinterAttributes::sides_supported)& sides_supported(
        const ::blink::mojom::blink::WebPrinterAttributesPtr& input)
    {
        return input->sides_supported;
    }

    static bool Read(::blink::mojom::blink::WebPrinterAttributes::DataView input, ::blink::mojom::blink::WebPrinterAttributesPtr* output);
};

template <>
struct PLATFORM_EXPORT
    StructTraits<::blink::mojom::blink::WebPrintingMediaCollectionRequested::DataView, ::blink::mojom::blink::WebPrintingMediaCollectionRequestedPtr> {
    static bool IsNull(const ::blink::mojom::blink::WebPrintingMediaCollectionRequestedPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::blink::WebPrintingMediaCollectionRequestedPtr* output)
    {
        output->reset();
    }

    static const decltype(::blink::mojom::blink::WebPrintingMediaCollectionRequested::media_size)& media_size(
        const ::blink::mojom::blink::WebPrintingMediaCollectionRequestedPtr& input)
    {
        return input->media_size;
    }

    static bool Read(
        ::blink::mojom::blink::WebPrintingMediaCollectionRequested::DataView input, ::blink::mojom::blink::WebPrintingMediaCollectionRequestedPtr* output);
};

template <>
struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::WebPrintJobTemplateAttributes::DataView, ::blink::mojom::blink::WebPrintJobTemplateAttributesPtr> {
    static bool IsNull(const ::blink::mojom::blink::WebPrintJobTemplateAttributesPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::blink::WebPrintJobTemplateAttributesPtr* output)
    {
        output->reset();
    }

    static const decltype(::blink::mojom::blink::WebPrintJobTemplateAttributes::job_name)& job_name(
        const ::blink::mojom::blink::WebPrintJobTemplateAttributesPtr& input)
    {
        return input->job_name;
    }

    static decltype(::blink::mojom::blink::WebPrintJobTemplateAttributes::copies) copies(const ::blink::mojom::blink::WebPrintJobTemplateAttributesPtr& input)
    {
        return input->copies;
    }

    static const decltype(::blink::mojom::blink::WebPrintJobTemplateAttributes::media_col)& media_col(
        const ::blink::mojom::blink::WebPrintJobTemplateAttributesPtr& input)
    {
        return input->media_col;
    }

    static const decltype(::blink::mojom::blink::WebPrintJobTemplateAttributes::media_source)& media_source(
        const ::blink::mojom::blink::WebPrintJobTemplateAttributesPtr& input)
    {
        return input->media_source;
    }

    static decltype(::blink::mojom::blink::WebPrintJobTemplateAttributes::multiple_document_handling) multiple_document_handling(
        const ::blink::mojom::blink::WebPrintJobTemplateAttributesPtr& input)
    {
        return input->multiple_document_handling;
    }

    static decltype(::blink::mojom::blink::WebPrintJobTemplateAttributes::orientation_requested) orientation_requested(
        const ::blink::mojom::blink::WebPrintJobTemplateAttributesPtr& input)
    {
        return input->orientation_requested;
    }

    static const decltype(::blink::mojom::blink::WebPrintJobTemplateAttributes::printer_resolution)& printer_resolution(
        const ::blink::mojom::blink::WebPrintJobTemplateAttributesPtr& input)
    {
        return input->printer_resolution;
    }

    static decltype(::blink::mojom::blink::WebPrintJobTemplateAttributes::print_color_mode) print_color_mode(
        const ::blink::mojom::blink::WebPrintJobTemplateAttributesPtr& input)
    {
        return input->print_color_mode;
    }

    static decltype(::blink::mojom::blink::WebPrintJobTemplateAttributes::sides) sides(const ::blink::mojom::blink::WebPrintJobTemplateAttributesPtr& input)
    {
        return input->sides;
    }

    static bool Read(::blink::mojom::blink::WebPrintJobTemplateAttributes::DataView input, ::blink::mojom::blink::WebPrintJobTemplateAttributesPtr* output);
};

template <> struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::WebPrintJobUpdate::DataView, ::blink::mojom::blink::WebPrintJobUpdatePtr> {
    static bool IsNull(const ::blink::mojom::blink::WebPrintJobUpdatePtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::blink::WebPrintJobUpdatePtr* output)
    {
        output->reset();
    }

    static decltype(::blink::mojom::blink::WebPrintJobUpdate::state) state(const ::blink::mojom::blink::WebPrintJobUpdatePtr& input)
    {
        return input->state;
    }

    static decltype(::blink::mojom::blink::WebPrintJobUpdate::pages_printed) pages_printed(const ::blink::mojom::blink::WebPrintJobUpdatePtr& input)
    {
        return input->pages_printed;
    }

    static bool Read(::blink::mojom::blink::WebPrintJobUpdate::DataView input, ::blink::mojom::blink::WebPrintJobUpdatePtr* output);
};

template <> struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::WebPrintJobInfo::DataView, ::blink::mojom::blink::WebPrintJobInfoPtr> {
    static bool IsNull(const ::blink::mojom::blink::WebPrintJobInfoPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::blink::WebPrintJobInfoPtr* output)
    {
        output->reset();
    }

    static const decltype(::blink::mojom::blink::WebPrintJobInfo::job_name)& job_name(const ::blink::mojom::blink::WebPrintJobInfoPtr& input)
    {
        return input->job_name;
    }

    static decltype(::blink::mojom::blink::WebPrintJobInfo::job_pages) job_pages(const ::blink::mojom::blink::WebPrintJobInfoPtr& input)
    {
        return input->job_pages;
    }

    static decltype(::blink::mojom::blink::WebPrintJobInfo::observer)& observer(::blink::mojom::blink::WebPrintJobInfoPtr& input)
    {
        return input->observer;
    }

    static decltype(::blink::mojom::blink::WebPrintJobInfo::controller)& controller(::blink::mojom::blink::WebPrintJobInfoPtr& input)
    {
        return input->controller;
    }

    static bool Read(::blink::mojom::blink::WebPrintJobInfo::DataView input, ::blink::mojom::blink::WebPrintJobInfoPtr* output);
};

template <>
struct PLATFORM_EXPORT UnionTraits<::blink::mojom::blink::WebPrintingMediaSizeDimension::DataView, ::blink::mojom::blink::WebPrintingMediaSizeDimensionPtr> {
    static bool IsNull(const ::blink::mojom::blink::WebPrintingMediaSizeDimensionPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::blink::WebPrintingMediaSizeDimensionPtr* output)
    {
        output->reset();
    }

    static ::blink::mojom::blink::WebPrintingMediaSizeDimension::Tag GetTag(const ::blink::mojom::blink::WebPrintingMediaSizeDimensionPtr& input)
    {
        return input->which();
    }

    static const ::blink::mojom::blink::WebPrintingRangePtr& range(const ::blink::mojom::blink::WebPrintingMediaSizeDimensionPtr& input)
    {
        return input->get_range();
    }

    static uint32_t value(const ::blink::mojom::blink::WebPrintingMediaSizeDimensionPtr& input)
    {
        return input->get_value();
    }

    static bool Read(::blink::mojom::blink::WebPrintingMediaSizeDimension::DataView input, ::blink::mojom::blink::WebPrintingMediaSizeDimensionPtr* output);
};

template <> struct PLATFORM_EXPORT UnionTraits<::blink::mojom::blink::GetPrintersResult::DataView, ::blink::mojom::blink::GetPrintersResultPtr> {
    static bool IsNull(const ::blink::mojom::blink::GetPrintersResultPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::blink::GetPrintersResultPtr* output)
    {
        output->reset();
    }

    static ::blink::mojom::blink::GetPrintersResult::Tag GetTag(const ::blink::mojom::blink::GetPrintersResultPtr& input)
    {
        return input->which();
    }

    static WTF::Vector<::blink::mojom::blink::WebPrinterInfoPtr>& printers(::blink::mojom::blink::GetPrintersResultPtr& input)
    {
        return input->get_printers();
    }

    static ::blink::mojom::blink::GetPrintersError error(const ::blink::mojom::blink::GetPrintersResultPtr& input)
    {
        return input->get_error();
    }

    static bool Read(::blink::mojom::blink::GetPrintersResult::DataView input, ::blink::mojom::blink::GetPrintersResultPtr* output);
};

template <> struct PLATFORM_EXPORT UnionTraits<::blink::mojom::blink::WebPrinterFetchResult::DataView, ::blink::mojom::blink::WebPrinterFetchResultPtr> {
    static bool IsNull(const ::blink::mojom::blink::WebPrinterFetchResultPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::blink::WebPrinterFetchResultPtr* output)
    {
        output->reset();
    }

    static ::blink::mojom::blink::WebPrinterFetchResult::Tag GetTag(const ::blink::mojom::blink::WebPrinterFetchResultPtr& input)
    {
        return input->which();
    }

    static const ::blink::mojom::blink::WebPrinterAttributesPtr& printer_attributes(const ::blink::mojom::blink::WebPrinterFetchResultPtr& input)
    {
        return input->get_printer_attributes();
    }

    static ::blink::mojom::blink::WebPrinterFetchError error(const ::blink::mojom::blink::WebPrinterFetchResultPtr& input)
    {
        return input->get_error();
    }

    static bool Read(::blink::mojom::blink::WebPrinterFetchResult::DataView input, ::blink::mojom::blink::WebPrinterFetchResultPtr* output);
};

template <> struct PLATFORM_EXPORT UnionTraits<::blink::mojom::blink::WebPrintResult::DataView, ::blink::mojom::blink::WebPrintResultPtr> {
    static bool IsNull(const ::blink::mojom::blink::WebPrintResultPtr& input)
    {
        return !input;
    }
    static void SetToNull(::blink::mojom::blink::WebPrintResultPtr* output)
    {
        output->reset();
    }

    static ::blink::mojom::blink::WebPrintResult::Tag GetTag(const ::blink::mojom::blink::WebPrintResultPtr& input)
    {
        return input->which();
    }

    static ::blink::mojom::blink::WebPrintJobInfoPtr& print_job_info(::blink::mojom::blink::WebPrintResultPtr& input)
    {
        return input->get_print_job_info();
    }

    static ::blink::mojom::blink::WebPrintError error(const ::blink::mojom::blink::WebPrintResultPtr& input)
    {
        return input->get_error();
    }

    static bool Read(::blink::mojom::blink::WebPrintResult::DataView input, ::blink::mojom::blink::WebPrintResultPtr* output);
};

} // namespace mojo

#endif // THIRD_PARTY_BLINK_PUBLIC_MOJOM_PRINTING_WEB_PRINTING_MOJOM_BLINK_H_
