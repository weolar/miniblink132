// third_party/blink/public/mojom/payments/payment_request.mojom-blink.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef THIRD_PARTY_BLINK_PUBLIC_MOJOM_PAYMENTS_PAYMENT_REQUEST_MOJOM_BLINK_H_
#define THIRD_PARTY_BLINK_PUBLIC_MOJOM_PAYMENTS_PAYMENT_REQUEST_MOJOM_BLINK_H_

#include <stdint.h>

#include <limits>
#include <optional>
#include <type_traits>
#include <utility>

#include "base/types/cxx23_to_underlying.h"
#include "mojo/public/cpp/bindings/clone_traits.h"
#include "mojo/public/cpp/bindings/equals_traits.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/struct_ptr.h"
#include "mojo/public/cpp/bindings/struct_traits.h"
#include "mojo/public/cpp/bindings/union_traits.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "third_party/blink/public/mojom/payments/payment_request.mojom-features.h" // IWYU pragma: export
#include "third_party/blink/public/mojom/payments/payment_request.mojom-shared.h" // IWYU pragma: export
#include "third_party/blink/public/mojom/payments/payment_request.mojom-blink-forward.h" // IWYU pragma: export
#include "components/payments/mojom/payment_request_data.mojom-blink.h"
#include "mojo/public/mojom/base/time.mojom-blink.h"
#include "third_party/blink/public/mojom/payments/payment_credential.mojom-blink-forward.h"
#include "url/mojom/origin.mojom-blink.h"
#include "url/mojom/url.mojom-blink.h"
#include "third_party/blink/public/mojom/webauthn/authenticator.mojom-blink.h"

#include "mojo/public/cpp/bindings/lib/wtf_clone_equals_util.h"
#include "mojo/public/cpp/bindings/lib/wtf_hash_util.h"
#include "third_party/blink/renderer/platform/wtf/hash_functions.h"
#include "third_party/blink/renderer/platform/wtf/text/wtf_string.h"

#include "mojo/public/cpp/bindings/lib/control_message_handler.h"
#include "mojo/public/cpp/bindings/lib/message_size_estimator.h"
#include "mojo/public/cpp/bindings/raw_ptr_impl_ref_traits.h"

#include "third_party/blink/renderer/platform/platform_export.h"
#if !BLINK_MOJO_IMPL && !INSIDE_BLINK
#error "File must only be imported inside blink"
#endif

namespace payments::mojom::blink {

class PaymentRequestClientProxy;

template <typename ImplRefTraits> class PaymentRequestClientStub;

class PaymentRequestClientRequestValidator;
class PaymentRequestClientResponseValidator;

class PLATFORM_EXPORT PaymentRequestClient : public PaymentRequestClientInterfaceBase {
public:
    using IPCStableHashFunction = uint32_t (*)();

    static const char Name_[];
    static IPCStableHashFunction MessageToMethodInfo_(mojo::Message& message);
    static const char* MessageToMethodName_(mojo::Message& message);
    static constexpr uint32_t Version_ = 0;
    static constexpr bool PassesAssociatedKinds_ = false;
    static constexpr bool HasUninterruptableMethods_ = false;

    using Base_ = PaymentRequestClientInterfaceBase;
    using Proxy_ = PaymentRequestClientProxy;

    template <typename ImplRefTraits> using Stub_ = PaymentRequestClientStub<ImplRefTraits>;

    using RequestValidator_ = PaymentRequestClientRequestValidator;
    using ResponseValidator_ = PaymentRequestClientResponseValidator;
    enum MethodMinVersions : uint32_t {
        kOnPaymentMethodChangeMinVersion = 0,
        kOnShippingAddressChangeMinVersion = 0,
        kOnShippingOptionChangeMinVersion = 0,
        kOnPayerDetailChangeMinVersion = 0,
        kOnPaymentResponseMinVersion = 0,
        kOnErrorMinVersion = 0,
        kOnCompleteMinVersion = 0,
        kOnAbortMinVersion = 0,
        kOnCanMakePaymentMinVersion = 0,
        kOnHasEnrolledInstrumentMinVersion = 0,
        kWarnNoFaviconMinVersion = 0,
        kAllowConnectToSourceMinVersion = 0,
    };

// crbug.com/1340245 - this causes binary size bloat on Fuchsia, and we're OK
// with not having this data in traces there.
#if !BUILDFLAG(IS_FUCHSIA)
    struct OnPaymentMethodChange_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct OnShippingAddressChange_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct OnShippingOptionChange_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct OnPayerDetailChange_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct OnPaymentResponse_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct OnError_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct OnComplete_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct OnAbort_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct OnCanMakePayment_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct OnHasEnrolledInstrument_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct WarnNoFavicon_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct AllowConnectToSource_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
#endif // !BUILDFLAG(IS_FUCHSIA)
    virtual ~PaymentRequestClient() = default;

    virtual void OnPaymentMethodChange(const WTF::String& method_name, const WTF::String& stringified_details) = 0;

    virtual void OnShippingAddressChange(::payments::mojom::blink::PaymentAddressPtr address) = 0;

    virtual void OnShippingOptionChange(const WTF::String& shipping_option_id) = 0;

    virtual void OnPayerDetailChange(PayerDetailPtr detail) = 0;

    virtual void OnPaymentResponse(PaymentResponsePtr response) = 0;

    virtual void OnError(PaymentErrorReason error, const WTF::String& error_message) = 0;

    virtual void OnComplete() = 0;

    virtual void OnAbort(bool aborted_successfully) = 0;

    virtual void OnCanMakePayment(CanMakePaymentQueryResult result) = 0;

    virtual void OnHasEnrolledInstrument(HasEnrolledInstrumentQueryResult result) = 0;

    virtual void WarnNoFavicon() = 0;

    using AllowConnectToSourceCallback = base::OnceCallback<void(bool)>;

    virtual void AllowConnectToSource(
        const ::blink::KURL& url, const ::blink::KURL& url_before_redirects, bool did_follow_redirect, AllowConnectToSourceCallback callback)
        = 0;
};

class PaymentRequestProxy;

template <typename ImplRefTraits> class PaymentRequestStub;

class PaymentRequestRequestValidator;

class PLATFORM_EXPORT PaymentRequest : public PaymentRequestInterfaceBase {
public:
    using IPCStableHashFunction = uint32_t (*)();

    static const char Name_[];
    static IPCStableHashFunction MessageToMethodInfo_(mojo::Message& message);
    static const char* MessageToMethodName_(mojo::Message& message);
    static constexpr uint32_t Version_ = 0;
    static constexpr bool PassesAssociatedKinds_ = false;
    static constexpr bool HasUninterruptableMethods_ = false;

    using Base_ = PaymentRequestInterfaceBase;
    using Proxy_ = PaymentRequestProxy;

    template <typename ImplRefTraits> using Stub_ = PaymentRequestStub<ImplRefTraits>;

    using RequestValidator_ = PaymentRequestRequestValidator;
    using ResponseValidator_ = mojo::PassThroughFilter;
    enum MethodMinVersions : uint32_t {
        kInitMinVersion = 0,
        kShowMinVersion = 0,
        kUpdateWithMinVersion = 0,
        kOnPaymentDetailsNotUpdatedMinVersion = 0,
        kAbortMinVersion = 0,
        kCompleteMinVersion = 0,
        kRetryMinVersion = 0,
        kCanMakePaymentMinVersion = 0,
        kHasEnrolledInstrumentMinVersion = 0,
    };

// crbug.com/1340245 - this causes binary size bloat on Fuchsia, and we're OK
// with not having this data in traces there.
#if !BUILDFLAG(IS_FUCHSIA)
    struct Init_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct Show_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct UpdateWith_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct OnPaymentDetailsNotUpdated_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct Abort_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct Complete_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct Retry_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct CanMakePayment_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct HasEnrolledInstrument_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
#endif // !BUILDFLAG(IS_FUCHSIA)
    virtual ~PaymentRequest() = default;

    virtual void Init(
        ::mojo::PendingRemote<PaymentRequestClient> client, WTF::Vector<PaymentMethodDataPtr> method_data, PaymentDetailsPtr details, PaymentOptionsPtr options)
        = 0;

    virtual void Show(bool wait_for_updated_details, bool had_user_activation) = 0;

    virtual void UpdateWith(PaymentDetailsPtr details) = 0;

    virtual void OnPaymentDetailsNotUpdated() = 0;

    virtual void Abort() = 0;

    virtual void Complete(PaymentComplete result) = 0;

    virtual void Retry(::payments::mojom::blink::PaymentValidationErrorsPtr errors) = 0;

    virtual void CanMakePayment() = 0;

    virtual void HasEnrolledInstrument() = 0;
};

//class PLATFORM_EXPORT PaymentRequestClientProxy : public PaymentRequestClient {
//public:
//    using InterfaceType = PaymentRequestClient;
//
//    explicit PaymentRequestClientProxy(mojo::MessageReceiverWithResponder* receiver);
//
//    void OnPaymentMethodChange(const WTF::String& method_name, const WTF::String& stringified_details) final;
//
//    void OnShippingAddressChange(::payments::mojom::blink::PaymentAddressPtr address) final;
//
//    void OnShippingOptionChange(const WTF::String& shipping_option_id) final;
//
//    void OnPayerDetailChange(PayerDetailPtr detail) final;
//
//    void OnPaymentResponse(PaymentResponsePtr response) final;
//
//    void OnError(PaymentErrorReason error, const WTF::String& error_message) final;
//
//    void OnComplete() final;
//
//    void OnAbort(bool aborted_successfully) final;
//
//    void OnCanMakePayment(CanMakePaymentQueryResult result) final;
//
//    void OnHasEnrolledInstrument(HasEnrolledInstrumentQueryResult result) final;
//
//    void WarnNoFavicon() final;
//
//    void AllowConnectToSource(
//        const ::blink::KURL& url, const ::blink::KURL& url_before_redirects, bool did_follow_redirect, AllowConnectToSourceCallback callback) final;
//
//private:
//    mojo::MessageReceiverWithResponder* receiver_;
//};

//class PLATFORM_EXPORT PaymentRequestProxy : public PaymentRequest {
//public:
//    using InterfaceType = PaymentRequest;
//
//    explicit PaymentRequestProxy(mojo::MessageReceiverWithResponder* receiver);
//
//    void Init(::mojo::PendingRemote<PaymentRequestClient> client, WTF::Vector<PaymentMethodDataPtr> method_data, PaymentDetailsPtr details,
//        PaymentOptionsPtr options) final;
//
//    void Show(bool wait_for_updated_details, bool had_user_activation) final;
//
//    void UpdateWith(PaymentDetailsPtr details) final;
//
//    void OnPaymentDetailsNotUpdated() final;
//
//    void Abort() final;
//
//    void Complete(PaymentComplete result) final;
//
//    void Retry(::payments::mojom::blink::PaymentValidationErrorsPtr errors) final;
//
//    void CanMakePayment() final;
//
//    void HasEnrolledInstrument() final;
//
//private:
//    mojo::MessageReceiverWithResponder* receiver_;
//};
//class PLATFORM_EXPORT PaymentRequestClientStubDispatch {
//public:
//    static bool Accept(PaymentRequestClient* impl, mojo::Message* message);
//    static bool AcceptWithResponder(PaymentRequestClient* impl, mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
//};

//template <typename ImplRefTraits = mojo::RawPtrImplRefTraits<PaymentRequestClient>>
//class PaymentRequestClientStub : public mojo::MessageReceiverWithResponderStatus {
//public:
//    using ImplPointerType = typename ImplRefTraits::PointerType;
//
//    PaymentRequestClientStub() = default;
//    ~PaymentRequestClientStub() override = default;
//
//    void set_sink(ImplPointerType sink)
//    {
//        sink_ = std::move(sink);
//    }
//    ImplPointerType& sink()
//    {
//        return sink_;
//    }
//
//    bool Accept(mojo::Message* message) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return PaymentRequestClientStubDispatch::Accept(ImplRefTraits::GetRawPointer(&sink_), message);
//    }
//
//    bool AcceptWithResponder(mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return PaymentRequestClientStubDispatch::AcceptWithResponder(ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
//    }
//
//private:
//    ImplPointerType sink_;
//};
//class PLATFORM_EXPORT PaymentRequestStubDispatch {
//public:
//    static bool Accept(PaymentRequest* impl, mojo::Message* message);
//    static bool AcceptWithResponder(PaymentRequest* impl, mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
//};

//template <typename ImplRefTraits = mojo::RawPtrImplRefTraits<PaymentRequest>> class PaymentRequestStub : public mojo::MessageReceiverWithResponderStatus {
//public:
//    using ImplPointerType = typename ImplRefTraits::PointerType;
//
//    PaymentRequestStub() = default;
//    ~PaymentRequestStub() override = default;
//
//    void set_sink(ImplPointerType sink)
//    {
//        sink_ = std::move(sink);
//    }
//    ImplPointerType& sink()
//    {
//        return sink_;
//    }
//
//    bool Accept(mojo::Message* message) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return PaymentRequestStubDispatch::Accept(ImplRefTraits::GetRawPointer(&sink_), message);
//    }
//
//    bool AcceptWithResponder(mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return PaymentRequestStubDispatch::AcceptWithResponder(ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
//    }
//
//private:
//    ImplPointerType sink_;
//};
//class PLATFORM_EXPORT PaymentRequestClientRequestValidator : public mojo::MessageReceiver {
//public:
//    bool Accept(mojo::Message* message) override;
//};
//class PLATFORM_EXPORT PaymentRequestRequestValidator : public mojo::MessageReceiver {
//public:
//    bool Accept(mojo::Message* message) override;
//};
//class PLATFORM_EXPORT PaymentRequestClientResponseValidator : public mojo::MessageReceiver {
//public:
//    bool Accept(mojo::Message* message) override;
//};

class PLATFORM_EXPORT PayerDetail {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<PayerDetail, T>::value>;
    using DataView = PayerDetailDataView;
    using Data_ = internal::PayerDetail_Data;

    template <typename... Args> static PayerDetailPtr New(Args&&... args)
    {
        return PayerDetailPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static PayerDetailPtr From(const U& u)
    {
        return mojo::TypeConverter<PayerDetailPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, PayerDetail>::Convert(*this);
    }

    PayerDetail()
    : email()
    , name()
    , phone()
{
}

    PayerDetail(const WTF::String& email_in, const WTF::String& name_in, const WTF::String& phone_in)
    : email(std::move(email_in))
    , name(std::move(name_in))
    , phone(std::move(phone_in)){
}

    ~PayerDetail() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = PayerDetailPtr> PayerDetailPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, PayerDetail::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, PayerDetail::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, PayerDetail::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<PayerDetail::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<PayerDetail::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(std::make_unique<internal::PayerDetail_UnserializedMessageContext<UserType, PayerDetail::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<PayerDetail::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return PayerDetail::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::PayerDetail_UnserializedMessageContext<UserType, PayerDetail::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<PayerDetail::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    WTF::String email;

    WTF::String name;

    WTF::String phone;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, PayerDetail::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, PayerDetail::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, PayerDetail::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, PayerDetail::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class PLATFORM_EXPORT PaymentResponse {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<PaymentResponse, T>::value>;
    using DataView = PaymentResponseDataView;
    using Data_ = internal::PaymentResponse_Data;

    template <typename... Args> static PaymentResponsePtr New(Args&&... args)
    {
        return PaymentResponsePtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static PaymentResponsePtr From(const U& u)
    {
        return mojo::TypeConverter<PaymentResponsePtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, PaymentResponse>::Convert(*this);
    }

    PaymentResponse()
    : method_name()
    , stringified_details()
    , shipping_address()
    , shipping_option()
    , payer()
    , get_assertion_authenticator_response()
{
}

    PaymentResponse(const WTF::String& method_name_in, const WTF::String& stringified_details_in,
    ::payments::mojom::blink::PaymentAddressPtr shipping_address_in, const WTF::String& shipping_option_in, PayerDetailPtr payer_in,
    ::blink::mojom::blink::GetAssertionAuthenticatorResponsePtr get_assertion_authenticator_response_in)
    : method_name(std::move(method_name_in))
    , stringified_details(std::move(stringified_details_in))
    , shipping_address(std::move(shipping_address_in))
    , shipping_option(std::move(shipping_option_in))
    , payer(std::move(payer_in))
    , get_assertion_authenticator_response(std::move(get_assertion_authenticator_response_in)){
}

    PaymentResponse(const PaymentResponse&) = delete;
    PaymentResponse& operator=(const PaymentResponse&) = delete;

    ~PaymentResponse() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = PaymentResponsePtr> PaymentResponsePtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, PaymentResponse::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, PaymentResponse::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, PaymentResponse::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<PaymentResponse::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<PaymentResponse::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::PaymentResponse_UnserializedMessageContext<UserType, PaymentResponse::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<PaymentResponse::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return PaymentResponse::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::PaymentResponse_UnserializedMessageContext<UserType, PaymentResponse::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<PaymentResponse::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    WTF::String method_name;

    WTF::String stringified_details;

    ::payments::mojom::blink::PaymentAddressPtr shipping_address;

    WTF::String shipping_option;

    PayerDetailPtr payer;

    ::blink::mojom::blink::GetAssertionAuthenticatorResponsePtr get_assertion_authenticator_response;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, PaymentResponse::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, PaymentResponse::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, PaymentResponse::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, PaymentResponse::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class PLATFORM_EXPORT PaymentItem {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<PaymentItem, T>::value>;
    using DataView = PaymentItemDataView;
    using Data_ = internal::PaymentItem_Data;

    template <typename... Args> static PaymentItemPtr New(Args&&... args)
    {
        return PaymentItemPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static PaymentItemPtr From(const U& u)
    {
        return mojo::TypeConverter<PaymentItemPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, PaymentItem>::Convert(*this);
    }

    PaymentItem()
    : label()
    , amount()
    , pending()
{
}

    PaymentItem(const WTF::String& label_in, ::payments::mojom::blink::PaymentCurrencyAmountPtr amount_in, bool pending_in)
    : label(std::move(label_in))
    , amount(std::move(amount_in))
    , pending(std::move(pending_in)){
}

    PaymentItem(const PaymentItem&) = delete;
    PaymentItem& operator=(const PaymentItem&) = delete;

    ~PaymentItem() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = PaymentItemPtr> PaymentItemPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, PaymentItem::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, PaymentItem::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, PaymentItem::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<PaymentItem::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<PaymentItem::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(std::make_unique<internal::PaymentItem_UnserializedMessageContext<UserType, PaymentItem::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<PaymentItem::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return PaymentItem::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::PaymentItem_UnserializedMessageContext<UserType, PaymentItem::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<PaymentItem::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    WTF::String label;

    ::payments::mojom::blink::PaymentCurrencyAmountPtr amount;

    bool pending;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, PaymentItem::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, PaymentItem::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, PaymentItem::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, PaymentItem::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class PLATFORM_EXPORT PaymentShippingOption {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<PaymentShippingOption, T>::value>;
    using DataView = PaymentShippingOptionDataView;
    using Data_ = internal::PaymentShippingOption_Data;

    template <typename... Args> static PaymentShippingOptionPtr New(Args&&... args)
    {
        return PaymentShippingOptionPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static PaymentShippingOptionPtr From(const U& u)
    {
        return mojo::TypeConverter<PaymentShippingOptionPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, PaymentShippingOption>::Convert(*this);
    }

    PaymentShippingOption()
    : id()
    , label()
    , amount()
    , selected()
{
}

    PaymentShippingOption(
    const WTF::String& id_in, const WTF::String& label_in, ::payments::mojom::blink::PaymentCurrencyAmountPtr amount_in, bool selected_in)
    : id(std::move(id_in))
    , label(std::move(label_in))
    , amount(std::move(amount_in))
    , selected(std::move(selected_in)){
}

    PaymentShippingOption(const PaymentShippingOption&) = delete;
    PaymentShippingOption& operator=(const PaymentShippingOption&) = delete;

    ~PaymentShippingOption() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = PaymentShippingOptionPtr> PaymentShippingOptionPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, PaymentShippingOption::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, PaymentShippingOption::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, PaymentShippingOption::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<PaymentShippingOption::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<PaymentShippingOption::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::PaymentShippingOption_UnserializedMessageContext<UserType, PaymentShippingOption::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<PaymentShippingOption::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return PaymentShippingOption::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::PaymentShippingOption_UnserializedMessageContext<UserType, PaymentShippingOption::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<PaymentShippingOption::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    WTF::String id;

    WTF::String label;

    ::payments::mojom::blink::PaymentCurrencyAmountPtr amount;

    bool selected;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, PaymentShippingOption::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, PaymentShippingOption::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, PaymentShippingOption::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, PaymentShippingOption::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class PLATFORM_EXPORT SecurePaymentConfirmationRequest {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<SecurePaymentConfirmationRequest, T>::value>;
    using DataView = SecurePaymentConfirmationRequestDataView;
    using Data_ = internal::SecurePaymentConfirmationRequest_Data;

    template <typename... Args> static SecurePaymentConfirmationRequestPtr New(Args&&... args)
    {
        return SecurePaymentConfirmationRequestPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static SecurePaymentConfirmationRequestPtr From(const U& u)
    {
        return mojo::TypeConverter<SecurePaymentConfirmationRequestPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, SecurePaymentConfirmationRequest>::Convert(*this);
    }

    SecurePaymentConfirmationRequest()
    : credential_ids()
    , challenge()
    , instrument()
    , timeout()
    , payee_origin()
    , payee_name()
    , rp_id()
    , extensions()
    , show_opt_out()
    , network_info()
    , issuer_info()
{
}

    SecurePaymentConfirmationRequest(WTF::Vector<WTF::Vector<uint8_t>> credential_ids_in, WTF::Vector<uint8_t> challenge_in,
    ::blink::mojom::blink::PaymentCredentialInstrumentPtr instrument_in, std::optional<::base::TimeDelta> timeout_in,
    const ::scoped_refptr<const ::blink::SecurityOrigin>& payee_origin_in, const WTF::String& payee_name_in, const WTF::String& rp_id_in,
    ::blink::mojom::blink::AuthenticationExtensionsClientInputsPtr extensions_in, bool show_opt_out_in, NetworkOrIssuerInformationPtr network_info_in,
    NetworkOrIssuerInformationPtr issuer_info_in)
    : credential_ids(std::move(credential_ids_in))
    , challenge(std::move(challenge_in))
    , instrument(std::move(instrument_in))
    , timeout(std::move(timeout_in))
    , payee_origin(std::move(payee_origin_in))
    , payee_name(std::move(payee_name_in))
    , rp_id(std::move(rp_id_in))
    , extensions(std::move(extensions_in))
    , show_opt_out(std::move(show_opt_out_in))
    , network_info(std::move(network_info_in))
    , issuer_info(std::move(issuer_info_in)){
}

    SecurePaymentConfirmationRequest(const SecurePaymentConfirmationRequest&) = delete;
    SecurePaymentConfirmationRequest& operator=(const SecurePaymentConfirmationRequest&) = delete;

    ~SecurePaymentConfirmationRequest() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = SecurePaymentConfirmationRequestPtr> SecurePaymentConfirmationRequestPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, SecurePaymentConfirmationRequest::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, SecurePaymentConfirmationRequest::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, SecurePaymentConfirmationRequest::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<SecurePaymentConfirmationRequest::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<SecurePaymentConfirmationRequest::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::SecurePaymentConfirmationRequest_UnserializedMessageContext<UserType, SecurePaymentConfirmationRequest::DataView>>(
                0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<SecurePaymentConfirmationRequest::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return SecurePaymentConfirmationRequest::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<
            internal::SecurePaymentConfirmationRequest_UnserializedMessageContext<UserType, SecurePaymentConfirmationRequest::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<SecurePaymentConfirmationRequest::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    WTF::Vector<WTF::Vector<uint8_t>> credential_ids;

    WTF::Vector<uint8_t> challenge;

    ::blink::mojom::blink::PaymentCredentialInstrumentPtr instrument;

    std::optional<::base::TimeDelta> timeout;

    ::scoped_refptr<const ::blink::SecurityOrigin> payee_origin;

    WTF::String payee_name;

    WTF::String rp_id;

    ::blink::mojom::blink::AuthenticationExtensionsClientInputsPtr extensions;

    bool show_opt_out;

    NetworkOrIssuerInformationPtr network_info;

    NetworkOrIssuerInformationPtr issuer_info;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, SecurePaymentConfirmationRequest::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, SecurePaymentConfirmationRequest::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, SecurePaymentConfirmationRequest::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, SecurePaymentConfirmationRequest::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class PLATFORM_EXPORT NetworkOrIssuerInformation {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<NetworkOrIssuerInformation, T>::value>;
    using DataView = NetworkOrIssuerInformationDataView;
    using Data_ = internal::NetworkOrIssuerInformation_Data;

    template <typename... Args> static NetworkOrIssuerInformationPtr New(Args&&... args)
    {
        return NetworkOrIssuerInformationPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static NetworkOrIssuerInformationPtr From(const U& u)
    {
        return mojo::TypeConverter<NetworkOrIssuerInformationPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, NetworkOrIssuerInformation>::Convert(*this);
    }

    NetworkOrIssuerInformation()
    : name()
    , icon()
{
}

    NetworkOrIssuerInformation(const WTF::String& name_in, const ::blink::KURL& icon_in)
    : name(std::move(name_in))
    , icon(std::move(icon_in)){
}

    ~NetworkOrIssuerInformation() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = NetworkOrIssuerInformationPtr> NetworkOrIssuerInformationPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, NetworkOrIssuerInformation::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, NetworkOrIssuerInformation::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, NetworkOrIssuerInformation::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<NetworkOrIssuerInformation::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<NetworkOrIssuerInformation::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(std::make_unique<internal::NetworkOrIssuerInformation_UnserializedMessageContext<UserType, NetworkOrIssuerInformation::DataView>>(
                                 0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<NetworkOrIssuerInformation::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return NetworkOrIssuerInformation::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context
            = input.TakeUnserializedContext<internal::NetworkOrIssuerInformation_UnserializedMessageContext<UserType, NetworkOrIssuerInformation::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<NetworkOrIssuerInformation::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    WTF::String name;

    ::blink::KURL icon;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, NetworkOrIssuerInformation::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, NetworkOrIssuerInformation::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, NetworkOrIssuerInformation::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, NetworkOrIssuerInformation::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class PLATFORM_EXPORT PaymentMethodData {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<PaymentMethodData, T>::value>;
    using DataView = PaymentMethodDataDataView;
    using Data_ = internal::PaymentMethodData_Data;

    template <typename... Args> static PaymentMethodDataPtr New(Args&&... args)
    {
        return PaymentMethodDataPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static PaymentMethodDataPtr From(const U& u)
    {
        return mojo::TypeConverter<PaymentMethodDataPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, PaymentMethodData>::Convert(*this);
    }

    PaymentMethodData()
    : supported_method()
    , stringified_data()
    , environment()
    , min_google_play_services_version()
    , api_version()
    , supported_networks()
    , secure_payment_confirmation()
{
}

    PaymentMethodData(const WTF::String& supported_method_in, const WTF::String& stringified_data_in, AndroidPayEnvironment environment_in,
    int32_t min_google_play_services_version_in, int32_t api_version_in, WTF::Vector<BasicCardNetwork> supported_networks_in,
    SecurePaymentConfirmationRequestPtr secure_payment_confirmation_in)
    : supported_method(std::move(supported_method_in))
    , stringified_data(std::move(stringified_data_in))
    , environment(std::move(environment_in))
    , min_google_play_services_version(std::move(min_google_play_services_version_in))
    , api_version(std::move(api_version_in))
    , supported_networks(std::move(supported_networks_in))
    , secure_payment_confirmation(std::move(secure_payment_confirmation_in)){
}

    PaymentMethodData(const PaymentMethodData&) = delete;
    PaymentMethodData& operator=(const PaymentMethodData&) = delete;

    ~PaymentMethodData() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = PaymentMethodDataPtr> PaymentMethodDataPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, PaymentMethodData::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, PaymentMethodData::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, PaymentMethodData::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<PaymentMethodData::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<PaymentMethodData::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::PaymentMethodData_UnserializedMessageContext<UserType, PaymentMethodData::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<PaymentMethodData::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return PaymentMethodData::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::PaymentMethodData_UnserializedMessageContext<UserType, PaymentMethodData::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<PaymentMethodData::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    WTF::String supported_method;

    WTF::String stringified_data;

    AndroidPayEnvironment environment;

    int32_t min_google_play_services_version;

    int32_t api_version;

    WTF::Vector<BasicCardNetwork> supported_networks;

    SecurePaymentConfirmationRequestPtr secure_payment_confirmation;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, PaymentMethodData::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, PaymentMethodData::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, PaymentMethodData::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, PaymentMethodData::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class PLATFORM_EXPORT PaymentDetailsModifier {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<PaymentDetailsModifier, T>::value>;
    using DataView = PaymentDetailsModifierDataView;
    using Data_ = internal::PaymentDetailsModifier_Data;

    template <typename... Args> static PaymentDetailsModifierPtr New(Args&&... args)
    {
        return PaymentDetailsModifierPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static PaymentDetailsModifierPtr From(const U& u)
    {
        return mojo::TypeConverter<PaymentDetailsModifierPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, PaymentDetailsModifier>::Convert(*this);
    }

    PaymentDetailsModifier()
    : total()
    , additional_display_items()
    , method_data()
{
}

    PaymentDetailsModifier(
    PaymentItemPtr total_in, WTF::Vector<PaymentItemPtr> additional_display_items_in, PaymentMethodDataPtr method_data_in)
    : total(std::move(total_in))
    , additional_display_items(std::move(additional_display_items_in))
    , method_data(std::move(method_data_in)){
}

    PaymentDetailsModifier(const PaymentDetailsModifier&) = delete;
    PaymentDetailsModifier& operator=(const PaymentDetailsModifier&) = delete;

    ~PaymentDetailsModifier() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = PaymentDetailsModifierPtr> PaymentDetailsModifierPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, PaymentDetailsModifier::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, PaymentDetailsModifier::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, PaymentDetailsModifier::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<PaymentDetailsModifier::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<PaymentDetailsModifier::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::PaymentDetailsModifier_UnserializedMessageContext<UserType, PaymentDetailsModifier::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<PaymentDetailsModifier::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return PaymentDetailsModifier::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::PaymentDetailsModifier_UnserializedMessageContext<UserType, PaymentDetailsModifier::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<PaymentDetailsModifier::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    PaymentItemPtr total;

    WTF::Vector<PaymentItemPtr> additional_display_items;

    PaymentMethodDataPtr method_data;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, PaymentDetailsModifier::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, PaymentDetailsModifier::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, PaymentDetailsModifier::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, PaymentDetailsModifier::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class PLATFORM_EXPORT PaymentDetails {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<PaymentDetails, T>::value>;
    using DataView = PaymentDetailsDataView;
    using Data_ = internal::PaymentDetails_Data;

    template <typename... Args> static PaymentDetailsPtr New(Args&&... args)
    {
        return PaymentDetailsPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static PaymentDetailsPtr From(const U& u)
    {
        return mojo::TypeConverter<PaymentDetailsPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, PaymentDetails>::Convert(*this);
    }

    PaymentDetails()
    : total()
    , display_items()
    , shipping_options()
    , modifiers()
    , error("")
    , shipping_address_errors()
    , id()
    , stringified_payment_method_errors()
{
}

    PaymentDetails(PaymentItemPtr total_in, std::optional<WTF::Vector<PaymentItemPtr>> display_items_in,
    std::optional<WTF::Vector<PaymentShippingOptionPtr>> shipping_options_in, std::optional<WTF::Vector<PaymentDetailsModifierPtr>> modifiers_in,
    const WTF::String& error_in, ::payments::mojom::blink::AddressErrorsPtr shipping_address_errors_in, const WTF::String& id_in,
    const WTF::String& stringified_payment_method_errors_in)
    : total(std::move(total_in))
    , display_items(std::move(display_items_in))
    , shipping_options(std::move(shipping_options_in))
    , modifiers(std::move(modifiers_in))
    , error(std::move(error_in))
    , shipping_address_errors(std::move(shipping_address_errors_in))
    , id(std::move(id_in))
    , stringified_payment_method_errors(std::move(stringified_payment_method_errors_in)){
}

    PaymentDetails(const PaymentDetails&) = delete;
    PaymentDetails& operator=(const PaymentDetails&) = delete;

    ~PaymentDetails() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = PaymentDetailsPtr> PaymentDetailsPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, PaymentDetails::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, PaymentDetails::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, PaymentDetails::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<PaymentDetails::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<PaymentDetails::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(std::make_unique<internal::PaymentDetails_UnserializedMessageContext<UserType, PaymentDetails::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<PaymentDetails::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return PaymentDetails::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::PaymentDetails_UnserializedMessageContext<UserType, PaymentDetails::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<PaymentDetails::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    PaymentItemPtr total;

    std::optional<WTF::Vector<PaymentItemPtr>> display_items;

    std::optional<WTF::Vector<PaymentShippingOptionPtr>> shipping_options;

    std::optional<WTF::Vector<PaymentDetailsModifierPtr>> modifiers;

    WTF::String error;

    ::payments::mojom::blink::AddressErrorsPtr shipping_address_errors;

    WTF::String id;

    WTF::String stringified_payment_method_errors;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, PaymentDetails::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, PaymentDetails::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, PaymentDetails::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, PaymentDetails::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class PLATFORM_EXPORT PaymentOptions {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<PaymentOptions, T>::value>;
    using DataView = PaymentOptionsDataView;
    using Data_ = internal::PaymentOptions_Data;

    template <typename... Args> static PaymentOptionsPtr New(Args&&... args)
    {
        return PaymentOptionsPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static PaymentOptionsPtr From(const U& u)
    {
        return mojo::TypeConverter<PaymentOptionsPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, PaymentOptions>::Convert(*this);
    }

    PaymentOptions()
    : request_payer_name()
    , request_payer_email()
    , request_payer_phone()
    , request_shipping()
    , shipping_type()
{
}

    PaymentOptions(
    bool request_payer_name_in, bool request_payer_email_in, bool request_payer_phone_in, bool request_shipping_in, PaymentShippingType shipping_type_in)
    : request_payer_name(std::move(request_payer_name_in))
    , request_payer_email(std::move(request_payer_email_in))
    , request_payer_phone(std::move(request_payer_phone_in))
    , request_shipping(std::move(request_shipping_in))
    , shipping_type(std::move(shipping_type_in)){
}

    ~PaymentOptions() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = PaymentOptionsPtr> PaymentOptionsPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, PaymentOptions::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, PaymentOptions::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, PaymentOptions::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<PaymentOptions::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<PaymentOptions::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(std::make_unique<internal::PaymentOptions_UnserializedMessageContext<UserType, PaymentOptions::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<PaymentOptions::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return PaymentOptions::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::PaymentOptions_UnserializedMessageContext<UserType, PaymentOptions::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<PaymentOptions::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    bool request_payer_name;

    bool request_payer_email;

    bool request_payer_phone;

    bool request_shipping;

    PaymentShippingType shipping_type;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, PaymentOptions::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, PaymentOptions::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, PaymentOptions::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, PaymentOptions::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

template <typename StructPtrType> PaymentResponsePtr PaymentResponse::Clone() const
{
    return New(mojo::Clone(method_name), mojo::Clone(stringified_details), mojo::Clone(shipping_address), mojo::Clone(shipping_option), mojo::Clone(payer),
        mojo::Clone(get_assertion_authenticator_response));
}

template <typename T, PaymentResponse::EnableIfSame<T>*> bool PaymentResponse::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->method_name, other_struct.method_name))
        return false;
    if (!mojo::Equals(this->stringified_details, other_struct.stringified_details))
        return false;
    if (!mojo::Equals(this->shipping_address, other_struct.shipping_address))
        return false;
    if (!mojo::Equals(this->shipping_option, other_struct.shipping_option))
        return false;
    if (!mojo::Equals(this->payer, other_struct.payer))
        return false;
    if (!mojo::Equals(this->get_assertion_authenticator_response, other_struct.get_assertion_authenticator_response))
        return false;
    return true;
}

template <typename T, PaymentResponse::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.method_name < rhs.method_name)
        return true;
    if (rhs.method_name < lhs.method_name)
        return false;
    if (lhs.stringified_details < rhs.stringified_details)
        return true;
    if (rhs.stringified_details < lhs.stringified_details)
        return false;
    if (lhs.shipping_address < rhs.shipping_address)
        return true;
    if (rhs.shipping_address < lhs.shipping_address)
        return false;
    if (lhs.shipping_option < rhs.shipping_option)
        return true;
    if (rhs.shipping_option < lhs.shipping_option)
        return false;
    if (lhs.payer < rhs.payer)
        return true;
    if (rhs.payer < lhs.payer)
        return false;
    if (lhs.get_assertion_authenticator_response < rhs.get_assertion_authenticator_response)
        return true;
    if (rhs.get_assertion_authenticator_response < lhs.get_assertion_authenticator_response)
        return false;
    return false;
}
template <typename StructPtrType> PayerDetailPtr PayerDetail::Clone() const
{
    return New(mojo::Clone(email), mojo::Clone(name), mojo::Clone(phone));
}

template <typename T, PayerDetail::EnableIfSame<T>*> bool PayerDetail::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->email, other_struct.email))
        return false;
    if (!mojo::Equals(this->name, other_struct.name))
        return false;
    if (!mojo::Equals(this->phone, other_struct.phone))
        return false;
    return true;
}

template <typename T, PayerDetail::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.email < rhs.email)
        return true;
    if (rhs.email < lhs.email)
        return false;
    if (lhs.name < rhs.name)
        return true;
    if (rhs.name < lhs.name)
        return false;
    if (lhs.phone < rhs.phone)
        return true;
    if (rhs.phone < lhs.phone)
        return false;
    return false;
}
template <typename StructPtrType> PaymentItemPtr PaymentItem::Clone() const
{
    return New(mojo::Clone(label), mojo::Clone(amount), mojo::Clone(pending));
}

template <typename T, PaymentItem::EnableIfSame<T>*> bool PaymentItem::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->label, other_struct.label))
        return false;
    if (!mojo::Equals(this->amount, other_struct.amount))
        return false;
    if (!mojo::Equals(this->pending, other_struct.pending))
        return false;
    return true;
}

template <typename T, PaymentItem::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.label < rhs.label)
        return true;
    if (rhs.label < lhs.label)
        return false;
    if (lhs.amount < rhs.amount)
        return true;
    if (rhs.amount < lhs.amount)
        return false;
    if (lhs.pending < rhs.pending)
        return true;
    if (rhs.pending < lhs.pending)
        return false;
    return false;
}
template <typename StructPtrType> PaymentShippingOptionPtr PaymentShippingOption::Clone() const
{
    return New(mojo::Clone(id), mojo::Clone(label), mojo::Clone(amount), mojo::Clone(selected));
}

template <typename T, PaymentShippingOption::EnableIfSame<T>*> bool PaymentShippingOption::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->id, other_struct.id))
        return false;
    if (!mojo::Equals(this->label, other_struct.label))
        return false;
    if (!mojo::Equals(this->amount, other_struct.amount))
        return false;
    if (!mojo::Equals(this->selected, other_struct.selected))
        return false;
    return true;
}

template <typename T, PaymentShippingOption::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.id < rhs.id)
        return true;
    if (rhs.id < lhs.id)
        return false;
    if (lhs.label < rhs.label)
        return true;
    if (rhs.label < lhs.label)
        return false;
    if (lhs.amount < rhs.amount)
        return true;
    if (rhs.amount < lhs.amount)
        return false;
    if (lhs.selected < rhs.selected)
        return true;
    if (rhs.selected < lhs.selected)
        return false;
    return false;
}
template <typename StructPtrType> SecurePaymentConfirmationRequestPtr SecurePaymentConfirmationRequest::Clone() const
{
    return New(mojo::Clone(credential_ids), mojo::Clone(challenge), mojo::Clone(instrument), mojo::Clone(timeout), mojo::Clone(payee_origin),
        mojo::Clone(payee_name), mojo::Clone(rp_id), mojo::Clone(extensions), mojo::Clone(show_opt_out), mojo::Clone(network_info), mojo::Clone(issuer_info));
}

template <typename T, SecurePaymentConfirmationRequest::EnableIfSame<T>*> bool SecurePaymentConfirmationRequest::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->credential_ids, other_struct.credential_ids))
        return false;
    if (!mojo::Equals(this->challenge, other_struct.challenge))
        return false;
    if (!mojo::Equals(this->instrument, other_struct.instrument))
        return false;
    if (!mojo::Equals(this->timeout, other_struct.timeout))
        return false;
    if (!mojo::Equals(this->payee_origin, other_struct.payee_origin))
        return false;
    if (!mojo::Equals(this->payee_name, other_struct.payee_name))
        return false;
    if (!mojo::Equals(this->rp_id, other_struct.rp_id))
        return false;
    if (!mojo::Equals(this->extensions, other_struct.extensions))
        return false;
    if (!mojo::Equals(this->show_opt_out, other_struct.show_opt_out))
        return false;
    if (!mojo::Equals(this->network_info, other_struct.network_info))
        return false;
    if (!mojo::Equals(this->issuer_info, other_struct.issuer_info))
        return false;
    return true;
}

template <typename T, SecurePaymentConfirmationRequest::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.credential_ids < rhs.credential_ids)
        return true;
    if (rhs.credential_ids < lhs.credential_ids)
        return false;
    if (lhs.challenge < rhs.challenge)
        return true;
    if (rhs.challenge < lhs.challenge)
        return false;
    if (lhs.instrument < rhs.instrument)
        return true;
    if (rhs.instrument < lhs.instrument)
        return false;
    if (lhs.timeout < rhs.timeout)
        return true;
    if (rhs.timeout < lhs.timeout)
        return false;
    if (lhs.payee_origin < rhs.payee_origin)
        return true;
    if (rhs.payee_origin < lhs.payee_origin)
        return false;
    if (lhs.payee_name < rhs.payee_name)
        return true;
    if (rhs.payee_name < lhs.payee_name)
        return false;
    if (lhs.rp_id < rhs.rp_id)
        return true;
    if (rhs.rp_id < lhs.rp_id)
        return false;
    if (lhs.extensions < rhs.extensions)
        return true;
    if (rhs.extensions < lhs.extensions)
        return false;
    if (lhs.show_opt_out < rhs.show_opt_out)
        return true;
    if (rhs.show_opt_out < lhs.show_opt_out)
        return false;
    if (lhs.network_info < rhs.network_info)
        return true;
    if (rhs.network_info < lhs.network_info)
        return false;
    if (lhs.issuer_info < rhs.issuer_info)
        return true;
    if (rhs.issuer_info < lhs.issuer_info)
        return false;
    return false;
}
template <typename StructPtrType> NetworkOrIssuerInformationPtr NetworkOrIssuerInformation::Clone() const
{
    return New(mojo::Clone(name), mojo::Clone(icon));
}

template <typename T, NetworkOrIssuerInformation::EnableIfSame<T>*> bool NetworkOrIssuerInformation::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->name, other_struct.name))
        return false;
    if (!mojo::Equals(this->icon, other_struct.icon))
        return false;
    return true;
}

template <typename T, NetworkOrIssuerInformation::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.name < rhs.name)
        return true;
    if (rhs.name < lhs.name)
        return false;
    if (lhs.icon < rhs.icon)
        return true;
    if (rhs.icon < lhs.icon)
        return false;
    return false;
}
template <typename StructPtrType> PaymentMethodDataPtr PaymentMethodData::Clone() const
{
    return New(mojo::Clone(supported_method), mojo::Clone(stringified_data), mojo::Clone(environment), mojo::Clone(min_google_play_services_version),
        mojo::Clone(api_version), mojo::Clone(supported_networks), mojo::Clone(secure_payment_confirmation));
}

template <typename T, PaymentMethodData::EnableIfSame<T>*> bool PaymentMethodData::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->supported_method, other_struct.supported_method))
        return false;
    if (!mojo::Equals(this->stringified_data, other_struct.stringified_data))
        return false;
    if (!mojo::Equals(this->environment, other_struct.environment))
        return false;
    if (!mojo::Equals(this->min_google_play_services_version, other_struct.min_google_play_services_version))
        return false;
    if (!mojo::Equals(this->api_version, other_struct.api_version))
        return false;
    if (!mojo::Equals(this->supported_networks, other_struct.supported_networks))
        return false;
    if (!mojo::Equals(this->secure_payment_confirmation, other_struct.secure_payment_confirmation))
        return false;
    return true;
}

template <typename T, PaymentMethodData::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.supported_method < rhs.supported_method)
        return true;
    if (rhs.supported_method < lhs.supported_method)
        return false;
    if (lhs.stringified_data < rhs.stringified_data)
        return true;
    if (rhs.stringified_data < lhs.stringified_data)
        return false;
    if (lhs.environment < rhs.environment)
        return true;
    if (rhs.environment < lhs.environment)
        return false;
    if (lhs.min_google_play_services_version < rhs.min_google_play_services_version)
        return true;
    if (rhs.min_google_play_services_version < lhs.min_google_play_services_version)
        return false;
    if (lhs.api_version < rhs.api_version)
        return true;
    if (rhs.api_version < lhs.api_version)
        return false;
    if (lhs.supported_networks < rhs.supported_networks)
        return true;
    if (rhs.supported_networks < lhs.supported_networks)
        return false;
    if (lhs.secure_payment_confirmation < rhs.secure_payment_confirmation)
        return true;
    if (rhs.secure_payment_confirmation < lhs.secure_payment_confirmation)
        return false;
    return false;
}
template <typename StructPtrType> PaymentDetailsModifierPtr PaymentDetailsModifier::Clone() const
{
    return New(mojo::Clone(total), mojo::Clone(additional_display_items), mojo::Clone(method_data));
}

template <typename T, PaymentDetailsModifier::EnableIfSame<T>*> bool PaymentDetailsModifier::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->total, other_struct.total))
        return false;
    if (!mojo::Equals(this->additional_display_items, other_struct.additional_display_items))
        return false;
    if (!mojo::Equals(this->method_data, other_struct.method_data))
        return false;
    return true;
}

template <typename T, PaymentDetailsModifier::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.total < rhs.total)
        return true;
    if (rhs.total < lhs.total)
        return false;
    if (lhs.additional_display_items < rhs.additional_display_items)
        return true;
    if (rhs.additional_display_items < lhs.additional_display_items)
        return false;
    if (lhs.method_data < rhs.method_data)
        return true;
    if (rhs.method_data < lhs.method_data)
        return false;
    return false;
}
template <typename StructPtrType> PaymentDetailsPtr PaymentDetails::Clone() const
{
    return New(mojo::Clone(total), mojo::Clone(display_items), mojo::Clone(shipping_options), mojo::Clone(modifiers), mojo::Clone(error),
        mojo::Clone(shipping_address_errors), mojo::Clone(id), mojo::Clone(stringified_payment_method_errors));
}

template <typename T, PaymentDetails::EnableIfSame<T>*> bool PaymentDetails::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->total, other_struct.total))
        return false;
    if (!mojo::Equals(this->display_items, other_struct.display_items))
        return false;
    if (!mojo::Equals(this->shipping_options, other_struct.shipping_options))
        return false;
    if (!mojo::Equals(this->modifiers, other_struct.modifiers))
        return false;
    if (!mojo::Equals(this->error, other_struct.error))
        return false;
    if (!mojo::Equals(this->shipping_address_errors, other_struct.shipping_address_errors))
        return false;
    if (!mojo::Equals(this->id, other_struct.id))
        return false;
    if (!mojo::Equals(this->stringified_payment_method_errors, other_struct.stringified_payment_method_errors))
        return false;
    return true;
}

template <typename T, PaymentDetails::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.total < rhs.total)
        return true;
    if (rhs.total < lhs.total)
        return false;
    if (lhs.display_items < rhs.display_items)
        return true;
    if (rhs.display_items < lhs.display_items)
        return false;
    if (lhs.shipping_options < rhs.shipping_options)
        return true;
    if (rhs.shipping_options < lhs.shipping_options)
        return false;
    if (lhs.modifiers < rhs.modifiers)
        return true;
    if (rhs.modifiers < lhs.modifiers)
        return false;
    if (lhs.error < rhs.error)
        return true;
    if (rhs.error < lhs.error)
        return false;
    if (lhs.shipping_address_errors < rhs.shipping_address_errors)
        return true;
    if (rhs.shipping_address_errors < lhs.shipping_address_errors)
        return false;
    if (lhs.id < rhs.id)
        return true;
    if (rhs.id < lhs.id)
        return false;
    if (lhs.stringified_payment_method_errors < rhs.stringified_payment_method_errors)
        return true;
    if (rhs.stringified_payment_method_errors < lhs.stringified_payment_method_errors)
        return false;
    return false;
}
template <typename StructPtrType> PaymentOptionsPtr PaymentOptions::Clone() const
{
    return New(mojo::Clone(request_payer_name), mojo::Clone(request_payer_email), mojo::Clone(request_payer_phone), mojo::Clone(request_shipping),
        mojo::Clone(shipping_type));
}

template <typename T, PaymentOptions::EnableIfSame<T>*> bool PaymentOptions::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->request_payer_name, other_struct.request_payer_name))
        return false;
    if (!mojo::Equals(this->request_payer_email, other_struct.request_payer_email))
        return false;
    if (!mojo::Equals(this->request_payer_phone, other_struct.request_payer_phone))
        return false;
    if (!mojo::Equals(this->request_shipping, other_struct.request_shipping))
        return false;
    if (!mojo::Equals(this->shipping_type, other_struct.shipping_type))
        return false;
    return true;
}

template <typename T, PaymentOptions::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.request_payer_name < rhs.request_payer_name)
        return true;
    if (rhs.request_payer_name < lhs.request_payer_name)
        return false;
    if (lhs.request_payer_email < rhs.request_payer_email)
        return true;
    if (rhs.request_payer_email < lhs.request_payer_email)
        return false;
    if (lhs.request_payer_phone < rhs.request_payer_phone)
        return true;
    if (rhs.request_payer_phone < lhs.request_payer_phone)
        return false;
    if (lhs.request_shipping < rhs.request_shipping)
        return true;
    if (rhs.request_shipping < lhs.request_shipping)
        return false;
    if (lhs.shipping_type < rhs.shipping_type)
        return true;
    if (rhs.shipping_type < lhs.shipping_type)
        return false;
    return false;
}

} // payments::mojom::blink

namespace mojo {

template <> struct PLATFORM_EXPORT StructTraits<::payments::mojom::blink::PaymentResponse::DataView, ::payments::mojom::blink::PaymentResponsePtr> {
    static bool IsNull(const ::payments::mojom::blink::PaymentResponsePtr& input)
    {
        return !input;
    }
    static void SetToNull(::payments::mojom::blink::PaymentResponsePtr* output)
    {
        output->reset();
    }

    static const decltype(::payments::mojom::blink::PaymentResponse::method_name)& method_name(const ::payments::mojom::blink::PaymentResponsePtr& input)
    {
        return input->method_name;
    }

    static const decltype(::payments::mojom::blink::PaymentResponse::stringified_details)& stringified_details(
        const ::payments::mojom::blink::PaymentResponsePtr& input)
    {
        return input->stringified_details;
    }

    static const decltype(::payments::mojom::blink::PaymentResponse::shipping_address)& shipping_address(
        const ::payments::mojom::blink::PaymentResponsePtr& input)
    {
        return input->shipping_address;
    }

    static const decltype(::payments::mojom::blink::PaymentResponse::shipping_option)& shipping_option(
        const ::payments::mojom::blink::PaymentResponsePtr& input)
    {
        return input->shipping_option;
    }

    static const decltype(::payments::mojom::blink::PaymentResponse::payer)& payer(const ::payments::mojom::blink::PaymentResponsePtr& input)
    {
        return input->payer;
    }

    static const decltype(::payments::mojom::blink::PaymentResponse::get_assertion_authenticator_response)& get_assertion_authenticator_response(
        const ::payments::mojom::blink::PaymentResponsePtr& input)
    {
        return input->get_assertion_authenticator_response;
    }

    static bool Read(::payments::mojom::blink::PaymentResponse::DataView input, ::payments::mojom::blink::PaymentResponsePtr* output);
};

template <> struct PLATFORM_EXPORT StructTraits<::payments::mojom::blink::PayerDetail::DataView, ::payments::mojom::blink::PayerDetailPtr> {
    static bool IsNull(const ::payments::mojom::blink::PayerDetailPtr& input)
    {
        return !input;
    }
    static void SetToNull(::payments::mojom::blink::PayerDetailPtr* output)
    {
        output->reset();
    }

    static const decltype(::payments::mojom::blink::PayerDetail::email)& email(const ::payments::mojom::blink::PayerDetailPtr& input)
    {
        return input->email;
    }

    static const decltype(::payments::mojom::blink::PayerDetail::name)& name(const ::payments::mojom::blink::PayerDetailPtr& input)
    {
        return input->name;
    }

    static const decltype(::payments::mojom::blink::PayerDetail::phone)& phone(const ::payments::mojom::blink::PayerDetailPtr& input)
    {
        return input->phone;
    }

    static bool Read(::payments::mojom::blink::PayerDetail::DataView input, ::payments::mojom::blink::PayerDetailPtr* output);
};

template <> struct PLATFORM_EXPORT StructTraits<::payments::mojom::blink::PaymentItem::DataView, ::payments::mojom::blink::PaymentItemPtr> {
    static bool IsNull(const ::payments::mojom::blink::PaymentItemPtr& input)
    {
        return !input;
    }
    static void SetToNull(::payments::mojom::blink::PaymentItemPtr* output)
    {
        output->reset();
    }

    static const decltype(::payments::mojom::blink::PaymentItem::label)& label(const ::payments::mojom::blink::PaymentItemPtr& input)
    {
        return input->label;
    }

    static const decltype(::payments::mojom::blink::PaymentItem::amount)& amount(const ::payments::mojom::blink::PaymentItemPtr& input)
    {
        return input->amount;
    }

    static decltype(::payments::mojom::blink::PaymentItem::pending) pending(const ::payments::mojom::blink::PaymentItemPtr& input)
    {
        return input->pending;
    }

    static bool Read(::payments::mojom::blink::PaymentItem::DataView input, ::payments::mojom::blink::PaymentItemPtr* output);
};

template <> struct PLATFORM_EXPORT StructTraits<::payments::mojom::blink::PaymentShippingOption::DataView, ::payments::mojom::blink::PaymentShippingOptionPtr> {
    static bool IsNull(const ::payments::mojom::blink::PaymentShippingOptionPtr& input)
    {
        return !input;
    }
    static void SetToNull(::payments::mojom::blink::PaymentShippingOptionPtr* output)
    {
        output->reset();
    }

    static const decltype(::payments::mojom::blink::PaymentShippingOption::id)& id(const ::payments::mojom::blink::PaymentShippingOptionPtr& input)
    {
        return input->id;
    }

    static const decltype(::payments::mojom::blink::PaymentShippingOption::label)& label(const ::payments::mojom::blink::PaymentShippingOptionPtr& input)
    {
        return input->label;
    }

    static const decltype(::payments::mojom::blink::PaymentShippingOption::amount)& amount(const ::payments::mojom::blink::PaymentShippingOptionPtr& input)
    {
        return input->amount;
    }

    static decltype(::payments::mojom::blink::PaymentShippingOption::selected) selected(const ::payments::mojom::blink::PaymentShippingOptionPtr& input)
    {
        return input->selected;
    }

    static bool Read(::payments::mojom::blink::PaymentShippingOption::DataView input, ::payments::mojom::blink::PaymentShippingOptionPtr* output);
};

template <>
struct PLATFORM_EXPORT
    StructTraits<::payments::mojom::blink::SecurePaymentConfirmationRequest::DataView, ::payments::mojom::blink::SecurePaymentConfirmationRequestPtr> {
    static bool IsNull(const ::payments::mojom::blink::SecurePaymentConfirmationRequestPtr& input)
    {
        return !input;
    }
    static void SetToNull(::payments::mojom::blink::SecurePaymentConfirmationRequestPtr* output)
    {
        output->reset();
    }

    static const decltype(::payments::mojom::blink::SecurePaymentConfirmationRequest::credential_ids)& credential_ids(
        const ::payments::mojom::blink::SecurePaymentConfirmationRequestPtr& input)
    {
        return input->credential_ids;
    }

    static const decltype(::payments::mojom::blink::SecurePaymentConfirmationRequest::challenge)& challenge(
        const ::payments::mojom::blink::SecurePaymentConfirmationRequestPtr& input)
    {
        return input->challenge;
    }

    static const decltype(::payments::mojom::blink::SecurePaymentConfirmationRequest::instrument)& instrument(
        const ::payments::mojom::blink::SecurePaymentConfirmationRequestPtr& input)
    {
        return input->instrument;
    }

    static const decltype(::payments::mojom::blink::SecurePaymentConfirmationRequest::timeout)& timeout(
        const ::payments::mojom::blink::SecurePaymentConfirmationRequestPtr& input)
    {
        return input->timeout;
    }

    static const decltype(::payments::mojom::blink::SecurePaymentConfirmationRequest::payee_origin)& payee_origin(
        const ::payments::mojom::blink::SecurePaymentConfirmationRequestPtr& input)
    {
        return input->payee_origin;
    }

    static const decltype(::payments::mojom::blink::SecurePaymentConfirmationRequest::payee_name)& payee_name(
        const ::payments::mojom::blink::SecurePaymentConfirmationRequestPtr& input)
    {
        return input->payee_name;
    }

    static const decltype(::payments::mojom::blink::SecurePaymentConfirmationRequest::rp_id)& rp_id(
        const ::payments::mojom::blink::SecurePaymentConfirmationRequestPtr& input)
    {
        return input->rp_id;
    }

    static const decltype(::payments::mojom::blink::SecurePaymentConfirmationRequest::extensions)& extensions(
        const ::payments::mojom::blink::SecurePaymentConfirmationRequestPtr& input)
    {
        return input->extensions;
    }

    static decltype(::payments::mojom::blink::SecurePaymentConfirmationRequest::show_opt_out) show_opt_out(
        const ::payments::mojom::blink::SecurePaymentConfirmationRequestPtr& input)
    {
        return input->show_opt_out;
    }

    static const decltype(::payments::mojom::blink::SecurePaymentConfirmationRequest::network_info)& network_info(
        const ::payments::mojom::blink::SecurePaymentConfirmationRequestPtr& input)
    {
        return input->network_info;
    }

    static const decltype(::payments::mojom::blink::SecurePaymentConfirmationRequest::issuer_info)& issuer_info(
        const ::payments::mojom::blink::SecurePaymentConfirmationRequestPtr& input)
    {
        return input->issuer_info;
    }

    static bool Read(
        ::payments::mojom::blink::SecurePaymentConfirmationRequest::DataView input, ::payments::mojom::blink::SecurePaymentConfirmationRequestPtr* output);
};

template <>
struct PLATFORM_EXPORT StructTraits<::payments::mojom::blink::NetworkOrIssuerInformation::DataView, ::payments::mojom::blink::NetworkOrIssuerInformationPtr> {
    static bool IsNull(const ::payments::mojom::blink::NetworkOrIssuerInformationPtr& input)
    {
        return !input;
    }
    static void SetToNull(::payments::mojom::blink::NetworkOrIssuerInformationPtr* output)
    {
        output->reset();
    }

    static const decltype(::payments::mojom::blink::NetworkOrIssuerInformation::name)& name(
        const ::payments::mojom::blink::NetworkOrIssuerInformationPtr& input)
    {
        return input->name;
    }

    static const decltype(::payments::mojom::blink::NetworkOrIssuerInformation::icon)& icon(
        const ::payments::mojom::blink::NetworkOrIssuerInformationPtr& input)
    {
        return input->icon;
    }

    static bool Read(::payments::mojom::blink::NetworkOrIssuerInformation::DataView input, ::payments::mojom::blink::NetworkOrIssuerInformationPtr* output);
};

template <> struct PLATFORM_EXPORT StructTraits<::payments::mojom::blink::PaymentMethodData::DataView, ::payments::mojom::blink::PaymentMethodDataPtr> {
    static bool IsNull(const ::payments::mojom::blink::PaymentMethodDataPtr& input)
    {
        return !input;
    }
    static void SetToNull(::payments::mojom::blink::PaymentMethodDataPtr* output)
    {
        output->reset();
    }

    static const decltype(::payments::mojom::blink::PaymentMethodData::supported_method)& supported_method(
        const ::payments::mojom::blink::PaymentMethodDataPtr& input)
    {
        return input->supported_method;
    }

    static const decltype(::payments::mojom::blink::PaymentMethodData::stringified_data)& stringified_data(
        const ::payments::mojom::blink::PaymentMethodDataPtr& input)
    {
        return input->stringified_data;
    }

    static decltype(::payments::mojom::blink::PaymentMethodData::environment) environment(const ::payments::mojom::blink::PaymentMethodDataPtr& input)
    {
        return input->environment;
    }

    static decltype(::payments::mojom::blink::PaymentMethodData::min_google_play_services_version) min_google_play_services_version(
        const ::payments::mojom::blink::PaymentMethodDataPtr& input)
    {
        return input->min_google_play_services_version;
    }

    static decltype(::payments::mojom::blink::PaymentMethodData::api_version) api_version(const ::payments::mojom::blink::PaymentMethodDataPtr& input)
    {
        return input->api_version;
    }

    static const decltype(::payments::mojom::blink::PaymentMethodData::supported_networks)& supported_networks(
        const ::payments::mojom::blink::PaymentMethodDataPtr& input)
    {
        return input->supported_networks;
    }

    static const decltype(::payments::mojom::blink::PaymentMethodData::secure_payment_confirmation)& secure_payment_confirmation(
        const ::payments::mojom::blink::PaymentMethodDataPtr& input)
    {
        return input->secure_payment_confirmation;
    }

    static bool Read(::payments::mojom::blink::PaymentMethodData::DataView input, ::payments::mojom::blink::PaymentMethodDataPtr* output);
};

template <>
struct PLATFORM_EXPORT StructTraits<::payments::mojom::blink::PaymentDetailsModifier::DataView, ::payments::mojom::blink::PaymentDetailsModifierPtr> {
    static bool IsNull(const ::payments::mojom::blink::PaymentDetailsModifierPtr& input)
    {
        return !input;
    }
    static void SetToNull(::payments::mojom::blink::PaymentDetailsModifierPtr* output)
    {
        output->reset();
    }

    static const decltype(::payments::mojom::blink::PaymentDetailsModifier::total)& total(const ::payments::mojom::blink::PaymentDetailsModifierPtr& input)
    {
        return input->total;
    }

    static const decltype(::payments::mojom::blink::PaymentDetailsModifier::additional_display_items)& additional_display_items(
        const ::payments::mojom::blink::PaymentDetailsModifierPtr& input)
    {
        return input->additional_display_items;
    }

    static const decltype(::payments::mojom::blink::PaymentDetailsModifier::method_data)& method_data(
        const ::payments::mojom::blink::PaymentDetailsModifierPtr& input)
    {
        return input->method_data;
    }

    static bool Read(::payments::mojom::blink::PaymentDetailsModifier::DataView input, ::payments::mojom::blink::PaymentDetailsModifierPtr* output);
};

template <> struct PLATFORM_EXPORT StructTraits<::payments::mojom::blink::PaymentDetails::DataView, ::payments::mojom::blink::PaymentDetailsPtr> {
    static bool IsNull(const ::payments::mojom::blink::PaymentDetailsPtr& input)
    {
        return !input;
    }
    static void SetToNull(::payments::mojom::blink::PaymentDetailsPtr* output)
    {
        output->reset();
    }

    static const decltype(::payments::mojom::blink::PaymentDetails::total)& total(const ::payments::mojom::blink::PaymentDetailsPtr& input)
    {
        return input->total;
    }

    static const decltype(::payments::mojom::blink::PaymentDetails::display_items)& display_items(const ::payments::mojom::blink::PaymentDetailsPtr& input)
    {
        return input->display_items;
    }

    static const decltype(::payments::mojom::blink::PaymentDetails::shipping_options)& shipping_options(
        const ::payments::mojom::blink::PaymentDetailsPtr& input)
    {
        return input->shipping_options;
    }

    static const decltype(::payments::mojom::blink::PaymentDetails::modifiers)& modifiers(const ::payments::mojom::blink::PaymentDetailsPtr& input)
    {
        return input->modifiers;
    }

    static const decltype(::payments::mojom::blink::PaymentDetails::error)& error(const ::payments::mojom::blink::PaymentDetailsPtr& input)
    {
        return input->error;
    }

    static const decltype(::payments::mojom::blink::PaymentDetails::shipping_address_errors)& shipping_address_errors(
        const ::payments::mojom::blink::PaymentDetailsPtr& input)
    {
        return input->shipping_address_errors;
    }

    static const decltype(::payments::mojom::blink::PaymentDetails::id)& id(const ::payments::mojom::blink::PaymentDetailsPtr& input)
    {
        return input->id;
    }

    static const decltype(::payments::mojom::blink::PaymentDetails::stringified_payment_method_errors)& stringified_payment_method_errors(
        const ::payments::mojom::blink::PaymentDetailsPtr& input)
    {
        return input->stringified_payment_method_errors;
    }

    static bool Read(::payments::mojom::blink::PaymentDetails::DataView input, ::payments::mojom::blink::PaymentDetailsPtr* output);
};

template <> struct PLATFORM_EXPORT StructTraits<::payments::mojom::blink::PaymentOptions::DataView, ::payments::mojom::blink::PaymentOptionsPtr> {
    static bool IsNull(const ::payments::mojom::blink::PaymentOptionsPtr& input)
    {
        return !input;
    }
    static void SetToNull(::payments::mojom::blink::PaymentOptionsPtr* output)
    {
        output->reset();
    }

    static decltype(::payments::mojom::blink::PaymentOptions::request_payer_name) request_payer_name(const ::payments::mojom::blink::PaymentOptionsPtr& input)
    {
        return input->request_payer_name;
    }

    static decltype(::payments::mojom::blink::PaymentOptions::request_payer_email) request_payer_email(const ::payments::mojom::blink::PaymentOptionsPtr& input)
    {
        return input->request_payer_email;
    }

    static decltype(::payments::mojom::blink::PaymentOptions::request_payer_phone) request_payer_phone(const ::payments::mojom::blink::PaymentOptionsPtr& input)
    {
        return input->request_payer_phone;
    }

    static decltype(::payments::mojom::blink::PaymentOptions::request_shipping) request_shipping(const ::payments::mojom::blink::PaymentOptionsPtr& input)
    {
        return input->request_shipping;
    }

    static decltype(::payments::mojom::blink::PaymentOptions::shipping_type) shipping_type(const ::payments::mojom::blink::PaymentOptionsPtr& input)
    {
        return input->shipping_type;
    }

    static bool Read(::payments::mojom::blink::PaymentOptions::DataView input, ::payments::mojom::blink::PaymentOptionsPtr* output);
};

} // namespace mojo

#endif // THIRD_PARTY_BLINK_PUBLIC_MOJOM_PAYMENTS_PAYMENT_REQUEST_MOJOM_BLINK_H_
