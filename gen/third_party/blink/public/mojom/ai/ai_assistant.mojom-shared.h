// third_party/blink/public/mojom/ai/ai_assistant.mojom-shared.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef THIRD_PARTY_BLINK_PUBLIC_MOJOM_AI_AI_ASSISTANT_MOJOM_SHARED_H_
#define THIRD_PARTY_BLINK_PUBLIC_MOJOM_AI_AI_ASSISTANT_MOJOM_SHARED_H_

#include <stdint.h>

#include <functional>
#include <iosfwd>
#include <type_traits>
#include <utility>
#include "mojo/public/cpp/bindings/array_data_view.h"
#include "mojo/public/cpp/bindings/enum_traits.h"
#include "mojo/public/cpp/bindings/interface_data_view.h"
#include "mojo/public/cpp/bindings/lib/bindings_internal.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/map_data_view.h"
#include "mojo/public/cpp/bindings/string_data_view.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "third_party/blink/public/mojom/ai/ai_assistant.mojom-shared-internal.h"
#include "third_party/blink/public/mojom/ai/model_streaming_responder.mojom-shared.h"
#include "mojo/public/cpp/bindings/lib/interface_serialization.h"
#include "mojo/public/cpp/system/data_pipe.h"

#include "base/component_export.h"

namespace blink::mojom {
class AIAssistantSamplingParamsDataView;

class AIModelInfoDataView;

class AIAssistantInfoDataView;

class AIAssistantInitialPromptDataView;

class AIAssistantCreateOptionsDataView;

} // blink::mojom

namespace mojo {
namespace internal {

template <> struct MojomTypeTraits<::blink::mojom::AIAssistantSamplingParamsDataView> {
    using Data = ::blink::mojom::internal::AIAssistantSamplingParams_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::blink::mojom::AIModelInfoDataView> {
    using Data = ::blink::mojom::internal::AIModelInfo_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::blink::mojom::AIAssistantInfoDataView> {
    using Data = ::blink::mojom::internal::AIAssistantInfo_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::blink::mojom::AIAssistantInitialPromptDataView> {
    using Data = ::blink::mojom::internal::AIAssistantInitialPrompt_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::blink::mojom::AIAssistantCreateOptionsDataView> {
    using Data = ::blink::mojom::internal::AIAssistantCreateOptions_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

} // namespace internal
} // namespace mojo

namespace blink::mojom {

enum class AIAssistantInitialPromptRole : int32_t {

    kSystem = 0,

    kUser = 1,

    kAssistant = 2,
    kMinValue = 0,
    kMaxValue = 2,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, AIAssistantInitialPromptRole value);
inline bool IsKnownEnumValue(AIAssistantInitialPromptRole value)
{
    return internal::AIAssistantInitialPromptRole_Data::IsKnownValue(static_cast<int32_t>(value));
}
// Interface base classes. They are used for type safety check.
class AIManagerCreateAssistantClientInterfaceBase { };

using AIManagerCreateAssistantClientPtrDataView = mojo::InterfacePtrDataView<AIManagerCreateAssistantClientInterfaceBase>;
using AIManagerCreateAssistantClientRequestDataView = mojo::InterfaceRequestDataView<AIManagerCreateAssistantClientInterfaceBase>;
using AIManagerCreateAssistantClientAssociatedPtrInfoDataView = mojo::AssociatedInterfacePtrInfoDataView<AIManagerCreateAssistantClientInterfaceBase>;
using AIManagerCreateAssistantClientAssociatedRequestDataView = mojo::AssociatedInterfaceRequestDataView<AIManagerCreateAssistantClientInterfaceBase>;
class AIAssistantCountPromptTokensClientInterfaceBase { };

using AIAssistantCountPromptTokensClientPtrDataView = mojo::InterfacePtrDataView<AIAssistantCountPromptTokensClientInterfaceBase>;
using AIAssistantCountPromptTokensClientRequestDataView = mojo::InterfaceRequestDataView<AIAssistantCountPromptTokensClientInterfaceBase>;
using AIAssistantCountPromptTokensClientAssociatedPtrInfoDataView = mojo::AssociatedInterfacePtrInfoDataView<AIAssistantCountPromptTokensClientInterfaceBase>;
using AIAssistantCountPromptTokensClientAssociatedRequestDataView = mojo::AssociatedInterfaceRequestDataView<AIAssistantCountPromptTokensClientInterfaceBase>;
class AIAssistantInterfaceBase { };

using AIAssistantPtrDataView = mojo::InterfacePtrDataView<AIAssistantInterfaceBase>;
using AIAssistantRequestDataView = mojo::InterfaceRequestDataView<AIAssistantInterfaceBase>;
using AIAssistantAssociatedPtrInfoDataView = mojo::AssociatedInterfacePtrInfoDataView<AIAssistantInterfaceBase>;
using AIAssistantAssociatedRequestDataView = mojo::AssociatedInterfaceRequestDataView<AIAssistantInterfaceBase>;

class AIAssistantSamplingParamsDataView {
public:
    AIAssistantSamplingParamsDataView() = default;

    AIAssistantSamplingParamsDataView(internal::AIAssistantSamplingParams_Data* data, mojo::Message* message)
        : data_(data)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    uint32_t top_k() const
    {
        return data_->top_k;
    }
    float temperature() const
    {
        return data_->temperature;
    }

private:
    internal::AIAssistantSamplingParams_Data* data_ = nullptr;
};

class AIModelInfoDataView {
public:
    AIModelInfoDataView() = default;

    AIModelInfoDataView(internal::AIModelInfo_Data* data, mojo::Message* message)
        : data_(data)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    uint32_t default_top_k() const
    {
        return data_->default_top_k;
    }
    uint32_t max_top_k() const
    {
        return data_->max_top_k;
    }
    float default_temperature() const
    {
        return data_->default_temperature;
    }

private:
    internal::AIModelInfo_Data* data_ = nullptr;
};

class AIAssistantInfoDataView {
public:
    AIAssistantInfoDataView() = default;

    AIAssistantInfoDataView(internal::AIAssistantInfo_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    uint64_t max_tokens() const
    {
        return data_->max_tokens;
    }
    inline void GetSamplingParamsDataView(AIAssistantSamplingParamsDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadSamplingParams(UserType* output)
    {

        auto* pointer = data_->sampling_params.Get();
        return mojo::internal::Deserialize<::blink::mojom::AIAssistantSamplingParamsDataView>(pointer, output, message_);
    }

private:
    internal::AIAssistantInfo_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class AIAssistantInitialPromptDataView {
public:
    AIAssistantInitialPromptDataView() = default;

    AIAssistantInitialPromptDataView(internal::AIAssistantInitialPrompt_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    template <typename UserType> [[nodiscard]] bool ReadRole(UserType* output) const
    {
        auto data_value = data_->role;
        return mojo::internal::Deserialize<::blink::mojom::AIAssistantInitialPromptRole>(data_value, output);
    }
    AIAssistantInitialPromptRole role() const
    {
        return ::mojo::internal::ToKnownEnumValueHelper(static_cast<::blink::mojom::AIAssistantInitialPromptRole>(data_->role));
    }
    inline void GetContentDataView(mojo::StringDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadContent(UserType* output)
    {

        auto* pointer = data_->content.Get();
        return mojo::internal::Deserialize<mojo::StringDataView>(pointer, output, message_);
    }

private:
    internal::AIAssistantInitialPrompt_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class AIAssistantCreateOptionsDataView {
public:
    AIAssistantCreateOptionsDataView() = default;

    AIAssistantCreateOptionsDataView(internal::AIAssistantCreateOptions_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetSamplingParamsDataView(AIAssistantSamplingParamsDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadSamplingParams(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::blink::mojom::AIAssistantSamplingParamsDataView, UserType>(),
            "Attempting to read the optional `sampling_params` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadSamplingParams` instead "
            "of `ReadSamplingParams if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->sampling_params.Get();
        return mojo::internal::Deserialize<::blink::mojom::AIAssistantSamplingParamsDataView>(pointer, output, message_);
    }
    inline void GetSystemPromptDataView(mojo::StringDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadSystemPrompt(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<mojo::StringDataView, UserType>(),
            "Attempting to read the optional `system_prompt` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadSystemPrompt` instead "
            "of `ReadSystemPrompt if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->system_prompt.Get();
        return mojo::internal::Deserialize<mojo::StringDataView>(pointer, output, message_);
    }
    inline void GetInitialPromptsDataView(mojo::ArrayDataView<AIAssistantInitialPromptDataView>* output);

    template <typename UserType> [[nodiscard]] bool ReadInitialPrompts(UserType* output)
    {

        auto* pointer = data_->initial_prompts.Get();
        return mojo::internal::Deserialize<mojo::ArrayDataView<::blink::mojom::AIAssistantInitialPromptDataView>>(pointer, output, message_);
    }

private:
    internal::AIAssistantCreateOptions_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

} // blink::mojom

namespace std {

template <> struct hash<::blink::mojom::AIAssistantInitialPromptRole> : public mojo::internal::EnumHashImpl<::blink::mojom::AIAssistantInitialPromptRole> { };

} // namespace std

namespace mojo {

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::AIAssistantInitialPromptRole, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = EnumTraits<::blink::mojom::AIAssistantInitialPromptRole, UserType>;

    static void Serialize(UserType input, int32_t* output)
    {
        *output = static_cast<int32_t>(Traits::ToMojom(input));
    }

    static bool Deserialize(int32_t input, UserType* output)
    {
        return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(static_cast<::blink::mojom::AIAssistantInitialPromptRole>(input)), output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::AIAssistantSamplingParamsDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::blink::mojom::AIAssistantSamplingParamsDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::blink::mojom::internal::AIAssistantSamplingParams_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        fragment->top_k = Traits::top_k(input);
        fragment->temperature = Traits::temperature(input);
    }

    static bool Deserialize(::blink::mojom::internal::AIAssistantSamplingParams_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::blink::mojom::AIAssistantSamplingParamsDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::AIModelInfoDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::blink::mojom::AIModelInfoDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::blink::mojom::internal::AIModelInfo_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        fragment->default_top_k = Traits::default_top_k(input);
        fragment->max_top_k = Traits::max_top_k(input);
        fragment->default_temperature = Traits::default_temperature(input);
    }

    static bool Deserialize(::blink::mojom::internal::AIModelInfo_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::blink::mojom::AIModelInfoDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::AIAssistantInfoDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::blink::mojom::AIAssistantInfoDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::blink::mojom::internal::AIAssistantInfo_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        fragment->max_tokens = Traits::max_tokens(input);
        decltype(Traits::sampling_params(input)) in_sampling_params = Traits::sampling_params(input);
        mojo::internal::MessageFragment<typename decltype(fragment->sampling_params)::BaseType> sampling_params_fragment(fragment.message());
        mojo::internal::Serialize<::blink::mojom::AIAssistantSamplingParamsDataView>(in_sampling_params, sampling_params_fragment);
        fragment->sampling_params.Set(sampling_params_fragment.is_null() ? nullptr : sampling_params_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->sampling_params.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null sampling_params in AIAssistantInfo struct");
    }

    static bool Deserialize(::blink::mojom::internal::AIAssistantInfo_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::blink::mojom::AIAssistantInfoDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::AIAssistantInitialPromptDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::blink::mojom::AIAssistantInitialPromptDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::blink::mojom::internal::AIAssistantInitialPrompt_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        mojo::internal::Serialize<::blink::mojom::AIAssistantInitialPromptRole>(Traits::role(input), &fragment->role);
        decltype(Traits::content(input)) in_content = Traits::content(input);
        mojo::internal::MessageFragment<typename decltype(fragment->content)::BaseType> content_fragment(fragment.message());
        mojo::internal::Serialize<mojo::StringDataView>(in_content, content_fragment);
        fragment->content.Set(content_fragment.is_null() ? nullptr : content_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->content.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null content in AIAssistantInitialPrompt struct");
    }

    static bool Deserialize(::blink::mojom::internal::AIAssistantInitialPrompt_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::blink::mojom::AIAssistantInitialPromptDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::blink::mojom::AIAssistantCreateOptionsDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::blink::mojom::AIAssistantCreateOptionsDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::blink::mojom::internal::AIAssistantCreateOptions_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::sampling_params(input)) in_sampling_params = Traits::sampling_params(input);
        mojo::internal::MessageFragment<typename decltype(fragment->sampling_params)::BaseType> sampling_params_fragment(fragment.message());
        mojo::internal::Serialize<::blink::mojom::AIAssistantSamplingParamsDataView>(in_sampling_params, sampling_params_fragment);
        fragment->sampling_params.Set(sampling_params_fragment.is_null() ? nullptr : sampling_params_fragment.data());
        decltype(Traits::system_prompt(input)) in_system_prompt = Traits::system_prompt(input);
        mojo::internal::MessageFragment<typename decltype(fragment->system_prompt)::BaseType> system_prompt_fragment(fragment.message());
        mojo::internal::Serialize<mojo::StringDataView>(in_system_prompt, system_prompt_fragment);
        fragment->system_prompt.Set(system_prompt_fragment.is_null() ? nullptr : system_prompt_fragment.data());
        decltype(Traits::initial_prompts(input)) in_initial_prompts = Traits::initial_prompts(input);
        mojo::internal::MessageFragment<typename decltype(fragment->initial_prompts)::BaseType> initial_prompts_fragment(fragment.message());
        constexpr const mojo::internal::ContainerValidateParams& initial_prompts_validate_params = mojo::internal::GetArrayValidator<0, false, nullptr>();
        mojo::internal::Serialize<mojo::ArrayDataView<::blink::mojom::AIAssistantInitialPromptDataView>>(
            in_initial_prompts, initial_prompts_fragment, &initial_prompts_validate_params);
        fragment->initial_prompts.Set(initial_prompts_fragment.is_null() ? nullptr : initial_prompts_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(fragment->initial_prompts.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null initial_prompts in AIAssistantCreateOptions struct");
    }

    static bool Deserialize(::blink::mojom::internal::AIAssistantCreateOptions_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::blink::mojom::AIAssistantCreateOptionsDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

} // namespace mojo

namespace blink::mojom {

inline void AIAssistantInfoDataView::GetSamplingParamsDataView(AIAssistantSamplingParamsDataView* output)
{
    auto pointer = data_->sampling_params.Get();
    *output = AIAssistantSamplingParamsDataView(pointer, message_);
}

inline void AIAssistantInitialPromptDataView::GetContentDataView(mojo::StringDataView* output)
{
    auto pointer = data_->content.Get();
    *output = mojo::StringDataView(pointer, message_);
}

inline void AIAssistantCreateOptionsDataView::GetSamplingParamsDataView(AIAssistantSamplingParamsDataView* output)
{
    auto pointer = data_->sampling_params.Get();
    *output = AIAssistantSamplingParamsDataView(pointer, message_);
}
inline void AIAssistantCreateOptionsDataView::GetSystemPromptDataView(mojo::StringDataView* output)
{
    auto pointer = data_->system_prompt.Get();
    *output = mojo::StringDataView(pointer, message_);
}
inline void AIAssistantCreateOptionsDataView::GetInitialPromptsDataView(mojo::ArrayDataView<AIAssistantInitialPromptDataView>* output)
{
    auto pointer = data_->initial_prompts.Get();
    *output = mojo::ArrayDataView<AIAssistantInitialPromptDataView>(pointer, message_);
}

} // blink::mojom

// Declare TraceFormatTraits for enums, which should be defined in ::perfetto
// namespace.

namespace perfetto {

template <> struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::AIAssistantInitialPromptRole> {
    static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::AIAssistantInitialPromptRole value);
};

} // namespace perfetto

#endif // THIRD_PARTY_BLINK_PUBLIC_MOJOM_AI_AI_ASSISTANT_MOJOM_SHARED_H_
