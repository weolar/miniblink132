// third_party/blink/public/mojom/widget/platform_widget.mojom-blink-test-utils.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2019 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef THIRD_PARTY_BLINK_PUBLIC_MOJOM_WIDGET_PLATFORM_WIDGET_MOJOM_BLINK_TEST_UTILS_H_
#define THIRD_PARTY_BLINK_PUBLIC_MOJOM_WIDGET_PLATFORM_WIDGET_MOJOM_BLINK_TEST_UTILS_H_

#include "third_party/blink/public/mojom/widget/platform_widget.mojom-blink.h"
#include "third_party/blink/renderer/platform/platform_export.h"

namespace blink::mojom::blink {

class PLATFORM_EXPORT WidgetCompositorInterceptorForTesting : public WidgetCompositor {
    virtual WidgetCompositor* GetForwardingInterface() = 0;
    void VisualStateRequest(VisualStateRequestCallback callback) override;
};
class PLATFORM_EXPORT WidgetCompositorAsyncWaiter {
public:
    explicit WidgetCompositorAsyncWaiter(WidgetCompositor* proxy);

    WidgetCompositorAsyncWaiter(const WidgetCompositorAsyncWaiter&) = delete;
    WidgetCompositorAsyncWaiter& operator=(const WidgetCompositorAsyncWaiter&) = delete;

    ~WidgetCompositorAsyncWaiter();
    void VisualStateRequest();

private:
    WidgetCompositor* const proxy_;
};

class PLATFORM_EXPORT WidgetHostInterceptorForTesting : public WidgetHost {
    virtual WidgetHost* GetForwardingInterface() = 0;
    void SetCursor(const ::ui::Cursor& cursor) override;
    void UpdateTooltipUnderCursor(const ::WTF::String& tooltip_text, ::base::i18n::TextDirection text_direction_hint) override;
    void UpdateTooltipFromKeyboard(const ::WTF::String& tooltip_text, ::base::i18n::TextDirection text_direction_hint, const ::gfx::Rect& bounds) override;
    void ClearKeyboardTriggeredTooltip() override;
    void TextInputStateChanged(::ui::mojom::blink::TextInputStatePtr state) override;
    void SelectionBoundsChanged(const ::gfx::Rect& anchor_rect, ::base::i18n::TextDirection anchor_dir, const ::gfx::Rect& focus_rect,
        ::base::i18n::TextDirection focus_dir, const ::gfx::Rect& bounding_box_rect, bool is_anchor_first) override;
    void CreateFrameSink(::mojo::PendingReceiver<::viz::mojom::blink::CompositorFrameSink> compositor_frame_sink_receiver,
        ::mojo::PendingRemote<::viz::mojom::blink::CompositorFrameSinkClient> compositor_frame_sink_client) override;
    void RegisterRenderFrameMetadataObserver(
        ::mojo::PendingReceiver<::cc::mojom::blink::RenderFrameMetadataObserverClient> render_frame_metadata_observer_client_receiver,
        ::mojo::PendingRemote<::cc::mojom::blink::RenderFrameMetadataObserver> render_frame_metadata_observer) override;
};
class PLATFORM_EXPORT WidgetHostAsyncWaiter {
public:
    explicit WidgetHostAsyncWaiter(WidgetHost* proxy);

    WidgetHostAsyncWaiter(const WidgetHostAsyncWaiter&) = delete;
    WidgetHostAsyncWaiter& operator=(const WidgetHostAsyncWaiter&) = delete;

    ~WidgetHostAsyncWaiter();

private:
    WidgetHost* const proxy_;
};

class PLATFORM_EXPORT WidgetInterceptorForTesting : public Widget {
    virtual Widget* GetForwardingInterface() = 0;
    void ForceRedraw(ForceRedrawCallback callback) override;
    void UpdateVisualProperties(const ::blink::VisualProperties& visual_properties) override;
    void UpdateScreenRects(const ::gfx::Rect& widget_screen_rect, const ::gfx::Rect& window_screen_rect, UpdateScreenRectsCallback callback) override;
    void WasHidden() override;
    void WasShown(bool was_evicted, ::blink::mojom::blink::RecordContentToVisibleTimeRequestPtr record_tab_switch_time_request) override;
    void RequestSuccessfulPresentationTimeForNextFrame(::blink::mojom::blink::RecordContentToVisibleTimeRequestPtr visible_time_request) override;
    void CancelSuccessfulPresentationTimeRequest() override;
    void SetupRenderInputRouterConnections(
        ::mojo::PendingReceiver<RenderInputRouterClient> browser_client, ::mojo::PendingReceiver<RenderInputRouterClient> viz_client) override;
};
class PLATFORM_EXPORT WidgetAsyncWaiter {
public:
    explicit WidgetAsyncWaiter(Widget* proxy);

    WidgetAsyncWaiter(const WidgetAsyncWaiter&) = delete;
    WidgetAsyncWaiter& operator=(const WidgetAsyncWaiter&) = delete;

    ~WidgetAsyncWaiter();
    void ForceRedraw();

    void UpdateScreenRects(const ::gfx::Rect& widget_screen_rect, const ::gfx::Rect& window_screen_rect);

private:
    Widget* const proxy_;
};

class PLATFORM_EXPORT RenderInputRouterClientInterceptorForTesting : public RenderInputRouterClient {
    virtual RenderInputRouterClient* GetForwardingInterface() = 0;
    void GetWidgetInputHandler(::mojo::PendingReceiver<::blink::mojom::blink::WidgetInputHandler> request,
        ::mojo::PendingRemote<::blink::mojom::blink::WidgetInputHandlerHost> host) override;
    void ShowContextMenu(::ui::mojom::blink::MenuSourceType source_type, const ::gfx::Point& location) override;
    void BindInputTargetClient(::mojo::PendingReceiver<::viz::mojom::blink::InputTargetClient> host) override;
};
class PLATFORM_EXPORT RenderInputRouterClientAsyncWaiter {
public:
    explicit RenderInputRouterClientAsyncWaiter(RenderInputRouterClient* proxy);

    RenderInputRouterClientAsyncWaiter(const RenderInputRouterClientAsyncWaiter&) = delete;
    RenderInputRouterClientAsyncWaiter& operator=(const RenderInputRouterClientAsyncWaiter&) = delete;

    ~RenderInputRouterClientAsyncWaiter();

private:
    RenderInputRouterClient* const proxy_;
};

} // blink::mojom::blink

#endif // THIRD_PARTY_BLINK_PUBLIC_MOJOM_WIDGET_PLATFORM_WIDGET_MOJOM_BLINK_TEST_UTILS_H_
