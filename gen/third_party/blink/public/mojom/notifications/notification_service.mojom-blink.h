// third_party/blink/public/mojom/notifications/notification_service.mojom-blink.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef THIRD_PARTY_BLINK_PUBLIC_MOJOM_NOTIFICATIONS_NOTIFICATION_SERVICE_MOJOM_BLINK_H_
#define THIRD_PARTY_BLINK_PUBLIC_MOJOM_NOTIFICATIONS_NOTIFICATION_SERVICE_MOJOM_BLINK_H_

#include <stdint.h>

#include <limits>
#include <optional>
#include <type_traits>
#include <utility>

#include "base/types/cxx23_to_underlying.h"
#include "mojo/public/cpp/bindings/clone_traits.h"
#include "mojo/public/cpp/bindings/equals_traits.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/struct_ptr.h"
#include "mojo/public/cpp/bindings/struct_traits.h"
#include "mojo/public/cpp/bindings/union_traits.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "third_party/blink/public/mojom/notifications/notification_service.mojom-features.h" // IWYU pragma: export
#include "third_party/blink/public/mojom/notifications/notification_service.mojom-shared.h" // IWYU pragma: export
#include "third_party/blink/public/mojom/notifications/notification_service.mojom-blink-forward.h" // IWYU pragma: export
#include "third_party/blink/public/mojom/notifications/notification.mojom-blink-forward.h"
#include "third_party/blink/public/mojom/permissions/permission_status.mojom-blink-forward.h"

#include "mojo/public/cpp/bindings/lib/wtf_clone_equals_util.h"
#include "mojo/public/cpp/bindings/lib/wtf_hash_util.h"
#include "third_party/blink/renderer/platform/wtf/hash_functions.h"
#include "third_party/blink/renderer/platform/wtf/text/wtf_string.h"

#include "mojo/public/cpp/bindings/lib/control_message_handler.h"
#include "mojo/public/cpp/bindings/lib/message_size_estimator.h"
#include "mojo/public/cpp/bindings/raw_ptr_impl_ref_traits.h"

#include "third_party/blink/renderer/platform/platform_export.h"
#if !BLINK_MOJO_IMPL && !INSIDE_BLINK
#error "File must only be imported inside blink"
#endif

namespace blink::mojom::blink {

class NonPersistentNotificationListenerProxy;

template <typename ImplRefTraits> class NonPersistentNotificationListenerStub;

class NonPersistentNotificationListenerRequestValidator;
class NonPersistentNotificationListenerResponseValidator;

class PLATFORM_EXPORT NonPersistentNotificationListener : public NonPersistentNotificationListenerInterfaceBase {
public:
    using IPCStableHashFunction = uint32_t (*)();

    static const char Name_[];
    static IPCStableHashFunction MessageToMethodInfo_(mojo::Message& message);
    static const char* MessageToMethodName_(mojo::Message& message);
    static constexpr uint32_t Version_ = 0;
    static constexpr bool PassesAssociatedKinds_ = false;
    static constexpr bool HasUninterruptableMethods_ = false;

    using Base_ = NonPersistentNotificationListenerInterfaceBase;
    using Proxy_ = NonPersistentNotificationListenerProxy;

    template <typename ImplRefTraits> using Stub_ = NonPersistentNotificationListenerStub<ImplRefTraits>;

    using RequestValidator_ = NonPersistentNotificationListenerRequestValidator;
    using ResponseValidator_ = NonPersistentNotificationListenerResponseValidator;
    enum MethodMinVersions : uint32_t {
        kOnShowMinVersion = 0,
        kOnClickMinVersion = 0,
        kOnCloseMinVersion = 0,
    };

// crbug.com/1340245 - this causes binary size bloat on Fuchsia, and we're OK
// with not having this data in traces there.
#if !BUILDFLAG(IS_FUCHSIA)
    struct OnShow_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct OnClick_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct OnClose_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
#endif // !BUILDFLAG(IS_FUCHSIA)
    virtual ~NonPersistentNotificationListener() = default;

    virtual void OnShow() = 0;

    using OnClickCallback = base::OnceCallback<void()>;

    virtual void OnClick(OnClickCallback callback) = 0;

    using OnCloseCallback = base::OnceCallback<void()>;

    virtual void OnClose(OnCloseCallback callback) = 0;
};

class NotificationServiceProxy;

template <typename ImplRefTraits> class NotificationServiceStub;

class NotificationServiceRequestValidator;
class NotificationServiceResponseValidator;

class PLATFORM_EXPORT NotificationService : public NotificationServiceInterfaceBase {
public:
    using IPCStableHashFunction = uint32_t (*)();

    static const char Name_[];
    static IPCStableHashFunction MessageToMethodInfo_(mojo::Message& message);
    static const char* MessageToMethodName_(mojo::Message& message);
    static constexpr uint32_t Version_ = 0;
    static constexpr bool PassesAssociatedKinds_ = false;
    static inline constexpr uint32_t kSyncMethodOrdinals[] = { 0 };
    static constexpr bool HasUninterruptableMethods_ = false;

    using Base_ = NotificationServiceInterfaceBase;
    using Proxy_ = NotificationServiceProxy;

    template <typename ImplRefTraits> using Stub_ = NotificationServiceStub<ImplRefTraits>;

    using RequestValidator_ = NotificationServiceRequestValidator;
    using ResponseValidator_ = NotificationServiceResponseValidator;
    enum MethodMinVersions : uint32_t {
        kGetPermissionStatusMinVersion = 0,
        kDisplayNonPersistentNotificationMinVersion = 0,
        kCloseNonPersistentNotificationMinVersion = 0,
        kDisplayPersistentNotificationMinVersion = 0,
        kClosePersistentNotificationMinVersion = 0,
        kGetNotificationsMinVersion = 0,
    };

// crbug.com/1340245 - this causes binary size bloat on Fuchsia, and we're OK
// with not having this data in traces there.
#if !BUILDFLAG(IS_FUCHSIA)
    struct GetPermissionStatus_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct DisplayNonPersistentNotification_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct CloseNonPersistentNotification_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct DisplayPersistentNotification_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct ClosePersistentNotification_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct GetNotifications_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
#endif // !BUILDFLAG(IS_FUCHSIA)
    virtual ~NotificationService() = default;

    // Sync method. This signature is used by the client side; the service side
    // should implement the signature with callback below.

    virtual bool GetPermissionStatus(::blink::mojom::blink::PermissionStatus* out_status);

    using GetPermissionStatusCallback = base::OnceCallback<void(::blink::mojom::blink::PermissionStatus)>;

    virtual void GetPermissionStatus(GetPermissionStatusCallback callback) = 0;

    virtual void DisplayNonPersistentNotification(const WTF::String& token, ::blink::mojom::blink::NotificationDataPtr notification_data,
        ::blink::mojom::blink::NotificationResourcesPtr notification_resources, ::mojo::PendingRemote<NonPersistentNotificationListener> event_listener)
        = 0;

    virtual void CloseNonPersistentNotification(const WTF::String& token) = 0;

    using DisplayPersistentNotificationCallback = base::OnceCallback<void(PersistentNotificationError)>;

    virtual void DisplayPersistentNotification(int64_t service_worker_registration_id, ::blink::mojom::blink::NotificationDataPtr notification_data,
        ::blink::mojom::blink::NotificationResourcesPtr notification_resources, DisplayPersistentNotificationCallback callback)
        = 0;

    virtual void ClosePersistentNotification(const WTF::String& notification_id) = 0;

    using GetNotificationsCallback = base::OnceCallback<void(const WTF::Vector<WTF::String>&, WTF::Vector<::blink::mojom::blink::NotificationDataPtr>)>;

    virtual void GetNotifications(
        int64_t service_worker_registration_id, const WTF::String& filter_tag, bool include_triggered, GetNotificationsCallback callback)
        = 0;
};

//class PLATFORM_EXPORT NonPersistentNotificationListenerProxy : public NonPersistentNotificationListener {
//public:
//    using InterfaceType = NonPersistentNotificationListener;
//
//    explicit NonPersistentNotificationListenerProxy(mojo::MessageReceiverWithResponder* receiver);
//
//    void OnShow() final;
//
//    void OnClick(OnClickCallback callback) final;
//
//    void OnClose(OnCloseCallback callback) final;
//
//private:
//    mojo::MessageReceiverWithResponder* receiver_;
//};

//class PLATFORM_EXPORT NotificationServiceProxy : public NotificationService {
//public:
//    using InterfaceType = NotificationService;
//
//    explicit NotificationServiceProxy(mojo::MessageReceiverWithResponder* receiver);
//
//    bool GetPermissionStatus(::blink::mojom::blink::PermissionStatus* out_status) final;
//
//    void GetPermissionStatus(GetPermissionStatusCallback callback) final;
//
//    void DisplayNonPersistentNotification(const WTF::String& token, ::blink::mojom::blink::NotificationDataPtr notification_data,
//        ::blink::mojom::blink::NotificationResourcesPtr notification_resources, ::mojo::PendingRemote<NonPersistentNotificationListener> event_listener) final;
//
//    void CloseNonPersistentNotification(const WTF::String& token) final;
//
//    void DisplayPersistentNotification(int64_t service_worker_registration_id, ::blink::mojom::blink::NotificationDataPtr notification_data,
//        ::blink::mojom::blink::NotificationResourcesPtr notification_resources, DisplayPersistentNotificationCallback callback) final;
//
//    void ClosePersistentNotification(const WTF::String& notification_id) final;
//
//    void GetNotifications(
//        int64_t service_worker_registration_id, const WTF::String& filter_tag, bool include_triggered, GetNotificationsCallback callback) final;
//
//private:
//    mojo::MessageReceiverWithResponder* receiver_;
//};
//class PLATFORM_EXPORT NonPersistentNotificationListenerStubDispatch {
//public:
//    static bool Accept(NonPersistentNotificationListener* impl, mojo::Message* message);
//    static bool AcceptWithResponder(
//        NonPersistentNotificationListener* impl, mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
//};

//template <typename ImplRefTraits = mojo::RawPtrImplRefTraits<NonPersistentNotificationListener>>
//class NonPersistentNotificationListenerStub : public mojo::MessageReceiverWithResponderStatus {
//public:
//    using ImplPointerType = typename ImplRefTraits::PointerType;
//
//    NonPersistentNotificationListenerStub() = default;
//    ~NonPersistentNotificationListenerStub() override = default;
//
//    void set_sink(ImplPointerType sink)
//    {
//        sink_ = std::move(sink);
//    }
//    ImplPointerType& sink()
//    {
//        return sink_;
//    }
//
//    bool Accept(mojo::Message* message) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return NonPersistentNotificationListenerStubDispatch::Accept(ImplRefTraits::GetRawPointer(&sink_), message);
//    }
//
//    bool AcceptWithResponder(mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return NonPersistentNotificationListenerStubDispatch::AcceptWithResponder(ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
//    }
//
//private:
//    ImplPointerType sink_;
//};
//class PLATFORM_EXPORT NotificationServiceStubDispatch {
//public:
//    static bool Accept(NotificationService* impl, mojo::Message* message);
//    static bool AcceptWithResponder(NotificationService* impl, mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
//};

//template <typename ImplRefTraits = mojo::RawPtrImplRefTraits<NotificationService>>
//class NotificationServiceStub : public mojo::MessageReceiverWithResponderStatus {
//public:
//    using ImplPointerType = typename ImplRefTraits::PointerType;
//
//    NotificationServiceStub() = default;
//    ~NotificationServiceStub() override = default;
//
//    void set_sink(ImplPointerType sink)
//    {
//        sink_ = std::move(sink);
//    }
//    ImplPointerType& sink()
//    {
//        return sink_;
//    }
//
//    bool Accept(mojo::Message* message) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return NotificationServiceStubDispatch::Accept(ImplRefTraits::GetRawPointer(&sink_), message);
//    }
//
//    bool AcceptWithResponder(mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return NotificationServiceStubDispatch::AcceptWithResponder(ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
//    }
//
//private:
//    ImplPointerType sink_;
//};
//class PLATFORM_EXPORT NonPersistentNotificationListenerRequestValidator : public mojo::MessageReceiver {
//public:
//    bool Accept(mojo::Message* message) override;
//};
//class PLATFORM_EXPORT NotificationServiceRequestValidator : public mojo::MessageReceiver {
//public:
//    bool Accept(mojo::Message* message) override;
//};
//class PLATFORM_EXPORT NonPersistentNotificationListenerResponseValidator : public mojo::MessageReceiver {
//public:
//    bool Accept(mojo::Message* message) override;
//};
//class PLATFORM_EXPORT NotificationServiceResponseValidator : public mojo::MessageReceiver {
//public:
//    bool Accept(mojo::Message* message) override;
//};

} // blink::mojom::blink

namespace mojo {

} // namespace mojo

#endif // THIRD_PARTY_BLINK_PUBLIC_MOJOM_NOTIFICATIONS_NOTIFICATION_SERVICE_MOJOM_BLINK_H_
