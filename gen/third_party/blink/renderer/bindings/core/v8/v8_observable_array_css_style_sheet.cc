// Copyright 2019 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// DO NOT EDIT: This file is auto-generated by
// //third_party/blink/renderer/bindings/scripts/generate_bindings.py
//
// Use the GN flag `blink_enable_generated_code_formatting=true` to enable
// formatting of the generated files.

#include "third_party/blink/renderer/bindings/core/v8/v8_observable_array_css_style_sheet.h"

#include "third_party/blink/renderer/bindings/core/v8/generated_code_helper.h"
#include "third_party/blink/renderer/bindings/core/v8/observable_array_exotic_object_handler.h"
#include "third_party/blink/renderer/core/css/css_style_sheet.h"
#include "third_party/blink/renderer/platform/bindings/v8_binding.h"

namespace blink {

// static
const WrapperTypeInfo V8ObservableArrayCSSStyleSheet::wrapper_type_info_body_ {
    gin::kEmbedderBlink,
    V8ObservableArrayCSSStyleSheet::InstallObservableArrayBackingListTemplate,
    nullptr,
    "V8ObservableArrayCSSStyleSheet",
    nullptr, // parent_class
    kDOMWrappersTag,
    kDOMWrappersTag,
    WrapperTypeInfo::kWrapperTypeNoPrototype,
    WrapperTypeInfo::kObjectClassId,
    WrapperTypeInfo::kNotInheritFromActiveScriptWrappable,
    WrapperTypeInfo::kIdlObservableArray,
};

// static
const WrapperTypeInfo& V8ObservableArrayCSSStyleSheet::wrapper_type_info_ = V8ObservableArrayCSSStyleSheet::wrapper_type_info_body_;

template class bindings::ObservableArrayExoticObjectHandler<V8ObservableArrayCSSStyleSheet, CSSStyleSheet>;

class V8ObservableArrayCSSStyleSheet::Handler final : public bindings::ObservableArrayExoticObjectHandler<V8ObservableArrayCSSStyleSheet, CSSStyleSheet> { };

V8ObservableArrayCSSStyleSheet::V8ObservableArrayCSSStyleSheet(
    GarbageCollectedMixin* platform_object, SetAlgorithmCallback set_algorithm_callback, DeleteAlgorithmCallback delete_algorithm_callback)
    : BaseClass(platform_object)
    , set_algorithm_callback_(set_algorithm_callback)
    , delete_algorithm_callback_(delete_algorithm_callback)
{
}

void V8ObservableArrayCSSStyleSheet::PerformAttributeSet(ScriptState* script_state, v8::Local<v8::Value> v8_value, ExceptionState& exception_state)
{
    Handler::PerformAttributeSet(script_state, *this, v8_value, exception_state);
}

v8::Local<v8::FunctionTemplate> V8ObservableArrayCSSStyleSheet::GetProxyHandlerFunctionTemplate(ScriptState* script_state)
{
    // Make `template_key` unique for `FindV8Template`.
    static const char kTemplateKeyTag = 0;
    const void* const template_key = &kTemplateKeyTag;

    v8::Isolate* isolate = script_state->GetIsolate();
    V8PerIsolateData* per_isolate_data = V8PerIsolateData::From(isolate);
    const DOMWrapperWorld& world = script_state->World();
    v8::Local<v8::Template> v8_template = per_isolate_data->FindV8Template(world, template_key);
    if (!v8_template.IsEmpty()) {
        return v8_template.As<v8::FunctionTemplate>();
    }

    v8::Local<v8::FunctionTemplate> constructor_template = v8::FunctionTemplate::New(isolate);
    v8::Local<v8::ObjectTemplate> instance_object_template = constructor_template->InstanceTemplate();
    instance_object_template->Set(V8AtomicString(isolate, "defineProperty"), v8::FunctionTemplate::New(isolate, Handler::TrapDefineProperty));
    instance_object_template->Set(V8AtomicString(isolate, "deleteProperty"), v8::FunctionTemplate::New(isolate, Handler::TrapDeleteProperty));
    instance_object_template->Set(V8AtomicString(isolate, "get"), v8::FunctionTemplate::New(isolate, Handler::TrapGet));
    instance_object_template->Set(
        V8AtomicString(isolate, "getOwnPropertyDescriptor"), v8::FunctionTemplate::New(isolate, Handler::TrapGetOwnPropertyDescriptor));
    instance_object_template->Set(V8AtomicString(isolate, "has"), v8::FunctionTemplate::New(isolate, Handler::TrapHas));
    instance_object_template->Set(V8AtomicString(isolate, "ownKeys"), v8::FunctionTemplate::New(isolate, Handler::TrapOwnKeys));
    instance_object_template->Set(V8AtomicString(isolate, "preventExtensions"), v8::FunctionTemplate::New(isolate, Handler::TrapPreventExtensions));
    instance_object_template->Set(V8AtomicString(isolate, "set"), v8::FunctionTemplate::New(isolate, Handler::TrapSet));

    per_isolate_data->AddV8Template(world, template_key, constructor_template);
    return constructor_template;
}

void V8ObservableArrayCSSStyleSheet::Trace(Visitor* visitor) const
{
    BaseClass::Trace(visitor);
}

void V8ObservableArrayCSSStyleSheet::InstallObservableArrayBackingListTemplate(
    v8::Isolate* isolate, const DOMWrapperWorld& world, v8::Local<v8::Template> backing_list_template)
{
    const WrapperTypeInfo* const wrapper_type_info = V8ObservableArrayCSSStyleSheet::GetStaticWrapperTypeInfo();
    v8::Local<v8::FunctionTemplate> backing_list_interface_function_template = backing_list_template.As<v8::FunctionTemplate>();
    v8::Local<v8::ObjectTemplate> backing_list_instance_object_template = backing_list_interface_function_template->InstanceTemplate();
    bindings::SetupIDLObservableArrayBackingListTemplate(
        isolate, wrapper_type_info, backing_list_instance_object_template, backing_list_interface_function_template);
}

} // namespace blink
