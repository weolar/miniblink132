// Copyright 2019 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// DO NOT EDIT: This file is auto-generated by
// //third_party/blink/renderer/bindings/scripts/generate_bindings.py
//
// Use the GN flag `blink_enable_generated_code_formatting=true` to enable
// formatting of the generated files.

#include "third_party/blink/renderer/bindings/core/v8/v8_element.h"

#include "third_party/blink/public/mojom/origin_trials/origin_trial_feature.mojom-shared.h"
#include "third_party/blink/renderer/bindings/core/v8/frozen_array.h"
#include "third_party/blink/renderer/bindings/core/v8/generated_code_helper.h"
#include "third_party/blink/renderer/bindings/core/v8/is_return_type_compatible.h"
#include "third_party/blink/renderer/bindings/core/v8/native_value_traits_impl.h"
#include "third_party/blink/renderer/bindings/core/v8/to_v8_traits.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_animation.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_aria_notification_options.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_attr.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_check_visibility_options.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_dom_rect.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_dom_rect_list.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_dom_token_list.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_event_handler_non_null.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_fullscreen_options.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_get_animations_options.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_get_html_options.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_get_inner_html_options.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_html_collection.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_html_slot_element.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_keyframe_animation_options.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_named_node_map.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_node.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_node_list.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_pointer_lock_options.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_scroll_into_view_options.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_scroll_to_options.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_set_html_options.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_set_return_value_for_core.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_shadow_root.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_shadow_root_init.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_style_property_map_read_only.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_trusted_html.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_trusted_script.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_trusted_script_url.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_union_boolean_scrollintoviewoptions.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_union_keyframeanimationoptions_unrestricteddouble.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_union_node_string_trustedscript.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_union_trustedhtml_trustedscript_trustedscripturl.h"
#include "third_party/blink/renderer/core/animation/animation.h"
#include "third_party/blink/renderer/core/css/cssom/element_computed_style_map.h"
#include "third_party/blink/renderer/core/css/cssom/style_property_map_read_only.h"
#include "third_party/blink/renderer/core/dom/attr.h"
#include "third_party/blink/renderer/core/dom/dom_token_list.h"
#include "third_party/blink/renderer/core/dom/element.h"
#include "third_party/blink/renderer/core/dom/named_node_map.h"
#include "third_party/blink/renderer/core/dom/node.h"
#include "third_party/blink/renderer/core/dom/node_list.h"
#include "third_party/blink/renderer/core/dom/shadow_root.h"
#include "third_party/blink/renderer/core/execution_context/execution_context.h"
#include "third_party/blink/renderer/core/frame/web_feature.h"
#include "third_party/blink/renderer/core/fullscreen/element_fullscreen.h"
#include "third_party/blink/renderer/core/geometry/dom_rect.h"
#include "third_party/blink/renderer/core/geometry/dom_rect_list.h"
#include "third_party/blink/renderer/core/html/custom/ce_reactions_scope.h"
#include "third_party/blink/renderer/core/html/html_collection.h"
#include "third_party/blink/renderer/core/html/html_slot_element.h"
#include "third_party/blink/renderer/core/html_names.h"
#include "third_party/blink/renderer/core/trustedtypes/trusted_html.h"
#include "third_party/blink/renderer/core/trustedtypes/trusted_script.h"
#include "third_party/blink/renderer/core/trustedtypes/trusted_script_url.h"
#include "third_party/blink/renderer/platform/bindings/cooperative_scheduling_helpers.h"
#include "third_party/blink/renderer/platform/bindings/exception_messages.h"
#include "third_party/blink/renderer/platform/bindings/idl_member_installer.h"
#include "third_party/blink/renderer/platform/bindings/runtime_call_stats.h"
#include "third_party/blink/renderer/platform/bindings/v8_binding.h"
#include "third_party/blink/renderer/platform/bindings/v8_dom_activity_logger.h"
#include "third_party/blink/renderer/platform/bindings/v8_per_context_data.h"
#include "third_party/blink/renderer/platform/bindings/wrapper_type_info.h"
#include "third_party/blink/renderer/platform/instrumentation/use_counter.h"

namespace blink {

bool V8Element::IsExposed(ExecutionContext* execution_context)
{

    return execution_context->IsWindow();
}

// Construction of WrapperTypeInfo may require non-trivial initialization due
// to cross-component address resolution in order to load the pointer to the
// parent interface's WrapperTypeInfo.  We ignore this issue because the issue
// happens only on component builds and the official release builds
// (statically-linked builds) are never affected by this issue.
#if defined(COMPONENT_BUILD) && defined(WIN32) && defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wglobal-constructors"
#endif

const WrapperTypeInfo V8Element::wrapper_type_info_ {
    gin::kEmbedderBlink,
    V8Element::InstallInterfaceTemplate,
    V8Element::InstallContextDependentProperties,
    "Element",
    V8Node::GetWrapperTypeInfo(),
    V8Element::kThisTag,
    V8Element::kMaxSubclassTag,
    WrapperTypeInfo::kWrapperTypeObjectPrototype,
    WrapperTypeInfo::kNodeClassId,
    WrapperTypeInfo::kNotInheritFromActiveScriptWrappable,
    WrapperTypeInfo::kIdlInterface,
    false,
};

#if defined(COMPONENT_BUILD) && defined(WIN32) && defined(__clang__)
#pragma clang diagnostic pop
#endif

const WrapperTypeInfo& Element::wrapper_type_info_ = V8Element::wrapper_type_info_;

// non-[ActiveScriptWrappable]
static_assert(!std::is_base_of<ActiveScriptWrappableBase, Element>::value,
    "Element inherits from ActiveScriptWrappable<> without "
    "[ActiveScriptWrappable] extended attribute.");

namespace {

namespace v8_element {

void NamespaceURIAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_namespaceURI_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.namespaceURI.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->namespaceURI();
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void PrefixAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_prefix_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.prefix.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->prefix();
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void LocalNameAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_localName_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.localName.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->localName();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void TagNameAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_tagName_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.tagName.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->tagName();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void IdAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_id_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.id.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->GetIdAttribute();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void IdAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_id_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.id.set");

    const char* const class_like_name = "Element";
    const char* const property_name = "id";
    bindings::PerformAttributeSetCEReactionsReflectTypeString(info, html_names::kIdAttr, class_like_name, property_name);
}

void ClassNameAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_className_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.className.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->GetClassAttribute();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void ClassNameAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_className_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.className.set");

    const char* const class_like_name = "Element";
    const char* const property_name = "className";
    bindings::PerformAttributeSetCEReactionsReflectTypeString(info, html_names::kClassAttr, class_like_name, property_name);
}

void ClassListAttributeGetCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_classList_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.classList.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->classList();
    static_assert(bindings::IsReturnTypeCompatible<DOMTokenList, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::kMainWorld);
}

void ClassListAttributeSetCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_classList_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.classList.set");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    // [PutForwards]
    v8::Local<v8::Value> target;
    v8::Local<v8::Object> v8_receiver = info.This();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    const char* const property_name = "classList";
    if (!v8_receiver->Get(current_context, V8AtomicString(isolate, property_name)).ToLocal(&target)) {
        return;
    }
    if (!target->IsObject()) {
        V8ThrowException::ThrowTypeError(isolate, "The attribute value is not an object");
        return;
    }
    bool did_set;
    v8::Local<v8::Value> v8_property_value = info[0];
    if (!target.As<v8::Object>()->Set(current_context, V8AtomicString(isolate, "value"), v8_property_value).To(&did_set)) {
        return;
    }
    return;
}

void ClassListAttributeGetCallbackForNonMainWorlds(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_classList_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.classList.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->classList();
    static_assert(bindings::IsReturnTypeCompatible<DOMTokenList, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void ClassListAttributeSetCallbackForNonMainWorlds(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_classList_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.classList.set");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    // [PutForwards]
    v8::Local<v8::Value> target;
    v8::Local<v8::Object> v8_receiver = info.This();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    const char* const property_name = "classList";
    if (!v8_receiver->Get(current_context, V8AtomicString(isolate, property_name)).ToLocal(&target)) {
        return;
    }
    if (!target->IsObject()) {
        V8ThrowException::ThrowTypeError(isolate, "The attribute value is not an object");
        return;
    }
    bool did_set;
    v8::Local<v8::Value> v8_property_value = info[0];
    if (!target.As<v8::Object>()->Set(current_context, V8AtomicString(isolate, "value"), v8_property_value).To(&did_set)) {
        return;
    }
    return;
}

void SlotAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_slot_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.slot.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->FastGetAttribute(html_names::kSlotAttr);
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void SlotAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_slot_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.slot.set");

    const char* const class_like_name = "Element";
    const char* const property_name = "slot";
    bindings::PerformAttributeSetCEReactionsReflectTypeString(info, html_names::kSlotAttr, class_like_name, property_name);
}

void AttributesAttributeGetCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_attributes_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.attributes.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->attributesForBindings();
    static_assert(bindings::IsReturnTypeCompatible<NamedNodeMap, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::kMainWorld);
}

void AttributesAttributeGetCallbackForNonMainWorlds(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_attributes_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.attributes.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->attributesForBindings();
    static_assert(bindings::IsReturnTypeCompatible<NamedNodeMap, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void ShadowRootAttributeGetCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_shadowRoot_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.shadowRoot.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->OpenShadowRoot();
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<ShadowRoot>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::kMainWorld);
}

void ShadowRootAttributeGetCallbackForNonMainWorlds(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_shadowRoot_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.shadowRoot.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->OpenShadowRoot();
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<ShadowRoot>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void PartAttributeGetCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_part_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.part.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->part();
    static_assert(bindings::IsReturnTypeCompatible<DOMTokenList, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::kMainWorld);
}

void PartAttributeSetCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_part_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.part.set");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    // [PutForwards]
    v8::Local<v8::Value> target;
    v8::Local<v8::Object> v8_receiver = info.This();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    const char* const property_name = "part";
    if (!v8_receiver->Get(current_context, V8AtomicString(isolate, property_name)).ToLocal(&target)) {
        return;
    }
    if (!target->IsObject()) {
        V8ThrowException::ThrowTypeError(isolate, "The attribute value is not an object");
        return;
    }
    bool did_set;
    v8::Local<v8::Value> v8_property_value = info[0];
    if (!target.As<v8::Object>()->Set(current_context, V8AtomicString(isolate, "value"), v8_property_value).To(&did_set)) {
        return;
    }
    return;
}

void PartAttributeGetCallbackForNonMainWorlds(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_part_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.part.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->part();
    static_assert(bindings::IsReturnTypeCompatible<DOMTokenList, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void PartAttributeSetCallbackForNonMainWorlds(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_part_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.part.set");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    // [PutForwards]
    v8::Local<v8::Value> target;
    v8::Local<v8::Object> v8_receiver = info.This();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    const char* const property_name = "part";
    if (!v8_receiver->Get(current_context, V8AtomicString(isolate, property_name)).ToLocal(&target)) {
        return;
    }
    if (!target->IsObject()) {
        V8ThrowException::ThrowTypeError(isolate, "The attribute value is not an object");
        return;
    }
    bool did_set;
    v8::Local<v8::Value> v8_property_value = info[0];
    if (!target.As<v8::Object>()->Set(current_context, V8AtomicString(isolate, "value"), v8_property_value).To(&did_set)) {
        return;
    }
    return;
}

void AssignedSlotAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_assignedSlot_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.assignedSlot.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->assignedSlotForBinding();
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<HTMLSlotElement>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void InnerHTMLAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE(info.GetIsolate(), RuntimeCallStats::CounterId::kElementInnerHTML_Getter);
    BLINK_BINDINGS_TRACE_EVENT("Element.innerHTML.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->innerHTML();
    static_assert(bindings::IsReturnTypeCompatible<IDLStringLegacyNullToEmptyStringStringContextTrustedHTML, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void InnerHTMLAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE(info.GetIsolate(), RuntimeCallStats::CounterId::kElementInnerHTML_Setter);
    BLINK_BINDINGS_TRACE_EVENT("Element.innerHTML.set");

    v8::Isolate* isolate = info.GetIsolate();
    ExceptionState exception_state(isolate);

    // [CEReactions]
    CEReactionsScope ce_reactions_scope;

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    v8::Local<v8::Value> v8_property_value = info[0];
    const char* const class_like_name = "Element";
    const char* const property_name = "innerHTML";
    ExecutionContext* execution_context_of_document_tree = bindings::ExecutionContextFromV8Wrappable(blink_receiver);
    auto&& arg1_value = NativeValueTraits<IDLStringLegacyNullToEmptyStringStringContextTrustedHTML>::NativeValue(
        isolate, v8_property_value, exception_state, class_like_name, property_name, execution_context_of_document_tree);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setInnerHTML(arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void OuterHTMLAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_outerHTML_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.outerHTML.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->outerHTML();
    static_assert(bindings::IsReturnTypeCompatible<IDLStringLegacyNullToEmptyStringStringContextTrustedHTML, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void OuterHTMLAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_outerHTML_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.outerHTML.set");

    v8::Isolate* isolate = info.GetIsolate();
    ExceptionState exception_state(isolate);

    // [CEReactions]
    CEReactionsScope ce_reactions_scope;

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    v8::Local<v8::Value> v8_property_value = info[0];
    const char* const class_like_name = "Element";
    const char* const property_name = "outerHTML";
    ExecutionContext* execution_context_of_document_tree = bindings::ExecutionContextFromV8Wrappable(blink_receiver);
    auto&& arg1_value = NativeValueTraits<IDLStringLegacyNullToEmptyStringStringContextTrustedHTML>::NativeValue(
        isolate, v8_property_value, exception_state, class_like_name, property_name, execution_context_of_document_tree);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setOuterHTML(arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void ScrollTopAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_scrollTop_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.scrollTop.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->scrollTop();
    static_assert(bindings::IsReturnTypeCompatible<IDLUnrestrictedDouble, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<double>());
}

void ScrollTopAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_scrollTop_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.scrollTop.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLUnrestrictedDouble>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setScrollTop(arg1_value);
}

void ScrollLeftAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_scrollLeft_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.scrollLeft.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->scrollLeft();
    static_assert(bindings::IsReturnTypeCompatible<IDLUnrestrictedDouble, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<double>());
}

void ScrollLeftAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_scrollLeft_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.scrollLeft.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLUnrestrictedDouble>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setScrollLeft(arg1_value);
}

void ScrollWidthAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_scrollWidth_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.scrollWidth.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->scrollWidth();
    static_assert(bindings::IsReturnTypeCompatible<IDLLong, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<int32_t>());
}

void ScrollHeightAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_scrollHeight_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.scrollHeight.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->scrollHeight();
    static_assert(bindings::IsReturnTypeCompatible<IDLLong, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<int32_t>());
}

void ClientTopAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_clientTop_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.clientTop.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->clientTop();
    static_assert(bindings::IsReturnTypeCompatible<IDLLong, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<int32_t>());
}

void ClientLeftAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_clientLeft_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.clientLeft.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->clientLeft();
    static_assert(bindings::IsReturnTypeCompatible<IDLLong, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<int32_t>());
}

void ClientWidthAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_clientWidth_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.clientWidth.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->clientWidth();
    static_assert(bindings::IsReturnTypeCompatible<IDLLong, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<int32_t>());
}

void ClientHeightAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_clientHeight_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.clientHeight.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->clientHeight();
    static_assert(bindings::IsReturnTypeCompatible<IDLLong, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<int32_t>());
}

void CurrentCSSZoomAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_currentCSSZoom_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.currentCSSZoom.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->currentCSSZoom();
    static_assert(bindings::IsReturnTypeCompatible<IDLDouble, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<double>());
}

void AnchorElementAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_anchorElement_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.anchorElement.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->anchorElementForBinding();
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<Element>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void AnchorElementAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_anchorElement_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.anchorElement.set");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    ExceptionState exception_state(isolate);

    // [CEReactions]
    CEReactionsScope ce_reactions_scope;

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    v8::Local<v8::Value> v8_property_value = info[0];
    auto&& arg1_value = NativeValueTraits<IDLNullable<Element>>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setAnchorElementForBinding(arg1_value);
}

void ComputedRoleAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_computedRole_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.computedRole.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->computedRole();
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void ComputedNameAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_computedName_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.computedName.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->computedName();
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void OnbeforecopyAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_onbeforecopy_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.onbeforecopy.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onbeforecopy();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnbeforecopyAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_onbeforecopy_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.onbeforecopy.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnbeforecopy(event_handler);
}

void OnbeforecutAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_onbeforecut_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.onbeforecut.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onbeforecut();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnbeforecutAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_onbeforecut_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.onbeforecut.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnbeforecut(event_handler);
}

void OnbeforepasteAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_onbeforepaste_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.onbeforepaste.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onbeforepaste();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnbeforepasteAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_onbeforepaste_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.onbeforepaste.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnbeforepaste(event_handler);
}

void OnsearchAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_onsearch_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.onsearch.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onsearch();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnsearchAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_onsearch_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.onsearch.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnsearch(event_handler);
}

void ElementTimingAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_elementTiming_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.elementTiming.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->FastGetAttribute(html_names::kElementtimingAttr);
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void ElementTimingAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_elementTiming_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.elementTiming.set");

    const char* const class_like_name = "Element";
    const char* const property_name = "elementTiming";
    bindings::PerformAttributeSetCEReactionsReflectTypeString(info, html_names::kElementtimingAttr, class_like_name, property_name);
}

void OnfullscreenchangeAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_onfullscreenchange_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.onfullscreenchange.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = ElementFullscreen::onfullscreenchange(*blink_receiver);
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnfullscreenchangeAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_onfullscreenchange_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.onfullscreenchange.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    ElementFullscreen::setOnfullscreenchange(*blink_receiver, event_handler);
}

void OnfullscreenerrorAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_onfullscreenerror_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.onfullscreenerror.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = ElementFullscreen::onfullscreenerror(*blink_receiver);
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnfullscreenerrorAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_onfullscreenerror_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.onfullscreenerror.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    ElementFullscreen::setOnfullscreenerror(*blink_receiver, event_handler);
}

void OnwebkitfullscreenchangeAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_onwebkitfullscreenchange_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.onwebkitfullscreenchange.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = ElementFullscreen::onwebkitfullscreenchange(*blink_receiver);
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnwebkitfullscreenchangeAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_onwebkitfullscreenchange_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.onwebkitfullscreenchange.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    ElementFullscreen::setOnwebkitfullscreenchange(*blink_receiver, event_handler);
}

void OnwebkitfullscreenerrorAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_onwebkitfullscreenerror_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.onwebkitfullscreenerror.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = ElementFullscreen::onwebkitfullscreenerror(*blink_receiver);
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnwebkitfullscreenerrorAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_onwebkitfullscreenerror_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.onwebkitfullscreenerror.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    ElementFullscreen::setOnwebkitfullscreenerror(*blink_receiver, event_handler);
}

void RoleAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_role_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.role.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->FastGetAttribute(html_names::kRoleAttr);
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void RoleAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_role_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.role.set");

    const char* const class_like_name = "Element";
    const char* const property_name = "role";
    bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kRoleAttr, class_like_name, property_name);
}

void AriaAtomicAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaAtomic_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaAtomic.get");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaAtomicAttr);
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaAtomicAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaAtomic_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaAtomic.set");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    const char* const class_like_name = "Element";
    const char* const property_name = "ariaAtomic";
    bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaAtomicAttr, class_like_name, property_name);
}

void AriaAutoCompleteAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaAutoComplete_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaAutoComplete.get");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaAutocompleteAttr);
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaAutoCompleteAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaAutoComplete_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaAutoComplete.set");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    const char* const class_like_name = "Element";
    const char* const property_name = "ariaAutoComplete";
    bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaAutocompleteAttr, class_like_name, property_name);
}

void AriaBusyAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaBusy_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaBusy.get");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaBusyAttr);
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaBusyAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaBusy_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaBusy.set");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    const char* const class_like_name = "Element";
    const char* const property_name = "ariaBusy";
    bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaBusyAttr, class_like_name, property_name);
}

void AriaBrailleLabelAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaBrailleLabel_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaBrailleLabel.get");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaBraillelabelAttr);
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaBrailleLabelAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaBrailleLabel_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaBrailleLabel.set");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    const char* const class_like_name = "Element";
    const char* const property_name = "ariaBrailleLabel";
    bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaBraillelabelAttr, class_like_name, property_name);
}

void AriaBrailleRoleDescriptionAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaBrailleRoleDescription_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaBrailleRoleDescription.get");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaBrailleroledescriptionAttr);
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaBrailleRoleDescriptionAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaBrailleRoleDescription_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaBrailleRoleDescription.set");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    const char* const class_like_name = "Element";
    const char* const property_name = "ariaBrailleRoleDescription";
    bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaBrailleroledescriptionAttr, class_like_name, property_name);
}

void AriaCheckedAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaChecked_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaChecked.get");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaCheckedAttr);
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaCheckedAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaChecked_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaChecked.set");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    const char* const class_like_name = "Element";
    const char* const property_name = "ariaChecked";
    bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaCheckedAttr, class_like_name, property_name);
}

void AriaColCountAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaColCount_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaColCount.get");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaColcountAttr);
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaColCountAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaColCount_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaColCount.set");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    const char* const class_like_name = "Element";
    const char* const property_name = "ariaColCount";
    bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaColcountAttr, class_like_name, property_name);
}

void AriaColIndexAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaColIndex_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaColIndex.get");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaColindexAttr);
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaColIndexAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaColIndex_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaColIndex.set");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    const char* const class_like_name = "Element";
    const char* const property_name = "ariaColIndex";
    bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaColindexAttr, class_like_name, property_name);
}

void AriaColIndexTextAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaColIndexText_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaColIndexText.get");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaColindextextAttr);
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaColIndexTextAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaColIndexText_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaColIndexText.set");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    const char* const class_like_name = "Element";
    const char* const property_name = "ariaColIndexText";
    bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaColindextextAttr, class_like_name, property_name);
}

void AriaColSpanAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaColSpan_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaColSpan.get");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaColspanAttr);
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaColSpanAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaColSpan_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaColSpan.set");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    const char* const class_like_name = "Element";
    const char* const property_name = "ariaColSpan";
    bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaColspanAttr, class_like_name, property_name);
}

void AriaCurrentAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaCurrent_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaCurrent.get");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaCurrentAttr);
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaCurrentAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaCurrent_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaCurrent.set");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    const char* const class_like_name = "Element";
    const char* const property_name = "ariaCurrent";
    bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaCurrentAttr, class_like_name, property_name);
}

void AriaDescriptionAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaDescription_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaDescription.get");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaDescriptionAttr);
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaDescriptionAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaDescription_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaDescription.set");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    const char* const class_like_name = "Element";
    const char* const property_name = "ariaDescription";
    bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaDescriptionAttr, class_like_name, property_name);
}

void AriaDisabledAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaDisabled_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaDisabled.get");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaDisabledAttr);
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaDisabledAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaDisabled_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaDisabled.set");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    const char* const class_like_name = "Element";
    const char* const property_name = "ariaDisabled";
    bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaDisabledAttr, class_like_name, property_name);
}

void AriaExpandedAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaExpanded_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaExpanded.get");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaExpandedAttr);
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaExpandedAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaExpanded_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaExpanded.set");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    const char* const class_like_name = "Element";
    const char* const property_name = "ariaExpanded";
    bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaExpandedAttr, class_like_name, property_name);
}

void AriaHasPopupAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaHasPopup_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaHasPopup.get");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaHaspopupAttr);
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaHasPopupAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaHasPopup_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaHasPopup.set");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    const char* const class_like_name = "Element";
    const char* const property_name = "ariaHasPopup";
    bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaHaspopupAttr, class_like_name, property_name);
}

void AriaHiddenAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaHidden_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaHidden.get");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaHiddenAttr);
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaHiddenAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaHidden_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaHidden.set");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    const char* const class_like_name = "Element";
    const char* const property_name = "ariaHidden";
    bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaHiddenAttr, class_like_name, property_name);
}

void AriaInvalidAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaInvalid_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaInvalid.get");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaInvalidAttr);
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaInvalidAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaInvalid_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaInvalid.set");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    const char* const class_like_name = "Element";
    const char* const property_name = "ariaInvalid";
    bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaInvalidAttr, class_like_name, property_name);
}

void AriaKeyShortcutsAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaKeyShortcuts_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaKeyShortcuts.get");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaKeyshortcutsAttr);
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaKeyShortcutsAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaKeyShortcuts_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaKeyShortcuts.set");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    const char* const class_like_name = "Element";
    const char* const property_name = "ariaKeyShortcuts";
    bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaKeyshortcutsAttr, class_like_name, property_name);
}

void AriaLabelAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaLabel_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaLabel.get");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaLabelAttr);
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaLabelAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaLabel_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaLabel.set");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    const char* const class_like_name = "Element";
    const char* const property_name = "ariaLabel";
    bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaLabelAttr, class_like_name, property_name);
}

void AriaLevelAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaLevel_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaLevel.get");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaLevelAttr);
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaLevelAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaLevel_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaLevel.set");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    const char* const class_like_name = "Element";
    const char* const property_name = "ariaLevel";
    bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaLevelAttr, class_like_name, property_name);
}

void AriaLiveAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaLive_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaLive.get");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaLiveAttr);
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaLiveAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaLive_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaLive.set");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    const char* const class_like_name = "Element";
    const char* const property_name = "ariaLive";
    bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaLiveAttr, class_like_name, property_name);
}

void AriaModalAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaModal_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaModal.get");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaModalAttr);
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaModalAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaModal_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaModal.set");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    const char* const class_like_name = "Element";
    const char* const property_name = "ariaModal";
    bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaModalAttr, class_like_name, property_name);
}

void AriaMultiLineAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaMultiLine_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaMultiLine.get");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaMultilineAttr);
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaMultiLineAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaMultiLine_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaMultiLine.set");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    const char* const class_like_name = "Element";
    const char* const property_name = "ariaMultiLine";
    bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaMultilineAttr, class_like_name, property_name);
}

void AriaMultiSelectableAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaMultiSelectable_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaMultiSelectable.get");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaMultiselectableAttr);
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaMultiSelectableAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaMultiSelectable_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaMultiSelectable.set");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    const char* const class_like_name = "Element";
    const char* const property_name = "ariaMultiSelectable";
    bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaMultiselectableAttr, class_like_name, property_name);
}

void AriaOrientationAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaOrientation_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaOrientation.get");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaOrientationAttr);
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaOrientationAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaOrientation_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaOrientation.set");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    const char* const class_like_name = "Element";
    const char* const property_name = "ariaOrientation";
    bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaOrientationAttr, class_like_name, property_name);
}

void AriaPlaceholderAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaPlaceholder_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaPlaceholder.get");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaPlaceholderAttr);
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaPlaceholderAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaPlaceholder_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaPlaceholder.set");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    const char* const class_like_name = "Element";
    const char* const property_name = "ariaPlaceholder";
    bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaPlaceholderAttr, class_like_name, property_name);
}

void AriaPosInSetAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaPosInSet_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaPosInSet.get");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaPosinsetAttr);
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaPosInSetAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaPosInSet_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaPosInSet.set");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    const char* const class_like_name = "Element";
    const char* const property_name = "ariaPosInSet";
    bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaPosinsetAttr, class_like_name, property_name);
}

void AriaPressedAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaPressed_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaPressed.get");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaPressedAttr);
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaPressedAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaPressed_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaPressed.set");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    const char* const class_like_name = "Element";
    const char* const property_name = "ariaPressed";
    bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaPressedAttr, class_like_name, property_name);
}

void AriaReadOnlyAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaReadOnly_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaReadOnly.get");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaReadonlyAttr);
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaReadOnlyAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaReadOnly_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaReadOnly.set");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    const char* const class_like_name = "Element";
    const char* const property_name = "ariaReadOnly";
    bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaReadonlyAttr, class_like_name, property_name);
}

void AriaRelevantAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaRelevant_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaRelevant.get");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaRelevantAttr);
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaRelevantAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaRelevant_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaRelevant.set");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    const char* const class_like_name = "Element";
    const char* const property_name = "ariaRelevant";
    bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaRelevantAttr, class_like_name, property_name);
}

void AriaRequiredAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaRequired_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaRequired.get");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaRequiredAttr);
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaRequiredAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaRequired_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaRequired.set");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    const char* const class_like_name = "Element";
    const char* const property_name = "ariaRequired";
    bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaRequiredAttr, class_like_name, property_name);
}

void AriaRoleDescriptionAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaRoleDescription_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaRoleDescription.get");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaRoledescriptionAttr);
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaRoleDescriptionAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaRoleDescription_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaRoleDescription.set");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    const char* const class_like_name = "Element";
    const char* const property_name = "ariaRoleDescription";
    bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaRoledescriptionAttr, class_like_name, property_name);
}

void AriaRowCountAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaRowCount_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaRowCount.get");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaRowcountAttr);
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaRowCountAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaRowCount_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaRowCount.set");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    const char* const class_like_name = "Element";
    const char* const property_name = "ariaRowCount";
    bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaRowcountAttr, class_like_name, property_name);
}

void AriaRowIndexAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaRowIndex_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaRowIndex.get");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaRowindexAttr);
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaRowIndexAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaRowIndex_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaRowIndex.set");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    const char* const class_like_name = "Element";
    const char* const property_name = "ariaRowIndex";
    bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaRowindexAttr, class_like_name, property_name);
}

void AriaRowIndexTextAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaRowIndexText_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaRowIndexText.get");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaRowindextextAttr);
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaRowIndexTextAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaRowIndexText_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaRowIndexText.set");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    const char* const class_like_name = "Element";
    const char* const property_name = "ariaRowIndexText";
    bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaRowindextextAttr, class_like_name, property_name);
}

void AriaRowSpanAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaRowSpan_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaRowSpan.get");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaRowspanAttr);
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaRowSpanAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaRowSpan_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaRowSpan.set");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    const char* const class_like_name = "Element";
    const char* const property_name = "ariaRowSpan";
    bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaRowspanAttr, class_like_name, property_name);
}

void AriaSelectedAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaSelected_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaSelected.get");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaSelectedAttr);
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaSelectedAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaSelected_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaSelected.set");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    const char* const class_like_name = "Element";
    const char* const property_name = "ariaSelected";
    bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaSelectedAttr, class_like_name, property_name);
}

void AriaSetSizeAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaSetSize_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaSetSize.get");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaSetsizeAttr);
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaSetSizeAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaSetSize_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaSetSize.set");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    const char* const class_like_name = "Element";
    const char* const property_name = "ariaSetSize";
    bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaSetsizeAttr, class_like_name, property_name);
}

void AriaSortAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaSort_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaSort.get");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaSortAttr);
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaSortAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaSort_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaSort.set");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    const char* const class_like_name = "Element";
    const char* const property_name = "ariaSort";
    bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaSortAttr, class_like_name, property_name);
}

void AriaValueMaxAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaValueMax_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaValueMax.get");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaValuemaxAttr);
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaValueMaxAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaValueMax_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaValueMax.set");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    const char* const class_like_name = "Element";
    const char* const property_name = "ariaValueMax";
    bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaValuemaxAttr, class_like_name, property_name);
}

void AriaValueMinAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaValueMin_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaValueMin.get");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaValueminAttr);
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaValueMinAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaValueMin_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaValueMin.set");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    const char* const class_like_name = "Element";
    const char* const property_name = "ariaValueMin";
    bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaValueminAttr, class_like_name, property_name);
}

void AriaValueNowAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaValueNow_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaValueNow.get");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaValuenowAttr);
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaValueNowAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaValueNow_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaValueNow.set");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    const char* const class_like_name = "Element";
    const char* const property_name = "ariaValueNow";
    bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaValuenowAttr, class_like_name, property_name);
}

void AriaValueTextAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaValueText_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaValueText.get");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaValuetextAttr);
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaValueTextAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaValueText_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaValueText.set");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    const char* const class_like_name = "Element";
    const char* const property_name = "ariaValueText";
    bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaValuetextAttr, class_like_name, property_name);
}

void AriaVirtualContentAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaVirtualContent_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaVirtualContent.get");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAriaVirtualcontentAttr);
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void AriaVirtualContentAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaVirtualContent_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaVirtualContent.set");
    v8::Isolate* isolate = info.GetIsolate();
    // [Measure], [MeasureAs]
    bindings::CountWebDXFeature(isolate, WebDXFeature::kAriaAttributeReflection);

    const char* const class_like_name = "Element";
    const char* const property_name = "ariaVirtualContent";
    bindings::PerformAttributeSetCEReactionsReflectTypeStringOrNull(info, html_names::kAriaVirtualcontentAttr, class_like_name, property_name);
}

void AriaActiveDescendantElementAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaActiveDescendantElement_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaActiveDescendantElement.get");
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kV8Element_AriaActiveDescendantElement_AttributeGetter);

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->GetElementAttribute(html_names::kAriaActivedescendantAttr);
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<Element>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void AriaActiveDescendantElementAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaActiveDescendantElement_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaActiveDescendantElement.set");
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kV8Element_AriaActiveDescendantElement_AttributeSetter);

    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    ExceptionState exception_state(isolate);

    // [CEReactions]
    CEReactionsScope ce_reactions_scope;

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    v8::Local<v8::Value> v8_property_value = info[0];
    auto&& arg1_value = NativeValueTraits<IDLNullable<Element>>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->SetElementAttribute(html_names::kAriaActivedescendantAttr, arg1_value);
}

void AriaControlsElementsAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaControlsElements_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaControlsElements.get");
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kV8Element_AriaControlsElements_AttributeGetter);

    v8::Local<v8::Object> v8_receiver = info.This();
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ariaControlsElements();
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLArray<Element>>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    v8::Local<v8::Value> v8_return_value = ToV8Traits<IDLNullable<IDLArray<Element>>>::ToV8(script_state, return_value);
    bindings::V8SetReturnValue(info, v8_return_value);
}

void AriaControlsElementsAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaControlsElements_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaControlsElements.set");
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kV8Element_AriaControlsElements_AttributeSetter);

    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    ExceptionState exception_state(isolate);

    // [CEReactions]
    CEReactionsScope ce_reactions_scope;

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    v8::Local<v8::Value> v8_property_value = info[0];
    auto&& arg1_value = NativeValueTraits<IDLNullable<IDLArray<Element>>>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setAriaControlsElements(arg1_value);
}

void AriaDescribedByElementsAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaDescribedByElements_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaDescribedByElements.get");
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kV8Element_AriaDescribedByElements_AttributeGetter);

    v8::Local<v8::Object> v8_receiver = info.This();
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ariaDescribedByElements();
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLArray<Element>>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    v8::Local<v8::Value> v8_return_value = ToV8Traits<IDLNullable<IDLArray<Element>>>::ToV8(script_state, return_value);
    bindings::V8SetReturnValue(info, v8_return_value);
}

void AriaDescribedByElementsAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaDescribedByElements_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaDescribedByElements.set");
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kV8Element_AriaDescribedByElements_AttributeSetter);

    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    ExceptionState exception_state(isolate);

    // [CEReactions]
    CEReactionsScope ce_reactions_scope;

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    v8::Local<v8::Value> v8_property_value = info[0];
    auto&& arg1_value = NativeValueTraits<IDLNullable<IDLArray<Element>>>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setAriaDescribedByElements(arg1_value);
}

void AriaDetailsElementsAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaDetailsElements_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaDetailsElements.get");
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kV8Element_AriaDetailsElements_AttributeGetter);

    v8::Local<v8::Object> v8_receiver = info.This();
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ariaDetailsElements();
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLArray<Element>>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    v8::Local<v8::Value> v8_return_value = ToV8Traits<IDLNullable<IDLArray<Element>>>::ToV8(script_state, return_value);
    bindings::V8SetReturnValue(info, v8_return_value);
}

void AriaDetailsElementsAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaDetailsElements_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaDetailsElements.set");
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kV8Element_AriaDetailsElements_AttributeSetter);

    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    ExceptionState exception_state(isolate);

    // [CEReactions]
    CEReactionsScope ce_reactions_scope;

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    v8::Local<v8::Value> v8_property_value = info[0];
    auto&& arg1_value = NativeValueTraits<IDLNullable<IDLArray<Element>>>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setAriaDetailsElements(arg1_value);
}

void AriaErrorMessageElementsAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaErrorMessageElements_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaErrorMessageElements.get");
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kV8Element_AriaErrorMessageElements_AttributeGetter);

    v8::Local<v8::Object> v8_receiver = info.This();
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ariaErrorMessageElements();
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLArray<Element>>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    v8::Local<v8::Value> v8_return_value = ToV8Traits<IDLNullable<IDLArray<Element>>>::ToV8(script_state, return_value);
    bindings::V8SetReturnValue(info, v8_return_value);
}

void AriaErrorMessageElementsAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaErrorMessageElements_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaErrorMessageElements.set");
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kV8Element_AriaErrorMessageElements_AttributeSetter);

    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    ExceptionState exception_state(isolate);

    // [CEReactions]
    CEReactionsScope ce_reactions_scope;

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    v8::Local<v8::Value> v8_property_value = info[0];
    auto&& arg1_value = NativeValueTraits<IDLNullable<IDLArray<Element>>>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setAriaErrorMessageElements(arg1_value);
}

void AriaFlowToElementsAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaFlowToElements_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaFlowToElements.get");
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kV8Element_AriaFlowToElements_AttributeGetter);

    v8::Local<v8::Object> v8_receiver = info.This();
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ariaFlowToElements();
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLArray<Element>>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    v8::Local<v8::Value> v8_return_value = ToV8Traits<IDLNullable<IDLArray<Element>>>::ToV8(script_state, return_value);
    bindings::V8SetReturnValue(info, v8_return_value);
}

void AriaFlowToElementsAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaFlowToElements_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaFlowToElements.set");
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kV8Element_AriaFlowToElements_AttributeSetter);

    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    ExceptionState exception_state(isolate);

    // [CEReactions]
    CEReactionsScope ce_reactions_scope;

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    v8::Local<v8::Value> v8_property_value = info[0];
    auto&& arg1_value = NativeValueTraits<IDLNullable<IDLArray<Element>>>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setAriaFlowToElements(arg1_value);
}

void AriaLabelledByElementsAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaLabelledByElements_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaLabelledByElements.get");
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kV8Element_AriaLabelledByElements_AttributeGetter);

    v8::Local<v8::Object> v8_receiver = info.This();
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ariaLabelledByElements();
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLArray<Element>>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    v8::Local<v8::Value> v8_return_value = ToV8Traits<IDLNullable<IDLArray<Element>>>::ToV8(script_state, return_value);
    bindings::V8SetReturnValue(info, v8_return_value);
}

void AriaLabelledByElementsAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaLabelledByElements_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaLabelledByElements.set");
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kV8Element_AriaLabelledByElements_AttributeSetter);

    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    ExceptionState exception_state(isolate);

    // [CEReactions]
    CEReactionsScope ce_reactions_scope;

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    v8::Local<v8::Value> v8_property_value = info[0];
    auto&& arg1_value = NativeValueTraits<IDLNullable<IDLArray<Element>>>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setAriaLabelledByElements(arg1_value);
}

void AriaOwnsElementsAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaOwnsElements_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaOwnsElements.get");
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kV8Element_AriaOwnsElements_AttributeGetter);

    v8::Local<v8::Object> v8_receiver = info.This();
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ariaOwnsElements();
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLArray<Element>>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    v8::Local<v8::Value> v8_return_value = ToV8Traits<IDLNullable<IDLArray<Element>>>::ToV8(script_state, return_value);
    bindings::V8SetReturnValue(info, v8_return_value);
}

void AriaOwnsElementsAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaOwnsElements_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaOwnsElements.set");
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kV8Element_AriaOwnsElements_AttributeSetter);

    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    ExceptionState exception_state(isolate);

    // [CEReactions]
    CEReactionsScope ce_reactions_scope;

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    v8::Local<v8::Value> v8_property_value = info[0];
    auto&& arg1_value = NativeValueTraits<IDLNullable<IDLArray<Element>>>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setAriaOwnsElements(arg1_value);
}

void ChildrenAttributeGetCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_children_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.children.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->children();
    static_assert(bindings::IsReturnTypeCompatible<HTMLCollection, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::kMainWorld);
}

void ChildrenAttributeGetCallbackForNonMainWorlds(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_children_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.children.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->children();
    static_assert(bindings::IsReturnTypeCompatible<HTMLCollection, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void FirstElementChildAttributeGetCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_firstElementChild_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.firstElementChild.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->firstElementChild();
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<Element>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::kMainWorld);
}

void FirstElementChildAttributeGetCallbackForNonMainWorlds(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_firstElementChild_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.firstElementChild.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->firstElementChild();
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<Element>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void LastElementChildAttributeGetCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_lastElementChild_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.lastElementChild.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->lastElementChild();
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<Element>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::kMainWorld);
}

void LastElementChildAttributeGetCallbackForNonMainWorlds(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_lastElementChild_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.lastElementChild.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->lastElementChild();
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<Element>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void ChildElementCountAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_childElementCount_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.childElementCount.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->childElementCount();
    static_assert(bindings::IsReturnTypeCompatible<IDLUnsignedLong, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<uint32_t>());
}

void PreviousElementSiblingAttributeGetCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_previousElementSibling_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.previousElementSibling.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->previousElementSibling();
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<Element>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::kMainWorld);
}

void PreviousElementSiblingAttributeGetCallbackForNonMainWorlds(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_previousElementSibling_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.previousElementSibling.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->previousElementSibling();
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<Element>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void NextElementSiblingAttributeGetCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_nextElementSibling_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.nextElementSibling.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->nextElementSibling();
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<Element>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::kMainWorld);
}

void NextElementSiblingAttributeGetCallbackForNonMainWorlds(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_nextElementSibling_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Element.nextElementSibling.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->nextElementSibling();
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<Element>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void AfterOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_after");
    BLINK_BINDINGS_TRACE_EVENT("Element.after");

    v8::Isolate* isolate = info.GetIsolate();
    ExceptionState exception_state(isolate);

    // [CEReactions]
    CEReactionsScope ce_reactions_scope;

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& arg1_nodes = bindings::VariadicArgumentsToNativeValues<V8UnionNodeOrStringOrTrustedScript>(isolate, info, 0, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->after(arg1_nodes, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void AnimateOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_animate");
    BLINK_BINDINGS_TRACE_EVENT("Element.animate");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kV8Element_Animate_Method);

    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    Animation* return_value;
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    do { // Dummy loop for use of 'break'.
        const int non_undefined_argument_length = bindings::NonUndefinedArgumentLength(info);
        ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
        ScriptState* script_state = receiver_script_state;
        auto&& arg1_keyframes = NativeValueTraits<IDLNullable<IDLObject>>::ArgumentValue(isolate, 0, info[0], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
        if (non_undefined_argument_length <= 1) {
            return_value = blink_receiver->animate(script_state, arg1_keyframes, exception_state);
            break;
        }
        auto&& arg2_options = NativeValueTraits<V8UnionKeyframeAnimationOptionsOrUnrestrictedDouble>::ArgumentValue(isolate, 1, info[1], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
        return_value = blink_receiver->animate(script_state, arg1_keyframes, arg2_options, exception_state);
    } while (false);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void AppendOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_append");
    BLINK_BINDINGS_TRACE_EVENT("Element.append");

    v8::Isolate* isolate = info.GetIsolate();
    ExceptionState exception_state(isolate);

    // [CEReactions]
    CEReactionsScope ce_reactions_scope;

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& arg1_nodes = bindings::VariadicArgumentsToNativeValues<V8UnionNodeOrStringOrTrustedScript>(isolate, info, 0, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->append(arg1_nodes, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void AriaNotifyOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_ariaNotify");
    BLINK_BINDINGS_TRACE_EVENT("Element.ariaNotify");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_announcement = NativeValueTraits<IDLString>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<AriaNotificationOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg2_options;
    if (info[1]->IsUndefined()) {
        arg2_options = AriaNotificationOptions::Create();
    } else {
        arg2_options = NativeValueTraits<AriaNotificationOptions>::ArgumentValue(isolate, 1, info[1], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    blink_receiver->ariaNotify(arg1_announcement, arg2_options);
}

void AttachShadowOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_attachShadow");
    BLINK_BINDINGS_TRACE_EVENT("Element.attachShadow");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kElementAttachShadow);

    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_shadow_root_init_dict = NativeValueTraits<ShadowRootInit>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->attachShadow(arg1_shadow_root_init_dict, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<ShadowRoot, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void BeforeOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_before");
    BLINK_BINDINGS_TRACE_EVENT("Element.before");

    v8::Isolate* isolate = info.GetIsolate();
    ExceptionState exception_state(isolate);

    // [CEReactions]
    CEReactionsScope ce_reactions_scope;

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& arg1_nodes = bindings::VariadicArgumentsToNativeValues<V8UnionNodeOrStringOrTrustedScript>(isolate, info, 0, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->before(arg1_nodes, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void CheckVisibilityOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_checkVisibility");
    BLINK_BINDINGS_TRACE_EVENT("Element.checkVisibility");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kElementCheckVisibility);

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    decltype(NativeValueTraits<CheckVisibilityOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg1_options;
    if (info[0]->IsUndefined()) {
        arg1_options = CheckVisibilityOptions::Create();
    } else {
        ExceptionState exception_state(isolate);
        arg1_options = NativeValueTraits<CheckVisibilityOptions>::ArgumentValue(isolate, 0, info[0], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->checkVisibility(arg1_options);
    static_assert(bindings::IsReturnTypeCompatible<IDLBoolean, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void ClosestOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_closest");
    BLINK_BINDINGS_TRACE_EVENT("Element.closest");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_selectors = NativeValueTraits<IDLString>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->closest(arg1_selectors, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<Element>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void ComputedStyleMapOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_computedStyleMap");
    BLINK_BINDINGS_TRACE_EVENT("Element.computedStyleMap");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kCSSTypedOMStylePropertyMap);

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = ElementComputedStyleMap::computedStyleMap(*blink_receiver);
    static_assert(bindings::IsReturnTypeCompatible<StylePropertyMapReadOnly, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void GetAnimationsOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_getAnimations");
    BLINK_BINDINGS_TRACE_EVENT("Element.getAnimations");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    decltype(NativeValueTraits<GetAnimationsOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg1_options;
    if (info[0]->IsUndefined()) {
        arg1_options = GetAnimationsOptions::Create();
    } else {
        ExceptionState exception_state(isolate);
        arg1_options = NativeValueTraits<GetAnimationsOptions>::ArgumentValue(isolate, 0, info[0], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->getAnimations(arg1_options);
    static_assert(bindings::IsReturnTypeCompatible<IDLSequence<Animation>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    v8::Local<v8::Value> v8_return_value = ToV8Traits<IDLSequence<Animation>>::ToV8(script_state, return_value);
    bindings::V8SetReturnValue(info, v8_return_value);
}

void GetAttributeOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_getAttribute");
    BLINK_BINDINGS_TRACE_EVENT("Element.getAttribute");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    decltype(NativeValueTraits<IDLString>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg1_name;
    if (info[0]->IsString()) [[likely]] {
        arg1_name.Init(isolate, info[0].As<v8::String>());
    } else {
        ExceptionState exception_state(isolate);
        arg1_name = NativeValueTraits<IDLString>::ArgumentValue(isolate, 0, info[0], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->getAttribute(arg1_name);
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void GetAttributeNSOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_getAttributeNS");
    BLINK_BINDINGS_TRACE_EVENT("Element.getAttributeNS");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_namespace_uri = NativeValueTraits<IDLNullable<IDLString>>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_local_name = NativeValueTraits<IDLString>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->getAttributeNS(arg1_namespace_uri, arg2_local_name);
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void GetAttributeNamesOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_getAttributeNames");
    BLINK_BINDINGS_TRACE_EVENT("Element.getAttributeNames");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->getAttributeNamesForBindings();
    static_assert(bindings::IsReturnTypeCompatible<IDLSequence<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    v8::Local<v8::Value> v8_return_value = ToV8Traits<IDLSequence<IDLString>>::ToV8(script_state, return_value);
    bindings::V8SetReturnValue(info, v8_return_value);
}

void GetAttributeNodeOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_getAttributeNode");
    BLINK_BINDINGS_TRACE_EVENT("Element.getAttributeNode");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    decltype(NativeValueTraits<IDLString>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg1_name;
    if (info[0]->IsString()) [[likely]] {
        arg1_name.Init(isolate, info[0].As<v8::String>());
    } else {
        ExceptionState exception_state(isolate);
        arg1_name = NativeValueTraits<IDLString>::ArgumentValue(isolate, 0, info[0], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->getAttributeNode(arg1_name);
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<Attr>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void GetAttributeNodeNSOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_getAttributeNodeNS");
    BLINK_BINDINGS_TRACE_EVENT("Element.getAttributeNodeNS");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_namespace_uri = NativeValueTraits<IDLNullable<IDLString>>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_local_name = NativeValueTraits<IDLString>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->getAttributeNodeNS(arg1_namespace_uri, arg2_local_name);
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<Attr>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void GetBoundingClientRectOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE(info.GetIsolate(), RuntimeCallStats::CounterId::kElementGetBoundingClientRect);
    BLINK_BINDINGS_TRACE_EVENT("Element.getBoundingClientRect");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kV8Element_GetBoundingClientRect_Method);

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->GetBoundingClientRectForBinding();
    static_assert(bindings::IsReturnTypeCompatible<DOMRect, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void GetClientRectsOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_getClientRects");
    BLINK_BINDINGS_TRACE_EVENT("Element.getClientRects");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kV8Element_GetClientRects_Method);

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->getClientRects();
    static_assert(bindings::IsReturnTypeCompatible<DOMRectList, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void GetElementsByClassNameOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_getElementsByClassName");
    BLINK_BINDINGS_TRACE_EVENT("Element.getElementsByClassName");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    decltype(NativeValueTraits<IDLString>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg1_class_names;
    if (info[0]->IsString()) [[likely]] {
        arg1_class_names.Init(isolate, info[0].As<v8::String>());
    } else {
        ExceptionState exception_state(isolate);
        arg1_class_names = NativeValueTraits<IDLString>::ArgumentValue(isolate, 0, info[0], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->getElementsByClassName(arg1_class_names);
    static_assert(bindings::IsReturnTypeCompatible<HTMLCollection, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void GetElementsByTagNameOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_getElementsByTagName");
    BLINK_BINDINGS_TRACE_EVENT("Element.getElementsByTagName");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    decltype(NativeValueTraits<IDLString>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg1_local_name;
    if (info[0]->IsString()) [[likely]] {
        arg1_local_name.Init(isolate, info[0].As<v8::String>());
    } else {
        ExceptionState exception_state(isolate);
        arg1_local_name = NativeValueTraits<IDLString>::ArgumentValue(isolate, 0, info[0], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->getElementsByTagName(arg1_local_name);
    static_assert(bindings::IsReturnTypeCompatible<HTMLCollection, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void GetElementsByTagNameNSOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_getElementsByTagNameNS");
    BLINK_BINDINGS_TRACE_EVENT("Element.getElementsByTagNameNS");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_namespace_uri = NativeValueTraits<IDLNullable<IDLString>>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_local_name = NativeValueTraits<IDLString>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->getElementsByTagNameNS(arg1_namespace_uri, arg2_local_name);
    static_assert(bindings::IsReturnTypeCompatible<HTMLCollection, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void GetHTMLOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_getHTML");
    BLINK_BINDINGS_TRACE_EVENT("Element.getHTML");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kElementGetHTML);

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    decltype(NativeValueTraits<GetHTMLOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg1_options;
    ExceptionState exception_state(isolate);
    if (info[0]->IsUndefined()) {
        arg1_options = GetHTMLOptions::Create();
    } else {
        arg1_options = NativeValueTraits<GetHTMLOptions>::ArgumentValue(isolate, 0, info[0], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->getHTML(arg1_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void GetInnerHTMLOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_getInnerHTML");
    BLINK_BINDINGS_TRACE_EVENT("Element.getInnerHTML");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kElementGetInnerHTML);

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    decltype(NativeValueTraits<GetInnerHTMLOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg1_options;
    if (info[0]->IsUndefined()) {
        arg1_options = GetInnerHTMLOptions::Create();
    } else {
        ExceptionState exception_state(isolate);
        arg1_options = NativeValueTraits<GetInnerHTMLOptions>::ArgumentValue(isolate, 0, info[0], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->getInnerHTML(arg1_options);
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void HasAttributeOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_hasAttribute");
    BLINK_BINDINGS_TRACE_EVENT("Element.hasAttribute");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    decltype(NativeValueTraits<IDLString>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg1_name;
    if (info[0]->IsString()) [[likely]] {
        arg1_name.Init(isolate, info[0].As<v8::String>());
    } else {
        ExceptionState exception_state(isolate);
        arg1_name = NativeValueTraits<IDLString>::ArgumentValue(isolate, 0, info[0], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->hasAttribute(arg1_name);
    static_assert(bindings::IsReturnTypeCompatible<IDLBoolean, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void HasAttributeNSOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_hasAttributeNS");
    BLINK_BINDINGS_TRACE_EVENT("Element.hasAttributeNS");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_namespace_uri = NativeValueTraits<IDLNullable<IDLString>>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_local_name = NativeValueTraits<IDLString>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->hasAttributeNS(arg1_namespace_uri, arg2_local_name);
    static_assert(bindings::IsReturnTypeCompatible<IDLBoolean, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void HasAttributesOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_hasAttributes");
    BLINK_BINDINGS_TRACE_EVENT("Element.hasAttributes");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->hasAttributes();
    static_assert(bindings::IsReturnTypeCompatible<IDLBoolean, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void HasPointerCaptureOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_hasPointerCapture");
    BLINK_BINDINGS_TRACE_EVENT("Element.hasPointerCapture");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_pointer_id = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->hasPointerCapture(arg1_pointer_id);
    static_assert(bindings::IsReturnTypeCompatible<IDLBoolean, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void InsertAdjacentElementOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_insertAdjacentElement");
    BLINK_BINDINGS_TRACE_EVENT("Element.insertAdjacentElement");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    ExceptionState exception_state(isolate);

    // [CEReactions]
    CEReactionsScope ce_reactions_scope;

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& arg1_where = NativeValueTraits<IDLString>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_element = NativeValueTraits<Element>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->insertAdjacentElement(arg1_where, arg2_element, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<Element>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void InsertAdjacentHTMLOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_insertAdjacentHTML");
    BLINK_BINDINGS_TRACE_EVENT("Element.insertAdjacentHTML");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    ExceptionState exception_state(isolate);

    // [CEReactions]
    CEReactionsScope ce_reactions_scope;

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& arg1_position = NativeValueTraits<IDLString>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    const char* const class_like_name = "Element";
    const char* const property_name = "insertAdjacentHTML";
    ExecutionContext* execution_context_of_document_tree = bindings::ExecutionContextFromV8Wrappable(blink_receiver);
    auto&& arg2_text = NativeValueTraits<IDLStringStringContextTrustedHTML>::ArgumentValue(
        isolate, 1, info[1], exception_state, class_like_name, property_name, execution_context_of_document_tree);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->insertAdjacentHTML(arg1_position, arg2_text, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void InsertAdjacentTextOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_insertAdjacentText");
    BLINK_BINDINGS_TRACE_EVENT("Element.insertAdjacentText");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_where = NativeValueTraits<IDLString>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_data = NativeValueTraits<IDLString>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->insertAdjacentText(arg1_where, arg2_data, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void MatchesOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_matches");
    BLINK_BINDINGS_TRACE_EVENT("Element.matches");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_selectors = NativeValueTraits<IDLString>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->matches(arg1_selectors, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<IDLBoolean, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void PrependOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_prepend");
    BLINK_BINDINGS_TRACE_EVENT("Element.prepend");

    v8::Isolate* isolate = info.GetIsolate();
    ExceptionState exception_state(isolate);

    // [CEReactions]
    CEReactionsScope ce_reactions_scope;

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& arg1_nodes = bindings::VariadicArgumentsToNativeValues<V8UnionNodeOrStringOrTrustedScript>(isolate, info, 0, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->prepend(arg1_nodes, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void QuerySelectorOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_querySelector");
    BLINK_BINDINGS_TRACE_EVENT("Element.querySelector");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_selectors = NativeValueTraits<IDLString>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->querySelector(arg1_selectors, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<Element>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void QuerySelectorAllOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_querySelectorAll");
    BLINK_BINDINGS_TRACE_EVENT("Element.querySelectorAll");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_selectors = NativeValueTraits<IDLString>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->querySelectorAll(arg1_selectors, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<NodeList, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void ReleasePointerCaptureOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_releasePointerCapture");
    BLINK_BINDINGS_TRACE_EVENT("Element.releasePointerCapture");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_pointer_id = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->releasePointerCapture(arg1_pointer_id, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void RemoveOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_remove");
    BLINK_BINDINGS_TRACE_EVENT("Element.remove");

    v8::Isolate* isolate = info.GetIsolate();
    ExceptionState exception_state(isolate);

    // [CEReactions]
    CEReactionsScope ce_reactions_scope;

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->remove(exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void RemoveAttributeOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_removeAttribute");
    BLINK_BINDINGS_TRACE_EVENT("Element.removeAttribute");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    ExceptionState exception_state(isolate);

    // [CEReactions]
    CEReactionsScope ce_reactions_scope;

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    decltype(NativeValueTraits<IDLString>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg1_name;
    if (info[0]->IsString()) [[likely]] {
        arg1_name.Init(isolate, info[0].As<v8::String>());
    } else {
        arg1_name = NativeValueTraits<IDLString>::ArgumentValue(isolate, 0, info[0], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    blink_receiver->removeAttribute(arg1_name);
}

void RemoveAttributeNSOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_removeAttributeNS");
    BLINK_BINDINGS_TRACE_EVENT("Element.removeAttributeNS");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    ExceptionState exception_state(isolate);

    // [CEReactions]
    CEReactionsScope ce_reactions_scope;

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& arg1_namespace_uri = NativeValueTraits<IDLNullable<IDLString>>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_local_name = NativeValueTraits<IDLString>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->removeAttributeNS(arg1_namespace_uri, arg2_local_name);
}

void RemoveAttributeNodeOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_removeAttributeNode");
    BLINK_BINDINGS_TRACE_EVENT("Element.removeAttributeNode");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    ExceptionState exception_state(isolate);

    // [CEReactions]
    CEReactionsScope ce_reactions_scope;

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& arg1_attr = NativeValueTraits<Attr>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->removeAttributeNode(arg1_attr, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<Attr, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void ReplaceChildrenOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_replaceChildren");
    BLINK_BINDINGS_TRACE_EVENT("Element.replaceChildren");

    v8::Isolate* isolate = info.GetIsolate();
    ExceptionState exception_state(isolate);

    // [CEReactions]
    CEReactionsScope ce_reactions_scope;

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& arg1_nodes = bindings::VariadicArgumentsToNativeValues<V8UnionNodeOrStringOrTrustedScript>(isolate, info, 0, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->replaceChildren(arg1_nodes, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void ReplaceWithOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_replaceWith");
    BLINK_BINDINGS_TRACE_EVENT("Element.replaceWith");

    v8::Isolate* isolate = info.GetIsolate();
    ExceptionState exception_state(isolate);

    // [CEReactions]
    CEReactionsScope ce_reactions_scope;

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& arg1_nodes = bindings::VariadicArgumentsToNativeValues<V8UnionNodeOrStringOrTrustedScript>(isolate, info, 0, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->replaceWith(arg1_nodes, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void RequestFullscreenOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_requestFullscreen");
    BLINK_BINDINGS_TRACE_EVENT("Element.requestFullscreen");
    // Promise returning function: Convert a TypeError to a reject promise.
    ExceptionToRejectPromiseScope reject_promise_scope(info);

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    if (!V8Element::HasInstance(isolate, v8_receiver)) {
        V8ThrowException::ThrowTypeError(isolate, "Illegal invocation");
        return;
    }

    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    decltype(NativeValueTraits<FullscreenOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg1_options;
    const v8::ExceptionContext exception_context_type = v8::ExceptionContext::kOperation;
    const char* const class_like_name = "Element";
    const char* const property_name = "requestFullscreen";
    ExceptionState exception_state(isolate, exception_context_type, class_like_name, property_name);
    if (info[0]->IsUndefined()) {
        arg1_options = FullscreenOptions::Create();
    } else {
        arg1_options = NativeValueTraits<FullscreenOptions>::ArgumentValue(isolate, 0, info[0], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    ScriptPromise<IDLUndefined> return_value = ElementFullscreen::requestFullscreen(script_state, *blink_receiver, arg1_options, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value);
}

void RequestPointerLockOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_requestPointerLock");
    BLINK_BINDINGS_TRACE_EVENT("Element.requestPointerLock");
    // Promise returning function: Convert a TypeError to a reject promise.
    ExceptionToRejectPromiseScope reject_promise_scope(info);

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    if (!V8Element::HasInstance(isolate, v8_receiver)) {
        V8ThrowException::ThrowTypeError(isolate, "Illegal invocation");
        return;
    }

    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kElementRequestPointerLock);

    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    decltype(NativeValueTraits<PointerLockOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg1_options;
    const v8::ExceptionContext exception_context_type = v8::ExceptionContext::kOperation;
    const char* const class_like_name = "Element";
    const char* const property_name = "requestPointerLock";
    ExceptionState exception_state(isolate, exception_context_type, class_like_name, property_name);
    if (info[0]->IsUndefined()) {
        arg1_options = PointerLockOptions::Create();
    } else {
        arg1_options = NativeValueTraits<PointerLockOptions>::ArgumentValue(isolate, 0, info[0], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    ScriptPromise<IDLUndefined> return_value = blink_receiver->requestPointerLock(script_state, arg1_options, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value);
}

void ScrollOperationOverload1(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    decltype(NativeValueTraits<ScrollToOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg1_options;
    if (info[0]->IsUndefined()) {
        arg1_options = ScrollToOptions::Create();
    } else {
        ExceptionState exception_state(isolate);
        arg1_options = NativeValueTraits<ScrollToOptions>::ArgumentValue(isolate, 0, info[0], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    blink_receiver->scrollTo(arg1_options);
}

void ScrollOperationOverload2(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_x = NativeValueTraits<IDLUnrestrictedDouble>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_y = NativeValueTraits<IDLUnrestrictedDouble>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->scrollTo(arg1_x, arg2_y);
}

void ScrollOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_scroll");
    BLINK_BINDINGS_TRACE_EVENT("Element.scroll");

    BINDINGS_COOPERATIVE_SCHEDULING_SAFEPOINT();

    const int arg_count = std::min(info.Length(), 2);
    if (arg_count == 2) {
        return ScrollOperationOverload2(info);
    }
    if (arg_count == 1) {
        return ScrollOperationOverload1(info);
    }
    return ScrollOperationOverload1(info);
}

void ScrollByOperationOverload1(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    decltype(NativeValueTraits<ScrollToOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg1_options;
    if (info[0]->IsUndefined()) {
        arg1_options = ScrollToOptions::Create();
    } else {
        ExceptionState exception_state(isolate);
        arg1_options = NativeValueTraits<ScrollToOptions>::ArgumentValue(isolate, 0, info[0], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    blink_receiver->scrollBy(arg1_options);
}

void ScrollByOperationOverload2(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_x = NativeValueTraits<IDLUnrestrictedDouble>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_y = NativeValueTraits<IDLUnrestrictedDouble>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->scrollBy(arg1_x, arg2_y);
}

void ScrollByOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_scrollBy");
    BLINK_BINDINGS_TRACE_EVENT("Element.scrollBy");

    BINDINGS_COOPERATIVE_SCHEDULING_SAFEPOINT();

    const int arg_count = std::min(info.Length(), 2);
    if (arg_count == 2) {
        return ScrollByOperationOverload2(info);
    }
    if (arg_count == 1) {
        return ScrollByOperationOverload1(info);
    }
    return ScrollByOperationOverload1(info);
}

void ScrollIntoViewOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_scrollIntoView");
    BLINK_BINDINGS_TRACE_EVENT("Element.scrollIntoView");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    decltype(NativeValueTraits<V8UnionBooleanOrScrollIntoViewOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg1_arg;
    if (info[0]->IsUndefined()) {
        arg1_arg = MakeGarbageCollected<V8UnionBooleanOrScrollIntoViewOptions>(ScrollIntoViewOptions::Create());
    } else {
        ExceptionState exception_state(isolate);
        arg1_arg = NativeValueTraits<V8UnionBooleanOrScrollIntoViewOptions>::ArgumentValue(isolate, 0, info[0], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    blink_receiver->scrollIntoView(arg1_arg);
}

void ScrollIntoViewIfNeededOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_scrollIntoViewIfNeeded");
    BLINK_BINDINGS_TRACE_EVENT("Element.scrollIntoViewIfNeeded");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kElementScrollIntoViewIfNeeded);

    do { // Dummy loop for use of 'break'.
        const int non_undefined_argument_length = bindings::NonUndefinedArgumentLength(info);
        v8::Local<v8::Object> v8_receiver = info.This();
        Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
        if (non_undefined_argument_length <= 0) {
            blink_receiver->scrollIntoViewIfNeeded();
            break;
        }
        ExceptionState exception_state(isolate);
        auto&& arg1_center_if_needed = NativeValueTraits<IDLBoolean>::ArgumentValue(isolate, 0, info[0], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
        blink_receiver->scrollIntoViewIfNeeded(arg1_center_if_needed);
    } while (false);
}

void ScrollToOperationOverload1(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    decltype(NativeValueTraits<ScrollToOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg1_options;
    if (info[0]->IsUndefined()) {
        arg1_options = ScrollToOptions::Create();
    } else {
        ExceptionState exception_state(isolate);
        arg1_options = NativeValueTraits<ScrollToOptions>::ArgumentValue(isolate, 0, info[0], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    blink_receiver->scrollTo(arg1_options);
}

void ScrollToOperationOverload2(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_x = NativeValueTraits<IDLUnrestrictedDouble>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_y = NativeValueTraits<IDLUnrestrictedDouble>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->scrollTo(arg1_x, arg2_y);
}

void ScrollToOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_scrollTo");
    BLINK_BINDINGS_TRACE_EVENT("Element.scrollTo");

    BINDINGS_COOPERATIVE_SCHEDULING_SAFEPOINT();

    const int arg_count = std::min(info.Length(), 2);
    if (arg_count == 2) {
        return ScrollToOperationOverload2(info);
    }
    if (arg_count == 1) {
        return ScrollToOperationOverload1(info);
    }
    return ScrollToOperationOverload1(info);
}

void SetAttributeOperationOverload1(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    ExceptionState exception_state(isolate);

    // [CEReactions]
    CEReactionsScope ce_reactions_scope;

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& arg1_name = NativeValueTraits<IDLString>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_value = NativeValueTraits<IDLString>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setAttribute(arg1_name, arg2_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void SetAttributeOperationOverload2(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    ExceptionState exception_state(isolate);

    // [CEReactions]
    CEReactionsScope ce_reactions_scope;

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& arg1_name = NativeValueTraits<IDLString>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_value = NativeValueTraits<V8UnionTrustedHTMLOrTrustedScriptOrTrustedScriptURL>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setAttribute(arg1_name, arg2_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void SetAttributeOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_setAttribute");
    BLINK_BINDINGS_TRACE_EVENT("Element.setAttribute");

    BINDINGS_COOPERATIVE_SCHEDULING_SAFEPOINT();

    const int arg_count = std::min(info.Length(), 2);
    v8::Isolate* isolate = info.GetIsolate();
    if (arg_count == 2) {
        if (info[1]->IsObject()) {
            if (V8TrustedScriptURL::HasInstance(isolate, info[1])) {
                return SetAttributeOperationOverload2(info);
            }
            if (V8TrustedScript::HasInstance(isolate, info[1])) {
                return SetAttributeOperationOverload2(info);
            }
            if (V8TrustedHTML::HasInstance(isolate, info[1])) {
                return SetAttributeOperationOverload2(info);
            }
        }
        return SetAttributeOperationOverload1(info);
    }

    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }
    V8ThrowException::ThrowTypeError(isolate, "Overload resolution failed.");
    return;
}

void SetAttributeNSOperationOverload1(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 3) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(3, info.Length()));
        return;
    }

    ExceptionState exception_state(isolate);

    // [CEReactions]
    CEReactionsScope ce_reactions_scope;

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& arg1_namespace_uri = NativeValueTraits<IDLNullable<IDLString>>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_name = NativeValueTraits<IDLString>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_value = NativeValueTraits<IDLString>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setAttributeNS(arg1_namespace_uri, arg2_name, arg3_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void SetAttributeNSOperationOverload2(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 3) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(3, info.Length()));
        return;
    }

    ExceptionState exception_state(isolate);

    // [CEReactions]
    CEReactionsScope ce_reactions_scope;

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& arg1_namespace_uri = NativeValueTraits<IDLNullable<IDLString>>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_name = NativeValueTraits<IDLString>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_value = NativeValueTraits<V8UnionTrustedHTMLOrTrustedScriptOrTrustedScriptURL>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setAttributeNS(arg1_namespace_uri, arg2_name, arg3_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void SetAttributeNSOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_setAttributeNS");
    BLINK_BINDINGS_TRACE_EVENT("Element.setAttributeNS");

    BINDINGS_COOPERATIVE_SCHEDULING_SAFEPOINT();

    const int arg_count = std::min(info.Length(), 3);
    v8::Isolate* isolate = info.GetIsolate();
    if (arg_count == 3) {
        if (info[2]->IsObject()) {
            if (V8TrustedScriptURL::HasInstance(isolate, info[2])) {
                return SetAttributeNSOperationOverload2(info);
            }
            if (V8TrustedScript::HasInstance(isolate, info[2])) {
                return SetAttributeNSOperationOverload2(info);
            }
            if (V8TrustedHTML::HasInstance(isolate, info[2])) {
                return SetAttributeNSOperationOverload2(info);
            }
        }
        return SetAttributeNSOperationOverload1(info);
    }

    if (info.Length() < 3) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(3, info.Length()));
        return;
    }
    V8ThrowException::ThrowTypeError(isolate, "Overload resolution failed.");
    return;
}

void SetAttributeNodeOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_setAttributeNode");
    BLINK_BINDINGS_TRACE_EVENT("Element.setAttributeNode");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    ExceptionState exception_state(isolate);

    // [CEReactions]
    CEReactionsScope ce_reactions_scope;

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& arg1_attr = NativeValueTraits<Attr>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->setAttributeNode(arg1_attr, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<Attr>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void SetAttributeNodeNSOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_setAttributeNodeNS");
    BLINK_BINDINGS_TRACE_EVENT("Element.setAttributeNodeNS");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    ExceptionState exception_state(isolate);

    // [CEReactions]
    CEReactionsScope ce_reactions_scope;

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& arg1_attr = NativeValueTraits<Attr>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->setAttributeNodeNS(arg1_attr, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<Attr>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void SetHTMLOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_setHTML");
    BLINK_BINDINGS_TRACE_EVENT("Element.setHTML");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kSetHTMLSafe);

    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    ExceptionState exception_state(isolate);

    // [CEReactions]
    CEReactionsScope ce_reactions_scope;

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& arg1_html = NativeValueTraits<IDLString>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<SetHTMLOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg2_options;
    if (info[1]->IsUndefined()) {
        arg2_options = SetHTMLOptions::Create();
    } else {
        arg2_options = NativeValueTraits<SetHTMLOptions>::ArgumentValue(isolate, 1, info[1], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    blink_receiver->setHTML(arg1_html, arg2_options, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void SetHTMLUnsafeOperationOverload1(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kSetHTMLUnsafe);

    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    ExceptionState exception_state(isolate);

    // [CEReactions]
    CEReactionsScope ce_reactions_scope;

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    const char* const class_like_name = "Element";
    const char* const property_name = "setHTMLUnsafe";
    ExecutionContext* execution_context_of_document_tree = bindings::ExecutionContextFromV8Wrappable(blink_receiver);
    auto&& arg1_html = NativeValueTraits<IDLStringStringContextTrustedHTML>::ArgumentValue(
        isolate, 0, info[0], exception_state, class_like_name, property_name, execution_context_of_document_tree);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setHTMLUnsafe(arg1_html, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void SetHTMLUnsafeOperationOverload2(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kSetHTMLUnsafe);

    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    ExceptionState exception_state(isolate);

    // [CEReactions]
    CEReactionsScope ce_reactions_scope;

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    const char* const class_like_name = "Element";
    const char* const property_name = "setHTMLUnsafe";
    ExecutionContext* execution_context_of_document_tree = bindings::ExecutionContextFromV8Wrappable(blink_receiver);
    auto&& arg1_html = NativeValueTraits<IDLStringStringContextTrustedHTML>::ArgumentValue(
        isolate, 0, info[0], exception_state, class_like_name, property_name, execution_context_of_document_tree);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_options = NativeValueTraits<SetHTMLOptions>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setHTMLUnsafe(arg1_html, arg2_options, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void SetHTMLUnsafeOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_setHTMLUnsafe");
    BLINK_BINDINGS_TRACE_EVENT("Element.setHTMLUnsafe");

    BINDINGS_COOPERATIVE_SCHEDULING_SAFEPOINT();

    const int arg_count = std::min(info.Length(), 2);
    if (RuntimeEnabledFeatures::SanitizerAPIEnabled()) {
        if (arg_count == 2) {
            return SetHTMLUnsafeOperationOverload2(info);
        }
    }
    if (arg_count == 1) {
        return SetHTMLUnsafeOperationOverload1(info);
    }

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }
    V8ThrowException::ThrowTypeError(isolate, "Overload resolution failed.");
    return;
}

void SetPointerCaptureOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_setPointerCapture");
    BLINK_BINDINGS_TRACE_EVENT("Element.setPointerCapture");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_pointer_id = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setPointerCapture(arg1_pointer_id, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void ToggleAttributeOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_toggleAttribute");
    BLINK_BINDINGS_TRACE_EVENT("Element.toggleAttribute");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    ExceptionState exception_state(isolate);

    // [CEReactions]
    CEReactionsScope ce_reactions_scope;

    bool return_value;
    do { // Dummy loop for use of 'break'.
        const int non_undefined_argument_length = bindings::NonUndefinedArgumentLength(info);
        v8::Local<v8::Object> v8_receiver = info.This();
        Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
        auto&& arg1_qualified_name = NativeValueTraits<IDLString>::ArgumentValue(isolate, 0, info[0], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
        if (non_undefined_argument_length <= 1) {
            return_value = blink_receiver->toggleAttribute(arg1_qualified_name, exception_state);
            break;
        }
        auto&& arg2_force = NativeValueTraits<IDLBoolean>::ArgumentValue(isolate, 1, info[1], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
        return_value = blink_receiver->toggleAttribute(arg1_qualified_name, arg2_force, exception_state);
    } while (false);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void WebkitMatchesSelectorOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_webkitMatchesSelector");
    BLINK_BINDINGS_TRACE_EVENT("Element.webkitMatchesSelector");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kElementPrefixedMatchesSelector);

    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_selectors = NativeValueTraits<IDLString>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->matches(arg1_selectors, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<IDLBoolean, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void WebkitRequestFullScreenOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_webkitRequestFullScreen");
    BLINK_BINDINGS_TRACE_EVENT("Element.webkitRequestFullScreen");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kPrefixedElementRequestFullScreen);
    v8::Local<v8::Object> v8_receiver = info.This();
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    V8PerContextData* per_context_data = script_state->PerContextData();
    // [LogActivity], [LogAllWorlds]
    if (per_context_data && per_context_data->ActivityLogger()) [[unlikely]] {
        per_context_data->ActivityLogger()->LogMethod(script_state, "Element.webkitRequestFullScreen", info);
    }

    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    decltype(NativeValueTraits<FullscreenOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg1_options;
    if (info[0]->IsUndefined()) {
        arg1_options = FullscreenOptions::Create();
    } else {
        ExceptionState exception_state(isolate);
        arg1_options = NativeValueTraits<FullscreenOptions>::ArgumentValue(isolate, 0, info[0], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    ElementFullscreen::webkitRequestFullscreen(*blink_receiver, arg1_options);
}

void WebkitRequestFullscreenOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Element_webkitRequestFullscreen");
    BLINK_BINDINGS_TRACE_EVENT("Element.webkitRequestFullscreen");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kPrefixedElementRequestFullscreen);
    v8::Local<v8::Object> v8_receiver = info.This();
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    V8PerContextData* per_context_data = script_state->PerContextData();
    // [LogActivity], [LogAllWorlds]
    if (per_context_data && per_context_data->ActivityLogger()) [[unlikely]] {
        per_context_data->ActivityLogger()->LogMethod(script_state, "Element.webkitRequestFullscreen", info);
    }

    Element* blink_receiver = V8Element::ToWrappableUnsafe(isolate, v8_receiver);
    decltype(NativeValueTraits<FullscreenOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg1_options;
    if (info[0]->IsUndefined()) {
        arg1_options = FullscreenOptions::Create();
    } else {
        ExceptionState exception_state(isolate);
        arg1_options = NativeValueTraits<FullscreenOptions>::ArgumentValue(isolate, 0, info[0], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    ElementFullscreen::webkitRequestFullscreen(*blink_receiver, arg1_options);
}

} // namespace v8_element

using namespace v8_element;

} // namespace

void V8Element::InstallInterfaceTemplate(v8::Isolate* isolate, const DOMWrapperWorld& world, v8::Local<v8::Template> interface_template)
{
    const WrapperTypeInfo* const wrapper_type_info = V8Element::GetWrapperTypeInfo();
    v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
    v8::Local<v8::ObjectTemplate> instance_object_template = interface_function_template->InstanceTemplate();
    v8::Local<v8::ObjectTemplate> prototype_object_template = interface_function_template->PrototypeTemplate();
    v8::Local<v8::FunctionTemplate> parent_interface_template = wrapper_type_info->parent_class->GetV8ClassTemplate(isolate, world).As<v8::FunctionTemplate>();
    bindings::SetupIDLInterfaceTemplate(
        isolate, wrapper_type_info, instance_object_template, prototype_object_template, interface_function_template, parent_interface_template);

    v8::Local<v8::Template> instance_template = instance_object_template;
    v8::Local<v8::Template> prototype_template = prototype_object_template;
    InstallUnconditionalProperties(isolate, world, instance_template, prototype_template, interface_template);
    InstallContextIndependentProperties(isolate, world, instance_template, prototype_template, interface_template);
}

void V8Element::InstallUnconditionalProperties(v8::Isolate* isolate, const DOMWrapperWorld& world, v8::Local<v8::Template> instance_template,
    v8::Local<v8::Template> prototype_template, v8::Local<v8::Template> interface_template)
{
    using bindings::IDLMemberInstaller;

    v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
    v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
    {
        static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
            { "namespaceURI", "Element", NamespaceURIAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "prefix", "Element", PrefixAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "localName", "Element", LocalNameAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "tagName", "Element", TagNameAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "id", "Element", IdAttributeGetCallback, IdAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "className", "Element", ClassNameAttributeGetCallback, ClassNameAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "classList", "Element", ClassListAttributeGetCallbackForMainWorld, ClassListAttributeSetCallbackForMainWorld, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kMainWorld),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "classList", "Element", ClassListAttributeGetCallbackForNonMainWorlds, ClassListAttributeSetCallbackForNonMainWorlds, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kNonMainWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "slot", "Element", SlotAttributeGetCallback, SlotAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "attributes", "Element", AttributesAttributeGetCallbackForMainWorld, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kMainWorld),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "attributes", "Element", AttributesAttributeGetCallbackForNonMainWorlds, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kNonMainWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "shadowRoot", "Element", ShadowRootAttributeGetCallbackForMainWorld, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kMainWorld),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "shadowRoot", "Element", ShadowRootAttributeGetCallbackForNonMainWorlds, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kNonMainWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "part", "Element", PartAttributeGetCallbackForMainWorld, PartAttributeSetCallbackForMainWorld, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kMainWorld),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "part", "Element", PartAttributeGetCallbackForNonMainWorlds, PartAttributeSetCallbackForNonMainWorlds, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kNonMainWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "assignedSlot", "Element", AssignedSlotAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "innerHTML", "Element", InnerHTMLAttributeGetCallback, InnerHTMLAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "outerHTML", "Element", OuterHTMLAttributeGetCallback, OuterHTMLAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "scrollTop", "Element", ScrollTopAttributeGetCallback, ScrollTopAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "scrollLeft", "Element", ScrollLeftAttributeGetCallback, ScrollLeftAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "scrollWidth", "Element", ScrollWidthAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "scrollHeight", "Element", ScrollHeightAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "clientTop", "Element", ClientTopAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "clientLeft", "Element", ClientLeftAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "clientWidth", "Element", ClientWidthAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "clientHeight", "Element", ClientHeightAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onbeforecopy", "Element", OnbeforecopyAttributeGetCallback, OnbeforecopyAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onbeforecut", "Element", OnbeforecutAttributeGetCallback, OnbeforecutAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onbeforepaste", "Element", OnbeforepasteAttributeGetCallback, OnbeforepasteAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onsearch", "Element", OnsearchAttributeGetCallback, OnsearchAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "elementTiming", "Element", ElementTimingAttributeGetCallback, ElementTimingAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onfullscreenchange", "Element", OnfullscreenchangeAttributeGetCallback, OnfullscreenchangeAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onfullscreenerror", "Element", OnfullscreenerrorAttributeGetCallback, OnfullscreenerrorAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onwebkitfullscreenchange", "Element", OnwebkitfullscreenchangeAttributeGetCallback, OnwebkitfullscreenchangeAttributeSetCallback,
                unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onwebkitfullscreenerror", "Element", OnwebkitfullscreenerrorAttributeGetCallback, OnwebkitfullscreenerrorAttributeSetCallback,
                unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "role", "Element", RoleAttributeGetCallback, RoleAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ariaAtomic", "Element", AriaAtomicAttributeGetCallback, AriaAtomicAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ariaAutoComplete", "Element", AriaAutoCompleteAttributeGetCallback, AriaAutoCompleteAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ariaBusy", "Element", AriaBusyAttributeGetCallback, AriaBusyAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ariaBrailleLabel", "Element", AriaBrailleLabelAttributeGetCallback, AriaBrailleLabelAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ariaBrailleRoleDescription", "Element", AriaBrailleRoleDescriptionAttributeGetCallback, AriaBrailleRoleDescriptionAttributeSetCallback,
                unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ariaChecked", "Element", AriaCheckedAttributeGetCallback, AriaCheckedAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ariaColCount", "Element", AriaColCountAttributeGetCallback, AriaColCountAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ariaColIndex", "Element", AriaColIndexAttributeGetCallback, AriaColIndexAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ariaColSpan", "Element", AriaColSpanAttributeGetCallback, AriaColSpanAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ariaCurrent", "Element", AriaCurrentAttributeGetCallback, AriaCurrentAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ariaDescription", "Element", AriaDescriptionAttributeGetCallback, AriaDescriptionAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ariaDisabled", "Element", AriaDisabledAttributeGetCallback, AriaDisabledAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ariaExpanded", "Element", AriaExpandedAttributeGetCallback, AriaExpandedAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ariaHasPopup", "Element", AriaHasPopupAttributeGetCallback, AriaHasPopupAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ariaHidden", "Element", AriaHiddenAttributeGetCallback, AriaHiddenAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ariaInvalid", "Element", AriaInvalidAttributeGetCallback, AriaInvalidAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ariaKeyShortcuts", "Element", AriaKeyShortcutsAttributeGetCallback, AriaKeyShortcutsAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ariaLabel", "Element", AriaLabelAttributeGetCallback, AriaLabelAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ariaLevel", "Element", AriaLevelAttributeGetCallback, AriaLevelAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ariaLive", "Element", AriaLiveAttributeGetCallback, AriaLiveAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ariaModal", "Element", AriaModalAttributeGetCallback, AriaModalAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ariaMultiLine", "Element", AriaMultiLineAttributeGetCallback, AriaMultiLineAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ariaMultiSelectable", "Element", AriaMultiSelectableAttributeGetCallback, AriaMultiSelectableAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ariaOrientation", "Element", AriaOrientationAttributeGetCallback, AriaOrientationAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ariaPlaceholder", "Element", AriaPlaceholderAttributeGetCallback, AriaPlaceholderAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ariaPosInSet", "Element", AriaPosInSetAttributeGetCallback, AriaPosInSetAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ariaPressed", "Element", AriaPressedAttributeGetCallback, AriaPressedAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ariaReadOnly", "Element", AriaReadOnlyAttributeGetCallback, AriaReadOnlyAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ariaRelevant", "Element", AriaRelevantAttributeGetCallback, AriaRelevantAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ariaRequired", "Element", AriaRequiredAttributeGetCallback, AriaRequiredAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ariaRoleDescription", "Element", AriaRoleDescriptionAttributeGetCallback, AriaRoleDescriptionAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ariaRowCount", "Element", AriaRowCountAttributeGetCallback, AriaRowCountAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ariaRowIndex", "Element", AriaRowIndexAttributeGetCallback, AriaRowIndexAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ariaRowSpan", "Element", AriaRowSpanAttributeGetCallback, AriaRowSpanAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ariaSelected", "Element", AriaSelectedAttributeGetCallback, AriaSelectedAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ariaSetSize", "Element", AriaSetSizeAttributeGetCallback, AriaSetSizeAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ariaSort", "Element", AriaSortAttributeGetCallback, AriaSortAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ariaValueMax", "Element", AriaValueMaxAttributeGetCallback, AriaValueMaxAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ariaValueMin", "Element", AriaValueMinAttributeGetCallback, AriaValueMinAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ariaValueNow", "Element", AriaValueNowAttributeGetCallback, AriaValueNowAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ariaValueText", "Element", AriaValueTextAttributeGetCallback, AriaValueTextAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "children", "Element", ChildrenAttributeGetCallbackForMainWorld, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kMainWorld),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "children", "Element", ChildrenAttributeGetCallbackForNonMainWorlds, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kNonMainWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "firstElementChild", "Element", FirstElementChildAttributeGetCallbackForMainWorld, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kMainWorld),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "firstElementChild", "Element", FirstElementChildAttributeGetCallbackForNonMainWorlds, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kNonMainWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "lastElementChild", "Element", LastElementChildAttributeGetCallbackForMainWorld, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kMainWorld),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "lastElementChild", "Element", LastElementChildAttributeGetCallbackForNonMainWorlds, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kNonMainWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "childElementCount", "Element", ChildElementCountAttributeGetCallback, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "previousElementSibling", "Element", PreviousElementSiblingAttributeGetCallbackForMainWorld, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kMainWorld),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "previousElementSibling", "Element", PreviousElementSiblingAttributeGetCallbackForNonMainWorlds, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kNonMainWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "nextElementSibling", "Element", NextElementSiblingAttributeGetCallbackForMainWorld, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kMainWorld),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "nextElementSibling", "Element", NextElementSiblingAttributeGetCallbackForNonMainWorlds, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kNonMainWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
        };
        IDLMemberInstaller::InstallAttributes(isolate, world, instance_template, prototype_template, interface_template, signature, kAttributeTable);
    }

    {
        static const IDLMemberInstaller::OperationConfig kOperationTable[] = {
            { "after", "Element", AfterOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "animate", "Element", AnimateOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "append", "Element", AppendOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "attachShadow", "Element", AttachShadowOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "before", "Element", BeforeOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "checkVisibility", "Element", CheckVisibilityOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "closest", "Element", ClosestOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "computedStyleMap", "Element", ComputedStyleMapOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "getAnimations", "Element", GetAnimationsOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "getAttribute", "Element", GetAttributeOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect) },
            { "getAttributeNS", "Element", GetAttributeNSOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect) },
            { "getAttributeNames", "Element", GetAttributeNamesOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect) },
            { "getAttributeNode", "Element", GetAttributeNodeOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "getAttributeNodeNS", "Element", GetAttributeNodeNSOperationCallback, 2, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "getBoundingClientRect", "Element", GetBoundingClientRectOperationCallback, 0, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasNoSideEffect) },
            { "getClientRects", "Element", GetClientRectsOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "getElementsByClassName", "Element", GetElementsByClassNameOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasNoSideEffect) },
            { "getElementsByTagName", "Element", GetElementsByTagNameOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasNoSideEffect) },
            { "getElementsByTagNameNS", "Element", GetElementsByTagNameNSOperationCallback, 2, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasNoSideEffect) },
            { "getHTML", "Element", GetHTMLOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect) },
            { "hasAttribute", "Element", HasAttributeOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect) },
            { "hasAttributeNS", "Element", HasAttributeNSOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect) },
            { "hasAttributes", "Element", HasAttributesOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect) },
            { "hasPointerCapture", "Element", HasPointerCaptureOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "insertAdjacentElement", "Element", InsertAdjacentElementOperationCallback, 2, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "insertAdjacentHTML", "Element", InsertAdjacentHTMLOperationCallback, 2, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "insertAdjacentText", "Element", InsertAdjacentTextOperationCallback, 2, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "matches", "Element", MatchesOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "prepend", "Element", PrependOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "querySelector", "Element", QuerySelectorOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect) },
            { "querySelectorAll", "Element", QuerySelectorAllOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect) },
            { "releasePointerCapture", "Element", ReleasePointerCaptureOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "remove", "Element", RemoveOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "removeAttribute", "Element", RemoveAttributeOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "removeAttributeNS", "Element", RemoveAttributeNSOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "removeAttributeNode", "Element", RemoveAttributeNodeOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "replaceChildren", "Element", ReplaceChildrenOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "replaceWith", "Element", ReplaceWithOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "requestFullscreen", "Element", RequestFullscreenOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kDoNotCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "requestPointerLock", "Element", RequestPointerLockOperationCallback, 0, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kDoNotCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "scroll", "Element", ScrollOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "scrollBy", "Element", ScrollByOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "scrollIntoView", "Element", ScrollIntoViewOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "scrollIntoViewIfNeeded", "Element", ScrollIntoViewIfNeededOperationCallback, 0, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "scrollTo", "Element", ScrollToOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "setAttribute", "Element", SetAttributeOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "setAttributeNS", "Element", SetAttributeNSOperationCallback, 3, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "setAttributeNode", "Element", SetAttributeNodeOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "setAttributeNodeNS", "Element", SetAttributeNodeNSOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "setHTMLUnsafe", "Element", SetHTMLUnsafeOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "setPointerCapture", "Element", SetPointerCaptureOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "toggleAttribute", "Element", ToggleAttributeOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "webkitMatchesSelector", "Element", WebkitMatchesSelectorOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "webkitRequestFullScreen", "Element", WebkitRequestFullScreenOperationCallback, 0, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "webkitRequestFullscreen", "Element", WebkitRequestFullscreenOperationCallback, 0, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
        };
        IDLMemberInstaller::InstallOperations(isolate, world, instance_template, prototype_template, interface_template, signature, kOperationTable);
    }
}

void V8Element::InstallContextIndependentProperties(v8::Isolate* isolate, const DOMWrapperWorld& world, v8::Local<v8::Template> instance_template,
    v8::Local<v8::Template> prototype_template, v8::Local<v8::Template> interface_template)
{
    using bindings::IDLMemberInstaller;

    if (RuntimeEnabledFeatures::StandardizedBrowserZoomEnabled()) {
        static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
            { "currentCSSZoom", "Element", CurrentCSSZoomAttributeGetCallback, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
        };
        v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
        v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
        IDLMemberInstaller::InstallAttributes(isolate, world, instance_template, prototype_template, interface_template, signature, kAttributeTable);
    }
    if (RuntimeEnabledFeatures::HTMLAnchorAttributeEnabled()) {
        static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
            { "anchorElement", "Element", AnchorElementAttributeGetCallback, AnchorElementAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
        };
        v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
        v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
        IDLMemberInstaller::InstallAttributes(isolate, world, instance_template, prototype_template, interface_template, signature, kAttributeTable);
    }
    if (RuntimeEnabledFeatures::ComputedAccessibilityInfoEnabled()) {
        static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
            { "computedRole", "Element", ComputedRoleAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "computedName", "Element", ComputedNameAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone) },
        };
        v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
        v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
        IDLMemberInstaller::InstallAttributes(isolate, world, instance_template, prototype_template, interface_template, signature, kAttributeTable);
    }
    if (RuntimeEnabledFeatures::AriaRowColIndexTextEnabled()) {
        static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
            { "ariaColIndexText", "Element", AriaColIndexTextAttributeGetCallback, AriaColIndexTextAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ariaRowIndexText", "Element", AriaRowIndexTextAttributeGetCallback, AriaRowIndexTextAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
        };
        v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
        v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
        IDLMemberInstaller::InstallAttributes(isolate, world, instance_template, prototype_template, interface_template, signature, kAttributeTable);
    }
    if (RuntimeEnabledFeatures::AccessibilityAriaVirtualContentEnabled()) {
        static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
            { "ariaVirtualContent", "Element", AriaVirtualContentAttributeGetCallback, AriaVirtualContentAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
        };
        v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
        v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
        IDLMemberInstaller::InstallAttributes(isolate, world, instance_template, prototype_template, interface_template, signature, kAttributeTable);
    }
    if (RuntimeEnabledFeatures::AOMAriaRelationshipPropertiesEnabled()) {
        static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
            { "ariaActiveDescendantElement", "Element", AriaActiveDescendantElementAttributeGetCallback, AriaActiveDescendantElementAttributeSetCallback,
                unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ariaControlsElements", "Element", AriaControlsElementsAttributeGetCallback, AriaControlsElementsAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ariaDescribedByElements", "Element", AriaDescribedByElementsAttributeGetCallback, AriaDescribedByElementsAttributeSetCallback,
                unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ariaDetailsElements", "Element", AriaDetailsElementsAttributeGetCallback, AriaDetailsElementsAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ariaErrorMessageElements", "Element", AriaErrorMessageElementsAttributeGetCallback, AriaErrorMessageElementsAttributeSetCallback,
                unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ariaFlowToElements", "Element", AriaFlowToElementsAttributeGetCallback, AriaFlowToElementsAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ariaLabelledByElements", "Element", AriaLabelledByElementsAttributeGetCallback, AriaLabelledByElementsAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
        };
        v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
        v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
        IDLMemberInstaller::InstallAttributes(isolate, world, instance_template, prototype_template, interface_template, signature, kAttributeTable);
    }
    if (RuntimeEnabledFeatures::AOMAriaRelationshipPropertiesEnabled() && RuntimeEnabledFeatures::AOMAriaRelationshipPropertiesAriaOwnsEnabled()) {
        static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
            { "ariaOwnsElements", "Element", AriaOwnsElementsAttributeGetCallback, AriaOwnsElementsAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
        };
        v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
        v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
        IDLMemberInstaller::InstallAttributes(isolate, world, instance_template, prototype_template, interface_template, signature, kAttributeTable);
    }

    if (RuntimeEnabledFeatures::AriaNotifyEnabled()) {
        static const IDLMemberInstaller::OperationConfig kOperationTable[] = {
            { "ariaNotify", "Element", AriaNotifyOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
        };
        v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
        v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
        IDLMemberInstaller::InstallOperations(isolate, world, instance_template, prototype_template, interface_template, signature, kOperationTable);
    }
    if (RuntimeEnabledFeatures::ElementGetInnerHTMLEnabled()) {
        static const IDLMemberInstaller::OperationConfig kOperationTable[] = {
            { "getInnerHTML", "Element", GetInnerHTMLOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect) },
        };
        v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
        v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
        IDLMemberInstaller::InstallOperations(isolate, world, instance_template, prototype_template, interface_template, signature, kOperationTable);
    }
    if (RuntimeEnabledFeatures::SanitizerAPIEnabled()) {
        static const IDLMemberInstaller::OperationConfig kOperationTable[] = {
            { "setHTML", "Element", SetHTMLOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
        };
        v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
        v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
        IDLMemberInstaller::InstallOperations(isolate, world, instance_template, prototype_template, interface_template, signature, kOperationTable);
    }
}

void V8Element::InstallContextDependentProperties(v8::Local<v8::Context> context, const DOMWrapperWorld& world, v8::Local<v8::Object> instance_object,
    v8::Local<v8::Object> prototype_object, v8::Local<v8::Object> interface_object, v8::Local<v8::Template> interface_template,
    FeatureSelector feature_selector)
{
    using bindings::IDLMemberInstaller;

    if (feature_selector.IsAll()) {
        // [Unscopable]
        // 3.7.3. Interface prototype object
        // https://webidl.spec.whatwg.org/#interface-prototype-object
        // step 10. If interface has any member declared with the [Unscopable]
        //   extended attribute, then:
        static constexpr const char* kUnscopablePropertyNames[] = {
            "after",
            "append",
            "before",
            "prepend",
            "remove",
            "replaceChildren",
            "replaceWith",
            "slot",
        };
        v8::Isolate* isolate = context->GetIsolate();
        bindings::InstallUnscopablePropertyNames(isolate, context, prototype_object, kUnscopablePropertyNames);
    }
}

} // namespace blink
