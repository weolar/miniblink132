// Copyright 2019 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// DO NOT EDIT: This file is auto-generated by
// //third_party/blink/renderer/bindings/scripts/generate_bindings.py
//
// Use the GN flag `blink_enable_generated_code_formatting=true` to enable
// formatting of the generated files.

#include "third_party/blink/renderer/bindings/core/v8/v8_css_position_try_descriptors.h"

#include "third_party/blink/public/mojom/origin_trials/origin_trial_feature.mojom-shared.h"
#include "third_party/blink/renderer/bindings/core/v8/generated_code_helper.h"
#include "third_party/blink/renderer/bindings/core/v8/is_return_type_compatible.h"
#include "third_party/blink/renderer/bindings/core/v8/native_value_traits_impl.h"
#include "third_party/blink/renderer/bindings/core/v8/to_v8_traits.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_css_style_declaration.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_set_return_value_for_core.h"
#include "third_party/blink/renderer/core/css/css_position_try_descriptors.h"
#include "third_party/blink/renderer/core/execution_context/execution_context.h"
#include "third_party/blink/renderer/platform/bindings/exception_messages.h"
#include "third_party/blink/renderer/platform/bindings/idl_member_installer.h"
#include "third_party/blink/renderer/platform/bindings/runtime_call_stats.h"
#include "third_party/blink/renderer/platform/bindings/v8_binding.h"
#include "third_party/blink/renderer/platform/bindings/wrapper_type_info.h"

namespace blink {

bool V8CSSPositionTryDescriptors::IsExposed(ExecutionContext* execution_context)
{

    return execution_context->IsWindow();
}

// Construction of WrapperTypeInfo may require non-trivial initialization due
// to cross-component address resolution in order to load the pointer to the
// parent interface's WrapperTypeInfo.  We ignore this issue because the issue
// happens only on component builds and the official release builds
// (statically-linked builds) are never affected by this issue.
#if defined(COMPONENT_BUILD) && defined(WIN32) && defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wglobal-constructors"
#endif

const WrapperTypeInfo V8CSSPositionTryDescriptors::wrapper_type_info_ {
    gin::kEmbedderBlink,
    V8CSSPositionTryDescriptors::InstallInterfaceTemplate,
    nullptr,
    "CSSPositionTryDescriptors",
    V8CSSStyleDeclaration::GetWrapperTypeInfo(),
    V8CSSPositionTryDescriptors::kThisTag,
    V8CSSPositionTryDescriptors::kMaxSubclassTag,
    WrapperTypeInfo::kWrapperTypeObjectPrototype,
    WrapperTypeInfo::kObjectClassId,
    WrapperTypeInfo::kNotInheritFromActiveScriptWrappable,
    WrapperTypeInfo::kIdlInterface,
    false,
};

#if defined(COMPONENT_BUILD) && defined(WIN32) && defined(__clang__)
#pragma clang diagnostic pop
#endif

const WrapperTypeInfo& CSSPositionTryDescriptors::wrapper_type_info_ = V8CSSPositionTryDescriptors::wrapper_type_info_;

// non-[ActiveScriptWrappable]
static_assert(!std::is_base_of<ActiveScriptWrappableBase, CSSPositionTryDescriptors>::value,
    "CSSPositionTryDescriptors inherits from ActiveScriptWrappable<> without "
    "[ActiveScriptWrappable] extended attribute.");

namespace {

namespace v8_css_position_try_descriptors {

void MarginAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_margin_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.margin.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->margin();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void MarginAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_margin_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.margin.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setMargin(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void MarginTopAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_marginTop_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.marginTop.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->marginTop();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void MarginTopAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_marginTop_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.marginTop.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setMarginTop(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void MarginRightAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_marginRight_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.marginRight.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->marginRight();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void MarginRightAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_marginRight_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.marginRight.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setMarginRight(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void MarginBottomAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_marginBottom_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.marginBottom.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->marginBottom();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void MarginBottomAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_marginBottom_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.marginBottom.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setMarginBottom(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void MarginLeftAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_marginLeft_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.marginLeft.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->marginLeft();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void MarginLeftAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_marginLeft_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.marginLeft.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setMarginLeft(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void MarginBlockAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_marginBlock_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.marginBlock.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->marginBlock();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void MarginBlockAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_marginBlock_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.marginBlock.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setMarginBlock(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void MarginBlockStartAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_marginBlockStart_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.marginBlockStart.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->marginBlockStart();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void MarginBlockStartAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_marginBlockStart_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.marginBlockStart.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setMarginBlockStart(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void MarginBlockEndAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_marginBlockEnd_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.marginBlockEnd.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->marginBlockEnd();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void MarginBlockEndAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_marginBlockEnd_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.marginBlockEnd.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setMarginBlockEnd(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void MarginInlineAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_marginInline_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.marginInline.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->marginInline();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void MarginInlineAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_marginInline_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.marginInline.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setMarginInline(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void MarginInlineStartAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_marginInlineStart_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.marginInlineStart.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->marginInlineStart();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void MarginInlineStartAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_marginInlineStart_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.marginInlineStart.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setMarginInlineStart(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void MarginInlineEndAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_marginInlineEnd_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.marginInlineEnd.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->marginInlineEnd();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void MarginInlineEndAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_marginInlineEnd_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.marginInlineEnd.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setMarginInlineEnd(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void MarginDec45TopAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_margin-top_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.margin-top.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->marginTop();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void MarginDec45TopAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_margin-top_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.margin-top.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setMarginTop(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void MarginDec45RightAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_margin-right_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.margin-right.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->marginRight();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void MarginDec45RightAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_margin-right_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.margin-right.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setMarginRight(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void MarginDec45BottomAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_margin-bottom_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.margin-bottom.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->marginBottom();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void MarginDec45BottomAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_margin-bottom_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.margin-bottom.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setMarginBottom(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void MarginDec45LeftAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_margin-left_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.margin-left.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->marginLeft();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void MarginDec45LeftAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_margin-left_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.margin-left.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setMarginLeft(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void MarginDec45BlockAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_margin-block_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.margin-block.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->marginBlock();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void MarginDec45BlockAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_margin-block_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.margin-block.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setMarginBlock(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void MarginDec45BlockDec45StartAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_margin-block-start_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.margin-block-start.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->marginBlockStart();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void MarginDec45BlockDec45StartAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_margin-block-start_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.margin-block-start.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setMarginBlockStart(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void MarginDec45BlockDec45EndAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_margin-block-end_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.margin-block-end.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->marginBlockEnd();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void MarginDec45BlockDec45EndAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_margin-block-end_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.margin-block-end.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setMarginBlockEnd(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void MarginDec45InlineAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_margin-inline_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.margin-inline.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->marginInline();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void MarginDec45InlineAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_margin-inline_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.margin-inline.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setMarginInline(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void MarginDec45InlineDec45StartAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_margin-inline-start_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.margin-inline-start.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->marginInlineStart();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void MarginDec45InlineDec45StartAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_margin-inline-start_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.margin-inline-start.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setMarginInlineStart(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void MarginDec45InlineDec45EndAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_margin-inline-end_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.margin-inline-end.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->marginInlineEnd();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void MarginDec45InlineDec45EndAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_margin-inline-end_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.margin-inline-end.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setMarginInlineEnd(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void InsetAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_inset_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.inset.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->inset();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void InsetAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_inset_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.inset.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setInset(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void InsetBlockAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_insetBlock_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.insetBlock.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->insetBlock();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void InsetBlockAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_insetBlock_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.insetBlock.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setInsetBlock(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void InsetBlockStartAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_insetBlockStart_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.insetBlockStart.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->insetBlockStart();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void InsetBlockStartAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_insetBlockStart_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.insetBlockStart.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setInsetBlockStart(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void InsetBlockEndAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_insetBlockEnd_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.insetBlockEnd.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->insetBlockEnd();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void InsetBlockEndAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_insetBlockEnd_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.insetBlockEnd.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setInsetBlockEnd(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void InsetInlineAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_insetInline_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.insetInline.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->insetInline();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void InsetInlineAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_insetInline_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.insetInline.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setInsetInline(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void InsetInlineStartAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_insetInlineStart_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.insetInlineStart.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->insetInlineStart();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void InsetInlineStartAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_insetInlineStart_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.insetInlineStart.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setInsetInlineStart(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void InsetInlineEndAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_insetInlineEnd_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.insetInlineEnd.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->insetInlineEnd();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void InsetInlineEndAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_insetInlineEnd_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.insetInlineEnd.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setInsetInlineEnd(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void TopAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_top_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.top.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->top();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void TopAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_top_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.top.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setTop(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void LeftAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_left_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.left.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->left();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void LeftAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_left_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.left.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setLeft(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void RightAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_right_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.right.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->right();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void RightAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_right_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.right.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setRight(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void BottomAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_bottom_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.bottom.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->bottom();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void BottomAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_bottom_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.bottom.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setBottom(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void InsetDec45BlockAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_inset-block_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.inset-block.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->insetBlock();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void InsetDec45BlockAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_inset-block_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.inset-block.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setInsetBlock(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void InsetDec45BlockDec45StartAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_inset-block-start_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.inset-block-start.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->insetBlockStart();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void InsetDec45BlockDec45StartAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_inset-block-start_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.inset-block-start.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setInsetBlockStart(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void InsetDec45BlockDec45EndAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_inset-block-end_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.inset-block-end.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->insetBlockEnd();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void InsetDec45BlockDec45EndAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_inset-block-end_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.inset-block-end.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setInsetBlockEnd(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void InsetDec45InlineAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_inset-inline_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.inset-inline.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->insetInline();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void InsetDec45InlineAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_inset-inline_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.inset-inline.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setInsetInline(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void InsetDec45InlineDec45StartAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_inset-inline-start_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.inset-inline-start.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->insetInlineStart();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void InsetDec45InlineDec45StartAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_inset-inline-start_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.inset-inline-start.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setInsetInlineStart(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void InsetDec45InlineDec45EndAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_inset-inline-end_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.inset-inline-end.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->insetInlineEnd();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void InsetDec45InlineDec45EndAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_inset-inline-end_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.inset-inline-end.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setInsetInlineEnd(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void WidthAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_width_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.width.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->width();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void WidthAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_width_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.width.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setWidth(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void MinWidthAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_minWidth_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.minWidth.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->minWidth();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void MinWidthAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_minWidth_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.minWidth.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setMinWidth(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void MaxWidthAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_maxWidth_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.maxWidth.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->maxWidth();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void MaxWidthAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_maxWidth_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.maxWidth.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setMaxWidth(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void HeightAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_height_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.height.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->height();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void HeightAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_height_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.height.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setHeight(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void MinHeightAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_minHeight_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.minHeight.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->minHeight();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void MinHeightAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_minHeight_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.minHeight.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setMinHeight(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void MaxHeightAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_maxHeight_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.maxHeight.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->maxHeight();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void MaxHeightAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_maxHeight_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.maxHeight.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setMaxHeight(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void BlockSizeAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_blockSize_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.blockSize.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->blockSize();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void BlockSizeAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_blockSize_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.blockSize.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setBlockSize(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void MinBlockSizeAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_minBlockSize_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.minBlockSize.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->minBlockSize();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void MinBlockSizeAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_minBlockSize_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.minBlockSize.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setMinBlockSize(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void MaxBlockSizeAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_maxBlockSize_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.maxBlockSize.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->maxBlockSize();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void MaxBlockSizeAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_maxBlockSize_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.maxBlockSize.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setMaxBlockSize(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void InlineSizeAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_inlineSize_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.inlineSize.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->inlineSize();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void InlineSizeAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_inlineSize_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.inlineSize.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setInlineSize(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void MinInlineSizeAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_minInlineSize_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.minInlineSize.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->minInlineSize();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void MinInlineSizeAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_minInlineSize_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.minInlineSize.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setMinInlineSize(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void MaxInlineSizeAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_maxInlineSize_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.maxInlineSize.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->maxInlineSize();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void MaxInlineSizeAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_maxInlineSize_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.maxInlineSize.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setMaxInlineSize(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void MinDec45WidthAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_min-width_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.min-width.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->minWidth();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void MinDec45WidthAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_min-width_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.min-width.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setMinWidth(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void MaxDec45WidthAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_max-width_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.max-width.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->maxWidth();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void MaxDec45WidthAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_max-width_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.max-width.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setMaxWidth(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void MinDec45HeightAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_min-height_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.min-height.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->minHeight();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void MinDec45HeightAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_min-height_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.min-height.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setMinHeight(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void MaxDec45HeightAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_max-height_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.max-height.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->maxHeight();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void MaxDec45HeightAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_max-height_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.max-height.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setMaxHeight(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void BlockDec45SizeAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_block-size_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.block-size.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->blockSize();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void BlockDec45SizeAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_block-size_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.block-size.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setBlockSize(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void MinDec45BlockDec45SizeAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_min-block-size_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.min-block-size.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->minBlockSize();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void MinDec45BlockDec45SizeAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_min-block-size_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.min-block-size.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setMinBlockSize(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void MaxDec45BlockDec45SizeAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_max-block-size_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.max-block-size.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->maxBlockSize();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void MaxDec45BlockDec45SizeAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_max-block-size_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.max-block-size.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setMaxBlockSize(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void InlineDec45SizeAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_inline-size_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.inline-size.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->inlineSize();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void InlineDec45SizeAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_inline-size_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.inline-size.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setInlineSize(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void MinDec45InlineDec45SizeAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_min-inline-size_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.min-inline-size.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->minInlineSize();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void MinDec45InlineDec45SizeAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_min-inline-size_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.min-inline-size.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setMinInlineSize(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void MaxDec45InlineDec45SizeAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_max-inline-size_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.max-inline-size.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->maxInlineSize();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void MaxDec45InlineDec45SizeAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_max-inline-size_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.max-inline-size.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setMaxInlineSize(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void PlaceSelfAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_placeSelf_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.placeSelf.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->placeSelf();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void PlaceSelfAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_placeSelf_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.placeSelf.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setPlaceSelf(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void AlignSelfAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_alignSelf_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.alignSelf.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->alignSelf();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void AlignSelfAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_alignSelf_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.alignSelf.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setAlignSelf(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void JustifySelfAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_justifySelf_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.justifySelf.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->justifySelf();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void JustifySelfAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_justifySelf_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.justifySelf.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setJustifySelf(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void PlaceDec45SelfAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_place-self_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.place-self.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->placeSelf();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void PlaceDec45SelfAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_place-self_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.place-self.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setPlaceSelf(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void AlignDec45SelfAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_align-self_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.align-self.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->alignSelf();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void AlignDec45SelfAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_align-self_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.align-self.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setAlignSelf(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void JustifyDec45SelfAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_justify-self_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.justify-self.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->justifySelf();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void JustifyDec45SelfAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_justify-self_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.justify-self.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setJustifySelf(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void PositionAnchorAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_positionAnchor_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.positionAnchor.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->positionAnchor();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void PositionAnchorAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_positionAnchor_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.positionAnchor.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setPositionAnchor(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void PositionDec45AnchorAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_position-anchor_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.position-anchor.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->positionAnchor();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void PositionDec45AnchorAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_position-anchor_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.position-anchor.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setPositionAnchor(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void PositionAreaAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_positionArea_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.positionArea.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->positionArea();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void PositionAreaAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_positionArea_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.positionArea.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setPositionArea(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void PositionDec45AreaAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_position-area_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.position-area.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->positionArea();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void PositionDec45AreaAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_position-area_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.position-area.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setPositionArea(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void InsetAreaAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_insetArea_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.insetArea.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->insetArea();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void InsetAreaAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_insetArea_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.insetArea.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setInsetArea(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void InsetDec45AreaAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_inset-area_Getter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.inset-area.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->insetArea();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void InsetDec45AreaAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_CSSPositionTryDescriptors_inset-area_Setter");
    BLINK_BINDINGS_TRACE_EVENT("CSSPositionTryDescriptors.inset-area.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    CSSPositionTryDescriptors* blink_receiver = V8CSSPositionTryDescriptors::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
    ExecutionContext* execution_context = receiver_execution_context;
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setInsetArea(execution_context, arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

} // namespace v8_css_position_try_descriptors

using namespace v8_css_position_try_descriptors;

} // namespace

void V8CSSPositionTryDescriptors::InstallInterfaceTemplate(v8::Isolate* isolate, const DOMWrapperWorld& world, v8::Local<v8::Template> interface_template)
{
    const WrapperTypeInfo* const wrapper_type_info = V8CSSPositionTryDescriptors::GetWrapperTypeInfo();
    v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
    v8::Local<v8::ObjectTemplate> instance_object_template = interface_function_template->InstanceTemplate();
    v8::Local<v8::ObjectTemplate> prototype_object_template = interface_function_template->PrototypeTemplate();
    v8::Local<v8::FunctionTemplate> parent_interface_template = wrapper_type_info->parent_class->GetV8ClassTemplate(isolate, world).As<v8::FunctionTemplate>();
    bindings::SetupIDLInterfaceTemplate(
        isolate, wrapper_type_info, instance_object_template, prototype_object_template, interface_function_template, parent_interface_template);

    v8::Local<v8::Template> instance_template = instance_object_template;
    v8::Local<v8::Template> prototype_template = prototype_object_template;
    InstallUnconditionalProperties(isolate, world, instance_template, prototype_template, interface_template);
    InstallContextIndependentProperties(isolate, world, instance_template, prototype_template, interface_template);
}

void V8CSSPositionTryDescriptors::InstallUnconditionalProperties(v8::Isolate* isolate, const DOMWrapperWorld& world, v8::Local<v8::Template> instance_template,
    v8::Local<v8::Template> prototype_template, v8::Local<v8::Template> interface_template)
{
    using bindings::IDLMemberInstaller;

    {
        static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
            { "margin", "CSSPositionTryDescriptors", MarginAttributeGetCallback, MarginAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "marginTop", "CSSPositionTryDescriptors", MarginTopAttributeGetCallback, MarginTopAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "marginRight", "CSSPositionTryDescriptors", MarginRightAttributeGetCallback, MarginRightAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "marginBottom", "CSSPositionTryDescriptors", MarginBottomAttributeGetCallback, MarginBottomAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "marginLeft", "CSSPositionTryDescriptors", MarginLeftAttributeGetCallback, MarginLeftAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "marginBlock", "CSSPositionTryDescriptors", MarginBlockAttributeGetCallback, MarginBlockAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "marginBlockStart", "CSSPositionTryDescriptors", MarginBlockStartAttributeGetCallback, MarginBlockStartAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "marginBlockEnd", "CSSPositionTryDescriptors", MarginBlockEndAttributeGetCallback, MarginBlockEndAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "marginInline", "CSSPositionTryDescriptors", MarginInlineAttributeGetCallback, MarginInlineAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "marginInlineStart", "CSSPositionTryDescriptors", MarginInlineStartAttributeGetCallback, MarginInlineStartAttributeSetCallback,
                unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "marginInlineEnd", "CSSPositionTryDescriptors", MarginInlineEndAttributeGetCallback, MarginInlineEndAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "margin-top", "CSSPositionTryDescriptors", MarginDec45TopAttributeGetCallback, MarginDec45TopAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "margin-right", "CSSPositionTryDescriptors", MarginDec45RightAttributeGetCallback, MarginDec45RightAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "margin-bottom", "CSSPositionTryDescriptors", MarginDec45BottomAttributeGetCallback, MarginDec45BottomAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "margin-left", "CSSPositionTryDescriptors", MarginDec45LeftAttributeGetCallback, MarginDec45LeftAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "margin-block", "CSSPositionTryDescriptors", MarginDec45BlockAttributeGetCallback, MarginDec45BlockAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "margin-block-start", "CSSPositionTryDescriptors", MarginDec45BlockDec45StartAttributeGetCallback, MarginDec45BlockDec45StartAttributeSetCallback,
                unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "margin-block-end", "CSSPositionTryDescriptors", MarginDec45BlockDec45EndAttributeGetCallback, MarginDec45BlockDec45EndAttributeSetCallback,
                unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "margin-inline", "CSSPositionTryDescriptors", MarginDec45InlineAttributeGetCallback, MarginDec45InlineAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "margin-inline-start", "CSSPositionTryDescriptors", MarginDec45InlineDec45StartAttributeGetCallback,
                MarginDec45InlineDec45StartAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "margin-inline-end", "CSSPositionTryDescriptors", MarginDec45InlineDec45EndAttributeGetCallback, MarginDec45InlineDec45EndAttributeSetCallback,
                unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "inset", "CSSPositionTryDescriptors", InsetAttributeGetCallback, InsetAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "insetBlock", "CSSPositionTryDescriptors", InsetBlockAttributeGetCallback, InsetBlockAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "insetBlockStart", "CSSPositionTryDescriptors", InsetBlockStartAttributeGetCallback, InsetBlockStartAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "insetBlockEnd", "CSSPositionTryDescriptors", InsetBlockEndAttributeGetCallback, InsetBlockEndAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "insetInline", "CSSPositionTryDescriptors", InsetInlineAttributeGetCallback, InsetInlineAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "insetInlineStart", "CSSPositionTryDescriptors", InsetInlineStartAttributeGetCallback, InsetInlineStartAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "insetInlineEnd", "CSSPositionTryDescriptors", InsetInlineEndAttributeGetCallback, InsetInlineEndAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "top", "CSSPositionTryDescriptors", TopAttributeGetCallback, TopAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "left", "CSSPositionTryDescriptors", LeftAttributeGetCallback, LeftAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "right", "CSSPositionTryDescriptors", RightAttributeGetCallback, RightAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "bottom", "CSSPositionTryDescriptors", BottomAttributeGetCallback, BottomAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "inset-block", "CSSPositionTryDescriptors", InsetDec45BlockAttributeGetCallback, InsetDec45BlockAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "inset-block-start", "CSSPositionTryDescriptors", InsetDec45BlockDec45StartAttributeGetCallback, InsetDec45BlockDec45StartAttributeSetCallback,
                unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "inset-block-end", "CSSPositionTryDescriptors", InsetDec45BlockDec45EndAttributeGetCallback, InsetDec45BlockDec45EndAttributeSetCallback,
                unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "inset-inline", "CSSPositionTryDescriptors", InsetDec45InlineAttributeGetCallback, InsetDec45InlineAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "inset-inline-start", "CSSPositionTryDescriptors", InsetDec45InlineDec45StartAttributeGetCallback, InsetDec45InlineDec45StartAttributeSetCallback,
                unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "inset-inline-end", "CSSPositionTryDescriptors", InsetDec45InlineDec45EndAttributeGetCallback, InsetDec45InlineDec45EndAttributeSetCallback,
                unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "width", "CSSPositionTryDescriptors", WidthAttributeGetCallback, WidthAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "minWidth", "CSSPositionTryDescriptors", MinWidthAttributeGetCallback, MinWidthAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "maxWidth", "CSSPositionTryDescriptors", MaxWidthAttributeGetCallback, MaxWidthAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "height", "CSSPositionTryDescriptors", HeightAttributeGetCallback, HeightAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "minHeight", "CSSPositionTryDescriptors", MinHeightAttributeGetCallback, MinHeightAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "maxHeight", "CSSPositionTryDescriptors", MaxHeightAttributeGetCallback, MaxHeightAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "blockSize", "CSSPositionTryDescriptors", BlockSizeAttributeGetCallback, BlockSizeAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "minBlockSize", "CSSPositionTryDescriptors", MinBlockSizeAttributeGetCallback, MinBlockSizeAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "maxBlockSize", "CSSPositionTryDescriptors", MaxBlockSizeAttributeGetCallback, MaxBlockSizeAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "inlineSize", "CSSPositionTryDescriptors", InlineSizeAttributeGetCallback, InlineSizeAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "minInlineSize", "CSSPositionTryDescriptors", MinInlineSizeAttributeGetCallback, MinInlineSizeAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "maxInlineSize", "CSSPositionTryDescriptors", MaxInlineSizeAttributeGetCallback, MaxInlineSizeAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "min-width", "CSSPositionTryDescriptors", MinDec45WidthAttributeGetCallback, MinDec45WidthAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "max-width", "CSSPositionTryDescriptors", MaxDec45WidthAttributeGetCallback, MaxDec45WidthAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "min-height", "CSSPositionTryDescriptors", MinDec45HeightAttributeGetCallback, MinDec45HeightAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "max-height", "CSSPositionTryDescriptors", MaxDec45HeightAttributeGetCallback, MaxDec45HeightAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "block-size", "CSSPositionTryDescriptors", BlockDec45SizeAttributeGetCallback, BlockDec45SizeAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "min-block-size", "CSSPositionTryDescriptors", MinDec45BlockDec45SizeAttributeGetCallback, MinDec45BlockDec45SizeAttributeSetCallback,
                unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "max-block-size", "CSSPositionTryDescriptors", MaxDec45BlockDec45SizeAttributeGetCallback, MaxDec45BlockDec45SizeAttributeSetCallback,
                unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "inline-size", "CSSPositionTryDescriptors", InlineDec45SizeAttributeGetCallback, InlineDec45SizeAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "min-inline-size", "CSSPositionTryDescriptors", MinDec45InlineDec45SizeAttributeGetCallback, MinDec45InlineDec45SizeAttributeSetCallback,
                unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "max-inline-size", "CSSPositionTryDescriptors", MaxDec45InlineDec45SizeAttributeGetCallback, MaxDec45InlineDec45SizeAttributeSetCallback,
                unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "placeSelf", "CSSPositionTryDescriptors", PlaceSelfAttributeGetCallback, PlaceSelfAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "alignSelf", "CSSPositionTryDescriptors", AlignSelfAttributeGetCallback, AlignSelfAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "justifySelf", "CSSPositionTryDescriptors", JustifySelfAttributeGetCallback, JustifySelfAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "place-self", "CSSPositionTryDescriptors", PlaceDec45SelfAttributeGetCallback, PlaceDec45SelfAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "align-self", "CSSPositionTryDescriptors", AlignDec45SelfAttributeGetCallback, AlignDec45SelfAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "justify-self", "CSSPositionTryDescriptors", JustifyDec45SelfAttributeGetCallback, JustifyDec45SelfAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "positionAnchor", "CSSPositionTryDescriptors", PositionAnchorAttributeGetCallback, PositionAnchorAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "position-anchor", "CSSPositionTryDescriptors", PositionDec45AnchorAttributeGetCallback, PositionDec45AnchorAttributeSetCallback,
                unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "positionArea", "CSSPositionTryDescriptors", PositionAreaAttributeGetCallback, PositionAreaAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "position-area", "CSSPositionTryDescriptors", PositionDec45AreaAttributeGetCallback, PositionDec45AreaAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
        };
        v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
        v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
        IDLMemberInstaller::InstallAttributes(isolate, world, instance_template, prototype_template, interface_template, signature, kAttributeTable);
    }
}

void V8CSSPositionTryDescriptors::InstallContextIndependentProperties(v8::Isolate* isolate, const DOMWrapperWorld& world,
    v8::Local<v8::Template> instance_template, v8::Local<v8::Template> prototype_template, v8::Local<v8::Template> interface_template)
{
    using bindings::IDLMemberInstaller;

    if (RuntimeEnabledFeatures::CSSInsetAreaPropertyEnabled()) {
        static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
            { "insetArea", "CSSPositionTryDescriptors", InsetAreaAttributeGetCallback, InsetAreaAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "inset-area", "CSSPositionTryDescriptors", InsetDec45AreaAttributeGetCallback, InsetDec45AreaAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
        };
        v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
        v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
        IDLMemberInstaller::InstallAttributes(isolate, world, instance_template, prototype_template, interface_template, signature, kAttributeTable);
    }
}

} // namespace blink
