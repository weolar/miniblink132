// Copyright 2019 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// DO NOT EDIT: This file is auto-generated by
// //third_party/blink/renderer/bindings/scripts/generate_bindings.py
//
// Use the GN flag `blink_enable_generated_code_formatting=true` to enable
// formatting of the generated files.

#include "third_party/blink/renderer/bindings/core/v8/v8_node.h"

#include "third_party/blink/public/mojom/origin_trials/origin_trial_feature.mojom-shared.h"
#include "third_party/blink/renderer/bindings/core/v8/generated_code_helper.h"
#include "third_party/blink/renderer/bindings/core/v8/is_return_type_compatible.h"
#include "third_party/blink/renderer/bindings/core/v8/native_value_traits_impl.h"
#include "third_party/blink/renderer/bindings/core/v8/to_v8_traits.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_document.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_element.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_event_target.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_get_root_node_options.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_node_list.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_set_return_value_for_core.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_trusted_script.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_union_string_trustedscript.h"
#include "third_party/blink/renderer/core/dom/document.h"
#include "third_party/blink/renderer/core/dom/element.h"
#include "third_party/blink/renderer/core/dom/node.h"
#include "third_party/blink/renderer/core/dom/node_list.h"
#include "third_party/blink/renderer/core/execution_context/execution_context.h"
#include "third_party/blink/renderer/core/frame/web_feature.h"
#include "third_party/blink/renderer/core/html/custom/ce_reactions_scope.h"
#include "third_party/blink/renderer/core/trustedtypes/trusted_script.h"
#include "third_party/blink/renderer/platform/bindings/exception_messages.h"
#include "third_party/blink/renderer/platform/bindings/idl_member_installer.h"
#include "third_party/blink/renderer/platform/bindings/runtime_call_stats.h"
#include "third_party/blink/renderer/platform/bindings/v8_binding.h"
#include "third_party/blink/renderer/platform/bindings/wrapper_type_info.h"
#include "third_party/blink/renderer/platform/instrumentation/use_counter.h"

namespace blink {

bool V8Node::IsExposed(ExecutionContext* execution_context)
{

    return execution_context->IsWindow();
}

// Construction of WrapperTypeInfo may require non-trivial initialization due
// to cross-component address resolution in order to load the pointer to the
// parent interface's WrapperTypeInfo.  We ignore this issue because the issue
// happens only on component builds and the official release builds
// (statically-linked builds) are never affected by this issue.
#if defined(COMPONENT_BUILD) && defined(WIN32) && defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wglobal-constructors"
#endif

const WrapperTypeInfo V8Node::wrapper_type_info_ {
    gin::kEmbedderBlink,
    V8Node::InstallInterfaceTemplate,
    nullptr,
    "Node",
    V8EventTarget::GetWrapperTypeInfo(),
    V8Node::kThisTag,
    V8Node::kMaxSubclassTag,
    WrapperTypeInfo::kWrapperTypeObjectPrototype,
    WrapperTypeInfo::kNodeClassId,
    WrapperTypeInfo::kNotInheritFromActiveScriptWrappable,
    WrapperTypeInfo::kIdlInterface,
    false,
};

#if defined(COMPONENT_BUILD) && defined(WIN32) && defined(__clang__)
#pragma clang diagnostic pop
#endif

const WrapperTypeInfo& Node::wrapper_type_info_ = V8Node::wrapper_type_info_;

// non-[ActiveScriptWrappable]
static_assert(!std::is_base_of<ActiveScriptWrappableBase, Node>::value,
    "Node inherits from ActiveScriptWrappable<> without "
    "[ActiveScriptWrappable] extended attribute.");

namespace {

namespace v8_node {

void NodeTypeAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Node_nodeType_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Node.nodeType.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Node* blink_receiver = V8Node::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->getNodeType();
    static_assert(bindings::IsReturnTypeCompatible<IDLUnsignedShort, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<uint16_t>());
}

void NodeNameAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE(info.GetIsolate(), RuntimeCallStats::CounterId::kNodeName_Getter);
    BLINK_BINDINGS_TRACE_EVENT("Node.nodeName.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Node* blink_receiver = V8Node::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->nodeName();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void BaseURIAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Node_baseURI_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Node.baseURI.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Node* blink_receiver = V8Node::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->baseURI();
    static_assert(bindings::IsReturnTypeCompatible<IDLUSVString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void IsConnectedAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Node_isConnected_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Node.isConnected.get");
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kV8Node_IsConnected_AttributeGetter);

    v8::Local<v8::Object> v8_receiver = info.This();
    Node* blink_receiver = V8Node::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->isConnected();
    static_assert(bindings::IsReturnTypeCompatible<IDLBoolean, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void OwnerDocumentAttributeGetCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Node_ownerDocument_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Node.ownerDocument.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Node* blink_receiver = V8Node::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ownerDocument();
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<Document>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::kMainWorld);
}

void OwnerDocumentAttributeGetCallbackForNonMainWorlds(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Node_ownerDocument_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Node.ownerDocument.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Node* blink_receiver = V8Node::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ownerDocument();
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<Document>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void ParentNodeAttributeGetCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Node_parentNode_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Node.parentNode.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Node* blink_receiver = V8Node::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->parentNode();
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<Node>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::kMainWorld);
}

void ParentNodeAttributeGetCallbackForNonMainWorlds(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Node_parentNode_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Node.parentNode.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Node* blink_receiver = V8Node::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->parentNode();
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<Node>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void ParentElementAttributeGetCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Node_parentElement_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Node.parentElement.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Node* blink_receiver = V8Node::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->parentElement();
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<Element>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::kMainWorld);
}

void ParentElementAttributeGetCallbackForNonMainWorlds(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Node_parentElement_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Node.parentElement.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Node* blink_receiver = V8Node::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->parentElement();
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<Element>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void ChildNodesAttributeGetCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Node_childNodes_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Node.childNodes.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Node* blink_receiver = V8Node::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->childNodes();
    static_assert(bindings::IsReturnTypeCompatible<NodeList, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::kMainWorld);
}

void ChildNodesAttributeGetCallbackForNonMainWorlds(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Node_childNodes_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Node.childNodes.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Node* blink_receiver = V8Node::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->childNodes();
    static_assert(bindings::IsReturnTypeCompatible<NodeList, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void FirstChildAttributeGetCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Node_firstChild_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Node.firstChild.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Node* blink_receiver = V8Node::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->firstChild();
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<Node>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::kMainWorld);
}

void FirstChildAttributeGetCallbackForNonMainWorlds(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Node_firstChild_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Node.firstChild.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Node* blink_receiver = V8Node::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->firstChild();
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<Node>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void LastChildAttributeGetCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Node_lastChild_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Node.lastChild.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Node* blink_receiver = V8Node::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->lastChild();
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<Node>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::kMainWorld);
}

void LastChildAttributeGetCallbackForNonMainWorlds(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Node_lastChild_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Node.lastChild.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Node* blink_receiver = V8Node::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->lastChild();
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<Node>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void PreviousSiblingAttributeGetCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Node_previousSibling_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Node.previousSibling.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Node* blink_receiver = V8Node::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->previousSibling();
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<Node>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::kMainWorld);
}

void PreviousSiblingAttributeGetCallbackForNonMainWorlds(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Node_previousSibling_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Node.previousSibling.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Node* blink_receiver = V8Node::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->previousSibling();
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<Node>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void NextSiblingAttributeGetCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Node_nextSibling_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Node.nextSibling.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Node* blink_receiver = V8Node::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->nextSibling();
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<Node>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::kMainWorld);
}

void NextSiblingAttributeGetCallbackForNonMainWorlds(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Node_nextSibling_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Node.nextSibling.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Node* blink_receiver = V8Node::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->nextSibling();
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<Node>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void NodeValueAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Node_nodeValue_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Node.nodeValue.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Node* blink_receiver = V8Node::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->nodeValue();
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void NodeValueAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Node_nodeValue_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Node.nodeValue.set");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    ExceptionState exception_state(isolate);

    // [CEReactions]
    CEReactionsScope ce_reactions_scope;

    v8::Local<v8::Object> v8_receiver = info.This();
    Node* blink_receiver = V8Node::ToWrappableUnsafe(isolate, v8_receiver);
    v8::Local<v8::Value> v8_property_value = info[0];
    auto&& arg1_value = NativeValueTraits<IDLNullable<IDLString>>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setNodeValue(arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void TextContentAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Node_textContent_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Node.textContent.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    Node* blink_receiver = V8Node::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->textContentForBinding();
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<V8UnionStringOrTrustedScript>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    v8::Local<v8::Value> v8_return_value = ToV8Traits<IDLNullable<V8UnionStringOrTrustedScript>>::ToV8(script_state, return_value);
    bindings::V8SetReturnValue(info, v8_return_value);
}

void TextContentAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Node_textContent_Setter");
    BLINK_BINDINGS_TRACE_EVENT("Node.textContent.set");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    ExceptionState exception_state(isolate);

    // [CEReactions]
    CEReactionsScope ce_reactions_scope;

    v8::Local<v8::Object> v8_receiver = info.This();
    Node* blink_receiver = V8Node::ToWrappableUnsafe(isolate, v8_receiver);
    v8::Local<v8::Value> v8_property_value = info[0];
    auto&& arg1_value = NativeValueTraits<IDLNullable<V8UnionStringOrTrustedScript>>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setTextContentForBinding(arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void AppendChildOperationCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE(info.GetIsolate(), RuntimeCallStats::CounterId::kNodeAppendChild);
    BLINK_BINDINGS_TRACE_EVENT("Node.appendChild");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    ExceptionState exception_state(isolate);

    // [CEReactions]
    CEReactionsScope ce_reactions_scope;

    v8::Local<v8::Object> v8_receiver = info.This();
    Node* blink_receiver = V8Node::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& arg1_node = NativeValueTraits<Node>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->appendChild(arg1_node, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<Node, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::kMainWorld);
}

void AppendChildOperationCallbackForNonMainWorlds(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE(info.GetIsolate(), RuntimeCallStats::CounterId::kNodeAppendChild);
    BLINK_BINDINGS_TRACE_EVENT("Node.appendChild");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    ExceptionState exception_state(isolate);

    // [CEReactions]
    CEReactionsScope ce_reactions_scope;

    v8::Local<v8::Object> v8_receiver = info.This();
    Node* blink_receiver = V8Node::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& arg1_node = NativeValueTraits<Node>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->appendChild(arg1_node, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<Node, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void CloneNodeOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Node_cloneNode");
    BLINK_BINDINGS_TRACE_EVENT("Node.cloneNode");

    v8::Isolate* isolate = info.GetIsolate();
    ExceptionState exception_state(isolate);

    // [CEReactions]
    CEReactionsScope ce_reactions_scope;

    v8::Local<v8::Object> v8_receiver = info.This();
    Node* blink_receiver = V8Node::ToWrappableUnsafe(isolate, v8_receiver);
    decltype(NativeValueTraits<IDLBoolean>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg1_deep { false };
    if (!info[0]->IsUndefined()) {
        arg1_deep = NativeValueTraits<IDLBoolean>::ArgumentValue(isolate, 0, info[0], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->cloneNode(arg1_deep, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<Node, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void CompareDocumentPositionOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Node_compareDocumentPosition");
    BLINK_BINDINGS_TRACE_EVENT("Node.compareDocumentPosition");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Node* blink_receiver = V8Node::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_other = NativeValueTraits<Node>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->compareDocumentPosition(arg1_other);
    static_assert(bindings::IsReturnTypeCompatible<IDLUnsignedShort, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<uint16_t>());
}

void ContainsOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Node_contains");
    BLINK_BINDINGS_TRACE_EVENT("Node.contains");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Node* blink_receiver = V8Node::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_other = NativeValueTraits<IDLNullable<Node>>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->contains(arg1_other);
    static_assert(bindings::IsReturnTypeCompatible<IDLBoolean, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void GetRootNodeOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Node_getRootNode");
    BLINK_BINDINGS_TRACE_EVENT("Node.getRootNode");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kNodeGetRootNode);

    v8::Local<v8::Object> v8_receiver = info.This();
    Node* blink_receiver = V8Node::ToWrappableUnsafe(isolate, v8_receiver);
    decltype(NativeValueTraits<GetRootNodeOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg1_options;
    if (info[0]->IsUndefined()) {
        arg1_options = GetRootNodeOptions::Create();
    } else {
        ExceptionState exception_state(isolate);
        arg1_options = NativeValueTraits<GetRootNodeOptions>::ArgumentValue(isolate, 0, info[0], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->getRootNode(arg1_options);
    static_assert(bindings::IsReturnTypeCompatible<Node, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void HasChildNodesOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Node_hasChildNodes");
    BLINK_BINDINGS_TRACE_EVENT("Node.hasChildNodes");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Node* blink_receiver = V8Node::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->hasChildren();
    static_assert(bindings::IsReturnTypeCompatible<IDLBoolean, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void InsertBeforeOperationCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Node_insertBefore");
    BLINK_BINDINGS_TRACE_EVENT("Node.insertBefore");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    ExceptionState exception_state(isolate);

    // [CEReactions]
    CEReactionsScope ce_reactions_scope;

    v8::Local<v8::Object> v8_receiver = info.This();
    Node* blink_receiver = V8Node::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& arg1_node = NativeValueTraits<Node>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_child = NativeValueTraits<IDLNullable<Node>>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->insertBefore(arg1_node, arg2_child, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<Node, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::kMainWorld);
}

void InsertBeforeOperationCallbackForNonMainWorlds(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Node_insertBefore");
    BLINK_BINDINGS_TRACE_EVENT("Node.insertBefore");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    ExceptionState exception_state(isolate);

    // [CEReactions]
    CEReactionsScope ce_reactions_scope;

    v8::Local<v8::Object> v8_receiver = info.This();
    Node* blink_receiver = V8Node::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& arg1_node = NativeValueTraits<Node>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_child = NativeValueTraits<IDLNullable<Node>>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->insertBefore(arg1_node, arg2_child, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<Node, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void IsDefaultNamespaceOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Node_isDefaultNamespace");
    BLINK_BINDINGS_TRACE_EVENT("Node.isDefaultNamespace");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Node* blink_receiver = V8Node::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_namespace_uri = NativeValueTraits<IDLNullable<IDLString>>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->isDefaultNamespace(arg1_namespace_uri);
    static_assert(bindings::IsReturnTypeCompatible<IDLBoolean, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void IsEqualNodeOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Node_isEqualNode");
    BLINK_BINDINGS_TRACE_EVENT("Node.isEqualNode");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Node* blink_receiver = V8Node::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_other_node = NativeValueTraits<IDLNullable<Node>>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->isEqualNode(arg1_other_node);
    static_assert(bindings::IsReturnTypeCompatible<IDLBoolean, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void IsSameNodeOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Node_isSameNode");
    BLINK_BINDINGS_TRACE_EVENT("Node.isSameNode");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Node* blink_receiver = V8Node::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_other_node = NativeValueTraits<IDLNullable<Node>>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->isSameNode(arg1_other_node);
    static_assert(bindings::IsReturnTypeCompatible<IDLBoolean, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void LookupNamespaceURIOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Node_lookupNamespaceURI");
    BLINK_BINDINGS_TRACE_EVENT("Node.lookupNamespaceURI");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Node* blink_receiver = V8Node::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_prefix = NativeValueTraits<IDLNullable<IDLString>>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->lookupNamespaceURI(arg1_prefix);
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void LookupPrefixOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Node_lookupPrefix");
    BLINK_BINDINGS_TRACE_EVENT("Node.lookupPrefix");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Node* blink_receiver = V8Node::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_namespace_uri = NativeValueTraits<IDLNullable<IDLString>>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->lookupPrefix(arg1_namespace_uri);
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void MoveBeforeOperationCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Node_moveBefore");
    BLINK_BINDINGS_TRACE_EVENT("Node.moveBefore");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    ExceptionState exception_state(isolate);

    // [CEReactions]
    CEReactionsScope ce_reactions_scope;

    v8::Local<v8::Object> v8_receiver = info.This();
    Node* blink_receiver = V8Node::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& arg1_node = NativeValueTraits<Node>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_child = NativeValueTraits<IDLNullable<Node>>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->moveBefore(arg1_node, arg2_child, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<Node, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::kMainWorld);
}

void MoveBeforeOperationCallbackForNonMainWorlds(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Node_moveBefore");
    BLINK_BINDINGS_TRACE_EVENT("Node.moveBefore");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    ExceptionState exception_state(isolate);

    // [CEReactions]
    CEReactionsScope ce_reactions_scope;

    v8::Local<v8::Object> v8_receiver = info.This();
    Node* blink_receiver = V8Node::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& arg1_node = NativeValueTraits<Node>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_child = NativeValueTraits<IDLNullable<Node>>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->moveBefore(arg1_node, arg2_child, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<Node, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void NormalizeOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Node_normalize");
    BLINK_BINDINGS_TRACE_EVENT("Node.normalize");

    // [CEReactions]
    CEReactionsScope ce_reactions_scope;

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Node* blink_receiver = V8Node::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->normalize();
}

void RemoveChildOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE(info.GetIsolate(), RuntimeCallStats::CounterId::kNodeRemoveChild);
    BLINK_BINDINGS_TRACE_EVENT("Node.removeChild");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    ExceptionState exception_state(isolate);

    // [CEReactions]
    CEReactionsScope ce_reactions_scope;

    v8::Local<v8::Object> v8_receiver = info.This();
    Node* blink_receiver = V8Node::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& arg1_child = NativeValueTraits<Node>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->removeChild(arg1_child, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<Node, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void ReplaceChildOperationCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Node_replaceChild");
    BLINK_BINDINGS_TRACE_EVENT("Node.replaceChild");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    ExceptionState exception_state(isolate);

    // [CEReactions]
    CEReactionsScope ce_reactions_scope;

    v8::Local<v8::Object> v8_receiver = info.This();
    Node* blink_receiver = V8Node::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& arg1_node = NativeValueTraits<Node>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_child = NativeValueTraits<Node>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->replaceChild(arg1_node, arg2_child, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<Node, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::kMainWorld);
}

void ReplaceChildOperationCallbackForNonMainWorlds(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Node_replaceChild");
    BLINK_BINDINGS_TRACE_EVENT("Node.replaceChild");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    ExceptionState exception_state(isolate);

    // [CEReactions]
    CEReactionsScope ce_reactions_scope;

    v8::Local<v8::Object> v8_receiver = info.This();
    Node* blink_receiver = V8Node::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& arg1_node = NativeValueTraits<Node>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_child = NativeValueTraits<Node>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->replaceChild(arg1_node, arg2_child, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<Node, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

} // namespace v8_node

using namespace v8_node;

} // namespace

void V8Node::InstallInterfaceTemplate(v8::Isolate* isolate, const DOMWrapperWorld& world, v8::Local<v8::Template> interface_template)
{
    const WrapperTypeInfo* const wrapper_type_info = V8Node::GetWrapperTypeInfo();
    v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
    v8::Local<v8::ObjectTemplate> instance_object_template = interface_function_template->InstanceTemplate();
    v8::Local<v8::ObjectTemplate> prototype_object_template = interface_function_template->PrototypeTemplate();
    v8::Local<v8::FunctionTemplate> parent_interface_template = wrapper_type_info->parent_class->GetV8ClassTemplate(isolate, world).As<v8::FunctionTemplate>();
    bindings::SetupIDLInterfaceTemplate(
        isolate, wrapper_type_info, instance_object_template, prototype_object_template, interface_function_template, parent_interface_template);

    v8::Local<v8::Template> instance_template = instance_object_template;
    v8::Local<v8::Template> prototype_template = prototype_object_template;
    InstallUnconditionalProperties(isolate, world, instance_template, prototype_template, interface_template);
    InstallContextIndependentProperties(isolate, world, instance_template, prototype_template, interface_template);
}

void V8Node::InstallUnconditionalProperties(v8::Isolate* isolate, const DOMWrapperWorld& world, v8::Local<v8::Template> instance_template,
    v8::Local<v8::Template> prototype_template, v8::Local<v8::Template> interface_template)
{
    using bindings::IDLMemberInstaller;

    v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
    v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
    {
        static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
            { "nodeType", "Node", NodeTypeAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "nodeName", "Node", NodeNameAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "baseURI", "Node", BaseURIAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "isConnected", "Node", IsConnectedAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ownerDocument", "Node", OwnerDocumentAttributeGetCallbackForMainWorld, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kMainWorld),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ownerDocument", "Node", OwnerDocumentAttributeGetCallbackForNonMainWorlds, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kNonMainWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "parentNode", "Node", ParentNodeAttributeGetCallbackForMainWorld, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kMainWorld),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "parentNode", "Node", ParentNodeAttributeGetCallbackForNonMainWorlds, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kNonMainWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "parentElement", "Node", ParentElementAttributeGetCallbackForMainWorld, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kMainWorld),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "parentElement", "Node", ParentElementAttributeGetCallbackForNonMainWorlds, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kNonMainWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "childNodes", "Node", ChildNodesAttributeGetCallbackForMainWorld, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kMainWorld),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "childNodes", "Node", ChildNodesAttributeGetCallbackForNonMainWorlds, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kNonMainWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "firstChild", "Node", FirstChildAttributeGetCallbackForMainWorld, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kMainWorld),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "firstChild", "Node", FirstChildAttributeGetCallbackForNonMainWorlds, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kNonMainWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "lastChild", "Node", LastChildAttributeGetCallbackForMainWorld, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kMainWorld),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "lastChild", "Node", LastChildAttributeGetCallbackForNonMainWorlds, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kNonMainWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "previousSibling", "Node", PreviousSiblingAttributeGetCallbackForMainWorld, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kMainWorld),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "previousSibling", "Node", PreviousSiblingAttributeGetCallbackForNonMainWorlds, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kNonMainWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "nextSibling", "Node", NextSiblingAttributeGetCallbackForMainWorld, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kMainWorld),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "nextSibling", "Node", NextSiblingAttributeGetCallbackForNonMainWorlds, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kNonMainWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "nodeValue", "Node", NodeValueAttributeGetCallback, NodeValueAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "textContent", "Node", TextContentAttributeGetCallback, TextContentAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
        };
        IDLMemberInstaller::InstallAttributes(isolate, world, instance_template, prototype_template, interface_template, signature, kAttributeTable);
    }

    {
        static const IDLMemberInstaller::ConstantValueConfig kConstantValueTable[] = {
            { "ELEMENT_NODE", V8Node::Constant::kElementNode },
            { "ATTRIBUTE_NODE", V8Node::Constant::kAttributeNode },
            { "TEXT_NODE", V8Node::Constant::kTextNode },
            { "CDATA_SECTION_NODE", V8Node::Constant::kCdataSectionNode },
            { "ENTITY_REFERENCE_NODE", V8Node::Constant::kEntityReferenceNode },
            { "ENTITY_NODE", V8Node::Constant::kEntityNode },
            { "PROCESSING_INSTRUCTION_NODE", V8Node::Constant::kProcessingInstructionNode },
            { "COMMENT_NODE", V8Node::Constant::kCommentNode },
            { "DOCUMENT_NODE", V8Node::Constant::kDocumentNode },
            { "DOCUMENT_TYPE_NODE", V8Node::Constant::kDocumentTypeNode },
            { "DOCUMENT_FRAGMENT_NODE", V8Node::Constant::kDocumentFragmentNode },
            { "NOTATION_NODE", V8Node::Constant::kNotationNode },
            { "DOCUMENT_POSITION_DISCONNECTED", V8Node::Constant::kDocumentPositionDisconnected },
            { "DOCUMENT_POSITION_PRECEDING", V8Node::Constant::kDocumentPositionPreceding },
            { "DOCUMENT_POSITION_FOLLOWING", V8Node::Constant::kDocumentPositionFollowing },
            { "DOCUMENT_POSITION_CONTAINS", V8Node::Constant::kDocumentPositionContains },
            { "DOCUMENT_POSITION_CONTAINED_BY", V8Node::Constant::kDocumentPositionContainedBy },
            { "DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC", V8Node::Constant::kDocumentPositionImplementationSpecific },
        };
        IDLMemberInstaller::InstallConstants(isolate, world, instance_template, prototype_template, interface_template, signature, kConstantValueTable);
    }

    {
        static const IDLMemberInstaller::OperationConfig kOperationTable[] = {
            { "appendChild", "Node", AppendChildOperationCallbackForMainWorld, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kMainWorld), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "appendChild", "Node", AppendChildOperationCallbackForNonMainWorlds, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kNonMainWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "cloneNode", "Node", CloneNodeOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "compareDocumentPosition", "Node", CompareDocumentPositionOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "contains", "Node", ContainsOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect) },
            { "getRootNode", "Node", GetRootNodeOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "hasChildNodes", "Node", HasChildNodesOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect) },
            { "insertBefore", "Node", InsertBeforeOperationCallbackForMainWorld, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kMainWorld), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "insertBefore", "Node", InsertBeforeOperationCallbackForNonMainWorlds, 2, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kNonMainWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "isDefaultNamespace", "Node", IsDefaultNamespaceOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "isEqualNode", "Node", IsEqualNodeOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "isSameNode", "Node", IsSameNodeOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "lookupNamespaceURI", "Node", LookupNamespaceURIOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "lookupPrefix", "Node", LookupPrefixOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "normalize", "Node", NormalizeOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "removeChild", "Node", RemoveChildOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "replaceChild", "Node", ReplaceChildOperationCallbackForMainWorld, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kMainWorld), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "replaceChild", "Node", ReplaceChildOperationCallbackForNonMainWorlds, 2, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kNonMainWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
        };
        IDLMemberInstaller::InstallOperations(isolate, world, instance_template, prototype_template, interface_template, signature, kOperationTable);
    }
}

void V8Node::InstallContextIndependentProperties(v8::Isolate* isolate, const DOMWrapperWorld& world, v8::Local<v8::Template> instance_template,
    v8::Local<v8::Template> prototype_template, v8::Local<v8::Template> interface_template)
{
    using bindings::IDLMemberInstaller;

    if (RuntimeEnabledFeatures::AtomicMoveAPIEnabled()) {
        static const IDLMemberInstaller::OperationConfig kOperationTable[] = {
            { "moveBefore", "Node", MoveBeforeOperationCallbackForMainWorld, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kMainWorld), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "moveBefore", "Node", MoveBeforeOperationCallbackForNonMainWorlds, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kNonMainWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
        };
        v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
        v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
        IDLMemberInstaller::InstallOperations(isolate, world, instance_template, prototype_template, interface_template, signature, kOperationTable);
    }
}

namespace bindings {

namespace v8_context_snapshot {

base::span<const intptr_t> GetRefTableOfV8Node()
{
    static const intptr_t kReferenceTable[] = {
        reinterpret_cast<intptr_t>(V8Node::GetWrapperTypeInfo()),
        reinterpret_cast<intptr_t>(NodeTypeAttributeGetCallback),
        reinterpret_cast<intptr_t>(NodeNameAttributeGetCallback),
        reinterpret_cast<intptr_t>(BaseURIAttributeGetCallback),
        reinterpret_cast<intptr_t>(IsConnectedAttributeGetCallback),
        reinterpret_cast<intptr_t>(OwnerDocumentAttributeGetCallbackForMainWorld),
        reinterpret_cast<intptr_t>(OwnerDocumentAttributeGetCallbackForNonMainWorlds),
        reinterpret_cast<intptr_t>(ParentNodeAttributeGetCallbackForMainWorld),
        reinterpret_cast<intptr_t>(ParentNodeAttributeGetCallbackForNonMainWorlds),
        reinterpret_cast<intptr_t>(ParentElementAttributeGetCallbackForMainWorld),
        reinterpret_cast<intptr_t>(ParentElementAttributeGetCallbackForNonMainWorlds),
        reinterpret_cast<intptr_t>(ChildNodesAttributeGetCallbackForMainWorld),
        reinterpret_cast<intptr_t>(ChildNodesAttributeGetCallbackForNonMainWorlds),
        reinterpret_cast<intptr_t>(FirstChildAttributeGetCallbackForMainWorld),
        reinterpret_cast<intptr_t>(FirstChildAttributeGetCallbackForNonMainWorlds),
        reinterpret_cast<intptr_t>(LastChildAttributeGetCallbackForMainWorld),
        reinterpret_cast<intptr_t>(LastChildAttributeGetCallbackForNonMainWorlds),
        reinterpret_cast<intptr_t>(PreviousSiblingAttributeGetCallbackForMainWorld),
        reinterpret_cast<intptr_t>(PreviousSiblingAttributeGetCallbackForNonMainWorlds),
        reinterpret_cast<intptr_t>(NextSiblingAttributeGetCallbackForMainWorld),
        reinterpret_cast<intptr_t>(NextSiblingAttributeGetCallbackForNonMainWorlds),
        reinterpret_cast<intptr_t>(NodeValueAttributeGetCallback),
        reinterpret_cast<intptr_t>(NodeValueAttributeSetCallback),
        reinterpret_cast<intptr_t>(TextContentAttributeGetCallback),
        reinterpret_cast<intptr_t>(TextContentAttributeSetCallback),
        reinterpret_cast<intptr_t>(AppendChildOperationCallbackForMainWorld),
        reinterpret_cast<intptr_t>(AppendChildOperationCallbackForNonMainWorlds),
        reinterpret_cast<intptr_t>(CloneNodeOperationCallback),
        reinterpret_cast<intptr_t>(CompareDocumentPositionOperationCallback),
        reinterpret_cast<intptr_t>(ContainsOperationCallback),
        reinterpret_cast<intptr_t>(GetRootNodeOperationCallback),
        reinterpret_cast<intptr_t>(HasChildNodesOperationCallback),
        reinterpret_cast<intptr_t>(InsertBeforeOperationCallbackForMainWorld),
        reinterpret_cast<intptr_t>(InsertBeforeOperationCallbackForNonMainWorlds),
        reinterpret_cast<intptr_t>(IsDefaultNamespaceOperationCallback),
        reinterpret_cast<intptr_t>(IsEqualNodeOperationCallback),
        reinterpret_cast<intptr_t>(IsSameNodeOperationCallback),
        reinterpret_cast<intptr_t>(LookupNamespaceURIOperationCallback),
        reinterpret_cast<intptr_t>(LookupPrefixOperationCallback),
        reinterpret_cast<intptr_t>(NormalizeOperationCallback),
        reinterpret_cast<intptr_t>(RemoveChildOperationCallback),
        reinterpret_cast<intptr_t>(ReplaceChildOperationCallbackForMainWorld),
        reinterpret_cast<intptr_t>(ReplaceChildOperationCallbackForNonMainWorlds),
    };
    return kReferenceTable;
}

void InstallPropsOfV8Node(v8::Local<v8::Context> context, const DOMWrapperWorld& world, v8::Local<v8::Object> instance_object,
    v8::Local<v8::Object> prototype_object, v8::Local<v8::Object> interface_object, v8::Local<v8::Template> interface_template)
{
    using bindings::IDLMemberInstaller;

    if (RuntimeEnabledFeatures::AtomicMoveAPIEnabled()) {
        static const IDLMemberInstaller::OperationConfig kOperationTable[] = {
            { "moveBefore", "Node", MoveBeforeOperationCallbackForMainWorld, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kMainWorld), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "moveBefore", "Node", MoveBeforeOperationCallbackForNonMainWorlds, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kNonMainWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
        };
        v8::Isolate* isolate = context->GetIsolate();
        v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
        v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
        IDLMemberInstaller::InstallOperations(isolate, world, instance_object, prototype_object, interface_object, signature, kOperationTable);
    }
}

void InstallPropsOfV8Node(v8::Isolate* isolate, const DOMWrapperWorld& world, v8::Local<v8::Template> instance_template,
    v8::Local<v8::Template> prototype_template, v8::Local<v8::Template> interface_template)
{
    return V8Node::InstallContextIndependentProperties(isolate, world, instance_template, prototype_template, interface_template);
}

} // namespace v8_context_snapshot

} // namespace bindings

} // namespace blink
