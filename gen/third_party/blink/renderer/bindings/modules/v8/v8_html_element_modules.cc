// Copyright 2019 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// DO NOT EDIT: This file is auto-generated by
// //third_party/blink/renderer/bindings/scripts/generate_bindings.py
//
// Use the GN flag `blink_enable_generated_code_formatting=true` to enable
// formatting of the generated files.

#include "third_party/blink/renderer/bindings/modules/v8/v8_html_element.h"

#include "third_party/blink/public/mojom/origin_trials/origin_trial_feature.mojom-shared.h"
#include "third_party/blink/renderer/bindings/core/v8/generated_code_helper.h"
#include "third_party/blink/renderer/bindings/core/v8/is_return_type_compatible.h"
#include "third_party/blink/renderer/bindings/core/v8/native_value_traits_impl.h"
#include "third_party/blink/renderer/bindings/core/v8/to_v8_traits.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_css_style_declaration.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_dom_string_map.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_edit_context.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_element.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_element_internals.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_event_handler_non_null.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_focus_options.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_html_constructor.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_set_return_value_for_core.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_show_popover_options.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_style_property_map.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_toggle_popover_options.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_trusted_script.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_union_boolean_string_unrestricteddouble.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_union_boolean_togglepopoveroptions.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_union_stringlegacynulltoemptystring_trustedscript.h"
#include "third_party/blink/renderer/core/css/css_style_declaration.h"
#include "third_party/blink/renderer/core/css/cssom/style_property_map.h"
#include "third_party/blink/renderer/core/dom/dom_string_map.h"
#include "third_party/blink/renderer/core/dom/element.h"
#include "third_party/blink/renderer/core/editing/ime/edit_context.h"
#include "third_party/blink/renderer/core/execution_context/execution_context.h"
#include "third_party/blink/renderer/core/frame/web_feature.h"
#include "third_party/blink/renderer/core/html/custom/ce_reactions_scope.h"
#include "third_party/blink/renderer/core/html/custom/element_internals.h"
#include "third_party/blink/renderer/core/html/html_element.h"
#include "third_party/blink/renderer/core/html_names.h"
#include "third_party/blink/renderer/core/keywords.h"
#include "third_party/blink/renderer/core/trustedtypes/trusted_script.h"
#include "third_party/blink/renderer/modules/xr/global_event_handlers_xr.h"
#include "third_party/blink/renderer/platform/bindings/exception_messages.h"
#include "third_party/blink/renderer/platform/bindings/idl_member_installer.h"
#include "third_party/blink/renderer/platform/bindings/runtime_call_stats.h"
#include "third_party/blink/renderer/platform/bindings/v8_binding.h"
#include "third_party/blink/renderer/platform/bindings/v8_object_constructor.h"
#include "third_party/blink/renderer/platform/instrumentation/use_counter.h"

namespace blink {

void V8HTMLElement::Impl::Init()
{
    V8HTMLElement::install_interface_template_func_ = InstallInterfaceTemplate;
    V8HTMLElement::install_unconditional_props_func_ = InstallUnconditionalProperties;
    V8HTMLElement::install_context_independent_props_func_ = InstallContextIndependentProperties;
    V8HTMLElement::install_context_dependent_props_func_ = InstallContextDependentProperties;
}

namespace {

namespace v8_html_element {

void TitleAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_title_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.title.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->FastGetAttribute(html_names::kTitleAttr);
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void TitleAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_title_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.title.set");

    const char* const class_like_name = "HTMLElement";
    const char* const property_name = "title";
    bindings::PerformAttributeSetCEReactionsReflectTypeString(info, html_names::kTitleAttr, class_like_name, property_name);
}

void LangAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_lang_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.lang.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->FastGetAttribute(html_names::kLangAttr);
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void LangAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_lang_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.lang.set");

    const char* const class_like_name = "HTMLElement";
    const char* const property_name = "lang";
    bindings::PerformAttributeSetCEReactionsReflectTypeString(info, html_names::kLangAttr, class_like_name, property_name);
}

void TranslateAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_translate_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.translate.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->translate();
    static_assert(bindings::IsReturnTypeCompatible<IDLBoolean, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void TranslateAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_translate_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.translate.set");

    v8::Isolate* isolate = info.GetIsolate();
    ExceptionState exception_state(isolate);

    // [CEReactions]
    CEReactionsScope ce_reactions_scope;

    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    v8::Local<v8::Value> v8_property_value = info[0];
    auto&& arg1_value = NativeValueTraits<IDLBoolean>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setTranslate(arg1_value);
}

void DirAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_dir_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.dir.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->dir();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void DirAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_dir_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.dir.set");

    v8::Isolate* isolate = info.GetIsolate();
    ExceptionState exception_state(isolate);

    // [CEReactions]
    CEReactionsScope ce_reactions_scope;

    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    v8::Local<v8::Value> v8_property_value = info[0];
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setDir(arg1_value);
}

void HiddenAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_hidden_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.hidden.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->hidden();
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<V8UnionBooleanOrStringOrUnrestrictedDouble>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    v8::Local<v8::Value> v8_return_value = ToV8Traits<IDLNullable<V8UnionBooleanOrStringOrUnrestrictedDouble>>::ToV8(script_state, return_value);
    bindings::V8SetReturnValue(info, v8_return_value);
}

void HiddenAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_hidden_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.hidden.set");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    ExceptionState exception_state(isolate);

    // [CEReactions]
    CEReactionsScope ce_reactions_scope;

    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    v8::Local<v8::Value> v8_property_value = info[0];
    auto&& arg1_value = NativeValueTraits<IDLNullable<V8UnionBooleanOrStringOrUnrestrictedDouble>>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setHidden(arg1_value);
}

void InertAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_inert_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.inert.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->FastHasAttribute(html_names::kInertAttr);
    static_assert(bindings::IsReturnTypeCompatible<IDLBoolean, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void InertAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_inert_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.inert.set");

    const char* const class_like_name = "HTMLElement";
    const char* const property_name = "inert";
    bindings::PerformAttributeSetCEReactionsReflectTypeBoolean(info, html_names::kInertAttr, class_like_name, property_name);
}

void AccessKeyAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_accessKey_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.accessKey.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->FastGetAttribute(html_names::kAccesskeyAttr);
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void AccessKeyAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_accessKey_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.accessKey.set");

    const char* const class_like_name = "HTMLElement";
    const char* const property_name = "accessKey";
    bindings::PerformAttributeSetCEReactionsReflectTypeString(info, html_names::kAccesskeyAttr, class_like_name, property_name);
}

void DraggableAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_draggable_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.draggable.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->draggable();
    static_assert(bindings::IsReturnTypeCompatible<IDLBoolean, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void DraggableAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_draggable_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.draggable.set");

    v8::Isolate* isolate = info.GetIsolate();
    ExceptionState exception_state(isolate);

    // [CEReactions]
    CEReactionsScope ce_reactions_scope;

    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    v8::Local<v8::Value> v8_property_value = info[0];
    auto&& arg1_value = NativeValueTraits<IDLBoolean>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setDraggable(arg1_value);
}

void SpellcheckAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_spellcheck_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.spellcheck.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->spellcheck();
    static_assert(bindings::IsReturnTypeCompatible<IDLBoolean, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void SpellcheckAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_spellcheck_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.spellcheck.set");

    v8::Isolate* isolate = info.GetIsolate();
    ExceptionState exception_state(isolate);

    // [CEReactions]
    CEReactionsScope ce_reactions_scope;

    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    v8::Local<v8::Value> v8_property_value = info[0];
    auto&& arg1_value = NativeValueTraits<IDLBoolean>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setSpellcheck(arg1_value);
}

void AutocapitalizeAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_autocapitalize_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.autocapitalize.get");
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kV8HTMLElement_Autocapitalize_AttributeGetter);

    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->autocapitalize();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void AutocapitalizeAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_autocapitalize_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.autocapitalize.set");
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kV8HTMLElement_Autocapitalize_AttributeSetter);

    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setAutocapitalize(arg1_value);
}

void EditContextAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_editContext_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.editContext.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->editContext();
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<EditContext>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void EditContextAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_editContext_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.editContext.set");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLNullable<EditContext>>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setEditContext(arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void ContentEditableAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_contentEditable_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.contentEditable.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->contentEditable();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void ContentEditableAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_contentEditable_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.contentEditable.set");

    v8::Isolate* isolate = info.GetIsolate();
    ExceptionState exception_state(isolate);

    // [CEReactions]
    CEReactionsScope ce_reactions_scope;

    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    v8::Local<v8::Value> v8_property_value = info[0];
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setContentEditable(arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void EnterKeyHintAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_enterKeyHint_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.enterKeyHint.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto return_value = blink_receiver->FastGetAttribute(html_names::kEnterkeyhintAttr);

    // [ReflectOnly]
    const AtomicString reflect_value(return_value.LowerASCII());
    if (reflect_value == keywords::kEnter || reflect_value == keywords::kDone || reflect_value == keywords::kGo || reflect_value == keywords::kNext
        || reflect_value == keywords::kPrevious || reflect_value == keywords::kSearch || reflect_value == keywords::kSend) {
        return_value = reflect_value;
    } else {
        return_value = g_empty_atom;
    }
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void EnterKeyHintAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_enterKeyHint_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.enterKeyHint.set");

    const char* const class_like_name = "HTMLElement";
    const char* const property_name = "enterKeyHint";
    bindings::PerformAttributeSetCEReactionsReflectTypeString(info, html_names::kEnterkeyhintAttr, class_like_name, property_name);
}

void IsContentEditableAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_isContentEditable_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.isContentEditable.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->isContentEditableForBinding();
    static_assert(bindings::IsReturnTypeCompatible<IDLBoolean, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void InputModeAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_inputMode_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.inputMode.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto return_value = blink_receiver->FastGetAttribute(html_names::kInputmodeAttr);

    // [ReflectOnly]
    const AtomicString reflect_value(return_value.LowerASCII());
    if (reflect_value == keywords::kNone || reflect_value == keywords::kText || reflect_value == keywords::kTel || reflect_value == keywords::kUrl
        || reflect_value == keywords::kEmail || reflect_value == keywords::kNumeric || reflect_value == keywords::kDecimal
        || reflect_value == keywords::kSearch) {
        return_value = reflect_value;
    } else {
        return_value = g_empty_atom;
    }
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void InputModeAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_inputMode_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.inputMode.set");

    const char* const class_like_name = "HTMLElement";
    const char* const property_name = "inputMode";
    bindings::PerformAttributeSetCEReactionsReflectTypeString(info, html_names::kInputmodeAttr, class_like_name, property_name);
}

void VirtualKeyboardPolicyAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_virtualKeyboardPolicy_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.virtualKeyboardPolicy.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto return_value = blink_receiver->FastGetAttribute(html_names::kVirtualkeyboardpolicyAttr);

    // [ReflectOnly]
    const AtomicString reflect_value(return_value.LowerASCII());
    if (reflect_value == keywords::kAuto || reflect_value == keywords::kManual) {
        return_value = reflect_value;
    } else {
        return_value = g_empty_atom;
    }
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void VirtualKeyboardPolicyAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_virtualKeyboardPolicy_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.virtualKeyboardPolicy.set");

    const char* const class_like_name = "HTMLElement";
    const char* const property_name = "virtualKeyboardPolicy";
    bindings::PerformAttributeSetCEReactionsReflectTypeString(info, html_names::kVirtualkeyboardpolicyAttr, class_like_name, property_name);
}

void OffsetParentAttributeGetCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_offsetParent_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.offsetParent.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->unclosedOffsetParent();
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<Element>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::kMainWorld);
}

void OffsetParentAttributeGetCallbackForNonMainWorlds(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_offsetParent_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.offsetParent.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->unclosedOffsetParent();
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<Element>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void OffsetTopAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_offsetTop_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.offsetTop.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->offsetTopForBinding();
    static_assert(bindings::IsReturnTypeCompatible<IDLLong, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<int32_t>());
}

void OffsetLeftAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_offsetLeft_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.offsetLeft.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->offsetLeftForBinding();
    static_assert(bindings::IsReturnTypeCompatible<IDLLong, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<int32_t>());
}

void OffsetWidthAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_offsetWidth_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.offsetWidth.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->offsetWidthForBinding();
    static_assert(bindings::IsReturnTypeCompatible<IDLLong, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<int32_t>());
}

void OffsetHeightAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_offsetHeight_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.offsetHeight.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->offsetHeightForBinding();
    static_assert(bindings::IsReturnTypeCompatible<IDLLong, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<int32_t>());
}

void PopoverAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_popover_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.popover.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->popover();
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void PopoverAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_popover_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.popover.set");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    ExceptionState exception_state(isolate);

    // [CEReactions]
    CEReactionsScope ce_reactions_scope;

    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    v8::Local<v8::Value> v8_property_value = info[0];
    auto&& arg1_value = NativeValueTraits<IDLNullable<IDLString>>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setPopover(arg1_value);
}

void InnerTextAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_innerText_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.innerText.get");
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kHTMLElementInnerText);

    v8::Local<v8::Object> v8_receiver = info.This();
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->innerTextForBinding();
    static_assert(bindings::IsReturnTypeCompatible<V8UnionStringLegacyNullToEmptyStringOrTrustedScript, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    v8::Local<v8::Value> v8_return_value = ToV8Traits<V8UnionStringLegacyNullToEmptyStringOrTrustedScript>::ToV8(script_state, return_value);
    bindings::V8SetReturnValue(info, v8_return_value);
}

void InnerTextAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_innerText_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.innerText.set");
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kHTMLElementInnerText);

    ExceptionState exception_state(isolate);

    // [CEReactions]
    CEReactionsScope ce_reactions_scope;

    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    v8::Local<v8::Value> v8_property_value = info[0];
    auto&& arg1_value = NativeValueTraits<V8UnionStringLegacyNullToEmptyStringOrTrustedScript>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setInnerTextForBinding(arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void OuterTextAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_outerText_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.outerText.get");
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kHTMLElementOuterText);

    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->outerText();
    static_assert(bindings::IsReturnTypeCompatible<IDLStringLegacyNullToEmptyString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void OuterTextAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_outerText_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.outerText.set");
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kHTMLElementOuterText);

    ExceptionState exception_state(isolate);

    // [CEReactions]
    CEReactionsScope ce_reactions_scope;

    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    v8::Local<v8::Value> v8_property_value = info[0];
    auto&& arg1_value = NativeValueTraits<IDLStringLegacyNullToEmptyString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setOuterText(arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void WritingSuggestionsAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_writingSuggestions_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.writingSuggestions.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->writingSuggestions();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void WritingSuggestionsAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_writingSuggestions_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.writingSuggestions.set");

    v8::Isolate* isolate = info.GetIsolate();
    ExceptionState exception_state(isolate);

    // [CEReactions]
    CEReactionsScope ce_reactions_scope;

    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    v8::Local<v8::Value> v8_property_value = info[0];
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setWritingSuggestions(arg1_value);
}

void OnbeforexrselectAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onbeforexrselect_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onbeforexrselect.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = GlobalEventHandlersXR::onbeforexrselect(*blink_receiver);
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnbeforexrselectAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onbeforexrselect_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onbeforexrselect.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    GlobalEventHandlersXR::setOnbeforexrselect(*blink_receiver, event_handler);
}

void OnabortAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onabort_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onabort.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onabort();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnabortAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onabort_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onabort.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnabort(event_handler);
}

void OnbeforeinputAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onbeforeinput_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onbeforeinput.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onbeforeinput();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnbeforeinputAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onbeforeinput_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onbeforeinput.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnbeforeinput(event_handler);
}

void OnbeforematchAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onbeforematch_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onbeforematch.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onbeforematch();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnbeforematchAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onbeforematch_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onbeforematch.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnbeforematch(event_handler);
}

void OnbeforetoggleAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onbeforetoggle_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onbeforetoggle.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onbeforetoggle();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnbeforetoggleAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onbeforetoggle_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onbeforetoggle.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnbeforetoggle(event_handler);
}

void OnblurAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onblur_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onblur.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onblur();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnblurAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onblur_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onblur.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnblur(event_handler);
}

void OncancelAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_oncancel_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.oncancel.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->oncancel();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OncancelAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_oncancel_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.oncancel.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOncancel(event_handler);
}

void OncanplayAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_oncanplay_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.oncanplay.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->oncanplay();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OncanplayAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_oncanplay_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.oncanplay.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOncanplay(event_handler);
}

void OncanplaythroughAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_oncanplaythrough_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.oncanplaythrough.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->oncanplaythrough();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OncanplaythroughAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_oncanplaythrough_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.oncanplaythrough.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOncanplaythrough(event_handler);
}

void OnchangeAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onchange_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onchange.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onchange();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnchangeAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onchange_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onchange.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnchange(event_handler);
}

void OnclickAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onclick_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onclick.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onclick();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnclickAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onclick_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onclick.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnclick(event_handler);
}

void OncloseAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onclose_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onclose.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onclose();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OncloseAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onclose_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onclose.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnclose(event_handler);
}

void OncontentvisibilityautostatechangeAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_oncontentvisibilityautostatechange_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.oncontentvisibilityautostatechange.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->oncontentvisibilityautostatechange();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OncontentvisibilityautostatechangeAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_oncontentvisibilityautostatechange_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.oncontentvisibilityautostatechange.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOncontentvisibilityautostatechange(event_handler);
}

void OncontextlostAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_oncontextlost_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.oncontextlost.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->oncontextlost();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OncontextlostAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_oncontextlost_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.oncontextlost.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOncontextlost(event_handler);
}

void OncontextmenuAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_oncontextmenu_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.oncontextmenu.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->oncontextmenu();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OncontextmenuAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_oncontextmenu_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.oncontextmenu.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOncontextmenu(event_handler);
}

void OncontextrestoredAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_oncontextrestored_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.oncontextrestored.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->oncontextrestored();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OncontextrestoredAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_oncontextrestored_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.oncontextrestored.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOncontextrestored(event_handler);
}

void OncuechangeAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_oncuechange_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.oncuechange.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->oncuechange();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OncuechangeAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_oncuechange_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.oncuechange.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOncuechange(event_handler);
}

void OndblclickAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_ondblclick_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.ondblclick.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ondblclick();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OndblclickAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_ondblclick_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.ondblclick.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOndblclick(event_handler);
}

void OndragAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_ondrag_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.ondrag.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ondrag();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OndragAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_ondrag_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.ondrag.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOndrag(event_handler);
}

void OndragendAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_ondragend_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.ondragend.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ondragend();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OndragendAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_ondragend_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.ondragend.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOndragend(event_handler);
}

void OndragenterAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_ondragenter_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.ondragenter.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ondragenter();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OndragenterAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_ondragenter_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.ondragenter.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOndragenter(event_handler);
}

void OndragleaveAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_ondragleave_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.ondragleave.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ondragleave();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OndragleaveAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_ondragleave_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.ondragleave.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOndragleave(event_handler);
}

void OndragoverAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_ondragover_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.ondragover.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ondragover();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OndragoverAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_ondragover_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.ondragover.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOndragover(event_handler);
}

void OndragstartAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_ondragstart_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.ondragstart.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ondragstart();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OndragstartAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_ondragstart_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.ondragstart.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOndragstart(event_handler);
}

void OndropAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_ondrop_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.ondrop.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ondrop();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OndropAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_ondrop_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.ondrop.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOndrop(event_handler);
}

void OndurationchangeAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_ondurationchange_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.ondurationchange.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ondurationchange();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OndurationchangeAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_ondurationchange_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.ondurationchange.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOndurationchange(event_handler);
}

void OnemptiedAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onemptied_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onemptied.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onemptied();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnemptiedAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onemptied_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onemptied.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnemptied(event_handler);
}

void OnendedAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onended_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onended.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onended();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnendedAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onended_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onended.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnended(event_handler);
}

void OnerrorAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onerror_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onerror.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onerror();
    static_assert(bindings::IsReturnTypeCompatible<IDLOnErrorEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnerrorAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onerror_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onerror.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kOnErrorEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnerror(event_handler);
}

void OnfencedtreeclickAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onfencedtreeclick_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onfencedtreeclick.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onfencedtreeclick();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnfencedtreeclickAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onfencedtreeclick_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onfencedtreeclick.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnfencedtreeclick(event_handler);
}

void OnfocusAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onfocus_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onfocus.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onfocus();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnfocusAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onfocus_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onfocus.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnfocus(event_handler);
}

void OnformdataAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onformdata_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onformdata.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onformdata();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnformdataAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onformdata_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onformdata.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnformdata(event_handler);
}

void OninputAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_oninput_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.oninput.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->oninput();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OninputAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_oninput_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.oninput.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOninput(event_handler);
}

void OninvalidAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_oninvalid_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.oninvalid.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->oninvalid();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OninvalidAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_oninvalid_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.oninvalid.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOninvalid(event_handler);
}

void OnkeydownAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onkeydown_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onkeydown.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onkeydown();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnkeydownAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onkeydown_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onkeydown.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnkeydown(event_handler);
}

void OnkeypressAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onkeypress_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onkeypress.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onkeypress();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnkeypressAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onkeypress_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onkeypress.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnkeypress(event_handler);
}

void OnkeyupAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onkeyup_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onkeyup.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onkeyup();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnkeyupAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onkeyup_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onkeyup.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnkeyup(event_handler);
}

void OnloadAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onload_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onload.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onload();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnloadAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onload_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onload.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnload(event_handler);
}

void OnloadeddataAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onloadeddata_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onloadeddata.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onloadeddata();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnloadeddataAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onloadeddata_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onloadeddata.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnloadeddata(event_handler);
}

void OnloadedmetadataAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onloadedmetadata_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onloadedmetadata.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onloadedmetadata();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnloadedmetadataAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onloadedmetadata_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onloadedmetadata.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnloadedmetadata(event_handler);
}

void OnloadstartAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onloadstart_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onloadstart.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onloadstart();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnloadstartAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onloadstart_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onloadstart.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnloadstart(event_handler);
}

void OnmousedownAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onmousedown_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onmousedown.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onmousedown();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnmousedownAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onmousedown_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onmousedown.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnmousedown(event_handler);
}

void OnmouseenterAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    // [LegacyLenientThis]
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    if (!V8HTMLElement::HasInstance(isolate, v8_receiver)) {
        return;
    }

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onmouseenter_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onmouseenter.get");

    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onmouseenter();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnmouseenterAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    // [LegacyLenientThis]
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    if (!V8HTMLElement::HasInstance(isolate, v8_receiver)) {
        return;
    }

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onmouseenter_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onmouseenter.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnmouseenter(event_handler);
}

void OnmouseleaveAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    // [LegacyLenientThis]
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    if (!V8HTMLElement::HasInstance(isolate, v8_receiver)) {
        return;
    }

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onmouseleave_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onmouseleave.get");

    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onmouseleave();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnmouseleaveAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    // [LegacyLenientThis]
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    if (!V8HTMLElement::HasInstance(isolate, v8_receiver)) {
        return;
    }

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onmouseleave_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onmouseleave.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnmouseleave(event_handler);
}

void OnmousemoveAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onmousemove_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onmousemove.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onmousemove();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnmousemoveAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onmousemove_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onmousemove.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnmousemove(event_handler);
}

void OnmouseoutAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onmouseout_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onmouseout.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onmouseout();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnmouseoutAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onmouseout_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onmouseout.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnmouseout(event_handler);
}

void OnmouseoverAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onmouseover_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onmouseover.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onmouseover();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnmouseoverAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onmouseover_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onmouseover.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnmouseover(event_handler);
}

void OnmouseupAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onmouseup_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onmouseup.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onmouseup();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnmouseupAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onmouseup_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onmouseup.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnmouseup(event_handler);
}

void OnmousewheelAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onmousewheel_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onmousewheel.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onmousewheel();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnmousewheelAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onmousewheel_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onmousewheel.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnmousewheel(event_handler);
}

void OnoverscrollAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onoverscroll_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onoverscroll.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onoverscroll();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnoverscrollAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onoverscroll_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onoverscroll.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnoverscroll(event_handler);
}

void OnpauseAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onpause_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onpause.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onpause();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnpauseAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onpause_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onpause.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnpause(event_handler);
}

void OnplayAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onplay_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onplay.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onplay();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnplayAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onplay_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onplay.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnplay(event_handler);
}

void OnplayingAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onplaying_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onplaying.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onplaying();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnplayingAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onplaying_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onplaying.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnplaying(event_handler);
}

void OnprogressAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onprogress_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onprogress.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onprogress();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnprogressAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onprogress_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onprogress.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnprogress(event_handler);
}

void OnratechangeAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onratechange_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onratechange.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onratechange();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnratechangeAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onratechange_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onratechange.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnratechange(event_handler);
}

void OnresetAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onreset_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onreset.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onreset();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnresetAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onreset_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onreset.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnreset(event_handler);
}

void OnresizeAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onresize_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onresize.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onresize();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnresizeAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onresize_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onresize.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnresize(event_handler);
}

void OnscrollAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onscroll_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onscroll.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onscroll();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnscrollAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onscroll_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onscroll.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnscroll(event_handler);
}

void OnscrollendAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onscrollend_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onscrollend.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onscrollend();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnscrollendAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onscrollend_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onscrollend.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnscrollend(event_handler);
}

void OnsecuritypolicyviolationAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onsecuritypolicyviolation_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onsecuritypolicyviolation.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onsecuritypolicyviolation();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnsecuritypolicyviolationAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onsecuritypolicyviolation_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onsecuritypolicyviolation.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnsecuritypolicyviolation(event_handler);
}

void OnseekedAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onseeked_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onseeked.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onseeked();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnseekedAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onseeked_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onseeked.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnseeked(event_handler);
}

void OnseekingAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onseeking_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onseeking.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onseeking();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnseekingAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onseeking_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onseeking.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnseeking(event_handler);
}

void OnselectAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onselect_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onselect.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onselect();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnselectAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onselect_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onselect.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnselect(event_handler);
}

void OnslotchangeAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onslotchange_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onslotchange.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onslotchange();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnslotchangeAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onslotchange_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onslotchange.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnslotchange(event_handler);
}

void OnscrollsnapchangeAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onscrollsnapchange_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onscrollsnapchange.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onscrollsnapchange();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnscrollsnapchangeAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onscrollsnapchange_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onscrollsnapchange.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnscrollsnapchange(event_handler);
}

void OnscrollsnapchangingAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onscrollsnapchanging_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onscrollsnapchanging.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onscrollsnapchanging();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnscrollsnapchangingAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onscrollsnapchanging_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onscrollsnapchanging.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnscrollsnapchanging(event_handler);
}

void OnstalledAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onstalled_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onstalled.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onstalled();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnstalledAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onstalled_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onstalled.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnstalled(event_handler);
}

void OnsubmitAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onsubmit_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onsubmit.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onsubmit();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnsubmitAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onsubmit_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onsubmit.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnsubmit(event_handler);
}

void OnsuspendAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onsuspend_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onsuspend.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onsuspend();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnsuspendAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onsuspend_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onsuspend.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnsuspend(event_handler);
}

void OntimeupdateAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_ontimeupdate_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.ontimeupdate.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ontimeupdate();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OntimeupdateAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_ontimeupdate_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.ontimeupdate.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOntimeupdate(event_handler);
}

void OntoggleAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_ontoggle_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.ontoggle.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ontoggle();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OntoggleAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_ontoggle_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.ontoggle.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOntoggle(event_handler);
}

void OnvolumechangeAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onvolumechange_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onvolumechange.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onvolumechange();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnvolumechangeAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onvolumechange_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onvolumechange.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnvolumechange(event_handler);
}

void OnwaitingAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onwaiting_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onwaiting.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onwaiting();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnwaitingAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onwaiting_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onwaiting.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnwaiting(event_handler);
}

void OnwebkitanimationendAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onwebkitanimationend_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onwebkitanimationend.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onwebkitanimationend();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnwebkitanimationendAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onwebkitanimationend_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onwebkitanimationend.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnwebkitanimationend(event_handler);
}

void OnwebkitanimationiterationAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onwebkitanimationiteration_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onwebkitanimationiteration.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onwebkitanimationiteration();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnwebkitanimationiterationAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onwebkitanimationiteration_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onwebkitanimationiteration.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnwebkitanimationiteration(event_handler);
}

void OnwebkitanimationstartAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onwebkitanimationstart_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onwebkitanimationstart.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onwebkitanimationstart();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnwebkitanimationstartAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onwebkitanimationstart_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onwebkitanimationstart.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnwebkitanimationstart(event_handler);
}

void OnwebkittransitionendAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onwebkittransitionend_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onwebkittransitionend.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onwebkittransitionend();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnwebkittransitionendAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onwebkittransitionend_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onwebkittransitionend.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnwebkittransitionend(event_handler);
}

void OnwheelAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onwheel_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onwheel.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onwheel();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnwheelAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onwheel_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onwheel.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnwheel(event_handler);
}

void OnauxclickAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onauxclick_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onauxclick.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onauxclick();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnauxclickAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onauxclick_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onauxclick.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnauxclick(event_handler);
}

void OngotpointercaptureAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_ongotpointercapture_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.ongotpointercapture.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ongotpointercapture();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OngotpointercaptureAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_ongotpointercapture_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.ongotpointercapture.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOngotpointercapture(event_handler);
}

void OnlostpointercaptureAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onlostpointercapture_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onlostpointercapture.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onlostpointercapture();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnlostpointercaptureAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onlostpointercapture_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onlostpointercapture.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnlostpointercapture(event_handler);
}

void OnpointerdownAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onpointerdown_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onpointerdown.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onpointerdown();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnpointerdownAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onpointerdown_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onpointerdown.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnpointerdown(event_handler);
}

void OnpointermoveAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onpointermove_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onpointermove.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onpointermove();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnpointermoveAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onpointermove_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onpointermove.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnpointermove(event_handler);
}

void OnpointerrawupdateAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onpointerrawupdate_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onpointerrawupdate.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onpointerrawupdate();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnpointerrawupdateAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onpointerrawupdate_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onpointerrawupdate.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnpointerrawupdate(event_handler);
}

void OnpointerupAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onpointerup_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onpointerup.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onpointerup();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnpointerupAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onpointerup_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onpointerup.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnpointerup(event_handler);
}

void OnpointercancelAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onpointercancel_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onpointercancel.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onpointercancel();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnpointercancelAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onpointercancel_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onpointercancel.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnpointercancel(event_handler);
}

void OnpointeroverAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onpointerover_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onpointerover.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onpointerover();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnpointeroverAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onpointerover_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onpointerover.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnpointerover(event_handler);
}

void OnpointeroutAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onpointerout_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onpointerout.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onpointerout();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnpointeroutAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onpointerout_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onpointerout.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnpointerout(event_handler);
}

void OnpointerenterAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onpointerenter_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onpointerenter.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onpointerenter();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnpointerenterAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onpointerenter_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onpointerenter.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnpointerenter(event_handler);
}

void OnpointerleaveAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onpointerleave_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onpointerleave.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onpointerleave();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnpointerleaveAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onpointerleave_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onpointerleave.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnpointerleave(event_handler);
}

void OntouchcancelAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_ontouchcancel_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.ontouchcancel.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ontouchcancel();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OntouchcancelAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_ontouchcancel_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.ontouchcancel.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOntouchcancel(event_handler);
}

void OntouchendAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_ontouchend_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.ontouchend.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ontouchend();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OntouchendAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_ontouchend_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.ontouchend.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOntouchend(event_handler);
}

void OntouchmoveAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_ontouchmove_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.ontouchmove.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ontouchmove();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OntouchmoveAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_ontouchmove_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.ontouchmove.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOntouchmove(event_handler);
}

void OntouchstartAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_ontouchstart_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.ontouchstart.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ontouchstart();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OntouchstartAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_ontouchstart_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.ontouchstart.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOntouchstart(event_handler);
}

void OnselectstartAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onselectstart_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onselectstart.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onselectstart();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnselectstartAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onselectstart_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onselectstart.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnselectstart(event_handler);
}

void OnselectionchangeAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onselectionchange_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onselectionchange.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onselectionchange();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnselectionchangeAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onselectionchange_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onselectionchange.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnselectionchange(event_handler);
}

void OnanimationendAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onanimationend_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onanimationend.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onanimationend();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnanimationendAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onanimationend_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onanimationend.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnanimationend(event_handler);
}

void OnanimationiterationAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onanimationiteration_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onanimationiteration.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onanimationiteration();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnanimationiterationAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onanimationiteration_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onanimationiteration.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnanimationiteration(event_handler);
}

void OnanimationstartAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onanimationstart_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onanimationstart.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onanimationstart();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnanimationstartAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onanimationstart_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onanimationstart.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnanimationstart(event_handler);
}

void OntransitionrunAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_ontransitionrun_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.ontransitionrun.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ontransitionrun();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OntransitionrunAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_ontransitionrun_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.ontransitionrun.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOntransitionrun(event_handler);
}

void OntransitionstartAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_ontransitionstart_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.ontransitionstart.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ontransitionstart();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OntransitionstartAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_ontransitionstart_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.ontransitionstart.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOntransitionstart(event_handler);
}

void OntransitionendAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_ontransitionend_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.ontransitionend.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ontransitionend();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OntransitionendAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_ontransitionend_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.ontransitionend.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOntransitionend(event_handler);
}

void OntransitioncancelAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_ontransitioncancel_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.ontransitioncancel.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ontransitioncancel();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OntransitioncancelAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_ontransitioncancel_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.ontransitioncancel.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOntransitioncancel(event_handler);
}

void OncopyAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_oncopy_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.oncopy.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->oncopy();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OncopyAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_oncopy_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.oncopy.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOncopy(event_handler);
}

void OncutAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_oncut_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.oncut.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->oncut();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OncutAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_oncut_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.oncut.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOncut(event_handler);
}

void OnpasteAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onpaste_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onpaste.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onpaste();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnpasteAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_onpaste_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.onpaste.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnpaste(event_handler);
}

void DatasetAttributeGetCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_dataset_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.dataset.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->dataset();
    static_assert(bindings::IsReturnTypeCompatible<DOMStringMap, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::kMainWorld);
}

void DatasetAttributeGetCallbackForNonMainWorlds(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_dataset_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.dataset.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->dataset();
    static_assert(bindings::IsReturnTypeCompatible<DOMStringMap, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void NonceAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_nonce_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.nonce.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->nonce();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void NonceAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_nonce_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.nonce.set");

    v8::Isolate* isolate = info.GetIsolate();
    ExceptionState exception_state(isolate);

    // [CEReactions]
    CEReactionsScope ce_reactions_scope;

    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    v8::Local<v8::Value> v8_property_value = info[0];
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setNonce(arg1_value);
}

void AutofocusAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_autofocus_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.autofocus.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->FastHasAttribute(html_names::kAutofocusAttr);
    static_assert(bindings::IsReturnTypeCompatible<IDLBoolean, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void AutofocusAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_autofocus_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.autofocus.set");

    const char* const class_like_name = "HTMLElement";
    const char* const property_name = "autofocus";
    bindings::PerformAttributeSetCEReactionsReflectTypeBoolean(info, html_names::kAutofocusAttr, class_like_name, property_name);
}

void TabIndexAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_tabIndex_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.tabIndex.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->tabIndex();
    static_assert(bindings::IsReturnTypeCompatible<IDLLong, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<int32_t>());
}

void TabIndexAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_tabIndex_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.tabIndex.set");

    v8::Isolate* isolate = info.GetIsolate();
    ExceptionState exception_state(isolate);

    // [CEReactions]
    CEReactionsScope ce_reactions_scope;

    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    v8::Local<v8::Value> v8_property_value = info[0];
    auto&& arg1_value = NativeValueTraits<IDLLong>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setTabIndex(arg1_value);
}

void FocusgroupAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_focusgroup_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.focusgroup.get");
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kV8HTMLElement_Focusgroup_AttributeGetter);

    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->FastGetAttribute(html_names::kFocusgroupAttr);
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void FocusgroupAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_focusgroup_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.focusgroup.set");
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kV8HTMLElement_Focusgroup_AttributeSetter);

    const char* const class_like_name = "HTMLElement";
    const char* const property_name = "focusgroup";
    bindings::PerformAttributeSetCEReactionsReflectTypeString(info, html_names::kFocusgroupAttr, class_like_name, property_name);
}

void StyleAttributeGetCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_style_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.style.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->style();
    static_assert(bindings::IsReturnTypeCompatible<CSSStyleDeclaration, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::kMainWorld);
}

void StyleAttributeSetCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_style_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.style.set");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    // [PutForwards]
    v8::Local<v8::Value> target;
    v8::Local<v8::Object> v8_receiver = info.This();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    const char* const property_name = "style";
    if (!v8_receiver->Get(current_context, V8AtomicString(isolate, property_name)).ToLocal(&target)) {
        return;
    }
    if (!target->IsObject()) {
        V8ThrowException::ThrowTypeError(isolate, "The attribute value is not an object");
        return;
    }
    bool did_set;
    v8::Local<v8::Value> v8_property_value = info[0];
    if (!target.As<v8::Object>()->Set(current_context, V8AtomicString(isolate, "cssText"), v8_property_value).To(&did_set)) {
        return;
    }
    return;
}

void StyleAttributeGetCallbackForNonMainWorlds(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_style_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.style.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->style();
    static_assert(bindings::IsReturnTypeCompatible<CSSStyleDeclaration, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void StyleAttributeSetCallbackForNonMainWorlds(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_style_Setter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.style.set");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    // [PutForwards]
    v8::Local<v8::Value> target;
    v8::Local<v8::Object> v8_receiver = info.This();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    const char* const property_name = "style";
    if (!v8_receiver->Get(current_context, V8AtomicString(isolate, property_name)).ToLocal(&target)) {
        return;
    }
    if (!target->IsObject()) {
        V8ThrowException::ThrowTypeError(isolate, "The attribute value is not an object");
        return;
    }
    bool did_set;
    v8::Local<v8::Value> v8_property_value = info[0];
    if (!target.As<v8::Object>()->Set(current_context, V8AtomicString(isolate, "cssText"), v8_property_value).To(&did_set)) {
        return;
    }
    return;
}

void AttributeStyleMapAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_attributeStyleMap_Getter");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.attributeStyleMap.get");
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kCSSTypedOMStylePropertyMap);

    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->attributeStyleMap();
    static_assert(bindings::IsReturnTypeCompatible<StylePropertyMap, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void ConstructorCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_constructor");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.constructor");

    v8::Isolate* isolate = info.GetIsolate();
    if (!info.IsConstructCall()) {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::ConstructorCalledAsFunction());
        return;
    }
    if (ConstructorMode::Current(isolate) == ConstructorMode::kWrapExistingObject) {
        v8::Local<v8::Object> v8_receiver = info.This();
        bindings::V8SetReturnValue(info, v8_receiver);
        return;
    }

    // [HTMLConstructor]
    V8HTMLConstructor::HtmlConstructor(info, *V8HTMLElement::GetWrapperTypeInfo(), HTMLElementType::kHTMLElement);
}

void AttachInternalsOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_attachInternals");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.attachInternals");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& return_value = blink_receiver->attachInternals(exception_state);
    static_assert(bindings::IsReturnTypeCompatible<ElementInternals, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void BlurOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_blur");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.blur");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->blur();
}

void ClickOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE(info.GetIsolate(), RuntimeCallStats::CounterId::kHTMLElementClick);
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.click");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->click();
}

void FocusOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_focus");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.focus");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    decltype(NativeValueTraits<FocusOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg1_options;
    if (info[0]->IsUndefined()) {
        arg1_options = FocusOptions::Create();
    } else {
        ExceptionState exception_state(isolate);
        arg1_options = NativeValueTraits<FocusOptions>::ArgumentValue(isolate, 0, info[0], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    blink_receiver->focusForBindings(arg1_options);
}

void HidePopoverOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_hidePopover");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.hidePopover");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kElementHidePopover);

    v8::Local<v8::Object> v8_receiver = info.This();
    HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    blink_receiver->hidePopover(exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void ShowPopoverOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_showPopover");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.showPopover");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kElementShowPopover);

    ExceptionState exception_state(isolate);
    do { // Dummy loop for use of 'break'.
        const int non_undefined_argument_length = bindings::NonUndefinedArgumentLength(info);
        v8::Local<v8::Object> v8_receiver = info.This();
        HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
        if (non_undefined_argument_length <= 0) {
            blink_receiver->showPopover(exception_state);
            break;
        }
        auto&& arg1_options = NativeValueTraits<ShowPopoverOptions>::ArgumentValue(isolate, 0, info[0], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
        blink_receiver->showPopover(arg1_options, exception_state);
    } while (false);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void TogglePopoverOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_HTMLElement_togglePopover");
    BLINK_BINDINGS_TRACE_EVENT("HTMLElement.togglePopover");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kElementTogglePopover);

    bool return_value;
    ExceptionState exception_state(isolate);
    do { // Dummy loop for use of 'break'.
        const int non_undefined_argument_length = bindings::NonUndefinedArgumentLength(info);
        v8::Local<v8::Object> v8_receiver = info.This();
        HTMLElement* blink_receiver = V8HTMLElement::ToWrappableUnsafe(isolate, v8_receiver);
        if (non_undefined_argument_length <= 0) {
            return_value = blink_receiver->togglePopover(exception_state);
            break;
        }
        auto&& arg1_options = NativeValueTraits<V8UnionBooleanOrTogglePopoverOptions>::ArgumentValue(isolate, 0, info[0], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
        return_value = blink_receiver->togglePopover(arg1_options, exception_state);
    } while (false);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

} // namespace v8_html_element

using namespace v8_html_element;

} // namespace

void V8HTMLElement::Impl::InstallInterfaceTemplate(v8::Isolate* isolate, const DOMWrapperWorld& world, v8::Local<v8::Template> interface_template)
{
    const WrapperTypeInfo* const wrapper_type_info = V8HTMLElement::GetWrapperTypeInfo();
    v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
    v8::Local<v8::ObjectTemplate> instance_object_template = interface_function_template->InstanceTemplate();
    v8::Local<v8::ObjectTemplate> prototype_object_template = interface_function_template->PrototypeTemplate();
    v8::Local<v8::FunctionTemplate> parent_interface_template = wrapper_type_info->parent_class->GetV8ClassTemplate(isolate, world).As<v8::FunctionTemplate>();
    bindings::SetupIDLInterfaceTemplate(
        isolate, wrapper_type_info, instance_object_template, prototype_object_template, interface_function_template, parent_interface_template);

    interface_function_template->SetCallHandler(ConstructorCallback);
    interface_function_template->SetLength(0);
    interface_function_template->SetInterfaceName(V8String(isolate, "HTMLElement"));
    interface_function_template->SetExceptionContext(v8::ExceptionContext::kConstructor);

    v8::Local<v8::Template> instance_template = instance_object_template;
    v8::Local<v8::Template> prototype_template = prototype_object_template;
    InstallUnconditionalProperties(isolate, world, instance_template, prototype_template, interface_template);
    InstallContextIndependentProperties(isolate, world, instance_template, prototype_template, interface_template);
}

void V8HTMLElement::Impl::InstallUnconditionalProperties(v8::Isolate* isolate, const DOMWrapperWorld& world, v8::Local<v8::Template> instance_template,
    v8::Local<v8::Template> prototype_template, v8::Local<v8::Template> interface_template)
{
    using bindings::IDLMemberInstaller;

    v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
    v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
    {
        static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
            { "title", "HTMLElement", TitleAttributeGetCallback, TitleAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "lang", "HTMLElement", LangAttributeGetCallback, LangAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "translate", "HTMLElement", TranslateAttributeGetCallback, TranslateAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "dir", "HTMLElement", DirAttributeGetCallback, DirAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "hidden", "HTMLElement", HiddenAttributeGetCallback, HiddenAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "inert", "HTMLElement", InertAttributeGetCallback, InertAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "accessKey", "HTMLElement", AccessKeyAttributeGetCallback, AccessKeyAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "draggable", "HTMLElement", DraggableAttributeGetCallback, DraggableAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "spellcheck", "HTMLElement", SpellcheckAttributeGetCallback, SpellcheckAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "autocapitalize", "HTMLElement", AutocapitalizeAttributeGetCallback, AutocapitalizeAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "editContext", "HTMLElement", EditContextAttributeGetCallback, EditContextAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "contentEditable", "HTMLElement", ContentEditableAttributeGetCallback, ContentEditableAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "enterKeyHint", "HTMLElement", EnterKeyHintAttributeGetCallback, EnterKeyHintAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "isContentEditable", "HTMLElement", IsContentEditableAttributeGetCallback, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "inputMode", "HTMLElement", InputModeAttributeGetCallback, InputModeAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "virtualKeyboardPolicy", "HTMLElement", VirtualKeyboardPolicyAttributeGetCallback, VirtualKeyboardPolicyAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "offsetParent", "HTMLElement", OffsetParentAttributeGetCallbackForMainWorld, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kMainWorld),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "offsetParent", "HTMLElement", OffsetParentAttributeGetCallbackForNonMainWorlds, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kNonMainWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "offsetTop", "HTMLElement", OffsetTopAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "offsetLeft", "HTMLElement", OffsetLeftAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "offsetWidth", "HTMLElement", OffsetWidthAttributeGetCallback, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "offsetHeight", "HTMLElement", OffsetHeightAttributeGetCallback, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "popover", "HTMLElement", PopoverAttributeGetCallback, PopoverAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "innerText", "HTMLElement", InnerTextAttributeGetCallback, InnerTextAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "outerText", "HTMLElement", OuterTextAttributeGetCallback, OuterTextAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "writingSuggestions", "HTMLElement", WritingSuggestionsAttributeGetCallback, WritingSuggestionsAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onbeforexrselect", "HTMLElement", OnbeforexrselectAttributeGetCallback, OnbeforexrselectAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onabort", "HTMLElement", OnabortAttributeGetCallback, OnabortAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onbeforeinput", "HTMLElement", OnbeforeinputAttributeGetCallback, OnbeforeinputAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onbeforematch", "HTMLElement", OnbeforematchAttributeGetCallback, OnbeforematchAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onbeforetoggle", "HTMLElement", OnbeforetoggleAttributeGetCallback, OnbeforetoggleAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onblur", "HTMLElement", OnblurAttributeGetCallback, OnblurAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "oncancel", "HTMLElement", OncancelAttributeGetCallback, OncancelAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "oncanplay", "HTMLElement", OncanplayAttributeGetCallback, OncanplayAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "oncanplaythrough", "HTMLElement", OncanplaythroughAttributeGetCallback, OncanplaythroughAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onchange", "HTMLElement", OnchangeAttributeGetCallback, OnchangeAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onclick", "HTMLElement", OnclickAttributeGetCallback, OnclickAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onclose", "HTMLElement", OncloseAttributeGetCallback, OncloseAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "oncontentvisibilityautostatechange", "HTMLElement", OncontentvisibilityautostatechangeAttributeGetCallback,
                OncontentvisibilityautostatechangeAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "oncontextlost", "HTMLElement", OncontextlostAttributeGetCallback, OncontextlostAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "oncontextmenu", "HTMLElement", OncontextmenuAttributeGetCallback, OncontextmenuAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "oncontextrestored", "HTMLElement", OncontextrestoredAttributeGetCallback, OncontextrestoredAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "oncuechange", "HTMLElement", OncuechangeAttributeGetCallback, OncuechangeAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ondblclick", "HTMLElement", OndblclickAttributeGetCallback, OndblclickAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ondrag", "HTMLElement", OndragAttributeGetCallback, OndragAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ondragend", "HTMLElement", OndragendAttributeGetCallback, OndragendAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ondragenter", "HTMLElement", OndragenterAttributeGetCallback, OndragenterAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ondragleave", "HTMLElement", OndragleaveAttributeGetCallback, OndragleaveAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ondragover", "HTMLElement", OndragoverAttributeGetCallback, OndragoverAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ondragstart", "HTMLElement", OndragstartAttributeGetCallback, OndragstartAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ondrop", "HTMLElement", OndropAttributeGetCallback, OndropAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ondurationchange", "HTMLElement", OndurationchangeAttributeGetCallback, OndurationchangeAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onemptied", "HTMLElement", OnemptiedAttributeGetCallback, OnemptiedAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onended", "HTMLElement", OnendedAttributeGetCallback, OnendedAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onerror", "HTMLElement", OnerrorAttributeGetCallback, OnerrorAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onfocus", "HTMLElement", OnfocusAttributeGetCallback, OnfocusAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onformdata", "HTMLElement", OnformdataAttributeGetCallback, OnformdataAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "oninput", "HTMLElement", OninputAttributeGetCallback, OninputAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "oninvalid", "HTMLElement", OninvalidAttributeGetCallback, OninvalidAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onkeydown", "HTMLElement", OnkeydownAttributeGetCallback, OnkeydownAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onkeypress", "HTMLElement", OnkeypressAttributeGetCallback, OnkeypressAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onkeyup", "HTMLElement", OnkeyupAttributeGetCallback, OnkeyupAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onload", "HTMLElement", OnloadAttributeGetCallback, OnloadAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onloadeddata", "HTMLElement", OnloadeddataAttributeGetCallback, OnloadeddataAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onloadedmetadata", "HTMLElement", OnloadedmetadataAttributeGetCallback, OnloadedmetadataAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onloadstart", "HTMLElement", OnloadstartAttributeGetCallback, OnloadstartAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onmousedown", "HTMLElement", OnmousedownAttributeGetCallback, OnmousedownAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onmouseenter", "HTMLElement", OnmouseenterAttributeGetCallback, OnmouseenterAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kDoNotCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onmouseleave", "HTMLElement", OnmouseleaveAttributeGetCallback, OnmouseleaveAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kDoNotCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onmousemove", "HTMLElement", OnmousemoveAttributeGetCallback, OnmousemoveAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onmouseout", "HTMLElement", OnmouseoutAttributeGetCallback, OnmouseoutAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onmouseover", "HTMLElement", OnmouseoverAttributeGetCallback, OnmouseoverAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onmouseup", "HTMLElement", OnmouseupAttributeGetCallback, OnmouseupAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onmousewheel", "HTMLElement", OnmousewheelAttributeGetCallback, OnmousewheelAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onpause", "HTMLElement", OnpauseAttributeGetCallback, OnpauseAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onplay", "HTMLElement", OnplayAttributeGetCallback, OnplayAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onplaying", "HTMLElement", OnplayingAttributeGetCallback, OnplayingAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onprogress", "HTMLElement", OnprogressAttributeGetCallback, OnprogressAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onratechange", "HTMLElement", OnratechangeAttributeGetCallback, OnratechangeAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onreset", "HTMLElement", OnresetAttributeGetCallback, OnresetAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onresize", "HTMLElement", OnresizeAttributeGetCallback, OnresizeAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onscroll", "HTMLElement", OnscrollAttributeGetCallback, OnscrollAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onsecuritypolicyviolation", "HTMLElement", OnsecuritypolicyviolationAttributeGetCallback, OnsecuritypolicyviolationAttributeSetCallback,
                unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onseeked", "HTMLElement", OnseekedAttributeGetCallback, OnseekedAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onseeking", "HTMLElement", OnseekingAttributeGetCallback, OnseekingAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onselect", "HTMLElement", OnselectAttributeGetCallback, OnselectAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onslotchange", "HTMLElement", OnslotchangeAttributeGetCallback, OnslotchangeAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onstalled", "HTMLElement", OnstalledAttributeGetCallback, OnstalledAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onsubmit", "HTMLElement", OnsubmitAttributeGetCallback, OnsubmitAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onsuspend", "HTMLElement", OnsuspendAttributeGetCallback, OnsuspendAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ontimeupdate", "HTMLElement", OntimeupdateAttributeGetCallback, OntimeupdateAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ontoggle", "HTMLElement", OntoggleAttributeGetCallback, OntoggleAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onvolumechange", "HTMLElement", OnvolumechangeAttributeGetCallback, OnvolumechangeAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onwaiting", "HTMLElement", OnwaitingAttributeGetCallback, OnwaitingAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onwebkitanimationend", "HTMLElement", OnwebkitanimationendAttributeGetCallback, OnwebkitanimationendAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onwebkitanimationiteration", "HTMLElement", OnwebkitanimationiterationAttributeGetCallback, OnwebkitanimationiterationAttributeSetCallback,
                unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onwebkitanimationstart", "HTMLElement", OnwebkitanimationstartAttributeGetCallback, OnwebkitanimationstartAttributeSetCallback,
                unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onwebkittransitionend", "HTMLElement", OnwebkittransitionendAttributeGetCallback, OnwebkittransitionendAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onwheel", "HTMLElement", OnwheelAttributeGetCallback, OnwheelAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onauxclick", "HTMLElement", OnauxclickAttributeGetCallback, OnauxclickAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ongotpointercapture", "HTMLElement", OngotpointercaptureAttributeGetCallback, OngotpointercaptureAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onlostpointercapture", "HTMLElement", OnlostpointercaptureAttributeGetCallback, OnlostpointercaptureAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onpointerdown", "HTMLElement", OnpointerdownAttributeGetCallback, OnpointerdownAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onpointermove", "HTMLElement", OnpointermoveAttributeGetCallback, OnpointermoveAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onpointerrawupdate", "HTMLElement", OnpointerrawupdateAttributeGetCallback, OnpointerrawupdateAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onpointerup", "HTMLElement", OnpointerupAttributeGetCallback, OnpointerupAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onpointercancel", "HTMLElement", OnpointercancelAttributeGetCallback, OnpointercancelAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onpointerover", "HTMLElement", OnpointeroverAttributeGetCallback, OnpointeroverAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onpointerout", "HTMLElement", OnpointeroutAttributeGetCallback, OnpointeroutAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onpointerenter", "HTMLElement", OnpointerenterAttributeGetCallback, OnpointerenterAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onpointerleave", "HTMLElement", OnpointerleaveAttributeGetCallback, OnpointerleaveAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onselectstart", "HTMLElement", OnselectstartAttributeGetCallback, OnselectstartAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onselectionchange", "HTMLElement", OnselectionchangeAttributeGetCallback, OnselectionchangeAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onanimationend", "HTMLElement", OnanimationendAttributeGetCallback, OnanimationendAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onanimationiteration", "HTMLElement", OnanimationiterationAttributeGetCallback, OnanimationiterationAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onanimationstart", "HTMLElement", OnanimationstartAttributeGetCallback, OnanimationstartAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ontransitionrun", "HTMLElement", OntransitionrunAttributeGetCallback, OntransitionrunAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ontransitionstart", "HTMLElement", OntransitionstartAttributeGetCallback, OntransitionstartAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ontransitionend", "HTMLElement", OntransitionendAttributeGetCallback, OntransitionendAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ontransitioncancel", "HTMLElement", OntransitioncancelAttributeGetCallback, OntransitioncancelAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "oncopy", "HTMLElement", OncopyAttributeGetCallback, OncopyAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "oncut", "HTMLElement", OncutAttributeGetCallback, OncutAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onpaste", "HTMLElement", OnpasteAttributeGetCallback, OnpasteAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "dataset", "HTMLElement", DatasetAttributeGetCallbackForMainWorld, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kMainWorld),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "dataset", "HTMLElement", DatasetAttributeGetCallbackForNonMainWorlds, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kNonMainWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "nonce", "HTMLElement", NonceAttributeGetCallback, NonceAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "autofocus", "HTMLElement", AutofocusAttributeGetCallback, AutofocusAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "tabIndex", "HTMLElement", TabIndexAttributeGetCallback, TabIndexAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "style", "HTMLElement", StyleAttributeGetCallbackForMainWorld, StyleAttributeSetCallbackForMainWorld, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kMainWorld),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "style", "HTMLElement", StyleAttributeGetCallbackForNonMainWorlds, StyleAttributeSetCallbackForNonMainWorlds, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kNonMainWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "attributeStyleMap", "HTMLElement", AttributeStyleMapAttributeGetCallback, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
        };
        IDLMemberInstaller::InstallAttributes(isolate, world, instance_template, prototype_template, interface_template, signature, kAttributeTable);
    }

    {
        static const IDLMemberInstaller::OperationConfig kOperationTable[] = {
            { "attachInternals", "HTMLElement", AttachInternalsOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "blur", "HTMLElement", BlurOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "click", "HTMLElement", ClickOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "focus", "HTMLElement", FocusOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "hidePopover", "HTMLElement", HidePopoverOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "showPopover", "HTMLElement", ShowPopoverOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "togglePopover", "HTMLElement", TogglePopoverOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
        };
        IDLMemberInstaller::InstallOperations(isolate, world, instance_template, prototype_template, interface_template, signature, kOperationTable);
    }
}

void V8HTMLElement::Impl::InstallContextIndependentProperties(v8::Isolate* isolate, const DOMWrapperWorld& world, v8::Local<v8::Template> instance_template,
    v8::Local<v8::Template> prototype_template, v8::Local<v8::Template> interface_template)
{
    using bindings::IDLMemberInstaller;

    if (RuntimeEnabledFeatures::FencedFramesLocalUnpartitionedDataAccessEnabled()) {
        static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
            { "onfencedtreeclick", "HTMLElement", OnfencedtreeclickAttributeGetCallback, OnfencedtreeclickAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
        };
        v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
        v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
        IDLMemberInstaller::InstallAttributes(isolate, world, instance_template, prototype_template, interface_template, signature, kAttributeTable);
    }
    if (RuntimeEnabledFeatures::OverscrollCustomizationEnabled()) {
        static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
            { "onoverscroll", "HTMLElement", OnoverscrollAttributeGetCallback, OnoverscrollAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
        };
        v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
        v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
        IDLMemberInstaller::InstallAttributes(isolate, world, instance_template, prototype_template, interface_template, signature, kAttributeTable);
    }
    if (RuntimeEnabledFeatures::ScrollEndEventsEnabled()) {
        static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
            { "onscrollend", "HTMLElement", OnscrollendAttributeGetCallback, OnscrollendAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
        };
        v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
        v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
        IDLMemberInstaller::InstallAttributes(isolate, world, instance_template, prototype_template, interface_template, signature, kAttributeTable);
    }
    if (RuntimeEnabledFeatures::CSSScrollSnapChangeEventEnabled()) {
        static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
            { "onscrollsnapchange", "HTMLElement", OnscrollsnapchangeAttributeGetCallback, OnscrollsnapchangeAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
        };
        v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
        v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
        IDLMemberInstaller::InstallAttributes(isolate, world, instance_template, prototype_template, interface_template, signature, kAttributeTable);
    }
    if (RuntimeEnabledFeatures::CSSScrollSnapChangingEventEnabled()) {
        static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
            { "onscrollsnapchanging", "HTMLElement", OnscrollsnapchangingAttributeGetCallback, OnscrollsnapchangingAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
        };
        v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
        v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
        IDLMemberInstaller::InstallAttributes(isolate, world, instance_template, prototype_template, interface_template, signature, kAttributeTable);
    }
}

void V8HTMLElement::Impl::InstallContextDependentProperties(v8::Local<v8::Context> context, const DOMWrapperWorld& world, v8::Local<v8::Object> instance_object,
    v8::Local<v8::Object> prototype_object, v8::Local<v8::Object> interface_object, v8::Local<v8::Template> interface_template,
    FeatureSelector feature_selector)
{
    using bindings::IDLMemberInstaller;

    v8::Isolate* isolate = context->GetIsolate();
    ScriptState* script_state = ScriptState::From(isolate, context);
    ExecutionContext* execution_context = ToExecutionContext(script_state);
    if ((feature_selector.IsAll() && RuntimeEnabledFeatures::TouchEventFeatureDetectionEnabled(execution_context))
        || feature_selector.IsAnyOf(mojom::blink::OriginTrialFeature::kTouchEventFeatureDetection)) {
        static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
            { "ontouchcancel", "HTMLElement", OntouchcancelAttributeGetCallback, OntouchcancelAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ontouchend", "HTMLElement", OntouchendAttributeGetCallback, OntouchendAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ontouchmove", "HTMLElement", OntouchmoveAttributeGetCallback, OntouchmoveAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ontouchstart", "HTMLElement", OntouchstartAttributeGetCallback, OntouchstartAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
        };
        v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
        v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
        IDLMemberInstaller::InstallAttributes(isolate, world, instance_object, prototype_object, interface_object, signature, kAttributeTable);
    }
    if ((feature_selector.IsAll() && RuntimeEnabledFeatures::FocusgroupEnabled(execution_context))
        || feature_selector.IsAnyOf(mojom::blink::OriginTrialFeature::kFocusgroup)) {
        static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
            { "focusgroup", "HTMLElement", FocusgroupAttributeGetCallback, FocusgroupAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
        };
        v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
        v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
        IDLMemberInstaller::InstallAttributes(isolate, world, instance_object, prototype_object, interface_object, signature, kAttributeTable);
    }
}

} // namespace blink
