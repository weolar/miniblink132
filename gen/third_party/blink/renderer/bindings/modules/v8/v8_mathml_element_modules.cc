// Copyright 2019 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// DO NOT EDIT: This file is auto-generated by
// //third_party/blink/renderer/bindings/scripts/generate_bindings.py
//
// Use the GN flag `blink_enable_generated_code_formatting=true` to enable
// formatting of the generated files.

#include "third_party/blink/renderer/bindings/modules/v8/v8_mathml_element.h"

#include "third_party/blink/public/mojom/origin_trials/origin_trial_feature.mojom-shared.h"
#include "third_party/blink/renderer/bindings/core/v8/generated_code_helper.h"
#include "third_party/blink/renderer/bindings/core/v8/is_return_type_compatible.h"
#include "third_party/blink/renderer/bindings/core/v8/native_value_traits_impl.h"
#include "third_party/blink/renderer/bindings/core/v8/to_v8_traits.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_css_style_declaration.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_dom_string_map.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_event_handler_non_null.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_focus_options.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_set_return_value_for_core.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_style_property_map.h"
#include "third_party/blink/renderer/core/css/css_style_declaration.h"
#include "third_party/blink/renderer/core/css/cssom/style_property_map.h"
#include "third_party/blink/renderer/core/dom/dom_string_map.h"
#include "third_party/blink/renderer/core/execution_context/execution_context.h"
#include "third_party/blink/renderer/core/frame/web_feature.h"
#include "third_party/blink/renderer/core/html/custom/ce_reactions_scope.h"
#include "third_party/blink/renderer/core/html_names.h"
#include "third_party/blink/renderer/core/mathml/mathml_element.h"
#include "third_party/blink/renderer/modules/xr/global_event_handlers_xr.h"
#include "third_party/blink/renderer/platform/bindings/exception_messages.h"
#include "third_party/blink/renderer/platform/bindings/idl_member_installer.h"
#include "third_party/blink/renderer/platform/bindings/runtime_call_stats.h"
#include "third_party/blink/renderer/platform/bindings/v8_binding.h"
#include "third_party/blink/renderer/platform/instrumentation/use_counter.h"

namespace blink {

void V8MathMLElement::Impl::Init()
{
    V8MathMLElement::install_interface_template_func_ = InstallInterfaceTemplate;
    V8MathMLElement::install_unconditional_props_func_ = InstallUnconditionalProperties;
    V8MathMLElement::install_context_independent_props_func_ = InstallContextIndependentProperties;
    V8MathMLElement::install_context_dependent_props_func_ = InstallContextDependentProperties;
}

namespace {

namespace v8_mathml_element {

void OnbeforexrselectAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onbeforexrselect_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onbeforexrselect.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = GlobalEventHandlersXR::onbeforexrselect(*blink_receiver);
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnbeforexrselectAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onbeforexrselect_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onbeforexrselect.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    GlobalEventHandlersXR::setOnbeforexrselect(*blink_receiver, event_handler);
}

void OnabortAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onabort_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onabort.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onabort();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnabortAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onabort_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onabort.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnabort(event_handler);
}

void OnbeforeinputAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onbeforeinput_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onbeforeinput.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onbeforeinput();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnbeforeinputAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onbeforeinput_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onbeforeinput.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnbeforeinput(event_handler);
}

void OnbeforematchAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onbeforematch_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onbeforematch.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onbeforematch();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnbeforematchAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onbeforematch_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onbeforematch.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnbeforematch(event_handler);
}

void OnbeforetoggleAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onbeforetoggle_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onbeforetoggle.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onbeforetoggle();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnbeforetoggleAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onbeforetoggle_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onbeforetoggle.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnbeforetoggle(event_handler);
}

void OnblurAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onblur_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onblur.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onblur();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnblurAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onblur_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onblur.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnblur(event_handler);
}

void OncancelAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_oncancel_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.oncancel.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->oncancel();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OncancelAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_oncancel_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.oncancel.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOncancel(event_handler);
}

void OncanplayAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_oncanplay_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.oncanplay.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->oncanplay();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OncanplayAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_oncanplay_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.oncanplay.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOncanplay(event_handler);
}

void OncanplaythroughAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_oncanplaythrough_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.oncanplaythrough.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->oncanplaythrough();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OncanplaythroughAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_oncanplaythrough_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.oncanplaythrough.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOncanplaythrough(event_handler);
}

void OnchangeAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onchange_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onchange.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onchange();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnchangeAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onchange_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onchange.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnchange(event_handler);
}

void OnclickAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onclick_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onclick.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onclick();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnclickAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onclick_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onclick.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnclick(event_handler);
}

void OncloseAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onclose_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onclose.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onclose();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OncloseAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onclose_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onclose.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnclose(event_handler);
}

void OncontentvisibilityautostatechangeAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_oncontentvisibilityautostatechange_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.oncontentvisibilityautostatechange.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->oncontentvisibilityautostatechange();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OncontentvisibilityautostatechangeAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_oncontentvisibilityautostatechange_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.oncontentvisibilityautostatechange.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOncontentvisibilityautostatechange(event_handler);
}

void OncontextlostAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_oncontextlost_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.oncontextlost.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->oncontextlost();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OncontextlostAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_oncontextlost_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.oncontextlost.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOncontextlost(event_handler);
}

void OncontextmenuAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_oncontextmenu_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.oncontextmenu.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->oncontextmenu();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OncontextmenuAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_oncontextmenu_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.oncontextmenu.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOncontextmenu(event_handler);
}

void OncontextrestoredAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_oncontextrestored_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.oncontextrestored.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->oncontextrestored();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OncontextrestoredAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_oncontextrestored_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.oncontextrestored.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOncontextrestored(event_handler);
}

void OncuechangeAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_oncuechange_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.oncuechange.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->oncuechange();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OncuechangeAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_oncuechange_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.oncuechange.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOncuechange(event_handler);
}

void OndblclickAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_ondblclick_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.ondblclick.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ondblclick();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OndblclickAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_ondblclick_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.ondblclick.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOndblclick(event_handler);
}

void OndragAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_ondrag_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.ondrag.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ondrag();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OndragAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_ondrag_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.ondrag.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOndrag(event_handler);
}

void OndragendAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_ondragend_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.ondragend.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ondragend();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OndragendAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_ondragend_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.ondragend.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOndragend(event_handler);
}

void OndragenterAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_ondragenter_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.ondragenter.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ondragenter();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OndragenterAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_ondragenter_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.ondragenter.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOndragenter(event_handler);
}

void OndragleaveAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_ondragleave_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.ondragleave.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ondragleave();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OndragleaveAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_ondragleave_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.ondragleave.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOndragleave(event_handler);
}

void OndragoverAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_ondragover_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.ondragover.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ondragover();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OndragoverAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_ondragover_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.ondragover.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOndragover(event_handler);
}

void OndragstartAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_ondragstart_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.ondragstart.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ondragstart();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OndragstartAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_ondragstart_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.ondragstart.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOndragstart(event_handler);
}

void OndropAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_ondrop_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.ondrop.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ondrop();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OndropAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_ondrop_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.ondrop.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOndrop(event_handler);
}

void OndurationchangeAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_ondurationchange_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.ondurationchange.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ondurationchange();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OndurationchangeAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_ondurationchange_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.ondurationchange.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOndurationchange(event_handler);
}

void OnemptiedAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onemptied_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onemptied.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onemptied();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnemptiedAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onemptied_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onemptied.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnemptied(event_handler);
}

void OnendedAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onended_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onended.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onended();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnendedAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onended_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onended.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnended(event_handler);
}

void OnerrorAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onerror_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onerror.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onerror();
    static_assert(bindings::IsReturnTypeCompatible<IDLOnErrorEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnerrorAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onerror_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onerror.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kOnErrorEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnerror(event_handler);
}

void OnfencedtreeclickAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onfencedtreeclick_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onfencedtreeclick.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onfencedtreeclick();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnfencedtreeclickAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onfencedtreeclick_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onfencedtreeclick.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnfencedtreeclick(event_handler);
}

void OnfocusAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onfocus_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onfocus.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onfocus();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnfocusAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onfocus_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onfocus.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnfocus(event_handler);
}

void OnformdataAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onformdata_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onformdata.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onformdata();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnformdataAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onformdata_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onformdata.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnformdata(event_handler);
}

void OninputAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_oninput_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.oninput.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->oninput();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OninputAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_oninput_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.oninput.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOninput(event_handler);
}

void OninvalidAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_oninvalid_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.oninvalid.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->oninvalid();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OninvalidAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_oninvalid_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.oninvalid.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOninvalid(event_handler);
}

void OnkeydownAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onkeydown_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onkeydown.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onkeydown();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnkeydownAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onkeydown_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onkeydown.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnkeydown(event_handler);
}

void OnkeypressAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onkeypress_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onkeypress.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onkeypress();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnkeypressAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onkeypress_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onkeypress.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnkeypress(event_handler);
}

void OnkeyupAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onkeyup_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onkeyup.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onkeyup();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnkeyupAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onkeyup_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onkeyup.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnkeyup(event_handler);
}

void OnloadAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onload_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onload.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onload();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnloadAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onload_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onload.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnload(event_handler);
}

void OnloadeddataAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onloadeddata_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onloadeddata.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onloadeddata();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnloadeddataAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onloadeddata_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onloadeddata.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnloadeddata(event_handler);
}

void OnloadedmetadataAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onloadedmetadata_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onloadedmetadata.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onloadedmetadata();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnloadedmetadataAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onloadedmetadata_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onloadedmetadata.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnloadedmetadata(event_handler);
}

void OnloadstartAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onloadstart_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onloadstart.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onloadstart();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnloadstartAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onloadstart_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onloadstart.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnloadstart(event_handler);
}

void OnmousedownAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onmousedown_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onmousedown.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onmousedown();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnmousedownAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onmousedown_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onmousedown.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnmousedown(event_handler);
}

void OnmouseenterAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    // [LegacyLenientThis]
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    if (!V8MathMLElement::HasInstance(isolate, v8_receiver)) {
        return;
    }

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onmouseenter_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onmouseenter.get");

    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onmouseenter();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnmouseenterAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    // [LegacyLenientThis]
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    if (!V8MathMLElement::HasInstance(isolate, v8_receiver)) {
        return;
    }

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onmouseenter_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onmouseenter.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnmouseenter(event_handler);
}

void OnmouseleaveAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    // [LegacyLenientThis]
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    if (!V8MathMLElement::HasInstance(isolate, v8_receiver)) {
        return;
    }

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onmouseleave_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onmouseleave.get");

    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onmouseleave();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnmouseleaveAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    // [LegacyLenientThis]
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    if (!V8MathMLElement::HasInstance(isolate, v8_receiver)) {
        return;
    }

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onmouseleave_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onmouseleave.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnmouseleave(event_handler);
}

void OnmousemoveAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onmousemove_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onmousemove.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onmousemove();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnmousemoveAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onmousemove_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onmousemove.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnmousemove(event_handler);
}

void OnmouseoutAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onmouseout_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onmouseout.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onmouseout();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnmouseoutAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onmouseout_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onmouseout.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnmouseout(event_handler);
}

void OnmouseoverAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onmouseover_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onmouseover.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onmouseover();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnmouseoverAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onmouseover_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onmouseover.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnmouseover(event_handler);
}

void OnmouseupAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onmouseup_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onmouseup.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onmouseup();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnmouseupAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onmouseup_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onmouseup.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnmouseup(event_handler);
}

void OnmousewheelAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onmousewheel_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onmousewheel.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onmousewheel();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnmousewheelAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onmousewheel_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onmousewheel.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnmousewheel(event_handler);
}

void OnoverscrollAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onoverscroll_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onoverscroll.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onoverscroll();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnoverscrollAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onoverscroll_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onoverscroll.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnoverscroll(event_handler);
}

void OnpauseAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onpause_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onpause.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onpause();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnpauseAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onpause_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onpause.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnpause(event_handler);
}

void OnplayAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onplay_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onplay.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onplay();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnplayAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onplay_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onplay.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnplay(event_handler);
}

void OnplayingAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onplaying_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onplaying.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onplaying();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnplayingAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onplaying_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onplaying.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnplaying(event_handler);
}

void OnprogressAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onprogress_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onprogress.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onprogress();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnprogressAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onprogress_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onprogress.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnprogress(event_handler);
}

void OnratechangeAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onratechange_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onratechange.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onratechange();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnratechangeAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onratechange_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onratechange.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnratechange(event_handler);
}

void OnresetAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onreset_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onreset.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onreset();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnresetAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onreset_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onreset.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnreset(event_handler);
}

void OnresizeAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onresize_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onresize.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onresize();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnresizeAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onresize_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onresize.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnresize(event_handler);
}

void OnscrollAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onscroll_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onscroll.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onscroll();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnscrollAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onscroll_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onscroll.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnscroll(event_handler);
}

void OnscrollendAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onscrollend_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onscrollend.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onscrollend();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnscrollendAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onscrollend_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onscrollend.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnscrollend(event_handler);
}

void OnsecuritypolicyviolationAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onsecuritypolicyviolation_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onsecuritypolicyviolation.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onsecuritypolicyviolation();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnsecuritypolicyviolationAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onsecuritypolicyviolation_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onsecuritypolicyviolation.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnsecuritypolicyviolation(event_handler);
}

void OnseekedAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onseeked_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onseeked.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onseeked();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnseekedAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onseeked_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onseeked.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnseeked(event_handler);
}

void OnseekingAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onseeking_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onseeking.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onseeking();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnseekingAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onseeking_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onseeking.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnseeking(event_handler);
}

void OnselectAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onselect_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onselect.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onselect();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnselectAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onselect_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onselect.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnselect(event_handler);
}

void OnslotchangeAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onslotchange_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onslotchange.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onslotchange();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnslotchangeAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onslotchange_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onslotchange.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnslotchange(event_handler);
}

void OnscrollsnapchangeAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onscrollsnapchange_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onscrollsnapchange.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onscrollsnapchange();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnscrollsnapchangeAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onscrollsnapchange_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onscrollsnapchange.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnscrollsnapchange(event_handler);
}

void OnscrollsnapchangingAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onscrollsnapchanging_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onscrollsnapchanging.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onscrollsnapchanging();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnscrollsnapchangingAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onscrollsnapchanging_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onscrollsnapchanging.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnscrollsnapchanging(event_handler);
}

void OnstalledAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onstalled_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onstalled.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onstalled();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnstalledAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onstalled_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onstalled.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnstalled(event_handler);
}

void OnsubmitAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onsubmit_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onsubmit.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onsubmit();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnsubmitAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onsubmit_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onsubmit.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnsubmit(event_handler);
}

void OnsuspendAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onsuspend_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onsuspend.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onsuspend();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnsuspendAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onsuspend_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onsuspend.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnsuspend(event_handler);
}

void OntimeupdateAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_ontimeupdate_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.ontimeupdate.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ontimeupdate();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OntimeupdateAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_ontimeupdate_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.ontimeupdate.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOntimeupdate(event_handler);
}

void OntoggleAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_ontoggle_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.ontoggle.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ontoggle();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OntoggleAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_ontoggle_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.ontoggle.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOntoggle(event_handler);
}

void OnvolumechangeAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onvolumechange_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onvolumechange.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onvolumechange();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnvolumechangeAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onvolumechange_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onvolumechange.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnvolumechange(event_handler);
}

void OnwaitingAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onwaiting_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onwaiting.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onwaiting();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnwaitingAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onwaiting_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onwaiting.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnwaiting(event_handler);
}

void OnwebkitanimationendAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onwebkitanimationend_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onwebkitanimationend.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onwebkitanimationend();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnwebkitanimationendAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onwebkitanimationend_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onwebkitanimationend.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnwebkitanimationend(event_handler);
}

void OnwebkitanimationiterationAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onwebkitanimationiteration_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onwebkitanimationiteration.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onwebkitanimationiteration();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnwebkitanimationiterationAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onwebkitanimationiteration_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onwebkitanimationiteration.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnwebkitanimationiteration(event_handler);
}

void OnwebkitanimationstartAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onwebkitanimationstart_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onwebkitanimationstart.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onwebkitanimationstart();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnwebkitanimationstartAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onwebkitanimationstart_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onwebkitanimationstart.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnwebkitanimationstart(event_handler);
}

void OnwebkittransitionendAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onwebkittransitionend_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onwebkittransitionend.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onwebkittransitionend();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnwebkittransitionendAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onwebkittransitionend_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onwebkittransitionend.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnwebkittransitionend(event_handler);
}

void OnwheelAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onwheel_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onwheel.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onwheel();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnwheelAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onwheel_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onwheel.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnwheel(event_handler);
}

void OnauxclickAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onauxclick_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onauxclick.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onauxclick();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnauxclickAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onauxclick_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onauxclick.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnauxclick(event_handler);
}

void OngotpointercaptureAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_ongotpointercapture_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.ongotpointercapture.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ongotpointercapture();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OngotpointercaptureAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_ongotpointercapture_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.ongotpointercapture.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOngotpointercapture(event_handler);
}

void OnlostpointercaptureAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onlostpointercapture_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onlostpointercapture.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onlostpointercapture();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnlostpointercaptureAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onlostpointercapture_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onlostpointercapture.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnlostpointercapture(event_handler);
}

void OnpointerdownAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onpointerdown_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onpointerdown.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onpointerdown();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnpointerdownAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onpointerdown_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onpointerdown.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnpointerdown(event_handler);
}

void OnpointermoveAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onpointermove_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onpointermove.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onpointermove();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnpointermoveAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onpointermove_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onpointermove.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnpointermove(event_handler);
}

void OnpointerrawupdateAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onpointerrawupdate_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onpointerrawupdate.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onpointerrawupdate();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnpointerrawupdateAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onpointerrawupdate_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onpointerrawupdate.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnpointerrawupdate(event_handler);
}

void OnpointerupAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onpointerup_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onpointerup.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onpointerup();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnpointerupAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onpointerup_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onpointerup.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnpointerup(event_handler);
}

void OnpointercancelAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onpointercancel_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onpointercancel.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onpointercancel();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnpointercancelAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onpointercancel_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onpointercancel.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnpointercancel(event_handler);
}

void OnpointeroverAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onpointerover_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onpointerover.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onpointerover();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnpointeroverAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onpointerover_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onpointerover.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnpointerover(event_handler);
}

void OnpointeroutAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onpointerout_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onpointerout.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onpointerout();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnpointeroutAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onpointerout_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onpointerout.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnpointerout(event_handler);
}

void OnpointerenterAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onpointerenter_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onpointerenter.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onpointerenter();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnpointerenterAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onpointerenter_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onpointerenter.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnpointerenter(event_handler);
}

void OnpointerleaveAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onpointerleave_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onpointerleave.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onpointerleave();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnpointerleaveAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onpointerleave_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onpointerleave.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnpointerleave(event_handler);
}

void OntouchcancelAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_ontouchcancel_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.ontouchcancel.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ontouchcancel();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OntouchcancelAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_ontouchcancel_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.ontouchcancel.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOntouchcancel(event_handler);
}

void OntouchendAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_ontouchend_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.ontouchend.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ontouchend();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OntouchendAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_ontouchend_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.ontouchend.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOntouchend(event_handler);
}

void OntouchmoveAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_ontouchmove_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.ontouchmove.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ontouchmove();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OntouchmoveAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_ontouchmove_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.ontouchmove.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOntouchmove(event_handler);
}

void OntouchstartAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_ontouchstart_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.ontouchstart.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ontouchstart();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OntouchstartAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_ontouchstart_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.ontouchstart.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOntouchstart(event_handler);
}

void OnselectstartAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onselectstart_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onselectstart.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onselectstart();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnselectstartAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onselectstart_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onselectstart.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnselectstart(event_handler);
}

void OnselectionchangeAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onselectionchange_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onselectionchange.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onselectionchange();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnselectionchangeAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onselectionchange_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onselectionchange.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnselectionchange(event_handler);
}

void OnanimationendAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onanimationend_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onanimationend.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onanimationend();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnanimationendAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onanimationend_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onanimationend.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnanimationend(event_handler);
}

void OnanimationiterationAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onanimationiteration_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onanimationiteration.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onanimationiteration();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnanimationiterationAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onanimationiteration_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onanimationiteration.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnanimationiteration(event_handler);
}

void OnanimationstartAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onanimationstart_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onanimationstart.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onanimationstart();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnanimationstartAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onanimationstart_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onanimationstart.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnanimationstart(event_handler);
}

void OntransitionrunAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_ontransitionrun_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.ontransitionrun.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ontransitionrun();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OntransitionrunAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_ontransitionrun_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.ontransitionrun.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOntransitionrun(event_handler);
}

void OntransitionstartAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_ontransitionstart_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.ontransitionstart.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ontransitionstart();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OntransitionstartAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_ontransitionstart_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.ontransitionstart.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOntransitionstart(event_handler);
}

void OntransitionendAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_ontransitionend_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.ontransitionend.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ontransitionend();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OntransitionendAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_ontransitionend_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.ontransitionend.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOntransitionend(event_handler);
}

void OntransitioncancelAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_ontransitioncancel_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.ontransitioncancel.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ontransitioncancel();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OntransitioncancelAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_ontransitioncancel_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.ontransitioncancel.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOntransitioncancel(event_handler);
}

void OncopyAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_oncopy_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.oncopy.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->oncopy();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OncopyAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_oncopy_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.oncopy.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOncopy(event_handler);
}

void OncutAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_oncut_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.oncut.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->oncut();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OncutAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_oncut_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.oncut.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOncut(event_handler);
}

void OnpasteAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onpaste_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onpaste.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onpaste();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnpasteAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_onpaste_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.onpaste.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnpaste(event_handler);
}

void DatasetAttributeGetCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_dataset_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.dataset.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->dataset();
    static_assert(bindings::IsReturnTypeCompatible<DOMStringMap, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::kMainWorld);
}

void DatasetAttributeGetCallbackForNonMainWorlds(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_dataset_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.dataset.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->dataset();
    static_assert(bindings::IsReturnTypeCompatible<DOMStringMap, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void NonceAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_nonce_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.nonce.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->nonce();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void NonceAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_nonce_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.nonce.set");

    v8::Isolate* isolate = info.GetIsolate();
    ExceptionState exception_state(isolate);

    // [CEReactions]
    CEReactionsScope ce_reactions_scope;

    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    v8::Local<v8::Value> v8_property_value = info[0];
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setNonce(arg1_value);
}

void AutofocusAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_autofocus_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.autofocus.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->FastHasAttribute(html_names::kAutofocusAttr);
    static_assert(bindings::IsReturnTypeCompatible<IDLBoolean, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void AutofocusAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_autofocus_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.autofocus.set");

    const char* const class_like_name = "MathMLElement";
    const char* const property_name = "autofocus";
    bindings::PerformAttributeSetCEReactionsReflectTypeBoolean(info, html_names::kAutofocusAttr, class_like_name, property_name);
}

void TabIndexAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_tabIndex_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.tabIndex.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->tabIndex();
    static_assert(bindings::IsReturnTypeCompatible<IDLLong, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<int32_t>());
}

void TabIndexAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_tabIndex_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.tabIndex.set");

    v8::Isolate* isolate = info.GetIsolate();
    ExceptionState exception_state(isolate);

    // [CEReactions]
    CEReactionsScope ce_reactions_scope;

    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    v8::Local<v8::Value> v8_property_value = info[0];
    auto&& arg1_value = NativeValueTraits<IDLLong>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setTabIndex(arg1_value);
}

void FocusgroupAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_focusgroup_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.focusgroup.get");
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kV8MathMLElement_Focusgroup_AttributeGetter);

    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->FastGetAttribute(html_names::kFocusgroupAttr);
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void FocusgroupAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_focusgroup_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.focusgroup.set");
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kV8MathMLElement_Focusgroup_AttributeSetter);

    const char* const class_like_name = "MathMLElement";
    const char* const property_name = "focusgroup";
    bindings::PerformAttributeSetCEReactionsReflectTypeString(info, html_names::kFocusgroupAttr, class_like_name, property_name);
}

void StyleAttributeGetCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_style_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.style.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->style();
    static_assert(bindings::IsReturnTypeCompatible<CSSStyleDeclaration, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::kMainWorld);
}

void StyleAttributeSetCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_style_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.style.set");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    // [PutForwards]
    v8::Local<v8::Value> target;
    v8::Local<v8::Object> v8_receiver = info.This();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    const char* const property_name = "style";
    if (!v8_receiver->Get(current_context, V8AtomicString(isolate, property_name)).ToLocal(&target)) {
        return;
    }
    if (!target->IsObject()) {
        V8ThrowException::ThrowTypeError(isolate, "The attribute value is not an object");
        return;
    }
    bool did_set;
    v8::Local<v8::Value> v8_property_value = info[0];
    if (!target.As<v8::Object>()->Set(current_context, V8AtomicString(isolate, "cssText"), v8_property_value).To(&did_set)) {
        return;
    }
    return;
}

void StyleAttributeGetCallbackForNonMainWorlds(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_style_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.style.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->style();
    static_assert(bindings::IsReturnTypeCompatible<CSSStyleDeclaration, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void StyleAttributeSetCallbackForNonMainWorlds(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_style_Setter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.style.set");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    // [PutForwards]
    v8::Local<v8::Value> target;
    v8::Local<v8::Object> v8_receiver = info.This();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    const char* const property_name = "style";
    if (!v8_receiver->Get(current_context, V8AtomicString(isolate, property_name)).ToLocal(&target)) {
        return;
    }
    if (!target->IsObject()) {
        V8ThrowException::ThrowTypeError(isolate, "The attribute value is not an object");
        return;
    }
    bool did_set;
    v8::Local<v8::Value> v8_property_value = info[0];
    if (!target.As<v8::Object>()->Set(current_context, V8AtomicString(isolate, "cssText"), v8_property_value).To(&did_set)) {
        return;
    }
    return;
}

void AttributeStyleMapAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_attributeStyleMap_Getter");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.attributeStyleMap.get");
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kCSSTypedOMStylePropertyMap);

    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->attributeStyleMap();
    static_assert(bindings::IsReturnTypeCompatible<StylePropertyMap, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void BlurOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_blur");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.blur");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->blur();
}

void FocusOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MathMLElement_focus");
    BLINK_BINDINGS_TRACE_EVENT("MathMLElement.focus");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    MathMLElement* blink_receiver = V8MathMLElement::ToWrappableUnsafe(isolate, v8_receiver);
    decltype(NativeValueTraits<FocusOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg1_options;
    if (info[0]->IsUndefined()) {
        arg1_options = FocusOptions::Create();
    } else {
        ExceptionState exception_state(isolate);
        arg1_options = NativeValueTraits<FocusOptions>::ArgumentValue(isolate, 0, info[0], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    blink_receiver->focusForBindings(arg1_options);
}

} // namespace v8_mathml_element

using namespace v8_mathml_element;

} // namespace

void V8MathMLElement::Impl::InstallInterfaceTemplate(v8::Isolate* isolate, const DOMWrapperWorld& world, v8::Local<v8::Template> interface_template)
{
    const WrapperTypeInfo* const wrapper_type_info = V8MathMLElement::GetWrapperTypeInfo();
    v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
    v8::Local<v8::ObjectTemplate> instance_object_template = interface_function_template->InstanceTemplate();
    v8::Local<v8::ObjectTemplate> prototype_object_template = interface_function_template->PrototypeTemplate();
    v8::Local<v8::FunctionTemplate> parent_interface_template = wrapper_type_info->parent_class->GetV8ClassTemplate(isolate, world).As<v8::FunctionTemplate>();
    bindings::SetupIDLInterfaceTemplate(
        isolate, wrapper_type_info, instance_object_template, prototype_object_template, interface_function_template, parent_interface_template);

    v8::Local<v8::Template> instance_template = instance_object_template;
    v8::Local<v8::Template> prototype_template = prototype_object_template;
    InstallUnconditionalProperties(isolate, world, instance_template, prototype_template, interface_template);
    InstallContextIndependentProperties(isolate, world, instance_template, prototype_template, interface_template);
}

void V8MathMLElement::Impl::InstallUnconditionalProperties(v8::Isolate* isolate, const DOMWrapperWorld& world, v8::Local<v8::Template> instance_template,
    v8::Local<v8::Template> prototype_template, v8::Local<v8::Template> interface_template)
{
    using bindings::IDLMemberInstaller;

    v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
    v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
    {
        static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
            { "onbeforexrselect", "MathMLElement", OnbeforexrselectAttributeGetCallback, OnbeforexrselectAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onabort", "MathMLElement", OnabortAttributeGetCallback, OnabortAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onbeforeinput", "MathMLElement", OnbeforeinputAttributeGetCallback, OnbeforeinputAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onbeforematch", "MathMLElement", OnbeforematchAttributeGetCallback, OnbeforematchAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onbeforetoggle", "MathMLElement", OnbeforetoggleAttributeGetCallback, OnbeforetoggleAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onblur", "MathMLElement", OnblurAttributeGetCallback, OnblurAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "oncancel", "MathMLElement", OncancelAttributeGetCallback, OncancelAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "oncanplay", "MathMLElement", OncanplayAttributeGetCallback, OncanplayAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "oncanplaythrough", "MathMLElement", OncanplaythroughAttributeGetCallback, OncanplaythroughAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onchange", "MathMLElement", OnchangeAttributeGetCallback, OnchangeAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onclick", "MathMLElement", OnclickAttributeGetCallback, OnclickAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onclose", "MathMLElement", OncloseAttributeGetCallback, OncloseAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "oncontentvisibilityautostatechange", "MathMLElement", OncontentvisibilityautostatechangeAttributeGetCallback,
                OncontentvisibilityautostatechangeAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "oncontextlost", "MathMLElement", OncontextlostAttributeGetCallback, OncontextlostAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "oncontextmenu", "MathMLElement", OncontextmenuAttributeGetCallback, OncontextmenuAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "oncontextrestored", "MathMLElement", OncontextrestoredAttributeGetCallback, OncontextrestoredAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "oncuechange", "MathMLElement", OncuechangeAttributeGetCallback, OncuechangeAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ondblclick", "MathMLElement", OndblclickAttributeGetCallback, OndblclickAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ondrag", "MathMLElement", OndragAttributeGetCallback, OndragAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ondragend", "MathMLElement", OndragendAttributeGetCallback, OndragendAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ondragenter", "MathMLElement", OndragenterAttributeGetCallback, OndragenterAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ondragleave", "MathMLElement", OndragleaveAttributeGetCallback, OndragleaveAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ondragover", "MathMLElement", OndragoverAttributeGetCallback, OndragoverAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ondragstart", "MathMLElement", OndragstartAttributeGetCallback, OndragstartAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ondrop", "MathMLElement", OndropAttributeGetCallback, OndropAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ondurationchange", "MathMLElement", OndurationchangeAttributeGetCallback, OndurationchangeAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onemptied", "MathMLElement", OnemptiedAttributeGetCallback, OnemptiedAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onended", "MathMLElement", OnendedAttributeGetCallback, OnendedAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onerror", "MathMLElement", OnerrorAttributeGetCallback, OnerrorAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onfocus", "MathMLElement", OnfocusAttributeGetCallback, OnfocusAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onformdata", "MathMLElement", OnformdataAttributeGetCallback, OnformdataAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "oninput", "MathMLElement", OninputAttributeGetCallback, OninputAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "oninvalid", "MathMLElement", OninvalidAttributeGetCallback, OninvalidAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onkeydown", "MathMLElement", OnkeydownAttributeGetCallback, OnkeydownAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onkeypress", "MathMLElement", OnkeypressAttributeGetCallback, OnkeypressAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onkeyup", "MathMLElement", OnkeyupAttributeGetCallback, OnkeyupAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onload", "MathMLElement", OnloadAttributeGetCallback, OnloadAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onloadeddata", "MathMLElement", OnloadeddataAttributeGetCallback, OnloadeddataAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onloadedmetadata", "MathMLElement", OnloadedmetadataAttributeGetCallback, OnloadedmetadataAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onloadstart", "MathMLElement", OnloadstartAttributeGetCallback, OnloadstartAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onmousedown", "MathMLElement", OnmousedownAttributeGetCallback, OnmousedownAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onmouseenter", "MathMLElement", OnmouseenterAttributeGetCallback, OnmouseenterAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kDoNotCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onmouseleave", "MathMLElement", OnmouseleaveAttributeGetCallback, OnmouseleaveAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kDoNotCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onmousemove", "MathMLElement", OnmousemoveAttributeGetCallback, OnmousemoveAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onmouseout", "MathMLElement", OnmouseoutAttributeGetCallback, OnmouseoutAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onmouseover", "MathMLElement", OnmouseoverAttributeGetCallback, OnmouseoverAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onmouseup", "MathMLElement", OnmouseupAttributeGetCallback, OnmouseupAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onmousewheel", "MathMLElement", OnmousewheelAttributeGetCallback, OnmousewheelAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onpause", "MathMLElement", OnpauseAttributeGetCallback, OnpauseAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onplay", "MathMLElement", OnplayAttributeGetCallback, OnplayAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onplaying", "MathMLElement", OnplayingAttributeGetCallback, OnplayingAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onprogress", "MathMLElement", OnprogressAttributeGetCallback, OnprogressAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onratechange", "MathMLElement", OnratechangeAttributeGetCallback, OnratechangeAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onreset", "MathMLElement", OnresetAttributeGetCallback, OnresetAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onresize", "MathMLElement", OnresizeAttributeGetCallback, OnresizeAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onscroll", "MathMLElement", OnscrollAttributeGetCallback, OnscrollAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onsecuritypolicyviolation", "MathMLElement", OnsecuritypolicyviolationAttributeGetCallback, OnsecuritypolicyviolationAttributeSetCallback,
                unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onseeked", "MathMLElement", OnseekedAttributeGetCallback, OnseekedAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onseeking", "MathMLElement", OnseekingAttributeGetCallback, OnseekingAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onselect", "MathMLElement", OnselectAttributeGetCallback, OnselectAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onslotchange", "MathMLElement", OnslotchangeAttributeGetCallback, OnslotchangeAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onstalled", "MathMLElement", OnstalledAttributeGetCallback, OnstalledAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onsubmit", "MathMLElement", OnsubmitAttributeGetCallback, OnsubmitAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onsuspend", "MathMLElement", OnsuspendAttributeGetCallback, OnsuspendAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ontimeupdate", "MathMLElement", OntimeupdateAttributeGetCallback, OntimeupdateAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ontoggle", "MathMLElement", OntoggleAttributeGetCallback, OntoggleAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onvolumechange", "MathMLElement", OnvolumechangeAttributeGetCallback, OnvolumechangeAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onwaiting", "MathMLElement", OnwaitingAttributeGetCallback, OnwaitingAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onwebkitanimationend", "MathMLElement", OnwebkitanimationendAttributeGetCallback, OnwebkitanimationendAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onwebkitanimationiteration", "MathMLElement", OnwebkitanimationiterationAttributeGetCallback, OnwebkitanimationiterationAttributeSetCallback,
                unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onwebkitanimationstart", "MathMLElement", OnwebkitanimationstartAttributeGetCallback, OnwebkitanimationstartAttributeSetCallback,
                unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onwebkittransitionend", "MathMLElement", OnwebkittransitionendAttributeGetCallback, OnwebkittransitionendAttributeSetCallback,
                unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onwheel", "MathMLElement", OnwheelAttributeGetCallback, OnwheelAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onauxclick", "MathMLElement", OnauxclickAttributeGetCallback, OnauxclickAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ongotpointercapture", "MathMLElement", OngotpointercaptureAttributeGetCallback, OngotpointercaptureAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onlostpointercapture", "MathMLElement", OnlostpointercaptureAttributeGetCallback, OnlostpointercaptureAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onpointerdown", "MathMLElement", OnpointerdownAttributeGetCallback, OnpointerdownAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onpointermove", "MathMLElement", OnpointermoveAttributeGetCallback, OnpointermoveAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onpointerrawupdate", "MathMLElement", OnpointerrawupdateAttributeGetCallback, OnpointerrawupdateAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onpointerup", "MathMLElement", OnpointerupAttributeGetCallback, OnpointerupAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onpointercancel", "MathMLElement", OnpointercancelAttributeGetCallback, OnpointercancelAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onpointerover", "MathMLElement", OnpointeroverAttributeGetCallback, OnpointeroverAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onpointerout", "MathMLElement", OnpointeroutAttributeGetCallback, OnpointeroutAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onpointerenter", "MathMLElement", OnpointerenterAttributeGetCallback, OnpointerenterAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onpointerleave", "MathMLElement", OnpointerleaveAttributeGetCallback, OnpointerleaveAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onselectstart", "MathMLElement", OnselectstartAttributeGetCallback, OnselectstartAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onselectionchange", "MathMLElement", OnselectionchangeAttributeGetCallback, OnselectionchangeAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onanimationend", "MathMLElement", OnanimationendAttributeGetCallback, OnanimationendAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onanimationiteration", "MathMLElement", OnanimationiterationAttributeGetCallback, OnanimationiterationAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onanimationstart", "MathMLElement", OnanimationstartAttributeGetCallback, OnanimationstartAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ontransitionrun", "MathMLElement", OntransitionrunAttributeGetCallback, OntransitionrunAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ontransitionstart", "MathMLElement", OntransitionstartAttributeGetCallback, OntransitionstartAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ontransitionend", "MathMLElement", OntransitionendAttributeGetCallback, OntransitionendAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ontransitioncancel", "MathMLElement", OntransitioncancelAttributeGetCallback, OntransitioncancelAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "oncopy", "MathMLElement", OncopyAttributeGetCallback, OncopyAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "oncut", "MathMLElement", OncutAttributeGetCallback, OncutAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onpaste", "MathMLElement", OnpasteAttributeGetCallback, OnpasteAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "dataset", "MathMLElement", DatasetAttributeGetCallbackForMainWorld, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kMainWorld),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "dataset", "MathMLElement", DatasetAttributeGetCallbackForNonMainWorlds, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kNonMainWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "nonce", "MathMLElement", NonceAttributeGetCallback, NonceAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "autofocus", "MathMLElement", AutofocusAttributeGetCallback, AutofocusAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "tabIndex", "MathMLElement", TabIndexAttributeGetCallback, TabIndexAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "style", "MathMLElement", StyleAttributeGetCallbackForMainWorld, StyleAttributeSetCallbackForMainWorld, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kMainWorld),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "style", "MathMLElement", StyleAttributeGetCallbackForNonMainWorlds, StyleAttributeSetCallbackForNonMainWorlds, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kNonMainWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "attributeStyleMap", "MathMLElement", AttributeStyleMapAttributeGetCallback, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
        };
        IDLMemberInstaller::InstallAttributes(isolate, world, instance_template, prototype_template, interface_template, signature, kAttributeTable);
    }

    {
        static const IDLMemberInstaller::OperationConfig kOperationTable[] = {
            { "blur", "MathMLElement", BlurOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "focus", "MathMLElement", FocusOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
        };
        IDLMemberInstaller::InstallOperations(isolate, world, instance_template, prototype_template, interface_template, signature, kOperationTable);
    }
}

void V8MathMLElement::Impl::InstallContextIndependentProperties(v8::Isolate* isolate, const DOMWrapperWorld& world, v8::Local<v8::Template> instance_template,
    v8::Local<v8::Template> prototype_template, v8::Local<v8::Template> interface_template)
{
    using bindings::IDLMemberInstaller;

    if (RuntimeEnabledFeatures::FencedFramesLocalUnpartitionedDataAccessEnabled()) {
        static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
            { "onfencedtreeclick", "MathMLElement", OnfencedtreeclickAttributeGetCallback, OnfencedtreeclickAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
        };
        v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
        v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
        IDLMemberInstaller::InstallAttributes(isolate, world, instance_template, prototype_template, interface_template, signature, kAttributeTable);
    }
    if (RuntimeEnabledFeatures::OverscrollCustomizationEnabled()) {
        static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
            { "onoverscroll", "MathMLElement", OnoverscrollAttributeGetCallback, OnoverscrollAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
        };
        v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
        v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
        IDLMemberInstaller::InstallAttributes(isolate, world, instance_template, prototype_template, interface_template, signature, kAttributeTable);
    }
    if (RuntimeEnabledFeatures::ScrollEndEventsEnabled()) {
        static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
            { "onscrollend", "MathMLElement", OnscrollendAttributeGetCallback, OnscrollendAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
        };
        v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
        v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
        IDLMemberInstaller::InstallAttributes(isolate, world, instance_template, prototype_template, interface_template, signature, kAttributeTable);
    }
    if (RuntimeEnabledFeatures::CSSScrollSnapChangeEventEnabled()) {
        static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
            { "onscrollsnapchange", "MathMLElement", OnscrollsnapchangeAttributeGetCallback, OnscrollsnapchangeAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
        };
        v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
        v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
        IDLMemberInstaller::InstallAttributes(isolate, world, instance_template, prototype_template, interface_template, signature, kAttributeTable);
    }
    if (RuntimeEnabledFeatures::CSSScrollSnapChangingEventEnabled()) {
        static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
            { "onscrollsnapchanging", "MathMLElement", OnscrollsnapchangingAttributeGetCallback, OnscrollsnapchangingAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
        };
        v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
        v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
        IDLMemberInstaller::InstallAttributes(isolate, world, instance_template, prototype_template, interface_template, signature, kAttributeTable);
    }
}

void V8MathMLElement::Impl::InstallContextDependentProperties(v8::Local<v8::Context> context, const DOMWrapperWorld& world,
    v8::Local<v8::Object> instance_object, v8::Local<v8::Object> prototype_object, v8::Local<v8::Object> interface_object,
    v8::Local<v8::Template> interface_template, FeatureSelector feature_selector)
{
    using bindings::IDLMemberInstaller;

    v8::Isolate* isolate = context->GetIsolate();
    ScriptState* script_state = ScriptState::From(isolate, context);
    ExecutionContext* execution_context = ToExecutionContext(script_state);
    if ((feature_selector.IsAll() && RuntimeEnabledFeatures::TouchEventFeatureDetectionEnabled(execution_context))
        || feature_selector.IsAnyOf(mojom::blink::OriginTrialFeature::kTouchEventFeatureDetection)) {
        static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
            { "ontouchcancel", "MathMLElement", OntouchcancelAttributeGetCallback, OntouchcancelAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ontouchend", "MathMLElement", OntouchendAttributeGetCallback, OntouchendAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ontouchmove", "MathMLElement", OntouchmoveAttributeGetCallback, OntouchmoveAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ontouchstart", "MathMLElement", OntouchstartAttributeGetCallback, OntouchstartAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
        };
        v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
        v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
        IDLMemberInstaller::InstallAttributes(isolate, world, instance_object, prototype_object, interface_object, signature, kAttributeTable);
    }
    if ((feature_selector.IsAll() && RuntimeEnabledFeatures::FocusgroupEnabled(execution_context))
        || feature_selector.IsAnyOf(mojom::blink::OriginTrialFeature::kFocusgroup)) {
        static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
            { "focusgroup", "MathMLElement", FocusgroupAttributeGetCallback, FocusgroupAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
        };
        v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
        v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
        IDLMemberInstaller::InstallAttributes(isolate, world, instance_object, prototype_object, interface_object, signature, kAttributeTable);
    }
}

} // namespace blink
