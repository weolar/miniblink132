// Copyright 2019 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// DO NOT EDIT: This file is auto-generated by
// //third_party/blink/renderer/bindings/scripts/generate_bindings.py
//
// Use the GN flag `blink_enable_generated_code_formatting=true` to enable
// formatting of the generated files.

#include "third_party/blink/renderer/bindings/modules/v8/v8_rtc_peer_connection.h"

#include "third_party/blink/public/mojom/origin_trials/origin_trial_feature.mojom-shared.h"
#include "third_party/blink/renderer/bindings/core/v8/generated_code_helper.h"
#include "third_party/blink/renderer/bindings/core/v8/is_return_type_compatible.h"
#include "third_party/blink/renderer/bindings/core/v8/native_value_traits_impl.h"
#include "third_party/blink/renderer/bindings/core/v8/to_v8_traits.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_event_handler_non_null.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_event_target.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_set_return_value_for_core.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_union_object_string.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_void_function.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_media_stream.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_media_stream_track.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_rtc_answer_options.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_rtc_certificate.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_rtc_configuration.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_rtc_data_channel.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_rtc_data_channel_init.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_rtc_dtmf_sender.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_rtc_ice_candidate_init.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_rtc_ice_connection_state.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_rtc_ice_gathering_state.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_rtc_offer_options.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_rtc_peer_connection_error_callback.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_rtc_peer_connection_state.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_rtc_rtp_receiver.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_rtc_rtp_sender.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_rtc_rtp_transceiver.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_rtc_rtp_transceiver_init.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_rtc_rtp_transport.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_rtc_sctp_transport.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_rtc_session_description.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_rtc_session_description_callback.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_rtc_session_description_init.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_rtc_signaling_state.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_rtc_stats_report.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_union_mediastreamtrack_string.h"
#include "third_party/blink/renderer/core/execution_context/execution_context.h"
#include "third_party/blink/renderer/core/frame/web_feature.h"
#include "third_party/blink/renderer/modules/mediastream/media_stream.h"
#include "third_party/blink/renderer/modules/mediastream/media_stream_track.h"
#include "third_party/blink/renderer/modules/peerconnection/rtc_certificate.h"
#include "third_party/blink/renderer/modules/peerconnection/rtc_data_channel.h"
#include "third_party/blink/renderer/modules/peerconnection/rtc_dtmf_sender.h"
#include "third_party/blink/renderer/modules/peerconnection/rtc_peer_connection.h"
#include "third_party/blink/renderer/modules/peerconnection/rtc_rtp_receiver.h"
#include "third_party/blink/renderer/modules/peerconnection/rtc_rtp_sender.h"
#include "third_party/blink/renderer/modules/peerconnection/rtc_rtp_transceiver.h"
#include "third_party/blink/renderer/modules/peerconnection/rtc_rtp_transport.h"
#include "third_party/blink/renderer/modules/peerconnection/rtc_sctp_transport.h"
#include "third_party/blink/renderer/modules/peerconnection/rtc_session_description.h"
#include "third_party/blink/renderer/modules/peerconnection/rtc_stats_report.h"
#include "third_party/blink/renderer/platform/bindings/cooperative_scheduling_helpers.h"
#include "third_party/blink/renderer/platform/bindings/exception_messages.h"
#include "third_party/blink/renderer/platform/bindings/idl_member_installer.h"
#include "third_party/blink/renderer/platform/bindings/runtime_call_stats.h"
#include "third_party/blink/renderer/platform/bindings/v8_binding.h"
#include "third_party/blink/renderer/platform/bindings/v8_object_constructor.h"
#include "third_party/blink/renderer/platform/bindings/wrapper_type_info.h"
#include "third_party/blink/renderer/platform/instrumentation/use_counter.h"

namespace blink {

bool V8RTCPeerConnection::IsExposed(ExecutionContext* execution_context)
{

    return execution_context->IsWindow();
}

// Construction of WrapperTypeInfo may require non-trivial initialization due
// to cross-component address resolution in order to load the pointer to the
// parent interface's WrapperTypeInfo.  We ignore this issue because the issue
// happens only on component builds and the official release builds
// (statically-linked builds) are never affected by this issue.
#if defined(COMPONENT_BUILD) && defined(WIN32) && defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wglobal-constructors"
#endif

const WrapperTypeInfo V8RTCPeerConnection::wrapper_type_info_ {
    gin::kEmbedderBlink,
    V8RTCPeerConnection::InstallInterfaceTemplate,
    nullptr,
    "RTCPeerConnection",
    V8EventTarget::GetWrapperTypeInfo(),
    V8RTCPeerConnection::kThisTag,
    V8RTCPeerConnection::kMaxSubclassTag,
    WrapperTypeInfo::kWrapperTypeObjectPrototype,
    WrapperTypeInfo::kObjectClassId,
    WrapperTypeInfo::kInheritFromActiveScriptWrappable,
    WrapperTypeInfo::kIdlInterface,
    false,
};

#if defined(COMPONENT_BUILD) && defined(WIN32) && defined(__clang__)
#pragma clang diagnostic pop
#endif

const WrapperTypeInfo& RTCPeerConnection::wrapper_type_info_ = V8RTCPeerConnection::wrapper_type_info_;

// [ActiveScriptWrappable]
static_assert(std::is_base_of<ActiveScriptWrappableBase, RTCPeerConnection>::value,
    "RTCPeerConnection does not inherit from ActiveScriptWrappable<> despite "
    "the IDL has [ActiveScriptWrappable] extended attribute.");

namespace {

namespace v8_rtc_peer_connection {

void LocalDescriptionAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_RTCPeerConnection_localDescription_Getter");
    BLINK_BINDINGS_TRACE_EVENT("RTCPeerConnection.localDescription.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    RTCPeerConnection* blink_receiver = V8RTCPeerConnection::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->localDescription();
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<RTCSessionDescription>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void CurrentLocalDescriptionAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_RTCPeerConnection_currentLocalDescription_Getter");
    BLINK_BINDINGS_TRACE_EVENT("RTCPeerConnection.currentLocalDescription.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    RTCPeerConnection* blink_receiver = V8RTCPeerConnection::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->currentLocalDescription();
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<RTCSessionDescription>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void PendingLocalDescriptionAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_RTCPeerConnection_pendingLocalDescription_Getter");
    BLINK_BINDINGS_TRACE_EVENT("RTCPeerConnection.pendingLocalDescription.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    RTCPeerConnection* blink_receiver = V8RTCPeerConnection::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->pendingLocalDescription();
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<RTCSessionDescription>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void RemoteDescriptionAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_RTCPeerConnection_remoteDescription_Getter");
    BLINK_BINDINGS_TRACE_EVENT("RTCPeerConnection.remoteDescription.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    RTCPeerConnection* blink_receiver = V8RTCPeerConnection::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->remoteDescription();
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<RTCSessionDescription>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void CurrentRemoteDescriptionAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_RTCPeerConnection_currentRemoteDescription_Getter");
    BLINK_BINDINGS_TRACE_EVENT("RTCPeerConnection.currentRemoteDescription.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    RTCPeerConnection* blink_receiver = V8RTCPeerConnection::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->currentRemoteDescription();
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<RTCSessionDescription>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void PendingRemoteDescriptionAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_RTCPeerConnection_pendingRemoteDescription_Getter");
    BLINK_BINDINGS_TRACE_EVENT("RTCPeerConnection.pendingRemoteDescription.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    RTCPeerConnection* blink_receiver = V8RTCPeerConnection::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->pendingRemoteDescription();
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<RTCSessionDescription>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void SignalingStateAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_RTCPeerConnection_signalingState_Getter");
    BLINK_BINDINGS_TRACE_EVENT("RTCPeerConnection.signalingState.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    RTCPeerConnection* blink_receiver = V8RTCPeerConnection::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->signalingState();
    static_assert(bindings::IsReturnTypeCompatible<V8RTCSignalingState, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void IceGatheringStateAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_RTCPeerConnection_iceGatheringState_Getter");
    BLINK_BINDINGS_TRACE_EVENT("RTCPeerConnection.iceGatheringState.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    RTCPeerConnection* blink_receiver = V8RTCPeerConnection::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->iceGatheringState();
    static_assert(bindings::IsReturnTypeCompatible<V8RTCIceGatheringState, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void IceConnectionStateAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_RTCPeerConnection_iceConnectionState_Getter");
    BLINK_BINDINGS_TRACE_EVENT("RTCPeerConnection.iceConnectionState.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    RTCPeerConnection* blink_receiver = V8RTCPeerConnection::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->iceConnectionState();
    static_assert(bindings::IsReturnTypeCompatible<V8RTCIceConnectionState, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void ConnectionStateAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_RTCPeerConnection_connectionState_Getter");
    BLINK_BINDINGS_TRACE_EVENT("RTCPeerConnection.connectionState.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    RTCPeerConnection* blink_receiver = V8RTCPeerConnection::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->connectionState();
    static_assert(bindings::IsReturnTypeCompatible<V8RTCPeerConnectionState, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void CanTrickleIceCandidatesAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_RTCPeerConnection_canTrickleIceCandidates_Getter");
    BLINK_BINDINGS_TRACE_EVENT("RTCPeerConnection.canTrickleIceCandidates.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    RTCPeerConnection* blink_receiver = V8RTCPeerConnection::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->canTrickleIceCandidates();
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLBoolean>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void OnnegotiationneededAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_RTCPeerConnection_onnegotiationneeded_Getter");
    BLINK_BINDINGS_TRACE_EVENT("RTCPeerConnection.onnegotiationneeded.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    RTCPeerConnection* blink_receiver = V8RTCPeerConnection::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onnegotiationneeded();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnnegotiationneededAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_RTCPeerConnection_onnegotiationneeded_Setter");
    BLINK_BINDINGS_TRACE_EVENT("RTCPeerConnection.onnegotiationneeded.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    RTCPeerConnection* blink_receiver = V8RTCPeerConnection::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnnegotiationneeded(event_handler);
}

void OnicecandidateAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_RTCPeerConnection_onicecandidate_Getter");
    BLINK_BINDINGS_TRACE_EVENT("RTCPeerConnection.onicecandidate.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    RTCPeerConnection* blink_receiver = V8RTCPeerConnection::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onicecandidate();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnicecandidateAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_RTCPeerConnection_onicecandidate_Setter");
    BLINK_BINDINGS_TRACE_EVENT("RTCPeerConnection.onicecandidate.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    RTCPeerConnection* blink_receiver = V8RTCPeerConnection::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnicecandidate(event_handler);
}

void OnsignalingstatechangeAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_RTCPeerConnection_onsignalingstatechange_Getter");
    BLINK_BINDINGS_TRACE_EVENT("RTCPeerConnection.onsignalingstatechange.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    RTCPeerConnection* blink_receiver = V8RTCPeerConnection::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onsignalingstatechange();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnsignalingstatechangeAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_RTCPeerConnection_onsignalingstatechange_Setter");
    BLINK_BINDINGS_TRACE_EVENT("RTCPeerConnection.onsignalingstatechange.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    RTCPeerConnection* blink_receiver = V8RTCPeerConnection::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnsignalingstatechange(event_handler);
}

void OniceconnectionstatechangeAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_RTCPeerConnection_oniceconnectionstatechange_Getter");
    BLINK_BINDINGS_TRACE_EVENT("RTCPeerConnection.oniceconnectionstatechange.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    RTCPeerConnection* blink_receiver = V8RTCPeerConnection::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->oniceconnectionstatechange();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OniceconnectionstatechangeAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_RTCPeerConnection_oniceconnectionstatechange_Setter");
    BLINK_BINDINGS_TRACE_EVENT("RTCPeerConnection.oniceconnectionstatechange.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    RTCPeerConnection* blink_receiver = V8RTCPeerConnection::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOniceconnectionstatechange(event_handler);
}

void OnconnectionstatechangeAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_RTCPeerConnection_onconnectionstatechange_Getter");
    BLINK_BINDINGS_TRACE_EVENT("RTCPeerConnection.onconnectionstatechange.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    RTCPeerConnection* blink_receiver = V8RTCPeerConnection::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onconnectionstatechange();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnconnectionstatechangeAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_RTCPeerConnection_onconnectionstatechange_Setter");
    BLINK_BINDINGS_TRACE_EVENT("RTCPeerConnection.onconnectionstatechange.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    RTCPeerConnection* blink_receiver = V8RTCPeerConnection::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnconnectionstatechange(event_handler);
}

void OnicegatheringstatechangeAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_RTCPeerConnection_onicegatheringstatechange_Getter");
    BLINK_BINDINGS_TRACE_EVENT("RTCPeerConnection.onicegatheringstatechange.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    RTCPeerConnection* blink_receiver = V8RTCPeerConnection::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onicegatheringstatechange();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnicegatheringstatechangeAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_RTCPeerConnection_onicegatheringstatechange_Setter");
    BLINK_BINDINGS_TRACE_EVENT("RTCPeerConnection.onicegatheringstatechange.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    RTCPeerConnection* blink_receiver = V8RTCPeerConnection::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnicegatheringstatechange(event_handler);
}

void OnicecandidateerrorAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_RTCPeerConnection_onicecandidateerror_Getter");
    BLINK_BINDINGS_TRACE_EVENT("RTCPeerConnection.onicecandidateerror.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    RTCPeerConnection* blink_receiver = V8RTCPeerConnection::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onicecandidateerror();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnicecandidateerrorAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_RTCPeerConnection_onicecandidateerror_Setter");
    BLINK_BINDINGS_TRACE_EVENT("RTCPeerConnection.onicecandidateerror.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    RTCPeerConnection* blink_receiver = V8RTCPeerConnection::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnicecandidateerror(event_handler);
}

void OntrackAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_RTCPeerConnection_ontrack_Getter");
    BLINK_BINDINGS_TRACE_EVENT("RTCPeerConnection.ontrack.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    RTCPeerConnection* blink_receiver = V8RTCPeerConnection::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ontrack();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OntrackAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_RTCPeerConnection_ontrack_Setter");
    BLINK_BINDINGS_TRACE_EVENT("RTCPeerConnection.ontrack.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    RTCPeerConnection* blink_receiver = V8RTCPeerConnection::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOntrack(event_handler);
}

void SctpAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_RTCPeerConnection_sctp_Getter");
    BLINK_BINDINGS_TRACE_EVENT("RTCPeerConnection.sctp.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    RTCPeerConnection* blink_receiver = V8RTCPeerConnection::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->sctp();
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<RTCSctpTransport>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void OndatachannelAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_RTCPeerConnection_ondatachannel_Getter");
    BLINK_BINDINGS_TRACE_EVENT("RTCPeerConnection.ondatachannel.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    RTCPeerConnection* blink_receiver = V8RTCPeerConnection::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ondatachannel();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OndatachannelAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_RTCPeerConnection_ondatachannel_Setter");
    BLINK_BINDINGS_TRACE_EVENT("RTCPeerConnection.ondatachannel.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    RTCPeerConnection* blink_receiver = V8RTCPeerConnection::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOndatachannel(event_handler);
}

void RtpTransportAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_RTCPeerConnection_rtpTransport_Getter");
    BLINK_BINDINGS_TRACE_EVENT("RTCPeerConnection.rtpTransport.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    RTCPeerConnection* blink_receiver = V8RTCPeerConnection::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->rtpTransport();
    static_assert(bindings::IsReturnTypeCompatible<RTCRtpTransport, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void OnaddstreamAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_RTCPeerConnection_onaddstream_Getter");
    BLINK_BINDINGS_TRACE_EVENT("RTCPeerConnection.onaddstream.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    RTCPeerConnection* blink_receiver = V8RTCPeerConnection::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onaddstream();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnaddstreamAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_RTCPeerConnection_onaddstream_Setter");
    BLINK_BINDINGS_TRACE_EVENT("RTCPeerConnection.onaddstream.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    RTCPeerConnection* blink_receiver = V8RTCPeerConnection::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnaddstream(event_handler);
}

void OnremovestreamAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_RTCPeerConnection_onremovestream_Getter");
    BLINK_BINDINGS_TRACE_EVENT("RTCPeerConnection.onremovestream.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    RTCPeerConnection* blink_receiver = V8RTCPeerConnection::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onremovestream();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnremovestreamAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_RTCPeerConnection_onremovestream_Setter");
    BLINK_BINDINGS_TRACE_EVENT("RTCPeerConnection.onremovestream.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    RTCPeerConnection* blink_receiver = V8RTCPeerConnection::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnremovestream(event_handler);
}

void ConstructorCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_RTCPeerConnection_constructor");
    BLINK_BINDINGS_TRACE_EVENT("RTCPeerConnection.constructor");

    v8::Isolate* isolate = info.GetIsolate();
    if (!info.IsConstructCall()) {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::ConstructorCalledAsFunction());
        return;
    }
    v8::Local<v8::Object> v8_receiver = info.This();
    if (ConstructorMode::Current(isolate) == ConstructorMode::kWrapExistingObject) {
        bindings::V8SetReturnValue(info, v8_receiver);
        return;
    }

    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    ExecutionContext* execution_context = current_execution_context;
    decltype(NativeValueTraits<RTCConfiguration>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg1_configuration;
    ExceptionState exception_state(isolate);
    if (info[0]->IsUndefined()) {
        arg1_configuration = RTCConfiguration::Create();
    } else {
        arg1_configuration = NativeValueTraits<RTCConfiguration>::ArgumentValue(isolate, 0, info[0], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = RTCPeerConnection::Create(execution_context, arg1_configuration, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<RTCPeerConnection, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    v8::Local<v8::Object> v8_wrapper = return_value->AssociateWithWrapper(isolate, V8RTCPeerConnection::GetWrapperTypeInfo(), v8_receiver);
    bindings::V8SetReturnValue(info, v8_wrapper);
}

void AddIceCandidateOperationOverload1(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    if (!V8RTCPeerConnection::HasInstance(isolate, v8_receiver)) {
        V8ThrowException::ThrowTypeError(isolate, "Illegal invocation");
        return;
    }

    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kRTCPeerConnectionAddIceCandidatePromise);

    RTCPeerConnection* blink_receiver = V8RTCPeerConnection::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    decltype(NativeValueTraits<RTCIceCandidateInit>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg1_candidate;
    const v8::ExceptionContext exception_context_type = v8::ExceptionContext::kOperation;
    const char* const class_like_name = "RTCPeerConnection";
    const char* const property_name = "addIceCandidate";
    ExceptionState exception_state(isolate, exception_context_type, class_like_name, property_name);
    if (info[0]->IsUndefined()) {
        arg1_candidate = RTCIceCandidateInit::Create();
    } else {
        arg1_candidate = NativeValueTraits<RTCIceCandidateInit>::ArgumentValue(isolate, 0, info[0], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    ScriptPromise<IDLUndefined> return_value = blink_receiver->addIceCandidate(script_state, arg1_candidate, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value);
}

void AddIceCandidateOperationOverload2(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    if (!V8RTCPeerConnection::HasInstance(isolate, v8_receiver)) {
        V8ThrowException::ThrowTypeError(isolate, "Illegal invocation");
        return;
    }

    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kRTCPeerConnectionAddIceCandidateLegacy);

    if (info.Length() < 3) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(3, info.Length()));
        return;
    }

    RTCPeerConnection* blink_receiver = V8RTCPeerConnection::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    const v8::ExceptionContext exception_context_type = v8::ExceptionContext::kOperation;
    const char* const class_like_name = "RTCPeerConnection";
    const char* const property_name = "addIceCandidate";
    ExceptionState exception_state(isolate, exception_context_type, class_like_name, property_name);
    auto&& arg1_candidate = NativeValueTraits<RTCIceCandidateInit>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_success_callback = NativeValueTraits<V8VoidFunction>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_failure_callback = NativeValueTraits<V8RTCPeerConnectionErrorCallback>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    ScriptPromise<IDLUndefined> return_value
        = blink_receiver->addIceCandidate(script_state, arg1_candidate, arg2_success_callback, arg3_failure_callback, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value);
}

void AddIceCandidateOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    // Promise returning function: Convert a TypeError to a reject promise.
    ExceptionToRejectPromiseScope reject_promise_scope(info);
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_RTCPeerConnection_addIceCandidate");
    BLINK_BINDINGS_TRACE_EVENT("RTCPeerConnection.addIceCandidate");

    BINDINGS_COOPERATIVE_SCHEDULING_SAFEPOINT();

    const int arg_count = std::min(info.Length(), 3);
    if (arg_count == 3) {
        return AddIceCandidateOperationOverload2(info);
    }
    if (arg_count == 1) {
        return AddIceCandidateOperationOverload1(info);
    }
    return AddIceCandidateOperationOverload1(info);
}

void AddStreamOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_RTCPeerConnection_addStream");
    BLINK_BINDINGS_TRACE_EVENT("RTCPeerConnection.addStream");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kV8RTCPeerConnection_AddStream_Method);

    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    RTCPeerConnection* blink_receiver = V8RTCPeerConnection::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    ExceptionState exception_state(isolate);
    auto&& arg1_stream = NativeValueTraits<MediaStream>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->addStream(script_state, arg1_stream, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void AddTrackOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_RTCPeerConnection_addTrack");
    BLINK_BINDINGS_TRACE_EVENT("RTCPeerConnection.addTrack");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kV8RTCPeerConnection_AddTrack_Method);

    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    RTCPeerConnection* blink_receiver = V8RTCPeerConnection::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_track = NativeValueTraits<MediaStreamTrack>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_streams = bindings::VariadicArgumentsToNativeValues<MediaStream>(isolate, info, 1, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->addTrack(arg1_track, arg2_streams, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<RTCRtpSender, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void AddTransceiverOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_RTCPeerConnection_addTransceiver");
    BLINK_BINDINGS_TRACE_EVENT("RTCPeerConnection.addTransceiver");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kV8RTCPeerConnection_AddTransceiver_Method);

    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    RTCPeerConnection* blink_receiver = V8RTCPeerConnection::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_track_or_kind = NativeValueTraits<V8UnionMediaStreamTrackOrString>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<RTCRtpTransceiverInit>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg2_init;
    if (info[1]->IsUndefined()) {
        arg2_init = RTCRtpTransceiverInit::Create();
    } else {
        arg2_init = NativeValueTraits<RTCRtpTransceiverInit>::ArgumentValue(isolate, 1, info[1], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->addTransceiver(arg1_track_or_kind, arg2_init, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<RTCRtpTransceiver, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void CloseOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_RTCPeerConnection_close");
    BLINK_BINDINGS_TRACE_EVENT("RTCPeerConnection.close");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    RTCPeerConnection* blink_receiver = V8RTCPeerConnection::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->close();
}

void CreateAnswerOperationOverload1(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    if (!V8RTCPeerConnection::HasInstance(isolate, v8_receiver)) {
        V8ThrowException::ThrowTypeError(isolate, "Illegal invocation");
        return;
    }

    RTCPeerConnection* blink_receiver = V8RTCPeerConnection::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    decltype(NativeValueTraits<RTCAnswerOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg1_options;
    const v8::ExceptionContext exception_context_type = v8::ExceptionContext::kOperation;
    const char* const class_like_name = "RTCPeerConnection";
    const char* const property_name = "createAnswer";
    ExceptionState exception_state(isolate, exception_context_type, class_like_name, property_name);
    if (info[0]->IsUndefined()) {
        arg1_options = RTCAnswerOptions::Create();
    } else {
        arg1_options = NativeValueTraits<RTCAnswerOptions>::ArgumentValue(isolate, 0, info[0], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    ScriptPromise<RTCSessionDescriptionInit> return_value = blink_receiver->createAnswer(script_state, arg1_options, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value);
}

void CreateAnswerOperationOverload2(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    if (!V8RTCPeerConnection::HasInstance(isolate, v8_receiver)) {
        V8ThrowException::ThrowTypeError(isolate, "Illegal invocation");
        return;
    }

    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    RTCPeerConnection* blink_receiver = V8RTCPeerConnection::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    const v8::ExceptionContext exception_context_type = v8::ExceptionContext::kOperation;
    const char* const class_like_name = "RTCPeerConnection";
    const char* const property_name = "createAnswer";
    ExceptionState exception_state(isolate, exception_context_type, class_like_name, property_name);
    auto&& arg1_success_callback = NativeValueTraits<V8RTCSessionDescriptionCallback>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_failure_callback = NativeValueTraits<V8RTCPeerConnectionErrorCallback>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    ScriptPromise<IDLUndefined> return_value = blink_receiver->createAnswer(script_state, arg1_success_callback, arg2_failure_callback, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value);
}

void CreateAnswerOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    // Promise returning function: Convert a TypeError to a reject promise.
    ExceptionToRejectPromiseScope reject_promise_scope(info);
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_RTCPeerConnection_createAnswer");
    BLINK_BINDINGS_TRACE_EVENT("RTCPeerConnection.createAnswer");

    BINDINGS_COOPERATIVE_SCHEDULING_SAFEPOINT();

    const int arg_count = std::min(info.Length(), 2);
    if (arg_count == 2) {
        return CreateAnswerOperationOverload2(info);
    }
    if (arg_count == 1) {
        return CreateAnswerOperationOverload1(info);
    }
    return CreateAnswerOperationOverload1(info);
}

void CreateDTMFSenderOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_RTCPeerConnection_createDTMFSender");
    BLINK_BINDINGS_TRACE_EVENT("RTCPeerConnection.createDTMFSender");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kV8RTCPeerConnection_CreateDTMFSender_Method);

    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    RTCPeerConnection* blink_receiver = V8RTCPeerConnection::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_track = NativeValueTraits<MediaStreamTrack>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->createDTMFSender(arg1_track, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<RTCDTMFSender, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void CreateDataChannelOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_RTCPeerConnection_createDataChannel");
    BLINK_BINDINGS_TRACE_EVENT("RTCPeerConnection.createDataChannel");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    RTCPeerConnection* blink_receiver = V8RTCPeerConnection::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    ExceptionState exception_state(isolate);
    auto&& arg1_label = NativeValueTraits<IDLUSVString>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<RTCDataChannelInit>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg2_data_channel_dict;
    if (info[1]->IsUndefined()) {
        arg2_data_channel_dict = RTCDataChannelInit::Create();
    } else {
        arg2_data_channel_dict = NativeValueTraits<RTCDataChannelInit>::ArgumentValue(isolate, 1, info[1], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->createDataChannel(script_state, arg1_label, arg2_data_channel_dict, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<RTCDataChannel, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void CreateOfferOperationOverload1(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    if (!V8RTCPeerConnection::HasInstance(isolate, v8_receiver)) {
        V8ThrowException::ThrowTypeError(isolate, "Illegal invocation");
        return;
    }

    RTCPeerConnection* blink_receiver = V8RTCPeerConnection::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    decltype(NativeValueTraits<RTCOfferOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg1_options;
    const v8::ExceptionContext exception_context_type = v8::ExceptionContext::kOperation;
    const char* const class_like_name = "RTCPeerConnection";
    const char* const property_name = "createOffer";
    ExceptionState exception_state(isolate, exception_context_type, class_like_name, property_name);
    if (info[0]->IsUndefined()) {
        arg1_options = RTCOfferOptions::Create();
    } else {
        arg1_options = NativeValueTraits<RTCOfferOptions>::ArgumentValue(isolate, 0, info[0], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    ScriptPromise<RTCSessionDescriptionInit> return_value = blink_receiver->createOffer(script_state, arg1_options, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value);
}

void CreateOfferOperationOverload2(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    if (!V8RTCPeerConnection::HasInstance(isolate, v8_receiver)) {
        V8ThrowException::ThrowTypeError(isolate, "Illegal invocation");
        return;
    }

    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    RTCPeerConnection* blink_receiver = V8RTCPeerConnection::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    const v8::ExceptionContext exception_context_type = v8::ExceptionContext::kOperation;
    const char* const class_like_name = "RTCPeerConnection";
    const char* const property_name = "createOffer";
    ExceptionState exception_state(isolate, exception_context_type, class_like_name, property_name);
    auto&& arg1_success_callback = NativeValueTraits<V8RTCSessionDescriptionCallback>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_failure_callback = NativeValueTraits<V8RTCPeerConnectionErrorCallback>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<RTCOfferOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg3_options;
    if (info[2]->IsUndefined()) {
        arg3_options = RTCOfferOptions::Create();
    } else {
        arg3_options = NativeValueTraits<RTCOfferOptions>::ArgumentValue(isolate, 2, info[2], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    ScriptPromise<IDLUndefined> return_value
        = blink_receiver->createOffer(script_state, arg1_success_callback, arg2_failure_callback, arg3_options, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value);
}

void CreateOfferOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    // Promise returning function: Convert a TypeError to a reject promise.
    ExceptionToRejectPromiseScope reject_promise_scope(info);
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_RTCPeerConnection_createOffer");
    BLINK_BINDINGS_TRACE_EVENT("RTCPeerConnection.createOffer");

    BINDINGS_COOPERATIVE_SCHEDULING_SAFEPOINT();

    const int arg_count = std::min(info.Length(), 3);
    if (arg_count == 3) {
        return CreateOfferOperationOverload2(info);
    }
    if (arg_count == 2) {
        return CreateOfferOperationOverload2(info);
    }
    if (arg_count == 1) {
        return CreateOfferOperationOverload1(info);
    }
    return CreateOfferOperationOverload1(info);
}

void GetConfigurationOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_RTCPeerConnection_getConfiguration");
    BLINK_BINDINGS_TRACE_EVENT("RTCPeerConnection.getConfiguration");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    RTCPeerConnection* blink_receiver = V8RTCPeerConnection::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->getConfiguration(script_state);
    static_assert(bindings::IsReturnTypeCompatible<RTCConfiguration, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    v8::Local<v8::Value> v8_return_value = ToV8Traits<RTCConfiguration>::ToV8(script_state, return_value);
    bindings::V8SetReturnValue(info, v8_return_value);
}

void GetLocalStreamsOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_RTCPeerConnection_getLocalStreams");
    BLINK_BINDINGS_TRACE_EVENT("RTCPeerConnection.getLocalStreams");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kV8RTCPeerConnection_GetLocalStreams_Method);

    v8::Local<v8::Object> v8_receiver = info.This();
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    RTCPeerConnection* blink_receiver = V8RTCPeerConnection::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->getLocalStreams();
    static_assert(bindings::IsReturnTypeCompatible<IDLSequence<MediaStream>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    v8::Local<v8::Value> v8_return_value = ToV8Traits<IDLSequence<MediaStream>>::ToV8(script_state, return_value);
    bindings::V8SetReturnValue(info, v8_return_value);
}

void GetReceiversOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_RTCPeerConnection_getReceivers");
    BLINK_BINDINGS_TRACE_EVENT("RTCPeerConnection.getReceivers");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kV8RTCPeerConnection_GetReceivers_Method);

    v8::Local<v8::Object> v8_receiver = info.This();
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    RTCPeerConnection* blink_receiver = V8RTCPeerConnection::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->getReceivers();
    static_assert(bindings::IsReturnTypeCompatible<IDLSequence<RTCRtpReceiver>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    v8::Local<v8::Value> v8_return_value = ToV8Traits<IDLSequence<RTCRtpReceiver>>::ToV8(script_state, return_value);
    bindings::V8SetReturnValue(info, v8_return_value);
}

void GetRemoteStreamsOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_RTCPeerConnection_getRemoteStreams");
    BLINK_BINDINGS_TRACE_EVENT("RTCPeerConnection.getRemoteStreams");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kV8RTCPeerConnection_GetRemoteStreams_Method);

    v8::Local<v8::Object> v8_receiver = info.This();
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    RTCPeerConnection* blink_receiver = V8RTCPeerConnection::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->getRemoteStreams();
    static_assert(bindings::IsReturnTypeCompatible<IDLSequence<MediaStream>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    v8::Local<v8::Value> v8_return_value = ToV8Traits<IDLSequence<MediaStream>>::ToV8(script_state, return_value);
    bindings::V8SetReturnValue(info, v8_return_value);
}

void GetSendersOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_RTCPeerConnection_getSenders");
    BLINK_BINDINGS_TRACE_EVENT("RTCPeerConnection.getSenders");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kV8RTCPeerConnection_GetSenders_Method);

    v8::Local<v8::Object> v8_receiver = info.This();
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    RTCPeerConnection* blink_receiver = V8RTCPeerConnection::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->getSenders();
    static_assert(bindings::IsReturnTypeCompatible<IDLSequence<RTCRtpSender>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    v8::Local<v8::Value> v8_return_value = ToV8Traits<IDLSequence<RTCRtpSender>>::ToV8(script_state, return_value);
    bindings::V8SetReturnValue(info, v8_return_value);
}

void GetStatsOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_RTCPeerConnection_getStats");
    BLINK_BINDINGS_TRACE_EVENT("RTCPeerConnection.getStats");
    // Promise returning function: Convert a TypeError to a reject promise.
    ExceptionToRejectPromiseScope reject_promise_scope(info);

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    if (!V8RTCPeerConnection::HasInstance(isolate, v8_receiver)) {
        V8ThrowException::ThrowTypeError(isolate, "Illegal invocation");
        return;
    }

    RTCPeerConnection* blink_receiver = V8RTCPeerConnection::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    decltype(NativeValueTraits<IDLNullable<MediaStreamTrack>>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg1_selector { nullptr };
    const v8::ExceptionContext exception_context_type = v8::ExceptionContext::kOperation;
    const char* const class_like_name = "RTCPeerConnection";
    const char* const property_name = "getStats";
    ExceptionState exception_state(isolate, exception_context_type, class_like_name, property_name);
    if (!info[0]->IsUndefined()) {
        arg1_selector = NativeValueTraits<IDLNullable<MediaStreamTrack>>::ArgumentValue(isolate, 0, info[0], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    ScriptPromise<RTCStatsReport> return_value = blink_receiver->getStats(script_state, arg1_selector, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value);
}

void GetTransceiversOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_RTCPeerConnection_getTransceivers");
    BLINK_BINDINGS_TRACE_EVENT("RTCPeerConnection.getTransceivers");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kV8RTCPeerConnection_GetTransceivers_Method);

    v8::Local<v8::Object> v8_receiver = info.This();
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    RTCPeerConnection* blink_receiver = V8RTCPeerConnection::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->getTransceivers();
    static_assert(bindings::IsReturnTypeCompatible<IDLSequence<RTCRtpTransceiver>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    v8::Local<v8::Value> v8_return_value = ToV8Traits<IDLSequence<RTCRtpTransceiver>>::ToV8(script_state, return_value);
    bindings::V8SetReturnValue(info, v8_return_value);
}

void RemoveStreamOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_RTCPeerConnection_removeStream");
    BLINK_BINDINGS_TRACE_EVENT("RTCPeerConnection.removeStream");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kV8RTCPeerConnection_RemoveStream_Method);

    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    RTCPeerConnection* blink_receiver = V8RTCPeerConnection::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_stream = NativeValueTraits<MediaStream>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->removeStream(arg1_stream, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void RemoveTrackOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_RTCPeerConnection_removeTrack");
    BLINK_BINDINGS_TRACE_EVENT("RTCPeerConnection.removeTrack");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kV8RTCPeerConnection_RemoveTrack_Method);

    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    RTCPeerConnection* blink_receiver = V8RTCPeerConnection::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_sender = NativeValueTraits<RTCRtpSender>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->removeTrack(arg1_sender, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void RestartIceOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_RTCPeerConnection_restartIce");
    BLINK_BINDINGS_TRACE_EVENT("RTCPeerConnection.restartIce");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    RTCPeerConnection* blink_receiver = V8RTCPeerConnection::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->restartIce();
}

void SetConfigurationOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_RTCPeerConnection_setConfiguration");
    BLINK_BINDINGS_TRACE_EVENT("RTCPeerConnection.setConfiguration");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    RTCPeerConnection* blink_receiver = V8RTCPeerConnection::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    decltype(NativeValueTraits<RTCConfiguration>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg1_configuration;
    ExceptionState exception_state(isolate);
    if (info[0]->IsUndefined()) {
        arg1_configuration = RTCConfiguration::Create();
    } else {
        arg1_configuration = NativeValueTraits<RTCConfiguration>::ArgumentValue(isolate, 0, info[0], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    blink_receiver->setConfiguration(script_state, arg1_configuration, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void SetLocalDescriptionOperationOverload1(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    if (!V8RTCPeerConnection::HasInstance(isolate, v8_receiver)) {
        V8ThrowException::ThrowTypeError(isolate, "Illegal invocation");
        return;
    }

    RTCPeerConnection* blink_receiver = V8RTCPeerConnection::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    decltype(NativeValueTraits<RTCSessionDescriptionInit>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg1_description;
    const v8::ExceptionContext exception_context_type = v8::ExceptionContext::kOperation;
    const char* const class_like_name = "RTCPeerConnection";
    const char* const property_name = "setLocalDescription";
    ExceptionState exception_state(isolate, exception_context_type, class_like_name, property_name);
    if (info[0]->IsUndefined()) {
        arg1_description = RTCSessionDescriptionInit::Create();
    } else {
        arg1_description = NativeValueTraits<RTCSessionDescriptionInit>::ArgumentValue(isolate, 0, info[0], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    ScriptPromise<IDLUndefined> return_value = blink_receiver->setLocalDescription(script_state, arg1_description, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value);
}

void SetLocalDescriptionOperationOverload2(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    if (!V8RTCPeerConnection::HasInstance(isolate, v8_receiver)) {
        V8ThrowException::ThrowTypeError(isolate, "Illegal invocation");
        return;
    }

    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    ScriptPromise<IDLUndefined> return_value;
    do { // Dummy loop for use of 'break'.
        const int non_undefined_argument_length = bindings::NonUndefinedArgumentLength(info);
        RTCPeerConnection* blink_receiver = V8RTCPeerConnection::ToWrappableUnsafe(isolate, v8_receiver);
        ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
        ScriptState* script_state = receiver_script_state;
        const v8::ExceptionContext exception_context_type = v8::ExceptionContext::kOperation;
        const char* const class_like_name = "RTCPeerConnection";
        const char* const property_name = "setLocalDescription";
        ExceptionState exception_state(isolate, exception_context_type, class_like_name, property_name);
        auto&& arg1_description = NativeValueTraits<RTCSessionDescriptionInit>::ArgumentValue(isolate, 0, info[0], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
        auto&& arg2_success_callback = NativeValueTraits<V8VoidFunction>::ArgumentValue(isolate, 1, info[1], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
        if (non_undefined_argument_length <= 2) {
            return_value = blink_receiver->setLocalDescription(script_state, arg1_description, arg2_success_callback);
            break;
        }
        auto&& arg3_failure_callback = NativeValueTraits<IDLNullable<V8RTCPeerConnectionErrorCallback>>::ArgumentValue(isolate, 2, info[2], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
        return_value = blink_receiver->setLocalDescription(script_state, arg1_description, arg2_success_callback, arg3_failure_callback);
    } while (false);
    bindings::V8SetReturnValue(info, return_value);
}

void SetLocalDescriptionOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    // Promise returning function: Convert a TypeError to a reject promise.
    ExceptionToRejectPromiseScope reject_promise_scope(info);
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_RTCPeerConnection_setLocalDescription");
    BLINK_BINDINGS_TRACE_EVENT("RTCPeerConnection.setLocalDescription");

    BINDINGS_COOPERATIVE_SCHEDULING_SAFEPOINT();

    const int arg_count = std::min(info.Length(), 3);
    if (arg_count == 3) {
        return SetLocalDescriptionOperationOverload2(info);
    }
    if (arg_count == 2) {
        return SetLocalDescriptionOperationOverload2(info);
    }
    if (arg_count == 1) {
        return SetLocalDescriptionOperationOverload1(info);
    }
    return SetLocalDescriptionOperationOverload1(info);
}

void SetRemoteDescriptionOperationOverload1(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    if (!V8RTCPeerConnection::HasInstance(isolate, v8_receiver)) {
        V8ThrowException::ThrowTypeError(isolate, "Illegal invocation");
        return;
    }

    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    RTCPeerConnection* blink_receiver = V8RTCPeerConnection::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    const v8::ExceptionContext exception_context_type = v8::ExceptionContext::kOperation;
    const char* const class_like_name = "RTCPeerConnection";
    const char* const property_name = "setRemoteDescription";
    ExceptionState exception_state(isolate, exception_context_type, class_like_name, property_name);
    auto&& arg1_description = NativeValueTraits<RTCSessionDescriptionInit>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    ScriptPromise<IDLUndefined> return_value = blink_receiver->setRemoteDescription(script_state, arg1_description, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value);
}

void SetRemoteDescriptionOperationOverload2(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    if (!V8RTCPeerConnection::HasInstance(isolate, v8_receiver)) {
        V8ThrowException::ThrowTypeError(isolate, "Illegal invocation");
        return;
    }

    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    ScriptPromise<IDLUndefined> return_value;
    do { // Dummy loop for use of 'break'.
        const int non_undefined_argument_length = bindings::NonUndefinedArgumentLength(info);
        RTCPeerConnection* blink_receiver = V8RTCPeerConnection::ToWrappableUnsafe(isolate, v8_receiver);
        ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
        ScriptState* script_state = receiver_script_state;
        const v8::ExceptionContext exception_context_type = v8::ExceptionContext::kOperation;
        const char* const class_like_name = "RTCPeerConnection";
        const char* const property_name = "setRemoteDescription";
        ExceptionState exception_state(isolate, exception_context_type, class_like_name, property_name);
        auto&& arg1_description = NativeValueTraits<RTCSessionDescriptionInit>::ArgumentValue(isolate, 0, info[0], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
        auto&& arg2_success_callback = NativeValueTraits<V8VoidFunction>::ArgumentValue(isolate, 1, info[1], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
        if (non_undefined_argument_length <= 2) {
            return_value = blink_receiver->setRemoteDescription(script_state, arg1_description, arg2_success_callback);
            break;
        }
        auto&& arg3_failure_callback = NativeValueTraits<IDLNullable<V8RTCPeerConnectionErrorCallback>>::ArgumentValue(isolate, 2, info[2], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
        return_value = blink_receiver->setRemoteDescription(script_state, arg1_description, arg2_success_callback, arg3_failure_callback);
    } while (false);
    bindings::V8SetReturnValue(info, return_value);
}

void SetRemoteDescriptionOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    // Promise returning function: Convert a TypeError to a reject promise.
    ExceptionToRejectPromiseScope reject_promise_scope(info);
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_RTCPeerConnection_setRemoteDescription");
    BLINK_BINDINGS_TRACE_EVENT("RTCPeerConnection.setRemoteDescription");

    BINDINGS_COOPERATIVE_SCHEDULING_SAFEPOINT();

    const int arg_count = std::min(info.Length(), 3);
    if (arg_count == 3) {
        return SetRemoteDescriptionOperationOverload2(info);
    }
    if (arg_count == 2) {
        return SetRemoteDescriptionOperationOverload2(info);
    }
    if (arg_count == 1) {
        return SetRemoteDescriptionOperationOverload1(info);
    }

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }
    V8ThrowException::ThrowTypeError(isolate, "Overload resolution failed.");
    return;
}

void GenerateCertificateStaticOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_RTCPeerConnection_generateCertificate");
    BLINK_BINDINGS_TRACE_EVENT("RTCPeerConnection.generateCertificate");
    // Promise returning function: Convert a TypeError to a reject promise.
    ExceptionToRejectPromiseScope reject_promise_scope(info);

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ScriptState* script_state = current_script_state;
    const v8::ExceptionContext exception_context_type = v8::ExceptionContext::kOperation;
    const char* const class_like_name = "RTCPeerConnection";
    const char* const property_name = "generateCertificate";
    ExceptionState exception_state(isolate, exception_context_type, class_like_name, property_name);
    auto&& arg1_keygen_algorithm = NativeValueTraits<V8UnionObjectOrString>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    ScriptPromise<RTCCertificate> return_value = RTCPeerConnection::generateCertificate(script_state, arg1_keygen_algorithm, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value);
}

} // namespace v8_rtc_peer_connection

using namespace v8_rtc_peer_connection;

} // namespace

void V8RTCPeerConnection::InstallInterfaceTemplate(v8::Isolate* isolate, const DOMWrapperWorld& world, v8::Local<v8::Template> interface_template)
{
    const WrapperTypeInfo* const wrapper_type_info = V8RTCPeerConnection::GetWrapperTypeInfo();
    v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
    v8::Local<v8::ObjectTemplate> instance_object_template = interface_function_template->InstanceTemplate();
    v8::Local<v8::ObjectTemplate> prototype_object_template = interface_function_template->PrototypeTemplate();
    v8::Local<v8::FunctionTemplate> parent_interface_template = wrapper_type_info->parent_class->GetV8ClassTemplate(isolate, world).As<v8::FunctionTemplate>();
    bindings::SetupIDLInterfaceTemplate(
        isolate, wrapper_type_info, instance_object_template, prototype_object_template, interface_function_template, parent_interface_template);

    interface_function_template->SetCallHandler(ConstructorCallback);
    interface_function_template->SetLength(0);
    interface_function_template->SetInterfaceName(V8String(isolate, "RTCPeerConnection"));
    interface_function_template->SetExceptionContext(v8::ExceptionContext::kConstructor);

    v8::Local<v8::Template> instance_template = instance_object_template;
    v8::Local<v8::Template> prototype_template = prototype_object_template;
    InstallUnconditionalProperties(isolate, world, instance_template, prototype_template, interface_template);
    InstallContextIndependentProperties(isolate, world, instance_template, prototype_template, interface_template);
}

void V8RTCPeerConnection::InstallUnconditionalProperties(v8::Isolate* isolate, const DOMWrapperWorld& world, v8::Local<v8::Template> instance_template,
    v8::Local<v8::Template> prototype_template, v8::Local<v8::Template> interface_template)
{
    using bindings::IDLMemberInstaller;

    v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
    v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
    {
        static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
            { "localDescription", "RTCPeerConnection", LocalDescriptionAttributeGetCallback, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "currentLocalDescription", "RTCPeerConnection", CurrentLocalDescriptionAttributeGetCallback, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "pendingLocalDescription", "RTCPeerConnection", PendingLocalDescriptionAttributeGetCallback, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "remoteDescription", "RTCPeerConnection", RemoteDescriptionAttributeGetCallback, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "currentRemoteDescription", "RTCPeerConnection", CurrentRemoteDescriptionAttributeGetCallback, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "pendingRemoteDescription", "RTCPeerConnection", PendingRemoteDescriptionAttributeGetCallback, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "signalingState", "RTCPeerConnection", SignalingStateAttributeGetCallback, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "iceGatheringState", "RTCPeerConnection", IceGatheringStateAttributeGetCallback, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "iceConnectionState", "RTCPeerConnection", IceConnectionStateAttributeGetCallback, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "connectionState", "RTCPeerConnection", ConnectionStateAttributeGetCallback, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "canTrickleIceCandidates", "RTCPeerConnection", CanTrickleIceCandidatesAttributeGetCallback, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onnegotiationneeded", "RTCPeerConnection", OnnegotiationneededAttributeGetCallback, OnnegotiationneededAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onicecandidate", "RTCPeerConnection", OnicecandidateAttributeGetCallback, OnicecandidateAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onsignalingstatechange", "RTCPeerConnection", OnsignalingstatechangeAttributeGetCallback, OnsignalingstatechangeAttributeSetCallback,
                unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "oniceconnectionstatechange", "RTCPeerConnection", OniceconnectionstatechangeAttributeGetCallback, OniceconnectionstatechangeAttributeSetCallback,
                unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onconnectionstatechange", "RTCPeerConnection", OnconnectionstatechangeAttributeGetCallback, OnconnectionstatechangeAttributeSetCallback,
                unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onicegatheringstatechange", "RTCPeerConnection", OnicegatheringstatechangeAttributeGetCallback, OnicegatheringstatechangeAttributeSetCallback,
                unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onicecandidateerror", "RTCPeerConnection", OnicecandidateerrorAttributeGetCallback, OnicecandidateerrorAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ontrack", "RTCPeerConnection", OntrackAttributeGetCallback, OntrackAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "sctp", "RTCPeerConnection", SctpAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ondatachannel", "RTCPeerConnection", OndatachannelAttributeGetCallback, OndatachannelAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onaddstream", "RTCPeerConnection", OnaddstreamAttributeGetCallback, OnaddstreamAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onremovestream", "RTCPeerConnection", OnremovestreamAttributeGetCallback, OnremovestreamAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
        };
        IDLMemberInstaller::InstallAttributes(isolate, world, instance_template, prototype_template, interface_template, signature, kAttributeTable);
    }

    {
        static const IDLMemberInstaller::OperationConfig kOperationTable[] = {
            { "addIceCandidate", "RTCPeerConnection", AddIceCandidateOperationCallback, 0, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kDoNotCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "addStream", "RTCPeerConnection", AddStreamOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "addTrack", "RTCPeerConnection", AddTrackOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "addTransceiver", "RTCPeerConnection", AddTransceiverOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "close", "RTCPeerConnection", CloseOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "createAnswer", "RTCPeerConnection", CreateAnswerOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kDoNotCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "createDTMFSender", "RTCPeerConnection", CreateDTMFSenderOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "createDataChannel", "RTCPeerConnection", CreateDataChannelOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "createOffer", "RTCPeerConnection", CreateOfferOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kDoNotCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "getConfiguration", "RTCPeerConnection", GetConfigurationOperationCallback, 0, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "getLocalStreams", "RTCPeerConnection", GetLocalStreamsOperationCallback, 0, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "getReceivers", "RTCPeerConnection", GetReceiversOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "getRemoteStreams", "RTCPeerConnection", GetRemoteStreamsOperationCallback, 0, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "getSenders", "RTCPeerConnection", GetSendersOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "getStats", "RTCPeerConnection", GetStatsOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kDoNotCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "getTransceivers", "RTCPeerConnection", GetTransceiversOperationCallback, 0, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "removeStream", "RTCPeerConnection", RemoveStreamOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "removeTrack", "RTCPeerConnection", RemoveTrackOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "restartIce", "RTCPeerConnection", RestartIceOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "setConfiguration", "RTCPeerConnection", SetConfigurationOperationCallback, 0, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "setLocalDescription", "RTCPeerConnection", SetLocalDescriptionOperationCallback, 0, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kDoNotCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "setRemoteDescription", "RTCPeerConnection", SetRemoteDescriptionOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kDoNotCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "generateCertificate", "RTCPeerConnection", GenerateCertificateStaticOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kInterface), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kDoNotCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kDoNotCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
        };
        IDLMemberInstaller::InstallOperations(isolate, world, instance_template, prototype_template, interface_template, signature, kOperationTable);
    }
}

void V8RTCPeerConnection::InstallContextIndependentProperties(v8::Isolate* isolate, const DOMWrapperWorld& world, v8::Local<v8::Template> instance_template,
    v8::Local<v8::Template> prototype_template, v8::Local<v8::Template> interface_template)
{
    using bindings::IDLMemberInstaller;

    if (RuntimeEnabledFeatures::RTCRtpTransportEnabled()) {
        static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
            { "rtpTransport", "RTCPeerConnection", RtpTransportAttributeGetCallback, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
        };
        v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
        v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
        IDLMemberInstaller::InstallAttributes(isolate, world, instance_template, prototype_template, interface_template, signature, kAttributeTable);
    }
}

} // namespace blink
