// Copyright 2019 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// DO NOT EDIT: This file is auto-generated by
// //third_party/blink/renderer/bindings/scripts/generate_bindings.py
//
// Use the GN flag `blink_enable_generated_code_formatting=true` to enable
// formatting of the generated files.

#include "third_party/blink/renderer/bindings/modules/v8/v8_internals.h"

#include "third_party/blink/public/mojom/origin_trials/origin_trial_feature.mojom-shared.h"
#include "third_party/blink/renderer/bindings/core/v8/generated_code_helper.h"
#include "third_party/blink/renderer/bindings/core/v8/is_return_type_compatible.h"
#include "third_party/blink/renderer/bindings/core/v8/native_value_traits_impl.h"
#include "third_party/blink/renderer/bindings/core/v8/to_v8_traits.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_animation.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_callback_function_test.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_css_style_declaration.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_dictionary_test.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_document.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_dom_point.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_dom_rect.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_dom_rect_list.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_dom_rect_read_only.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_element.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_gc_observation.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_hit_test_layer_rect_list.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_html_canvas_element.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_html_iframe_element.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_html_image_element.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_html_input_element.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_html_media_element.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_html_select_element.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_html_video_element.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_internal_cookie.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_internal_runtime_flags.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_internal_settings.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_internals_ukm_recorder.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_location.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_navigator.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_node.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_node_list.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_origin_trials_test.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_permission_state.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_range.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_readable_stream.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_record_test.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_response.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_sequence_test.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_set_return_value_for_core.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_shadow_root.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_static_selection.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_text.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_type_conversions.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_union_arraybuffer_arraybufferview.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_union_types_test.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_window.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_audio_context.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_canvas_rendering_context_2d.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_create_virtual_pressure_source_options.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_create_virtual_sensor_options.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_device_posture_type.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_dialog_button.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_effective_connection_type.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_media_device_info.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_media_stream_track.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_media_track_constraints.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_offscreen_canvas_rendering_context_2d.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_pressure_source.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_pressure_state.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_rtc_certificate.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_rtc_peer_connection.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_service_worker.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_virtual_sensor_information.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_virtual_sensor_reading.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_virtual_sensor_type.h"
#include "third_party/blink/renderer/core/animation/animation.h"
#include "third_party/blink/renderer/core/css/css_style_declaration.h"
#include "third_party/blink/renderer/core/dom/document.h"
#include "third_party/blink/renderer/core/dom/element.h"
#include "third_party/blink/renderer/core/dom/node.h"
#include "third_party/blink/renderer/core/dom/node_list.h"
#include "third_party/blink/renderer/core/dom/range.h"
#include "third_party/blink/renderer/core/dom/shadow_root.h"
#include "third_party/blink/renderer/core/dom/testing/internals_storage_access.h"
#include "third_party/blink/renderer/core/dom/text.h"
#include "third_party/blink/renderer/core/fetch/response.h"
#include "third_party/blink/renderer/core/fetch/testing/internals_fetch.h"
#include "third_party/blink/renderer/core/frame/dom_window.h"
#include "third_party/blink/renderer/core/frame/location.h"
#include "third_party/blink/renderer/core/frame/navigator.h"
#include "third_party/blink/renderer/core/geometry/dom_point.h"
#include "third_party/blink/renderer/core/geometry/dom_rect.h"
#include "third_party/blink/renderer/core/geometry/dom_rect_list.h"
#include "third_party/blink/renderer/core/geometry/dom_rect_read_only.h"
#include "third_party/blink/renderer/core/html/canvas/html_canvas_element.h"
#include "third_party/blink/renderer/core/html/forms/html_input_element.h"
#include "third_party/blink/renderer/core/html/forms/html_select_element.h"
#include "third_party/blink/renderer/core/html/html_iframe_element.h"
#include "third_party/blink/renderer/core/html/html_image_element.h"
#include "third_party/blink/renderer/core/html/media/html_media_element.h"
#include "third_party/blink/renderer/core/html/media/html_video_element.h"
#include "third_party/blink/renderer/core/streams/readable_stream.h"
#include "third_party/blink/renderer/core/testing/callback_function_test.h"
#include "third_party/blink/renderer/core/testing/dictionary_test.h"
#include "third_party/blink/renderer/core/testing/gc_observation.h"
#include "third_party/blink/renderer/core/testing/hit_test_layer_rect_list.h"
#include "third_party/blink/renderer/core/testing/internal_runtime_flags.h"
#include "third_party/blink/renderer/core/testing/internal_settings.h"
#include "third_party/blink/renderer/core/testing/internals.h"
#include "third_party/blink/renderer/core/testing/internals_delete_all_cookies.h"
#include "third_party/blink/renderer/core/testing/internals_get_all_cookies.h"
#include "third_party/blink/renderer/core/testing/internals_get_named_cookie.h"
#include "third_party/blink/renderer/core/testing/internals_ukm_recorder.h"
#include "third_party/blink/renderer/core/testing/origin_trials_test.h"
#include "third_party/blink/renderer/core/testing/record_test.h"
#include "third_party/blink/renderer/core/testing/sequence_test.h"
#include "third_party/blink/renderer/core/testing/static_selection.h"
#include "third_party/blink/renderer/core/testing/type_conversions.h"
#include "third_party/blink/renderer/core/testing/union_types_test.h"
#include "third_party/blink/renderer/core/timing/internals_profiler.h"
#include "third_party/blink/renderer/modules/accessibility/testing/internals_accessibility.h"
#include "third_party/blink/renderer/modules/canvas/canvas2d/canvas_rendering_context_2d.h"
#include "third_party/blink/renderer/modules/canvas/offscreencanvas2d/offscreen_canvas_rendering_context_2d.h"
#include "third_party/blink/renderer/modules/compute_pressure/testing/internals_compute_pressure.h"
#include "third_party/blink/renderer/modules/credentialmanagement/testing/internals_fed_cm.h"
#include "third_party/blink/renderer/modules/device_posture/testing/internals_device_posture.h"
#include "third_party/blink/renderer/modules/fuzzing/internals_fuzzing.h"
#include "third_party/blink/renderer/modules/mediastream/media_device_info.h"
#include "third_party/blink/renderer/modules/mediastream/media_stream_track.h"
#include "third_party/blink/renderer/modules/mediastream/testing/internals_media_stream.h"
#include "third_party/blink/renderer/modules/netinfo/testing/internals_net_info.h"
#include "third_party/blink/renderer/modules/peerconnection/rtc_certificate.h"
#include "third_party/blink/renderer/modules/peerconnection/rtc_peer_connection.h"
#include "third_party/blink/renderer/modules/peerconnection/testing/internals_rtc_certificate.h"
#include "third_party/blink/renderer/modules/peerconnection/testing/internals_rtc_peer_connection.h"
#include "third_party/blink/renderer/modules/permissions/testing/internals_permission.h"
#include "third_party/blink/renderer/modules/sensor/testing/internals_sensor.h"
#include "third_party/blink/renderer/modules/service_worker/service_worker.h"
#include "third_party/blink/renderer/modules/service_worker/testing/internals_service_worker.h"
#include "third_party/blink/renderer/modules/speech/testing/internals_speech_synthesis.h"
#include "third_party/blink/renderer/modules/vibration/testing/internals_vibration.h"
#include "third_party/blink/renderer/modules/webaudio/audio_context.h"
#include "third_party/blink/renderer/modules/webaudio/testing/internals_web_audio.h"
#include "third_party/blink/renderer/platform/bindings/cooperative_scheduling_helpers.h"
#include "third_party/blink/renderer/platform/bindings/exception_messages.h"
#include "third_party/blink/renderer/platform/bindings/idl_member_installer.h"
#include "third_party/blink/renderer/platform/bindings/runtime_call_stats.h"
#include "third_party/blink/renderer/platform/bindings/v8_binding.h"

namespace blink {

void V8Internals::Impl::Init()
{
    V8Internals::install_interface_template_func_ = InstallInterfaceTemplate;
    V8Internals::install_unconditional_props_func_ = InstallUnconditionalProperties;
    V8Internals::install_context_dependent_props_func_ = InstallContextDependentProperties;
}

namespace {

namespace v8_internals {

void PagePopupWindowAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_pagePopupWindow_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Internals.pagePopupWindow.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->pagePopupWindow();
    static_assert(bindings::IsReturnTypeCompatible<DOMWindow, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver, bindings::V8ReturnValue::kMaybeCrossOrigin);
}

void SettingsAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_settings_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Internals.settings.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->settings();
    static_assert(bindings::IsReturnTypeCompatible<InternalSettings, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void RuntimeFlagsAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_runtimeFlags_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Internals.runtimeFlags.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->runtimeFlags();
    static_assert(bindings::IsReturnTypeCompatible<InternalRuntimeFlags, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void WorkerThreadCountAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_workerThreadCount_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Internals.workerThreadCount.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->workerThreadCount();
    static_assert(bindings::IsReturnTypeCompatible<IDLUnsignedLong, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<uint32_t>());
}

void CursorUpdatePendingAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_cursorUpdatePending_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Internals.cursorUpdatePending.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->cursorUpdatePending();
    static_assert(bindings::IsReturnTypeCompatible<IDLBoolean, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void VisibleSelectionAnchorNodeAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_visibleSelectionAnchorNode_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Internals.visibleSelectionAnchorNode.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->visibleSelectionAnchorNode();
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<Node>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void VisibleSelectionAnchorOffsetAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_visibleSelectionAnchorOffset_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Internals.visibleSelectionAnchorOffset.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->visibleSelectionAnchorOffset();
    static_assert(bindings::IsReturnTypeCompatible<IDLUnsignedLong, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<uint32_t>());
}

void VisibleSelectionFocusNodeAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_visibleSelectionFocusNode_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Internals.visibleSelectionFocusNode.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->visibleSelectionFocusNode();
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<Node>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void VisibleSelectionFocusOffsetAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_visibleSelectionFocusOffset_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Internals.visibleSelectionFocusOffset.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->visibleSelectionFocusOffset();
    static_assert(bindings::IsReturnTypeCompatible<IDLUnsignedLong, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<uint32_t>());
}

void TextAffinityAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_textAffinity_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Internals.textAffinity.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->textAffinity();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void LengthAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_length_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Internals.length.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->length();
    static_assert(bindings::IsReturnTypeCompatible<IDLUnsignedLong, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<uint32_t>());
}

void UnscopableAttributeAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_unscopableAttribute_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Internals.unscopableAttribute.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->unscopableAttribute();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void OverlayScrollbarsEnabledAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_overlayScrollbarsEnabled_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Internals.overlayScrollbarsEnabled.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->overlayScrollbarsEnabled();
    static_assert(bindings::IsReturnTypeCompatible<IDLBoolean, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void PeerConnectionCountLimitAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_peerConnectionCountLimit_Getter");
    BLINK_BINDINGS_TRACE_EVENT("Internals.peerConnectionCountLimit.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = InternalsRTCPeerConnection::peerConnectionCountLimit(*blink_receiver);
    static_assert(bindings::IsReturnTypeCompatible<IDLLong, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<int32_t>());
}

void DisableIntersectionObserverThrottleDelayOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_DisableIntersectionObserverThrottleDelay");
    BLINK_BINDINGS_TRACE_EVENT("Internals.DisableIntersectionObserverThrottleDelay");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->DisableIntersectionObserverThrottleDelay();
}

void LCPPredictionOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_LCPPrediction");
    BLINK_BINDINGS_TRACE_EVENT("Internals.LCPPrediction");
    // Promise returning function: Convert a TypeError to a reject promise.
    ExceptionToRejectPromiseScope reject_promise_scope(info);

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    if (!V8Internals::HasInstance(isolate, v8_receiver)) {
        V8ThrowException::ThrowTypeError(isolate, "Illegal invocation");
        return;
    }

    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    const v8::ExceptionContext exception_context_type = v8::ExceptionContext::kOperation;
    const char* const class_like_name = "Internals";
    const char* const property_name = "LCPPrediction";
    ExceptionState exception_state(isolate, exception_context_type, class_like_name, property_name);
    auto&& arg1_document = NativeValueTraits<Document>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    ScriptPromise<IDLString> return_value = blink_receiver->LCPPrediction(script_state, arg1_document);
    bindings::V8SetReturnValue(info, return_value);
}

void SetSupportsDraggableRegionsOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_SetSupportsDraggableRegions");
    BLINK_BINDINGS_TRACE_EVENT("Internals.SetSupportsDraggableRegions");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_supports_draggable_regionss = NativeValueTraits<IDLBoolean>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->SetSupportsDraggableRegions(arg1_supports_draggable_regionss);
}

void ShadowRootModeOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_ShadowRootMode");
    BLINK_BINDINGS_TRACE_EVENT("Internals.ShadowRootMode");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_root = NativeValueTraits<Node>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->ShadowRootMode(arg1_root, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void AbsoluteCaretBoundsOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_absoluteCaretBounds");
    BLINK_BINDINGS_TRACE_EVENT("Internals.absoluteCaretBounds");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& return_value = blink_receiver->absoluteCaretBounds(exception_state);
    static_assert(bindings::IsReturnTypeCompatible<DOMRectReadOnly, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void ActiveMarkerCountForNodeOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_activeMarkerCountForNode");
    BLINK_BINDINGS_TRACE_EVENT("Internals.activeMarkerCountForNode");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_text = NativeValueTraits<Text>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->activeMarkerCountForNode(arg1_text);
    static_assert(bindings::IsReturnTypeCompatible<IDLUnsignedLong, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<uint32_t>());
}

void AddActiveSuggestionMarkerOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_addActiveSuggestionMarker");
    BLINK_BINDINGS_TRACE_EVENT("Internals.addActiveSuggestionMarker");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 4) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(4, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_range = NativeValueTraits<Range>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_underline_color_value = NativeValueTraits<IDLString>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_thickness_value = NativeValueTraits<IDLString>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg4_background_color_value = NativeValueTraits<IDLString>::ArgumentValue(isolate, 3, info[3], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->addActiveSuggestionMarker(arg1_range, arg2_underline_color_value, arg3_thickness_value, arg4_background_color_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void AddCompositionMarkerOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_addCompositionMarker");
    BLINK_BINDINGS_TRACE_EVENT("Internals.addCompositionMarker");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 6) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(6, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_range = NativeValueTraits<Range>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_underline_color_value = NativeValueTraits<IDLString>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_thickness_value = NativeValueTraits<IDLString>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg4_underline_style_value = NativeValueTraits<IDLString>::ArgumentValue(isolate, 3, info[3], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg5_text_color_value = NativeValueTraits<IDLString>::ArgumentValue(isolate, 4, info[4], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg6_background_color_value = NativeValueTraits<IDLString>::ArgumentValue(isolate, 5, info[5], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->addCompositionMarker(arg1_range, arg2_underline_color_value, arg3_thickness_value, arg4_underline_style_value, arg5_text_color_value,
        arg6_background_color_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void AddEmbedderCustomElementNameOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_addEmbedderCustomElementName");
    BLINK_BINDINGS_TRACE_EVENT("Internals.addEmbedderCustomElementName");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_name = NativeValueTraits<IDLString>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->addEmbedderCustomElementName(arg1_name, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void AddFakeDeviceOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_addFakeDevice");
    BLINK_BINDINGS_TRACE_EVENT("Internals.addFakeDevice");
    // Promise returning function: Convert a TypeError to a reject promise.
    ExceptionToRejectPromiseScope reject_promise_scope(info);

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    if (!V8Internals::HasInstance(isolate, v8_receiver)) {
        V8ThrowException::ThrowTypeError(isolate, "Illegal invocation");
        return;
    }

    if (info.Length() < 3) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(3, info.Length()));
        return;
    }

    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    const v8::ExceptionContext exception_context_type = v8::ExceptionContext::kOperation;
    const char* const class_like_name = "Internals";
    const char* const property_name = "addFakeDevice";
    ExceptionState exception_state(isolate, exception_context_type, class_like_name, property_name);
    auto&& arg1_device_info = NativeValueTraits<MediaDeviceInfo>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_capabilities = NativeValueTraits<MediaTrackConstraints>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_data_source = NativeValueTraits<IDLNullable<MediaStreamTrack>>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    ScriptPromise<IDLUndefined> return_value
        = InternalsMediaStream::addFakeDevice(script_state, *blink_receiver, arg1_device_info, arg2_capabilities, arg3_data_source);
    bindings::V8SetReturnValue(info, return_value);
}

void AddOneToPromiseOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_addOneToPromise");
    BLINK_BINDINGS_TRACE_EVENT("Internals.addOneToPromise");
    // Promise returning function: Convert a TypeError to a reject promise.
    ExceptionToRejectPromiseScope reject_promise_scope(info);

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    if (!V8Internals::HasInstance(isolate, v8_receiver)) {
        V8ThrowException::ThrowTypeError(isolate, "Illegal invocation");
        return;
    }

    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    const v8::ExceptionContext exception_context_type = v8::ExceptionContext::kOperation;
    const char* const class_like_name = "Internals";
    const char* const property_name = "addOneToPromise";
    ExceptionState exception_state(isolate, exception_context_type, class_like_name, property_name);
    auto&& arg1_promise = NativeValueTraits<IDLPromise<IDLLong>>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    ScriptPromise<IDLLong> return_value = blink_receiver->addOneToPromise(script_state, arg1_promise);
    bindings::V8SetReturnValue(info, return_value);
}

void AddSuggestionMarkerOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_addSuggestionMarker");
    BLINK_BINDINGS_TRACE_EVENT("Internals.addSuggestionMarker");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 6) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(6, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_range = NativeValueTraits<Range>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_suggestions = NativeValueTraits<IDLSequence<IDLString>>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_suggestion_highlight_color_value = NativeValueTraits<IDLString>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg4_underline_color_value = NativeValueTraits<IDLString>::ArgumentValue(isolate, 3, info[3], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg5_thickness_value = NativeValueTraits<IDLString>::ArgumentValue(isolate, 4, info[4], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg6_background_color_value = NativeValueTraits<IDLString>::ArgumentValue(isolate, 5, info[5], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->addSuggestionMarker(arg1_range, std::move(arg2_suggestions), arg3_suggestion_highlight_color_value, arg4_underline_color_value,
        arg5_thickness_value, arg6_background_color_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void AddTextMatchMarkerOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_addTextMatchMarker");
    BLINK_BINDINGS_TRACE_EVENT("Internals.addTextMatchMarker");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_range = NativeValueTraits<Range>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_match_status = NativeValueTraits<IDLString>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->addTextMatchMarker(arg1_range, arg2_match_status, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void AdvanceImageAnimationOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_advanceImageAnimation");
    BLINK_BINDINGS_TRACE_EVENT("Internals.advanceImageAnimation");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_image = NativeValueTraits<Element>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->advanceImageAnimation(arg1_image, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void AllIconURLsOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_allIconURLs");
    BLINK_BINDINGS_TRACE_EVENT("Internals.allIconURLs");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_document = NativeValueTraits<Document>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->allIconURLs(arg1_document);
    static_assert(bindings::IsReturnTypeCompatible<IDLSequence<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    v8::Local<v8::Value> v8_return_value = ToV8Traits<IDLSequence<IDLString>>::ToV8(script_state, return_value);
    bindings::V8SetReturnValue(info, v8_return_value);
}

void AudioHandlerCountOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_audioHandlerCount");
    BLINK_BINDINGS_TRACE_EVENT("Internals.audioHandlerCount");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = InternalsWebAudio::audioHandlerCount(*blink_receiver);
    static_assert(bindings::IsReturnTypeCompatible<IDLUnsignedLong, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<uint32_t>());
}

void AudioWorkletProcessorCountOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_audioWorkletProcessorCount");
    BLINK_BINDINGS_TRACE_EVENT("Internals.audioWorkletProcessorCount");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = InternalsWebAudio::audioWorkletProcessorCount(*blink_receiver);
    static_assert(bindings::IsReturnTypeCompatible<IDLUnsignedLong, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<uint32_t>());
}

void BoundingBoxOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_boundingBox");
    BLINK_BINDINGS_TRACE_EVENT("Internals.boundingBox");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_element = NativeValueTraits<Element>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->boundingBox(arg1_element);
    static_assert(bindings::IsReturnTypeCompatible<DOMRectReadOnly, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void CallbackFunctionTestOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_callbackFunctionTest");
    BLINK_BINDINGS_TRACE_EVENT("Internals.callbackFunctionTest");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->callbackFunctionTest();
    static_assert(bindings::IsReturnTypeCompatible<CallbackFunctionTest, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void CanHyphenateOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_canHyphenate");
    BLINK_BINDINGS_TRACE_EVENT("Internals.canHyphenate");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    decltype(NativeValueTraits<IDLString>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg1_locale;
    if (info[0]->IsString()) [[likely]] {
        arg1_locale.Init(isolate, info[0].As<v8::String>());
    } else {
        ExceptionState exception_state(isolate);
        arg1_locale = NativeValueTraits<IDLString>::ArgumentValue(isolate, 0, info[0], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->canHyphenate(arg1_locale);
    static_assert(bindings::IsReturnTypeCompatible<IDLBoolean, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void CancelCurrentSpellCheckRequestOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_cancelCurrentSpellCheckRequest");
    BLINK_BINDINGS_TRACE_EVENT("Internals.cancelCurrentSpellCheckRequest");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_document = NativeValueTraits<Document>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->cancelCurrentSpellCheckRequest(arg1_document, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void CanvasFontCacheMaxFontsOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_canvasFontCacheMaxFonts");
    BLINK_BINDINGS_TRACE_EVENT("Internals.canvasFontCacheMaxFonts");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->canvasFontCacheMaxFonts();
    static_assert(bindings::IsReturnTypeCompatible<IDLUnsignedLong, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<uint32_t>());
}

void ClearDevicePostureOverrideOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_clearDevicePostureOverride");
    BLINK_BINDINGS_TRACE_EVENT("Internals.clearDevicePostureOverride");
    // Promise returning function: Convert a TypeError to a reject promise.
    ExceptionToRejectPromiseScope reject_promise_scope(info);

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    if (!V8Internals::HasInstance(isolate, v8_receiver)) {
        V8ThrowException::ThrowTypeError(isolate, "Illegal invocation");
        return;
    }

    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptPromise<IDLUndefined> return_value = InternalsDevicePosture::clearDevicePostureOverride(script_state, *blink_receiver);
    bindings::V8SetReturnValue(info, return_value);
}

void ClearHitTestCacheOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_clearHitTestCache");
    BLINK_BINDINGS_TRACE_EVENT("Internals.clearHitTestCache");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_document = NativeValueTraits<Document>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->clearHitTestCache(arg1_document, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void ClearNetworkConnectionInfoOverrideOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_clearNetworkConnectionInfoOverride");
    BLINK_BINDINGS_TRACE_EVENT("Internals.clearNetworkConnectionInfoOverride");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    InternalsNetInfo::clearNetworkConnectionInfoOverride(*blink_receiver);
}

void ClearUseCounterOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_clearUseCounter");
    BLINK_BINDINGS_TRACE_EVENT("Internals.clearUseCounter");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_document = NativeValueTraits<Document>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_feature = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->clearUseCounter(arg1_document, arg2_feature);
}

void ClickFedCmDialogButtonOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_clickFedCmDialogButton");
    BLINK_BINDINGS_TRACE_EVENT("Internals.clickFedCmDialogButton");
    // Promise returning function: Convert a TypeError to a reject promise.
    ExceptionToRejectPromiseScope reject_promise_scope(info);

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    if (!V8Internals::HasInstance(isolate, v8_receiver)) {
        V8ThrowException::ThrowTypeError(isolate, "Illegal invocation");
        return;
    }

    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    const v8::ExceptionContext exception_context_type = v8::ExceptionContext::kOperation;
    const char* const class_like_name = "Internals";
    const char* const property_name = "clickFedCmDialogButton";
    ExceptionState exception_state(isolate, exception_context_type, class_like_name, property_name);
    auto&& arg1_dialog_button = NativeValueTraits<V8DialogButton>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    ScriptPromise<IDLUndefined> return_value = InternalsFedCm::clickFedCmDialogButton(script_state, *blink_receiver, arg1_dialog_button);
    bindings::V8SetReturnValue(info, return_value);
}

void CollectSampleOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_collectSample");
    BLINK_BINDINGS_TRACE_EVENT("Internals.collectSample");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    InternalsProfiler::collectSample(script_state, *blink_receiver);
}

void CompareTreeScopePositionOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_compareTreeScopePosition");
    BLINK_BINDINGS_TRACE_EVENT("Internals.compareTreeScopePosition");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_tree_scope_1 = NativeValueTraits<Node>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_tree_scope_2 = NativeValueTraits<Node>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->compareTreeScopePosition(arg1_tree_scope_1, arg2_tree_scope_2, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<IDLUnsignedShort, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<uint16_t>());
}

void ComputedStyleIncludingVisitedInfoOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_computedStyleIncludingVisitedInfo");
    BLINK_BINDINGS_TRACE_EVENT("Internals.computedStyleIncludingVisitedInfo");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_element = NativeValueTraits<Element>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->computedStyleIncludingVisitedInfo(arg1_element);
    static_assert(bindings::IsReturnTypeCompatible<CSSStyleDeclaration, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void CountElementShadowOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_countElementShadow");
    BLINK_BINDINGS_TRACE_EVENT("Internals.countElementShadow");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_root = NativeValueTraits<Node>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->countElementShadow(arg1_root, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<IDLUnsignedLong, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<uint32_t>());
}

void CounterValueOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_counterValue");
    BLINK_BINDINGS_TRACE_EVENT("Internals.counterValue");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_element = NativeValueTraits<Element>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->counterValue(arg1_element);
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void CrashOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_crash");
    BLINK_BINDINGS_TRACE_EVENT("Internals.crash");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->crash();
}

void CreateReadableStreamOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_createReadableStream");
    BLINK_BINDINGS_TRACE_EVENT("Internals.createReadableStream");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    ExceptionState exception_state(isolate);
    auto&& arg1_queue_size = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_optimizer = NativeValueTraits<IDLString>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->createReadableStream(script_state, arg1_queue_size, arg2_optimizer, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<ReadableStream, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void CreateRejectedPromiseOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_createRejectedPromise");
    BLINK_BINDINGS_TRACE_EVENT("Internals.createRejectedPromise");
    // Promise returning function: Convert a TypeError to a reject promise.
    ExceptionToRejectPromiseScope reject_promise_scope(info);

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    if (!V8Internals::HasInstance(isolate, v8_receiver)) {
        V8ThrowException::ThrowTypeError(isolate, "Illegal invocation");
        return;
    }

    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    const v8::ExceptionContext exception_context_type = v8::ExceptionContext::kOperation;
    const char* const class_like_name = "Internals";
    const char* const property_name = "createRejectedPromise";
    ExceptionState exception_state(isolate, exception_context_type, class_like_name, property_name);
    auto&& arg1_reason = NativeValueTraits<IDLAny>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    ScriptPromise<IDLAny> return_value = blink_receiver->createRejectedPromise(script_state, arg1_reason);
    bindings::V8SetReturnValue(info, return_value);
}

void CreateResolvedPromiseOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_createResolvedPromise");
    BLINK_BINDINGS_TRACE_EVENT("Internals.createResolvedPromise");
    // Promise returning function: Convert a TypeError to a reject promise.
    ExceptionToRejectPromiseScope reject_promise_scope(info);

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    if (!V8Internals::HasInstance(isolate, v8_receiver)) {
        V8ThrowException::ThrowTypeError(isolate, "Illegal invocation");
        return;
    }

    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    const v8::ExceptionContext exception_context_type = v8::ExceptionContext::kOperation;
    const char* const class_like_name = "Internals";
    const char* const property_name = "createResolvedPromise";
    ExceptionState exception_state(isolate, exception_context_type, class_like_name, property_name);
    auto&& arg1_value = NativeValueTraits<IDLAny>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    ScriptPromise<IDLAny> return_value = blink_receiver->createResolvedPromise(script_state, arg1_value);
    bindings::V8SetReturnValue(info, return_value);
}

void CreateUserAgentShadowRootOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_createUserAgentShadowRoot");
    BLINK_BINDINGS_TRACE_EVENT("Internals.createUserAgentShadowRoot");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_host = NativeValueTraits<Element>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->createUserAgentShadowRoot(arg1_host);
    static_assert(bindings::IsReturnTypeCompatible<ShadowRoot, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void CreateVirtualPressureSourceOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_createVirtualPressureSource");
    BLINK_BINDINGS_TRACE_EVENT("Internals.createVirtualPressureSource");
    // Promise returning function: Convert a TypeError to a reject promise.
    ExceptionToRejectPromiseScope reject_promise_scope(info);

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    if (!V8Internals::HasInstance(isolate, v8_receiver)) {
        V8ThrowException::ThrowTypeError(isolate, "Illegal invocation");
        return;
    }

    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    const v8::ExceptionContext exception_context_type = v8::ExceptionContext::kOperation;
    const char* const class_like_name = "Internals";
    const char* const property_name = "createVirtualPressureSource";
    ExceptionState exception_state(isolate, exception_context_type, class_like_name, property_name);
    auto&& arg1_source = NativeValueTraits<V8PressureSource>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_options = NativeValueTraits<CreateVirtualPressureSourceOptions>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    ScriptPromise<IDLUndefined> return_value = InternalsComputePressure::createVirtualPressureSource(script_state, *blink_receiver, arg1_source, arg2_options);
    bindings::V8SetReturnValue(info, return_value);
}

void CreateVirtualSensorOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_createVirtualSensor");
    BLINK_BINDINGS_TRACE_EVENT("Internals.createVirtualSensor");
    // Promise returning function: Convert a TypeError to a reject promise.
    ExceptionToRejectPromiseScope reject_promise_scope(info);

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    if (!V8Internals::HasInstance(isolate, v8_receiver)) {
        V8ThrowException::ThrowTypeError(isolate, "Illegal invocation");
        return;
    }

    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    const v8::ExceptionContext exception_context_type = v8::ExceptionContext::kOperation;
    const char* const class_like_name = "Internals";
    const char* const property_name = "createVirtualSensor";
    ExceptionState exception_state(isolate, exception_context_type, class_like_name, property_name);
    auto&& arg1_type = NativeValueTraits<V8VirtualSensorType>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_options = NativeValueTraits<CreateVirtualSensorOptions>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    ScriptPromise<IDLUndefined> return_value = InternalsSensor::createVirtualSensor(script_state, *blink_receiver, arg1_type, arg2_options);
    bindings::V8SetReturnValue(info, return_value);
}

void CreateWritableStreamAndSinkOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_createWritableStreamAndSink");
    BLINK_BINDINGS_TRACE_EVENT("Internals.createWritableStreamAndSink");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    ExceptionState exception_state(isolate);
    auto&& arg1_queue_size = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_optimizer = NativeValueTraits<IDLString>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->createWritableStreamAndSink(script_state, arg1_queue_size, arg2_optimizer, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<IDLAny, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value);
}

void CurrentTimeTicksOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_currentTimeTicks");
    BLINK_BINDINGS_TRACE_EVENT("Internals.currentTimeTicks");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->currentTimeTicks();
    static_assert(bindings::IsReturnTypeCompatible<IDLLongLong, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<int64_t>());
}

void DeleteAllCookiesOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_deleteAllCookies");
    BLINK_BINDINGS_TRACE_EVENT("Internals.deleteAllCookies");
    // Promise returning function: Convert a TypeError to a reject promise.
    ExceptionToRejectPromiseScope reject_promise_scope(info);

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    if (!V8Internals::HasInstance(isolate, v8_receiver)) {
        V8ThrowException::ThrowTypeError(isolate, "Illegal invocation");
        return;
    }

    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptPromise<IDLUndefined> return_value = InternalsDeleteAllCookies::deleteAllCookies(script_state, *blink_receiver);
    bindings::V8SetReturnValue(info, return_value);
}

void DeserializeBufferOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_deserializeBuffer");
    BLINK_BINDINGS_TRACE_EVENT("Internals.deserializeBuffer");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_buffer = NativeValueTraits<DOMArrayBuffer>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->deserializeBuffer(isolate, arg1_buffer);
    static_assert(bindings::IsReturnTypeCompatible<IDLAny, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value);
}

void DictionaryTestOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_dictionaryTest");
    BLINK_BINDINGS_TRACE_EVENT("Internals.dictionaryTest");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->dictionaryTest();
    static_assert(bindings::IsReturnTypeCompatible<DictionaryTest, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void DisableCanvasAccelerationOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_disableCanvasAcceleration");
    BLINK_BINDINGS_TRACE_EVENT("Internals.disableCanvasAcceleration");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_canvas = NativeValueTraits<HTMLCanvasElement>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->disableCanvasAcceleration(arg1_canvas);
}

void DisableCompositedAnimationOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_disableCompositedAnimation");
    BLINK_BINDINGS_TRACE_EVENT("Internals.disableCompositedAnimation");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_animation = NativeValueTraits<Animation>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->disableCompositedAnimation(arg1_animation);
}

void DisableReferencedFilePathsVerificationOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_disableReferencedFilePathsVerification");
    BLINK_BINDINGS_TRACE_EVENT("Internals.disableReferencedFilePathsVerification");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->disableReferencedFilePathsVerification();
}

void DismissFedCmDialogOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_dismissFedCmDialog");
    BLINK_BINDINGS_TRACE_EVENT("Internals.dismissFedCmDialog");
    // Promise returning function: Convert a TypeError to a reject promise.
    ExceptionToRejectPromiseScope reject_promise_scope(info);

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    if (!V8Internals::HasInstance(isolate, v8_receiver)) {
        V8ThrowException::ThrowTypeError(isolate, "Illegal invocation");
        return;
    }

    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptPromise<IDLUndefined> return_value = InternalsFedCm::dismissFedCmDialog(script_state, *blink_receiver);
    bindings::V8SetReturnValue(info, return_value);
}

void DoesWindowHaveUrlFragmentOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_doesWindowHaveUrlFragment");
    BLINK_BINDINGS_TRACE_EVENT("Internals.doesWindowHaveUrlFragment");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_window = NativeValueTraits<DOMWindow>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->doesWindowHaveUrlFragment(arg1_window);
    static_assert(bindings::IsReturnTypeCompatible<IDLBoolean, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void DraggableRegionsOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_draggableRegions");
    BLINK_BINDINGS_TRACE_EVENT("Internals.draggableRegions");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_document = NativeValueTraits<Document>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->draggableRegions(arg1_document, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<DOMRectList, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void EffectivePreloadOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_effectivePreload");
    BLINK_BINDINGS_TRACE_EVENT("Internals.effectivePreload");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_media_element = NativeValueTraits<HTMLMediaElement>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->effectivePreload(arg1_media_element);
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void EffectiveRootScrollerOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_effectiveRootScroller");
    BLINK_BINDINGS_TRACE_EVENT("Internals.effectiveRootScroller");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_document = NativeValueTraits<Document>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->effectiveRootScroller(arg1_document);
    static_assert(bindings::IsReturnTypeCompatible<Node, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void ElementFromPointOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_elementFromPoint");
    BLINK_BINDINGS_TRACE_EVENT("Internals.elementFromPoint");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 5) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(5, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_document = NativeValueTraits<Document>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_x = NativeValueTraits<IDLDouble>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_y = NativeValueTraits<IDLDouble>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg4_ignore_clipping = NativeValueTraits<IDLBoolean>::ArgumentValue(isolate, 3, info[3], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg5_allow_child_frame_content = NativeValueTraits<IDLBoolean>::ArgumentValue(isolate, 4, info[4], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value
        = blink_receiver->elementFromPoint(arg1_document, arg2_x, arg3_y, arg4_ignore_clipping, arg5_allow_child_frame_content, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<Element>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void ElementLayoutTreeAsTextOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_elementLayoutTreeAsText");
    BLINK_BINDINGS_TRACE_EVENT("Internals.elementLayoutTreeAsText");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_element = NativeValueTraits<Element>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->elementLayoutTreeAsText(arg1_element, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void ElementShouldAutoCompleteOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_elementShouldAutoComplete");
    BLINK_BINDINGS_TRACE_EVENT("Internals.elementShouldAutoComplete");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_input_element = NativeValueTraits<Element>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->elementShouldAutoComplete(arg1_input_element, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<IDLBoolean, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void EmulateDeviceFailureOnAudioContextOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_emulateDeviceFailureOnAudioContext");
    BLINK_BINDINGS_TRACE_EVENT("Internals.emulateDeviceFailureOnAudioContext");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_context = NativeValueTraits<AudioContext>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    InternalsWebAudio::emulateDeviceFailureOnAudioContext(*blink_receiver, arg1_context);
}

void EnableMockSpeechSynthesizerOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_enableMockSpeechSynthesizer");
    BLINK_BINDINGS_TRACE_EVENT("Internals.enableMockSpeechSynthesizer");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_window = NativeValueTraits<DOMWindow>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    InternalsSpeechSynthesis::enableMockSpeechSynthesizer(*blink_receiver, arg1_window);
}

void EndColorChooserOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_endColorChooser");
    BLINK_BINDINGS_TRACE_EVENT("Internals.endColorChooser");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_element = NativeValueTraits<Element>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->endColorChooser(arg1_element);
}

void EvaluateInInspectorOverlayOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_evaluateInInspectorOverlay");
    BLINK_BINDINGS_TRACE_EVENT("Internals.evaluateInInspectorOverlay");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    decltype(NativeValueTraits<IDLString>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg1_script;
    if (info[0]->IsString()) [[likely]] {
        arg1_script.Init(isolate, info[0].As<v8::String>());
    } else {
        ExceptionState exception_state(isolate);
        arg1_script = NativeValueTraits<IDLString>::ArgumentValue(isolate, 0, info[0], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->evaluateInInspectorOverlay(arg1_script);
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void EvictAllResourcesOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_evictAllResources");
    BLINK_BINDINGS_TRACE_EVENT("Internals.evictAllResources");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->evictAllResources();
}

void ExecuteCommandOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_executeCommand");
    BLINK_BINDINGS_TRACE_EVENT("Internals.executeCommand");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 3) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(3, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_document = NativeValueTraits<Document>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_name = NativeValueTraits<IDLString>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_value = NativeValueTraits<IDLString>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->executeCommand(arg1_document, arg2_name, arg3_value, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<IDLBoolean, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void ExemptUrlFromNetworkRevocationOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_exemptUrlFromNetworkRevocation");
    BLINK_BINDINGS_TRACE_EVENT("Internals.exemptUrlFromNetworkRevocation");
    // Promise returning function: Convert a TypeError to a reject promise.
    ExceptionToRejectPromiseScope reject_promise_scope(info);

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    if (!V8Internals::HasInstance(isolate, v8_receiver)) {
        V8ThrowException::ThrowTypeError(isolate, "Illegal invocation");
        return;
    }

    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    const v8::ExceptionContext exception_context_type = v8::ExceptionContext::kOperation;
    const char* const class_like_name = "Internals";
    const char* const property_name = "exemptUrlFromNetworkRevocation";
    ExceptionState exception_state(isolate, exception_context_type, class_like_name, property_name);
    auto&& arg1_url = NativeValueTraits<IDLUSVString>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    ScriptPromise<IDLUndefined> return_value = blink_receiver->exemptUrlFromNetworkRevocation(script_state, arg1_url);
    bindings::V8SetReturnValue(info, return_value);
}

void FakeCaptureConfigurationChangedOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_fakeCaptureConfigurationChanged");
    BLINK_BINDINGS_TRACE_EVENT("Internals.fakeCaptureConfigurationChanged");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_track = NativeValueTraits<IDLNullable<MediaStreamTrack>>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    InternalsMediaStream::fakeCaptureConfigurationChanged(*blink_receiver, arg1_track);
}

void FirstChildInFlatTreeOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_firstChildInFlatTree");
    BLINK_BINDINGS_TRACE_EVENT("Internals.firstChildInFlatTree");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_node = NativeValueTraits<Node>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->firstChildInFlatTree(arg1_node, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<Node, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void ForceCompositingUpdateOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_forceCompositingUpdate");
    BLINK_BINDINGS_TRACE_EVENT("Internals.forceCompositingUpdate");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_document = NativeValueTraits<Document>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->forceCompositingUpdate(arg1_document, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void ForceFullRepaintOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_forceFullRepaint");
    BLINK_BINDINGS_TRACE_EVENT("Internals.forceFullRepaint");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_document = NativeValueTraits<Document>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->forceFullRepaint(arg1_document, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void ForceImageReloadOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_forceImageReload");
    BLINK_BINDINGS_TRACE_EVENT("Internals.forceImageReload");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_element = NativeValueTraits<Element>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->forceImageReload(arg1_element, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void ForceLoseCanvasContextOperationOverload1(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_ctx = NativeValueTraits<CanvasRenderingContext2D>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->forceLoseCanvasContext(arg1_ctx);
}

void ForceLoseCanvasContextOperationOverload2(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_ctx = NativeValueTraits<OffscreenCanvasRenderingContext2D>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->forceLoseCanvasContext(arg1_ctx);
}

void ForceLoseCanvasContextOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_forceLoseCanvasContext");
    BLINK_BINDINGS_TRACE_EVENT("Internals.forceLoseCanvasContext");

    BINDINGS_COOPERATIVE_SCHEDULING_SAFEPOINT();

    const int arg_count = std::min(info.Length(), 1);
    v8::Isolate* isolate = info.GetIsolate();
    do { // Dummy loop for use of 'break'.
        if (arg_count == 1) {
            if (info[0]->IsObject()) {
                if (V8OffscreenCanvasRenderingContext2D::HasInstance(isolate, info[0])) {
                    return ForceLoseCanvasContextOperationOverload2(info);
                }
                if (V8CanvasRenderingContext2D::HasInstance(isolate, info[0])) {
                    return ForceLoseCanvasContextOperationOverload1(info);
                }
            }
            break;
        }
    } while (false);

    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }
    V8ThrowException::ThrowTypeError(isolate, "Overload resolution failed.");
    return;
}

void ForceReloadOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_forceReload");
    BLINK_BINDINGS_TRACE_EVENT("Internals.forceReload");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_end_to_end = NativeValueTraits<IDLBoolean>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->forceReload(arg1_end_to_end);
}

void ForceStaleStateForMediaElementOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_forceStaleStateForMediaElement");
    BLINK_BINDINGS_TRACE_EVENT("Internals.forceStaleStateForMediaElement");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_media_element = NativeValueTraits<HTMLMediaElement>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_state = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->forceStaleStateForMediaElement(arg1_media_element, arg2_state);
}

void FormControlStateOfHistoryItemOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_formControlStateOfHistoryItem");
    BLINK_BINDINGS_TRACE_EVENT("Internals.formControlStateOfHistoryItem");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& return_value = blink_receiver->formControlStateOfHistoryItem(exception_state);
    static_assert(bindings::IsReturnTypeCompatible<IDLSequence<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    v8::Local<v8::Value> v8_return_value = ToV8Traits<IDLSequence<IDLString>>::ToV8(script_state, return_value);
    bindings::V8SetReturnValue(info, v8_return_value);
}

void GenerateTestReportOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_generateTestReport");
    BLINK_BINDINGS_TRACE_EVENT("Internals.generateTestReport");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    decltype(NativeValueTraits<IDLString>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg1_message;
    if (info[0]->IsString()) [[likely]] {
        arg1_message.Init(isolate, info[0].As<v8::String>());
    } else {
        ExceptionState exception_state(isolate);
        arg1_message = NativeValueTraits<IDLString>::ArgumentValue(isolate, 0, info[0], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    blink_receiver->generateTestReport(arg1_message);
}

void GetAgentIdOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_getAgentId");
    BLINK_BINDINGS_TRACE_EVENT("Internals.getAgentId");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_window = NativeValueTraits<DOMWindow>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->getAgentId(arg1_window);
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void GetAllCookiesOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_getAllCookies");
    BLINK_BINDINGS_TRACE_EVENT("Internals.getAllCookies");
    // Promise returning function: Convert a TypeError to a reject promise.
    ExceptionToRejectPromiseScope reject_promise_scope(info);

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    if (!V8Internals::HasInstance(isolate, v8_receiver)) {
        V8ThrowException::ThrowTypeError(isolate, "Illegal invocation");
        return;
    }

    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptPromise<IDLSequence<InternalCookie>> return_value = InternalsGetAllCookies::getAllCookies(script_state, *blink_receiver);
    bindings::V8SetReturnValue(info, return_value);
}

void GetCSSPropertyAliasesOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_getCSSPropertyAliases");
    BLINK_BINDINGS_TRACE_EVENT("Internals.getCSSPropertyAliases");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->getCSSPropertyAliases();
    static_assert(bindings::IsReturnTypeCompatible<IDLSequence<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    v8::Local<v8::Value> v8_return_value = ToV8Traits<IDLSequence<IDLString>>::ToV8(script_state, return_value);
    bindings::V8SetReturnValue(info, v8_return_value);
}

void GetCSSPropertyLonghandsOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_getCSSPropertyLonghands");
    BLINK_BINDINGS_TRACE_EVENT("Internals.getCSSPropertyLonghands");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->getCSSPropertyLonghands();
    static_assert(bindings::IsReturnTypeCompatible<IDLSequence<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    v8::Local<v8::Value> v8_return_value = ToV8Traits<IDLSequence<IDLString>>::ToV8(script_state, return_value);
    bindings::V8SetReturnValue(info, v8_return_value);
}

void GetCSSPropertyShorthandsOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_getCSSPropertyShorthands");
    BLINK_BINDINGS_TRACE_EVENT("Internals.getCSSPropertyShorthands");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->getCSSPropertyShorthands();
    static_assert(bindings::IsReturnTypeCompatible<IDLSequence<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    v8::Local<v8::Value> v8_return_value = ToV8Traits<IDLSequence<IDLString>>::ToV8(script_state, return_value);
    bindings::V8SetReturnValue(info, v8_return_value);
}

void GetComputedLabelOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_getComputedLabel");
    BLINK_BINDINGS_TRACE_EVENT("Internals.getComputedLabel");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_element = NativeValueTraits<Element>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = InternalsAccessibility::getComputedLabel(*blink_receiver, arg1_element);
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void GetComputedRoleOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_getComputedRole");
    BLINK_BINDINGS_TRACE_EVENT("Internals.getComputedRole");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_element = NativeValueTraits<Element>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = InternalsAccessibility::getComputedRole(*blink_receiver, arg1_element);
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void GetCreatorScriptsOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_getCreatorScripts");
    BLINK_BINDINGS_TRACE_EVENT("Internals.getCreatorScripts");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_img = NativeValueTraits<HTMLImageElement>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->getCreatorScripts(arg1_img);
    static_assert(bindings::IsReturnTypeCompatible<IDLSequence<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    v8::Local<v8::Value> v8_return_value = ToV8Traits<IDLSequence<IDLString>>::ToV8(script_state, return_value);
    bindings::V8SetReturnValue(info, v8_return_value);
}

void GetCurrentCursorInfoOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_getCurrentCursorInfo");
    BLINK_BINDINGS_TRACE_EVENT("Internals.getCurrentCursorInfo");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->getCurrentCursorInfo();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void GetDragCaretOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_getDragCaret");
    BLINK_BINDINGS_TRACE_EVENT("Internals.getDragCaret");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->getDragCaret();
    static_assert(bindings::IsReturnTypeCompatible<StaticSelection, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void GetFedCmDialogTypeOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_getFedCmDialogType");
    BLINK_BINDINGS_TRACE_EVENT("Internals.getFedCmDialogType");
    // Promise returning function: Convert a TypeError to a reject promise.
    ExceptionToRejectPromiseScope reject_promise_scope(info);

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    if (!V8Internals::HasInstance(isolate, v8_receiver)) {
        V8ThrowException::ThrowTypeError(isolate, "Illegal invocation");
        return;
    }

    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptPromise<IDLString> return_value = InternalsFedCm::getFedCmDialogType(script_state, *blink_receiver);
    bindings::V8SetReturnValue(info, return_value);
}

void GetFedCmTitleOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_getFedCmTitle");
    BLINK_BINDINGS_TRACE_EVENT("Internals.getFedCmTitle");
    // Promise returning function: Convert a TypeError to a reject promise.
    ExceptionToRejectPromiseScope reject_promise_scope(info);

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    if (!V8Internals::HasInstance(isolate, v8_receiver)) {
        V8ThrowException::ThrowTypeError(isolate, "Illegal invocation");
        return;
    }

    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptPromise<IDLString> return_value = InternalsFedCm::getFedCmTitle(script_state, *blink_receiver);
    bindings::V8SetReturnValue(info, return_value);
}

void GetImageSourceURLOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_getImageSourceURL");
    BLINK_BINDINGS_TRACE_EVENT("Internals.getImageSourceURL");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_element = NativeValueTraits<Element>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->getImageSourceURL(arg1_element);
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void GetInitialResourcePriorityOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_getInitialResourcePriority");
    BLINK_BINDINGS_TRACE_EVENT("Internals.getInitialResourcePriority");
    // Promise returning function: Convert a TypeError to a reject promise.
    ExceptionToRejectPromiseScope reject_promise_scope(info);

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    if (!V8Internals::HasInstance(isolate, v8_receiver)) {
        V8ThrowException::ThrowTypeError(isolate, "Illegal invocation");
        return;
    }

    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    const v8::ExceptionContext exception_context_type = v8::ExceptionContext::kOperation;
    const char* const class_like_name = "Internals";
    const char* const property_name = "getInitialResourcePriority";
    ExceptionState exception_state(isolate, exception_context_type, class_like_name, property_name);
    auto&& arg1_url = NativeValueTraits<IDLString>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_document = NativeValueTraits<Document>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    ScriptPromise<IDLLong> return_value = blink_receiver->getInitialResourcePriority(script_state, arg1_url, arg2_document);
    bindings::V8SetReturnValue(info, return_value);
}

void GetInitialResourcePriorityOfNewLoadOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_getInitialResourcePriorityOfNewLoad");
    BLINK_BINDINGS_TRACE_EVENT("Internals.getInitialResourcePriorityOfNewLoad");
    // Promise returning function: Convert a TypeError to a reject promise.
    ExceptionToRejectPromiseScope reject_promise_scope(info);

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    if (!V8Internals::HasInstance(isolate, v8_receiver)) {
        V8ThrowException::ThrowTypeError(isolate, "Illegal invocation");
        return;
    }

    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    const v8::ExceptionContext exception_context_type = v8::ExceptionContext::kOperation;
    const char* const class_like_name = "Internals";
    const char* const property_name = "getInitialResourcePriorityOfNewLoad";
    ExceptionState exception_state(isolate, exception_context_type, class_like_name, property_name);
    auto&& arg1_url = NativeValueTraits<IDLString>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_document = NativeValueTraits<Document>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    ScriptPromise<IDLLong> return_value = blink_receiver->getInitialResourcePriorityOfNewLoad(script_state, arg1_url, arg2_document);
    bindings::V8SetReturnValue(info, return_value);
}

void GetInternalResponseURLListOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_getInternalResponseURLList");
    BLINK_BINDINGS_TRACE_EVENT("Internals.getInternalResponseURLList");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_response = NativeValueTraits<Response>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = InternalsFetch::getInternalResponseURLList(*blink_receiver, arg1_response);
    static_assert(bindings::IsReturnTypeCompatible<IDLSequence<IDLUSVString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    v8::Local<v8::Value> v8_return_value = ToV8Traits<IDLSequence<IDLUSVString>>::ToV8(script_state, return_value);
    bindings::V8SetReturnValue(info, v8_return_value);
}

void GetNamedCookieOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_getNamedCookie");
    BLINK_BINDINGS_TRACE_EVENT("Internals.getNamedCookie");
    // Promise returning function: Convert a TypeError to a reject promise.
    ExceptionToRejectPromiseScope reject_promise_scope(info);

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    if (!V8Internals::HasInstance(isolate, v8_receiver)) {
        V8ThrowException::ThrowTypeError(isolate, "Illegal invocation");
        return;
    }

    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    const v8::ExceptionContext exception_context_type = v8::ExceptionContext::kOperation;
    const char* const class_like_name = "Internals";
    const char* const property_name = "getNamedCookie";
    ExceptionState exception_state(isolate, exception_context_type, class_like_name, property_name);
    auto&& arg1_name = NativeValueTraits<IDLString>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    ScriptPromise<IDLNullable<InternalCookie>> return_value = InternalsGetNamedCookie::getNamedCookie(script_state, *blink_receiver, arg1_name);
    bindings::V8SetReturnValue(info, return_value);
}

void GetParsedImportMapOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_getParsedImportMap");
    BLINK_BINDINGS_TRACE_EVENT("Internals.getParsedImportMap");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_document = NativeValueTraits<Document>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->getParsedImportMap(arg1_document, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void GetProgrammaticScrollAnimationStateOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_getProgrammaticScrollAnimationState");
    BLINK_BINDINGS_TRACE_EVENT("Internals.getProgrammaticScrollAnimationState");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_node = NativeValueTraits<Node>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->getProgrammaticScrollAnimationState(arg1_node);
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void GetReferencedFilePathsOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_getReferencedFilePaths");
    BLINK_BINDINGS_TRACE_EVENT("Internals.getReferencedFilePaths");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->getReferencedFilePaths();
    static_assert(bindings::IsReturnTypeCompatible<IDLSequence<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    v8::Local<v8::Value> v8_return_value = ToV8Traits<IDLSequence<IDLString>>::ToV8(script_state, return_value);
    bindings::V8SetReturnValue(info, v8_return_value);
}

void GetResourceHeaderOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_getResourceHeader");
    BLINK_BINDINGS_TRACE_EVENT("Internals.getResourceHeader");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 3) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(3, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_url = NativeValueTraits<IDLString>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_header = NativeValueTraits<IDLString>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_document = NativeValueTraits<Document>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->getResourceHeader(arg1_url, arg2_header, arg3_document);
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void GetScrollAnimationStateOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_getScrollAnimationState");
    BLINK_BINDINGS_TRACE_EVENT("Internals.getScrollAnimationState");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_node = NativeValueTraits<Node>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->getScrollAnimationState(arg1_node);
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void GetSelectionInFlatTreeOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_getSelectionInFlatTree");
    BLINK_BINDINGS_TRACE_EVENT("Internals.getSelectionInFlatTree");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_window = NativeValueTraits<DOMWindow>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->getSelectionInFlatTree(arg1_window, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<StaticSelection, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void GetVirtualSensorInformationOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_getVirtualSensorInformation");
    BLINK_BINDINGS_TRACE_EVENT("Internals.getVirtualSensorInformation");
    // Promise returning function: Convert a TypeError to a reject promise.
    ExceptionToRejectPromiseScope reject_promise_scope(info);

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    if (!V8Internals::HasInstance(isolate, v8_receiver)) {
        V8ThrowException::ThrowTypeError(isolate, "Illegal invocation");
        return;
    }

    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    const v8::ExceptionContext exception_context_type = v8::ExceptionContext::kOperation;
    const char* const class_like_name = "Internals";
    const char* const property_name = "getVirtualSensorInformation";
    ExceptionState exception_state(isolate, exception_context_type, class_like_name, property_name);
    auto&& arg1_type = NativeValueTraits<V8VirtualSensorType>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    ScriptPromise<VirtualSensorInformation> return_value = InternalsSensor::getVirtualSensorInformation(script_state, *blink_receiver, arg1_type);
    bindings::V8SetReturnValue(info, return_value);
}

void HasAutofocusRequestOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_hasAutofocusRequest");
    BLINK_BINDINGS_TRACE_EVENT("Internals.hasAutofocusRequest");

    bool return_value;
    do { // Dummy loop for use of 'break'.
        const int non_undefined_argument_length = bindings::NonUndefinedArgumentLength(info);
        v8::Isolate* isolate = info.GetIsolate();
        v8::Local<v8::Object> v8_receiver = info.This();
        Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
        if (non_undefined_argument_length <= 0) {
            return_value = blink_receiver->hasAutofocusRequest();
            break;
        }
        ExceptionState exception_state(isolate);
        auto&& arg1_document = NativeValueTraits<Document>::ArgumentValue(isolate, 0, info[0], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
        return_value = blink_receiver->hasAutofocusRequest(arg1_document);
    } while (false);
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void HasGrammarMarkerOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_hasGrammarMarker");
    BLINK_BINDINGS_TRACE_EVENT("Internals.hasGrammarMarker");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 3) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(3, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_document = NativeValueTraits<Document>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_from = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_length = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->hasGrammarMarker(arg1_document, arg2_from, arg3_length, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<IDLBoolean, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void HasLastEditCommandOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_hasLastEditCommand");
    BLINK_BINDINGS_TRACE_EVENT("Internals.hasLastEditCommand");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_document = NativeValueTraits<Document>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->hasLastEditCommand(arg1_document, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<IDLBoolean, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void HasSpellingMarkerOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_hasSpellingMarker");
    BLINK_BINDINGS_TRACE_EVENT("Internals.hasSpellingMarker");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 3) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(3, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_document = NativeValueTraits<Document>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_from = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_length = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->hasSpellingMarker(arg1_document, arg2_from, arg3_length, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<IDLBoolean, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void HitTestCacheHitsOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_hitTestCacheHits");
    BLINK_BINDINGS_TRACE_EVENT("Internals.hitTestCacheHits");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_document = NativeValueTraits<Document>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->hitTestCacheHits(arg1_document, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<IDLUnsignedLong, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<uint32_t>());
}

void HitTestCountOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_hitTestCount");
    BLINK_BINDINGS_TRACE_EVENT("Internals.hitTestCount");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_document = NativeValueTraits<Document>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->hitTestCount(arg1_document, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<IDLUnsignedLong, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<uint32_t>());
}

void HTMLNamespaceOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_htmlNamespace");
    BLINK_BINDINGS_TRACE_EVENT("Internals.htmlNamespace");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->htmlNamespace();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void HTMLTagsOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_htmlTags");
    BLINK_BINDINGS_TRACE_EVENT("Internals.htmlTags");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->htmlTags();
    static_assert(bindings::IsReturnTypeCompatible<IDLSequence<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    v8::Local<v8::Value> v8_return_value = ToV8Traits<IDLSequence<IDLString>>::ToV8(script_state, return_value);
    bindings::V8SetReturnValue(info, v8_return_value);
}

void IdleTimeSpellCheckerStateOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_idleTimeSpellCheckerState");
    BLINK_BINDINGS_TRACE_EVENT("Internals.idleTimeSpellCheckerState");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_document = NativeValueTraits<Document>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->idleTimeSpellCheckerState(arg1_document, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void InitializeUKMRecorderOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_initializeUKMRecorder");
    BLINK_BINDINGS_TRACE_EVENT("Internals.initializeUKMRecorder");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->initializeUKMRecorder();
    static_assert(bindings::IsReturnTypeCompatible<InternalsUkmRecorder, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void InnerEditorElementOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_innerEditorElement");
    BLINK_BINDINGS_TRACE_EVENT("Internals.innerEditorElement");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_container = NativeValueTraits<Element>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->innerEditorElement(arg1_container, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<Element>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void IsActivatedOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_isActivated");
    BLINK_BINDINGS_TRACE_EVENT("Internals.isActivated");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->isActivated();
    static_assert(bindings::IsReturnTypeCompatible<IDLBoolean, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void IsAnimatedCSSPropertyUseCountedOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_isAnimatedCSSPropertyUseCounted");
    BLINK_BINDINGS_TRACE_EVENT("Internals.isAnimatedCSSPropertyUseCounted");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_document = NativeValueTraits<Document>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_property_name = NativeValueTraits<IDLString>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->isAnimatedCSSPropertyUseCounted(arg1_document, arg2_property_name);
    static_assert(bindings::IsReturnTypeCompatible<IDLBoolean, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void IsCSSPropertyUseCountedOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_isCSSPropertyUseCounted");
    BLINK_BINDINGS_TRACE_EVENT("Internals.isCSSPropertyUseCounted");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_document = NativeValueTraits<Document>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_property_name = NativeValueTraits<IDLString>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->isCSSPropertyUseCounted(arg1_document, arg2_property_name);
    static_assert(bindings::IsReturnTypeCompatible<IDLBoolean, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void IsCompositedAnimationOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_isCompositedAnimation");
    BLINK_BINDINGS_TRACE_EVENT("Internals.isCompositedAnimation");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_animation = NativeValueTraits<Animation>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->isCompositedAnimation(arg1_animation);
    static_assert(bindings::IsReturnTypeCompatible<IDLBoolean, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void IsInCanvasFontCacheOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_isInCanvasFontCache");
    BLINK_BINDINGS_TRACE_EVENT("Internals.isInCanvasFontCache");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_document = NativeValueTraits<Document>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_font_string = NativeValueTraits<IDLString>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->isInCanvasFontCache(arg1_document, arg2_font_string);
    static_assert(bindings::IsReturnTypeCompatible<IDLBoolean, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void IsLoadingOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_isLoading");
    BLINK_BINDINGS_TRACE_EVENT("Internals.isLoading");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    decltype(NativeValueTraits<IDLString>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg1_url;
    if (info[0]->IsString()) [[likely]] {
        arg1_url.Init(isolate, info[0].As<v8::String>());
    } else {
        ExceptionState exception_state(isolate);
        arg1_url = NativeValueTraits<IDLString>::ArgumentValue(isolate, 0, info[0], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->isLoading(arg1_url);
    static_assert(bindings::IsReturnTypeCompatible<IDLBoolean, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void IsLoadingFromMemoryCacheOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_isLoadingFromMemoryCache");
    BLINK_BINDINGS_TRACE_EVENT("Internals.isLoadingFromMemoryCache");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    decltype(NativeValueTraits<IDLString>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg1_url;
    if (info[0]->IsString()) [[likely]] {
        arg1_url.Init(isolate, info[0].As<v8::String>());
    } else {
        ExceptionState exception_state(isolate);
        arg1_url = NativeValueTraits<IDLString>::ArgumentValue(isolate, 0, info[0], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->isLoadingFromMemoryCache(arg1_url);
    static_assert(bindings::IsReturnTypeCompatible<IDLBoolean, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void IsLowEndDeviceOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_isLowEndDevice");
    BLINK_BINDINGS_TRACE_EVENT("Internals.isLowEndDevice");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->isLowEndDevice();
    static_assert(bindings::IsReturnTypeCompatible<IDLBoolean, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void IsMediaElementSuspendedOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_isMediaElementSuspended");
    BLINK_BINDINGS_TRACE_EVENT("Internals.isMediaElementSuspended");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_media_element = NativeValueTraits<HTMLMediaElement>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->isMediaElementSuspended(arg1_media_element);
    static_assert(bindings::IsReturnTypeCompatible<IDLBoolean, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void IsPreloadedOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_isPreloaded");
    BLINK_BINDINGS_TRACE_EVENT("Internals.isPreloaded");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    decltype(NativeValueTraits<IDLString>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg1_url;
    if (info[0]->IsString()) [[likely]] {
        arg1_url.Init(isolate, info[0].As<v8::String>());
    } else {
        ExceptionState exception_state(isolate);
        arg1_url = NativeValueTraits<IDLString>::ArgumentValue(isolate, 0, info[0], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->isPreloaded(arg1_url);
    static_assert(bindings::IsReturnTypeCompatible<IDLBoolean, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void IsPreloadedByOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_isPreloadedBy");
    BLINK_BINDINGS_TRACE_EVENT("Internals.isPreloadedBy");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_url = NativeValueTraits<IDLString>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_document = NativeValueTraits<Document>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->isPreloadedBy(arg1_url, arg2_document);
    static_assert(bindings::IsReturnTypeCompatible<IDLBoolean, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void IsSelectPopupVisibleOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_isSelectPopupVisible");
    BLINK_BINDINGS_TRACE_EVENT("Internals.isSelectPopupVisible");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_node = NativeValueTraits<Node>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->isSelectPopupVisible(arg1_node);
    static_assert(bindings::IsReturnTypeCompatible<IDLBoolean, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void IsSiteIsolatedOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_isSiteIsolated");
    BLINK_BINDINGS_TRACE_EVENT("Internals.isSiteIsolated");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_iframe = NativeValueTraits<HTMLIFrameElement>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->isSiteIsolated(arg1_iframe);
    static_assert(bindings::IsReturnTypeCompatible<IDLBoolean, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void IsTrackingOcclusionForIFrameOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_isTrackingOcclusionForIFrame");
    BLINK_BINDINGS_TRACE_EVENT("Internals.isTrackingOcclusionForIFrame");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_iframe = NativeValueTraits<HTMLIFrameElement>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->isTrackingOcclusionForIFrame(arg1_iframe);
    static_assert(bindings::IsReturnTypeCompatible<IDLBoolean, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void IsUseCountedOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_isUseCounted");
    BLINK_BINDINGS_TRACE_EVENT("Internals.isUseCounted");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_document = NativeValueTraits<Document>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_feature = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->isUseCounted(arg1_document, arg2_feature);
    static_assert(bindings::IsReturnTypeCompatible<IDLBoolean, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void IsValidationMessageVisibleOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_isValidationMessageVisible");
    BLINK_BINDINGS_TRACE_EVENT("Internals.isValidationMessageVisible");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_element = NativeValueTraits<Element>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->isValidationMessageVisible(arg1_element);
    static_assert(bindings::IsReturnTypeCompatible<IDLBoolean, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void IsVibratingOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_isVibrating");
    BLINK_BINDINGS_TRACE_EVENT("Internals.isVibrating");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_navigator = NativeValueTraits<Navigator>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = InternalsVibration::isVibrating(*blink_receiver, arg1_navigator);
    static_assert(bindings::IsReturnTypeCompatible<IDLBoolean, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void IsWebDXFeatureUseCountedOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_isWebDXFeatureUseCounted");
    BLINK_BINDINGS_TRACE_EVENT("Internals.isWebDXFeatureUseCounted");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_document = NativeValueTraits<Document>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_feature = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->isWebDXFeatureUseCounted(arg1_document, arg2_feature);
    static_assert(bindings::IsReturnTypeCompatible<IDLBoolean, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void LastChildInFlatTreeOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_lastChildInFlatTree");
    BLINK_BINDINGS_TRACE_EVENT("Internals.lastChildInFlatTree");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_node = NativeValueTraits<Node>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->lastChildInFlatTree(arg1_node, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<Node, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void LastCompiledScriptFileNameOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_lastCompiledScriptFileName");
    BLINK_BINDINGS_TRACE_EVENT("Internals.lastCompiledScriptFileName");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_document = NativeValueTraits<Document>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->lastCompiledScriptFileName(arg1_document);
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void LastCompiledScriptUsedCodeCacheOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_lastCompiledScriptUsedCodeCache");
    BLINK_BINDINGS_TRACE_EVENT("Internals.lastCompiledScriptUsedCodeCache");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_document = NativeValueTraits<Document>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->lastCompiledScriptUsedCodeCache(arg1_document);
    static_assert(bindings::IsReturnTypeCompatible<IDLBoolean, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void LastSpellCheckProcessedSequenceOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_lastSpellCheckProcessedSequence");
    BLINK_BINDINGS_TRACE_EVENT("Internals.lastSpellCheckProcessedSequence");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_document = NativeValueTraits<Document>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->lastSpellCheckProcessedSequence(arg1_document, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<IDLLong, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<int32_t>());
}

void LastSpellCheckRequestSequenceOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_lastSpellCheckRequestSequence");
    BLINK_BINDINGS_TRACE_EVENT("Internals.lastSpellCheckRequestSequence");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_document = NativeValueTraits<Document>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->lastSpellCheckRequestSequence(arg1_document, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<IDLLong, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<int32_t>());
}

void LayerTreeAsTextOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_layerTreeAsText");
    BLINK_BINDINGS_TRACE_EVENT("Internals.layerTreeAsText");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    String return_value;
    ExceptionState exception_state(isolate);
    do { // Dummy loop for use of 'break'.
        const int non_undefined_argument_length = bindings::NonUndefinedArgumentLength(info);
        v8::Local<v8::Object> v8_receiver = info.This();
        Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
        auto&& arg1_document = NativeValueTraits<Document>::ArgumentValue(isolate, 0, info[0], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
        if (non_undefined_argument_length <= 1) {
            return_value = blink_receiver->layerTreeAsText(arg1_document, exception_state);
            break;
        }
        auto&& arg2_flags = NativeValueTraits<IDLUnsignedShort>::ArgumentValue(isolate, 1, info[1], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
        return_value = blink_receiver->layerTreeAsText(arg1_document, arg2_flags, exception_state);
    } while (false);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void LayoutCountForTestingOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_layoutCountForTesting");
    BLINK_BINDINGS_TRACE_EVENT("Internals.layoutCountForTesting");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& return_value = blink_receiver->layoutCountForTesting(exception_state);
    static_assert(bindings::IsReturnTypeCompatible<IDLUnsignedLong, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<uint32_t>());
}

void LayoutZoomFactorOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_layoutZoomFactor");
    BLINK_BINDINGS_TRACE_EVENT("Internals.layoutZoomFactor");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& return_value = blink_receiver->layoutZoomFactor(exception_state);
    static_assert(bindings::IsReturnTypeCompatible<IDLFloat, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<float>());
}

void LengthFromRangeOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_lengthFromRange");
    BLINK_BINDINGS_TRACE_EVENT("Internals.lengthFromRange");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_scope = NativeValueTraits<Element>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_range = NativeValueTraits<Range>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->lengthFromRange(arg1_scope, arg2_range);
    static_assert(bindings::IsReturnTypeCompatible<IDLUnsignedLong, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<uint32_t>());
}

void LocationFromRangeOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_locationFromRange");
    BLINK_BINDINGS_TRACE_EVENT("Internals.locationFromRange");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_scope = NativeValueTraits<Element>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_range = NativeValueTraits<Range>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->locationFromRange(arg1_scope, arg2_range);
    static_assert(bindings::IsReturnTypeCompatible<IDLUnsignedLong, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<uint32_t>());
}

void MainThreadScrollingReasonsOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_mainThreadScrollingReasons");
    BLINK_BINDINGS_TRACE_EVENT("Internals.mainThreadScrollingReasons");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_document = NativeValueTraits<Document>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->mainThreadScrollingReasons(arg1_document, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void MarkerBackgroundColorForNodeOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_markerBackgroundColorForNode");
    BLINK_BINDINGS_TRACE_EVENT("Internals.markerBackgroundColorForNode");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 3) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(3, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_text = NativeValueTraits<Text>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_marker_type = NativeValueTraits<IDLString>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_index = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->markerBackgroundColorForNode(arg1_text, arg2_marker_type, arg3_index, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<IDLUnsignedLong, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<uint32_t>());
}

void MarkerCountForNodeOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_markerCountForNode");
    BLINK_BINDINGS_TRACE_EVENT("Internals.markerCountForNode");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_text = NativeValueTraits<Text>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_marker_type = NativeValueTraits<IDLString>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->markerCountForNode(arg1_text, arg2_marker_type, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<IDLUnsignedLong, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<uint32_t>());
}

void MarkerDescriptionForNodeOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_markerDescriptionForNode");
    BLINK_BINDINGS_TRACE_EVENT("Internals.markerDescriptionForNode");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 3) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(3, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_text = NativeValueTraits<Text>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_marker_type = NativeValueTraits<IDLString>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_index = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->markerDescriptionForNode(arg1_text, arg2_marker_type, arg3_index, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void MarkerRangeForNodeOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_markerRangeForNode");
    BLINK_BINDINGS_TRACE_EVENT("Internals.markerRangeForNode");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 3) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(3, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_text = NativeValueTraits<Text>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_marker_type = NativeValueTraits<IDLString>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_index = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->markerRangeForNode(arg1_text, arg2_marker_type, arg3_index, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<Range, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void MarkerTextForListItemOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_markerTextForListItem");
    BLINK_BINDINGS_TRACE_EVENT("Internals.markerTextForListItem");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_element = NativeValueTraits<Element>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->markerTextForListItem(arg1_element);
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void MarkerUnderlineColorForNodeOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_markerUnderlineColorForNode");
    BLINK_BINDINGS_TRACE_EVENT("Internals.markerUnderlineColorForNode");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 3) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(3, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_text = NativeValueTraits<Text>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_marker_type = NativeValueTraits<IDLString>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_index = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->markerUnderlineColorForNode(arg1_text, arg2_marker_type, arg3_index, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<IDLUnsignedLong, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<uint32_t>());
}

void MediaKeySessionCountOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_mediaKeySessionCount");
    BLINK_BINDINGS_TRACE_EVENT("Internals.mediaKeySessionCount");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->mediaKeySessionCount();
    static_assert(bindings::IsReturnTypeCompatible<IDLUnsignedLong, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<uint32_t>());
}

void MediaKeysCountOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_mediaKeysCount");
    BLINK_BINDINGS_TRACE_EVENT("Internals.mediaKeysCount");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->mediaKeysCount();
    static_assert(bindings::IsReturnTypeCompatible<IDLUnsignedLong, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<uint32_t>());
}

void MediaPlayerPlayingRemotelyChangedOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_mediaPlayerPlayingRemotelyChanged");
    BLINK_BINDINGS_TRACE_EVENT("Internals.mediaPlayerPlayingRemotelyChanged");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_media_element = NativeValueTraits<HTMLMediaElement>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_remote = NativeValueTraits<IDLBoolean>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->mediaPlayerPlayingRemotelyChanged(arg1_media_element, arg2_remote);
}

void MediaPlayerRemoteRouteAvailabilityChangedOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_mediaPlayerRemoteRouteAvailabilityChanged");
    BLINK_BINDINGS_TRACE_EVENT("Internals.mediaPlayerRemoteRouteAvailabilityChanged");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_media_element = NativeValueTraits<HTMLMediaElement>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_available = NativeValueTraits<IDLBoolean>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->mediaPlayerRemoteRouteAvailabilityChanged(arg1_media_element, arg2_available);
}

void MonotonicTimeToZeroBasedDocumentTimeOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_monotonicTimeToZeroBasedDocumentTime");
    BLINK_BINDINGS_TRACE_EVENT("Internals.monotonicTimeToZeroBasedDocumentTime");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_platform_time = NativeValueTraits<IDLDouble>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->monotonicTimeToZeroBasedDocumentTime(arg1_platform_time, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<IDLDouble, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<double>());
}

void NeedsLayoutCountOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_needsLayoutCount");
    BLINK_BINDINGS_TRACE_EVENT("Internals.needsLayoutCount");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& return_value = blink_receiver->needsLayoutCount(exception_state);
    static_assert(bindings::IsReturnTypeCompatible<IDLUnsignedLong, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<uint32_t>());
}

void NextInFlatTreeOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_nextInFlatTree");
    BLINK_BINDINGS_TRACE_EVENT("Internals.nextInFlatTree");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_node = NativeValueTraits<Node>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->nextInFlatTree(arg1_node, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<Node, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void NextSiblingInFlatTreeOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_nextSiblingInFlatTree");
    BLINK_BINDINGS_TRACE_EVENT("Internals.nextSiblingInFlatTree");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_node = NativeValueTraits<Node>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->nextSiblingInFlatTree(arg1_node, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<Node, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void NodeNeedsStyleRecalcOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_nodeNeedsStyleRecalc");
    BLINK_BINDINGS_TRACE_EVENT("Internals.nodeNeedsStyleRecalc");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_node = NativeValueTraits<Node>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->nodeNeedsStyleRecalc(arg1_node, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<IDLBoolean, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void NodesFromRectOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_nodesFromRect");
    BLINK_BINDINGS_TRACE_EVENT("Internals.nodesFromRect");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 7) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(7, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    ExceptionState exception_state(isolate);
    auto&& arg1_document = NativeValueTraits<Document>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_x = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_y = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg4_width = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 3, info[3], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg5_height = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 4, info[4], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg6_ignore_clipping = NativeValueTraits<IDLBoolean>::ArgumentValue(isolate, 5, info[5], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg7_allow_child_frame_content = NativeValueTraits<IDLBoolean>::ArgumentValue(isolate, 6, info[6], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->nodesFromRect(
        script_state, arg1_document, arg2_x, arg3_y, arg4_width, arg5_height, arg6_ignore_clipping, arg7_allow_child_frame_content, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<NodeList, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void NonDraggableRegionsOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_nonDraggableRegions");
    BLINK_BINDINGS_TRACE_EVENT("Internals.nonDraggableRegions");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_document = NativeValueTraits<Document>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->nonDraggableRegions(arg1_document, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<DOMRectList, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void NumberOfLiveAXObjectsOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_numberOfLiveAXObjects");
    BLINK_BINDINGS_TRACE_EVENT("Internals.numberOfLiveAXObjects");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = InternalsAccessibility::numberOfLiveAXObjects(*blink_receiver);
    static_assert(bindings::IsReturnTypeCompatible<IDLUnsignedLong, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<uint32_t>());
}

void NumberOfLiveDocumentsOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_numberOfLiveDocuments");
    BLINK_BINDINGS_TRACE_EVENT("Internals.numberOfLiveDocuments");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->numberOfLiveDocuments();
    static_assert(bindings::IsReturnTypeCompatible<IDLUnsignedLong, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<uint32_t>());
}

void NumberOfLiveNodesOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_numberOfLiveNodes");
    BLINK_BINDINGS_TRACE_EVENT("Internals.numberOfLiveNodes");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->numberOfLiveNodes();
    static_assert(bindings::IsReturnTypeCompatible<IDLUnsignedLong, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<uint32_t>());
}

void NumberOfPagesOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_numberOfPages");
    BLINK_BINDINGS_TRACE_EVENT("Internals.numberOfPages");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    decltype(NativeValueTraits<IDLDouble>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg1_page_width_in_pixels { 800 };
    ExceptionState exception_state(isolate);
    if (!info[0]->IsUndefined()) {
        arg1_page_width_in_pixels = NativeValueTraits<IDLDouble>::ArgumentValue(isolate, 0, info[0], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    decltype(NativeValueTraits<IDLDouble>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg2_page_height_in_pixels { 600 };
    if (!info[1]->IsUndefined()) {
        arg2_page_height_in_pixels = NativeValueTraits<IDLDouble>::ArgumentValue(isolate, 1, info[1], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->numberOfPages(arg1_page_width_in_pixels, arg2_page_height_in_pixels, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<IDLLong, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<int32_t>());
}

void NumberOfScrollableAreasOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_numberOfScrollableAreas");
    BLINK_BINDINGS_TRACE_EVENT("Internals.numberOfScrollableAreas");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_document = NativeValueTraits<Document>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->numberOfScrollableAreas(arg1_document);
    static_assert(bindings::IsReturnTypeCompatible<IDLUnsignedLong, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<uint32_t>());
}

void ObserveGCOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_observeGC");
    BLINK_BINDINGS_TRACE_EVENT("Internals.observeGC");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_observed = NativeValueTraits<IDLAny>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->observeGC(arg1_observed, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<GCObservation, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void ObserveUseCounterOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_observeUseCounter");
    BLINK_BINDINGS_TRACE_EVENT("Internals.observeUseCounter");
    // Promise returning function: Convert a TypeError to a reject promise.
    ExceptionToRejectPromiseScope reject_promise_scope(info);

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    if (!V8Internals::HasInstance(isolate, v8_receiver)) {
        V8ThrowException::ThrowTypeError(isolate, "Illegal invocation");
        return;
    }

    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    const v8::ExceptionContext exception_context_type = v8::ExceptionContext::kOperation;
    const char* const class_like_name = "Internals";
    const char* const property_name = "observeUseCounter";
    ExceptionState exception_state(isolate, exception_context_type, class_like_name, property_name);
    auto&& arg1_document = NativeValueTraits<Document>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_feature = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    ScriptPromise<IDLUndefined> return_value = blink_receiver->observeUseCounter(script_state, arg1_document, arg2_feature);
    bindings::V8SetReturnValue(info, return_value);
}

void OriginTrialsTestOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_originTrialsTest");
    BLINK_BINDINGS_TRACE_EVENT("Internals.originTrialsTest");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->originTrialsTest();
    static_assert(bindings::IsReturnTypeCompatible<OriginTrialsTest, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void PageNumberOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_pageNumber");
    BLINK_BINDINGS_TRACE_EVENT("Internals.pageNumber");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_element = NativeValueTraits<Element>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<IDLFloat>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg2_page_width { 800 };
    if (!info[1]->IsUndefined()) {
        arg2_page_width = NativeValueTraits<IDLFloat>::ArgumentValue(isolate, 1, info[1], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    decltype(NativeValueTraits<IDLFloat>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg3_page_height { 600 };
    if (!info[2]->IsUndefined()) {
        arg3_page_height = NativeValueTraits<IDLFloat>::ArgumentValue(isolate, 2, info[2], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->pageNumber(arg1_element, arg2_page_width, arg3_page_height, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<IDLLong, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<int32_t>());
}

void PageScaleFactorOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_pageScaleFactor");
    BLINK_BINDINGS_TRACE_EVENT("Internals.pageScaleFactor");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& return_value = blink_receiver->pageScaleFactor(exception_state);
    static_assert(bindings::IsReturnTypeCompatible<IDLFloat, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<float>());
}

void ParentTreeScopeOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_parentTreeScope");
    BLINK_BINDINGS_TRACE_EVENT("Internals.parentTreeScope");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_node = NativeValueTraits<Node>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->parentTreeScope(arg1_node);
    static_assert(bindings::IsReturnTypeCompatible<Node, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void PauseAnimationsOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_pauseAnimations");
    BLINK_BINDINGS_TRACE_EVENT("Internals.pauseAnimations");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_pause_time = NativeValueTraits<IDLDouble>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->pauseAnimations(arg1_pause_time, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void PeerConnectionCountOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_peerConnectionCount");
    BLINK_BINDINGS_TRACE_EVENT("Internals.peerConnectionCount");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = InternalsRTCPeerConnection::peerConnectionCount(*blink_receiver);
    static_assert(bindings::IsReturnTypeCompatible<IDLLong, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<int32_t>());
}

void PendingVibrationPatternOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_pendingVibrationPattern");
    BLINK_BINDINGS_TRACE_EVENT("Internals.pendingVibrationPattern");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_navigator = NativeValueTraits<Navigator>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = InternalsVibration::pendingVibrationPattern(*blink_receiver, arg1_navigator);
    static_assert(bindings::IsReturnTypeCompatible<IDLSequence<IDLUnsignedLong>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    v8::Local<v8::Value> v8_return_value = ToV8Traits<IDLSequence<IDLUnsignedLong>>::ToV8(script_state, return_value);
    bindings::V8SetReturnValue(info, v8_return_value);
}

void PointerEventHandlerCountOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_pointerEventHandlerCount");
    BLINK_BINDINGS_TRACE_EVENT("Internals.pointerEventHandlerCount");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_document = NativeValueTraits<Document>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->pointerEventHandlerCount(arg1_document);
    static_assert(bindings::IsReturnTypeCompatible<IDLUnsignedLong, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<uint32_t>());
}

void PreviousInFlatTreeOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_previousInFlatTree");
    BLINK_BINDINGS_TRACE_EVENT("Internals.previousInFlatTree");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_node = NativeValueTraits<Node>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->previousInFlatTree(arg1_node, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<Node, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void PromiseCheckOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_promiseCheck");
    BLINK_BINDINGS_TRACE_EVENT("Internals.promiseCheck");
    // Promise returning function: Convert a TypeError to a reject promise.
    ExceptionToRejectPromiseScope reject_promise_scope(info);

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    if (!V8Internals::HasInstance(isolate, v8_receiver)) {
        V8ThrowException::ThrowTypeError(isolate, "Illegal invocation");
        return;
    }

    if (info.Length() < 5) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(5, info.Length()));
        return;
    }

    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    const v8::ExceptionContext exception_context_type = v8::ExceptionContext::kOperation;
    const char* const class_like_name = "Internals";
    const char* const property_name = "promiseCheck";
    ExceptionState exception_state(isolate, exception_context_type, class_like_name, property_name);
    auto&& arg1_arg_1 = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_arg_2 = NativeValueTraits<IDLBoolean>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_arg_3 = NativeValueTraits<IDLObject>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg4_arg_4 = NativeValueTraits<IDLString>::ArgumentValue(isolate, 3, info[3], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg5_arg_5 = NativeValueTraits<IDLSequence<IDLString>>::ArgumentValue(isolate, 4, info[4], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    ScriptPromise<IDLAny> return_value
        = blink_receiver->promiseCheck(script_state, arg1_arg_1, arg2_arg_2, arg3_arg_3, arg4_arg_4, std::move(arg5_arg_5), exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value);
}

void PromiseCheckOverloadOperationOverload1(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    if (!V8Internals::HasInstance(isolate, v8_receiver)) {
        V8ThrowException::ThrowTypeError(isolate, "Illegal invocation");
        return;
    }

    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    const v8::ExceptionContext exception_context_type = v8::ExceptionContext::kOperation;
    const char* const class_like_name = "Internals";
    const char* const property_name = "promiseCheckOverload";
    ExceptionState exception_state(isolate, exception_context_type, class_like_name, property_name);
    auto&& arg1_arg_1 = NativeValueTraits<Location>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    ScriptPromise<IDLAny> return_value = blink_receiver->promiseCheckOverload(script_state, arg1_arg_1);
    bindings::V8SetReturnValue(info, return_value);
}

void PromiseCheckOverloadOperationOverload2(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    if (!V8Internals::HasInstance(isolate, v8_receiver)) {
        V8ThrowException::ThrowTypeError(isolate, "Illegal invocation");
        return;
    }

    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    const v8::ExceptionContext exception_context_type = v8::ExceptionContext::kOperation;
    const char* const class_like_name = "Internals";
    const char* const property_name = "promiseCheckOverload";
    ExceptionState exception_state(isolate, exception_context_type, class_like_name, property_name);
    auto&& arg1_arg_1 = NativeValueTraits<Document>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    ScriptPromise<IDLAny> return_value = blink_receiver->promiseCheckOverload(script_state, arg1_arg_1);
    bindings::V8SetReturnValue(info, return_value);
}

void PromiseCheckOverloadOperationOverload3(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    if (!V8Internals::HasInstance(isolate, v8_receiver)) {
        V8ThrowException::ThrowTypeError(isolate, "Illegal invocation");
        return;
    }

    if (info.Length() < 3) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(3, info.Length()));
        return;
    }

    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    const v8::ExceptionContext exception_context_type = v8::ExceptionContext::kOperation;
    const char* const class_like_name = "Internals";
    const char* const property_name = "promiseCheckOverload";
    ExceptionState exception_state(isolate, exception_context_type, class_like_name, property_name);
    auto&& arg1_arg_1 = NativeValueTraits<Location>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_arg_2 = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_arg_3 = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    ScriptPromise<IDLAny> return_value = blink_receiver->promiseCheckOverload(script_state, arg1_arg_1, arg2_arg_2, arg3_arg_3);
    bindings::V8SetReturnValue(info, return_value);
}

void PromiseCheckOverloadOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    // Promise returning function: Convert a TypeError to a reject promise.
    ExceptionToRejectPromiseScope reject_promise_scope(info);
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_promiseCheckOverload");
    BLINK_BINDINGS_TRACE_EVENT("Internals.promiseCheckOverload");

    BINDINGS_COOPERATIVE_SCHEDULING_SAFEPOINT();

    const int arg_count = std::min(info.Length(), 3);
    v8::Isolate* isolate = info.GetIsolate();
    do { // Dummy loop for use of 'break'.
        if (arg_count == 3) {
            return PromiseCheckOverloadOperationOverload3(info);
        }
        if (arg_count == 1) {
            if (info[0]->IsObject()) {
                if (V8Document::HasInstance(isolate, info[0])) {
                    return PromiseCheckOverloadOperationOverload2(info);
                }
                if (V8Location::HasInstance(isolate, info[0])) {
                    return PromiseCheckOverloadOperationOverload1(info);
                }
            }
            break;
        }
    } while (false);

    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }
    V8ThrowException::ThrowTypeError(isolate, "Overload resolution failed.");
    return;
}

void PromiseCheckRangeOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_promiseCheckRange");
    BLINK_BINDINGS_TRACE_EVENT("Internals.promiseCheckRange");
    // Promise returning function: Convert a TypeError to a reject promise.
    ExceptionToRejectPromiseScope reject_promise_scope(info);

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    if (!V8Internals::HasInstance(isolate, v8_receiver)) {
        V8ThrowException::ThrowTypeError(isolate, "Illegal invocation");
        return;
    }

    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    const v8::ExceptionContext exception_context_type = v8::ExceptionContext::kOperation;
    const char* const class_like_name = "Internals";
    const char* const property_name = "promiseCheckRange";
    ExceptionState exception_state(isolate, exception_context_type, class_like_name, property_name);
    auto&& arg1_arg_1 = NativeValueTraits<IDLOctetEnforceRange>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    ScriptPromise<IDLAny> return_value = blink_receiver->promiseCheckRange(script_state, arg1_arg_1);
    bindings::V8SetReturnValue(info, return_value);
}

void PromiseCheckWithoutExceptionStateOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_promiseCheckWithoutExceptionState");
    BLINK_BINDINGS_TRACE_EVENT("Internals.promiseCheckWithoutExceptionState");
    // Promise returning function: Convert a TypeError to a reject promise.
    ExceptionToRejectPromiseScope reject_promise_scope(info);

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    if (!V8Internals::HasInstance(isolate, v8_receiver)) {
        V8ThrowException::ThrowTypeError(isolate, "Illegal invocation");
        return;
    }

    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    const v8::ExceptionContext exception_context_type = v8::ExceptionContext::kOperation;
    const char* const class_like_name = "Internals";
    const char* const property_name = "promiseCheckWithoutExceptionState";
    ExceptionState exception_state(isolate, exception_context_type, class_like_name, property_name);
    auto&& arg1_arg_1 = NativeValueTraits<IDLObject>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_arg_2 = NativeValueTraits<IDLString>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_variadic = bindings::VariadicArgumentsToNativeValues<IDLString>(isolate, info, 2, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    ScriptPromise<IDLAny> return_value = blink_receiver->promiseCheckWithoutExceptionState(script_state, arg1_arg_1, arg2_arg_2, arg3_variadic);
    bindings::V8SetReturnValue(info, return_value);
}

void RangeAsTextOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_rangeAsText");
    BLINK_BINDINGS_TRACE_EVENT("Internals.rangeAsText");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_range = NativeValueTraits<Range>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->rangeAsText(arg1_range);
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void RangeFromLocationAndLengthOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_rangeFromLocationAndLength");
    BLINK_BINDINGS_TRACE_EVENT("Internals.rangeFromLocationAndLength");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 3) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(3, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_scope = NativeValueTraits<Element>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_range_location = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_range_length = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->rangeFromLocationAndLength(arg1_scope, arg2_range_location, arg3_range_length);
    static_assert(bindings::IsReturnTypeCompatible<Range, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void RecordTestOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_recordTest");
    BLINK_BINDINGS_TRACE_EVENT("Internals.recordTest");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->recordTest();
    static_assert(bindings::IsReturnTypeCompatible<RecordTest, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void RegisterURLSchemeAsBypassingContentSecurityPolicyOperationOverload1(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    decltype(NativeValueTraits<IDLString>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg1_scheme;
    if (info[0]->IsString()) [[likely]] {
        arg1_scheme.Init(isolate, info[0].As<v8::String>());
    } else {
        ExceptionState exception_state(isolate);
        arg1_scheme = NativeValueTraits<IDLString>::ArgumentValue(isolate, 0, info[0], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    blink_receiver->registerURLSchemeAsBypassingContentSecurityPolicy(arg1_scheme);
}

void RegisterURLSchemeAsBypassingContentSecurityPolicyOperationOverload2(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_scheme = NativeValueTraits<IDLString>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_policy_areas = NativeValueTraits<IDLSequence<IDLString>>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->registerURLSchemeAsBypassingContentSecurityPolicy(arg1_scheme, std::move(arg2_policy_areas));
}

void RegisterURLSchemeAsBypassingContentSecurityPolicyOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_registerURLSchemeAsBypassingContentSecurityPolicy");
    BLINK_BINDINGS_TRACE_EVENT("Internals.registerURLSchemeAsBypassingContentSecurityPolicy");

    BINDINGS_COOPERATIVE_SCHEDULING_SAFEPOINT();

    const int arg_count = std::min(info.Length(), 2);
    if (arg_count == 2) {
        return RegisterURLSchemeAsBypassingContentSecurityPolicyOperationOverload2(info);
    }
    if (arg_count == 1) {
        return RegisterURLSchemeAsBypassingContentSecurityPolicyOperationOverload1(info);
    }

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }
    V8ThrowException::ThrowTypeError(isolate, "Overload resolution failed.");
    return;
}

void RemoveMarkerOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_removeMarker");
    BLINK_BINDINGS_TRACE_EVENT("Internals.removeMarker");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 3) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(3, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_document = NativeValueTraits<Document>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_range = NativeValueTraits<Range>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_marker_type = NativeValueTraits<IDLString>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->removeMarker(arg1_document, arg2_range, arg3_marker_type, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void RemoveURLSchemeRegisteredAsBypassingContentSecurityPolicyOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_removeURLSchemeRegisteredAsBypassingContentSecurityPolicy");
    BLINK_BINDINGS_TRACE_EVENT("Internals.removeURLSchemeRegisteredAsBypassingContentSecurityPolicy");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    decltype(NativeValueTraits<IDLString>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg1_scheme;
    if (info[0]->IsString()) [[likely]] {
        arg1_scheme.Init(isolate, info[0].As<v8::String>());
    } else {
        ExceptionState exception_state(isolate);
        arg1_scheme = NativeValueTraits<IDLString>::ArgumentValue(isolate, 0, info[0], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    blink_receiver->removeURLSchemeRegisteredAsBypassingContentSecurityPolicy(arg1_scheme);
}

void RemoveVirtualPressureSourceOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_removeVirtualPressureSource");
    BLINK_BINDINGS_TRACE_EVENT("Internals.removeVirtualPressureSource");
    // Promise returning function: Convert a TypeError to a reject promise.
    ExceptionToRejectPromiseScope reject_promise_scope(info);

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    if (!V8Internals::HasInstance(isolate, v8_receiver)) {
        V8ThrowException::ThrowTypeError(isolate, "Illegal invocation");
        return;
    }

    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    const v8::ExceptionContext exception_context_type = v8::ExceptionContext::kOperation;
    const char* const class_like_name = "Internals";
    const char* const property_name = "removeVirtualPressureSource";
    ExceptionState exception_state(isolate, exception_context_type, class_like_name, property_name);
    auto&& arg1_source = NativeValueTraits<V8PressureSource>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    ScriptPromise<IDLUndefined> return_value = InternalsComputePressure::removeVirtualPressureSource(script_state, *blink_receiver, arg1_source);
    bindings::V8SetReturnValue(info, return_value);
}

void RemoveVirtualSensorOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_removeVirtualSensor");
    BLINK_BINDINGS_TRACE_EVENT("Internals.removeVirtualSensor");
    // Promise returning function: Convert a TypeError to a reject promise.
    ExceptionToRejectPromiseScope reject_promise_scope(info);

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    if (!V8Internals::HasInstance(isolate, v8_receiver)) {
        V8ThrowException::ThrowTypeError(isolate, "Illegal invocation");
        return;
    }

    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    const v8::ExceptionContext exception_context_type = v8::ExceptionContext::kOperation;
    const char* const class_like_name = "Internals";
    const char* const property_name = "removeVirtualSensor";
    ExceptionState exception_state(isolate, exception_context_type, class_like_name, property_name);
    auto&& arg1_type = NativeValueTraits<V8VirtualSensorType>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    ScriptPromise<IDLUndefined> return_value = InternalsSensor::removeVirtualSensor(script_state, *blink_receiver, arg1_type);
    bindings::V8SetReturnValue(info, return_value);
}

void ReplaceMisspelledOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_replaceMisspelled");
    BLINK_BINDINGS_TRACE_EVENT("Internals.replaceMisspelled");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_document = NativeValueTraits<Document>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_replacement = NativeValueTraits<IDLString>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->replaceMisspelled(arg1_document, arg2_replacement, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void ResetTypeAheadSessionOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_resetTypeAheadSession");
    BLINK_BINDINGS_TRACE_EVENT("Internals.resetTypeAheadSession");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_select = NativeValueTraits<HTMLSelectElement>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->resetTypeAheadSession(arg1_select);
}

void RTCCertificateEqualsOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_rtcCertificateEquals");
    BLINK_BINDINGS_TRACE_EVENT("Internals.rtcCertificateEquals");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_a = NativeValueTraits<RTCCertificate>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_b = NativeValueTraits<RTCCertificate>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = InternalsRTCCertificate::rtcCertificateEquals(*blink_receiver, arg1_a, arg2_b);
    static_assert(bindings::IsReturnTypeCompatible<IDLBoolean, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void RunFuzzerOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_runFuzzer");
    BLINK_BINDINGS_TRACE_EVENT("Internals.runFuzzer");
    // Promise returning function: Convert a TypeError to a reject promise.
    ExceptionToRejectPromiseScope reject_promise_scope(info);

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    if (!V8Internals::HasInstance(isolate, v8_receiver)) {
        V8ThrowException::ThrowTypeError(isolate, "Illegal invocation");
        return;
    }

    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    const v8::ExceptionContext exception_context_type = v8::ExceptionContext::kOperation;
    const char* const class_like_name = "Internals";
    const char* const property_name = "runFuzzer";
    ExceptionState exception_state(isolate, exception_context_type, class_like_name, property_name);
    auto&& arg1_fuzzer_id = NativeValueTraits<IDLString>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_fuzzer_data = NativeValueTraits<V8UnionArrayBufferOrArrayBufferView>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    ScriptPromise<IDLUndefined> return_value = InternalsFuzzing::runFuzzer(script_state, *blink_receiver, arg1_fuzzer_id, arg2_fuzzer_data);
    bindings::V8SetReturnValue(info, return_value);
}

void RunIdleTimeSpellCheckerOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_runIdleTimeSpellChecker");
    BLINK_BINDINGS_TRACE_EVENT("Internals.runIdleTimeSpellChecker");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_document = NativeValueTraits<Document>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->runIdleTimeSpellChecker(arg1_document, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void ScrollEventHandlerCountOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_scrollEventHandlerCount");
    BLINK_BINDINGS_TRACE_EVENT("Internals.scrollEventHandlerCount");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_document = NativeValueTraits<Document>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->scrollEventHandlerCount(arg1_document);
    static_assert(bindings::IsReturnTypeCompatible<IDLUnsignedLong, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<uint32_t>());
}

void SelectColorInColorChooserOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_selectColorInColorChooser");
    BLINK_BINDINGS_TRACE_EVENT("Internals.selectColorInColorChooser");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_element = NativeValueTraits<Element>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_color_value = NativeValueTraits<IDLString>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->selectColorInColorChooser(arg1_element, arg2_color_value);
}

void SelectFedCmAccountOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_selectFedCmAccount");
    BLINK_BINDINGS_TRACE_EVENT("Internals.selectFedCmAccount");
    // Promise returning function: Convert a TypeError to a reject promise.
    ExceptionToRejectPromiseScope reject_promise_scope(info);

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    if (!V8Internals::HasInstance(isolate, v8_receiver)) {
        V8ThrowException::ThrowTypeError(isolate, "Illegal invocation");
        return;
    }

    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    const v8::ExceptionContext exception_context_type = v8::ExceptionContext::kOperation;
    const char* const class_like_name = "Internals";
    const char* const property_name = "selectFedCmAccount";
    ExceptionState exception_state(isolate, exception_context_type, class_like_name, property_name);
    auto&& arg1_account_index = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    ScriptPromise<IDLUndefined> return_value = InternalsFedCm::selectFedCmAccount(script_state, *blink_receiver, arg1_account_index, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value);
}

void SelectMenuListTextOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_selectMenuListText");
    BLINK_BINDINGS_TRACE_EVENT("Internals.selectMenuListText");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_select = NativeValueTraits<HTMLSelectElement>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->selectMenuListText(arg1_select);
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void SelectPopupItemStyleFontHeightOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_selectPopupItemStyleFontHeight");
    BLINK_BINDINGS_TRACE_EVENT("Internals.selectPopupItemStyleFontHeight");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_select = NativeValueTraits<Node>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_item_index = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->selectPopupItemStyleFontHeight(arg1_select, arg2_item_index);
    static_assert(bindings::IsReturnTypeCompatible<IDLLong, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<int32_t>());
}

void SelectPopupItemStyleIsRtlOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_selectPopupItemStyleIsRtl");
    BLINK_BINDINGS_TRACE_EVENT("Internals.selectPopupItemStyleIsRtl");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_select = NativeValueTraits<Node>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_item_index = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->selectPopupItemStyleIsRtl(arg1_select, arg2_item_index);
    static_assert(bindings::IsReturnTypeCompatible<IDLBoolean, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void SelectedHTMLForClipboardOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_selectedHTMLForClipboard");
    BLINK_BINDINGS_TRACE_EVENT("Internals.selectedHTMLForClipboard");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->selectedHTMLForClipboard();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void SelectedTextForClipboardOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_selectedTextForClipboard");
    BLINK_BINDINGS_TRACE_EVENT("Internals.selectedTextForClipboard");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->selectedTextForClipboard();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void SelectionBoundsOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_selectionBounds");
    BLINK_BINDINGS_TRACE_EVENT("Internals.selectionBounds");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& return_value = blink_receiver->selectionBounds(exception_state);
    static_assert(bindings::IsReturnTypeCompatible<DOMRect, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void SequenceTestOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_sequenceTest");
    BLINK_BINDINGS_TRACE_EVENT("Internals.sequenceTest");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->sequenceTest();
    static_assert(bindings::IsReturnTypeCompatible<SequenceTest, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void SerializeObjectOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_serializeObject");
    BLINK_BINDINGS_TRACE_EVENT("Internals.serializeObject");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_obj = NativeValueTraits<IDLAny>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->serializeObject(isolate, arg1_obj, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<DOMArrayBuffer, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    v8::Local<v8::Value> v8_return_value = ToV8Traits<DOMArrayBuffer>::ToV8(script_state, return_value);
    bindings::V8SetReturnValue(info, v8_return_value);
}

void SetAllowPerChunkTransferringOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_setAllowPerChunkTransferring");
    BLINK_BINDINGS_TRACE_EVENT("Internals.setAllowPerChunkTransferring");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_stream = NativeValueTraits<ReadableStream>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setAllowPerChunkTransferring(arg1_stream);
}

void SetAutofilledOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_setAutofilled");
    BLINK_BINDINGS_TRACE_EVENT("Internals.setAutofilled");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_input_element = NativeValueTraits<Element>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_enabled = NativeValueTraits<IDLBoolean>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setAutofilled(arg1_input_element, arg2_enabled, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void SetAutofilledValueOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_setAutofilledValue");
    BLINK_BINDINGS_TRACE_EVENT("Internals.setAutofilledValue");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_input_element = NativeValueTraits<Element>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_value = NativeValueTraits<IDLString>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setAutofilledValue(arg1_input_element, arg2_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void SetBackForwardCacheRestorationBufferSizeOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_setBackForwardCacheRestorationBufferSize");
    BLINK_BINDINGS_TRACE_EVENT("Internals.setBackForwardCacheRestorationBufferSize");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_max_size = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setBackForwardCacheRestorationBufferSize(arg1_max_size);
}

void SetBrowserControlsShownRatioOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_setBrowserControlsShownRatio");
    BLINK_BINDINGS_TRACE_EVENT("Internals.setBrowserControlsShownRatio");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_top_ratio = NativeValueTraits<IDLFloat>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_bottom_ratio = NativeValueTraits<IDLFloat>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setBrowserControlsShownRatio(arg1_top_ratio, arg2_bottom_ratio);
}

void SetBrowserControlsStateOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_setBrowserControlsState");
    BLINK_BINDINGS_TRACE_EVENT("Internals.setBrowserControlsState");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 3) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(3, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_top_height = NativeValueTraits<IDLFloat>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_bottom_height = NativeValueTraits<IDLFloat>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_shrinks_layout = NativeValueTraits<IDLBoolean>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setBrowserControlsState(arg1_top_height, arg2_bottom_height, arg3_shrinks_layout);
}

void SetCapsLockStateOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_setCapsLockState");
    BLINK_BINDINGS_TRACE_EVENT("Internals.setCapsLockState");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_enabled = NativeValueTraits<IDLBoolean>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setCapsLockState(arg1_enabled);
}

void SetDarkPreferredColorSchemeOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_setDarkPreferredColorScheme");
    BLINK_BINDINGS_TRACE_EVENT("Internals.setDarkPreferredColorScheme");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_document = NativeValueTraits<Document>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setDarkPreferredColorScheme(arg1_document);
}

void SetDarkPreferredRootScrollbarColorSchemeOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_setDarkPreferredRootScrollbarColorScheme");
    BLINK_BINDINGS_TRACE_EVENT("Internals.setDarkPreferredRootScrollbarColorScheme");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_document = NativeValueTraits<Document>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setDarkPreferredRootScrollbarColorScheme(arg1_document);
}

void SetDeviceEmulationScaleOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_setDeviceEmulationScale");
    BLINK_BINDINGS_TRACE_EVENT("Internals.setDeviceEmulationScale");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_scale = NativeValueTraits<IDLFloat>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setDeviceEmulationScale(arg1_scale, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void SetDevicePostureOverrideOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_setDevicePostureOverride");
    BLINK_BINDINGS_TRACE_EVENT("Internals.setDevicePostureOverride");
    // Promise returning function: Convert a TypeError to a reject promise.
    ExceptionToRejectPromiseScope reject_promise_scope(info);

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    if (!V8Internals::HasInstance(isolate, v8_receiver)) {
        V8ThrowException::ThrowTypeError(isolate, "Illegal invocation");
        return;
    }

    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    const v8::ExceptionContext exception_context_type = v8::ExceptionContext::kOperation;
    const char* const class_like_name = "Internals";
    const char* const property_name = "setDevicePostureOverride";
    ExceptionState exception_state(isolate, exception_context_type, class_like_name, property_name);
    auto&& arg1_posture = NativeValueTraits<V8DevicePostureType>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    ScriptPromise<IDLUndefined> return_value = InternalsDevicePosture::setDevicePostureOverride(script_state, *blink_receiver, arg1_posture);
    bindings::V8SetReturnValue(info, return_value);
}

void SetEventTimingBufferSizeOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_setEventTimingBufferSize");
    BLINK_BINDINGS_TRACE_EVENT("Internals.setEventTimingBufferSize");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_max_size = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setEventTimingBufferSize(arg1_max_size);
}

void SetFocusedOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_setFocused");
    BLINK_BINDINGS_TRACE_EVENT("Internals.setFocused");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_focused = NativeValueTraits<IDLBoolean>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setFocused(arg1_focused);
}

void SetForcedColorsAndDarkPreferredColorSchemeOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_setForcedColorsAndDarkPreferredColorScheme");
    BLINK_BINDINGS_TRACE_EVENT("Internals.setForcedColorsAndDarkPreferredColorScheme");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_document = NativeValueTraits<Document>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setForcedColorsAndDarkPreferredColorScheme(arg1_document);
}

void SetFormControlStateOfHistoryItemOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_setFormControlStateOfHistoryItem");
    BLINK_BINDINGS_TRACE_EVENT("Internals.setFormControlStateOfHistoryItem");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_values = NativeValueTraits<IDLSequence<IDLString>>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setFormControlStateOfHistoryItem(std::move(arg1_values), exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void SetInitialFocusOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_setInitialFocus");
    BLINK_BINDINGS_TRACE_EVENT("Internals.setInitialFocus");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_reverse = NativeValueTraits<IDLBoolean>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setInitialFocus(arg1_reverse);
}

void SetIsAdFrameOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_setIsAdFrame");
    BLINK_BINDINGS_TRACE_EVENT("Internals.setIsAdFrame");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_target_doc = NativeValueTraits<Document>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setIsAdFrame(arg1_target_doc, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void SetIsCursorVisibleOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_setIsCursorVisible");
    BLINK_BINDINGS_TRACE_EVENT("Internals.setIsCursorVisible");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_document = NativeValueTraits<Document>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_is_visible = NativeValueTraits<IDLBoolean>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setIsCursorVisible(arg1_document, arg2_is_visible, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void SetIsLowEndDeviceOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_setIsLowEndDevice");
    BLINK_BINDINGS_TRACE_EVENT("Internals.setIsLowEndDevice");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_is_low_end_device = NativeValueTraits<IDLBoolean>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setIsLowEndDevice(arg1_is_low_end_device);
}

void SetMarkerOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_setMarker");
    BLINK_BINDINGS_TRACE_EVENT("Internals.setMarker");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 3) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(3, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_document = NativeValueTraits<Document>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_range = NativeValueTraits<Range>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_marker_type = NativeValueTraits<IDLString>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setMarker(arg1_document, arg2_range, arg3_marker_type, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void SetMaxNumberOfFramesToTenOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_setMaxNumberOfFramesToTen");
    BLINK_BINDINGS_TRACE_EVENT("Internals.setMaxNumberOfFramesToTen");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_enable = NativeValueTraits<IDLBoolean>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setMaxNumberOfFramesToTen(arg1_enable);
}

void SetMediaControlsTestModeOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_setMediaControlsTestMode");
    BLINK_BINDINGS_TRACE_EVENT("Internals.setMediaControlsTestMode");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_media_element = NativeValueTraits<HTMLMediaElement>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_enable = NativeValueTraits<IDLBoolean>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setMediaControlsTestMode(arg1_media_element, arg2_enable);
}

void SetMockHyphenationOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_setMockHyphenation");
    BLINK_BINDINGS_TRACE_EVENT("Internals.setMockHyphenation");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    decltype(NativeValueTraits<IDLString>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg1_locale;
    if (info[0]->IsString()) [[likely]] {
        arg1_locale.Init(isolate, info[0].As<v8::String>());
    } else {
        ExceptionState exception_state(isolate);
        arg1_locale = NativeValueTraits<IDLString>::ArgumentValue(isolate, 0, info[0], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    blink_receiver->setMockHyphenation(arg1_locale);
}

void SetNetworkConnectionInfoOverrideOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_setNetworkConnectionInfoOverride");
    BLINK_BINDINGS_TRACE_EVENT("Internals.setNetworkConnectionInfoOverride");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 5) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(5, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_on_line = NativeValueTraits<IDLBoolean>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_type = NativeValueTraits<IDLString>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_effective_type = NativeValueTraits<V8EffectiveConnectionType>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg4_http_rtt_msec = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 3, info[3], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg5_downlink_max_mbps = NativeValueTraits<IDLDouble>::ArgumentValue(isolate, 4, info[4], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    InternalsNetInfo::setNetworkConnectionInfoOverride(
        *blink_receiver, arg1_on_line, arg2_type, arg3_effective_type, arg4_http_rtt_msec, arg5_downlink_max_mbps, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void SetPageScaleFactorOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_setPageScaleFactor");
    BLINK_BINDINGS_TRACE_EVENT("Internals.setPageScaleFactor");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_scale_factor = NativeValueTraits<IDLFloat>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setPageScaleFactor(arg1_scale_factor, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void SetPageScaleFactorLimitsOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_setPageScaleFactorLimits");
    BLINK_BINDINGS_TRACE_EVENT("Internals.setPageScaleFactorLimits");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_min_scale_factor = NativeValueTraits<IDLFloat>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_max_scale_factor = NativeValueTraits<IDLFloat>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setPageScaleFactorLimits(arg1_min_scale_factor, arg2_max_scale_factor, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void SetPermissionOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_setPermission");
    BLINK_BINDINGS_TRACE_EVENT("Internals.setPermission");
    // Promise returning function: Convert a TypeError to a reject promise.
    ExceptionToRejectPromiseScope reject_promise_scope(info);

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    if (!V8Internals::HasInstance(isolate, v8_receiver)) {
        V8ThrowException::ThrowTypeError(isolate, "Illegal invocation");
        return;
    }

    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    const v8::ExceptionContext exception_context_type = v8::ExceptionContext::kOperation;
    const char* const class_like_name = "Internals";
    const char* const property_name = "setPermission";
    ExceptionState exception_state(isolate, exception_context_type, class_like_name, property_name);
    auto&& arg1_descriptor = NativeValueTraits<IDLObject>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_state = NativeValueTraits<V8PermissionState>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    ScriptPromise<IDLUndefined> return_value = InternalsPermission::setPermission(script_state, *blink_receiver, arg1_descriptor, arg2_state, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value);
}

void SetPersistentOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_setPersistent");
    BLINK_BINDINGS_TRACE_EVENT("Internals.setPersistent");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_video = NativeValueTraits<HTMLVideoElement>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_persistent = NativeValueTraits<IDLBoolean>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setPersistent(arg1_video, arg2_persistent);
}

void SetPseudoClassStateOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_setPseudoClassState");
    BLINK_BINDINGS_TRACE_EVENT("Internals.setPseudoClassState");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 3) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(3, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_element = NativeValueTraits<Element>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_pseudo = NativeValueTraits<IDLString>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_enabled = NativeValueTraits<IDLBoolean>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setPseudoClassState(arg1_element, arg2_pseudo, arg3_enabled, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void SetSaveDataEnabledOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_setSaveDataEnabled");
    BLINK_BINDINGS_TRACE_EVENT("Internals.setSaveDataEnabled");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_enabled = NativeValueTraits<IDLBoolean>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    InternalsNetInfo::setSaveDataEnabled(*blink_receiver, arg1_enabled);
}

void SetScrollbarVisibilityInScrollableAreaOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_setScrollbarVisibilityInScrollableArea");
    BLINK_BINDINGS_TRACE_EVENT("Internals.setScrollbarVisibilityInScrollableArea");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_node = NativeValueTraits<Node>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_visible = NativeValueTraits<IDLBoolean>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->setScrollbarVisibilityInScrollableArea(arg1_node, arg2_visible);
    static_assert(bindings::IsReturnTypeCompatible<IDLBoolean, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void SetSelectionRangeForNumberTypeOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_setSelectionRangeForNumberType");
    BLINK_BINDINGS_TRACE_EVENT("Internals.setSelectionRangeForNumberType");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 3) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(3, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_input_element = NativeValueTraits<Element>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_start = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_end = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setSelectionRangeForNumberType(arg1_input_element, arg2_start, arg3_end, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void SetShouldRevealPasswordOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_setShouldRevealPassword");
    BLINK_BINDINGS_TRACE_EVENT("Internals.setShouldRevealPassword");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_element = NativeValueTraits<Element>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_reveal = NativeValueTraits<IDLBoolean>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setShouldRevealPassword(arg1_element, arg2_reveal, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void SetStorageAccessOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_setStorageAccess");
    BLINK_BINDINGS_TRACE_EVENT("Internals.setStorageAccess");
    // Promise returning function: Convert a TypeError to a reject promise.
    ExceptionToRejectPromiseScope reject_promise_scope(info);

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    if (!V8Internals::HasInstance(isolate, v8_receiver)) {
        V8ThrowException::ThrowTypeError(isolate, "Illegal invocation");
        return;
    }

    if (info.Length() < 3) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(3, info.Length()));
        return;
    }

    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    const v8::ExceptionContext exception_context_type = v8::ExceptionContext::kOperation;
    const char* const class_like_name = "Internals";
    const char* const property_name = "setStorageAccess";
    ExceptionState exception_state(isolate, exception_context_type, class_like_name, property_name);
    auto&& arg1_origin = NativeValueTraits<IDLUSVString>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_embedding_origin = NativeValueTraits<IDLUSVString>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_blocked = NativeValueTraits<IDLBoolean>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    ScriptPromise<IDLUndefined> return_value
        = InternalsStorageAccess::setStorageAccess(script_state, *blink_receiver, arg1_origin, arg2_embedding_origin, arg3_blocked, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value);
}

void SetSuggestedValueOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_setSuggestedValue");
    BLINK_BINDINGS_TRACE_EVENT("Internals.setSuggestedValue");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_input_element = NativeValueTraits<Element>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_value = NativeValueTraits<IDLString>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setSuggestedValue(arg1_input_element, arg2_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void SetSystemTimeZoneOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_setSystemTimeZone");
    BLINK_BINDINGS_TRACE_EVENT("Internals.setSystemTimeZone");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    decltype(NativeValueTraits<IDLString>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg1_timezone;
    if (info[0]->IsString()) [[likely]] {
        arg1_timezone.Init(isolate, info[0].As<v8::String>());
    } else {
        ExceptionState exception_state(isolate);
        arg1_timezone = NativeValueTraits<IDLString>::ArgumentValue(isolate, 0, info[0], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    blink_receiver->setSystemTimeZone(arg1_timezone);
}

void SetTextMatchMarkersActiveOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_setTextMatchMarkersActive");
    BLINK_BINDINGS_TRACE_EVENT("Internals.setTextMatchMarkersActive");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 4) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(4, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_node = NativeValueTraits<Node>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_start_offset = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_end_offset = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg4_active = NativeValueTraits<IDLBoolean>::ArgumentValue(isolate, 3, info[3], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setTextMatchMarkersActive(arg1_node, arg2_start_offset, arg3_end_offset, arg4_active);
}

void SetUserPreferredLanguagesOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_setUserPreferredLanguages");
    BLINK_BINDINGS_TRACE_EVENT("Internals.setUserPreferredLanguages");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_languages = NativeValueTraits<IDLSequence<IDLString>>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setUserPreferredLanguages(std::move(arg1_languages));
}

void SetValueForUserOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_setValueForUser");
    BLINK_BINDINGS_TRACE_EVENT("Internals.setValueForUser");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_element = NativeValueTraits<HTMLInputElement>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_value = NativeValueTraits<IDLString>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setValueForUser(arg1_element, arg2_value);
}

void SetVisualViewportOffsetOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_setVisualViewportOffset");
    BLINK_BINDINGS_TRACE_EVENT("Internals.setVisualViewportOffset");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_x = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_y = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setVisualViewportOffset(arg1_x, arg2_y);
}

void ShadowPseudoIdOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_shadowPseudoId");
    BLINK_BINDINGS_TRACE_EVENT("Internals.shadowPseudoId");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_element = NativeValueTraits<Element>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->shadowPseudoId(arg1_element);
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void ShadowRootOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_shadowRoot");
    BLINK_BINDINGS_TRACE_EVENT("Internals.shadowRoot");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_host = NativeValueTraits<Element>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->shadowRoot(arg1_host);
    static_assert(bindings::IsReturnTypeCompatible<ShadowRoot, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void ShortcutIconURLsOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_shortcutIconURLs");
    BLINK_BINDINGS_TRACE_EVENT("Internals.shortcutIconURLs");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_document = NativeValueTraits<Document>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->shortcutIconURLs(arg1_document);
    static_assert(bindings::IsReturnTypeCompatible<IDLSequence<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    v8::Local<v8::Value> v8_return_value = ToV8Traits<IDLSequence<IDLString>>::ToV8(script_state, return_value);
    bindings::V8SetReturnValue(info, v8_return_value);
}

void SimulateRasterUnderInvalidationsOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_simulateRasterUnderInvalidations");
    BLINK_BINDINGS_TRACE_EVENT("Internals.simulateRasterUnderInvalidations");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_enable = NativeValueTraits<IDLBoolean>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->simulateRasterUnderInvalidations(arg1_enable);
}

void SpellCheckedTextLengthOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_spellCheckedTextLength");
    BLINK_BINDINGS_TRACE_EVENT("Internals.spellCheckedTextLength");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_document = NativeValueTraits<Document>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->spellCheckedTextLength(arg1_document, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<IDLLong, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<int32_t>());
}

void StartTrackingRepaintsOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_startTrackingRepaints");
    BLINK_BINDINGS_TRACE_EVENT("Internals.startTrackingRepaints");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_document = NativeValueTraits<Document>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->startTrackingRepaints(arg1_document, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void StopResponsivenessMetricsUkmSamplingOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_stopResponsivenessMetricsUkmSampling");
    BLINK_BINDINGS_TRACE_EVENT("Internals.stopResponsivenessMetricsUkmSampling");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->stopResponsivenessMetricsUkmSampling();
}

void StopTrackingRepaintsOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_stopTrackingRepaints");
    BLINK_BINDINGS_TRACE_EVENT("Internals.stopTrackingRepaints");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_document = NativeValueTraits<Document>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->stopTrackingRepaints(arg1_document, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void StyleForElementCountOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_styleForElementCount");
    BLINK_BINDINGS_TRACE_EVENT("Internals.styleForElementCount");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& return_value = blink_receiver->styleForElementCount(exception_state);
    static_assert(bindings::IsReturnTypeCompatible<IDLUnsignedLong, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<uint32_t>());
}

void SuggestedValueOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_suggestedValue");
    BLINK_BINDINGS_TRACE_EVENT("Internals.suggestedValue");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_input_element = NativeValueTraits<Element>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->suggestedValue(arg1_input_element, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void SupportedTextEncodingLabelsOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_supportedTextEncodingLabels");
    BLINK_BINDINGS_TRACE_EVENT("Internals.supportedTextEncodingLabels");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->supportedTextEncodingLabels();
    static_assert(bindings::IsReturnTypeCompatible<IDLSequence<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    v8::Local<v8::Value> v8_return_value = ToV8Traits<IDLSequence<IDLString>>::ToV8(script_state, return_value);
    bindings::V8SetReturnValue(info, v8_return_value);
}

void SVGNamespaceOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_svgNamespace");
    BLINK_BINDINGS_TRACE_EVENT("Internals.svgNamespace");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->svgNamespace();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void SVGTagsOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_svgTags");
    BLINK_BINDINGS_TRACE_EVENT("Internals.svgTags");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->svgTags();
    static_assert(bindings::IsReturnTypeCompatible<IDLSequence<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    v8::Local<v8::Value> v8_return_value = ToV8Traits<IDLSequence<IDLString>>::ToV8(script_state, return_value);
    bindings::V8SetReturnValue(info, v8_return_value);
}

void TerminateServiceWorkerOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_terminateServiceWorker");
    BLINK_BINDINGS_TRACE_EVENT("Internals.terminateServiceWorker");
    // Promise returning function: Convert a TypeError to a reject promise.
    ExceptionToRejectPromiseScope reject_promise_scope(info);

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    if (!V8Internals::HasInstance(isolate, v8_receiver)) {
        V8ThrowException::ThrowTypeError(isolate, "Illegal invocation");
        return;
    }

    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    const v8::ExceptionContext exception_context_type = v8::ExceptionContext::kOperation;
    const char* const class_like_name = "Internals";
    const char* const property_name = "terminateServiceWorker";
    ExceptionState exception_state(isolate, exception_context_type, class_like_name, property_name);
    auto&& arg1_worker = NativeValueTraits<ServiceWorker>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    ScriptPromise<IDLUndefined> return_value = InternalsServiceWorker::terminateServiceWorker(script_state, *blink_receiver, arg1_worker);
    bindings::V8SetReturnValue(info, return_value);
}

void TouchEndOrCancelEventHandlerCountOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_touchEndOrCancelEventHandlerCount");
    BLINK_BINDINGS_TRACE_EVENT("Internals.touchEndOrCancelEventHandlerCount");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_document = NativeValueTraits<Document>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->touchEndOrCancelEventHandlerCount(arg1_document);
    static_assert(bindings::IsReturnTypeCompatible<IDLUnsignedLong, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<uint32_t>());
}

void TouchEventTargetLayerRectsOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_touchEventTargetLayerRects");
    BLINK_BINDINGS_TRACE_EVENT("Internals.touchEventTargetLayerRects");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_document = NativeValueTraits<Document>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->touchEventTargetLayerRects(arg1_document, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<HitTestLayerRectList, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void TouchNodeAdjustedToBestClickableNodeOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_touchNodeAdjustedToBestClickableNode");
    BLINK_BINDINGS_TRACE_EVENT("Internals.touchNodeAdjustedToBestClickableNode");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 5) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(5, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_x = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_y = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_width = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg4_height = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 3, info[3], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg5_document = NativeValueTraits<Document>::ArgumentValue(isolate, 4, info[4], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->touchNodeAdjustedToBestClickableNode(arg1_x, arg2_y, arg3_width, arg4_height, arg5_document, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<Node, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void TouchNodeAdjustedToBestContextMenuNodeOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_touchNodeAdjustedToBestContextMenuNode");
    BLINK_BINDINGS_TRACE_EVENT("Internals.touchNodeAdjustedToBestContextMenuNode");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 5) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(5, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_x = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_y = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_width = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg4_height = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 3, info[3], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg5_document = NativeValueTraits<Document>::ArgumentValue(isolate, 4, info[4], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->touchNodeAdjustedToBestContextMenuNode(arg1_x, arg2_y, arg3_width, arg4_height, arg5_document, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<Node, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void TouchNodeAdjustedToBestStylusWritableNodeOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_touchNodeAdjustedToBestStylusWritableNode");
    BLINK_BINDINGS_TRACE_EVENT("Internals.touchNodeAdjustedToBestStylusWritableNode");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 5) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(5, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_x = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_y = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_width = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg4_height = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 3, info[3], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg5_document = NativeValueTraits<Document>::ArgumentValue(isolate, 4, info[4], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->touchNodeAdjustedToBestStylusWritableNode(arg1_x, arg2_y, arg3_width, arg4_height, arg5_document, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<Node, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void TouchPositionAdjustedToBestClickableNodeOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_touchPositionAdjustedToBestClickableNode");
    BLINK_BINDINGS_TRACE_EVENT("Internals.touchPositionAdjustedToBestClickableNode");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 5) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(5, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_x = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_y = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_width = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg4_height = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 3, info[3], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg5_document = NativeValueTraits<Document>::ArgumentValue(isolate, 4, info[4], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->touchPositionAdjustedToBestClickableNode(arg1_x, arg2_y, arg3_width, arg4_height, arg5_document, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<DOMPoint, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void TouchPositionAdjustedToBestContextMenuNodeOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_touchPositionAdjustedToBestContextMenuNode");
    BLINK_BINDINGS_TRACE_EVENT("Internals.touchPositionAdjustedToBestContextMenuNode");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 5) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(5, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_x = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_y = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_width = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg4_height = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 3, info[3], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg5_document = NativeValueTraits<Document>::ArgumentValue(isolate, 4, info[4], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->touchPositionAdjustedToBestContextMenuNode(arg1_x, arg2_y, arg3_width, arg4_height, arg5_document, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<DOMPoint, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void TouchStartOrMoveEventHandlerCountOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_touchStartOrMoveEventHandlerCount");
    BLINK_BINDINGS_TRACE_EVENT("Internals.touchStartOrMoveEventHandlerCount");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_document = NativeValueTraits<Document>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->touchStartOrMoveEventHandlerCount(arg1_document);
    static_assert(bindings::IsReturnTypeCompatible<IDLUnsignedLong, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<uint32_t>());
}

void TreeScopeRootNodeOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_treeScopeRootNode");
    BLINK_BINDINGS_TRACE_EVENT("Internals.treeScopeRootNode");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_node = NativeValueTraits<Node>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->treeScopeRootNode(arg1_node);
    static_assert(bindings::IsReturnTypeCompatible<Node, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void TriggerTestInspectorIssueOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_triggerTestInspectorIssue");
    BLINK_BINDINGS_TRACE_EVENT("Internals.triggerTestInspectorIssue");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_document = NativeValueTraits<Document>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->triggerTestInspectorIssue(arg1_document);
}

void TypeConversionsOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_typeConversions");
    BLINK_BINDINGS_TRACE_EVENT("Internals.typeConversions");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->typeConversions();
    static_assert(bindings::IsReturnTypeCompatible<TypeConversions, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void UnionTypesTestOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_unionTypesTest");
    BLINK_BINDINGS_TRACE_EVENT("Internals.unionTypesTest");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->unionTypesTest();
    static_assert(bindings::IsReturnTypeCompatible<UnionTypesTest, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void UnscopableMethodOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_unscopableMethod");
    BLINK_BINDINGS_TRACE_EVENT("Internals.unscopableMethod");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->unscopableMethod();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void UpdateLayoutAndRunPostLayoutTasksOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_updateLayoutAndRunPostLayoutTasks");
    BLINK_BINDINGS_TRACE_EVENT("Internals.updateLayoutAndRunPostLayoutTasks");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    decltype(NativeValueTraits<IDLNullable<Node>>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg1_node { nullptr };
    ExceptionState exception_state(isolate);
    if (!info[0]->IsUndefined()) {
        arg1_node = NativeValueTraits<IDLNullable<Node>>::ArgumentValue(isolate, 0, info[0], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    blink_receiver->updateLayoutAndRunPostLayoutTasks(arg1_node, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void UpdateStyleAndReturnAffectedElementCountOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_updateStyleAndReturnAffectedElementCount");
    BLINK_BINDINGS_TRACE_EVENT("Internals.updateStyleAndReturnAffectedElementCount");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& return_value = blink_receiver->updateStyleAndReturnAffectedElementCount(exception_state);
    static_assert(bindings::IsReturnTypeCompatible<IDLUnsignedLong, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<uint32_t>());
}

void UpdateVirtualPressureSourceOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_updateVirtualPressureSource");
    BLINK_BINDINGS_TRACE_EVENT("Internals.updateVirtualPressureSource");
    // Promise returning function: Convert a TypeError to a reject promise.
    ExceptionToRejectPromiseScope reject_promise_scope(info);

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    if (!V8Internals::HasInstance(isolate, v8_receiver)) {
        V8ThrowException::ThrowTypeError(isolate, "Illegal invocation");
        return;
    }

    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    const v8::ExceptionContext exception_context_type = v8::ExceptionContext::kOperation;
    const char* const class_like_name = "Internals";
    const char* const property_name = "updateVirtualPressureSource";
    ExceptionState exception_state(isolate, exception_context_type, class_like_name, property_name);
    auto&& arg1_source = NativeValueTraits<V8PressureSource>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_state = NativeValueTraits<V8PressureState>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    ScriptPromise<IDLUndefined> return_value = InternalsComputePressure::updateVirtualPressureSource(script_state, *blink_receiver, arg1_source, arg2_state);
    bindings::V8SetReturnValue(info, return_value);
}

void UpdateVirtualSensorOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_updateVirtualSensor");
    BLINK_BINDINGS_TRACE_EVENT("Internals.updateVirtualSensor");
    // Promise returning function: Convert a TypeError to a reject promise.
    ExceptionToRejectPromiseScope reject_promise_scope(info);

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    if (!V8Internals::HasInstance(isolate, v8_receiver)) {
        V8ThrowException::ThrowTypeError(isolate, "Illegal invocation");
        return;
    }

    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    const v8::ExceptionContext exception_context_type = v8::ExceptionContext::kOperation;
    const char* const class_like_name = "Internals";
    const char* const property_name = "updateVirtualSensor";
    ExceptionState exception_state(isolate, exception_context_type, class_like_name, property_name);
    auto&& arg1_type = NativeValueTraits<V8VirtualSensorType>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_reading = NativeValueTraits<VirtualSensorReading>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    ScriptPromise<IDLUndefined> return_value = InternalsSensor::updateVirtualSensor(script_state, *blink_receiver, arg1_type, arg2_reading);
    bindings::V8SetReturnValue(info, return_value);
}

void UseMockOverlayScrollbarsOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_useMockOverlayScrollbars");
    BLINK_BINDINGS_TRACE_EVENT("Internals.useMockOverlayScrollbars");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->useMockOverlayScrollbars();
}

void UserPreferredLanguagesOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_userPreferredLanguages");
    BLINK_BINDINGS_TRACE_EVENT("Internals.userPreferredLanguages");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->userPreferredLanguages();
    static_assert(bindings::IsReturnTypeCompatible<IDLSequence<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    v8::Local<v8::Value> v8_return_value = ToV8Traits<IDLSequence<IDLString>>::ToV8(script_state, return_value);
    bindings::V8SetReturnValue(info, v8_return_value);
}

void ViewportAsTextOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_viewportAsText");
    BLINK_BINDINGS_TRACE_EVENT("Internals.viewportAsText");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 4) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(4, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_document = NativeValueTraits<Document>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_device_pixel_ratio = NativeValueTraits<IDLFloat>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_available_width = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg4_available_height = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 3, info[3], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->viewportAsText(arg1_document, arg2_device_pixel_ratio, arg3_available_width, arg4_available_height, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void WaitForPeerConnectionDispatchEventsTaskCreatedOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_waitForPeerConnectionDispatchEventsTaskCreated");
    BLINK_BINDINGS_TRACE_EVENT("Internals.waitForPeerConnectionDispatchEventsTaskCreated");
    // Promise returning function: Convert a TypeError to a reject promise.
    ExceptionToRejectPromiseScope reject_promise_scope(info);

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    if (!V8Internals::HasInstance(isolate, v8_receiver)) {
        V8ThrowException::ThrowTypeError(isolate, "Illegal invocation");
        return;
    }

    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    const v8::ExceptionContext exception_context_type = v8::ExceptionContext::kOperation;
    const char* const class_like_name = "Internals";
    const char* const property_name = "waitForPeerConnectionDispatchEventsTaskCreated";
    ExceptionState exception_state(isolate, exception_context_type, class_like_name, property_name);
    auto&& arg1_connection = NativeValueTraits<RTCPeerConnection>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    ScriptPromise<IDLAny> return_value
        = InternalsRTCPeerConnection::waitForPeerConnectionDispatchEventsTaskCreated(script_state, *blink_receiver, arg1_connection);
    bindings::V8SetReturnValue(info, return_value);
}

void WheelEventHandlerCountOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_wheelEventHandlerCount");
    BLINK_BINDINGS_TRACE_EVENT("Internals.wheelEventHandlerCount");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_document = NativeValueTraits<Document>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->wheelEventHandlerCount(arg1_document);
    static_assert(bindings::IsReturnTypeCompatible<IDLUnsignedLong, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<uint32_t>());
}

void ZeroBasedDocumentTimeToMonotonicTimeOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_Internals_zeroBasedDocumentTimeToMonotonicTime");
    BLINK_BINDINGS_TRACE_EVENT("Internals.zeroBasedDocumentTimeToMonotonicTime");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    Internals* blink_receiver = V8Internals::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_dom_high_res_time_stamp = NativeValueTraits<IDLDouble>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->zeroBasedDocumentTimeToMonotonicTime(arg1_dom_high_res_time_stamp);
    static_assert(bindings::IsReturnTypeCompatible<IDLLongLong, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<int64_t>());
}

} // namespace v8_internals

using namespace v8_internals;

} // namespace

void V8Internals::Impl::InstallInterfaceTemplate(v8::Isolate* isolate, const DOMWrapperWorld& world, v8::Local<v8::Template> interface_template)
{
    const WrapperTypeInfo* const wrapper_type_info = V8Internals::GetWrapperTypeInfo();
    v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
    v8::Local<v8::ObjectTemplate> instance_object_template = interface_function_template->InstanceTemplate();
    v8::Local<v8::ObjectTemplate> prototype_object_template = interface_function_template->PrototypeTemplate();
    v8::Local<v8::FunctionTemplate> parent_interface_template;
    bindings::SetupIDLInterfaceTemplate(
        isolate, wrapper_type_info, instance_object_template, prototype_object_template, interface_function_template, parent_interface_template);

    // Indexed interceptors
    instance_object_template->SetHandler(
        v8::IndexedPropertyHandlerConfiguration(V8Internals::IndexedPropertyGetterCallback, V8Internals::IndexedPropertySetterCallback,
            nullptr, // query
            V8Internals::IndexedPropertyDeleterCallback, V8Internals::IndexedPropertyEnumeratorCallback, V8Internals::IndexedPropertyDefinerCallback,
            V8Internals::IndexedPropertyDescriptorCallback, v8::Local<v8::Value>(), v8::PropertyHandlerFlags::kHasNoSideEffect));

    v8::Local<v8::Template> prototype_template = prototype_object_template;
    // @@iterator for indexed properties
    // https://webidl.spec.whatwg.org/#define-the-iteration-methods
    prototype_template->SetIntrinsicDataProperty(v8::Symbol::GetIterator(isolate), v8::kArrayProto_values, v8::DontEnum);

    // Value iterator's properties
    // https://webidl.spec.whatwg.org/#define-the-iteration-methods
    prototype_template->SetIntrinsicDataProperty(V8AtomicString(isolate, "entries"), v8::kArrayProto_entries, v8::None);
    prototype_template->SetIntrinsicDataProperty(V8AtomicString(isolate, "keys"), v8::kArrayProto_keys, v8::None);
    prototype_template->SetIntrinsicDataProperty(V8AtomicString(isolate, "values"), v8::kArrayProto_values, v8::None);
    prototype_template->SetIntrinsicDataProperty(V8AtomicString(isolate, "forEach"), v8::kArrayProto_forEach, v8::None);

    v8::Local<v8::Template> instance_template = instance_object_template;
    InstallUnconditionalProperties(isolate, world, instance_template, prototype_template, interface_template);
}

void V8Internals::Impl::InstallUnconditionalProperties(v8::Isolate* isolate, const DOMWrapperWorld& world, v8::Local<v8::Template> instance_template,
    v8::Local<v8::Template> prototype_template, v8::Local<v8::Template> interface_template)
{
    using bindings::IDLMemberInstaller;

    v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
    v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
    {
        static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
            { "pagePopupWindow", "Internals", PagePopupWindowAttributeGetCallback, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "settings", "Internals", SettingsAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "runtimeFlags", "Internals", RuntimeFlagsAttributeGetCallback, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "workerThreadCount", "Internals", WorkerThreadCountAttributeGetCallback, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "cursorUpdatePending", "Internals", CursorUpdatePendingAttributeGetCallback, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "visibleSelectionAnchorNode", "Internals", VisibleSelectionAnchorNodeAttributeGetCallback, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "visibleSelectionAnchorOffset", "Internals", VisibleSelectionAnchorOffsetAttributeGetCallback, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "visibleSelectionFocusNode", "Internals", VisibleSelectionFocusNodeAttributeGetCallback, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "visibleSelectionFocusOffset", "Internals", VisibleSelectionFocusOffsetAttributeGetCallback, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "textAffinity", "Internals", TextAffinityAttributeGetCallback, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "length", "Internals", LengthAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "unscopableAttribute", "Internals", UnscopableAttributeAttributeGetCallback, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "overlayScrollbarsEnabled", "Internals", OverlayScrollbarsEnabledAttributeGetCallback, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "peerConnectionCountLimit", "Internals", PeerConnectionCountLimitAttributeGetCallback, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
        };
        IDLMemberInstaller::InstallAttributes(isolate, world, instance_template, prototype_template, interface_template, signature, kAttributeTable);
    }

    {
        static const IDLMemberInstaller::ConstantValueConfig kConstantValueTable[] = {
            { "LAYER_TREE_INCLUDES_INVALIDATIONS", V8Internals::Constant::kLayerTreeIncludesInvalidations },
            { "LAYER_TREE_INCLUDES_DETAILED_INVALIDATIONS", V8Internals::Constant::kLayerTreeIncludesDetailedInvalidations },
        };
        IDLMemberInstaller::InstallConstants(isolate, world, instance_template, prototype_template, interface_template, signature, kConstantValueTable);
    }

    {
        static const IDLMemberInstaller::OperationConfig kOperationTable[] = {
            { "DisableIntersectionObserverThrottleDelay", "Internals", DisableIntersectionObserverThrottleDelayOperationCallback, 0, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "LCPPrediction", "Internals", LCPPredictionOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kDoNotCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "SetSupportsDraggableRegions", "Internals", SetSupportsDraggableRegionsOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "ShadowRootMode", "Internals", ShadowRootModeOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "absoluteCaretBounds", "Internals", AbsoluteCaretBoundsOperationCallback, 0, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "activeMarkerCountForNode", "Internals", ActiveMarkerCountForNodeOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "addActiveSuggestionMarker", "Internals", AddActiveSuggestionMarkerOperationCallback, 4, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "addCompositionMarker", "Internals", AddCompositionMarkerOperationCallback, 6, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "addEmbedderCustomElementName", "Internals", AddEmbedderCustomElementNameOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "addFakeDevice", "Internals", AddFakeDeviceOperationCallback, 3, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kDoNotCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "addOneToPromise", "Internals", AddOneToPromiseOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kDoNotCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "addSuggestionMarker", "Internals", AddSuggestionMarkerOperationCallback, 6, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "addTextMatchMarker", "Internals", AddTextMatchMarkerOperationCallback, 2, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "advanceImageAnimation", "Internals", AdvanceImageAnimationOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "allIconURLs", "Internals", AllIconURLsOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "audioHandlerCount", "Internals", AudioHandlerCountOperationCallback, 0, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "audioWorkletProcessorCount", "Internals", AudioWorkletProcessorCountOperationCallback, 0, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "boundingBox", "Internals", BoundingBoxOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "callbackFunctionTest", "Internals", CallbackFunctionTestOperationCallback, 0, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "canHyphenate", "Internals", CanHyphenateOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "cancelCurrentSpellCheckRequest", "Internals", CancelCurrentSpellCheckRequestOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "canvasFontCacheMaxFonts", "Internals", CanvasFontCacheMaxFontsOperationCallback, 0, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "clearDevicePostureOverride", "Internals", ClearDevicePostureOverrideOperationCallback, 0, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kDoNotCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "clearHitTestCache", "Internals", ClearHitTestCacheOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "clearNetworkConnectionInfoOverride", "Internals", ClearNetworkConnectionInfoOverrideOperationCallback, 0, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "clearUseCounter", "Internals", ClearUseCounterOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "clickFedCmDialogButton", "Internals", ClickFedCmDialogButtonOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kDoNotCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "collectSample", "Internals", CollectSampleOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "compareTreeScopePosition", "Internals", CompareTreeScopePositionOperationCallback, 2, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "computedStyleIncludingVisitedInfo", "Internals", ComputedStyleIncludingVisitedInfoOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "countElementShadow", "Internals", CountElementShadowOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "counterValue", "Internals", CounterValueOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "crash", "Internals", CrashOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "createReadableStream", "Internals", CreateReadableStreamOperationCallback, 2, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "createRejectedPromise", "Internals", CreateRejectedPromiseOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kDoNotCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "createResolvedPromise", "Internals", CreateResolvedPromiseOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kDoNotCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "createUserAgentShadowRoot", "Internals", CreateUserAgentShadowRootOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "createVirtualPressureSource", "Internals", CreateVirtualPressureSourceOperationCallback, 2, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kDoNotCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "createVirtualSensor", "Internals", CreateVirtualSensorOperationCallback, 2, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kDoNotCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "createWritableStreamAndSink", "Internals", CreateWritableStreamAndSinkOperationCallback, 2, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "currentTimeTicks", "Internals", CurrentTimeTicksOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "deleteAllCookies", "Internals", DeleteAllCookiesOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kDoNotCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "deserializeBuffer", "Internals", DeserializeBufferOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "dictionaryTest", "Internals", DictionaryTestOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "disableCanvasAcceleration", "Internals", DisableCanvasAccelerationOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "disableCompositedAnimation", "Internals", DisableCompositedAnimationOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "disableReferencedFilePathsVerification", "Internals", DisableReferencedFilePathsVerificationOperationCallback, 0, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "dismissFedCmDialog", "Internals", DismissFedCmDialogOperationCallback, 0, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kDoNotCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "doesWindowHaveUrlFragment", "Internals", DoesWindowHaveUrlFragmentOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "draggableRegions", "Internals", DraggableRegionsOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "effectivePreload", "Internals", EffectivePreloadOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "effectiveRootScroller", "Internals", EffectiveRootScrollerOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "elementFromPoint", "Internals", ElementFromPointOperationCallback, 5, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "elementLayoutTreeAsText", "Internals", ElementLayoutTreeAsTextOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "elementShouldAutoComplete", "Internals", ElementShouldAutoCompleteOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "emulateDeviceFailureOnAudioContext", "Internals", EmulateDeviceFailureOnAudioContextOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "enableMockSpeechSynthesizer", "Internals", EnableMockSpeechSynthesizerOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "endColorChooser", "Internals", EndColorChooserOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "evaluateInInspectorOverlay", "Internals", EvaluateInInspectorOverlayOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "evictAllResources", "Internals", EvictAllResourcesOperationCallback, 0, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "executeCommand", "Internals", ExecuteCommandOperationCallback, 3, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "exemptUrlFromNetworkRevocation", "Internals", ExemptUrlFromNetworkRevocationOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kDoNotCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "fakeCaptureConfigurationChanged", "Internals", FakeCaptureConfigurationChangedOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "firstChildInFlatTree", "Internals", FirstChildInFlatTreeOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "forceCompositingUpdate", "Internals", ForceCompositingUpdateOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "forceFullRepaint", "Internals", ForceFullRepaintOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "forceImageReload", "Internals", ForceImageReloadOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "forceLoseCanvasContext", "Internals", ForceLoseCanvasContextOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "forceReload", "Internals", ForceReloadOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "forceStaleStateForMediaElement", "Internals", ForceStaleStateForMediaElementOperationCallback, 2, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "formControlStateOfHistoryItem", "Internals", FormControlStateOfHistoryItemOperationCallback, 0, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "generateTestReport", "Internals", GenerateTestReportOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "getAgentId", "Internals", GetAgentIdOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "getAllCookies", "Internals", GetAllCookiesOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kDoNotCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "getCSSPropertyAliases", "Internals", GetCSSPropertyAliasesOperationCallback, 0, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "getCSSPropertyLonghands", "Internals", GetCSSPropertyLonghandsOperationCallback, 0, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "getCSSPropertyShorthands", "Internals", GetCSSPropertyShorthandsOperationCallback, 0, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "getComputedLabel", "Internals", GetComputedLabelOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "getComputedRole", "Internals", GetComputedRoleOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "getCreatorScripts", "Internals", GetCreatorScriptsOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "getCurrentCursorInfo", "Internals", GetCurrentCursorInfoOperationCallback, 0, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "getDragCaret", "Internals", GetDragCaretOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "getFedCmDialogType", "Internals", GetFedCmDialogTypeOperationCallback, 0, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kDoNotCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "getFedCmTitle", "Internals", GetFedCmTitleOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kDoNotCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "getImageSourceURL", "Internals", GetImageSourceURLOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "getInitialResourcePriority", "Internals", GetInitialResourcePriorityOperationCallback, 2, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kDoNotCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "getInitialResourcePriorityOfNewLoad", "Internals", GetInitialResourcePriorityOfNewLoadOperationCallback, 2, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kDoNotCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "getInternalResponseURLList", "Internals", GetInternalResponseURLListOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "getNamedCookie", "Internals", GetNamedCookieOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kDoNotCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "getParsedImportMap", "Internals", GetParsedImportMapOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "getProgrammaticScrollAnimationState", "Internals", GetProgrammaticScrollAnimationStateOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "getReferencedFilePaths", "Internals", GetReferencedFilePathsOperationCallback, 0, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "getResourceHeader", "Internals", GetResourceHeaderOperationCallback, 3, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "getScrollAnimationState", "Internals", GetScrollAnimationStateOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "getSelectionInFlatTree", "Internals", GetSelectionInFlatTreeOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "getVirtualSensorInformation", "Internals", GetVirtualSensorInformationOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kDoNotCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "hasAutofocusRequest", "Internals", HasAutofocusRequestOperationCallback, 0, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "hasGrammarMarker", "Internals", HasGrammarMarkerOperationCallback, 3, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "hasLastEditCommand", "Internals", HasLastEditCommandOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "hasSpellingMarker", "Internals", HasSpellingMarkerOperationCallback, 3, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "hitTestCacheHits", "Internals", HitTestCacheHitsOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "hitTestCount", "Internals", HitTestCountOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "htmlNamespace", "Internals", HTMLNamespaceOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "htmlTags", "Internals", HTMLTagsOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "idleTimeSpellCheckerState", "Internals", IdleTimeSpellCheckerStateOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "initializeUKMRecorder", "Internals", InitializeUKMRecorderOperationCallback, 0, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "innerEditorElement", "Internals", InnerEditorElementOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "isActivated", "Internals", IsActivatedOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "isAnimatedCSSPropertyUseCounted", "Internals", IsAnimatedCSSPropertyUseCountedOperationCallback, 2, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "isCSSPropertyUseCounted", "Internals", IsCSSPropertyUseCountedOperationCallback, 2, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "isCompositedAnimation", "Internals", IsCompositedAnimationOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "isInCanvasFontCache", "Internals", IsInCanvasFontCacheOperationCallback, 2, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "isLoading", "Internals", IsLoadingOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "isLoadingFromMemoryCache", "Internals", IsLoadingFromMemoryCacheOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "isLowEndDevice", "Internals", IsLowEndDeviceOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "isMediaElementSuspended", "Internals", IsMediaElementSuspendedOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "isPreloaded", "Internals", IsPreloadedOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "isPreloadedBy", "Internals", IsPreloadedByOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "isSelectPopupVisible", "Internals", IsSelectPopupVisibleOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "isSiteIsolated", "Internals", IsSiteIsolatedOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "isTrackingOcclusionForIFrame", "Internals", IsTrackingOcclusionForIFrameOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "isUseCounted", "Internals", IsUseCountedOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "isValidationMessageVisible", "Internals", IsValidationMessageVisibleOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "isVibrating", "Internals", IsVibratingOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "isWebDXFeatureUseCounted", "Internals", IsWebDXFeatureUseCountedOperationCallback, 2, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "lastChildInFlatTree", "Internals", LastChildInFlatTreeOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "lastCompiledScriptFileName", "Internals", LastCompiledScriptFileNameOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "lastCompiledScriptUsedCodeCache", "Internals", LastCompiledScriptUsedCodeCacheOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "lastSpellCheckProcessedSequence", "Internals", LastSpellCheckProcessedSequenceOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "lastSpellCheckRequestSequence", "Internals", LastSpellCheckRequestSequenceOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "layerTreeAsText", "Internals", LayerTreeAsTextOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "layoutCountForTesting", "Internals", LayoutCountForTestingOperationCallback, 0, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "layoutZoomFactor", "Internals", LayoutZoomFactorOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "lengthFromRange", "Internals", LengthFromRangeOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "locationFromRange", "Internals", LocationFromRangeOperationCallback, 2, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "mainThreadScrollingReasons", "Internals", MainThreadScrollingReasonsOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "markerBackgroundColorForNode", "Internals", MarkerBackgroundColorForNodeOperationCallback, 3, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "markerCountForNode", "Internals", MarkerCountForNodeOperationCallback, 2, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "markerDescriptionForNode", "Internals", MarkerDescriptionForNodeOperationCallback, 3, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "markerRangeForNode", "Internals", MarkerRangeForNodeOperationCallback, 3, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "markerTextForListItem", "Internals", MarkerTextForListItemOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "markerUnderlineColorForNode", "Internals", MarkerUnderlineColorForNodeOperationCallback, 3, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "mediaKeySessionCount", "Internals", MediaKeySessionCountOperationCallback, 0, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "mediaKeysCount", "Internals", MediaKeysCountOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "mediaPlayerPlayingRemotelyChanged", "Internals", MediaPlayerPlayingRemotelyChangedOperationCallback, 2, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "mediaPlayerRemoteRouteAvailabilityChanged", "Internals", MediaPlayerRemoteRouteAvailabilityChangedOperationCallback, 2, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "monotonicTimeToZeroBasedDocumentTime", "Internals", MonotonicTimeToZeroBasedDocumentTimeOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "needsLayoutCount", "Internals", NeedsLayoutCountOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "nextInFlatTree", "Internals", NextInFlatTreeOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "nextSiblingInFlatTree", "Internals", NextSiblingInFlatTreeOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "nodeNeedsStyleRecalc", "Internals", NodeNeedsStyleRecalcOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "nodesFromRect", "Internals", NodesFromRectOperationCallback, 7, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "nonDraggableRegions", "Internals", NonDraggableRegionsOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "numberOfLiveAXObjects", "Internals", NumberOfLiveAXObjectsOperationCallback, 0, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "numberOfLiveDocuments", "Internals", NumberOfLiveDocumentsOperationCallback, 0, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "numberOfLiveNodes", "Internals", NumberOfLiveNodesOperationCallback, 0, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "numberOfPages", "Internals", NumberOfPagesOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "numberOfScrollableAreas", "Internals", NumberOfScrollableAreasOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "observeGC", "Internals", ObserveGCOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "observeUseCounter", "Internals", ObserveUseCounterOperationCallback, 2, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kDoNotCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "originTrialsTest", "Internals", OriginTrialsTestOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "pageNumber", "Internals", PageNumberOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "pageScaleFactor", "Internals", PageScaleFactorOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "parentTreeScope", "Internals", ParentTreeScopeOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "pauseAnimations", "Internals", PauseAnimationsOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "peerConnectionCount", "Internals", PeerConnectionCountOperationCallback, 0, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "pendingVibrationPattern", "Internals", PendingVibrationPatternOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "pointerEventHandlerCount", "Internals", PointerEventHandlerCountOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "previousInFlatTree", "Internals", PreviousInFlatTreeOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "promiseCheck", "Internals", PromiseCheckOperationCallback, 5, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kDoNotCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "promiseCheckOverload", "Internals", PromiseCheckOverloadOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kDoNotCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "promiseCheckRange", "Internals", PromiseCheckRangeOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kDoNotCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "promiseCheckWithoutExceptionState", "Internals", PromiseCheckWithoutExceptionStateOperationCallback, 2, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kDoNotCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "rangeAsText", "Internals", RangeAsTextOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "rangeFromLocationAndLength", "Internals", RangeFromLocationAndLengthOperationCallback, 3, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "recordTest", "Internals", RecordTestOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "registerURLSchemeAsBypassingContentSecurityPolicy", "Internals", RegisterURLSchemeAsBypassingContentSecurityPolicyOperationCallback, 1,
                unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "removeMarker", "Internals", RemoveMarkerOperationCallback, 3, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "removeURLSchemeRegisteredAsBypassingContentSecurityPolicy", "Internals",
                RemoveURLSchemeRegisteredAsBypassingContentSecurityPolicyOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "removeVirtualPressureSource", "Internals", RemoveVirtualPressureSourceOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kDoNotCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "removeVirtualSensor", "Internals", RemoveVirtualSensorOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kDoNotCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "replaceMisspelled", "Internals", ReplaceMisspelledOperationCallback, 2, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "resetTypeAheadSession", "Internals", ResetTypeAheadSessionOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "rtcCertificateEquals", "Internals", RTCCertificateEqualsOperationCallback, 2, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "runFuzzer", "Internals", RunFuzzerOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kDoNotCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "runIdleTimeSpellChecker", "Internals", RunIdleTimeSpellCheckerOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "scrollEventHandlerCount", "Internals", ScrollEventHandlerCountOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "selectColorInColorChooser", "Internals", SelectColorInColorChooserOperationCallback, 2, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "selectFedCmAccount", "Internals", SelectFedCmAccountOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kDoNotCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "selectMenuListText", "Internals", SelectMenuListTextOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "selectPopupItemStyleFontHeight", "Internals", SelectPopupItemStyleFontHeightOperationCallback, 2, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "selectPopupItemStyleIsRtl", "Internals", SelectPopupItemStyleIsRtlOperationCallback, 2, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "selectedHTMLForClipboard", "Internals", SelectedHTMLForClipboardOperationCallback, 0, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "selectedTextForClipboard", "Internals", SelectedTextForClipboardOperationCallback, 0, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "selectionBounds", "Internals", SelectionBoundsOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "sequenceTest", "Internals", SequenceTestOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "serializeObject", "Internals", SerializeObjectOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "setAllowPerChunkTransferring", "Internals", SetAllowPerChunkTransferringOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "setAutofilled", "Internals", SetAutofilledOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "setAutofilledValue", "Internals", SetAutofilledValueOperationCallback, 2, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "setBackForwardCacheRestorationBufferSize", "Internals", SetBackForwardCacheRestorationBufferSizeOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "setBrowserControlsShownRatio", "Internals", SetBrowserControlsShownRatioOperationCallback, 2, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "setBrowserControlsState", "Internals", SetBrowserControlsStateOperationCallback, 3, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "setCapsLockState", "Internals", SetCapsLockStateOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "setDarkPreferredColorScheme", "Internals", SetDarkPreferredColorSchemeOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "setDarkPreferredRootScrollbarColorScheme", "Internals", SetDarkPreferredRootScrollbarColorSchemeOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "setDeviceEmulationScale", "Internals", SetDeviceEmulationScaleOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "setDevicePostureOverride", "Internals", SetDevicePostureOverrideOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kDoNotCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "setEventTimingBufferSize", "Internals", SetEventTimingBufferSizeOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "setFocused", "Internals", SetFocusedOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "setForcedColorsAndDarkPreferredColorScheme", "Internals", SetForcedColorsAndDarkPreferredColorSchemeOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "setFormControlStateOfHistoryItem", "Internals", SetFormControlStateOfHistoryItemOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "setInitialFocus", "Internals", SetInitialFocusOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "setIsAdFrame", "Internals", SetIsAdFrameOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "setIsCursorVisible", "Internals", SetIsCursorVisibleOperationCallback, 2, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "setIsLowEndDevice", "Internals", SetIsLowEndDeviceOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "setMarker", "Internals", SetMarkerOperationCallback, 3, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "setMaxNumberOfFramesToTen", "Internals", SetMaxNumberOfFramesToTenOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "setMediaControlsTestMode", "Internals", SetMediaControlsTestModeOperationCallback, 2, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "setMockHyphenation", "Internals", SetMockHyphenationOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "setNetworkConnectionInfoOverride", "Internals", SetNetworkConnectionInfoOverrideOperationCallback, 5, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "setPageScaleFactor", "Internals", SetPageScaleFactorOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "setPageScaleFactorLimits", "Internals", SetPageScaleFactorLimitsOperationCallback, 2, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "setPermission", "Internals", SetPermissionOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kDoNotCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "setPersistent", "Internals", SetPersistentOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "setPseudoClassState", "Internals", SetPseudoClassStateOperationCallback, 3, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "setSaveDataEnabled", "Internals", SetSaveDataEnabledOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "setScrollbarVisibilityInScrollableArea", "Internals", SetScrollbarVisibilityInScrollableAreaOperationCallback, 2, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "setSelectionRangeForNumberType", "Internals", SetSelectionRangeForNumberTypeOperationCallback, 3, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "setShouldRevealPassword", "Internals", SetShouldRevealPasswordOperationCallback, 2, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "setStorageAccess", "Internals", SetStorageAccessOperationCallback, 3, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kDoNotCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "setSuggestedValue", "Internals", SetSuggestedValueOperationCallback, 2, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "setSystemTimeZone", "Internals", SetSystemTimeZoneOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "setTextMatchMarkersActive", "Internals", SetTextMatchMarkersActiveOperationCallback, 4, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "setUserPreferredLanguages", "Internals", SetUserPreferredLanguagesOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "setValueForUser", "Internals", SetValueForUserOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "setVisualViewportOffset", "Internals", SetVisualViewportOffsetOperationCallback, 2, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "shadowPseudoId", "Internals", ShadowPseudoIdOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "shadowRoot", "Internals", ShadowRootOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "shortcutIconURLs", "Internals", ShortcutIconURLsOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "simulateRasterUnderInvalidations", "Internals", SimulateRasterUnderInvalidationsOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "spellCheckedTextLength", "Internals", SpellCheckedTextLengthOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "startTrackingRepaints", "Internals", StartTrackingRepaintsOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "stopResponsivenessMetricsUkmSampling", "Internals", StopResponsivenessMetricsUkmSamplingOperationCallback, 0, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "stopTrackingRepaints", "Internals", StopTrackingRepaintsOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "styleForElementCount", "Internals", StyleForElementCountOperationCallback, 0, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "suggestedValue", "Internals", SuggestedValueOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "supportedTextEncodingLabels", "Internals", SupportedTextEncodingLabelsOperationCallback, 0, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "svgNamespace", "Internals", SVGNamespaceOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "svgTags", "Internals", SVGTagsOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "terminateServiceWorker", "Internals", TerminateServiceWorkerOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kDoNotCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "touchEndOrCancelEventHandlerCount", "Internals", TouchEndOrCancelEventHandlerCountOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "touchEventTargetLayerRects", "Internals", TouchEventTargetLayerRectsOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "touchNodeAdjustedToBestClickableNode", "Internals", TouchNodeAdjustedToBestClickableNodeOperationCallback, 5, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "touchNodeAdjustedToBestContextMenuNode", "Internals", TouchNodeAdjustedToBestContextMenuNodeOperationCallback, 5, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "touchNodeAdjustedToBestStylusWritableNode", "Internals", TouchNodeAdjustedToBestStylusWritableNodeOperationCallback, 5, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "touchPositionAdjustedToBestClickableNode", "Internals", TouchPositionAdjustedToBestClickableNodeOperationCallback, 5, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "touchPositionAdjustedToBestContextMenuNode", "Internals", TouchPositionAdjustedToBestContextMenuNodeOperationCallback, 5, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "touchStartOrMoveEventHandlerCount", "Internals", TouchStartOrMoveEventHandlerCountOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "treeScopeRootNode", "Internals", TreeScopeRootNodeOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "triggerTestInspectorIssue", "Internals", TriggerTestInspectorIssueOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "typeConversions", "Internals", TypeConversionsOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "unionTypesTest", "Internals", UnionTypesTestOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "unscopableMethod", "Internals", UnscopableMethodOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "updateLayoutAndRunPostLayoutTasks", "Internals", UpdateLayoutAndRunPostLayoutTasksOperationCallback, 0, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "updateStyleAndReturnAffectedElementCount", "Internals", UpdateStyleAndReturnAffectedElementCountOperationCallback, 0, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "updateVirtualPressureSource", "Internals", UpdateVirtualPressureSourceOperationCallback, 2, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kDoNotCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "updateVirtualSensor", "Internals", UpdateVirtualSensorOperationCallback, 2, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kDoNotCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "useMockOverlayScrollbars", "Internals", UseMockOverlayScrollbarsOperationCallback, 0, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "userPreferredLanguages", "Internals", UserPreferredLanguagesOperationCallback, 0, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "viewportAsText", "Internals", ViewportAsTextOperationCallback, 4, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "waitForPeerConnectionDispatchEventsTaskCreated", "Internals", WaitForPeerConnectionDispatchEventsTaskCreatedOperationCallback, 1,
                unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kDoNotCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "wheelEventHandlerCount", "Internals", WheelEventHandlerCountOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "zeroBasedDocumentTimeToMonotonicTime", "Internals", ZeroBasedDocumentTimeToMonotonicTimeOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
        };
        IDLMemberInstaller::InstallOperations(isolate, world, instance_template, prototype_template, interface_template, signature, kOperationTable);
    }
}

void V8Internals::Impl::InstallContextDependentProperties(v8::Local<v8::Context> context, const DOMWrapperWorld& world, v8::Local<v8::Object> instance_object,
    v8::Local<v8::Object> prototype_object, v8::Local<v8::Object> interface_object, v8::Local<v8::Template> interface_template,
    FeatureSelector feature_selector)
{
    using bindings::IDLMemberInstaller;

    if (feature_selector.IsAll()) {
        // [Unscopable]
        // 3.7.3. Interface prototype object
        // https://webidl.spec.whatwg.org/#interface-prototype-object
        // step 10. If interface has any member declared with the [Unscopable]
        //   extended attribute, then:
        static constexpr const char* kUnscopablePropertyNames[] = {
            "unscopableAttribute",
            "unscopableMethod",
        };
        v8::Isolate* isolate = context->GetIsolate();
        bindings::InstallUnscopablePropertyNames(isolate, context, prototype_object, kUnscopablePropertyNames);
    }
}

} // namespace blink
