// Copyright 2019 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// DO NOT EDIT: This file is auto-generated by
// //third_party/blink/renderer/bindings/scripts/generate_bindings.py
//
// Use the GN flag `blink_enable_generated_code_formatting=true` to enable
// formatting of the generated files.

#include "third_party/blink/renderer/bindings/modules/v8/v8_webgl_rendering_context.h"

#include "third_party/blink/public/mojom/origin_trials/origin_trial_feature.mojom-shared.h"
#include "third_party/blink/renderer/bindings/core/v8/generated_code_helper.h"
#include "third_party/blink/renderer/bindings/core/v8/is_return_type_compatible.h"
#include "third_party/blink/renderer/bindings/core/v8/native_value_traits_impl.h"
#include "third_party/blink/renderer/bindings/core/v8/to_v8_traits.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_html_canvas_element.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_html_image_element.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_html_video_element.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_image_bitmap.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_image_data.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_offscreen_canvas.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_predefined_color_space.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_set_return_value_for_core.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_union_arraybuffer_arraybufferview.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_union_htmlcanvaselement_offscreencanvas.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_video_frame.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_webgl_active_info.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_webgl_buffer.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_webgl_context_attributes.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_webgl_framebuffer.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_webgl_program.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_webgl_renderbuffer.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_webgl_shader.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_webgl_shader_precision_format.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_webgl_texture.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_webgl_uniform_location.h"
#include "third_party/blink/renderer/core/execution_context/execution_context.h"
#include "third_party/blink/renderer/core/frame/dactyloscoper.h"
#include "third_party/blink/renderer/core/frame/web_feature.h"
#include "third_party/blink/renderer/core/html/canvas/html_canvas_element.h"
#include "third_party/blink/renderer/core/html/canvas/image_data.h"
#include "third_party/blink/renderer/core/html/html_image_element.h"
#include "third_party/blink/renderer/core/html/media/html_video_element.h"
#include "third_party/blink/renderer/core/imagebitmap/image_bitmap.h"
#include "third_party/blink/renderer/core/offscreencanvas/offscreen_canvas.h"
#include "third_party/blink/renderer/modules/webcodecs/video_frame.h"
#include "third_party/blink/renderer/modules/webgl/webgl_active_info.h"
#include "third_party/blink/renderer/modules/webgl/webgl_buffer.h"
#include "third_party/blink/renderer/modules/webgl/webgl_framebuffer.h"
#include "third_party/blink/renderer/modules/webgl/webgl_program.h"
#include "third_party/blink/renderer/modules/webgl/webgl_renderbuffer.h"
#include "third_party/blink/renderer/modules/webgl/webgl_rendering_context.h"
#include "third_party/blink/renderer/modules/webgl/webgl_shader.h"
#include "third_party/blink/renderer/modules/webgl/webgl_shader_precision_format.h"
#include "third_party/blink/renderer/modules/webgl/webgl_texture.h"
#include "third_party/blink/renderer/modules/webgl/webgl_uniform_location.h"
#include "third_party/blink/renderer/platform/bindings/cooperative_scheduling_helpers.h"
#include "third_party/blink/renderer/platform/bindings/exception_messages.h"
#include "third_party/blink/renderer/platform/bindings/idl_member_installer.h"
#include "third_party/blink/renderer/platform/bindings/runtime_call_stats.h"
#include "third_party/blink/renderer/platform/bindings/v8_binding.h"
#include "third_party/blink/renderer/platform/bindings/wrapper_type_info.h"
#include "third_party/blink/renderer/platform/instrumentation/use_counter.h"

namespace blink {

bool V8WebGLRenderingContext::IsExposed(ExecutionContext* execution_context)
{

    return execution_context->IsWindow() || execution_context->IsWorkerGlobalScope();
}

// Construction of WrapperTypeInfo may require non-trivial initialization due
// to cross-component address resolution in order to load the pointer to the
// parent interface's WrapperTypeInfo.  We ignore this issue because the issue
// happens only on component builds and the official release builds
// (statically-linked builds) are never affected by this issue.
#if defined(COMPONENT_BUILD) && defined(WIN32) && defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wglobal-constructors"
#endif

const WrapperTypeInfo V8WebGLRenderingContext::wrapper_type_info_ {
    gin::kEmbedderBlink,
    V8WebGLRenderingContext::InstallInterfaceTemplate,
    V8WebGLRenderingContext::InstallContextDependentProperties,
    "WebGLRenderingContext",
    nullptr,
    V8WebGLRenderingContext::kThisTag,
    V8WebGLRenderingContext::kMaxSubclassTag,
    WrapperTypeInfo::kWrapperTypeObjectPrototype,
    WrapperTypeInfo::kObjectClassId,
    WrapperTypeInfo::kInheritFromActiveScriptWrappable,
    WrapperTypeInfo::kIdlInterface,
    false,
};

#if defined(COMPONENT_BUILD) && defined(WIN32) && defined(__clang__)
#pragma clang diagnostic pop
#endif

const WrapperTypeInfo& WebGLRenderingContext::wrapper_type_info_ = V8WebGLRenderingContext::wrapper_type_info_;

// [ActiveScriptWrappable]
static_assert(std::is_base_of<ActiveScriptWrappableBase, WebGLRenderingContext>::value,
    "WebGLRenderingContext does not inherit from ActiveScriptWrappable<> despite "
    "the IDL has [ActiveScriptWrappable] extended attribute.");

namespace {

namespace v8_webgl_rendering_context {

void CanvasAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_canvas_Getter");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.canvas.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->getHTMLOrOffscreenCanvas();
    static_assert(bindings::IsReturnTypeCompatible<V8UnionHTMLCanvasElementOrOffscreenCanvas, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    v8::Local<v8::Value> v8_return_value = ToV8Traits<V8UnionHTMLCanvasElementOrOffscreenCanvas>::ToV8(script_state, return_value);
    bindings::V8SetReturnValue(info, v8_return_value);
}

void DrawingBufferWidthAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_drawingBufferWidth_Getter");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.drawingBufferWidth.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->drawingBufferWidth();
    static_assert(bindings::IsReturnTypeCompatible<IDLLong, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<int32_t>());
}

void DrawingBufferHeightAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_drawingBufferHeight_Getter");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.drawingBufferHeight.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->drawingBufferHeight();
    static_assert(bindings::IsReturnTypeCompatible<IDLLong, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<int32_t>());
}

void DrawingBufferFormatAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_drawingBufferFormat_Getter");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.drawingBufferFormat.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->drawingBufferFormat();
    static_assert(bindings::IsReturnTypeCompatible<IDLUnsignedLong, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<uint32_t>());
}

void DrawingBufferColorSpaceAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_drawingBufferColorSpace_Getter");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.drawingBufferColorSpace.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->drawingBufferColorSpace();
    static_assert(bindings::IsReturnTypeCompatible<V8PredefinedColorSpace, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void DrawingBufferColorSpaceAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_drawingBufferColorSpace_Setter");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.drawingBufferColorSpace.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    // https://webidl.spec.whatwg.org/#dfn-attribute-setter
    // step 4.6.1. Let S be ? ToString(V).
    const auto&& arg1_value_string = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    // step 4.6.2. If S is not one of the enumeration's values, then return
    //   undefined.
    const auto arg1_value_maybe_enum = V8PredefinedColorSpace::Create(arg1_value_string);
    if (!arg1_value_maybe_enum) {
        bindings::ReportInvalidEnumSetToAttribute(isolate, arg1_value_string, "PredefinedColorSpace", exception_state);
        return; // Return undefined.
    }
    const auto arg1_value = arg1_value_maybe_enum.value();

    blink_receiver->setDrawingBufferColorSpace(arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void UnpackColorSpaceAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_unpackColorSpace_Getter");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.unpackColorSpace.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->unpackColorSpace();
    static_assert(bindings::IsReturnTypeCompatible<V8PredefinedColorSpace, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void UnpackColorSpaceAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_unpackColorSpace_Setter");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.unpackColorSpace.set");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    v8::Local<v8::Value> v8_property_value = info[0];
    ExceptionState exception_state(isolate);
    // https://webidl.spec.whatwg.org/#dfn-attribute-setter
    // step 4.6.1. Let S be ? ToString(V).
    const auto&& arg1_value_string = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    // step 4.6.2. If S is not one of the enumeration's values, then return
    //   undefined.
    const auto arg1_value_maybe_enum = V8PredefinedColorSpace::Create(arg1_value_string);
    if (!arg1_value_maybe_enum) {
        bindings::ReportInvalidEnumSetToAttribute(isolate, arg1_value_string, "PredefinedColorSpace", exception_state);
        return; // Return undefined.
    }
    const auto arg1_value = arg1_value_maybe_enum.value();

    blink_receiver->setUnpackColorSpace(arg1_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void ActiveTextureOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_activeTexture");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.activeTexture");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_texture = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->activeTexture(arg1_texture);
}

void AttachShaderOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_attachShader");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.attachShader");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_program = NativeValueTraits<WebGLProgram>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_shader = NativeValueTraits<WebGLShader>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->attachShader(arg1_program, arg2_shader);
}

void BindAttribLocationOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_bindAttribLocation");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.bindAttribLocation");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 3) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(3, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_program = NativeValueTraits<WebGLProgram>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_index = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_name = NativeValueTraits<IDLString>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->bindAttribLocation(arg1_program, arg2_index, arg3_name);
}

void BindBufferOperationNoAllocDirectCallArg2(
    v8::Local<v8::Object> v8_arg0_receiver, uint32_t v8_arg1_target, v8::Local<v8::Value> v8_arg2_buffer, v8::FastApiCallbackOptions& v8_arg_callback_options)
{
    v8::Isolate* isolate = v8_arg_callback_options.isolate;
    v8::HandleScope handle_scope(isolate);

    v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& arg1_target = v8_arg1_target;
    ExceptionState exception_state(isolate);
    auto&& arg2_buffer = NativeValueTraits<IDLNullable<WebGLBuffer>>::ArgumentValue(isolate, 1, v8_arg2_buffer, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->bindBuffer(arg1_target, arg2_buffer);
}

void BindBufferOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_bindBuffer");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.bindBuffer");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_buffer = NativeValueTraits<IDLNullable<WebGLBuffer>>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->bindBuffer(arg1_target, arg2_buffer);
}

void BindFramebufferOperationNoAllocDirectCallArg2(v8::Local<v8::Object> v8_arg0_receiver, uint32_t v8_arg1_target, v8::Local<v8::Value> v8_arg2_framebuffer,
    v8::FastApiCallbackOptions& v8_arg_callback_options)
{
    v8::Isolate* isolate = v8_arg_callback_options.isolate;
    v8::HandleScope handle_scope(isolate);

    v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& arg1_target = v8_arg1_target;
    ExceptionState exception_state(isolate);
    auto&& arg2_framebuffer = NativeValueTraits<IDLNullable<WebGLFramebuffer>>::ArgumentValue(isolate, 1, v8_arg2_framebuffer, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->bindFramebuffer(arg1_target, arg2_framebuffer);
}

void BindFramebufferOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_bindFramebuffer");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.bindFramebuffer");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_framebuffer = NativeValueTraits<IDLNullable<WebGLFramebuffer>>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->bindFramebuffer(arg1_target, arg2_framebuffer);
}

void BindRenderbufferOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_bindRenderbuffer");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.bindRenderbuffer");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_renderbuffer = NativeValueTraits<IDLNullable<WebGLRenderbuffer>>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->bindRenderbuffer(arg1_target, arg2_renderbuffer);
}

void BindTextureOperationNoAllocDirectCallArg2(
    v8::Local<v8::Object> v8_arg0_receiver, uint32_t v8_arg1_target, v8::Local<v8::Value> v8_arg2_texture, v8::FastApiCallbackOptions& v8_arg_callback_options)
{
    v8::Isolate* isolate = v8_arg_callback_options.isolate;
    v8::HandleScope handle_scope(isolate);

    v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& arg1_target = v8_arg1_target;
    ExceptionState exception_state(isolate);
    auto&& arg2_texture = NativeValueTraits<IDLNullable<WebGLTexture>>::ArgumentValue(isolate, 1, v8_arg2_texture, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->bindTexture(arg1_target, arg2_texture);
}

void BindTextureOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_bindTexture");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.bindTexture");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_texture = NativeValueTraits<IDLNullable<WebGLTexture>>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->bindTexture(arg1_target, arg2_texture);
}

void BlendColorOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_blendColor");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.blendColor");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 4) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(4, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_red = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_green = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_blue = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg4_alpha = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 3, info[3], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->blendColor(arg1_red, arg2_green, arg3_blue, arg4_alpha);
}

void BlendEquationOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_blendEquation");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.blendEquation");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_mode = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->blendEquation(arg1_mode);
}

void BlendEquationSeparateOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_blendEquationSeparate");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.blendEquationSeparate");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_mode_rgb = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_mode_alpha = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->blendEquationSeparate(arg1_mode_rgb, arg2_mode_alpha);
}

void BlendFuncOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_blendFunc");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.blendFunc");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_sfactor = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_dfactor = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->blendFunc(arg1_sfactor, arg2_dfactor);
}

void BlendFuncSeparateOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_blendFuncSeparate");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.blendFuncSeparate");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 4) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(4, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_src_rgb = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_dst_rgb = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_src_alpha = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg4_dst_alpha = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 3, info[3], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->blendFuncSeparate(arg1_src_rgb, arg2_dst_rgb, arg3_src_alpha, arg4_dst_alpha);
}

void BufferDataOperationOverload1(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 3) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(3, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_size = NativeValueTraits<IDLLongLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_usage = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->bufferData(arg1_target, arg2_size, arg3_usage);
}

void BufferDataOperationOverload2(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 3) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(3, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_data = NativeValueTraits<IDLBufferSourceTypeNoSizeLimit<MaybeShared<DOMArrayBufferView>>>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_usage = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->bufferData(arg1_target, arg2_data, arg3_usage);
}

void BufferDataOperationOverload3(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 3) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(3, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_data = NativeValueTraits<IDLNullable<IDLBufferSourceTypeNoSizeLimit<DOMArrayBufferBase>>>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_usage = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->bufferData(arg1_target, arg2_data, arg3_usage);
}

void BufferDataOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_bufferData");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.bufferData");

    BINDINGS_COOPERATIVE_SCHEDULING_SAFEPOINT();

    const int arg_count = std::min(info.Length(), 3);
    if (arg_count == 3) {
        if (info[1]->IsNullOrUndefined()) {
            return BufferDataOperationOverload3(info);
        }
        if (info[1]->IsObject()) {
            if (info[1]->IsArrayBuffer() || info[1]->IsSharedArrayBuffer()) {
                return BufferDataOperationOverload3(info);
            }
            if (info[1]->IsArrayBufferView()) {
                return BufferDataOperationOverload2(info);
            }
        }
        if (info[1]->IsNumber()) {
            return BufferDataOperationOverload1(info);
        }
        return BufferDataOperationOverload1(info);
    }

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 3) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(3, info.Length()));
        return;
    }
    V8ThrowException::ThrowTypeError(isolate, "Overload resolution failed.");
    return;
}

void BufferSubDataOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_bufferSubData");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.bufferSubData");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 3) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(3, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_offset = NativeValueTraits<IDLLongLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_data = NativeValueTraits<PassAsSpan<PassAsSpanMarkerBase::Flags::kAllowShared, void>>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->bufferSubData(arg1_target, arg2_offset, arg3_data);
}

void CheckFramebufferStatusOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_checkFramebufferStatus");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.checkFramebufferStatus");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->checkFramebufferStatus(arg1_target);
    static_assert(bindings::IsReturnTypeCompatible<IDLUnsignedLong, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<uint32_t>());
}

void ClearOperationNoAllocDirectCallArg1(v8::Local<v8::Object> v8_arg0_receiver, uint32_t v8_arg1_mask, v8::FastApiCallbackOptions& v8_arg_callback_options)
{
    v8::Isolate* isolate = v8_arg_callback_options.isolate;
    v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& arg1_mask = v8_arg1_mask;
    blink_receiver->clear(arg1_mask);
}

void ClearOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_clear");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.clear");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_mask = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->clear(arg1_mask);
}

void ClearColorOperationNoAllocDirectCallArg4(v8::Local<v8::Object> v8_arg0_receiver, float v8_arg1_red, float v8_arg2_green, float v8_arg3_blue,
    float v8_arg4_alpha, v8::FastApiCallbackOptions& v8_arg_callback_options)
{
    v8::Isolate* isolate = v8_arg_callback_options.isolate;
    v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& arg1_red = v8_arg1_red;
    auto&& arg2_green = v8_arg2_green;
    auto&& arg3_blue = v8_arg3_blue;
    auto&& arg4_alpha = v8_arg4_alpha;
    blink_receiver->clearColor(arg1_red, arg2_green, arg3_blue, arg4_alpha);
}

void ClearColorOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_clearColor");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.clearColor");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 4) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(4, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_red = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_green = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_blue = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg4_alpha = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 3, info[3], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->clearColor(arg1_red, arg2_green, arg3_blue, arg4_alpha);
}

void ClearDepthOperationNoAllocDirectCallArg1(v8::Local<v8::Object> v8_arg0_receiver, float v8_arg1_depth, v8::FastApiCallbackOptions& v8_arg_callback_options)
{
    v8::Isolate* isolate = v8_arg_callback_options.isolate;
    v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& arg1_depth = v8_arg1_depth;
    blink_receiver->clearDepth(arg1_depth);
}

void ClearDepthOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_clearDepth");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.clearDepth");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_depth = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->clearDepth(arg1_depth);
}

void ClearStencilOperationNoAllocDirectCallArg1(v8::Local<v8::Object> v8_arg0_receiver, int32_t v8_arg1_s, v8::FastApiCallbackOptions& v8_arg_callback_options)
{
    v8::Isolate* isolate = v8_arg_callback_options.isolate;
    v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& arg1_s = v8_arg1_s;
    blink_receiver->clearStencil(arg1_s);
}

void ClearStencilOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_clearStencil");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.clearStencil");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_s = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->clearStencil(arg1_s);
}

void ColorMaskOperationNoAllocDirectCallArg4(v8::Local<v8::Object> v8_arg0_receiver, bool v8_arg1_red, bool v8_arg2_green, bool v8_arg3_blue,
    bool v8_arg4_alpha, v8::FastApiCallbackOptions& v8_arg_callback_options)
{
    v8::Isolate* isolate = v8_arg_callback_options.isolate;
    v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& arg1_red = v8_arg1_red;
    auto&& arg2_green = v8_arg2_green;
    auto&& arg3_blue = v8_arg3_blue;
    auto&& arg4_alpha = v8_arg4_alpha;
    blink_receiver->colorMask(arg1_red, arg2_green, arg3_blue, arg4_alpha);
}

void ColorMaskOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_colorMask");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.colorMask");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 4) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(4, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_red = NativeValueTraits<IDLBoolean>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_green = NativeValueTraits<IDLBoolean>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_blue = NativeValueTraits<IDLBoolean>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg4_alpha = NativeValueTraits<IDLBoolean>::ArgumentValue(isolate, 3, info[3], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->colorMask(arg1_red, arg2_green, arg3_blue, arg4_alpha);
}

void CommitOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_commit");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.commit");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->commit();
}

void CompileShaderOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_compileShader");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.compileShader");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_shader = NativeValueTraits<WebGLShader>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->compileShader(arg1_shader);
}

void CompressedTexImage2DOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_compressedTexImage2D");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.compressedTexImage2D");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 7) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(7, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_level = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_internalformat = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg4_width = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 3, info[3], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg5_height = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 4, info[4], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg6_border = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 5, info[5], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg7_data = NativeValueTraits<IDLBufferSourceTypeNoSizeLimit<MaybeShared<DOMArrayBufferView>>>::ArgumentValue(isolate, 6, info[6], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->compressedTexImage2D(arg1_target, arg2_level, arg3_internalformat, arg4_width, arg5_height, arg6_border, arg7_data);
}

void CompressedTexSubImage2DOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_compressedTexSubImage2D");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.compressedTexSubImage2D");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 8) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(8, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_level = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_xoffset = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg4_yoffset = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 3, info[3], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg5_width = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 4, info[4], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg6_height = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 5, info[5], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg7_format = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 6, info[6], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg8_data = NativeValueTraits<IDLBufferSourceTypeNoSizeLimit<MaybeShared<DOMArrayBufferView>>>::ArgumentValue(isolate, 7, info[7], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->compressedTexSubImage2D(arg1_target, arg2_level, arg3_xoffset, arg4_yoffset, arg5_width, arg6_height, arg7_format, arg8_data);
}

void CopyTexImage2DOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_copyTexImage2D");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.copyTexImage2D");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 8) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(8, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_level = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_internalformat = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg4_x = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 3, info[3], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg5_y = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 4, info[4], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg6_width = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 5, info[5], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg7_height = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 6, info[6], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg8_border = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 7, info[7], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->copyTexImage2D(arg1_target, arg2_level, arg3_internalformat, arg4_x, arg5_y, arg6_width, arg7_height, arg8_border);
}

void CopyTexSubImage2DOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_copyTexSubImage2D");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.copyTexSubImage2D");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 8) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(8, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_level = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_xoffset = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg4_yoffset = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 3, info[3], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg5_x = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 4, info[4], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg6_y = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 5, info[5], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg7_width = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 6, info[6], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg8_height = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 7, info[7], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->copyTexSubImage2D(arg1_target, arg2_level, arg3_xoffset, arg4_yoffset, arg5_x, arg6_y, arg7_width, arg8_height);
}

void CreateBufferOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_createBuffer");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.createBuffer");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->createBuffer();
    static_assert(bindings::IsReturnTypeCompatible<WebGLBuffer, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void CreateFramebufferOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_createFramebuffer");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.createFramebuffer");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->createFramebuffer();
    static_assert(bindings::IsReturnTypeCompatible<WebGLFramebuffer, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void CreateProgramOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_createProgram");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.createProgram");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->createProgram();
    static_assert(bindings::IsReturnTypeCompatible<WebGLProgram, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void CreateRenderbufferOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_createRenderbuffer");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.createRenderbuffer");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->createRenderbuffer();
    static_assert(bindings::IsReturnTypeCompatible<WebGLRenderbuffer, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void CreateShaderOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_createShader");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.createShader");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_type = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->createShader(arg1_type);
    static_assert(bindings::IsReturnTypeCompatible<WebGLShader, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void CreateTextureOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_createTexture");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.createTexture");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->createTexture();
    static_assert(bindings::IsReturnTypeCompatible<WebGLTexture, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void CullFaceOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_cullFace");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.cullFace");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_mode = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->cullFace(arg1_mode);
}

void DeleteBufferOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_deleteBuffer");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.deleteBuffer");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_buffer = NativeValueTraits<IDLNullable<WebGLBuffer>>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->deleteBuffer(arg1_buffer);
}

void DeleteFramebufferOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_deleteFramebuffer");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.deleteFramebuffer");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_framebuffer = NativeValueTraits<IDLNullable<WebGLFramebuffer>>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->deleteFramebuffer(arg1_framebuffer);
}

void DeleteProgramOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_deleteProgram");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.deleteProgram");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_program = NativeValueTraits<IDLNullable<WebGLProgram>>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->deleteProgram(arg1_program);
}

void DeleteRenderbufferOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_deleteRenderbuffer");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.deleteRenderbuffer");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_renderbuffer = NativeValueTraits<IDLNullable<WebGLRenderbuffer>>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->deleteRenderbuffer(arg1_renderbuffer);
}

void DeleteShaderOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_deleteShader");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.deleteShader");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_shader = NativeValueTraits<IDLNullable<WebGLShader>>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->deleteShader(arg1_shader);
}

void DeleteTextureOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_deleteTexture");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.deleteTexture");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_texture = NativeValueTraits<IDLNullable<WebGLTexture>>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->deleteTexture(arg1_texture);
}

void DepthFuncOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_depthFunc");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.depthFunc");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_func = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->depthFunc(arg1_func);
}

void DepthMaskOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_depthMask");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.depthMask");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_flag = NativeValueTraits<IDLBoolean>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->depthMask(arg1_flag);
}

void DepthRangeOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_depthRange");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.depthRange");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_z_near = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_z_far = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->depthRange(arg1_z_near, arg2_z_far);
}

void DetachShaderOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_detachShader");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.detachShader");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_program = NativeValueTraits<WebGLProgram>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_shader = NativeValueTraits<WebGLShader>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->detachShader(arg1_program, arg2_shader);
}

void DisableOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_disable");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.disable");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_cap = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->disable(arg1_cap);
}

void DisableVertexAttribArrayOperationNoAllocDirectCallArg1(
    v8::Local<v8::Object> v8_arg0_receiver, uint32_t v8_arg1_index, v8::FastApiCallbackOptions& v8_arg_callback_options)
{
    v8::Isolate* isolate = v8_arg_callback_options.isolate;
    v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& arg1_index = v8_arg1_index;
    blink_receiver->disableVertexAttribArray(arg1_index);
}

void DisableVertexAttribArrayOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_disableVertexAttribArray");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.disableVertexAttribArray");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_index = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->disableVertexAttribArray(arg1_index);
}

void DrawArraysOperationNoAllocDirectCallArg3(v8::Local<v8::Object> v8_arg0_receiver, uint32_t v8_arg1_mode, int32_t v8_arg2_first, int32_t v8_arg3_count,
    v8::FastApiCallbackOptions& v8_arg_callback_options)
{
    v8::Isolate* isolate = v8_arg_callback_options.isolate;
    v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& arg1_mode = v8_arg1_mode;
    auto&& arg2_first = v8_arg2_first;
    auto&& arg3_count = v8_arg3_count;
    blink_receiver->drawArrays(arg1_mode, arg2_first, arg3_count);
}

void DrawArraysOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_drawArrays");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.drawArrays");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 3) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(3, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_mode = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_first = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_count = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->drawArrays(arg1_mode, arg2_first, arg3_count);
}

void DrawElementsOperationNoAllocDirectCallArg4(v8::Local<v8::Object> v8_arg0_receiver, uint32_t v8_arg1_mode, int32_t v8_arg2_count, uint32_t v8_arg3_type,
    int64_t v8_arg4_offset, v8::FastApiCallbackOptions& v8_arg_callback_options)
{
    v8::Isolate* isolate = v8_arg_callback_options.isolate;
    v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& arg1_mode = v8_arg1_mode;
    auto&& arg2_count = v8_arg2_count;
    auto&& arg3_type = v8_arg3_type;
    auto&& arg4_offset = v8_arg4_offset;
    blink_receiver->drawElements(arg1_mode, arg2_count, arg3_type, arg4_offset);
}

void DrawElementsOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_drawElements");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.drawElements");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 4) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(4, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_mode = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_count = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_type = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg4_offset = NativeValueTraits<IDLLongLong>::ArgumentValue(isolate, 3, info[3], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->drawElements(arg1_mode, arg2_count, arg3_type, arg4_offset);
}

void DrawingBufferStorageOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_drawingBufferStorage");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.drawingBufferStorage");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 3) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(3, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_sizedformat = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_width = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_height = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->drawingBufferStorage(arg1_sizedformat, arg2_width, arg3_height);
}

void EnableOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_enable");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.enable");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_cap = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->enable(arg1_cap);
}

void EnableVertexAttribArrayOperationNoAllocDirectCallArg1(
    v8::Local<v8::Object> v8_arg0_receiver, uint32_t v8_arg1_index, v8::FastApiCallbackOptions& v8_arg_callback_options)
{
    v8::Isolate* isolate = v8_arg_callback_options.isolate;
    v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& arg1_index = v8_arg1_index;
    blink_receiver->enableVertexAttribArray(arg1_index);
}

void EnableVertexAttribArrayOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_enableVertexAttribArray");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.enableVertexAttribArray");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_index = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->enableVertexAttribArray(arg1_index);
}

void FinishOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_finish");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.finish");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->finish();
}

void FlushOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_flush");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.flush");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->flush();
}

void FramebufferRenderbufferOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_framebufferRenderbuffer");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.framebufferRenderbuffer");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 4) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(4, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_attachment = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_renderbuffertarget = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg4_renderbuffer = NativeValueTraits<IDLNullable<WebGLRenderbuffer>>::ArgumentValue(isolate, 3, info[3], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->framebufferRenderbuffer(arg1_target, arg2_attachment, arg3_renderbuffertarget, arg4_renderbuffer);
}

void FramebufferTexture2DOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_framebufferTexture2D");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.framebufferTexture2D");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 5) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(5, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_attachment = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_textarget = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg4_texture = NativeValueTraits<IDLNullable<WebGLTexture>>::ArgumentValue(isolate, 3, info[3], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg5_level = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 4, info[4], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->framebufferTexture2D(arg1_target, arg2_attachment, arg3_textarget, arg4_texture, arg5_level);
}

void FrontFaceOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_frontFace");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.frontFace");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_mode = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->frontFace(arg1_mode);
}

void GenerateMipmapOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_generateMipmap");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.generateMipmap");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->generateMipmap(arg1_target);
}

void GetActiveAttribOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_getActiveAttrib");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.getActiveAttrib");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_program = NativeValueTraits<WebGLProgram>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_index = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->getActiveAttrib(arg1_program, arg2_index);
    static_assert(bindings::IsReturnTypeCompatible<WebGLActiveInfo, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void GetActiveUniformOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_getActiveUniform");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.getActiveUniform");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_program = NativeValueTraits<WebGLProgram>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_index = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->getActiveUniform(arg1_program, arg2_index);
    static_assert(bindings::IsReturnTypeCompatible<WebGLActiveInfo, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void GetAttachedShadersOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_getAttachedShaders");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.getAttachedShaders");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_program = NativeValueTraits<WebGLProgram>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->getAttachedShaders(arg1_program);
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLSequence<WebGLShader>>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    v8::Local<v8::Value> v8_return_value = ToV8Traits<IDLNullable<IDLSequence<WebGLShader>>>::ToV8(script_state, return_value);
    bindings::V8SetReturnValue(info, v8_return_value);
}

void GetAttribLocationOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_getAttribLocation");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.getAttribLocation");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_program = NativeValueTraits<WebGLProgram>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_name = NativeValueTraits<IDLString>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->getAttribLocation(arg1_program, arg2_name);
    static_assert(bindings::IsReturnTypeCompatible<IDLLong, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<int32_t>());
}

void GetBufferParameterOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_getBufferParameter");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.getBufferParameter");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    ExceptionState exception_state(isolate);
    auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_pname = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->getBufferParameter(script_state, arg1_target, arg2_pname);
    static_assert(bindings::IsReturnTypeCompatible<IDLAny, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value);
}

void GetContextAttributesOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_getContextAttributes");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.getContextAttributes");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->getContextAttributes();
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<WebGLContextAttributes>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    v8::Local<v8::Value> v8_return_value = ToV8Traits<IDLNullable<WebGLContextAttributes>>::ToV8(script_state, return_value);
    bindings::V8SetReturnValue(info, v8_return_value);
}

void GetErrorOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_getError");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.getError");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->getError();
    static_assert(bindings::IsReturnTypeCompatible<IDLUnsignedLong, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<uint32_t>());
}

void GetExtensionOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_getExtension");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.getExtension");

    // [HighEntropy]
    const Dactyloscoper::HighEntropyTracer high_entropy_tracer("WebGLRenderingContext.getExtension", info);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kV8WebGLRenderingContext_GetExtension_Method);

    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    decltype(NativeValueTraits<IDLString>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg1_name;
    if (info[0]->IsString()) [[likely]] {
        arg1_name.Init(isolate, info[0].As<v8::String>());
    } else {
        ExceptionState exception_state(isolate);
        arg1_name = NativeValueTraits<IDLString>::ArgumentValue(isolate, 0, info[0], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->getExtension(script_state, arg1_name);
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLObject>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value);
}

void GetFramebufferAttachmentParameterOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_getFramebufferAttachmentParameter");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.getFramebufferAttachmentParameter");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 3) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(3, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    ExceptionState exception_state(isolate);
    auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_attachment = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_pname = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->getFramebufferAttachmentParameter(script_state, arg1_target, arg2_attachment, arg3_pname);
    static_assert(bindings::IsReturnTypeCompatible<IDLAny, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value);
}

void GetParameterOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_getParameter");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.getParameter");

    // [HighEntropy]
    const Dactyloscoper::HighEntropyTracer high_entropy_tracer("WebGLRenderingContext.getParameter", info);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kWebGLRenderingContextGetParameter);

    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    ExceptionState exception_state(isolate);
    auto&& arg1_pname = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->getParameter(script_state, arg1_pname);
    static_assert(bindings::IsReturnTypeCompatible<IDLAny, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value);
}

void GetProgramInfoLogOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_getProgramInfoLog");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.getProgramInfoLog");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_program = NativeValueTraits<WebGLProgram>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->getProgramInfoLog(arg1_program);
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void GetProgramParameterOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_getProgramParameter");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.getProgramParameter");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    ExceptionState exception_state(isolate);
    auto&& arg1_program = NativeValueTraits<WebGLProgram>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_pname = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->getProgramParameter(script_state, arg1_program, arg2_pname);
    static_assert(bindings::IsReturnTypeCompatible<IDLAny, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value);
}

void GetRenderbufferParameterOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_getRenderbufferParameter");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.getRenderbufferParameter");

    // [HighEntropy]
    const Dactyloscoper::HighEntropyTracer high_entropy_tracer("WebGLRenderingContext.getRenderbufferParameter", info);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kWebGLRenderingContextGetRenderbufferParameter);

    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    ExceptionState exception_state(isolate);
    auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_pname = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->getRenderbufferParameter(script_state, arg1_target, arg2_pname);
    static_assert(bindings::IsReturnTypeCompatible<IDLAny, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value);
}

void GetShaderInfoLogOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_getShaderInfoLog");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.getShaderInfoLog");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_shader = NativeValueTraits<WebGLShader>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->getShaderInfoLog(arg1_shader);
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void GetShaderParameterOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_getShaderParameter");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.getShaderParameter");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    ExceptionState exception_state(isolate);
    auto&& arg1_shader = NativeValueTraits<WebGLShader>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_pname = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->getShaderParameter(script_state, arg1_shader, arg2_pname);
    static_assert(bindings::IsReturnTypeCompatible<IDLAny, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value);
}

void GetShaderPrecisionFormatOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_getShaderPrecisionFormat");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.getShaderPrecisionFormat");

    // [HighEntropy]
    const Dactyloscoper::HighEntropyTracer high_entropy_tracer("WebGLRenderingContext.getShaderPrecisionFormat", info);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kWebGLRenderingContextGetShaderPrecisionFormat);

    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_shadertype = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_precisiontype = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->getShaderPrecisionFormat(arg1_shadertype, arg2_precisiontype);
    static_assert(bindings::IsReturnTypeCompatible<WebGLShaderPrecisionFormat, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void GetShaderSourceOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_getShaderSource");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.getShaderSource");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_shader = NativeValueTraits<WebGLShader>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->getShaderSource(arg1_shader);
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void GetSupportedExtensionsOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_getSupportedExtensions");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.getSupportedExtensions");

    // [HighEntropy]
    const Dactyloscoper::HighEntropyTracer high_entropy_tracer("WebGLRenderingContext.getSupportedExtensions", info);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kV8WebGLRenderingContext_GetSupportedExtensions_Method);

    v8::Local<v8::Object> v8_receiver = info.This();
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->getSupportedExtensions();
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<IDLSequence<IDLString>>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    v8::Local<v8::Value> v8_return_value = ToV8Traits<IDLNullable<IDLSequence<IDLString>>>::ToV8(script_state, return_value);
    bindings::V8SetReturnValue(info, v8_return_value);
    // [HighEntropy=Direct]
    Dactyloscoper::RecordDirectSurface(current_execution_context, WebFeature::kV8WebGLRenderingContext_GetSupportedExtensions_Method, return_value);
}

void GetTexParameterOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_getTexParameter");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.getTexParameter");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    ExceptionState exception_state(isolate);
    auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_pname = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->getTexParameter(script_state, arg1_target, arg2_pname);
    static_assert(bindings::IsReturnTypeCompatible<IDLAny, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value);
}

void GetUniformOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_getUniform");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.getUniform");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    ExceptionState exception_state(isolate);
    auto&& arg1_program = NativeValueTraits<WebGLProgram>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_location = NativeValueTraits<WebGLUniformLocation>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->getUniform(script_state, arg1_program, arg2_location);
    static_assert(bindings::IsReturnTypeCompatible<IDLAny, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value);
}

void GetUniformLocationOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_getUniformLocation");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.getUniformLocation");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_program = NativeValueTraits<WebGLProgram>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_name = NativeValueTraits<IDLString>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->getUniformLocation(arg1_program, arg2_name);
    static_assert(bindings::IsReturnTypeCompatible<WebGLUniformLocation, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void GetVertexAttribOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_getVertexAttrib");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.getVertexAttrib");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    ExceptionState exception_state(isolate);
    auto&& arg1_index = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_pname = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->getVertexAttrib(script_state, arg1_index, arg2_pname);
    static_assert(bindings::IsReturnTypeCompatible<IDLAny, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value);
}

void GetVertexAttribOffsetOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_getVertexAttribOffset");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.getVertexAttribOffset");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_index = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_pname = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->getVertexAttribOffset(arg1_index, arg2_pname);
    static_assert(bindings::IsReturnTypeCompatible<IDLLongLong, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<int64_t>());
}

void HintOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_hint");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.hint");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_mode = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->hint(arg1_target, arg2_mode);
}

void IsBufferOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_isBuffer");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.isBuffer");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_buffer = NativeValueTraits<IDLNullable<WebGLBuffer>>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->isBuffer(arg1_buffer);
    static_assert(bindings::IsReturnTypeCompatible<IDLBoolean, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void IsContextLostOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_isContextLost");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.isContextLost");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->isContextLost();
    static_assert(bindings::IsReturnTypeCompatible<IDLBoolean, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void IsEnabledOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_isEnabled");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.isEnabled");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_cap = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->isEnabled(arg1_cap);
    static_assert(bindings::IsReturnTypeCompatible<IDLBoolean, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void IsFramebufferOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_isFramebuffer");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.isFramebuffer");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_framebuffer = NativeValueTraits<IDLNullable<WebGLFramebuffer>>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->isFramebuffer(arg1_framebuffer);
    static_assert(bindings::IsReturnTypeCompatible<IDLBoolean, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void IsProgramOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_isProgram");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.isProgram");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_program = NativeValueTraits<IDLNullable<WebGLProgram>>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->isProgram(arg1_program);
    static_assert(bindings::IsReturnTypeCompatible<IDLBoolean, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void IsRenderbufferOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_isRenderbuffer");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.isRenderbuffer");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_renderbuffer = NativeValueTraits<IDLNullable<WebGLRenderbuffer>>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->isRenderbuffer(arg1_renderbuffer);
    static_assert(bindings::IsReturnTypeCompatible<IDLBoolean, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void IsShaderOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_isShader");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.isShader");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_shader = NativeValueTraits<IDLNullable<WebGLShader>>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->isShader(arg1_shader);
    static_assert(bindings::IsReturnTypeCompatible<IDLBoolean, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void IsTextureOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_isTexture");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.isTexture");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_texture = NativeValueTraits<IDLNullable<WebGLTexture>>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->isTexture(arg1_texture);
    static_assert(bindings::IsReturnTypeCompatible<IDLBoolean, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void LineWidthOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_lineWidth");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.lineWidth");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_width = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->lineWidth(arg1_width);
}

void LinkProgramOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_linkProgram");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.linkProgram");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_program = NativeValueTraits<WebGLProgram>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->linkProgram(arg1_program);
}

void MakeXRCompatibleOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_makeXRCompatible");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.makeXRCompatible");
    // Promise returning function: Convert a TypeError to a reject promise.
    ExceptionToRejectPromiseScope reject_promise_scope(info);

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    if (!V8WebGLRenderingContext::HasInstance(isolate, v8_receiver)) {
        V8ThrowException::ThrowTypeError(isolate, "Illegal invocation");
        return;
    }

    // [HighEntropy]
    const Dactyloscoper::HighEntropyTracer high_entropy_tracer("WebGLRenderingContext.makeXRCompatible", info);
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kWebGLRenderingContextMakeXRCompatible);

    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    const v8::ExceptionContext exception_context_type = v8::ExceptionContext::kOperation;
    const char* const class_like_name = "WebGLRenderingContext";
    const char* const property_name = "makeXRCompatible";
    ExceptionState exception_state(isolate, exception_context_type, class_like_name, property_name);
    ScriptPromise<IDLUndefined> return_value = blink_receiver->makeXRCompatible(script_state, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value);
}

void PixelStoreiOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_pixelStorei");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.pixelStorei");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_pname = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_param = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->pixelStorei(arg1_pname, arg2_param);
}

void PolygonOffsetOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_polygonOffset");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.polygonOffset");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_factor = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_units = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->polygonOffset(arg1_factor, arg2_units);
}

void ReadPixelsOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_readPixels");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.readPixels");

    // [HighEntropy]
    const Dactyloscoper::HighEntropyTracer high_entropy_tracer("WebGLRenderingContext.readPixels", info);

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 7) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(7, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_x = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_y = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_width = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg4_height = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 3, info[3], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg5_format = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 4, info[4], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg6_type = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 5, info[5], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg7_pixels
        = NativeValueTraits<IDLNullable<IDLBufferSourceTypeNoSizeLimit<MaybeShared<DOMArrayBufferView>>>>::ArgumentValue(isolate, 6, info[6], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->readPixels(arg1_x, arg2_y, arg3_width, arg4_height, arg5_format, arg6_type, arg7_pixels);
}

void RenderbufferStorageOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_renderbufferStorage");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.renderbufferStorage");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 4) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(4, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_internalformat = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_width = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg4_height = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 3, info[3], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->renderbufferStorage(arg1_target, arg2_internalformat, arg3_width, arg4_height);
}

void SampleCoverageOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_sampleCoverage");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.sampleCoverage");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_value = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_invert = NativeValueTraits<IDLBoolean>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->sampleCoverage(arg1_value, arg2_invert);
}

void ScissorOperationNoAllocDirectCallArg4(v8::Local<v8::Object> v8_arg0_receiver, int32_t v8_arg1_x, int32_t v8_arg2_y, int32_t v8_arg3_width,
    int32_t v8_arg4_height, v8::FastApiCallbackOptions& v8_arg_callback_options)
{
    v8::Isolate* isolate = v8_arg_callback_options.isolate;
    v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& arg1_x = v8_arg1_x;
    auto&& arg2_y = v8_arg2_y;
    auto&& arg3_width = v8_arg3_width;
    auto&& arg4_height = v8_arg4_height;
    blink_receiver->scissor(arg1_x, arg2_y, arg3_width, arg4_height);
}

void ScissorOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_scissor");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.scissor");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 4) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(4, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_x = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_y = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_width = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg4_height = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 3, info[3], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->scissor(arg1_x, arg2_y, arg3_width, arg4_height);
}

void ShaderSourceOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_shaderSource");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.shaderSource");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_shader = NativeValueTraits<WebGLShader>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_string = NativeValueTraits<IDLString>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->shaderSource(arg1_shader, arg2_string);
}

void StencilFuncOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_stencilFunc");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.stencilFunc");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 3) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(3, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_func = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_ref = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_mask = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->stencilFunc(arg1_func, arg2_ref, arg3_mask);
}

void StencilFuncSeparateOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_stencilFuncSeparate");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.stencilFuncSeparate");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 4) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(4, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_face = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_func = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_ref = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg4_mask = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 3, info[3], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->stencilFuncSeparate(arg1_face, arg2_func, arg3_ref, arg4_mask);
}

void StencilMaskOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_stencilMask");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.stencilMask");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_mask = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->stencilMask(arg1_mask);
}

void StencilMaskSeparateOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_stencilMaskSeparate");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.stencilMaskSeparate");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_face = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_mask = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->stencilMaskSeparate(arg1_face, arg2_mask);
}

void StencilOpOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_stencilOp");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.stencilOp");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 3) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(3, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_fail = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_zfail = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_zpass = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->stencilOp(arg1_fail, arg2_zfail, arg3_zpass);
}

void StencilOpSeparateOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_stencilOpSeparate");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.stencilOpSeparate");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 4) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(4, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_face = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_fail = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_zfail = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg4_zpass = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 3, info[3], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->stencilOpSeparate(arg1_face, arg2_fail, arg3_zfail, arg4_zpass);
}

void TexImage2DOperationOverload1(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 9) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(9, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_level = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_internalformat = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg4_width = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 3, info[3], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg5_height = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 4, info[4], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg6_border = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 5, info[5], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg7_format = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 6, info[6], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg8_type = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 7, info[7], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg9_pixels
        = NativeValueTraits<IDLNullable<IDLBufferSourceTypeNoSizeLimit<MaybeShared<DOMArrayBufferView>>>>::ArgumentValue(isolate, 8, info[8], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->texImage2D(arg1_target, arg2_level, arg3_internalformat, arg4_width, arg5_height, arg6_border, arg7_format, arg8_type, arg9_pixels);
}

void TexImage2DOperationOverload2(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 6) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(6, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_level = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_internalformat = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg4_format = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 3, info[3], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg5_type = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 4, info[4], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg6_pixels = NativeValueTraits<ImageData>::ArgumentValue(isolate, 5, info[5], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->texImage2D(arg1_target, arg2_level, arg3_internalformat, arg4_format, arg5_type, arg6_pixels);
}

void TexImage2DOperationOverload3(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 6) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(6, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    ExceptionState exception_state(isolate);
    auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_level = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_internalformat = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg4_format = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 3, info[3], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg5_type = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 4, info[4], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg6_image = NativeValueTraits<HTMLImageElement>::ArgumentValue(isolate, 5, info[5], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->texImage2D(script_state, arg1_target, arg2_level, arg3_internalformat, arg4_format, arg5_type, arg6_image, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void TexImage2DOperationOverload4(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 6) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(6, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    ExceptionState exception_state(isolate);
    auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_level = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_internalformat = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg4_format = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 3, info[3], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg5_type = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 4, info[4], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg6_canvas = NativeValueTraits<HTMLCanvasElement>::ArgumentValue(isolate, 5, info[5], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->texImage2D(script_state, arg1_target, arg2_level, arg3_internalformat, arg4_format, arg5_type, arg6_canvas, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void TexImage2DOperationOverload5(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 6) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(6, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    ExceptionState exception_state(isolate);
    auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_level = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_internalformat = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg4_format = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 3, info[3], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg5_type = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 4, info[4], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg6_offscreen_canvas = NativeValueTraits<OffscreenCanvas>::ArgumentValue(isolate, 5, info[5], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->texImage2D(script_state, arg1_target, arg2_level, arg3_internalformat, arg4_format, arg5_type, arg6_offscreen_canvas, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void TexImage2DOperationOverload6(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 6) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(6, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    ExceptionState exception_state(isolate);
    auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_level = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_internalformat = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg4_format = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 3, info[3], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg5_type = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 4, info[4], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg6_video = NativeValueTraits<HTMLVideoElement>::ArgumentValue(isolate, 5, info[5], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->texImage2D(script_state, arg1_target, arg2_level, arg3_internalformat, arg4_format, arg5_type, arg6_video, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void TexImage2DOperationOverload7(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 6) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(6, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_level = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_internalformat = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg4_format = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 3, info[3], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg5_type = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 4, info[4], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg6_bitmap = NativeValueTraits<ImageBitmap>::ArgumentValue(isolate, 5, info[5], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->texImage2D(arg1_target, arg2_level, arg3_internalformat, arg4_format, arg5_type, arg6_bitmap, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void TexImage2DOperationOverload8(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 6) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(6, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    ExceptionState exception_state(isolate);
    auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_level = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_internalformat = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg4_format = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 3, info[3], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg5_type = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 4, info[4], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg6_frame = NativeValueTraits<VideoFrame>::ArgumentValue(isolate, 5, info[5], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->texImage2D(script_state, arg1_target, arg2_level, arg3_internalformat, arg4_format, arg5_type, arg6_frame, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void TexImage2DOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_texImage2D");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.texImage2D");

    BINDINGS_COOPERATIVE_SCHEDULING_SAFEPOINT();

    const int arg_count = std::min(info.Length(), 9);
    v8::Isolate* isolate = info.GetIsolate();
    do { // Dummy loop for use of 'break'.
        if (arg_count == 9) {
            return TexImage2DOperationOverload1(info);
        }
        if (arg_count == 6) {
            if (info[5]->IsObject()) {
                if (V8HTMLVideoElement::HasInstance(isolate, info[5])) {
                    return TexImage2DOperationOverload6(info);
                }
                if (V8HTMLImageElement::HasInstance(isolate, info[5])) {
                    return TexImage2DOperationOverload3(info);
                }
                if (V8HTMLCanvasElement::HasInstance(isolate, info[5])) {
                    return TexImage2DOperationOverload4(info);
                }
                if (V8OffscreenCanvas::HasInstance(isolate, info[5])) {
                    return TexImage2DOperationOverload5(info);
                }
                if (V8VideoFrame::HasInstance(isolate, info[5])) {
                    return TexImage2DOperationOverload8(info);
                }
                if (V8ImageData::HasInstance(isolate, info[5])) {
                    return TexImage2DOperationOverload2(info);
                }
                if (V8ImageBitmap::HasInstance(isolate, info[5])) {
                    return TexImage2DOperationOverload7(info);
                }
            }
            break;
        }
    } while (false);

    if (info.Length() < 6) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(6, info.Length()));
        return;
    }
    V8ThrowException::ThrowTypeError(isolate, "Overload resolution failed.");
    return;
}

void TexParameterfOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_texParameterf");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.texParameterf");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 3) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(3, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_pname = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_param = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->texParameterf(arg1_target, arg2_pname, arg3_param);
}

void TexParameteriOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_texParameteri");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.texParameteri");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 3) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(3, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_pname = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_param = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->texParameteri(arg1_target, arg2_pname, arg3_param);
}

void TexSubImage2DOperationOverload1(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 9) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(9, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_level = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_xoffset = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg4_yoffset = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 3, info[3], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg5_width = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 4, info[4], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg6_height = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 5, info[5], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg7_format = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 6, info[6], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg8_type = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 7, info[7], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg9_pixels
        = NativeValueTraits<IDLNullable<IDLBufferSourceTypeNoSizeLimit<MaybeShared<DOMArrayBufferView>>>>::ArgumentValue(isolate, 8, info[8], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->texSubImage2D(arg1_target, arg2_level, arg3_xoffset, arg4_yoffset, arg5_width, arg6_height, arg7_format, arg8_type, arg9_pixels);
}

void TexSubImage2DOperationOverload2(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 7) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(7, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_level = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_xoffset = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg4_yoffset = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 3, info[3], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg5_format = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 4, info[4], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg6_type = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 5, info[5], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg7_pixels = NativeValueTraits<ImageData>::ArgumentValue(isolate, 6, info[6], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->texSubImage2D(arg1_target, arg2_level, arg3_xoffset, arg4_yoffset, arg5_format, arg6_type, arg7_pixels);
}

void TexSubImage2DOperationOverload3(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 7) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(7, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    ExceptionState exception_state(isolate);
    auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_level = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_xoffset = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg4_yoffset = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 3, info[3], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg5_format = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 4, info[4], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg6_type = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 5, info[5], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg7_image = NativeValueTraits<HTMLImageElement>::ArgumentValue(isolate, 6, info[6], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->texSubImage2D(script_state, arg1_target, arg2_level, arg3_xoffset, arg4_yoffset, arg5_format, arg6_type, arg7_image, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void TexSubImage2DOperationOverload4(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 7) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(7, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    ExceptionState exception_state(isolate);
    auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_level = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_xoffset = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg4_yoffset = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 3, info[3], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg5_format = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 4, info[4], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg6_type = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 5, info[5], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg7_canvas = NativeValueTraits<HTMLCanvasElement>::ArgumentValue(isolate, 6, info[6], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->texSubImage2D(script_state, arg1_target, arg2_level, arg3_xoffset, arg4_yoffset, arg5_format, arg6_type, arg7_canvas, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void TexSubImage2DOperationOverload5(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 7) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(7, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    ExceptionState exception_state(isolate);
    auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_level = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_xoffset = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg4_yoffset = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 3, info[3], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg5_format = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 4, info[4], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg6_type = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 5, info[5], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg7_offscreen_canvas = NativeValueTraits<OffscreenCanvas>::ArgumentValue(isolate, 6, info[6], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->texSubImage2D(
        script_state, arg1_target, arg2_level, arg3_xoffset, arg4_yoffset, arg5_format, arg6_type, arg7_offscreen_canvas, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void TexSubImage2DOperationOverload6(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 7) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(7, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    ExceptionState exception_state(isolate);
    auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_level = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_xoffset = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg4_yoffset = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 3, info[3], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg5_format = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 4, info[4], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg6_type = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 5, info[5], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg7_video = NativeValueTraits<HTMLVideoElement>::ArgumentValue(isolate, 6, info[6], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->texSubImage2D(script_state, arg1_target, arg2_level, arg3_xoffset, arg4_yoffset, arg5_format, arg6_type, arg7_video, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void TexSubImage2DOperationOverload7(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 7) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(7, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_level = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_xoffset = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg4_yoffset = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 3, info[3], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg5_format = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 4, info[4], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg6_type = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 5, info[5], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg7_bitmap = NativeValueTraits<ImageBitmap>::ArgumentValue(isolate, 6, info[6], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->texSubImage2D(arg1_target, arg2_level, arg3_xoffset, arg4_yoffset, arg5_format, arg6_type, arg7_bitmap, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void TexSubImage2DOperationOverload8(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 7) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(7, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    ExceptionState exception_state(isolate);
    auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_level = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_xoffset = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg4_yoffset = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 3, info[3], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg5_format = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 4, info[4], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg6_type = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 5, info[5], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg7_frame = NativeValueTraits<VideoFrame>::ArgumentValue(isolate, 6, info[6], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->texSubImage2D(script_state, arg1_target, arg2_level, arg3_xoffset, arg4_yoffset, arg5_format, arg6_type, arg7_frame, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
}

void TexSubImage2DOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_texSubImage2D");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.texSubImage2D");

    BINDINGS_COOPERATIVE_SCHEDULING_SAFEPOINT();

    const int arg_count = std::min(info.Length(), 9);
    v8::Isolate* isolate = info.GetIsolate();
    do { // Dummy loop for use of 'break'.
        if (arg_count == 9) {
            return TexSubImage2DOperationOverload1(info);
        }
        if (arg_count == 7) {
            if (info[6]->IsObject()) {
                if (V8HTMLVideoElement::HasInstance(isolate, info[6])) {
                    return TexSubImage2DOperationOverload6(info);
                }
                if (V8HTMLImageElement::HasInstance(isolate, info[6])) {
                    return TexSubImage2DOperationOverload3(info);
                }
                if (V8HTMLCanvasElement::HasInstance(isolate, info[6])) {
                    return TexSubImage2DOperationOverload4(info);
                }
                if (V8OffscreenCanvas::HasInstance(isolate, info[6])) {
                    return TexSubImage2DOperationOverload5(info);
                }
                if (V8VideoFrame::HasInstance(isolate, info[6])) {
                    return TexSubImage2DOperationOverload8(info);
                }
                if (V8ImageData::HasInstance(isolate, info[6])) {
                    return TexSubImage2DOperationOverload2(info);
                }
                if (V8ImageBitmap::HasInstance(isolate, info[6])) {
                    return TexSubImage2DOperationOverload7(info);
                }
            }
            break;
        }
    } while (false);

    if (info.Length() < 7) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(7, info.Length()));
        return;
    }
    V8ThrowException::ThrowTypeError(isolate, "Overload resolution failed.");
    return;
}

void Uniform1FOperationNoAllocDirectCallArg2(
    v8::Local<v8::Object> v8_arg0_receiver, v8::Local<v8::Value> v8_arg1_location, float v8_arg2_x, v8::FastApiCallbackOptions& v8_arg_callback_options)
{
    v8::Isolate* isolate = v8_arg_callback_options.isolate;
    v8::HandleScope handle_scope(isolate);

    v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, v8_arg1_location, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_x = v8_arg2_x;
    blink_receiver->uniform1f(arg1_location, arg2_x);
}

void Uniform1FOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_uniform1f");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.uniform1f");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_x = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->uniform1f(arg1_location, arg2_x);
}

void Uniform1FvOperationNoAllocDirectCallArg2(v8::Local<v8::Object> v8_arg0_receiver, v8::Local<v8::Value> v8_arg1_location, v8::Local<v8::Value> v8_arg2_v,
    v8::FastApiCallbackOptions& v8_arg_callback_options)
{
    v8::Isolate* isolate = v8_arg_callback_options.isolate;
    v8::HandleScope handle_scope(isolate);

    v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, v8_arg1_location, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_v
        = NativeValueTraits<PassAsSpan<PassAsSpanMarkerBase::Flags::kAllowSequence | PassAsSpanMarkerBase::Flags::kAllowShared, float>>::ArgumentValue(
            isolate, 1, v8_arg2_v, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->uniform1fv(arg1_location, arg2_v);
}

void Uniform1FvOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_uniform1fv");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.uniform1fv");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_v
        = NativeValueTraits<PassAsSpan<PassAsSpanMarkerBase::Flags::kAllowSequence | PassAsSpanMarkerBase::Flags::kAllowShared, float>>::ArgumentValue(
            isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->uniform1fv(arg1_location, arg2_v);
}

void Uniform1IOperationNoAllocDirectCallArg2(
    v8::Local<v8::Object> v8_arg0_receiver, v8::Local<v8::Value> v8_arg1_location, int32_t v8_arg2_x, v8::FastApiCallbackOptions& v8_arg_callback_options)
{
    v8::Isolate* isolate = v8_arg_callback_options.isolate;
    v8::HandleScope handle_scope(isolate);

    v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, v8_arg1_location, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_x = v8_arg2_x;
    blink_receiver->uniform1i(arg1_location, arg2_x);
}

void Uniform1IOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_uniform1i");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.uniform1i");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_x = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->uniform1i(arg1_location, arg2_x);
}

void Uniform1IvOperationNoAllocDirectCallArg2(v8::Local<v8::Object> v8_arg0_receiver, v8::Local<v8::Value> v8_arg1_location, v8::Local<v8::Value> v8_arg2_v,
    v8::FastApiCallbackOptions& v8_arg_callback_options)
{
    v8::Isolate* isolate = v8_arg_callback_options.isolate;
    v8::HandleScope handle_scope(isolate);

    v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, v8_arg1_location, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_v
        = NativeValueTraits<PassAsSpan<PassAsSpanMarkerBase::Flags::kAllowSequence | PassAsSpanMarkerBase::Flags::kAllowShared, int32_t>>::ArgumentValue(
            isolate, 1, v8_arg2_v, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->uniform1iv(arg1_location, arg2_v);
}

void Uniform1IvOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_uniform1iv");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.uniform1iv");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_v
        = NativeValueTraits<PassAsSpan<PassAsSpanMarkerBase::Flags::kAllowSequence | PassAsSpanMarkerBase::Flags::kAllowShared, int32_t>>::ArgumentValue(
            isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->uniform1iv(arg1_location, arg2_v);
}

void Uniform2FOperationNoAllocDirectCallArg3(v8::Local<v8::Object> v8_arg0_receiver, v8::Local<v8::Value> v8_arg1_location, float v8_arg2_x, float v8_arg3_y,
    v8::FastApiCallbackOptions& v8_arg_callback_options)
{
    v8::Isolate* isolate = v8_arg_callback_options.isolate;
    v8::HandleScope handle_scope(isolate);

    v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, v8_arg1_location, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_x = v8_arg2_x;
    auto&& arg3_y = v8_arg3_y;
    blink_receiver->uniform2f(arg1_location, arg2_x, arg3_y);
}

void Uniform2FOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_uniform2f");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.uniform2f");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 3) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(3, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_x = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_y = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->uniform2f(arg1_location, arg2_x, arg3_y);
}

void Uniform2FvOperationNoAllocDirectCallArg2(v8::Local<v8::Object> v8_arg0_receiver, v8::Local<v8::Value> v8_arg1_location, v8::Local<v8::Value> v8_arg2_v,
    v8::FastApiCallbackOptions& v8_arg_callback_options)
{
    v8::Isolate* isolate = v8_arg_callback_options.isolate;
    v8::HandleScope handle_scope(isolate);

    v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, v8_arg1_location, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_v
        = NativeValueTraits<PassAsSpan<PassAsSpanMarkerBase::Flags::kAllowSequence | PassAsSpanMarkerBase::Flags::kAllowShared, float>>::ArgumentValue(
            isolate, 1, v8_arg2_v, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->uniform2fv(arg1_location, arg2_v);
}

void Uniform2FvOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_uniform2fv");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.uniform2fv");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_v
        = NativeValueTraits<PassAsSpan<PassAsSpanMarkerBase::Flags::kAllowSequence | PassAsSpanMarkerBase::Flags::kAllowShared, float>>::ArgumentValue(
            isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->uniform2fv(arg1_location, arg2_v);
}

void Uniform2IOperationNoAllocDirectCallArg3(v8::Local<v8::Object> v8_arg0_receiver, v8::Local<v8::Value> v8_arg1_location, int32_t v8_arg2_x,
    int32_t v8_arg3_y, v8::FastApiCallbackOptions& v8_arg_callback_options)
{
    v8::Isolate* isolate = v8_arg_callback_options.isolate;
    v8::HandleScope handle_scope(isolate);

    v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, v8_arg1_location, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_x = v8_arg2_x;
    auto&& arg3_y = v8_arg3_y;
    blink_receiver->uniform2i(arg1_location, arg2_x, arg3_y);
}

void Uniform2IOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_uniform2i");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.uniform2i");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 3) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(3, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_x = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_y = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->uniform2i(arg1_location, arg2_x, arg3_y);
}

void Uniform2IvOperationNoAllocDirectCallArg2(v8::Local<v8::Object> v8_arg0_receiver, v8::Local<v8::Value> v8_arg1_location, v8::Local<v8::Value> v8_arg2_v,
    v8::FastApiCallbackOptions& v8_arg_callback_options)
{
    v8::Isolate* isolate = v8_arg_callback_options.isolate;
    v8::HandleScope handle_scope(isolate);

    v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, v8_arg1_location, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_v
        = NativeValueTraits<PassAsSpan<PassAsSpanMarkerBase::Flags::kAllowSequence | PassAsSpanMarkerBase::Flags::kAllowShared, int32_t>>::ArgumentValue(
            isolate, 1, v8_arg2_v, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->uniform2iv(arg1_location, arg2_v);
}

void Uniform2IvOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_uniform2iv");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.uniform2iv");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_v
        = NativeValueTraits<PassAsSpan<PassAsSpanMarkerBase::Flags::kAllowSequence | PassAsSpanMarkerBase::Flags::kAllowShared, int32_t>>::ArgumentValue(
            isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->uniform2iv(arg1_location, arg2_v);
}

void Uniform3FOperationNoAllocDirectCallArg4(v8::Local<v8::Object> v8_arg0_receiver, v8::Local<v8::Value> v8_arg1_location, float v8_arg2_x, float v8_arg3_y,
    float v8_arg4_z, v8::FastApiCallbackOptions& v8_arg_callback_options)
{
    v8::Isolate* isolate = v8_arg_callback_options.isolate;
    v8::HandleScope handle_scope(isolate);

    v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, v8_arg1_location, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_x = v8_arg2_x;
    auto&& arg3_y = v8_arg3_y;
    auto&& arg4_z = v8_arg4_z;
    blink_receiver->uniform3f(arg1_location, arg2_x, arg3_y, arg4_z);
}

void Uniform3FOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_uniform3f");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.uniform3f");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 4) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(4, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_x = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_y = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg4_z = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 3, info[3], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->uniform3f(arg1_location, arg2_x, arg3_y, arg4_z);
}

void Uniform3FvOperationNoAllocDirectCallArg2(v8::Local<v8::Object> v8_arg0_receiver, v8::Local<v8::Value> v8_arg1_location, v8::Local<v8::Value> v8_arg2_v,
    v8::FastApiCallbackOptions& v8_arg_callback_options)
{
    v8::Isolate* isolate = v8_arg_callback_options.isolate;
    v8::HandleScope handle_scope(isolate);

    v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, v8_arg1_location, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_v
        = NativeValueTraits<PassAsSpan<PassAsSpanMarkerBase::Flags::kAllowSequence | PassAsSpanMarkerBase::Flags::kAllowShared, float>>::ArgumentValue(
            isolate, 1, v8_arg2_v, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->uniform3fv(arg1_location, arg2_v);
}

void Uniform3FvOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_uniform3fv");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.uniform3fv");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_v
        = NativeValueTraits<PassAsSpan<PassAsSpanMarkerBase::Flags::kAllowSequence | PassAsSpanMarkerBase::Flags::kAllowShared, float>>::ArgumentValue(
            isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->uniform3fv(arg1_location, arg2_v);
}

void Uniform3IOperationNoAllocDirectCallArg4(v8::Local<v8::Object> v8_arg0_receiver, v8::Local<v8::Value> v8_arg1_location, int32_t v8_arg2_x,
    int32_t v8_arg3_y, int32_t v8_arg4_z, v8::FastApiCallbackOptions& v8_arg_callback_options)
{
    v8::Isolate* isolate = v8_arg_callback_options.isolate;
    v8::HandleScope handle_scope(isolate);

    v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, v8_arg1_location, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_x = v8_arg2_x;
    auto&& arg3_y = v8_arg3_y;
    auto&& arg4_z = v8_arg4_z;
    blink_receiver->uniform3i(arg1_location, arg2_x, arg3_y, arg4_z);
}

void Uniform3IOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_uniform3i");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.uniform3i");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 4) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(4, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_x = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_y = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg4_z = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 3, info[3], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->uniform3i(arg1_location, arg2_x, arg3_y, arg4_z);
}

void Uniform3IvOperationNoAllocDirectCallArg2(v8::Local<v8::Object> v8_arg0_receiver, v8::Local<v8::Value> v8_arg1_location, v8::Local<v8::Value> v8_arg2_v,
    v8::FastApiCallbackOptions& v8_arg_callback_options)
{
    v8::Isolate* isolate = v8_arg_callback_options.isolate;
    v8::HandleScope handle_scope(isolate);

    v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, v8_arg1_location, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_v
        = NativeValueTraits<PassAsSpan<PassAsSpanMarkerBase::Flags::kAllowSequence | PassAsSpanMarkerBase::Flags::kAllowShared, int32_t>>::ArgumentValue(
            isolate, 1, v8_arg2_v, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->uniform3iv(arg1_location, arg2_v);
}

void Uniform3IvOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_uniform3iv");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.uniform3iv");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_v
        = NativeValueTraits<PassAsSpan<PassAsSpanMarkerBase::Flags::kAllowSequence | PassAsSpanMarkerBase::Flags::kAllowShared, int32_t>>::ArgumentValue(
            isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->uniform3iv(arg1_location, arg2_v);
}

void Uniform4FOperationNoAllocDirectCallArg5(v8::Local<v8::Object> v8_arg0_receiver, v8::Local<v8::Value> v8_arg1_location, float v8_arg2_x, float v8_arg3_y,
    float v8_arg4_z, float v8_arg5_w, v8::FastApiCallbackOptions& v8_arg_callback_options)
{
    v8::Isolate* isolate = v8_arg_callback_options.isolate;
    v8::HandleScope handle_scope(isolate);

    v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, v8_arg1_location, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_x = v8_arg2_x;
    auto&& arg3_y = v8_arg3_y;
    auto&& arg4_z = v8_arg4_z;
    auto&& arg5_w = v8_arg5_w;
    blink_receiver->uniform4f(arg1_location, arg2_x, arg3_y, arg4_z, arg5_w);
}

void Uniform4FOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_uniform4f");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.uniform4f");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 5) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(5, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_x = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_y = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg4_z = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 3, info[3], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg5_w = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 4, info[4], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->uniform4f(arg1_location, arg2_x, arg3_y, arg4_z, arg5_w);
}

void Uniform4FvOperationNoAllocDirectCallArg2(v8::Local<v8::Object> v8_arg0_receiver, v8::Local<v8::Value> v8_arg1_location, v8::Local<v8::Value> v8_arg2_v,
    v8::FastApiCallbackOptions& v8_arg_callback_options)
{
    v8::Isolate* isolate = v8_arg_callback_options.isolate;
    v8::HandleScope handle_scope(isolate);

    v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, v8_arg1_location, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_v
        = NativeValueTraits<PassAsSpan<PassAsSpanMarkerBase::Flags::kAllowSequence | PassAsSpanMarkerBase::Flags::kAllowShared, float>>::ArgumentValue(
            isolate, 1, v8_arg2_v, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->uniform4fv(arg1_location, arg2_v);
}

void Uniform4FvOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_uniform4fv");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.uniform4fv");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_v
        = NativeValueTraits<PassAsSpan<PassAsSpanMarkerBase::Flags::kAllowSequence | PassAsSpanMarkerBase::Flags::kAllowShared, float>>::ArgumentValue(
            isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->uniform4fv(arg1_location, arg2_v);
}

void Uniform4IOperationNoAllocDirectCallArg5(v8::Local<v8::Object> v8_arg0_receiver, v8::Local<v8::Value> v8_arg1_location, int32_t v8_arg2_x,
    int32_t v8_arg3_y, int32_t v8_arg4_z, int32_t v8_arg5_w, v8::FastApiCallbackOptions& v8_arg_callback_options)
{
    v8::Isolate* isolate = v8_arg_callback_options.isolate;
    v8::HandleScope handle_scope(isolate);

    v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, v8_arg1_location, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_x = v8_arg2_x;
    auto&& arg3_y = v8_arg3_y;
    auto&& arg4_z = v8_arg4_z;
    auto&& arg5_w = v8_arg5_w;
    blink_receiver->uniform4i(arg1_location, arg2_x, arg3_y, arg4_z, arg5_w);
}

void Uniform4IOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_uniform4i");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.uniform4i");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 5) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(5, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_x = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_y = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg4_z = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 3, info[3], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg5_w = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 4, info[4], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->uniform4i(arg1_location, arg2_x, arg3_y, arg4_z, arg5_w);
}

void Uniform4IvOperationNoAllocDirectCallArg2(v8::Local<v8::Object> v8_arg0_receiver, v8::Local<v8::Value> v8_arg1_location, v8::Local<v8::Value> v8_arg2_v,
    v8::FastApiCallbackOptions& v8_arg_callback_options)
{
    v8::Isolate* isolate = v8_arg_callback_options.isolate;
    v8::HandleScope handle_scope(isolate);

    v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, v8_arg1_location, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_v
        = NativeValueTraits<PassAsSpan<PassAsSpanMarkerBase::Flags::kAllowSequence | PassAsSpanMarkerBase::Flags::kAllowShared, int32_t>>::ArgumentValue(
            isolate, 1, v8_arg2_v, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->uniform4iv(arg1_location, arg2_v);
}

void Uniform4IvOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_uniform4iv");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.uniform4iv");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_v
        = NativeValueTraits<PassAsSpan<PassAsSpanMarkerBase::Flags::kAllowSequence | PassAsSpanMarkerBase::Flags::kAllowShared, int32_t>>::ArgumentValue(
            isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->uniform4iv(arg1_location, arg2_v);
}

void UniformMatrix2FvOperationNoAllocDirectCallArg3(v8::Local<v8::Object> v8_arg0_receiver, v8::Local<v8::Value> v8_arg1_location, bool v8_arg2_transpose,
    v8::Local<v8::Value> v8_arg3_array, v8::FastApiCallbackOptions& v8_arg_callback_options)
{
    v8::Isolate* isolate = v8_arg_callback_options.isolate;
    v8::HandleScope handle_scope(isolate);

    v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, v8_arg1_location, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_transpose = v8_arg2_transpose;
    auto&& arg3_array
        = NativeValueTraits<PassAsSpan<PassAsSpanMarkerBase::Flags::kAllowSequence | PassAsSpanMarkerBase::Flags::kAllowShared, float>>::ArgumentValue(
            isolate, 2, v8_arg3_array, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->uniformMatrix2fv(arg1_location, arg2_transpose, arg3_array);
}

void UniformMatrix2FvOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_uniformMatrix2fv");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.uniformMatrix2fv");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 3) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(3, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_transpose = NativeValueTraits<IDLBoolean>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_array
        = NativeValueTraits<PassAsSpan<PassAsSpanMarkerBase::Flags::kAllowSequence | PassAsSpanMarkerBase::Flags::kAllowShared, float>>::ArgumentValue(
            isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->uniformMatrix2fv(arg1_location, arg2_transpose, arg3_array);
}

void UniformMatrix3FvOperationNoAllocDirectCallArg3(v8::Local<v8::Object> v8_arg0_receiver, v8::Local<v8::Value> v8_arg1_location, bool v8_arg2_transpose,
    v8::Local<v8::Value> v8_arg3_array, v8::FastApiCallbackOptions& v8_arg_callback_options)
{
    v8::Isolate* isolate = v8_arg_callback_options.isolate;
    v8::HandleScope handle_scope(isolate);

    v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, v8_arg1_location, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_transpose = v8_arg2_transpose;
    auto&& arg3_array
        = NativeValueTraits<PassAsSpan<PassAsSpanMarkerBase::Flags::kAllowSequence | PassAsSpanMarkerBase::Flags::kAllowShared, float>>::ArgumentValue(
            isolate, 2, v8_arg3_array, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->uniformMatrix3fv(arg1_location, arg2_transpose, arg3_array);
}

void UniformMatrix3FvOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_uniformMatrix3fv");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.uniformMatrix3fv");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 3) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(3, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_transpose = NativeValueTraits<IDLBoolean>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_array
        = NativeValueTraits<PassAsSpan<PassAsSpanMarkerBase::Flags::kAllowSequence | PassAsSpanMarkerBase::Flags::kAllowShared, float>>::ArgumentValue(
            isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->uniformMatrix3fv(arg1_location, arg2_transpose, arg3_array);
}

void UniformMatrix4FvOperationNoAllocDirectCallArg3(v8::Local<v8::Object> v8_arg0_receiver, v8::Local<v8::Value> v8_arg1_location, bool v8_arg2_transpose,
    v8::Local<v8::Value> v8_arg3_array, v8::FastApiCallbackOptions& v8_arg_callback_options)
{
    v8::Isolate* isolate = v8_arg_callback_options.isolate;
    v8::HandleScope handle_scope(isolate);

    v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, v8_arg1_location, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_transpose = v8_arg2_transpose;
    auto&& arg3_array
        = NativeValueTraits<PassAsSpan<PassAsSpanMarkerBase::Flags::kAllowSequence | PassAsSpanMarkerBase::Flags::kAllowShared, float>>::ArgumentValue(
            isolate, 2, v8_arg3_array, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->uniformMatrix4fv(arg1_location, arg2_transpose, arg3_array);
}

void UniformMatrix4FvOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_uniformMatrix4fv");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.uniformMatrix4fv");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 3) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(3, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_transpose = NativeValueTraits<IDLBoolean>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_array
        = NativeValueTraits<PassAsSpan<PassAsSpanMarkerBase::Flags::kAllowSequence | PassAsSpanMarkerBase::Flags::kAllowShared, float>>::ArgumentValue(
            isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->uniformMatrix4fv(arg1_location, arg2_transpose, arg3_array);
}

void UseProgramOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_useProgram");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.useProgram");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_program = NativeValueTraits<IDLNullable<WebGLProgram>>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->useProgram(arg1_program);
}

void ValidateProgramOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_validateProgram");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.validateProgram");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_program = NativeValueTraits<WebGLProgram>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->validateProgram(arg1_program);
}

void VertexAttrib1FOperationNoAllocDirectCallArg2(
    v8::Local<v8::Object> v8_arg0_receiver, uint32_t v8_arg1_indx, float v8_arg2_x, v8::FastApiCallbackOptions& v8_arg_callback_options)
{
    v8::Isolate* isolate = v8_arg_callback_options.isolate;
    v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& arg1_indx = v8_arg1_indx;
    auto&& arg2_x = v8_arg2_x;
    blink_receiver->vertexAttrib1f(arg1_indx, arg2_x);
}

void VertexAttrib1FOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_vertexAttrib1f");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.vertexAttrib1f");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_indx = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_x = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->vertexAttrib1f(arg1_indx, arg2_x);
}

void VertexAttrib1FvOperationNoAllocDirectCallArg2(
    v8::Local<v8::Object> v8_arg0_receiver, uint32_t v8_arg1_indx, v8::Local<v8::Value> v8_arg2_values, v8::FastApiCallbackOptions& v8_arg_callback_options)
{
    v8::Isolate* isolate = v8_arg_callback_options.isolate;
    v8::HandleScope handle_scope(isolate);

    v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& arg1_indx = v8_arg1_indx;
    ExceptionState exception_state(isolate);
    auto&& arg2_values
        = NativeValueTraits<PassAsSpan<PassAsSpanMarkerBase::Flags::kAllowSequence | PassAsSpanMarkerBase::Flags::kAllowShared, float>>::ArgumentValue(
            isolate, 1, v8_arg2_values, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->vertexAttrib1fv(arg1_indx, arg2_values);
}

void VertexAttrib1FvOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_vertexAttrib1fv");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.vertexAttrib1fv");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_indx = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_values
        = NativeValueTraits<PassAsSpan<PassAsSpanMarkerBase::Flags::kAllowSequence | PassAsSpanMarkerBase::Flags::kAllowShared, float>>::ArgumentValue(
            isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->vertexAttrib1fv(arg1_indx, arg2_values);
}

void VertexAttrib2FOperationNoAllocDirectCallArg3(
    v8::Local<v8::Object> v8_arg0_receiver, uint32_t v8_arg1_indx, float v8_arg2_x, float v8_arg3_y, v8::FastApiCallbackOptions& v8_arg_callback_options)
{
    v8::Isolate* isolate = v8_arg_callback_options.isolate;
    v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& arg1_indx = v8_arg1_indx;
    auto&& arg2_x = v8_arg2_x;
    auto&& arg3_y = v8_arg3_y;
    blink_receiver->vertexAttrib2f(arg1_indx, arg2_x, arg3_y);
}

void VertexAttrib2FOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_vertexAttrib2f");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.vertexAttrib2f");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 3) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(3, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_indx = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_x = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_y = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->vertexAttrib2f(arg1_indx, arg2_x, arg3_y);
}

void VertexAttrib2FvOperationNoAllocDirectCallArg2(
    v8::Local<v8::Object> v8_arg0_receiver, uint32_t v8_arg1_indx, v8::Local<v8::Value> v8_arg2_values, v8::FastApiCallbackOptions& v8_arg_callback_options)
{
    v8::Isolate* isolate = v8_arg_callback_options.isolate;
    v8::HandleScope handle_scope(isolate);

    v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& arg1_indx = v8_arg1_indx;
    ExceptionState exception_state(isolate);
    auto&& arg2_values
        = NativeValueTraits<PassAsSpan<PassAsSpanMarkerBase::Flags::kAllowSequence | PassAsSpanMarkerBase::Flags::kAllowShared, float>>::ArgumentValue(
            isolate, 1, v8_arg2_values, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->vertexAttrib2fv(arg1_indx, arg2_values);
}

void VertexAttrib2FvOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_vertexAttrib2fv");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.vertexAttrib2fv");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_indx = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_values
        = NativeValueTraits<PassAsSpan<PassAsSpanMarkerBase::Flags::kAllowSequence | PassAsSpanMarkerBase::Flags::kAllowShared, float>>::ArgumentValue(
            isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->vertexAttrib2fv(arg1_indx, arg2_values);
}

void VertexAttrib3FOperationNoAllocDirectCallArg4(v8::Local<v8::Object> v8_arg0_receiver, uint32_t v8_arg1_indx, float v8_arg2_x, float v8_arg3_y,
    float v8_arg4_z, v8::FastApiCallbackOptions& v8_arg_callback_options)
{
    v8::Isolate* isolate = v8_arg_callback_options.isolate;
    v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& arg1_indx = v8_arg1_indx;
    auto&& arg2_x = v8_arg2_x;
    auto&& arg3_y = v8_arg3_y;
    auto&& arg4_z = v8_arg4_z;
    blink_receiver->vertexAttrib3f(arg1_indx, arg2_x, arg3_y, arg4_z);
}

void VertexAttrib3FOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_vertexAttrib3f");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.vertexAttrib3f");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 4) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(4, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_indx = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_x = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_y = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg4_z = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 3, info[3], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->vertexAttrib3f(arg1_indx, arg2_x, arg3_y, arg4_z);
}

void VertexAttrib3FvOperationNoAllocDirectCallArg2(
    v8::Local<v8::Object> v8_arg0_receiver, uint32_t v8_arg1_indx, v8::Local<v8::Value> v8_arg2_values, v8::FastApiCallbackOptions& v8_arg_callback_options)
{
    v8::Isolate* isolate = v8_arg_callback_options.isolate;
    v8::HandleScope handle_scope(isolate);

    v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& arg1_indx = v8_arg1_indx;
    ExceptionState exception_state(isolate);
    auto&& arg2_values
        = NativeValueTraits<PassAsSpan<PassAsSpanMarkerBase::Flags::kAllowSequence | PassAsSpanMarkerBase::Flags::kAllowShared, float>>::ArgumentValue(
            isolate, 1, v8_arg2_values, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->vertexAttrib3fv(arg1_indx, arg2_values);
}

void VertexAttrib3FvOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_vertexAttrib3fv");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.vertexAttrib3fv");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_indx = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_values
        = NativeValueTraits<PassAsSpan<PassAsSpanMarkerBase::Flags::kAllowSequence | PassAsSpanMarkerBase::Flags::kAllowShared, float>>::ArgumentValue(
            isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->vertexAttrib3fv(arg1_indx, arg2_values);
}

void VertexAttrib4FOperationNoAllocDirectCallArg5(v8::Local<v8::Object> v8_arg0_receiver, uint32_t v8_arg1_indx, float v8_arg2_x, float v8_arg3_y,
    float v8_arg4_z, float v8_arg5_w, v8::FastApiCallbackOptions& v8_arg_callback_options)
{
    v8::Isolate* isolate = v8_arg_callback_options.isolate;
    v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& arg1_indx = v8_arg1_indx;
    auto&& arg2_x = v8_arg2_x;
    auto&& arg3_y = v8_arg3_y;
    auto&& arg4_z = v8_arg4_z;
    auto&& arg5_w = v8_arg5_w;
    blink_receiver->vertexAttrib4f(arg1_indx, arg2_x, arg3_y, arg4_z, arg5_w);
}

void VertexAttrib4FOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_vertexAttrib4f");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.vertexAttrib4f");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 5) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(5, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_indx = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_x = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_y = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg4_z = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 3, info[3], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg5_w = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 4, info[4], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->vertexAttrib4f(arg1_indx, arg2_x, arg3_y, arg4_z, arg5_w);
}

void VertexAttrib4FvOperationNoAllocDirectCallArg2(
    v8::Local<v8::Object> v8_arg0_receiver, uint32_t v8_arg1_indx, v8::Local<v8::Value> v8_arg2_values, v8::FastApiCallbackOptions& v8_arg_callback_options)
{
    v8::Isolate* isolate = v8_arg_callback_options.isolate;
    v8::HandleScope handle_scope(isolate);

    v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& arg1_indx = v8_arg1_indx;
    ExceptionState exception_state(isolate);
    auto&& arg2_values
        = NativeValueTraits<PassAsSpan<PassAsSpanMarkerBase::Flags::kAllowSequence | PassAsSpanMarkerBase::Flags::kAllowShared, float>>::ArgumentValue(
            isolate, 1, v8_arg2_values, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->vertexAttrib4fv(arg1_indx, arg2_values);
}

void VertexAttrib4FvOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_vertexAttrib4fv");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.vertexAttrib4fv");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_indx = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_values
        = NativeValueTraits<PassAsSpan<PassAsSpanMarkerBase::Flags::kAllowSequence | PassAsSpanMarkerBase::Flags::kAllowShared, float>>::ArgumentValue(
            isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->vertexAttrib4fv(arg1_indx, arg2_values);
}

void VertexAttribPointerOperationNoAllocDirectCallArg6(v8::Local<v8::Object> v8_arg0_receiver, uint32_t v8_arg1_indx, int32_t v8_arg2_size,
    uint32_t v8_arg3_type, bool v8_arg4_normalized, int32_t v8_arg5_stride, int64_t v8_arg6_offset, v8::FastApiCallbackOptions& v8_arg_callback_options)
{
    v8::Isolate* isolate = v8_arg_callback_options.isolate;
    v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& arg1_indx = v8_arg1_indx;
    auto&& arg2_size = v8_arg2_size;
    auto&& arg3_type = v8_arg3_type;
    auto&& arg4_normalized = v8_arg4_normalized;
    auto&& arg5_stride = v8_arg5_stride;
    auto&& arg6_offset = v8_arg6_offset;
    blink_receiver->vertexAttribPointer(arg1_indx, arg2_size, arg3_type, arg4_normalized, arg5_stride, arg6_offset);
}

void VertexAttribPointerOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_vertexAttribPointer");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.vertexAttribPointer");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 6) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(6, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_indx = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_size = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_type = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg4_normalized = NativeValueTraits<IDLBoolean>::ArgumentValue(isolate, 3, info[3], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg5_stride = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 4, info[4], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg6_offset = NativeValueTraits<IDLLongLong>::ArgumentValue(isolate, 5, info[5], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->vertexAttribPointer(arg1_indx, arg2_size, arg3_type, arg4_normalized, arg5_stride, arg6_offset);
}

void ViewportOperationNoAllocDirectCallArg4(v8::Local<v8::Object> v8_arg0_receiver, int32_t v8_arg1_x, int32_t v8_arg2_y, int32_t v8_arg3_width,
    int32_t v8_arg4_height, v8::FastApiCallbackOptions& v8_arg_callback_options)
{
    v8::Isolate* isolate = v8_arg_callback_options.isolate;
    v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& arg1_x = v8_arg1_x;
    auto&& arg2_y = v8_arg2_y;
    auto&& arg3_width = v8_arg3_width;
    auto&& arg4_height = v8_arg4_height;
    blink_receiver->viewport(arg1_x, arg2_y, arg3_width, arg4_height);
}

void ViewportOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_viewport");
    BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.viewport");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 4) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(4, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_x = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_y = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_width = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg4_height = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 3, info[3], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->viewport(arg1_x, arg2_y, arg3_width, arg4_height);
}

} // namespace v8_webgl_rendering_context

using namespace v8_webgl_rendering_context;

} // namespace

void V8WebGLRenderingContext::InstallInterfaceTemplate(v8::Isolate* isolate, const DOMWrapperWorld& world, v8::Local<v8::Template> interface_template)
{
    const WrapperTypeInfo* const wrapper_type_info = V8WebGLRenderingContext::GetWrapperTypeInfo();
    v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
    v8::Local<v8::ObjectTemplate> instance_object_template = interface_function_template->InstanceTemplate();
    v8::Local<v8::ObjectTemplate> prototype_object_template = interface_function_template->PrototypeTemplate();
    v8::Local<v8::FunctionTemplate> parent_interface_template;
    bindings::SetupIDLInterfaceTemplate(
        isolate, wrapper_type_info, instance_object_template, prototype_object_template, interface_function_template, parent_interface_template);

    v8::Local<v8::Template> instance_template = instance_object_template;
    v8::Local<v8::Template> prototype_template = prototype_object_template;
    InstallUnconditionalProperties(isolate, world, instance_template, prototype_template, interface_template);
    InstallContextIndependentProperties(isolate, world, instance_template, prototype_template, interface_template);
}

void V8WebGLRenderingContext::InstallUnconditionalProperties(v8::Isolate* isolate, const DOMWrapperWorld& world, v8::Local<v8::Template> instance_template,
    v8::Local<v8::Template> prototype_template, v8::Local<v8::Template> interface_template)
{
    using bindings::IDLMemberInstaller;

    v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
    v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
    {
        static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
            { "canvas", "WebGLRenderingContext", CanvasAttributeGetCallback, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "drawingBufferWidth", "WebGLRenderingContext", DrawingBufferWidthAttributeGetCallback, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "drawingBufferHeight", "WebGLRenderingContext", DrawingBufferHeightAttributeGetCallback, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "drawingBufferColorSpace", "WebGLRenderingContext", DrawingBufferColorSpaceAttributeGetCallback, DrawingBufferColorSpaceAttributeSetCallback,
                unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "unpackColorSpace", "WebGLRenderingContext", UnpackColorSpaceAttributeGetCallback, UnpackColorSpaceAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
        };
        IDLMemberInstaller::InstallAttributes(isolate, world, instance_template, prototype_template, interface_template, signature, kAttributeTable);
    }

    {
        static const IDLMemberInstaller::ConstantValueConfig kConstantValueTable[] = {
            { "DEPTH_BUFFER_BIT", V8WebGLRenderingContext::Constant::kDepthBufferBit },
            { "STENCIL_BUFFER_BIT", V8WebGLRenderingContext::Constant::kStencilBufferBit },
            { "COLOR_BUFFER_BIT", V8WebGLRenderingContext::Constant::kColorBufferBit },
            { "POINTS", V8WebGLRenderingContext::Constant::kPoints },
            { "LINES", V8WebGLRenderingContext::Constant::kLines },
            { "LINE_LOOP", V8WebGLRenderingContext::Constant::kLineLoop },
            { "LINE_STRIP", V8WebGLRenderingContext::Constant::kLineStrip },
            { "TRIANGLES", V8WebGLRenderingContext::Constant::kTriangles },
            { "TRIANGLE_STRIP", V8WebGLRenderingContext::Constant::kTriangleStrip },
            { "TRIANGLE_FAN", V8WebGLRenderingContext::Constant::kTriangleFan },
            { "ZERO", V8WebGLRenderingContext::Constant::kZero },
            { "ONE", V8WebGLRenderingContext::Constant::kOne },
            { "SRC_COLOR", V8WebGLRenderingContext::Constant::kSrcColor },
            { "ONE_MINUS_SRC_COLOR", V8WebGLRenderingContext::Constant::kOneMinusSrcColor },
            { "SRC_ALPHA", V8WebGLRenderingContext::Constant::kSrcAlpha },
            { "ONE_MINUS_SRC_ALPHA", V8WebGLRenderingContext::Constant::kOneMinusSrcAlpha },
            { "DST_ALPHA", V8WebGLRenderingContext::Constant::kDstAlpha },
            { "ONE_MINUS_DST_ALPHA", V8WebGLRenderingContext::Constant::kOneMinusDstAlpha },
            { "DST_COLOR", V8WebGLRenderingContext::Constant::kDstColor },
            { "ONE_MINUS_DST_COLOR", V8WebGLRenderingContext::Constant::kOneMinusDstColor },
            { "SRC_ALPHA_SATURATE", V8WebGLRenderingContext::Constant::kSrcAlphaSaturate },
            { "FUNC_ADD", V8WebGLRenderingContext::Constant::kFuncAdd },
            { "BLEND_EQUATION", V8WebGLRenderingContext::Constant::kBlendEquation },
            { "BLEND_EQUATION_RGB", V8WebGLRenderingContext::Constant::kBlendEquationRgb },
            { "BLEND_EQUATION_ALPHA", V8WebGLRenderingContext::Constant::kBlendEquationAlpha },
            { "FUNC_SUBTRACT", V8WebGLRenderingContext::Constant::kFuncSubtract },
            { "FUNC_REVERSE_SUBTRACT", V8WebGLRenderingContext::Constant::kFuncReverseSubtract },
            { "BLEND_DST_RGB", V8WebGLRenderingContext::Constant::kBlendDstRgb },
            { "BLEND_SRC_RGB", V8WebGLRenderingContext::Constant::kBlendSrcRgb },
            { "BLEND_DST_ALPHA", V8WebGLRenderingContext::Constant::kBlendDstAlpha },
            { "BLEND_SRC_ALPHA", V8WebGLRenderingContext::Constant::kBlendSrcAlpha },
            { "CONSTANT_COLOR", V8WebGLRenderingContext::Constant::kConstantColor },
            { "ONE_MINUS_CONSTANT_COLOR", V8WebGLRenderingContext::Constant::kOneMinusConstantColor },
            { "CONSTANT_ALPHA", V8WebGLRenderingContext::Constant::kConstantAlpha },
            { "ONE_MINUS_CONSTANT_ALPHA", V8WebGLRenderingContext::Constant::kOneMinusConstantAlpha },
            { "BLEND_COLOR", V8WebGLRenderingContext::Constant::kBlendColor },
            { "ARRAY_BUFFER", V8WebGLRenderingContext::Constant::kArrayBuffer },
            { "ELEMENT_ARRAY_BUFFER", V8WebGLRenderingContext::Constant::kElementArrayBuffer },
            { "ARRAY_BUFFER_BINDING", V8WebGLRenderingContext::Constant::kArrayBufferBinding },
            { "ELEMENT_ARRAY_BUFFER_BINDING", V8WebGLRenderingContext::Constant::kElementArrayBufferBinding },
            { "STREAM_DRAW", V8WebGLRenderingContext::Constant::kStreamDraw },
            { "STATIC_DRAW", V8WebGLRenderingContext::Constant::kStaticDraw },
            { "DYNAMIC_DRAW", V8WebGLRenderingContext::Constant::kDynamicDraw },
            { "BUFFER_SIZE", V8WebGLRenderingContext::Constant::kBufferSize },
            { "BUFFER_USAGE", V8WebGLRenderingContext::Constant::kBufferUsage },
            { "CURRENT_VERTEX_ATTRIB", V8WebGLRenderingContext::Constant::kCurrentVertexAttrib },
            { "FRONT", V8WebGLRenderingContext::Constant::kFront },
            { "BACK", V8WebGLRenderingContext::Constant::kBack },
            { "FRONT_AND_BACK", V8WebGLRenderingContext::Constant::kFrontAndBack },
            { "TEXTURE_2D", V8WebGLRenderingContext::Constant::kTexture2d },
            { "CULL_FACE", V8WebGLRenderingContext::Constant::kCullFace },
            { "BLEND", V8WebGLRenderingContext::Constant::kBlend },
            { "DITHER", V8WebGLRenderingContext::Constant::kDither },
            { "STENCIL_TEST", V8WebGLRenderingContext::Constant::kStencilTest },
            { "DEPTH_TEST", V8WebGLRenderingContext::Constant::kDepthTest },
            { "SCISSOR_TEST", V8WebGLRenderingContext::Constant::kScissorTest },
            { "POLYGON_OFFSET_FILL", V8WebGLRenderingContext::Constant::kPolygonOffsetFill },
            { "SAMPLE_ALPHA_TO_COVERAGE", V8WebGLRenderingContext::Constant::kSampleAlphaToCoverage },
            { "SAMPLE_COVERAGE", V8WebGLRenderingContext::Constant::kSampleCoverage },
            { "NO_ERROR", V8WebGLRenderingContext::Constant::kNoError },
            { "INVALID_ENUM", V8WebGLRenderingContext::Constant::kInvalidEnum },
            { "INVALID_VALUE", V8WebGLRenderingContext::Constant::kInvalidValue },
            { "INVALID_OPERATION", V8WebGLRenderingContext::Constant::kInvalidOperation },
            { "OUT_OF_MEMORY", V8WebGLRenderingContext::Constant::kOutOfMemory },
            { "CW", V8WebGLRenderingContext::Constant::kCw },
            { "CCW", V8WebGLRenderingContext::Constant::kCcw },
            { "LINE_WIDTH", V8WebGLRenderingContext::Constant::kLineWidth },
            { "ALIASED_POINT_SIZE_RANGE", V8WebGLRenderingContext::Constant::kAliasedPointSizeRange },
            { "ALIASED_LINE_WIDTH_RANGE", V8WebGLRenderingContext::Constant::kAliasedLineWidthRange },
            { "CULL_FACE_MODE", V8WebGLRenderingContext::Constant::kCullFaceMode },
            { "FRONT_FACE", V8WebGLRenderingContext::Constant::kFrontFace },
            { "DEPTH_RANGE", V8WebGLRenderingContext::Constant::kDepthRange },
            { "DEPTH_WRITEMASK", V8WebGLRenderingContext::Constant::kDepthWritemask },
            { "DEPTH_CLEAR_VALUE", V8WebGLRenderingContext::Constant::kDepthClearValue },
            { "DEPTH_FUNC", V8WebGLRenderingContext::Constant::kDepthFunc },
            { "STENCIL_CLEAR_VALUE", V8WebGLRenderingContext::Constant::kStencilClearValue },
            { "STENCIL_FUNC", V8WebGLRenderingContext::Constant::kStencilFunc },
            { "STENCIL_FAIL", V8WebGLRenderingContext::Constant::kStencilFail },
            { "STENCIL_PASS_DEPTH_FAIL", V8WebGLRenderingContext::Constant::kStencilPassDepthFail },
            { "STENCIL_PASS_DEPTH_PASS", V8WebGLRenderingContext::Constant::kStencilPassDepthPass },
            { "STENCIL_REF", V8WebGLRenderingContext::Constant::kStencilRef },
            { "STENCIL_VALUE_MASK", V8WebGLRenderingContext::Constant::kStencilValueMask },
            { "STENCIL_WRITEMASK", V8WebGLRenderingContext::Constant::kStencilWritemask },
            { "STENCIL_BACK_FUNC", V8WebGLRenderingContext::Constant::kStencilBackFunc },
            { "STENCIL_BACK_FAIL", V8WebGLRenderingContext::Constant::kStencilBackFail },
            { "STENCIL_BACK_PASS_DEPTH_FAIL", V8WebGLRenderingContext::Constant::kStencilBackPassDepthFail },
            { "STENCIL_BACK_PASS_DEPTH_PASS", V8WebGLRenderingContext::Constant::kStencilBackPassDepthPass },
            { "STENCIL_BACK_REF", V8WebGLRenderingContext::Constant::kStencilBackRef },
            { "STENCIL_BACK_VALUE_MASK", V8WebGLRenderingContext::Constant::kStencilBackValueMask },
            { "STENCIL_BACK_WRITEMASK", V8WebGLRenderingContext::Constant::kStencilBackWritemask },
            { "VIEWPORT", V8WebGLRenderingContext::Constant::kViewport },
            { "SCISSOR_BOX", V8WebGLRenderingContext::Constant::kScissorBox },
            { "COLOR_CLEAR_VALUE", V8WebGLRenderingContext::Constant::kColorClearValue },
            { "COLOR_WRITEMASK", V8WebGLRenderingContext::Constant::kColorWritemask },
            { "UNPACK_ALIGNMENT", V8WebGLRenderingContext::Constant::kUnpackAlignment },
            { "PACK_ALIGNMENT", V8WebGLRenderingContext::Constant::kPackAlignment },
            { "MAX_TEXTURE_SIZE", V8WebGLRenderingContext::Constant::kMaxTextureSize },
            { "MAX_VIEWPORT_DIMS", V8WebGLRenderingContext::Constant::kMaxViewportDims },
            { "SUBPIXEL_BITS", V8WebGLRenderingContext::Constant::kSubpixelBits },
            { "RED_BITS", V8WebGLRenderingContext::Constant::kRedBits },
            { "GREEN_BITS", V8WebGLRenderingContext::Constant::kGreenBits },
            { "BLUE_BITS", V8WebGLRenderingContext::Constant::kBlueBits },
            { "ALPHA_BITS", V8WebGLRenderingContext::Constant::kAlphaBits },
            { "DEPTH_BITS", V8WebGLRenderingContext::Constant::kDepthBits },
            { "STENCIL_BITS", V8WebGLRenderingContext::Constant::kStencilBits },
            { "POLYGON_OFFSET_UNITS", V8WebGLRenderingContext::Constant::kPolygonOffsetUnits },
            { "POLYGON_OFFSET_FACTOR", V8WebGLRenderingContext::Constant::kPolygonOffsetFactor },
            { "TEXTURE_BINDING_2D", V8WebGLRenderingContext::Constant::kTextureBinding2d },
            { "SAMPLE_BUFFERS", V8WebGLRenderingContext::Constant::kSampleBuffers },
            { "SAMPLES", V8WebGLRenderingContext::Constant::kSamples },
            { "SAMPLE_COVERAGE_VALUE", V8WebGLRenderingContext::Constant::kSampleCoverageValue },
            { "SAMPLE_COVERAGE_INVERT", V8WebGLRenderingContext::Constant::kSampleCoverageInvert },
            { "COMPRESSED_TEXTURE_FORMATS", V8WebGLRenderingContext::Constant::kCompressedTextureFormats },
            { "DONT_CARE", V8WebGLRenderingContext::Constant::kDontCare },
            { "FASTEST", V8WebGLRenderingContext::Constant::kFastest },
            { "NICEST", V8WebGLRenderingContext::Constant::kNicest },
            { "GENERATE_MIPMAP_HINT", V8WebGLRenderingContext::Constant::kGenerateMipmapHint },
            { "BYTE", V8WebGLRenderingContext::Constant::kByte },
            { "UNSIGNED_BYTE", V8WebGLRenderingContext::Constant::kUnsignedByte },
            { "SHORT", V8WebGLRenderingContext::Constant::kShort },
            { "UNSIGNED_SHORT", V8WebGLRenderingContext::Constant::kUnsignedShort },
            { "INT", V8WebGLRenderingContext::Constant::kInt },
            { "UNSIGNED_INT", V8WebGLRenderingContext::Constant::kUnsignedInt },
            { "FLOAT", V8WebGLRenderingContext::Constant::kFloat },
            { "DEPTH_COMPONENT", V8WebGLRenderingContext::Constant::kDepthComponent },
            { "ALPHA", V8WebGLRenderingContext::Constant::kAlpha },
            { "RGB", V8WebGLRenderingContext::Constant::kRgb },
            { "RGBA", V8WebGLRenderingContext::Constant::kRgba },
            { "LUMINANCE", V8WebGLRenderingContext::Constant::kLuminance },
            { "LUMINANCE_ALPHA", V8WebGLRenderingContext::Constant::kLuminanceAlpha },
            { "UNSIGNED_SHORT_4_4_4_4", V8WebGLRenderingContext::Constant::kUnsignedShort4444 },
            { "UNSIGNED_SHORT_5_5_5_1", V8WebGLRenderingContext::Constant::kUnsignedShort5551 },
            { "UNSIGNED_SHORT_5_6_5", V8WebGLRenderingContext::Constant::kUnsignedShort565 },
            { "FRAGMENT_SHADER", V8WebGLRenderingContext::Constant::kFragmentShader },
            { "VERTEX_SHADER", V8WebGLRenderingContext::Constant::kVertexShader },
            { "MAX_VERTEX_ATTRIBS", V8WebGLRenderingContext::Constant::kMaxVertexAttribs },
            { "MAX_VERTEX_UNIFORM_VECTORS", V8WebGLRenderingContext::Constant::kMaxVertexUniformVectors },
            { "MAX_VARYING_VECTORS", V8WebGLRenderingContext::Constant::kMaxVaryingVectors },
            { "MAX_COMBINED_TEXTURE_IMAGE_UNITS", V8WebGLRenderingContext::Constant::kMaxCombinedTextureImageUnits },
            { "MAX_VERTEX_TEXTURE_IMAGE_UNITS", V8WebGLRenderingContext::Constant::kMaxVertexTextureImageUnits },
            { "MAX_TEXTURE_IMAGE_UNITS", V8WebGLRenderingContext::Constant::kMaxTextureImageUnits },
            { "MAX_FRAGMENT_UNIFORM_VECTORS", V8WebGLRenderingContext::Constant::kMaxFragmentUniformVectors },
            { "SHADER_TYPE", V8WebGLRenderingContext::Constant::kShaderType },
            { "DELETE_STATUS", V8WebGLRenderingContext::Constant::kDeleteStatus },
            { "LINK_STATUS", V8WebGLRenderingContext::Constant::kLinkStatus },
            { "VALIDATE_STATUS", V8WebGLRenderingContext::Constant::kValidateStatus },
            { "ATTACHED_SHADERS", V8WebGLRenderingContext::Constant::kAttachedShaders },
            { "ACTIVE_UNIFORMS", V8WebGLRenderingContext::Constant::kActiveUniforms },
            { "ACTIVE_ATTRIBUTES", V8WebGLRenderingContext::Constant::kActiveAttributes },
            { "SHADING_LANGUAGE_VERSION", V8WebGLRenderingContext::Constant::kShadingLanguageVersion },
            { "CURRENT_PROGRAM", V8WebGLRenderingContext::Constant::kCurrentProgram },
            { "NEVER", V8WebGLRenderingContext::Constant::kNever },
            { "LESS", V8WebGLRenderingContext::Constant::kLess },
            { "EQUAL", V8WebGLRenderingContext::Constant::kEqual },
            { "LEQUAL", V8WebGLRenderingContext::Constant::kLequal },
            { "GREATER", V8WebGLRenderingContext::Constant::kGreater },
            { "NOTEQUAL", V8WebGLRenderingContext::Constant::kNotequal },
            { "GEQUAL", V8WebGLRenderingContext::Constant::kGequal },
            { "ALWAYS", V8WebGLRenderingContext::Constant::kAlways },
            { "KEEP", V8WebGLRenderingContext::Constant::kKeep },
            { "REPLACE", V8WebGLRenderingContext::Constant::kReplace },
            { "INCR", V8WebGLRenderingContext::Constant::kIncr },
            { "DECR", V8WebGLRenderingContext::Constant::kDecr },
            { "INVERT", V8WebGLRenderingContext::Constant::kInvert },
            { "INCR_WRAP", V8WebGLRenderingContext::Constant::kIncrWrap },
            { "DECR_WRAP", V8WebGLRenderingContext::Constant::kDecrWrap },
            { "VENDOR", V8WebGLRenderingContext::Constant::kVendor },
            { "RENDERER", V8WebGLRenderingContext::Constant::kRenderer },
            { "VERSION", V8WebGLRenderingContext::Constant::kVersion },
            { "NEAREST", V8WebGLRenderingContext::Constant::kNearest },
            { "LINEAR", V8WebGLRenderingContext::Constant::kLinear },
            { "NEAREST_MIPMAP_NEAREST", V8WebGLRenderingContext::Constant::kNearestMipmapNearest },
            { "LINEAR_MIPMAP_NEAREST", V8WebGLRenderingContext::Constant::kLinearMipmapNearest },
            { "NEAREST_MIPMAP_LINEAR", V8WebGLRenderingContext::Constant::kNearestMipmapLinear },
            { "LINEAR_MIPMAP_LINEAR", V8WebGLRenderingContext::Constant::kLinearMipmapLinear },
            { "TEXTURE_MAG_FILTER", V8WebGLRenderingContext::Constant::kTextureMagFilter },
            { "TEXTURE_MIN_FILTER", V8WebGLRenderingContext::Constant::kTextureMinFilter },
            { "TEXTURE_WRAP_S", V8WebGLRenderingContext::Constant::kTextureWrapS },
            { "TEXTURE_WRAP_T", V8WebGLRenderingContext::Constant::kTextureWrapT },
            { "TEXTURE", V8WebGLRenderingContext::Constant::kTexture },
            { "TEXTURE_CUBE_MAP", V8WebGLRenderingContext::Constant::kTextureCubeMap },
            { "TEXTURE_BINDING_CUBE_MAP", V8WebGLRenderingContext::Constant::kTextureBindingCubeMap },
            { "TEXTURE_CUBE_MAP_POSITIVE_X", V8WebGLRenderingContext::Constant::kTextureCubeMapPositiveX },
            { "TEXTURE_CUBE_MAP_NEGATIVE_X", V8WebGLRenderingContext::Constant::kTextureCubeMapNegativeX },
            { "TEXTURE_CUBE_MAP_POSITIVE_Y", V8WebGLRenderingContext::Constant::kTextureCubeMapPositiveY },
            { "TEXTURE_CUBE_MAP_NEGATIVE_Y", V8WebGLRenderingContext::Constant::kTextureCubeMapNegativeY },
            { "TEXTURE_CUBE_MAP_POSITIVE_Z", V8WebGLRenderingContext::Constant::kTextureCubeMapPositiveZ },
            { "TEXTURE_CUBE_MAP_NEGATIVE_Z", V8WebGLRenderingContext::Constant::kTextureCubeMapNegativeZ },
            { "MAX_CUBE_MAP_TEXTURE_SIZE", V8WebGLRenderingContext::Constant::kMaxCubeMapTextureSize },
            { "TEXTURE0", V8WebGLRenderingContext::Constant::kTexture0 },
            { "TEXTURE1", V8WebGLRenderingContext::Constant::kTexture1 },
            { "TEXTURE2", V8WebGLRenderingContext::Constant::kTexture2 },
            { "TEXTURE3", V8WebGLRenderingContext::Constant::kTexture3 },
            { "TEXTURE4", V8WebGLRenderingContext::Constant::kTexture4 },
            { "TEXTURE5", V8WebGLRenderingContext::Constant::kTexture5 },
            { "TEXTURE6", V8WebGLRenderingContext::Constant::kTexture6 },
            { "TEXTURE7", V8WebGLRenderingContext::Constant::kTexture7 },
            { "TEXTURE8", V8WebGLRenderingContext::Constant::kTexture8 },
            { "TEXTURE9", V8WebGLRenderingContext::Constant::kTexture9 },
            { "TEXTURE10", V8WebGLRenderingContext::Constant::kTexture10 },
            { "TEXTURE11", V8WebGLRenderingContext::Constant::kTexture11 },
            { "TEXTURE12", V8WebGLRenderingContext::Constant::kTexture12 },
            { "TEXTURE13", V8WebGLRenderingContext::Constant::kTexture13 },
            { "TEXTURE14", V8WebGLRenderingContext::Constant::kTexture14 },
            { "TEXTURE15", V8WebGLRenderingContext::Constant::kTexture15 },
            { "TEXTURE16", V8WebGLRenderingContext::Constant::kTexture16 },
            { "TEXTURE17", V8WebGLRenderingContext::Constant::kTexture17 },
            { "TEXTURE18", V8WebGLRenderingContext::Constant::kTexture18 },
            { "TEXTURE19", V8WebGLRenderingContext::Constant::kTexture19 },
            { "TEXTURE20", V8WebGLRenderingContext::Constant::kTexture20 },
            { "TEXTURE21", V8WebGLRenderingContext::Constant::kTexture21 },
            { "TEXTURE22", V8WebGLRenderingContext::Constant::kTexture22 },
            { "TEXTURE23", V8WebGLRenderingContext::Constant::kTexture23 },
            { "TEXTURE24", V8WebGLRenderingContext::Constant::kTexture24 },
            { "TEXTURE25", V8WebGLRenderingContext::Constant::kTexture25 },
            { "TEXTURE26", V8WebGLRenderingContext::Constant::kTexture26 },
            { "TEXTURE27", V8WebGLRenderingContext::Constant::kTexture27 },
            { "TEXTURE28", V8WebGLRenderingContext::Constant::kTexture28 },
            { "TEXTURE29", V8WebGLRenderingContext::Constant::kTexture29 },
            { "TEXTURE30", V8WebGLRenderingContext::Constant::kTexture30 },
            { "TEXTURE31", V8WebGLRenderingContext::Constant::kTexture31 },
            { "ACTIVE_TEXTURE", V8WebGLRenderingContext::Constant::kActiveTexture },
            { "REPEAT", V8WebGLRenderingContext::Constant::kRepeat },
            { "CLAMP_TO_EDGE", V8WebGLRenderingContext::Constant::kClampToEdge },
            { "MIRRORED_REPEAT", V8WebGLRenderingContext::Constant::kMirroredRepeat },
            { "FLOAT_VEC2", V8WebGLRenderingContext::Constant::kFloatVec2 },
            { "FLOAT_VEC3", V8WebGLRenderingContext::Constant::kFloatVec3 },
            { "FLOAT_VEC4", V8WebGLRenderingContext::Constant::kFloatVec4 },
            { "INT_VEC2", V8WebGLRenderingContext::Constant::kIntVec2 },
            { "INT_VEC3", V8WebGLRenderingContext::Constant::kIntVec3 },
            { "INT_VEC4", V8WebGLRenderingContext::Constant::kIntVec4 },
            { "BOOL", V8WebGLRenderingContext::Constant::kBool },
            { "BOOL_VEC2", V8WebGLRenderingContext::Constant::kBoolVec2 },
            { "BOOL_VEC3", V8WebGLRenderingContext::Constant::kBoolVec3 },
            { "BOOL_VEC4", V8WebGLRenderingContext::Constant::kBoolVec4 },
            { "FLOAT_MAT2", V8WebGLRenderingContext::Constant::kFloatMat2 },
            { "FLOAT_MAT3", V8WebGLRenderingContext::Constant::kFloatMat3 },
            { "FLOAT_MAT4", V8WebGLRenderingContext::Constant::kFloatMat4 },
            { "SAMPLER_2D", V8WebGLRenderingContext::Constant::kSampler2d },
            { "SAMPLER_CUBE", V8WebGLRenderingContext::Constant::kSamplerCube },
            { "VERTEX_ATTRIB_ARRAY_ENABLED", V8WebGLRenderingContext::Constant::kVertexAttribArrayEnabled },
            { "VERTEX_ATTRIB_ARRAY_SIZE", V8WebGLRenderingContext::Constant::kVertexAttribArraySize },
            { "VERTEX_ATTRIB_ARRAY_STRIDE", V8WebGLRenderingContext::Constant::kVertexAttribArrayStride },
            { "VERTEX_ATTRIB_ARRAY_TYPE", V8WebGLRenderingContext::Constant::kVertexAttribArrayType },
            { "VERTEX_ATTRIB_ARRAY_NORMALIZED", V8WebGLRenderingContext::Constant::kVertexAttribArrayNormalized },
            { "VERTEX_ATTRIB_ARRAY_POINTER", V8WebGLRenderingContext::Constant::kVertexAttribArrayPointer },
            { "VERTEX_ATTRIB_ARRAY_BUFFER_BINDING", V8WebGLRenderingContext::Constant::kVertexAttribArrayBufferBinding },
            { "IMPLEMENTATION_COLOR_READ_TYPE", V8WebGLRenderingContext::Constant::kImplementationColorReadType },
            { "IMPLEMENTATION_COLOR_READ_FORMAT", V8WebGLRenderingContext::Constant::kImplementationColorReadFormat },
            { "COMPILE_STATUS", V8WebGLRenderingContext::Constant::kCompileStatus },
            { "LOW_FLOAT", V8WebGLRenderingContext::Constant::kLowFloat },
            { "MEDIUM_FLOAT", V8WebGLRenderingContext::Constant::kMediumFloat },
            { "HIGH_FLOAT", V8WebGLRenderingContext::Constant::kHighFloat },
            { "LOW_INT", V8WebGLRenderingContext::Constant::kLowInt },
            { "MEDIUM_INT", V8WebGLRenderingContext::Constant::kMediumInt },
            { "HIGH_INT", V8WebGLRenderingContext::Constant::kHighInt },
            { "FRAMEBUFFER", V8WebGLRenderingContext::Constant::kFramebuffer },
            { "RENDERBUFFER", V8WebGLRenderingContext::Constant::kRenderbuffer },
            { "RGBA4", V8WebGLRenderingContext::Constant::kRgba4 },
            { "RGB5_A1", V8WebGLRenderingContext::Constant::kRgb5A1 },
            { "RGB565", V8WebGLRenderingContext::Constant::kRgb565 },
            { "DEPTH_COMPONENT16", V8WebGLRenderingContext::Constant::kDepthComponent16 },
            { "STENCIL_INDEX8", V8WebGLRenderingContext::Constant::kStencilIndex8 },
            { "DEPTH_STENCIL", V8WebGLRenderingContext::Constant::kDepthStencil },
            { "RENDERBUFFER_WIDTH", V8WebGLRenderingContext::Constant::kRenderbufferWidth },
            { "RENDERBUFFER_HEIGHT", V8WebGLRenderingContext::Constant::kRenderbufferHeight },
            { "RENDERBUFFER_INTERNAL_FORMAT", V8WebGLRenderingContext::Constant::kRenderbufferInternalFormat },
            { "RENDERBUFFER_RED_SIZE", V8WebGLRenderingContext::Constant::kRenderbufferRedSize },
            { "RENDERBUFFER_GREEN_SIZE", V8WebGLRenderingContext::Constant::kRenderbufferGreenSize },
            { "RENDERBUFFER_BLUE_SIZE", V8WebGLRenderingContext::Constant::kRenderbufferBlueSize },
            { "RENDERBUFFER_ALPHA_SIZE", V8WebGLRenderingContext::Constant::kRenderbufferAlphaSize },
            { "RENDERBUFFER_DEPTH_SIZE", V8WebGLRenderingContext::Constant::kRenderbufferDepthSize },
            { "RENDERBUFFER_STENCIL_SIZE", V8WebGLRenderingContext::Constant::kRenderbufferStencilSize },
            { "FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE", V8WebGLRenderingContext::Constant::kFramebufferAttachmentObjectType },
            { "FRAMEBUFFER_ATTACHMENT_OBJECT_NAME", V8WebGLRenderingContext::Constant::kFramebufferAttachmentObjectName },
            { "FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL", V8WebGLRenderingContext::Constant::kFramebufferAttachmentTextureLevel },
            { "FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE", V8WebGLRenderingContext::Constant::kFramebufferAttachmentTextureCubeMapFace },
            { "COLOR_ATTACHMENT0", V8WebGLRenderingContext::Constant::kColorAttachment0 },
            { "DEPTH_ATTACHMENT", V8WebGLRenderingContext::Constant::kDepthAttachment },
            { "STENCIL_ATTACHMENT", V8WebGLRenderingContext::Constant::kStencilAttachment },
            { "DEPTH_STENCIL_ATTACHMENT", V8WebGLRenderingContext::Constant::kDepthStencilAttachment },
            { "NONE", V8WebGLRenderingContext::Constant::kNone },
            { "FRAMEBUFFER_COMPLETE", V8WebGLRenderingContext::Constant::kFramebufferComplete },
            { "FRAMEBUFFER_INCOMPLETE_ATTACHMENT", V8WebGLRenderingContext::Constant::kFramebufferIncompleteAttachment },
            { "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT", V8WebGLRenderingContext::Constant::kFramebufferIncompleteMissingAttachment },
            { "FRAMEBUFFER_INCOMPLETE_DIMENSIONS", V8WebGLRenderingContext::Constant::kFramebufferIncompleteDimensions },
            { "FRAMEBUFFER_UNSUPPORTED", V8WebGLRenderingContext::Constant::kFramebufferUnsupported },
            { "FRAMEBUFFER_BINDING", V8WebGLRenderingContext::Constant::kFramebufferBinding },
            { "RENDERBUFFER_BINDING", V8WebGLRenderingContext::Constant::kRenderbufferBinding },
            { "MAX_RENDERBUFFER_SIZE", V8WebGLRenderingContext::Constant::kMaxRenderbufferSize },
            { "INVALID_FRAMEBUFFER_OPERATION", V8WebGLRenderingContext::Constant::kInvalidFramebufferOperation },
            { "UNPACK_FLIP_Y_WEBGL", V8WebGLRenderingContext::Constant::kUnpackFlipYWebgl },
            { "UNPACK_PREMULTIPLY_ALPHA_WEBGL", V8WebGLRenderingContext::Constant::kUnpackPremultiplyAlphaWebgl },
            { "CONTEXT_LOST_WEBGL", V8WebGLRenderingContext::Constant::kContextLostWebgl },
            { "UNPACK_COLORSPACE_CONVERSION_WEBGL", V8WebGLRenderingContext::Constant::kUnpackColorspaceConversionWebgl },
            { "BROWSER_DEFAULT_WEBGL", V8WebGLRenderingContext::Constant::kBrowserDefaultWebgl },
        };
        IDLMemberInstaller::InstallConstants(isolate, world, instance_template, prototype_template, interface_template, signature, kConstantValueTable);
    }

    {
        static const IDLMemberInstaller::OperationConfig kOperationTable[] = {
            { "activeTexture", "WebGLRenderingContext", ActiveTextureOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "attachShader", "WebGLRenderingContext", AttachShaderOperationCallback, 2, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "bindAttribLocation", "WebGLRenderingContext", BindAttribLocationOperationCallback, 3, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "bindRenderbuffer", "WebGLRenderingContext", BindRenderbufferOperationCallback, 2, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "blendColor", "WebGLRenderingContext", BlendColorOperationCallback, 4, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "blendEquation", "WebGLRenderingContext", BlendEquationOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "blendEquationSeparate", "WebGLRenderingContext", BlendEquationSeparateOperationCallback, 2, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "blendFunc", "WebGLRenderingContext", BlendFuncOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "blendFuncSeparate", "WebGLRenderingContext", BlendFuncSeparateOperationCallback, 4, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "bufferData", "WebGLRenderingContext", BufferDataOperationCallback, 3, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "bufferSubData", "WebGLRenderingContext", BufferSubDataOperationCallback, 3, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "checkFramebufferStatus", "WebGLRenderingContext", CheckFramebufferStatusOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "compileShader", "WebGLRenderingContext", CompileShaderOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "compressedTexImage2D", "WebGLRenderingContext", CompressedTexImage2DOperationCallback, 7, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "compressedTexSubImage2D", "WebGLRenderingContext", CompressedTexSubImage2DOperationCallback, 8, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "copyTexImage2D", "WebGLRenderingContext", CopyTexImage2DOperationCallback, 8, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "copyTexSubImage2D", "WebGLRenderingContext", CopyTexSubImage2DOperationCallback, 8, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "createBuffer", "WebGLRenderingContext", CreateBufferOperationCallback, 0, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "createFramebuffer", "WebGLRenderingContext", CreateFramebufferOperationCallback, 0, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "createProgram", "WebGLRenderingContext", CreateProgramOperationCallback, 0, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "createRenderbuffer", "WebGLRenderingContext", CreateRenderbufferOperationCallback, 0, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "createShader", "WebGLRenderingContext", CreateShaderOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "createTexture", "WebGLRenderingContext", CreateTextureOperationCallback, 0, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "cullFace", "WebGLRenderingContext", CullFaceOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "deleteBuffer", "WebGLRenderingContext", DeleteBufferOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "deleteFramebuffer", "WebGLRenderingContext", DeleteFramebufferOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "deleteProgram", "WebGLRenderingContext", DeleteProgramOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "deleteRenderbuffer", "WebGLRenderingContext", DeleteRenderbufferOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "deleteShader", "WebGLRenderingContext", DeleteShaderOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "deleteTexture", "WebGLRenderingContext", DeleteTextureOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "depthFunc", "WebGLRenderingContext", DepthFuncOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "depthMask", "WebGLRenderingContext", DepthMaskOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "depthRange", "WebGLRenderingContext", DepthRangeOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "detachShader", "WebGLRenderingContext", DetachShaderOperationCallback, 2, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "disable", "WebGLRenderingContext", DisableOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "enable", "WebGLRenderingContext", EnableOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "finish", "WebGLRenderingContext", FinishOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "flush", "WebGLRenderingContext", FlushOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "framebufferRenderbuffer", "WebGLRenderingContext", FramebufferRenderbufferOperationCallback, 4, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "framebufferTexture2D", "WebGLRenderingContext", FramebufferTexture2DOperationCallback, 5, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "frontFace", "WebGLRenderingContext", FrontFaceOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "generateMipmap", "WebGLRenderingContext", GenerateMipmapOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "getActiveAttrib", "WebGLRenderingContext", GetActiveAttribOperationCallback, 2, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "getActiveUniform", "WebGLRenderingContext", GetActiveUniformOperationCallback, 2, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "getAttachedShaders", "WebGLRenderingContext", GetAttachedShadersOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "getAttribLocation", "WebGLRenderingContext", GetAttribLocationOperationCallback, 2, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "getBufferParameter", "WebGLRenderingContext", GetBufferParameterOperationCallback, 2, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "getContextAttributes", "WebGLRenderingContext", GetContextAttributesOperationCallback, 0, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "getError", "WebGLRenderingContext", GetErrorOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "getExtension", "WebGLRenderingContext", GetExtensionOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "getFramebufferAttachmentParameter", "WebGLRenderingContext", GetFramebufferAttachmentParameterOperationCallback, 3, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "getParameter", "WebGLRenderingContext", GetParameterOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "getProgramInfoLog", "WebGLRenderingContext", GetProgramInfoLogOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "getProgramParameter", "WebGLRenderingContext", GetProgramParameterOperationCallback, 2, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "getRenderbufferParameter", "WebGLRenderingContext", GetRenderbufferParameterOperationCallback, 2, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "getShaderInfoLog", "WebGLRenderingContext", GetShaderInfoLogOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "getShaderParameter", "WebGLRenderingContext", GetShaderParameterOperationCallback, 2, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "getShaderPrecisionFormat", "WebGLRenderingContext", GetShaderPrecisionFormatOperationCallback, 2, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "getShaderSource", "WebGLRenderingContext", GetShaderSourceOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "getSupportedExtensions", "WebGLRenderingContext", GetSupportedExtensionsOperationCallback, 0, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "getTexParameter", "WebGLRenderingContext", GetTexParameterOperationCallback, 2, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "getUniform", "WebGLRenderingContext", GetUniformOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "getUniformLocation", "WebGLRenderingContext", GetUniformLocationOperationCallback, 2, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "getVertexAttrib", "WebGLRenderingContext", GetVertexAttribOperationCallback, 2, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "getVertexAttribOffset", "WebGLRenderingContext", GetVertexAttribOffsetOperationCallback, 2, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "hint", "WebGLRenderingContext", HintOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "isBuffer", "WebGLRenderingContext", IsBufferOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "isContextLost", "WebGLRenderingContext", IsContextLostOperationCallback, 0, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "isEnabled", "WebGLRenderingContext", IsEnabledOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "isFramebuffer", "WebGLRenderingContext", IsFramebufferOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "isProgram", "WebGLRenderingContext", IsProgramOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "isRenderbuffer", "WebGLRenderingContext", IsRenderbufferOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "isShader", "WebGLRenderingContext", IsShaderOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "isTexture", "WebGLRenderingContext", IsTextureOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "lineWidth", "WebGLRenderingContext", LineWidthOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "linkProgram", "WebGLRenderingContext", LinkProgramOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "pixelStorei", "WebGLRenderingContext", PixelStoreiOperationCallback, 2, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "polygonOffset", "WebGLRenderingContext", PolygonOffsetOperationCallback, 2, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "readPixels", "WebGLRenderingContext", ReadPixelsOperationCallback, 7, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "renderbufferStorage", "WebGLRenderingContext", RenderbufferStorageOperationCallback, 4, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "sampleCoverage", "WebGLRenderingContext", SampleCoverageOperationCallback, 2, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "shaderSource", "WebGLRenderingContext", ShaderSourceOperationCallback, 2, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "stencilFunc", "WebGLRenderingContext", StencilFuncOperationCallback, 3, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "stencilFuncSeparate", "WebGLRenderingContext", StencilFuncSeparateOperationCallback, 4, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "stencilMask", "WebGLRenderingContext", StencilMaskOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "stencilMaskSeparate", "WebGLRenderingContext", StencilMaskSeparateOperationCallback, 2, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "stencilOp", "WebGLRenderingContext", StencilOpOperationCallback, 3, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "stencilOpSeparate", "WebGLRenderingContext", StencilOpSeparateOperationCallback, 4, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "texImage2D", "WebGLRenderingContext", TexImage2DOperationCallback, 6, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "texParameterf", "WebGLRenderingContext", TexParameterfOperationCallback, 3, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "texParameteri", "WebGLRenderingContext", TexParameteriOperationCallback, 3, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "texSubImage2D", "WebGLRenderingContext", TexSubImage2DOperationCallback, 7, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "useProgram", "WebGLRenderingContext", UseProgramOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "validateProgram", "WebGLRenderingContext", ValidateProgramOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
        };
        IDLMemberInstaller::InstallOperations(isolate, world, instance_template, prototype_template, interface_template, signature, kOperationTable);
    }

    {
        static const v8::CFunction kNoAllocDirectCallOverloadsOfBindBuffer[] = {
            v8::CFunctionBuilder().Fn(BindBufferOperationNoAllocDirectCallArg2).Build(),
        };
        static const v8::CFunction kNoAllocDirectCallOverloadsOfBindFramebuffer[] = {
            v8::CFunctionBuilder().Fn(BindFramebufferOperationNoAllocDirectCallArg2).Build(),
        };
        static const v8::CFunction kNoAllocDirectCallOverloadsOfBindTexture[] = {
            v8::CFunctionBuilder().Fn(BindTextureOperationNoAllocDirectCallArg2).Build(),
        };
        static const v8::CFunction kNoAllocDirectCallOverloadsOfClear[] = {
            v8::CFunctionBuilder().Fn(ClearOperationNoAllocDirectCallArg1).Build(),
        };
        static const v8::CFunction kNoAllocDirectCallOverloadsOfClearColor[] = {
            v8::CFunctionBuilder().Fn(ClearColorOperationNoAllocDirectCallArg4).Build(),
        };
        static const v8::CFunction kNoAllocDirectCallOverloadsOfClearDepth[] = {
            v8::CFunctionBuilder().Fn(ClearDepthOperationNoAllocDirectCallArg1).Build(),
        };
        static const v8::CFunction kNoAllocDirectCallOverloadsOfClearStencil[] = {
            v8::CFunctionBuilder().Fn(ClearStencilOperationNoAllocDirectCallArg1).Build(),
        };
        static const v8::CFunction kNoAllocDirectCallOverloadsOfColorMask[] = {
            v8::CFunctionBuilder().Fn(ColorMaskOperationNoAllocDirectCallArg4).Build(),
        };
        static const v8::CFunction kNoAllocDirectCallOverloadsOfDisableVertexAttribArray[] = {
            v8::CFunctionBuilder().Fn(DisableVertexAttribArrayOperationNoAllocDirectCallArg1).Build(),
        };
        static const v8::CFunction kNoAllocDirectCallOverloadsOfDrawArrays[] = {
            v8::CFunctionBuilder().Fn(DrawArraysOperationNoAllocDirectCallArg3).Build(),
        };
        static const v8::CFunction kNoAllocDirectCallOverloadsOfDrawElements[] = {
            v8::CFunctionBuilder().Fn(DrawElementsOperationNoAllocDirectCallArg4).Build(),
        };
        static const v8::CFunction kNoAllocDirectCallOverloadsOfEnableVertexAttribArray[] = {
            v8::CFunctionBuilder().Fn(EnableVertexAttribArrayOperationNoAllocDirectCallArg1).Build(),
        };
        static const v8::CFunction kNoAllocDirectCallOverloadsOfScissor[] = {
            v8::CFunctionBuilder().Fn(ScissorOperationNoAllocDirectCallArg4).Build(),
        };
        static const v8::CFunction kNoAllocDirectCallOverloadsOfUniform1F[] = {
            v8::CFunctionBuilder().Fn(Uniform1FOperationNoAllocDirectCallArg2).Build(),
        };
        static const v8::CFunction kNoAllocDirectCallOverloadsOfUniform1Fv[] = {
            v8::CFunctionBuilder().Fn(Uniform1FvOperationNoAllocDirectCallArg2).Build(),
        };
        static const v8::CFunction kNoAllocDirectCallOverloadsOfUniform1I[] = {
            v8::CFunctionBuilder().Fn(Uniform1IOperationNoAllocDirectCallArg2).Build(),
        };
        static const v8::CFunction kNoAllocDirectCallOverloadsOfUniform1Iv[] = {
            v8::CFunctionBuilder().Fn(Uniform1IvOperationNoAllocDirectCallArg2).Build(),
        };
        static const v8::CFunction kNoAllocDirectCallOverloadsOfUniform2F[] = {
            v8::CFunctionBuilder().Fn(Uniform2FOperationNoAllocDirectCallArg3).Build(),
        };
        static const v8::CFunction kNoAllocDirectCallOverloadsOfUniform2Fv[] = {
            v8::CFunctionBuilder().Fn(Uniform2FvOperationNoAllocDirectCallArg2).Build(),
        };
        static const v8::CFunction kNoAllocDirectCallOverloadsOfUniform2I[] = {
            v8::CFunctionBuilder().Fn(Uniform2IOperationNoAllocDirectCallArg3).Build(),
        };
        static const v8::CFunction kNoAllocDirectCallOverloadsOfUniform2Iv[] = {
            v8::CFunctionBuilder().Fn(Uniform2IvOperationNoAllocDirectCallArg2).Build(),
        };
        static const v8::CFunction kNoAllocDirectCallOverloadsOfUniform3F[] = {
            v8::CFunctionBuilder().Fn(Uniform3FOperationNoAllocDirectCallArg4).Build(),
        };
        static const v8::CFunction kNoAllocDirectCallOverloadsOfUniform3Fv[] = {
            v8::CFunctionBuilder().Fn(Uniform3FvOperationNoAllocDirectCallArg2).Build(),
        };
        static const v8::CFunction kNoAllocDirectCallOverloadsOfUniform3I[] = {
            v8::CFunctionBuilder().Fn(Uniform3IOperationNoAllocDirectCallArg4).Build(),
        };
        static const v8::CFunction kNoAllocDirectCallOverloadsOfUniform3Iv[] = {
            v8::CFunctionBuilder().Fn(Uniform3IvOperationNoAllocDirectCallArg2).Build(),
        };
        static const v8::CFunction kNoAllocDirectCallOverloadsOfUniform4F[] = {
            v8::CFunctionBuilder().Fn(Uniform4FOperationNoAllocDirectCallArg5).Build(),
        };
        static const v8::CFunction kNoAllocDirectCallOverloadsOfUniform4Fv[] = {
            v8::CFunctionBuilder().Fn(Uniform4FvOperationNoAllocDirectCallArg2).Build(),
        };
        static const v8::CFunction kNoAllocDirectCallOverloadsOfUniform4I[] = {
            v8::CFunctionBuilder().Fn(Uniform4IOperationNoAllocDirectCallArg5).Build(),
        };
        static const v8::CFunction kNoAllocDirectCallOverloadsOfUniform4Iv[] = {
            v8::CFunctionBuilder().Fn(Uniform4IvOperationNoAllocDirectCallArg2).Build(),
        };
        static const v8::CFunction kNoAllocDirectCallOverloadsOfUniformMatrix2Fv[] = {
            v8::CFunctionBuilder().Fn(UniformMatrix2FvOperationNoAllocDirectCallArg3).Build(),
        };
        static const v8::CFunction kNoAllocDirectCallOverloadsOfUniformMatrix3Fv[] = {
            v8::CFunctionBuilder().Fn(UniformMatrix3FvOperationNoAllocDirectCallArg3).Build(),
        };
        static const v8::CFunction kNoAllocDirectCallOverloadsOfUniformMatrix4Fv[] = {
            v8::CFunctionBuilder().Fn(UniformMatrix4FvOperationNoAllocDirectCallArg3).Build(),
        };
        static const v8::CFunction kNoAllocDirectCallOverloadsOfVertexAttrib1F[] = {
            v8::CFunctionBuilder().Fn(VertexAttrib1FOperationNoAllocDirectCallArg2).Build(),
        };
        static const v8::CFunction kNoAllocDirectCallOverloadsOfVertexAttrib1Fv[] = {
            v8::CFunctionBuilder().Fn(VertexAttrib1FvOperationNoAllocDirectCallArg2).Build(),
        };
        static const v8::CFunction kNoAllocDirectCallOverloadsOfVertexAttrib2F[] = {
            v8::CFunctionBuilder().Fn(VertexAttrib2FOperationNoAllocDirectCallArg3).Build(),
        };
        static const v8::CFunction kNoAllocDirectCallOverloadsOfVertexAttrib2Fv[] = {
            v8::CFunctionBuilder().Fn(VertexAttrib2FvOperationNoAllocDirectCallArg2).Build(),
        };
        static const v8::CFunction kNoAllocDirectCallOverloadsOfVertexAttrib3F[] = {
            v8::CFunctionBuilder().Fn(VertexAttrib3FOperationNoAllocDirectCallArg4).Build(),
        };
        static const v8::CFunction kNoAllocDirectCallOverloadsOfVertexAttrib3Fv[] = {
            v8::CFunctionBuilder().Fn(VertexAttrib3FvOperationNoAllocDirectCallArg2).Build(),
        };
        static const v8::CFunction kNoAllocDirectCallOverloadsOfVertexAttrib4F[] = {
            v8::CFunctionBuilder().Fn(VertexAttrib4FOperationNoAllocDirectCallArg5).Build(),
        };
        static const v8::CFunction kNoAllocDirectCallOverloadsOfVertexAttrib4Fv[] = {
            v8::CFunctionBuilder().Fn(VertexAttrib4FvOperationNoAllocDirectCallArg2).Build(),
        };
        static const v8::CFunction kNoAllocDirectCallOverloadsOfVertexAttribPointer[] = {
            v8::CFunctionBuilder().Fn(VertexAttribPointerOperationNoAllocDirectCallArg6).Build(),
        };
        static const v8::CFunction kNoAllocDirectCallOverloadsOfViewport[] = {
            v8::CFunctionBuilder().Fn(ViewportOperationNoAllocDirectCallArg4).Build(),
        };

        static const IDLMemberInstaller::NoAllocDirectCallOperationConfig kOperationTable[] = {
            { { "bindBuffer", "WebGLRenderingContext", BindBufferOperationCallback, 2, unsigned(v8::None),
                  unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                  unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                  unsigned(v8::SideEffectType::kHasSideEffect) },
                kNoAllocDirectCallOverloadsOfBindBuffer, std::size(kNoAllocDirectCallOverloadsOfBindBuffer) },
            { { "bindFramebuffer", "WebGLRenderingContext", BindFramebufferOperationCallback, 2, unsigned(v8::None),
                  unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                  unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                  unsigned(v8::SideEffectType::kHasSideEffect) },
                kNoAllocDirectCallOverloadsOfBindFramebuffer, std::size(kNoAllocDirectCallOverloadsOfBindFramebuffer) },
            { { "bindTexture", "WebGLRenderingContext", BindTextureOperationCallback, 2, unsigned(v8::None),
                  unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                  unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                  unsigned(v8::SideEffectType::kHasSideEffect) },
                kNoAllocDirectCallOverloadsOfBindTexture, std::size(kNoAllocDirectCallOverloadsOfBindTexture) },
            { { "clear", "WebGLRenderingContext", ClearOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                  unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                  unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
                kNoAllocDirectCallOverloadsOfClear, std::size(kNoAllocDirectCallOverloadsOfClear) },
            { { "clearColor", "WebGLRenderingContext", ClearColorOperationCallback, 4, unsigned(v8::None),
                  unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                  unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                  unsigned(v8::SideEffectType::kHasSideEffect) },
                kNoAllocDirectCallOverloadsOfClearColor, std::size(kNoAllocDirectCallOverloadsOfClearColor) },
            { { "clearDepth", "WebGLRenderingContext", ClearDepthOperationCallback, 1, unsigned(v8::None),
                  unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                  unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                  unsigned(v8::SideEffectType::kHasSideEffect) },
                kNoAllocDirectCallOverloadsOfClearDepth, std::size(kNoAllocDirectCallOverloadsOfClearDepth) },
            { { "clearStencil", "WebGLRenderingContext", ClearStencilOperationCallback, 1, unsigned(v8::None),
                  unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                  unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                  unsigned(v8::SideEffectType::kHasSideEffect) },
                kNoAllocDirectCallOverloadsOfClearStencil, std::size(kNoAllocDirectCallOverloadsOfClearStencil) },
            { { "colorMask", "WebGLRenderingContext", ColorMaskOperationCallback, 4, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                  unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                  unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
                kNoAllocDirectCallOverloadsOfColorMask, std::size(kNoAllocDirectCallOverloadsOfColorMask) },
            { { "disableVertexAttribArray", "WebGLRenderingContext", DisableVertexAttribArrayOperationCallback, 1, unsigned(v8::None),
                  unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                  unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                  unsigned(v8::SideEffectType::kHasSideEffect) },
                kNoAllocDirectCallOverloadsOfDisableVertexAttribArray, std::size(kNoAllocDirectCallOverloadsOfDisableVertexAttribArray) },
            { { "drawArrays", "WebGLRenderingContext", DrawArraysOperationCallback, 3, unsigned(v8::None),
                  unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                  unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                  unsigned(v8::SideEffectType::kHasSideEffect) },
                kNoAllocDirectCallOverloadsOfDrawArrays, std::size(kNoAllocDirectCallOverloadsOfDrawArrays) },
            { { "drawElements", "WebGLRenderingContext", DrawElementsOperationCallback, 4, unsigned(v8::None),
                  unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                  unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                  unsigned(v8::SideEffectType::kHasSideEffect) },
                kNoAllocDirectCallOverloadsOfDrawElements, std::size(kNoAllocDirectCallOverloadsOfDrawElements) },
            { { "enableVertexAttribArray", "WebGLRenderingContext", EnableVertexAttribArrayOperationCallback, 1, unsigned(v8::None),
                  unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                  unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                  unsigned(v8::SideEffectType::kHasSideEffect) },
                kNoAllocDirectCallOverloadsOfEnableVertexAttribArray, std::size(kNoAllocDirectCallOverloadsOfEnableVertexAttribArray) },
            { { "scissor", "WebGLRenderingContext", ScissorOperationCallback, 4, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                  unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                  unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
                kNoAllocDirectCallOverloadsOfScissor, std::size(kNoAllocDirectCallOverloadsOfScissor) },
            { { "uniform1f", "WebGLRenderingContext", Uniform1FOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                  unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                  unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
                kNoAllocDirectCallOverloadsOfUniform1F, std::size(kNoAllocDirectCallOverloadsOfUniform1F) },
            { { "uniform1fv", "WebGLRenderingContext", Uniform1FvOperationCallback, 2, unsigned(v8::None),
                  unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                  unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                  unsigned(v8::SideEffectType::kHasSideEffect) },
                kNoAllocDirectCallOverloadsOfUniform1Fv, std::size(kNoAllocDirectCallOverloadsOfUniform1Fv) },
            { { "uniform1i", "WebGLRenderingContext", Uniform1IOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                  unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                  unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
                kNoAllocDirectCallOverloadsOfUniform1I, std::size(kNoAllocDirectCallOverloadsOfUniform1I) },
            { { "uniform1iv", "WebGLRenderingContext", Uniform1IvOperationCallback, 2, unsigned(v8::None),
                  unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                  unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                  unsigned(v8::SideEffectType::kHasSideEffect) },
                kNoAllocDirectCallOverloadsOfUniform1Iv, std::size(kNoAllocDirectCallOverloadsOfUniform1Iv) },
            { { "uniform2f", "WebGLRenderingContext", Uniform2FOperationCallback, 3, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                  unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                  unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
                kNoAllocDirectCallOverloadsOfUniform2F, std::size(kNoAllocDirectCallOverloadsOfUniform2F) },
            { { "uniform2fv", "WebGLRenderingContext", Uniform2FvOperationCallback, 2, unsigned(v8::None),
                  unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                  unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                  unsigned(v8::SideEffectType::kHasSideEffect) },
                kNoAllocDirectCallOverloadsOfUniform2Fv, std::size(kNoAllocDirectCallOverloadsOfUniform2Fv) },
            { { "uniform2i", "WebGLRenderingContext", Uniform2IOperationCallback, 3, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                  unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                  unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
                kNoAllocDirectCallOverloadsOfUniform2I, std::size(kNoAllocDirectCallOverloadsOfUniform2I) },
            { { "uniform2iv", "WebGLRenderingContext", Uniform2IvOperationCallback, 2, unsigned(v8::None),
                  unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                  unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                  unsigned(v8::SideEffectType::kHasSideEffect) },
                kNoAllocDirectCallOverloadsOfUniform2Iv, std::size(kNoAllocDirectCallOverloadsOfUniform2Iv) },
            { { "uniform3f", "WebGLRenderingContext", Uniform3FOperationCallback, 4, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                  unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                  unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
                kNoAllocDirectCallOverloadsOfUniform3F, std::size(kNoAllocDirectCallOverloadsOfUniform3F) },
            { { "uniform3fv", "WebGLRenderingContext", Uniform3FvOperationCallback, 2, unsigned(v8::None),
                  unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                  unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                  unsigned(v8::SideEffectType::kHasSideEffect) },
                kNoAllocDirectCallOverloadsOfUniform3Fv, std::size(kNoAllocDirectCallOverloadsOfUniform3Fv) },
            { { "uniform3i", "WebGLRenderingContext", Uniform3IOperationCallback, 4, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                  unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                  unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
                kNoAllocDirectCallOverloadsOfUniform3I, std::size(kNoAllocDirectCallOverloadsOfUniform3I) },
            { { "uniform3iv", "WebGLRenderingContext", Uniform3IvOperationCallback, 2, unsigned(v8::None),
                  unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                  unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                  unsigned(v8::SideEffectType::kHasSideEffect) },
                kNoAllocDirectCallOverloadsOfUniform3Iv, std::size(kNoAllocDirectCallOverloadsOfUniform3Iv) },
            { { "uniform4f", "WebGLRenderingContext", Uniform4FOperationCallback, 5, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                  unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                  unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
                kNoAllocDirectCallOverloadsOfUniform4F, std::size(kNoAllocDirectCallOverloadsOfUniform4F) },
            { { "uniform4fv", "WebGLRenderingContext", Uniform4FvOperationCallback, 2, unsigned(v8::None),
                  unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                  unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                  unsigned(v8::SideEffectType::kHasSideEffect) },
                kNoAllocDirectCallOverloadsOfUniform4Fv, std::size(kNoAllocDirectCallOverloadsOfUniform4Fv) },
            { { "uniform4i", "WebGLRenderingContext", Uniform4IOperationCallback, 5, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                  unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                  unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
                kNoAllocDirectCallOverloadsOfUniform4I, std::size(kNoAllocDirectCallOverloadsOfUniform4I) },
            { { "uniform4iv", "WebGLRenderingContext", Uniform4IvOperationCallback, 2, unsigned(v8::None),
                  unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                  unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                  unsigned(v8::SideEffectType::kHasSideEffect) },
                kNoAllocDirectCallOverloadsOfUniform4Iv, std::size(kNoAllocDirectCallOverloadsOfUniform4Iv) },
            { { "uniformMatrix2fv", "WebGLRenderingContext", UniformMatrix2FvOperationCallback, 3, unsigned(v8::None),
                  unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                  unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                  unsigned(v8::SideEffectType::kHasSideEffect) },
                kNoAllocDirectCallOverloadsOfUniformMatrix2Fv, std::size(kNoAllocDirectCallOverloadsOfUniformMatrix2Fv) },
            { { "uniformMatrix3fv", "WebGLRenderingContext", UniformMatrix3FvOperationCallback, 3, unsigned(v8::None),
                  unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                  unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                  unsigned(v8::SideEffectType::kHasSideEffect) },
                kNoAllocDirectCallOverloadsOfUniformMatrix3Fv, std::size(kNoAllocDirectCallOverloadsOfUniformMatrix3Fv) },
            { { "uniformMatrix4fv", "WebGLRenderingContext", UniformMatrix4FvOperationCallback, 3, unsigned(v8::None),
                  unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                  unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                  unsigned(v8::SideEffectType::kHasSideEffect) },
                kNoAllocDirectCallOverloadsOfUniformMatrix4Fv, std::size(kNoAllocDirectCallOverloadsOfUniformMatrix4Fv) },
            { { "vertexAttrib1f", "WebGLRenderingContext", VertexAttrib1FOperationCallback, 2, unsigned(v8::None),
                  unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                  unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                  unsigned(v8::SideEffectType::kHasSideEffect) },
                kNoAllocDirectCallOverloadsOfVertexAttrib1F, std::size(kNoAllocDirectCallOverloadsOfVertexAttrib1F) },
            { { "vertexAttrib1fv", "WebGLRenderingContext", VertexAttrib1FvOperationCallback, 2, unsigned(v8::None),
                  unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                  unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                  unsigned(v8::SideEffectType::kHasSideEffect) },
                kNoAllocDirectCallOverloadsOfVertexAttrib1Fv, std::size(kNoAllocDirectCallOverloadsOfVertexAttrib1Fv) },
            { { "vertexAttrib2f", "WebGLRenderingContext", VertexAttrib2FOperationCallback, 3, unsigned(v8::None),
                  unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                  unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                  unsigned(v8::SideEffectType::kHasSideEffect) },
                kNoAllocDirectCallOverloadsOfVertexAttrib2F, std::size(kNoAllocDirectCallOverloadsOfVertexAttrib2F) },
            { { "vertexAttrib2fv", "WebGLRenderingContext", VertexAttrib2FvOperationCallback, 2, unsigned(v8::None),
                  unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                  unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                  unsigned(v8::SideEffectType::kHasSideEffect) },
                kNoAllocDirectCallOverloadsOfVertexAttrib2Fv, std::size(kNoAllocDirectCallOverloadsOfVertexAttrib2Fv) },
            { { "vertexAttrib3f", "WebGLRenderingContext", VertexAttrib3FOperationCallback, 4, unsigned(v8::None),
                  unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                  unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                  unsigned(v8::SideEffectType::kHasSideEffect) },
                kNoAllocDirectCallOverloadsOfVertexAttrib3F, std::size(kNoAllocDirectCallOverloadsOfVertexAttrib3F) },
            { { "vertexAttrib3fv", "WebGLRenderingContext", VertexAttrib3FvOperationCallback, 2, unsigned(v8::None),
                  unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                  unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                  unsigned(v8::SideEffectType::kHasSideEffect) },
                kNoAllocDirectCallOverloadsOfVertexAttrib3Fv, std::size(kNoAllocDirectCallOverloadsOfVertexAttrib3Fv) },
            { { "vertexAttrib4f", "WebGLRenderingContext", VertexAttrib4FOperationCallback, 5, unsigned(v8::None),
                  unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                  unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                  unsigned(v8::SideEffectType::kHasSideEffect) },
                kNoAllocDirectCallOverloadsOfVertexAttrib4F, std::size(kNoAllocDirectCallOverloadsOfVertexAttrib4F) },
            { { "vertexAttrib4fv", "WebGLRenderingContext", VertexAttrib4FvOperationCallback, 2, unsigned(v8::None),
                  unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                  unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                  unsigned(v8::SideEffectType::kHasSideEffect) },
                kNoAllocDirectCallOverloadsOfVertexAttrib4Fv, std::size(kNoAllocDirectCallOverloadsOfVertexAttrib4Fv) },
            { { "vertexAttribPointer", "WebGLRenderingContext", VertexAttribPointerOperationCallback, 6, unsigned(v8::None),
                  unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                  unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                  unsigned(v8::SideEffectType::kHasSideEffect) },
                kNoAllocDirectCallOverloadsOfVertexAttribPointer, std::size(kNoAllocDirectCallOverloadsOfVertexAttribPointer) },
            { { "viewport", "WebGLRenderingContext", ViewportOperationCallback, 4, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                  unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                  unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
                kNoAllocDirectCallOverloadsOfViewport, std::size(kNoAllocDirectCallOverloadsOfViewport) },
        };
        IDLMemberInstaller::InstallOperations(isolate, world, instance_template, prototype_template, interface_template, signature, kOperationTable);
    }
}

void V8WebGLRenderingContext::InstallContextIndependentProperties(v8::Isolate* isolate, const DOMWrapperWorld& world, v8::Local<v8::Template> instance_template,
    v8::Local<v8::Template> prototype_template, v8::Local<v8::Template> interface_template)
{
    using bindings::IDLMemberInstaller;

    if (RuntimeEnabledFeatures::WebGLDrawingBufferStorageEnabled()) {
        static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
            { "drawingBufferFormat", "WebGLRenderingContext", DrawingBufferFormatAttributeGetCallback, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
        };
        v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
        v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
        IDLMemberInstaller::InstallAttributes(isolate, world, instance_template, prototype_template, interface_template, signature, kAttributeTable);
    }

    if (RuntimeEnabledFeatures::WebGLDrawingBufferStorageEnabled()) {
        static const IDLMemberInstaller::ConstantValueConfig kConstantValueTable[] = {
            { "RGB8", V8WebGLRenderingContext::Constant::kRgb8 },
            { "RGBA8", V8WebGLRenderingContext::Constant::kRgba8 },
        };
        v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
        v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
        IDLMemberInstaller::InstallConstants(isolate, world, instance_template, prototype_template, interface_template, signature, kConstantValueTable);
    }

    if (RuntimeEnabledFeatures::OffscreenCanvasCommitEnabled()) {
        static const IDLMemberInstaller::OperationConfig kOperationTable[] = {
            { "commit", "WebGLRenderingContext", CommitOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
        };
        v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
        v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
        IDLMemberInstaller::InstallOperations(isolate, world, instance_template, prototype_template, interface_template, signature, kOperationTable);
    }
    if (RuntimeEnabledFeatures::WebGLDrawingBufferStorageEnabled()) {
        static const IDLMemberInstaller::OperationConfig kOperationTable[] = {
            { "drawingBufferStorage", "WebGLRenderingContext", DrawingBufferStorageOperationCallback, 3, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
        };
        v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
        v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
        IDLMemberInstaller::InstallOperations(isolate, world, instance_template, prototype_template, interface_template, signature, kOperationTable);
    }
}

void V8WebGLRenderingContext::InstallContextDependentProperties(v8::Local<v8::Context> context, const DOMWrapperWorld& world,
    v8::Local<v8::Object> instance_object, v8::Local<v8::Object> prototype_object, v8::Local<v8::Object> interface_object,
    v8::Local<v8::Template> interface_template, FeatureSelector feature_selector)
{
    using bindings::IDLMemberInstaller;

    v8::Isolate* isolate = context->GetIsolate();
    ScriptState* script_state = ScriptState::From(isolate, context);
    ExecutionContext* execution_context = ToExecutionContext(script_state);
    const bool is_in_secure_context = execution_context->IsSecureContext();
    if (is_in_secure_context && (feature_selector.IsAll() && RuntimeEnabledFeatures::WebXREnabled())) {
        static const IDLMemberInstaller::OperationConfig kOperationTable[] = {
            { "makeXRCompatible", "WebGLRenderingContext", MakeXRCompatibleOperationCallback, 0, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kDoNotCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
        };
        v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
        v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
        IDLMemberInstaller::InstallOperations(isolate, world, instance_object, prototype_object, interface_object, signature, kOperationTable);
    }
}

} // namespace blink
