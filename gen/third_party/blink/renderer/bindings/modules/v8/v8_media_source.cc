// Copyright 2019 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// DO NOT EDIT: This file is auto-generated by
// //third_party/blink/renderer/bindings/scripts/generate_bindings.py
//
// Use the GN flag `blink_enable_generated_code_formatting=true` to enable
// formatting of the generated files.

#include "third_party/blink/renderer/bindings/modules/v8/v8_media_source.h"

#include "third_party/blink/public/mojom/origin_trials/origin_trial_feature.mojom-shared.h"
#include "third_party/blink/renderer/bindings/core/v8/generated_code_helper.h"
#include "third_party/blink/renderer/bindings/core/v8/is_return_type_compatible.h"
#include "third_party/blink/renderer/bindings/core/v8/native_value_traits_impl.h"
#include "third_party/blink/renderer/bindings/core/v8/to_v8_traits.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_event_handler_non_null.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_event_target.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_set_return_value_for_core.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_end_of_stream_error.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_media_source_handle.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_source_buffer.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_source_buffer_config.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_source_buffer_list.h"
#include "third_party/blink/renderer/core/execution_context/execution_context.h"
#include "third_party/blink/renderer/core/frame/web_feature.h"
#include "third_party/blink/renderer/modules/mediasource/media_source.h"
#include "third_party/blink/renderer/modules/mediasource/media_source_handle_impl.h"
#include "third_party/blink/renderer/modules/mediasource/source_buffer.h"
#include "third_party/blink/renderer/modules/mediasource/source_buffer_list.h"
#include "third_party/blink/renderer/platform/bindings/cooperative_scheduling_helpers.h"
#include "third_party/blink/renderer/platform/bindings/exception_messages.h"
#include "third_party/blink/renderer/platform/bindings/idl_member_installer.h"
#include "third_party/blink/renderer/platform/bindings/runtime_call_stats.h"
#include "third_party/blink/renderer/platform/bindings/v8_binding.h"
#include "third_party/blink/renderer/platform/bindings/v8_object_constructor.h"
#include "third_party/blink/renderer/platform/bindings/wrapper_type_info.h"
#include "third_party/blink/renderer/platform/instrumentation/use_counter.h"

namespace blink {

bool V8MediaSource::IsExposed(ExecutionContext* execution_context)
{
    return execution_context->IsWindow() || execution_context->IsDedicatedWorkerGlobalScope();
}

// Construction of WrapperTypeInfo may require non-trivial initialization due
// to cross-component address resolution in order to load the pointer to the
// parent interface's WrapperTypeInfo.  We ignore this issue because the issue
// happens only on component builds and the official release builds
// (statically-linked builds) are never affected by this issue.
#if defined(COMPONENT_BUILD) && defined(WIN32) && defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wglobal-constructors"
#endif

const WrapperTypeInfo V8MediaSource::wrapper_type_info_ {
    gin::kEmbedderBlink,
    V8MediaSource::InstallInterfaceTemplate,
    V8MediaSource::InstallContextDependentProperties,
    "MediaSource",
    V8EventTarget::GetWrapperTypeInfo(),
    V8MediaSource::kThisTag,
    V8MediaSource::kMaxSubclassTag,
    WrapperTypeInfo::kWrapperTypeObjectPrototype,
    WrapperTypeInfo::kObjectClassId,
    WrapperTypeInfo::kInheritFromActiveScriptWrappable,
    WrapperTypeInfo::kIdlInterface,
    false,
};

// #if defined(COMPONENT_BUILD) && defined(WIN32) && defined(__clang__)
// #pragma clang diagnostic pop
// #endif
// 
// const WrapperTypeInfo& MediaSource::wrapper_type_info_ = V8MediaSource::wrapper_type_info_;
// 
// // [ActiveScriptWrappable]
// static_assert(std::is_base_of<ActiveScriptWrappableBase, MediaSource>::value,
//     "MediaSource does not inherit from ActiveScriptWrappable<> despite "
//     "the IDL has [ActiveScriptWrappable] extended attribute.");
// 
// namespace {
// 
// namespace v8_media_source {
// 
// void SourceBuffersAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
// {
// 
//     RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MediaSource_sourceBuffers_Getter");
//     BLINK_BINDINGS_TRACE_EVENT("MediaSource.sourceBuffers.get");
// 
//     v8::Isolate* isolate = info.GetIsolate();
//     v8::Local<v8::Object> v8_receiver = info.This();
//     MediaSource* blink_receiver = V8MediaSource::ToWrappableUnsafe(isolate, v8_receiver);
//     auto&& return_value = blink_receiver->sourceBuffers();
//     static_assert(bindings::IsReturnTypeCompatible<SourceBufferList, std::remove_cvref_t<decltype(return_value)>>,
//         "Return type from native call is incompatible to the type specified in IDL");
//     bindings::V8SetReturnValue(info, return_value, blink_receiver);
// }
// 
// void ActiveSourceBuffersAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
// {
// 
//     RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MediaSource_activeSourceBuffers_Getter");
//     BLINK_BINDINGS_TRACE_EVENT("MediaSource.activeSourceBuffers.get");
// 
//     v8::Isolate* isolate = info.GetIsolate();
//     v8::Local<v8::Object> v8_receiver = info.This();
//     MediaSource* blink_receiver = V8MediaSource::ToWrappableUnsafe(isolate, v8_receiver);
//     auto&& return_value = blink_receiver->activeSourceBuffers();
//     static_assert(bindings::IsReturnTypeCompatible<SourceBufferList, std::remove_cvref_t<decltype(return_value)>>,
//         "Return type from native call is incompatible to the type specified in IDL");
//     bindings::V8SetReturnValue(info, return_value, blink_receiver);
// }
// 
// void DurationAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
// {
// 
//     RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MediaSource_duration_Getter");
//     BLINK_BINDINGS_TRACE_EVENT("MediaSource.duration.get");
// 
//     v8::Isolate* isolate = info.GetIsolate();
//     v8::Local<v8::Object> v8_receiver = info.This();
//     MediaSource* blink_receiver = V8MediaSource::ToWrappableUnsafe(isolate, v8_receiver);
//     auto&& return_value = blink_receiver->duration();
//     static_assert(bindings::IsReturnTypeCompatible<IDLUnrestrictedDouble, std::remove_cvref_t<decltype(return_value)>>,
//         "Return type from native call is incompatible to the type specified in IDL");
//     bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<double>());
// }
// 
// void DurationAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
// {
// 
//     RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MediaSource_duration_Setter");
//     BLINK_BINDINGS_TRACE_EVENT("MediaSource.duration.set");
// 
//     v8::Isolate* isolate = info.GetIsolate();
//     v8::Local<v8::Object> v8_receiver = info.This();
//     MediaSource* blink_receiver = V8MediaSource::ToWrappableUnsafe(isolate, v8_receiver);
//     v8::Local<v8::Value> v8_property_value = info[0];
//     ExceptionState exception_state(isolate);
//     auto&& arg1_value = NativeValueTraits<IDLUnrestrictedDouble>::NativeValue(isolate, v8_property_value, exception_state);
//     if (exception_state.HadException()) [[unlikely]] {
//         return;
//     }
//     blink_receiver->setDuration(arg1_value, exception_state);
//     if (exception_state.HadException()) [[unlikely]] {
//         return;
//     }
// }
// 
// void OnsourceopenAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
// {
// 
//     RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MediaSource_onsourceopen_Getter");
//     BLINK_BINDINGS_TRACE_EVENT("MediaSource.onsourceopen.get");
// 
//     v8::Isolate* isolate = info.GetIsolate();
//     v8::Local<v8::Object> v8_receiver = info.This();
//     MediaSource* blink_receiver = V8MediaSource::ToWrappableUnsafe(isolate, v8_receiver);
//     auto&& return_value = blink_receiver->onsourceopen();
//     static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
//         "Return type from native call is incompatible to the type specified in IDL");
//     bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
// }
// 
// void OnsourceopenAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
// {
// 
//     RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MediaSource_onsourceopen_Setter");
//     BLINK_BINDINGS_TRACE_EVENT("MediaSource.onsourceopen.set");
// 
//     v8::Local<v8::Value> v8_property_value = info[0];
//     EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
//     v8::Isolate* isolate = info.GetIsolate();
//     v8::Local<v8::Object> v8_receiver = info.This();
//     MediaSource* blink_receiver = V8MediaSource::ToWrappableUnsafe(isolate, v8_receiver);
//     blink_receiver->setOnsourceopen(event_handler);
// }
// 
// void OnsourceendedAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
// {
// 
//     RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MediaSource_onsourceended_Getter");
//     BLINK_BINDINGS_TRACE_EVENT("MediaSource.onsourceended.get");
// 
//     v8::Isolate* isolate = info.GetIsolate();
//     v8::Local<v8::Object> v8_receiver = info.This();
//     MediaSource* blink_receiver = V8MediaSource::ToWrappableUnsafe(isolate, v8_receiver);
//     auto&& return_value = blink_receiver->onsourceended();
//     static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
//         "Return type from native call is incompatible to the type specified in IDL");
//     bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
// }
// 
// void OnsourceendedAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
// {
// 
//     RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MediaSource_onsourceended_Setter");
//     BLINK_BINDINGS_TRACE_EVENT("MediaSource.onsourceended.set");
// 
//     v8::Local<v8::Value> v8_property_value = info[0];
//     EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
//     v8::Isolate* isolate = info.GetIsolate();
//     v8::Local<v8::Object> v8_receiver = info.This();
//     MediaSource* blink_receiver = V8MediaSource::ToWrappableUnsafe(isolate, v8_receiver);
//     blink_receiver->setOnsourceended(event_handler);
// }
// 
// void OnsourcecloseAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
// {
// 
//     RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MediaSource_onsourceclose_Getter");
//     BLINK_BINDINGS_TRACE_EVENT("MediaSource.onsourceclose.get");
// 
//     v8::Isolate* isolate = info.GetIsolate();
//     v8::Local<v8::Object> v8_receiver = info.This();
//     MediaSource* blink_receiver = V8MediaSource::ToWrappableUnsafe(isolate, v8_receiver);
//     auto&& return_value = blink_receiver->onsourceclose();
//     static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
//         "Return type from native call is incompatible to the type specified in IDL");
//     bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
// }
// 
// void OnsourcecloseAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
// {
// 
//     RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MediaSource_onsourceclose_Setter");
//     BLINK_BINDINGS_TRACE_EVENT("MediaSource.onsourceclose.set");
// 
//     v8::Local<v8::Value> v8_property_value = info[0];
//     EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
//     v8::Isolate* isolate = info.GetIsolate();
//     v8::Local<v8::Object> v8_receiver = info.This();
//     MediaSource* blink_receiver = V8MediaSource::ToWrappableUnsafe(isolate, v8_receiver);
//     blink_receiver->setOnsourceclose(event_handler);
// }
// 
// void ReadyStateAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
// {
// 
//     RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MediaSource_readyState_Getter");
//     BLINK_BINDINGS_TRACE_EVENT("MediaSource.readyState.get");
// 
//     v8::Isolate* isolate = info.GetIsolate();
//     v8::Local<v8::Object> v8_receiver = info.This();
//     MediaSource* blink_receiver = V8MediaSource::ToWrappableUnsafe(isolate, v8_receiver);
//     auto&& return_value = blink_receiver->readyState();
//     static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
//         "Return type from native call is incompatible to the type specified in IDL");
//     bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
// }
// 
// void HandleAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
// {
// 
//     RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MediaSource_handle_Getter");
//     BLINK_BINDINGS_TRACE_EVENT("MediaSource.handle.get");
//     v8::Isolate* isolate = info.GetIsolate();
//     v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
//     ScriptState* current_script_state = ScriptState::From(isolate, current_context);
//     ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
//     // [Measure], [MeasureAs]
//     UseCounter::Count(current_execution_context, WebFeature::kMediaSourceGetHandle);
// 
//     v8::Local<v8::Object> v8_receiver = info.This();
//     MediaSource* blink_receiver = V8MediaSource::ToWrappableUnsafe(isolate, v8_receiver);
//     auto&& return_value = blink_receiver->handle();
//     static_assert(bindings::IsReturnTypeCompatible<MediaSourceHandleImpl, std::remove_cvref_t<decltype(return_value)>>,
//         "Return type from native call is incompatible to the type specified in IDL");
//     bindings::V8SetReturnValue(info, return_value, blink_receiver);
// }
// 
// void CanConstructInDedicatedWorkerAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
// {
// 
//     RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MediaSource_canConstructInDedicatedWorker_Getter");
//     BLINK_BINDINGS_TRACE_EVENT("MediaSource.canConstructInDedicatedWorker.get");
// 
//     v8::Isolate* isolate = info.GetIsolate();
//     v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
//     ScriptState* current_script_state = ScriptState::From(isolate, current_context);
//     ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
//     ExecutionContext* execution_context = current_execution_context;
//     auto&& return_value = MediaSource::canConstructInDedicatedWorker(execution_context);
//     static_assert(bindings::IsReturnTypeCompatible<IDLBoolean, std::remove_cvref_t<decltype(return_value)>>,
//         "Return type from native call is incompatible to the type specified in IDL");
//     bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
// }
// 
// void ConstructorCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
// {
//     RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MediaSource_constructor");
//     BLINK_BINDINGS_TRACE_EVENT("MediaSource.constructor");
// 
//     v8::Isolate* isolate = info.GetIsolate();
//     if (!info.IsConstructCall()) {
//         V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::ConstructorCalledAsFunction());
//         return;
//     }
//     v8::Local<v8::Object> v8_receiver = info.This();
//     if (ConstructorMode::Current(isolate) == ConstructorMode::kWrapExistingObject) {
//         bindings::V8SetReturnValue(info, v8_receiver);
//         return;
//     }
// 
//     v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
//     ScriptState* current_script_state = ScriptState::From(isolate, current_context);
//     ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
//     ExecutionContext* execution_context = current_execution_context;
//     auto&& return_value = MediaSource::Create(execution_context);
//     static_assert(bindings::IsReturnTypeCompatible<MediaSource, std::remove_cvref_t<decltype(return_value)>>,
//         "Return type from native call is incompatible to the type specified in IDL");
//     v8::Local<v8::Object> v8_wrapper = return_value->AssociateWithWrapper(isolate, V8MediaSource::GetWrapperTypeInfo(), v8_receiver);
//     bindings::V8SetReturnValue(info, v8_wrapper);
// }
// 
// void AddSourceBufferOperationOverload1(const v8::FunctionCallbackInfo<v8::Value>& info)
// {
// 
//     v8::Isolate* isolate = info.GetIsolate();
//     if (info.Length() < 1) [[unlikely]] {
//         V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
//         return;
//     }
// 
//     v8::Local<v8::Object> v8_receiver = info.This();
//     MediaSource* blink_receiver = V8MediaSource::ToWrappableUnsafe(isolate, v8_receiver);
//     ExceptionState exception_state(isolate);
//     auto&& arg1_type = NativeValueTraits<IDLString>::ArgumentValue(isolate, 0, info[0], exception_state);
//     if (exception_state.HadException()) [[unlikely]] {
//         return;
//     }
//     auto&& return_value = blink_receiver->addSourceBuffer(arg1_type, exception_state);
//     static_assert(bindings::IsReturnTypeCompatible<SourceBuffer, std::remove_cvref_t<decltype(return_value)>>,
//         "Return type from native call is incompatible to the type specified in IDL");
//     if (exception_state.HadException()) [[unlikely]] {
//         return;
//     }
//     bindings::V8SetReturnValue(info, return_value, blink_receiver);
// }
// 
// void AddSourceBufferOperationOverload2(const v8::FunctionCallbackInfo<v8::Value>& info)
// {
// 
//     v8::Isolate* isolate = info.GetIsolate();
//     v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
//     ScriptState* current_script_state = ScriptState::From(isolate, current_context);
//     ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
//     // [Measure], [MeasureAs]
//     UseCounter::Count(current_execution_context, WebFeature::kAddSourceBufferUsingConfig);
// 
//     if (info.Length() < 1) [[unlikely]] {
//         V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
//         return;
//     }
// 
//     v8::Local<v8::Object> v8_receiver = info.This();
//     MediaSource* blink_receiver = V8MediaSource::ToWrappableUnsafe(isolate, v8_receiver);
//     ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
//     ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
//     ExecutionContext* execution_context = receiver_execution_context;
//     ExceptionState exception_state(isolate);
//     auto&& arg1_config = NativeValueTraits<SourceBufferConfig>::ArgumentValue(isolate, 0, info[0], exception_state);
//     if (exception_state.HadException()) [[unlikely]] {
//         return;
//     }
//     auto&& return_value = blink_receiver->AddSourceBufferUsingConfig(execution_context, arg1_config, exception_state);
//     static_assert(bindings::IsReturnTypeCompatible<SourceBuffer, std::remove_cvref_t<decltype(return_value)>>,
//         "Return type from native call is incompatible to the type specified in IDL");
//     if (exception_state.HadException()) [[unlikely]] {
//         return;
//     }
//     bindings::V8SetReturnValue(info, return_value, blink_receiver);
// }
// 
// void AddSourceBufferOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
// {
//     RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MediaSource_addSourceBuffer");
//     BLINK_BINDINGS_TRACE_EVENT("MediaSource.addSourceBuffer");
// 
//     BINDINGS_COOPERATIVE_SCHEDULING_SAFEPOINT();
// 
//     const int arg_count = std::min(info.Length(), 1);
//     v8::Isolate* isolate = info.GetIsolate();
//     if (arg_count == 1) {
//         v8::Local<v8::Object> v8_receiver = info.This();
//         ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
//         ExecutionContext* receiver_execution_context = ToExecutionContext(receiver_script_state);
//         ExecutionContext* execution_context = receiver_execution_context;
//         if (RuntimeEnabledFeatures::MediaSourceExtensionsForWebCodecsEnabled(execution_context)) {
//             if (info[0]->IsNullOrUndefined()) {
//                 return AddSourceBufferOperationOverload2(info);
//             }
//         }
//         if (info[0]->IsObject()) {
//             if (RuntimeEnabledFeatures::MediaSourceExtensionsForWebCodecsEnabled(execution_context)) {
//                 return AddSourceBufferOperationOverload2(info);
//             }
//         }
//         return AddSourceBufferOperationOverload1(info);
//     }
// 
//     if (info.Length() < 1) [[unlikely]] {
//         V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
//         return;
//     }
//     V8ThrowException::ThrowTypeError(isolate, "Overload resolution failed.");
//     return;
// }
// 
// void ClearLiveSeekableRangeOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
// {
//     RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MediaSource_clearLiveSeekableRange");
//     BLINK_BINDINGS_TRACE_EVENT("MediaSource.clearLiveSeekableRange");
// 
//     v8::Isolate* isolate = info.GetIsolate();
//     v8::Local<v8::Object> v8_receiver = info.This();
//     MediaSource* blink_receiver = V8MediaSource::ToWrappableUnsafe(isolate, v8_receiver);
//     ExceptionState exception_state(isolate);
//     blink_receiver->clearLiveSeekableRange(exception_state);
//     if (exception_state.HadException()) [[unlikely]] {
//         return;
//     }
// }
// 
// void EndOfStreamOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
// {
//     RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MediaSource_endOfStream");
//     BLINK_BINDINGS_TRACE_EVENT("MediaSource.endOfStream");
// 
//     v8::Isolate* isolate = info.GetIsolate();
//     ExceptionState exception_state(isolate);
//     do { // Dummy loop for use of 'break'.
//         const int non_undefined_argument_length = bindings::NonUndefinedArgumentLength(info);
//         v8::Local<v8::Object> v8_receiver = info.This();
//         MediaSource* blink_receiver = V8MediaSource::ToWrappableUnsafe(isolate, v8_receiver);
//         if (non_undefined_argument_length <= 0) {
//             blink_receiver->endOfStream(exception_state);
//             break;
//         }
//         auto&& arg1_error = NativeValueTraits<V8EndOfStreamError>::ArgumentValue(isolate, 0, info[0], exception_state);
//         if (exception_state.HadException()) [[unlikely]] {
//             return;
//         }
//         blink_receiver->endOfStream(arg1_error, exception_state);
//     } while (false);
//     if (exception_state.HadException()) [[unlikely]] {
//         return;
//     }
// }
// 
// void RemoveSourceBufferOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
// {
//     RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MediaSource_removeSourceBuffer");
//     BLINK_BINDINGS_TRACE_EVENT("MediaSource.removeSourceBuffer");
// 
//     v8::Isolate* isolate = info.GetIsolate();
//     if (info.Length() < 1) [[unlikely]] {
//         V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
//         return;
//     }
// 
//     v8::Local<v8::Object> v8_receiver = info.This();
//     MediaSource* blink_receiver = V8MediaSource::ToWrappableUnsafe(isolate, v8_receiver);
//     ExceptionState exception_state(isolate);
//     auto&& arg1_buffer = NativeValueTraits<SourceBuffer>::ArgumentValue(isolate, 0, info[0], exception_state);
//     if (exception_state.HadException()) [[unlikely]] {
//         return;
//     }
//     blink_receiver->removeSourceBuffer(arg1_buffer, exception_state);
//     if (exception_state.HadException()) [[unlikely]] {
//         return;
//     }
// }
// 
// void SetLiveSeekableRangeOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
// {
//     RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MediaSource_setLiveSeekableRange");
//     BLINK_BINDINGS_TRACE_EVENT("MediaSource.setLiveSeekableRange");
// 
//     v8::Isolate* isolate = info.GetIsolate();
//     if (info.Length() < 2) [[unlikely]] {
//         V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
//         return;
//     }
// 
//     v8::Local<v8::Object> v8_receiver = info.This();
//     MediaSource* blink_receiver = V8MediaSource::ToWrappableUnsafe(isolate, v8_receiver);
//     ExceptionState exception_state(isolate);
//     auto&& arg1_start = NativeValueTraits<IDLDouble>::ArgumentValue(isolate, 0, info[0], exception_state);
//     if (exception_state.HadException()) [[unlikely]] {
//         return;
//     }
//     auto&& arg2_end = NativeValueTraits<IDLDouble>::ArgumentValue(isolate, 1, info[1], exception_state);
//     if (exception_state.HadException()) [[unlikely]] {
//         return;
//     }
//     blink_receiver->setLiveSeekableRange(arg1_start, arg2_end, exception_state);
//     if (exception_state.HadException()) [[unlikely]] {
//         return;
//     }
// }
// 
// void IsTypeSupportedStaticOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
// {
//     RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MediaSource_isTypeSupported");
//     BLINK_BINDINGS_TRACE_EVENT("MediaSource.isTypeSupported");
// 
//     v8::Isolate* isolate = info.GetIsolate();
//     if (info.Length() < 1) [[unlikely]] {
//         V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
//         return;
//     }
// 
//     v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
//     ScriptState* current_script_state = ScriptState::From(isolate, current_context);
//     ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
//     ExecutionContext* execution_context = current_execution_context;
//     decltype(NativeValueTraits<IDLString>::NativeValue(
//         std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg1_type;
//     if (info[0]->IsString()) [[likely]] {
//         arg1_type.Init(isolate, info[0].As<v8::String>());
//     } else {
//         ExceptionState exception_state(isolate);
//         arg1_type = NativeValueTraits<IDLString>::ArgumentValue(isolate, 0, info[0], exception_state);
//         if (exception_state.HadException()) [[unlikely]] {
//             return;
//         }
//     }
//     auto&& return_value = MediaSource::isTypeSupported(execution_context, arg1_type);
//     static_assert(bindings::IsReturnTypeCompatible<IDLBoolean, std::remove_cvref_t<decltype(return_value)>>,
//         "Return type from native call is incompatible to the type specified in IDL");
//     bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
// }
// 
// } // namespace v8_media_source
// 
// using namespace v8_media_source;
// 
// } // namespace
// 
void V8MediaSource::InstallInterfaceTemplate(v8::Isolate* isolate, const DOMWrapperWorld& world, v8::Local<v8::Template> interface_template)
{
//     const WrapperTypeInfo* const wrapper_type_info = V8MediaSource::GetWrapperTypeInfo();
//     v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
//     v8::Local<v8::ObjectTemplate> instance_object_template = interface_function_template->InstanceTemplate();
//     v8::Local<v8::ObjectTemplate> prototype_object_template = interface_function_template->PrototypeTemplate();
//     v8::Local<v8::FunctionTemplate> parent_interface_template = wrapper_type_info->parent_class->GetV8ClassTemplate(isolate, world).As<v8::FunctionTemplate>();
//     bindings::SetupIDLInterfaceTemplate(
//         isolate, wrapper_type_info, instance_object_template, prototype_object_template, interface_function_template, parent_interface_template);
// 
//     interface_function_template->SetCallHandler(ConstructorCallback);
//     interface_function_template->SetLength(0);
//     interface_function_template->SetInterfaceName(V8String(isolate, "MediaSource"));
//     interface_function_template->SetExceptionContext(v8::ExceptionContext::kConstructor);
// 
//     v8::Local<v8::Template> instance_template = instance_object_template;
//     v8::Local<v8::Template> prototype_template = prototype_object_template;
//     InstallUnconditionalProperties(isolate, world, instance_template, prototype_template, interface_template);
}
// 
// void V8MediaSource::InstallUnconditionalProperties(v8::Isolate* isolate, const DOMWrapperWorld& world, v8::Local<v8::Template> instance_template,
//     v8::Local<v8::Template> prototype_template, v8::Local<v8::Template> interface_template)
// {
//     using bindings::IDLMemberInstaller;
// 
//     v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
//     v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
//     {
//         static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
//             { "sourceBuffers", "MediaSource", SourceBuffersAttributeGetCallback, nullptr, unsigned(v8::None),
//                 unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
//                 unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
//                 unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
//                 unsigned(V8PrivateProperty::CachedAccessor::kNone) },
//             { "activeSourceBuffers", "MediaSource", ActiveSourceBuffersAttributeGetCallback, nullptr, unsigned(v8::None),
//                 unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
//                 unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
//                 unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
//                 unsigned(V8PrivateProperty::CachedAccessor::kNone) },
//             { "duration", "MediaSource", DurationAttributeGetCallback, DurationAttributeSetCallback, unsigned(v8::None),
//                 unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
//                 unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
//                 unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
//                 unsigned(V8PrivateProperty::CachedAccessor::kNone) },
//             { "onsourceopen", "MediaSource", OnsourceopenAttributeGetCallback, OnsourceopenAttributeSetCallback, unsigned(v8::None),
//                 unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
//                 unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
//                 unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
//                 unsigned(V8PrivateProperty::CachedAccessor::kNone) },
//             { "onsourceended", "MediaSource", OnsourceendedAttributeGetCallback, OnsourceendedAttributeSetCallback, unsigned(v8::None),
//                 unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
//                 unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
//                 unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
//                 unsigned(V8PrivateProperty::CachedAccessor::kNone) },
//             { "onsourceclose", "MediaSource", OnsourcecloseAttributeGetCallback, OnsourcecloseAttributeSetCallback, unsigned(v8::None),
//                 unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
//                 unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
//                 unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
//                 unsigned(V8PrivateProperty::CachedAccessor::kNone) },
//             { "readyState", "MediaSource", ReadyStateAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
//                 unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
//                 unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
//                 unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone) },
//             { "canConstructInDedicatedWorker", "MediaSource", CanConstructInDedicatedWorkerAttributeGetCallback, nullptr, unsigned(v8::None),
//                 unsigned(IDLMemberInstaller::FlagLocation::kInterface), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
//                 unsigned(IDLMemberInstaller::FlagReceiverCheck::kDoNotCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kDoNotCheck),
//                 unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kDoNotCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
//                 unsigned(V8PrivateProperty::CachedAccessor::kNone) },
//         };
//         IDLMemberInstaller::InstallAttributes(isolate, world, instance_template, prototype_template, interface_template, signature, kAttributeTable);
//     }
// 
//     {
//         static const IDLMemberInstaller::OperationConfig kOperationTable[] = {
//             { "addSourceBuffer", "MediaSource", AddSourceBufferOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
//                 unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
//                 unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
//             { "clearLiveSeekableRange", "MediaSource", ClearLiveSeekableRangeOperationCallback, 0, unsigned(v8::None),
//                 unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
//                 unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
//                 unsigned(v8::SideEffectType::kHasSideEffect) },
//             { "endOfStream", "MediaSource", EndOfStreamOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
//                 unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
//                 unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
//             { "removeSourceBuffer", "MediaSource", RemoveSourceBufferOperationCallback, 1, unsigned(v8::None),
//                 unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
//                 unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
//                 unsigned(v8::SideEffectType::kHasSideEffect) },
//             { "setLiveSeekableRange", "MediaSource", SetLiveSeekableRangeOperationCallback, 2, unsigned(v8::None),
//                 unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
//                 unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
//                 unsigned(v8::SideEffectType::kHasSideEffect) },
//             { "isTypeSupported", "MediaSource", IsTypeSupportedStaticOperationCallback, 1, unsigned(v8::None),
//                 unsigned(IDLMemberInstaller::FlagLocation::kInterface), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
//                 unsigned(IDLMemberInstaller::FlagReceiverCheck::kDoNotCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kDoNotCheck),
//                 unsigned(v8::SideEffectType::kHasSideEffect) },
//         };
//         IDLMemberInstaller::InstallOperations(isolate, world, instance_template, prototype_template, interface_template, signature, kOperationTable);
//     }
// }
// 
void V8MediaSource::InstallContextDependentProperties(v8::Local<v8::Context> context, const DOMWrapperWorld& world, v8::Local<v8::Object> instance_object,
    v8::Local<v8::Object> prototype_object, v8::Local<v8::Object> interface_object, v8::Local<v8::Template> interface_template,
    FeatureSelector feature_selector)
{
//     using bindings::IDLMemberInstaller;
// 
//     v8::Isolate* isolate = context->GetIsolate();
//     ScriptState* script_state = ScriptState::From(isolate, context);
//     ExecutionContext* execution_context = ToExecutionContext(script_state);
//     if (execution_context->IsDedicatedWorkerGlobalScope() && feature_selector.IsAll()) {
//         static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
//             { "handle", "MediaSource", HandleAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
//                 unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
//                 unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
//                 unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone) },
//         };
//         v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
//         v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
//         IDLMemberInstaller::InstallAttributes(isolate, world, instance_object, prototype_object, interface_object, signature, kAttributeTable);
//     }
}

} // namespace blink
