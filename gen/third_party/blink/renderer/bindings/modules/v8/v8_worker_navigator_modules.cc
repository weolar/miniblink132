// Copyright 2019 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// DO NOT EDIT: This file is auto-generated by
// //third_party/blink/renderer/bindings/scripts/generate_bindings.py
//
// Use the GN flag `blink_enable_generated_code_formatting=true` to enable
// formatting of the generated files.

#include "third_party/blink/renderer/bindings/modules/v8/v8_worker_navigator.h"

#include "third_party/blink/public/mojom/origin_trials/origin_trial_feature.mojom-shared.h"
#include "third_party/blink/renderer/bindings/core/v8/frozen_array.h"
#include "third_party/blink/renderer/bindings/core/v8/generated_code_helper.h"
#include "third_party/blink/renderer/bindings/core/v8/is_return_type_compatible.h"
#include "third_party/blink/renderer/bindings/core/v8/native_value_traits_impl.h"
#include "third_party/blink/renderer/bindings/core/v8/to_v8_traits.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_navigator_ua_data.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_set_return_value_for_core.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_gpu.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_hid.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_lock_manager.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_media_capabilities.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_ml.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_network_information.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_permissions.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_serial.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_storage_bucket_manager.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_storage_manager.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_usb.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_wake_lock.h"
#include "third_party/blink/renderer/core/execution_context/execution_context.h"
#include "third_party/blink/renderer/core/frame/dactyloscoper.h"
#include "third_party/blink/renderer/core/frame/navigator_ua_data.h"
#include "third_party/blink/renderer/core/frame/web_feature.h"
#include "third_party/blink/renderer/core/workers/worker_navigator.h"
#include "third_party/blink/renderer/modules/badging/navigator_badge.h"
#include "third_party/blink/renderer/modules/buckets/storage_bucket_manager.h"
#include "third_party/blink/renderer/modules/hid/hid.h"
#include "third_party/blink/renderer/modules/locks/lock_manager.h"
// #include "third_party/blink/renderer/modules/media_capabilities/media_capabilities.h"
// #include "third_party/blink/renderer/modules/ml/ml.h"
// #include "third_party/blink/renderer/modules/ml/navigator_ml.h"
#include "third_party/blink/renderer/modules/netinfo/network_information.h"
#include "third_party/blink/renderer/modules/permissions/permissions.h"
#include "third_party/blink/renderer/modules/quota/navigator_storage_quota.h"
#include "third_party/blink/renderer/modules/quota/storage_manager.h"
// #include "third_party/blink/renderer/modules/serial/serial.h"
// #include "third_party/blink/renderer/modules/wake_lock/wake_lock.h"
// #include "third_party/blink/renderer/modules/webgpu/gpu.h"
// #include "third_party/blink/renderer/modules/webusb/usb.h"
#include "third_party/blink/renderer/platform/bindings/exception_messages.h"
#include "third_party/blink/renderer/platform/bindings/idl_member_installer.h"
#include "third_party/blink/renderer/platform/bindings/runtime_call_stats.h"
#include "third_party/blink/renderer/platform/bindings/v8_binding.h"
#include "third_party/blink/renderer/platform/instrumentation/use_counter.h"

namespace blink {

void V8WorkerNavigator::Impl::Init()
{
    V8WorkerNavigator::install_interface_template_func_ = InstallInterfaceTemplate;
    V8WorkerNavigator::install_unconditional_props_func_ = InstallUnconditionalProperties;
    V8WorkerNavigator::install_context_dependent_props_func_ = InstallContextDependentProperties;
}

namespace {

namespace v8_worker_navigator {

// void StorageBucketsAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
// {
// 
//     RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WorkerNavigator_storageBuckets_Getter");
//     BLINK_BINDINGS_TRACE_EVENT("WorkerNavigator.storageBuckets.get");
// 
//     v8::Isolate* isolate = info.GetIsolate();
//     v8::Local<v8::Object> v8_receiver = info.This();
//     WorkerNavigator* blink_receiver = V8WorkerNavigator::ToWrappableUnsafe(isolate, v8_receiver);
//     auto&& return_value = StorageBucketManager::storageBuckets(*blink_receiver);
//     static_assert(bindings::IsReturnTypeCompatible<StorageBucketManager, std::remove_cvref_t<decltype(return_value)>>,
//         "Return type from native call is incompatible to the type specified in IDL");
//     bindings::V8SetReturnValue(info, return_value, blink_receiver);
// }
// 
// void HidAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
// {
// 
//     RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WorkerNavigator_hid_Getter");
//     BLINK_BINDINGS_TRACE_EVENT("WorkerNavigator.hid.get");
// 
//     v8::Isolate* isolate = info.GetIsolate();
//     v8::Local<v8::Object> v8_receiver = info.This();
//     WorkerNavigator* blink_receiver = V8WorkerNavigator::ToWrappableUnsafe(isolate, v8_receiver);
//     auto&& return_value = HID::hid(*blink_receiver);
//     static_assert(bindings::IsReturnTypeCompatible<HID, std::remove_cvref_t<decltype(return_value)>>,
//         "Return type from native call is incompatible to the type specified in IDL");
//     bindings::V8SetReturnValue(info, return_value, blink_receiver);
// }
//
// void LocksAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
// {
// 
//     RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WorkerNavigator_locks_Getter");
//     BLINK_BINDINGS_TRACE_EVENT("WorkerNavigator.locks.get");
// 
//     v8::Isolate* isolate = info.GetIsolate();
//     v8::Local<v8::Object> v8_receiver = info.This();
//     WorkerNavigator* blink_receiver = V8WorkerNavigator::ToWrappableUnsafe(isolate, v8_receiver);
//     auto&& return_value = LockManager::locks(*blink_receiver);
//     static_assert(bindings::IsReturnTypeCompatible<LockManager, std::remove_cvref_t<decltype(return_value)>>,
//         "Return type from native call is incompatible to the type specified in IDL");
//     bindings::V8SetReturnValue(info, return_value, blink_receiver);
// }
//
// void MediaCapabilitiesAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
// {
// 
//     RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WorkerNavigator_mediaCapabilities_Getter");
//     BLINK_BINDINGS_TRACE_EVENT("WorkerNavigator.mediaCapabilities.get");
// 
//     v8::Isolate* isolate = info.GetIsolate();
//     v8::Local<v8::Object> v8_receiver = info.This();
//     WorkerNavigator* blink_receiver = V8WorkerNavigator::ToWrappableUnsafe(isolate, v8_receiver);
//     auto&& return_value = MediaCapabilities::mediaCapabilities(*blink_receiver);
//     static_assert(bindings::IsReturnTypeCompatible<MediaCapabilities, std::remove_cvref_t<decltype(return_value)>>,
//         "Return type from native call is incompatible to the type specified in IDL");
//     bindings::V8SetReturnValue(info, return_value, blink_receiver);
// }
//
// void MlAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
// {
// 
//     RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WorkerNavigator_ml_Getter");
//     BLINK_BINDINGS_TRACE_EVENT("WorkerNavigator.ml.get");
// 
//     v8::Isolate* isolate = info.GetIsolate();
//     v8::Local<v8::Object> v8_receiver = info.This();
//     WorkerNavigator* blink_receiver = V8WorkerNavigator::ToWrappableUnsafe(isolate, v8_receiver);
//     auto&& return_value = NavigatorML::ml(*blink_receiver);
//     static_assert(bindings::IsReturnTypeCompatible<ML, std::remove_cvref_t<decltype(return_value)>>,
//         "Return type from native call is incompatible to the type specified in IDL");
//     bindings::V8SetReturnValue(info, return_value, blink_receiver);
// }
//
// void ConnectionAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
// {
// 
//     RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WorkerNavigator_connection_Getter");
//     BLINK_BINDINGS_TRACE_EVENT("WorkerNavigator.connection.get");
//     v8::Isolate* isolate = info.GetIsolate();
//     v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
//     ScriptState* current_script_state = ScriptState::From(isolate, current_context);
//     ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
//     // [Measure], [MeasureAs]
//     UseCounter::Count(current_execution_context, WebFeature::kNetInfo);
// 
//     v8::Local<v8::Object> v8_receiver = info.This();
//     WorkerNavigator* blink_receiver = V8WorkerNavigator::ToWrappableUnsafe(isolate, v8_receiver);
//     auto&& return_value = NetworkInformation::connection(*blink_receiver);
//     static_assert(bindings::IsReturnTypeCompatible<NetworkInformation, std::remove_cvref_t<decltype(return_value)>>,
//         "Return type from native call is incompatible to the type specified in IDL");
//     bindings::V8SetReturnValue(info, return_value, blink_receiver);
// }
// 
// void PermissionsAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
// {
// 
//     RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WorkerNavigator_permissions_Getter");
//     BLINK_BINDINGS_TRACE_EVENT("WorkerNavigator.permissions.get");
// 
//     v8::Isolate* isolate = info.GetIsolate();
//     v8::Local<v8::Object> v8_receiver = info.This();
//     WorkerNavigator* blink_receiver = V8WorkerNavigator::ToWrappableUnsafe(isolate, v8_receiver);
//     auto&& return_value = Permissions::permissions(*blink_receiver);
//     static_assert(bindings::IsReturnTypeCompatible<Permissions, std::remove_cvref_t<decltype(return_value)>>,
//         "Return type from native call is incompatible to the type specified in IDL");
//     bindings::V8SetReturnValue(info, return_value, blink_receiver);
// }

void StorageAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WorkerNavigator_storage_Getter");
    BLINK_BINDINGS_TRACE_EVENT("WorkerNavigator.storage.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    WorkerNavigator* blink_receiver = V8WorkerNavigator::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = NavigatorStorageQuota::storage(*blink_receiver);
    static_assert(bindings::IsReturnTypeCompatible<StorageManager, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

// void WakeLockAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
// {
// 
//     RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WorkerNavigator_wakeLock_Getter");
//     BLINK_BINDINGS_TRACE_EVENT("WorkerNavigator.wakeLock.get");
// 
//     v8::Isolate* isolate = info.GetIsolate();
//     v8::Local<v8::Object> v8_receiver = info.This();
//     WorkerNavigator* blink_receiver = V8WorkerNavigator::ToWrappableUnsafe(isolate, v8_receiver);
//     auto&& return_value = WakeLock::wakeLock(*blink_receiver);
//     static_assert(bindings::IsReturnTypeCompatible<WakeLock, std::remove_cvref_t<decltype(return_value)>>,
//         "Return type from native call is incompatible to the type specified in IDL");
//     bindings::V8SetReturnValue(info, return_value, blink_receiver);
// }
//
// void GpuAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
// {
// 
//     RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WorkerNavigator_gpu_Getter");
//     BLINK_BINDINGS_TRACE_EVENT("WorkerNavigator.gpu.get");
// 
//     v8::Isolate* isolate = info.GetIsolate();
//     v8::Local<v8::Object> v8_receiver = info.This();
//     WorkerNavigator* blink_receiver = V8WorkerNavigator::ToWrappableUnsafe(isolate, v8_receiver);
//     auto&& return_value = GPU::gpu(*blink_receiver);
//     static_assert(bindings::IsReturnTypeCompatible<GPU, std::remove_cvref_t<decltype(return_value)>>,
//         "Return type from native call is incompatible to the type specified in IDL");
//     bindings::V8SetReturnValue(info, return_value, blink_receiver);
// }
// 
// void UsbAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
// {
// 
//     RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WorkerNavigator_usb_Getter");
//     BLINK_BINDINGS_TRACE_EVENT("WorkerNavigator.usb.get");
// 
//     v8::Isolate* isolate = info.GetIsolate();
//     v8::Local<v8::Object> v8_receiver = info.This();
//     WorkerNavigator* blink_receiver = V8WorkerNavigator::ToWrappableUnsafe(isolate, v8_receiver);
//     auto&& return_value = USB::usb(*blink_receiver);
//     static_assert(bindings::IsReturnTypeCompatible<USB, std::remove_cvref_t<decltype(return_value)>>,
//         "Return type from native call is incompatible to the type specified in IDL");
//     bindings::V8SetReturnValue(info, return_value, blink_receiver);
// }
// 
// void SerialAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
// {
// 
//     RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WorkerNavigator_serial_Getter");
//     BLINK_BINDINGS_TRACE_EVENT("WorkerNavigator.serial.get");
// 
//     v8::Isolate* isolate = info.GetIsolate();
//     v8::Local<v8::Object> v8_receiver = info.This();
//     WorkerNavigator* blink_receiver = V8WorkerNavigator::ToWrappableUnsafe(isolate, v8_receiver);
//     auto&& return_value = Serial::serial(*blink_receiver);
//     static_assert(bindings::IsReturnTypeCompatible<Serial, std::remove_cvref_t<decltype(return_value)>>,
//         "Return type from native call is incompatible to the type specified in IDL");
//     bindings::V8SetReturnValue(info, return_value, blink_receiver);
// }

void HardwareConcurrencyAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WorkerNavigator_hardwareConcurrency_Getter");
    BLINK_BINDINGS_TRACE_EVENT("WorkerNavigator.hardwareConcurrency.get");
    // [HighEntropy]
    const Dactyloscoper::HighEntropyTracer high_entropy_tracer("WorkerNavigator.hardwareConcurrency.get", info);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kNavigatorHardwareConcurrency);

    v8::Local<v8::Object> v8_receiver = info.This();
    WorkerNavigator* blink_receiver = V8WorkerNavigator::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->hardwareConcurrency();
    static_assert(bindings::IsReturnTypeCompatible<IDLUnsignedLongLong, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<uint64_t>());
    // [HighEntropy=Direct]
    Dactyloscoper::RecordDirectSurface(current_execution_context, WebFeature::kNavigatorHardwareConcurrency, return_value);
}

void DeviceMemoryAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WorkerNavigator_deviceMemory_Getter");
    BLINK_BINDINGS_TRACE_EVENT("WorkerNavigator.deviceMemory.get");
    // [HighEntropy]
    const Dactyloscoper::HighEntropyTracer high_entropy_tracer("WorkerNavigator.deviceMemory.get", info);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kNavigatorDeviceMemory);

    v8::Local<v8::Object> v8_receiver = info.This();
    WorkerNavigator* blink_receiver = V8WorkerNavigator::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->deviceMemory();
    static_assert(bindings::IsReturnTypeCompatible<IDLFloat, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<float>());
    // [HighEntropy=Direct]
    Dactyloscoper::RecordDirectSurface(current_execution_context, WebFeature::kNavigatorDeviceMemory, return_value);
}

void AppCodeNameAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WorkerNavigator_appCodeName_Getter");
    BLINK_BINDINGS_TRACE_EVENT("WorkerNavigator.appCodeName.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    WorkerNavigator* blink_receiver = V8WorkerNavigator::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->appCodeName();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void AppNameAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WorkerNavigator_appName_Getter");
    BLINK_BINDINGS_TRACE_EVENT("WorkerNavigator.appName.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    WorkerNavigator* blink_receiver = V8WorkerNavigator::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->appName();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void AppVersionAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WorkerNavigator_appVersion_Getter");
    BLINK_BINDINGS_TRACE_EVENT("WorkerNavigator.appVersion.get");
    // [HighEntropy]
    const Dactyloscoper::HighEntropyTracer high_entropy_tracer("WorkerNavigator.appVersion.get", info);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kNavigatorAppVersion);

    v8::Local<v8::Object> v8_receiver = info.This();
    WorkerNavigator* blink_receiver = V8WorkerNavigator::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->appVersion();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
    // [HighEntropy=Direct]
    Dactyloscoper::RecordDirectSurface(current_execution_context, WebFeature::kNavigatorAppVersion, return_value);
}

void PlatformAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WorkerNavigator_platform_Getter");
    BLINK_BINDINGS_TRACE_EVENT("WorkerNavigator.platform.get");
    // [HighEntropy]
    const Dactyloscoper::HighEntropyTracer high_entropy_tracer("WorkerNavigator.platform.get", info);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kNavigatorPlatform);

    v8::Local<v8::Object> v8_receiver = info.This();
    WorkerNavigator* blink_receiver = V8WorkerNavigator::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->platform();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
    // [HighEntropy=Direct]
    Dactyloscoper::RecordDirectSurface(current_execution_context, WebFeature::kNavigatorPlatform, return_value);
}

void ProductAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WorkerNavigator_product_Getter");
    BLINK_BINDINGS_TRACE_EVENT("WorkerNavigator.product.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    WorkerNavigator* blink_receiver = V8WorkerNavigator::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->product();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void UserAgentAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WorkerNavigator_userAgent_Getter");
    BLINK_BINDINGS_TRACE_EVENT("WorkerNavigator.userAgent.get");
    // [HighEntropy]
    const Dactyloscoper::HighEntropyTracer high_entropy_tracer("WorkerNavigator.userAgent.get", info);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kNavigatorUserAgent);

    v8::Local<v8::Object> v8_receiver = info.This();
    WorkerNavigator* blink_receiver = V8WorkerNavigator::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->userAgent();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
    // [HighEntropy=Direct]
    Dactyloscoper::RecordDirectSurface(current_execution_context, WebFeature::kNavigatorUserAgent, return_value);
}

void LanguageAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WorkerNavigator_language_Getter");
    BLINK_BINDINGS_TRACE_EVENT("WorkerNavigator.language.get");
    // [HighEntropy]
    const Dactyloscoper::HighEntropyTracer high_entropy_tracer("WorkerNavigator.language.get", info);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kNavigatorLanguage);

    v8::Local<v8::Object> v8_receiver = info.This();
    WorkerNavigator* blink_receiver = V8WorkerNavigator::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->language();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
    // [HighEntropy=Direct]
    Dactyloscoper::RecordDirectSurface(current_execution_context, WebFeature::kNavigatorLanguage, return_value);
}

void LanguagesAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WorkerNavigator_languages_Getter");
    BLINK_BINDINGS_TRACE_EVENT("WorkerNavigator.languages.get");
    // [HighEntropy]
    const Dactyloscoper::HighEntropyTracer high_entropy_tracer("WorkerNavigator.languages.get", info);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kNavigatorLanguages);

    v8::Local<v8::Object> v8_receiver = info.This();
    WorkerNavigator* blink_receiver = V8WorkerNavigator::ToWrappableUnsafe(isolate, v8_receiver);
    // [CachedAttribute]
    static const V8PrivateProperty::SymbolKey kPrivatePropertyCachedAttribute;
    auto&& v8_private_cached_attribute = V8PrivateProperty::GetSymbol(isolate, kPrivatePropertyCachedAttribute);
    if (!blink_receiver->IsLanguagesDirty()) {
        v8::Local<v8::Value> v8_value;
        if (!v8_private_cached_attribute.GetOrUndefined(v8_receiver).ToLocal(&v8_value)) {
            return;
        }
        if (!v8_value->IsUndefined()) {
            bindings::V8SetReturnValue(info, v8_value);
            return;
        }
    }

    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    auto&& return_value = blink_receiver->languages();
    static_assert(bindings::IsReturnTypeCompatible<IDLArray<IDLString>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    v8::Local<v8::Value> v8_return_value = ToV8Traits<IDLArray<IDLString>>::ToV8(script_state, return_value);
    bindings::V8SetReturnValue(info, v8_return_value);
    // [HighEntropy=Direct]
    Dactyloscoper::RecordDirectSurface(current_execution_context, WebFeature::kNavigatorLanguages, return_value);
    // [CachedAttribute]
    v8_private_cached_attribute.Set(v8_receiver, info.GetReturnValue().Get());
}

void OnLineAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WorkerNavigator_onLine_Getter");
    BLINK_BINDINGS_TRACE_EVENT("WorkerNavigator.onLine.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    WorkerNavigator* blink_receiver = V8WorkerNavigator::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onLine();
    static_assert(bindings::IsReturnTypeCompatible<IDLBoolean, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void UserAgentDataAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WorkerNavigator_userAgentData_Getter");
    BLINK_BINDINGS_TRACE_EVENT("WorkerNavigator.userAgentData.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    WorkerNavigator* blink_receiver = V8WorkerNavigator::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->userAgentData();
    static_assert(bindings::IsReturnTypeCompatible<NavigatorUAData, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

// void ClearAppBadgeOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
// {
//     RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WorkerNavigator_clearAppBadge");
//     BLINK_BINDINGS_TRACE_EVENT("WorkerNavigator.clearAppBadge");
//     // Promise returning function: Convert a TypeError to a reject promise.
//     ExceptionToRejectPromiseScope reject_promise_scope(info);
// 
//     v8::Isolate* isolate = info.GetIsolate();
//     v8::Local<v8::Object> v8_receiver = info.This();
//     if (!V8WorkerNavigator::HasInstance(isolate, v8_receiver)) {
//         V8ThrowException::ThrowTypeError(isolate, "Illegal invocation");
//         return;
//     }
// 
//     v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
//     ScriptState* current_script_state = ScriptState::From(isolate, current_context);
//     ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
//     // [Measure], [MeasureAs]
//     UseCounter::Count(current_execution_context, WebFeature::kBadgeClear);
// 
//     ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
//     ScriptState* script_state = receiver_script_state;
//     WorkerNavigator* blink_receiver = V8WorkerNavigator::ToWrappableUnsafe(isolate, v8_receiver);
//     const v8::ExceptionContext exception_context_type = v8::ExceptionContext::kOperation;
//     const char* const class_like_name = "WorkerNavigator";
//     const char* const property_name = "clearAppBadge";
//     ExceptionState exception_state(isolate, exception_context_type, class_like_name, property_name);
//     ScriptPromise<IDLUndefined> return_value = NavigatorBadge::clearAppBadge(script_state, *blink_receiver, exception_state);
//     if (exception_state.HadException()) [[unlikely]] {
//         return;
//     }
//     bindings::V8SetReturnValue(info, return_value);
// }
// 
// void SetAppBadgeOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
// {
//     RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WorkerNavigator_setAppBadge");
//     BLINK_BINDINGS_TRACE_EVENT("WorkerNavigator.setAppBadge");
//     // Promise returning function: Convert a TypeError to a reject promise.
//     ExceptionToRejectPromiseScope reject_promise_scope(info);
// 
//     v8::Isolate* isolate = info.GetIsolate();
//     v8::Local<v8::Object> v8_receiver = info.This();
//     if (!V8WorkerNavigator::HasInstance(isolate, v8_receiver)) {
//         V8ThrowException::ThrowTypeError(isolate, "Illegal invocation");
//         return;
//     }
// 
//     v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
//     ScriptState* current_script_state = ScriptState::From(isolate, current_context);
//     ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
//     // [Measure], [MeasureAs]
//     UseCounter::Count(current_execution_context, WebFeature::kBadgeSet);
// 
//     ScriptPromise<IDLUndefined> return_value;
//     const v8::ExceptionContext exception_context_type = v8::ExceptionContext::kOperation;
//     const char* const class_like_name = "WorkerNavigator";
//     const char* const property_name = "setAppBadge";
//     ExceptionState exception_state(isolate, exception_context_type, class_like_name, property_name);
//     do { // Dummy loop for use of 'break'.
//         const int non_undefined_argument_length = bindings::NonUndefinedArgumentLength(info);
//         ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
//         ScriptState* script_state = receiver_script_state;
//         WorkerNavigator* blink_receiver = V8WorkerNavigator::ToWrappableUnsafe(isolate, v8_receiver);
//         if (non_undefined_argument_length <= 0) {
//             return_value = NavigatorBadge::setAppBadge(script_state, *blink_receiver, exception_state);
//             break;
//         }
//         auto&& arg1_contents = NativeValueTraits<IDLUnsignedLongLongEnforceRange>::ArgumentValue(isolate, 0, info[0], exception_state);
//         if (exception_state.HadException()) [[unlikely]] {
//             return;
//         }
//         return_value = NavigatorBadge::setAppBadge(script_state, *blink_receiver, arg1_contents, exception_state);
//     } while (false);
//     if (exception_state.HadException()) [[unlikely]] {
//         return;
//     }
//     bindings::V8SetReturnValue(info, return_value);
// }

} // namespace v8_worker_navigator

using namespace v8_worker_navigator;

} // namespace

void V8WorkerNavigator::Impl::InstallInterfaceTemplate(v8::Isolate* isolate, const DOMWrapperWorld& world, v8::Local<v8::Template> interface_template)
{
    const WrapperTypeInfo* const wrapper_type_info = V8WorkerNavigator::GetWrapperTypeInfo();
    v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
    v8::Local<v8::ObjectTemplate> instance_object_template = interface_function_template->InstanceTemplate();
    v8::Local<v8::ObjectTemplate> prototype_object_template = interface_function_template->PrototypeTemplate();
    v8::Local<v8::FunctionTemplate> parent_interface_template;
    bindings::SetupIDLInterfaceTemplate(
        isolate, wrapper_type_info, instance_object_template, prototype_object_template, interface_function_template, parent_interface_template);

    v8::Local<v8::Template> instance_template = instance_object_template;
    v8::Local<v8::Template> prototype_template = prototype_object_template;
    InstallUnconditionalProperties(isolate, world, instance_template, prototype_template, interface_template);
}

void V8WorkerNavigator::Impl::InstallUnconditionalProperties(v8::Isolate* isolate, const DOMWrapperWorld& world, v8::Local<v8::Template> instance_template,
    v8::Local<v8::Template> prototype_template, v8::Local<v8::Template> interface_template)
{
    using bindings::IDLMemberInstaller;

    {
        static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
            { "hardwareConcurrency", "WorkerNavigator", HardwareConcurrencyAttributeGetCallback, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "appCodeName", "WorkerNavigator", AppCodeNameAttributeGetCallback, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "appName", "WorkerNavigator", AppNameAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "appVersion", "WorkerNavigator", AppVersionAttributeGetCallback, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "platform", "WorkerNavigator", PlatformAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "product", "WorkerNavigator", ProductAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "userAgent", "WorkerNavigator", UserAgentAttributeGetCallback, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "language", "WorkerNavigator", LanguageAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "languages", "WorkerNavigator", LanguagesAttributeGetCallback, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onLine", "WorkerNavigator", OnLineAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone) },
        };
        v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
        v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
        IDLMemberInstaller::InstallAttributes(isolate, world, instance_template, prototype_template, interface_template, signature, kAttributeTable);
    }
}

void V8WorkerNavigator::Impl::InstallContextDependentProperties(v8::Local<v8::Context> context, const DOMWrapperWorld& world,
    v8::Local<v8::Object> instance_object, v8::Local<v8::Object> prototype_object, v8::Local<v8::Object> interface_object,
    v8::Local<v8::Template> interface_template, FeatureSelector feature_selector)
{
    using bindings::IDLMemberInstaller;

    v8::Isolate* isolate = context->GetIsolate();
    ScriptState* script_state = ScriptState::From(isolate, context);
    ExecutionContext* execution_context = ToExecutionContext(script_state);
    const bool is_in_secure_context = execution_context->IsSecureContext();
//     if (is_in_secure_context && (feature_selector.IsAll() && RuntimeEnabledFeatures::StorageBucketsEnabled())) {
//         static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
//             { "storageBuckets", "WorkerNavigator", StorageBucketsAttributeGetCallback, nullptr, unsigned(v8::None),
//                 unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
//                 unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
//                 unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
//                 unsigned(V8PrivateProperty::CachedAccessor::kNone) },
//         };
//         v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
//         v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
//         IDLMemberInstaller::InstallAttributes(isolate, world, instance_object, prototype_object, interface_object, signature, kAttributeTable);
//     }
//     if (is_in_secure_context
//         && (feature_selector.IsAll()
//             && ((execution_context->IsServiceWorkerGlobalScope() && RuntimeEnabledFeatures::WebHIDOnServiceWorkersEnabled())
//                 || (execution_context->IsDedicatedWorkerGlobalScope() && RuntimeEnabledFeatures::WebHIDOnDedicatedWorkersEnabled()))
//             && RuntimeEnabledFeatures::WebHIDEnabled())) {
//         static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
//             { "hid", "WorkerNavigator", HidAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
//                 unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
//                 unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
//                 unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone) },
//         };
//         v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
//         v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
//         IDLMemberInstaller::InstallAttributes(isolate, world, instance_object, prototype_object, interface_object, signature, kAttributeTable);
//     }
//     if (is_in_secure_context && execution_context->IsWorkerGlobalScope() && feature_selector.IsAll()) {
//         static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
//             { "locks", "WorkerNavigator", LocksAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
//                 unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
//                 unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
//                 unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone) },
//             { "gpu", "WorkerNavigator", GpuAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
//                 unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
//                 unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
//                 unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone) },
//         };
//         v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
//         v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
//         IDLMemberInstaller::InstallAttributes(isolate, world, instance_object, prototype_object, interface_object, signature, kAttributeTable);
//     }
//     if (execution_context->IsWorkerGlobalScope() && feature_selector.IsAll()) {
//         static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
//             { "mediaCapabilities", "WorkerNavigator", MediaCapabilitiesAttributeGetCallback, nullptr, unsigned(v8::None),
//                 unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
//                 unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
//                 unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
//                 unsigned(V8PrivateProperty::CachedAccessor::kNone) },
//             { "connection", "WorkerNavigator", ConnectionAttributeGetCallback, nullptr, unsigned(v8::None),
//                 unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
//                 unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
//                 unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
//                 unsigned(V8PrivateProperty::CachedAccessor::kNone) },
//         };
//         v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
//         v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
//         IDLMemberInstaller::InstallAttributes(isolate, world, instance_object, prototype_object, interface_object, signature, kAttributeTable);
//     }
//     if (is_in_secure_context && execution_context->IsDedicatedWorkerGlobalScope()
//         && (feature_selector.IsAll() && RuntimeEnabledFeatures::MachineLearningNeuralNetworkEnabled())) {
//         static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
//             { "ml", "WorkerNavigator", MlAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
//                 unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
//                 unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
//                 unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone) },
//         };
//         v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
//         v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
//         IDLMemberInstaller::InstallAttributes(isolate, world, instance_object, prototype_object, interface_object, signature, kAttributeTable);
//     }
//     if (execution_context->IsWorkerGlobalScope() && (feature_selector.IsAll() && RuntimeEnabledFeatures::PermissionsEnabled())) {
//         static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
//             { "permissions", "WorkerNavigator", PermissionsAttributeGetCallback, nullptr, unsigned(v8::None),
//                 unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
//                 unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
//                 unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
//                 unsigned(V8PrivateProperty::CachedAccessor::kNone) },
//         };
//         v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
//         v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
//         IDLMemberInstaller::InstallAttributes(isolate, world, instance_object, prototype_object, interface_object, signature, kAttributeTable);
//     }
    if (is_in_secure_context && feature_selector.IsAll()) {
        static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
            { "storage", "WorkerNavigator", StorageAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "deviceMemory", "WorkerNavigator", DeviceMemoryAttributeGetCallback, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "userAgentData", "WorkerNavigator", UserAgentDataAttributeGetCallback, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
        };
        v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
        v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
        IDLMemberInstaller::InstallAttributes(isolate, world, instance_object, prototype_object, interface_object, signature, kAttributeTable);
    }
//     if (is_in_secure_context && execution_context->IsDedicatedWorkerGlobalScope()
//         && (feature_selector.IsAll() && RuntimeEnabledFeatures::SystemWakeLockEnabled())) {
//         static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
//             { "wakeLock", "WorkerNavigator", WakeLockAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
//                 unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
//                 unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
//                 unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone) },
//         };
//         v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
//         v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
//         IDLMemberInstaller::InstallAttributes(isolate, world, instance_object, prototype_object, interface_object, signature, kAttributeTable);
//     }
//     if (is_in_secure_context
//         && (feature_selector.IsAll()
//             && ((execution_context->IsDedicatedWorkerGlobalScope() && RuntimeEnabledFeatures::WebUSBOnDedicatedWorkersEnabled())
//                 || (execution_context->IsServiceWorkerGlobalScope() && RuntimeEnabledFeatures::WebUSBOnServiceWorkersEnabled())))) {
//         static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
//             { "usb", "WorkerNavigator", UsbAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
//                 unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
//                 unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
//                 unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone) },
//         };
//         v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
//         v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
//         IDLMemberInstaller::InstallAttributes(isolate, world, instance_object, prototype_object, interface_object, signature, kAttributeTable);
//     }
//     if (is_in_secure_context && execution_context->IsDedicatedWorkerGlobalScope() && (feature_selector.IsAll() && RuntimeEnabledFeatures::SerialEnabled())) {
//         static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
//             { "serial", "WorkerNavigator", SerialAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
//                 unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
//                 unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
//                 unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone) },
//         };
//         v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
//         v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
//         IDLMemberInstaller::InstallAttributes(isolate, world, instance_object, prototype_object, interface_object, signature, kAttributeTable);
//     }
// 
//     if (is_in_secure_context && execution_context->IsServiceWorkerGlobalScope() && feature_selector.IsAll()) {
//         static const IDLMemberInstaller::OperationConfig kOperationTable[] = {
//             { "clearAppBadge", "WorkerNavigator", ClearAppBadgeOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
//                 unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kDoNotCheck),
//                 unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
//             { "setAppBadge", "WorkerNavigator", SetAppBadgeOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
//                 unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kDoNotCheck),
//                 unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
//         };
//         v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
//         v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
//         IDLMemberInstaller::InstallOperations(isolate, world, instance_object, prototype_object, interface_object, signature, kOperationTable);
//     }
}

} // namespace blink
