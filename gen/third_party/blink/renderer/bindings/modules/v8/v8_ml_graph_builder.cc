// Copyright 2019 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// DO NOT EDIT: This file is auto-generated by
// //third_party/blink/renderer/bindings/scripts/generate_bindings.py
//
// Use the GN flag `blink_enable_generated_code_formatting=true` to enable
// formatting of the generated files.

#include "third_party/blink/renderer/bindings/modules/v8/v8_ml_graph_builder.h"

#include "third_party/blink/public/mojom/origin_trials/origin_trial_feature.mojom-shared.h"
#include "third_party/blink/renderer/bindings/core/v8/generated_code_helper.h"
#include "third_party/blink/renderer/bindings/core/v8/is_return_type_compatible.h"
#include "third_party/blink/renderer/bindings/core/v8/native_value_traits_impl.h"
#include "third_party/blink/renderer/bindings/core/v8/to_v8_traits.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_set_return_value_for_core.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_ml_arg_min_max_options.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_ml_batch_normalization_options.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_ml_clamp_options.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_ml_context.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_ml_conv_2d_options.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_ml_conv_transpose_2d_options.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_ml_cumulative_sum_options.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_ml_elu_options.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_ml_gather_options.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_ml_gemm_options.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_ml_graph.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_ml_gru_cell_options.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_ml_gru_options.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_ml_hard_sigmoid_options.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_ml_instance_normalization_options.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_ml_layer_normalization_options.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_ml_leaky_relu_options.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_ml_linear_options.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_ml_lstm_cell_options.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_ml_lstm_options.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_ml_operand.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_ml_operand_data_type.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_ml_operand_descriptor.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_ml_operator_options.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_ml_pad_options.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_ml_pool_2d_options.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_ml_reduce_options.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_ml_resample_2d_options.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_ml_scatter_options.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_ml_slice_options.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_ml_split_options.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_ml_transpose_options.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_ml_triangular_options.h"
#include "third_party/blink/renderer/core/execution_context/execution_context.h"
#include "third_party/blink/renderer/modules/ml/ml_context.h"
#include "third_party/blink/renderer/modules/ml/webnn/ml_graph.h"
#include "third_party/blink/renderer/modules/ml/webnn/ml_graph_builder.h"
#include "third_party/blink/renderer/modules/ml/webnn/ml_operand.h"
#include "third_party/blink/renderer/platform/bindings/cooperative_scheduling_helpers.h"
#include "third_party/blink/renderer/platform/bindings/exception_messages.h"
#include "third_party/blink/renderer/platform/bindings/idl_member_installer.h"
#include "third_party/blink/renderer/platform/bindings/runtime_call_stats.h"
#include "third_party/blink/renderer/platform/bindings/v8_binding.h"
#include "third_party/blink/renderer/platform/bindings/v8_object_constructor.h"
#include "third_party/blink/renderer/platform/bindings/wrapper_type_info.h"

namespace blink {

bool V8MLGraphBuilder::IsExposed(ExecutionContext* execution_context)
{

    return (execution_context->IsWindow() || execution_context->IsDedicatedWorkerGlobalScope())
        && RuntimeEnabledFeatures::MachineLearningNeuralNetworkEnabled();
}

// Construction of WrapperTypeInfo may require non-trivial initialization due
// to cross-component address resolution in order to load the pointer to the
// parent interface's WrapperTypeInfo.  We ignore this issue because the issue
// happens only on component builds and the official release builds
// (statically-linked builds) are never affected by this issue.
#if defined(COMPONENT_BUILD) && defined(WIN32) && defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wglobal-constructors"
#endif

const WrapperTypeInfo V8MLGraphBuilder::wrapper_type_info_ {
    gin::kEmbedderBlink,
    V8MLGraphBuilder::InstallInterfaceTemplate,
    nullptr,
    "MLGraphBuilder",
    nullptr,
    V8MLGraphBuilder::kThisTag,
    V8MLGraphBuilder::kMaxSubclassTag,
    WrapperTypeInfo::kWrapperTypeObjectPrototype,
    WrapperTypeInfo::kObjectClassId,
    WrapperTypeInfo::kNotInheritFromActiveScriptWrappable,
    WrapperTypeInfo::kIdlInterface,
    false,
};

#if defined(COMPONENT_BUILD) && defined(WIN32) && defined(__clang__)
#pragma clang diagnostic pop
#endif

const WrapperTypeInfo& MLGraphBuilder::wrapper_type_info_ = V8MLGraphBuilder::wrapper_type_info_;

// non-[ActiveScriptWrappable]
static_assert(!std::is_base_of<ActiveScriptWrappableBase, MLGraphBuilder>::value,
    "MLGraphBuilder inherits from ActiveScriptWrappable<> without "
    "[ActiveScriptWrappable] extended attribute.");

namespace {

namespace v8_ml_graph_builder {

void ConstructorCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_constructor");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.constructor");

    v8::Isolate* isolate = info.GetIsolate();
    if (!info.IsConstructCall()) {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::ConstructorCalledAsFunction());
        return;
    }
    v8::Local<v8::Object> v8_receiver = info.This();
    if (ConstructorMode::Current(isolate) == ConstructorMode::kWrapExistingObject) {
        bindings::V8SetReturnValue(info, v8_receiver);
        return;
    }

    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ScriptState* script_state = current_script_state;
    ExceptionState exception_state(isolate);
    auto&& arg1_context = NativeValueTraits<MLContext>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = MLGraphBuilder::Create(script_state, arg1_context, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLGraphBuilder, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    v8::Local<v8::Object> v8_wrapper = return_value->AssociateWithWrapper(isolate, V8MLGraphBuilder::GetWrapperTypeInfo(), v8_receiver);
    bindings::V8SetReturnValue(info, v8_wrapper);
}

void AbsOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_abs");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.abs");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_x = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLOperatorOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg2_options;
    if (info[1]->IsUndefined()) {
        arg2_options = MLOperatorOptions::Create();
    } else {
        arg2_options = NativeValueTraits<MLOperatorOptions>::ArgumentValue(isolate, 1, info[1], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->abs(arg1_x, arg2_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void AddOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_add");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.add");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_a = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_b = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLOperatorOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg3_options;
    if (info[2]->IsUndefined()) {
        arg3_options = MLOperatorOptions::Create();
    } else {
        arg3_options = NativeValueTraits<MLOperatorOptions>::ArgumentValue(isolate, 2, info[2], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->add(arg1_a, arg2_b, arg3_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void ArgMaxOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_argMax");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.argMax");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_input = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_axis = NativeValueTraits<IDLUnsignedLongEnforceRange>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLArgMinMaxOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg3_options;
    if (info[2]->IsUndefined()) {
        arg3_options = MLArgMinMaxOptions::Create();
    } else {
        arg3_options = NativeValueTraits<MLArgMinMaxOptions>::ArgumentValue(isolate, 2, info[2], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->argMax(arg1_input, arg2_axis, arg3_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void ArgMinOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_argMin");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.argMin");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_input = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_axis = NativeValueTraits<IDLUnsignedLongEnforceRange>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLArgMinMaxOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg3_options;
    if (info[2]->IsUndefined()) {
        arg3_options = MLArgMinMaxOptions::Create();
    } else {
        arg3_options = NativeValueTraits<MLArgMinMaxOptions>::ArgumentValue(isolate, 2, info[2], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->argMin(arg1_input, arg2_axis, arg3_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void AveragePool2dOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_averagePool2d");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.averagePool2d");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_input = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLPool2dOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg2_options;
    if (info[1]->IsUndefined()) {
        arg2_options = MLPool2dOptions::Create();
    } else {
        arg2_options = NativeValueTraits<MLPool2dOptions>::ArgumentValue(isolate, 1, info[1], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->averagePool2d(arg1_input, arg2_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void BatchNormalizationOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_batchNormalization");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.batchNormalization");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 3) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(3, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_input = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_mean = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_variance = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLBatchNormalizationOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg4_options;
    if (info[3]->IsUndefined()) {
        arg4_options = MLBatchNormalizationOptions::Create();
    } else {
        arg4_options = NativeValueTraits<MLBatchNormalizationOptions>::ArgumentValue(isolate, 3, info[3], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->batchNormalization(arg1_input, arg2_mean, arg3_variance, arg4_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void BuildOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_build");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.build");
    // Promise returning function: Convert a TypeError to a reject promise.
    ExceptionToRejectPromiseScope reject_promise_scope(info);

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    if (!V8MLGraphBuilder::HasInstance(isolate, v8_receiver)) {
        V8ThrowException::ThrowTypeError(isolate, "Illegal invocation");
        return;
    }

    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    const v8::ExceptionContext exception_context_type = v8::ExceptionContext::kOperation;
    const char* const class_like_name = "MLGraphBuilder";
    const char* const property_name = "build";
    ExceptionState exception_state(isolate, exception_context_type, class_like_name, property_name);
    auto&& arg1_outputs = NativeValueTraits<IDLRecord<IDLUSVString, MLOperand>>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    ScriptPromise<MLGraph> return_value = blink_receiver->build(script_state, arg1_outputs, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value);
}

void CastOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_cast");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.cast");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_input = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_output_data_type = NativeValueTraits<V8MLOperandDataType>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLOperatorOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg3_options;
    if (info[2]->IsUndefined()) {
        arg3_options = MLOperatorOptions::Create();
    } else {
        arg3_options = NativeValueTraits<MLOperatorOptions>::ArgumentValue(isolate, 2, info[2], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->cast(arg1_input, arg2_output_data_type, arg3_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void CeilOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_ceil");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.ceil");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_x = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLOperatorOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg2_options;
    if (info[1]->IsUndefined()) {
        arg2_options = MLOperatorOptions::Create();
    } else {
        arg2_options = NativeValueTraits<MLOperatorOptions>::ArgumentValue(isolate, 1, info[1], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->ceil(arg1_x, arg2_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void ClampOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_clamp");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.clamp");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_input = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLClampOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg2_options;
    if (info[1]->IsUndefined()) {
        arg2_options = MLClampOptions::Create();
    } else {
        arg2_options = NativeValueTraits<MLClampOptions>::ArgumentValue(isolate, 1, info[1], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->clamp(arg1_input, arg2_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void ConcatOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_concat");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.concat");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_inputs = NativeValueTraits<IDLSequence<MLOperand>>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_axis = NativeValueTraits<IDLUnsignedLongEnforceRange>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLOperatorOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg3_options;
    if (info[2]->IsUndefined()) {
        arg3_options = MLOperatorOptions::Create();
    } else {
        arg3_options = NativeValueTraits<MLOperatorOptions>::ArgumentValue(isolate, 2, info[2], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->concat(std::move(arg1_inputs), arg2_axis, arg3_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void ConstantOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_constant");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.constant");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    ExceptionState exception_state(isolate);
    auto&& arg1_desc = NativeValueTraits<MLOperandDescriptor>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_buffer_view = NativeValueTraits<NotShared<DOMArrayBufferView>>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->constant(script_state, arg1_desc, arg2_buffer_view, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void Conv2dOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_conv2d");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.conv2d");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_input = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_filter = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLConv2dOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg3_options;
    if (info[2]->IsUndefined()) {
        arg3_options = MLConv2dOptions::Create();
    } else {
        arg3_options = NativeValueTraits<MLConv2dOptions>::ArgumentValue(isolate, 2, info[2], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->conv2d(arg1_input, arg2_filter, arg3_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void ConvTranspose2dOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_convTranspose2d");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.convTranspose2d");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_input = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_filter = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLConvTranspose2dOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg3_options;
    if (info[2]->IsUndefined()) {
        arg3_options = MLConvTranspose2dOptions::Create();
    } else {
        arg3_options = NativeValueTraits<MLConvTranspose2dOptions>::ArgumentValue(isolate, 2, info[2], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->convTranspose2d(arg1_input, arg2_filter, arg3_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void CosOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_cos");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.cos");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_x = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLOperatorOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg2_options;
    if (info[1]->IsUndefined()) {
        arg2_options = MLOperatorOptions::Create();
    } else {
        arg2_options = NativeValueTraits<MLOperatorOptions>::ArgumentValue(isolate, 1, info[1], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->cos(arg1_x, arg2_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void CumulativeSumOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_cumulativeSum");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.cumulativeSum");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_input = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_axis = NativeValueTraits<IDLUnsignedLongEnforceRange>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLCumulativeSumOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg3_options;
    if (info[2]->IsUndefined()) {
        arg3_options = MLCumulativeSumOptions::Create();
    } else {
        arg3_options = NativeValueTraits<MLCumulativeSumOptions>::ArgumentValue(isolate, 2, info[2], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->cumulativeSum(arg1_input, arg2_axis, arg3_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void DequantizeLinearOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_dequantizeLinear");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.dequantizeLinear");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 3) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(3, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_input = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_scale = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_zero_point = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLOperatorOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg4_options;
    if (info[3]->IsUndefined()) {
        arg4_options = MLOperatorOptions::Create();
    } else {
        arg4_options = NativeValueTraits<MLOperatorOptions>::ArgumentValue(isolate, 3, info[3], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->dequantizeLinear(arg1_input, arg2_scale, arg3_zero_point, arg4_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void DivOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_div");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.div");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_a = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_b = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLOperatorOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg3_options;
    if (info[2]->IsUndefined()) {
        arg3_options = MLOperatorOptions::Create();
    } else {
        arg3_options = NativeValueTraits<MLOperatorOptions>::ArgumentValue(isolate, 2, info[2], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->div(arg1_a, arg2_b, arg3_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void EluOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_elu");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.elu");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_x = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLEluOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg2_options;
    if (info[1]->IsUndefined()) {
        arg2_options = MLEluOptions::Create();
    } else {
        arg2_options = NativeValueTraits<MLEluOptions>::ArgumentValue(isolate, 1, info[1], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->elu(arg1_x, arg2_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void EqualOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_equal");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.equal");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_a = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_b = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLOperatorOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg3_options;
    if (info[2]->IsUndefined()) {
        arg3_options = MLOperatorOptions::Create();
    } else {
        arg3_options = NativeValueTraits<MLOperatorOptions>::ArgumentValue(isolate, 2, info[2], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->equal(arg1_a, arg2_b, arg3_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void ErfOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_erf");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.erf");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_x = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLOperatorOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg2_options;
    if (info[1]->IsUndefined()) {
        arg2_options = MLOperatorOptions::Create();
    } else {
        arg2_options = NativeValueTraits<MLOperatorOptions>::ArgumentValue(isolate, 1, info[1], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->erf(arg1_x, arg2_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void ExpOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_exp");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.exp");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_x = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLOperatorOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg2_options;
    if (info[1]->IsUndefined()) {
        arg2_options = MLOperatorOptions::Create();
    } else {
        arg2_options = NativeValueTraits<MLOperatorOptions>::ArgumentValue(isolate, 1, info[1], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->exp(arg1_x, arg2_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void ExpandOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_expand");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.expand");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_input = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_new_shape = NativeValueTraits<IDLSequence<IDLUnsignedLongEnforceRange>>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLOperatorOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg3_options;
    if (info[2]->IsUndefined()) {
        arg3_options = MLOperatorOptions::Create();
    } else {
        arg3_options = NativeValueTraits<MLOperatorOptions>::ArgumentValue(isolate, 2, info[2], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->expand(arg1_input, std::move(arg2_new_shape), arg3_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void FloorOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_floor");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.floor");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_x = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLOperatorOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg2_options;
    if (info[1]->IsUndefined()) {
        arg2_options = MLOperatorOptions::Create();
    } else {
        arg2_options = NativeValueTraits<MLOperatorOptions>::ArgumentValue(isolate, 1, info[1], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->floor(arg1_x, arg2_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void GatherOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_gather");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.gather");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_input = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_indices = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLGatherOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg3_options;
    if (info[2]->IsUndefined()) {
        arg3_options = MLGatherOptions::Create();
    } else {
        arg3_options = NativeValueTraits<MLGatherOptions>::ArgumentValue(isolate, 2, info[2], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->gather(arg1_input, arg2_indices, arg3_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void GatherElementsOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_gatherElements");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.gatherElements");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_input = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_indices = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLGatherOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg3_options;
    if (info[2]->IsUndefined()) {
        arg3_options = MLGatherOptions::Create();
    } else {
        arg3_options = NativeValueTraits<MLGatherOptions>::ArgumentValue(isolate, 2, info[2], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->gatherElements(arg1_input, arg2_indices, arg3_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void GatherNDOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_gatherND");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.gatherND");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_input = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_indices = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLOperatorOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg3_options;
    if (info[2]->IsUndefined()) {
        arg3_options = MLOperatorOptions::Create();
    } else {
        arg3_options = NativeValueTraits<MLOperatorOptions>::ArgumentValue(isolate, 2, info[2], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->gatherND(arg1_input, arg2_indices, arg3_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void GeluOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_gelu");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.gelu");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_input = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLOperatorOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg2_options;
    if (info[1]->IsUndefined()) {
        arg2_options = MLOperatorOptions::Create();
    } else {
        arg2_options = NativeValueTraits<MLOperatorOptions>::ArgumentValue(isolate, 1, info[1], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->gelu(arg1_input, arg2_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void GemmOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_gemm");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.gemm");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_a = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_b = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLGemmOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg3_options;
    if (info[2]->IsUndefined()) {
        arg3_options = MLGemmOptions::Create();
    } else {
        arg3_options = NativeValueTraits<MLGemmOptions>::ArgumentValue(isolate, 2, info[2], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->gemm(arg1_a, arg2_b, arg3_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void GreaterOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_greater");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.greater");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_a = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_b = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLOperatorOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg3_options;
    if (info[2]->IsUndefined()) {
        arg3_options = MLOperatorOptions::Create();
    } else {
        arg3_options = NativeValueTraits<MLOperatorOptions>::ArgumentValue(isolate, 2, info[2], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->greater(arg1_a, arg2_b, arg3_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void GreaterOrEqualOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_greaterOrEqual");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.greaterOrEqual");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_a = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_b = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLOperatorOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg3_options;
    if (info[2]->IsUndefined()) {
        arg3_options = MLOperatorOptions::Create();
    } else {
        arg3_options = NativeValueTraits<MLOperatorOptions>::ArgumentValue(isolate, 2, info[2], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->greaterOrEqual(arg1_a, arg2_b, arg3_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void GruOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_gru");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.gru");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 5) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(5, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_input = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_weight = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_recurrent_weight = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg4_steps = NativeValueTraits<IDLUnsignedLongEnforceRange>::ArgumentValue(isolate, 3, info[3], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg5_hidden_size = NativeValueTraits<IDLUnsignedLongEnforceRange>::ArgumentValue(isolate, 4, info[4], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLGruOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg6_options;
    if (info[5]->IsUndefined()) {
        arg6_options = MLGruOptions::Create();
    } else {
        arg6_options = NativeValueTraits<MLGruOptions>::ArgumentValue(isolate, 5, info[5], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->gru(arg1_input, arg2_weight, arg3_recurrent_weight, arg4_steps, arg5_hidden_size, arg6_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<IDLSequence<MLOperand>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    v8::Local<v8::Value> v8_return_value = ToV8Traits<IDLSequence<MLOperand>>::ToV8(script_state, return_value);
    bindings::V8SetReturnValue(info, v8_return_value);
}

void GruCellOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_gruCell");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.gruCell");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 5) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(5, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_input = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_weight = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_recurrent_weight = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg4_hidden_state = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 3, info[3], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg5_hidden_size = NativeValueTraits<IDLUnsignedLongEnforceRange>::ArgumentValue(isolate, 4, info[4], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLGruCellOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg6_options;
    if (info[5]->IsUndefined()) {
        arg6_options = MLGruCellOptions::Create();
    } else {
        arg6_options = NativeValueTraits<MLGruCellOptions>::ArgumentValue(isolate, 5, info[5], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value
        = blink_receiver->gruCell(arg1_input, arg2_weight, arg3_recurrent_weight, arg4_hidden_state, arg5_hidden_size, arg6_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void HardSigmoidOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_hardSigmoid");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.hardSigmoid");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_x = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLHardSigmoidOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg2_options;
    if (info[1]->IsUndefined()) {
        arg2_options = MLHardSigmoidOptions::Create();
    } else {
        arg2_options = NativeValueTraits<MLHardSigmoidOptions>::ArgumentValue(isolate, 1, info[1], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->hardSigmoid(arg1_x, arg2_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void HardSwishOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_hardSwish");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.hardSwish");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_x = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLOperatorOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg2_options;
    if (info[1]->IsUndefined()) {
        arg2_options = MLOperatorOptions::Create();
    } else {
        arg2_options = NativeValueTraits<MLOperatorOptions>::ArgumentValue(isolate, 1, info[1], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->hardSwish(arg1_x, arg2_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void IdentityOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_identity");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.identity");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_x = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLOperatorOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg2_options;
    if (info[1]->IsUndefined()) {
        arg2_options = MLOperatorOptions::Create();
    } else {
        arg2_options = NativeValueTraits<MLOperatorOptions>::ArgumentValue(isolate, 1, info[1], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->identity(arg1_x, arg2_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void InputOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_input");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.input");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    ExceptionState exception_state(isolate);
    auto&& arg1_name = NativeValueTraits<IDLUSVString>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_desc = NativeValueTraits<MLOperandDescriptor>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& return_value = blink_receiver->input(script_state, arg1_name, arg2_desc, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void InstanceNormalizationOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_instanceNormalization");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.instanceNormalization");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_input = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLInstanceNormalizationOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg2_options;
    if (info[1]->IsUndefined()) {
        arg2_options = MLInstanceNormalizationOptions::Create();
    } else {
        arg2_options = NativeValueTraits<MLInstanceNormalizationOptions>::ArgumentValue(isolate, 1, info[1], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->instanceNormalization(arg1_input, arg2_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void L2Pool2dOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_l2Pool2d");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.l2Pool2d");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_input = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLPool2dOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg2_options;
    if (info[1]->IsUndefined()) {
        arg2_options = MLPool2dOptions::Create();
    } else {
        arg2_options = NativeValueTraits<MLPool2dOptions>::ArgumentValue(isolate, 1, info[1], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->l2Pool2d(arg1_input, arg2_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void LayerNormalizationOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_layerNormalization");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.layerNormalization");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_input = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLLayerNormalizationOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg2_options;
    if (info[1]->IsUndefined()) {
        arg2_options = MLLayerNormalizationOptions::Create();
    } else {
        arg2_options = NativeValueTraits<MLLayerNormalizationOptions>::ArgumentValue(isolate, 1, info[1], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->layerNormalization(arg1_input, arg2_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void LeakyReluOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_leakyRelu");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.leakyRelu");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_x = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLLeakyReluOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg2_options;
    if (info[1]->IsUndefined()) {
        arg2_options = MLLeakyReluOptions::Create();
    } else {
        arg2_options = NativeValueTraits<MLLeakyReluOptions>::ArgumentValue(isolate, 1, info[1], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->leakyRelu(arg1_x, arg2_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void LesserOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_lesser");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.lesser");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_a = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_b = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLOperatorOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg3_options;
    if (info[2]->IsUndefined()) {
        arg3_options = MLOperatorOptions::Create();
    } else {
        arg3_options = NativeValueTraits<MLOperatorOptions>::ArgumentValue(isolate, 2, info[2], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->lesser(arg1_a, arg2_b, arg3_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void LesserOrEqualOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_lesserOrEqual");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.lesserOrEqual");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_a = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_b = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLOperatorOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg3_options;
    if (info[2]->IsUndefined()) {
        arg3_options = MLOperatorOptions::Create();
    } else {
        arg3_options = NativeValueTraits<MLOperatorOptions>::ArgumentValue(isolate, 2, info[2], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->lesserOrEqual(arg1_a, arg2_b, arg3_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void LinearOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_linear");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.linear");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_input = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLLinearOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg2_options;
    if (info[1]->IsUndefined()) {
        arg2_options = MLLinearOptions::Create();
    } else {
        arg2_options = NativeValueTraits<MLLinearOptions>::ArgumentValue(isolate, 1, info[1], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->linear(arg1_input, arg2_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void LogOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_log");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.log");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_x = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLOperatorOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg2_options;
    if (info[1]->IsUndefined()) {
        arg2_options = MLOperatorOptions::Create();
    } else {
        arg2_options = NativeValueTraits<MLOperatorOptions>::ArgumentValue(isolate, 1, info[1], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->log(arg1_x, arg2_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void LogicalAndOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_logicalAnd");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.logicalAnd");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_a = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_b = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLOperatorOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg3_options;
    if (info[2]->IsUndefined()) {
        arg3_options = MLOperatorOptions::Create();
    } else {
        arg3_options = NativeValueTraits<MLOperatorOptions>::ArgumentValue(isolate, 2, info[2], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->logicalAnd(arg1_a, arg2_b, arg3_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void LogicalNotOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_logicalNot");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.logicalNot");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_x = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLOperatorOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg2_options;
    if (info[1]->IsUndefined()) {
        arg2_options = MLOperatorOptions::Create();
    } else {
        arg2_options = NativeValueTraits<MLOperatorOptions>::ArgumentValue(isolate, 1, info[1], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->logicalNot(arg1_x, arg2_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void LogicalOrOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_logicalOr");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.logicalOr");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_a = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_b = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLOperatorOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg3_options;
    if (info[2]->IsUndefined()) {
        arg3_options = MLOperatorOptions::Create();
    } else {
        arg3_options = NativeValueTraits<MLOperatorOptions>::ArgumentValue(isolate, 2, info[2], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->logicalOr(arg1_a, arg2_b, arg3_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void LogicalXorOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_logicalXor");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.logicalXor");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_a = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_b = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLOperatorOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg3_options;
    if (info[2]->IsUndefined()) {
        arg3_options = MLOperatorOptions::Create();
    } else {
        arg3_options = NativeValueTraits<MLOperatorOptions>::ArgumentValue(isolate, 2, info[2], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->logicalXor(arg1_a, arg2_b, arg3_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void LstmOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_lstm");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.lstm");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 5) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(5, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_input = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_weight = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_recurrent_weight = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg4_steps = NativeValueTraits<IDLUnsignedLongEnforceRange>::ArgumentValue(isolate, 3, info[3], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg5_hidden_size = NativeValueTraits<IDLUnsignedLongEnforceRange>::ArgumentValue(isolate, 4, info[4], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLLstmOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg6_options;
    if (info[5]->IsUndefined()) {
        arg6_options = MLLstmOptions::Create();
    } else {
        arg6_options = NativeValueTraits<MLLstmOptions>::ArgumentValue(isolate, 5, info[5], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->lstm(arg1_input, arg2_weight, arg3_recurrent_weight, arg4_steps, arg5_hidden_size, arg6_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<IDLSequence<MLOperand>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    v8::Local<v8::Value> v8_return_value = ToV8Traits<IDLSequence<MLOperand>>::ToV8(script_state, return_value);
    bindings::V8SetReturnValue(info, v8_return_value);
}

void LstmCellOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_lstmCell");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.lstmCell");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 6) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(6, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_input = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_weight = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_recurrent_weight = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg4_hidden_state = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 3, info[3], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg5_cell_state = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 4, info[4], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg6_hidden_size = NativeValueTraits<IDLUnsignedLongEnforceRange>::ArgumentValue(isolate, 5, info[5], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLLstmCellOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg7_options;
    if (info[6]->IsUndefined()) {
        arg7_options = MLLstmCellOptions::Create();
    } else {
        arg7_options = NativeValueTraits<MLLstmCellOptions>::ArgumentValue(isolate, 6, info[6], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->lstmCell(
        arg1_input, arg2_weight, arg3_recurrent_weight, arg4_hidden_state, arg5_cell_state, arg6_hidden_size, arg7_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<IDLSequence<MLOperand>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    v8::Local<v8::Value> v8_return_value = ToV8Traits<IDLSequence<MLOperand>>::ToV8(script_state, return_value);
    bindings::V8SetReturnValue(info, v8_return_value);
}

void MatmulOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_matmul");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.matmul");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_a = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_b = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLOperatorOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg3_options;
    if (info[2]->IsUndefined()) {
        arg3_options = MLOperatorOptions::Create();
    } else {
        arg3_options = NativeValueTraits<MLOperatorOptions>::ArgumentValue(isolate, 2, info[2], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->matmul(arg1_a, arg2_b, arg3_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void MaxOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_max");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.max");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_a = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_b = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLOperatorOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg3_options;
    if (info[2]->IsUndefined()) {
        arg3_options = MLOperatorOptions::Create();
    } else {
        arg3_options = NativeValueTraits<MLOperatorOptions>::ArgumentValue(isolate, 2, info[2], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->max(arg1_a, arg2_b, arg3_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void MaxPool2dOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_maxPool2d");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.maxPool2d");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_input = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLPool2dOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg2_options;
    if (info[1]->IsUndefined()) {
        arg2_options = MLPool2dOptions::Create();
    } else {
        arg2_options = NativeValueTraits<MLPool2dOptions>::ArgumentValue(isolate, 1, info[1], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->maxPool2d(arg1_input, arg2_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void MinOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_min");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.min");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_a = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_b = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLOperatorOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg3_options;
    if (info[2]->IsUndefined()) {
        arg3_options = MLOperatorOptions::Create();
    } else {
        arg3_options = NativeValueTraits<MLOperatorOptions>::ArgumentValue(isolate, 2, info[2], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->min(arg1_a, arg2_b, arg3_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void MulOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_mul");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.mul");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_a = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_b = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLOperatorOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg3_options;
    if (info[2]->IsUndefined()) {
        arg3_options = MLOperatorOptions::Create();
    } else {
        arg3_options = NativeValueTraits<MLOperatorOptions>::ArgumentValue(isolate, 2, info[2], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->mul(arg1_a, arg2_b, arg3_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void NegOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_neg");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.neg");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_x = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLOperatorOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg2_options;
    if (info[1]->IsUndefined()) {
        arg2_options = MLOperatorOptions::Create();
    } else {
        arg2_options = NativeValueTraits<MLOperatorOptions>::ArgumentValue(isolate, 1, info[1], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->neg(arg1_x, arg2_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void PadOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_pad");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.pad");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 3) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(3, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    ExceptionState exception_state(isolate);
    auto&& arg1_input = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_beginning_padding = NativeValueTraits<IDLSequence<IDLUnsignedLongEnforceRange>>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_ending_padding = NativeValueTraits<IDLSequence<IDLUnsignedLongEnforceRange>>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLPadOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg4_options;
    if (info[3]->IsUndefined()) {
        arg4_options = MLPadOptions::Create();
    } else {
        arg4_options = NativeValueTraits<MLPadOptions>::ArgumentValue(isolate, 3, info[3], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value
        = blink_receiver->pad(script_state, arg1_input, std::move(arg2_beginning_padding), std::move(arg3_ending_padding), arg4_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void PowOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_pow");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.pow");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_a = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_b = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLOperatorOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg3_options;
    if (info[2]->IsUndefined()) {
        arg3_options = MLOperatorOptions::Create();
    } else {
        arg3_options = NativeValueTraits<MLOperatorOptions>::ArgumentValue(isolate, 2, info[2], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->pow(arg1_a, arg2_b, arg3_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void PreluOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_prelu");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.prelu");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_x = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_slope = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLOperatorOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg3_options;
    if (info[2]->IsUndefined()) {
        arg3_options = MLOperatorOptions::Create();
    } else {
        arg3_options = NativeValueTraits<MLOperatorOptions>::ArgumentValue(isolate, 2, info[2], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->prelu(arg1_x, arg2_slope, arg3_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void QuantizeLinearOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_quantizeLinear");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.quantizeLinear");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 3) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(3, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_input = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_scale = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_zero_point = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLOperatorOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg4_options;
    if (info[3]->IsUndefined()) {
        arg4_options = MLOperatorOptions::Create();
    } else {
        arg4_options = NativeValueTraits<MLOperatorOptions>::ArgumentValue(isolate, 3, info[3], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->quantizeLinear(arg1_input, arg2_scale, arg3_zero_point, arg4_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void ReciprocalOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_reciprocal");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.reciprocal");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_x = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLOperatorOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg2_options;
    if (info[1]->IsUndefined()) {
        arg2_options = MLOperatorOptions::Create();
    } else {
        arg2_options = NativeValueTraits<MLOperatorOptions>::ArgumentValue(isolate, 1, info[1], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->reciprocal(arg1_x, arg2_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void ReduceL1OperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_reduceL1");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.reduceL1");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_input = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLReduceOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg2_options;
    if (info[1]->IsUndefined()) {
        arg2_options = MLReduceOptions::Create();
    } else {
        arg2_options = NativeValueTraits<MLReduceOptions>::ArgumentValue(isolate, 1, info[1], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->reduceL1(arg1_input, arg2_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void ReduceL2OperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_reduceL2");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.reduceL2");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_input = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLReduceOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg2_options;
    if (info[1]->IsUndefined()) {
        arg2_options = MLReduceOptions::Create();
    } else {
        arg2_options = NativeValueTraits<MLReduceOptions>::ArgumentValue(isolate, 1, info[1], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->reduceL2(arg1_input, arg2_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void ReduceLogSumOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_reduceLogSum");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.reduceLogSum");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_input = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLReduceOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg2_options;
    if (info[1]->IsUndefined()) {
        arg2_options = MLReduceOptions::Create();
    } else {
        arg2_options = NativeValueTraits<MLReduceOptions>::ArgumentValue(isolate, 1, info[1], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->reduceLogSum(arg1_input, arg2_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void ReduceLogSumExpOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_reduceLogSumExp");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.reduceLogSumExp");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_input = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLReduceOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg2_options;
    if (info[1]->IsUndefined()) {
        arg2_options = MLReduceOptions::Create();
    } else {
        arg2_options = NativeValueTraits<MLReduceOptions>::ArgumentValue(isolate, 1, info[1], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->reduceLogSumExp(arg1_input, arg2_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void ReduceMaxOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_reduceMax");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.reduceMax");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_input = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLReduceOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg2_options;
    if (info[1]->IsUndefined()) {
        arg2_options = MLReduceOptions::Create();
    } else {
        arg2_options = NativeValueTraits<MLReduceOptions>::ArgumentValue(isolate, 1, info[1], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->reduceMax(arg1_input, arg2_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void ReduceMeanOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_reduceMean");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.reduceMean");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_input = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLReduceOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg2_options;
    if (info[1]->IsUndefined()) {
        arg2_options = MLReduceOptions::Create();
    } else {
        arg2_options = NativeValueTraits<MLReduceOptions>::ArgumentValue(isolate, 1, info[1], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->reduceMean(arg1_input, arg2_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void ReduceMinOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_reduceMin");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.reduceMin");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_input = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLReduceOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg2_options;
    if (info[1]->IsUndefined()) {
        arg2_options = MLReduceOptions::Create();
    } else {
        arg2_options = NativeValueTraits<MLReduceOptions>::ArgumentValue(isolate, 1, info[1], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->reduceMin(arg1_input, arg2_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void ReduceProductOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_reduceProduct");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.reduceProduct");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_input = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLReduceOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg2_options;
    if (info[1]->IsUndefined()) {
        arg2_options = MLReduceOptions::Create();
    } else {
        arg2_options = NativeValueTraits<MLReduceOptions>::ArgumentValue(isolate, 1, info[1], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->reduceProduct(arg1_input, arg2_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void ReduceSumOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_reduceSum");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.reduceSum");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_input = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLReduceOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg2_options;
    if (info[1]->IsUndefined()) {
        arg2_options = MLReduceOptions::Create();
    } else {
        arg2_options = NativeValueTraits<MLReduceOptions>::ArgumentValue(isolate, 1, info[1], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->reduceSum(arg1_input, arg2_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void ReduceSumSquareOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_reduceSumSquare");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.reduceSumSquare");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_input = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLReduceOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg2_options;
    if (info[1]->IsUndefined()) {
        arg2_options = MLReduceOptions::Create();
    } else {
        arg2_options = NativeValueTraits<MLReduceOptions>::ArgumentValue(isolate, 1, info[1], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->reduceSumSquare(arg1_input, arg2_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void ReluOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_relu");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.relu");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_input = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLOperatorOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg2_options;
    if (info[1]->IsUndefined()) {
        arg2_options = MLOperatorOptions::Create();
    } else {
        arg2_options = NativeValueTraits<MLOperatorOptions>::ArgumentValue(isolate, 1, info[1], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->relu(arg1_input, arg2_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void Resample2dOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_resample2d");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.resample2d");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    ExceptionState exception_state(isolate);
    auto&& arg1_input = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLResample2dOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg2_options;
    if (info[1]->IsUndefined()) {
        arg2_options = MLResample2dOptions::Create();
    } else {
        arg2_options = NativeValueTraits<MLResample2dOptions>::ArgumentValue(isolate, 1, info[1], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->resample2d(script_state, arg1_input, arg2_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void ReshapeOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_reshape");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.reshape");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_input = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_new_shape = NativeValueTraits<IDLSequence<IDLUnsignedLongEnforceRange>>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLOperatorOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg3_options;
    if (info[2]->IsUndefined()) {
        arg3_options = MLOperatorOptions::Create();
    } else {
        arg3_options = NativeValueTraits<MLOperatorOptions>::ArgumentValue(isolate, 2, info[2], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->reshape(arg1_input, std::move(arg2_new_shape), arg3_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void ScatterElementsOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_scatterElements");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.scatterElements");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 3) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(3, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_input = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_indices = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_updates = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLScatterOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg4_options;
    if (info[3]->IsUndefined()) {
        arg4_options = MLScatterOptions::Create();
    } else {
        arg4_options = NativeValueTraits<MLScatterOptions>::ArgumentValue(isolate, 3, info[3], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->scatterElements(arg1_input, arg2_indices, arg3_updates, arg4_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void ScatterNDOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_scatterND");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.scatterND");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 3) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(3, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_input = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_indices = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_updates = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLOperatorOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg4_options;
    if (info[3]->IsUndefined()) {
        arg4_options = MLOperatorOptions::Create();
    } else {
        arg4_options = NativeValueTraits<MLOperatorOptions>::ArgumentValue(isolate, 3, info[3], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->scatterND(arg1_input, arg2_indices, arg3_updates, arg4_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void SigmoidOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_sigmoid");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.sigmoid");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_input = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLOperatorOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg2_options;
    if (info[1]->IsUndefined()) {
        arg2_options = MLOperatorOptions::Create();
    } else {
        arg2_options = NativeValueTraits<MLOperatorOptions>::ArgumentValue(isolate, 1, info[1], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->sigmoid(arg1_input, arg2_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void SignOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_sign");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.sign");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_x = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLOperatorOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg2_options;
    if (info[1]->IsUndefined()) {
        arg2_options = MLOperatorOptions::Create();
    } else {
        arg2_options = NativeValueTraits<MLOperatorOptions>::ArgumentValue(isolate, 1, info[1], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->sign(arg1_x, arg2_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void SinOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_sin");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.sin");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_x = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLOperatorOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg2_options;
    if (info[1]->IsUndefined()) {
        arg2_options = MLOperatorOptions::Create();
    } else {
        arg2_options = NativeValueTraits<MLOperatorOptions>::ArgumentValue(isolate, 1, info[1], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->sin(arg1_x, arg2_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void SliceOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_slice");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.slice");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 3) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(3, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_input = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_starts = NativeValueTraits<IDLSequence<IDLUnsignedLongEnforceRange>>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_sizes = NativeValueTraits<IDLSequence<IDLUnsignedLongEnforceRange>>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLSliceOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg4_options;
    if (info[3]->IsUndefined()) {
        arg4_options = MLSliceOptions::Create();
    } else {
        arg4_options = NativeValueTraits<MLSliceOptions>::ArgumentValue(isolate, 3, info[3], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->slice(arg1_input, std::move(arg2_starts), std::move(arg3_sizes), arg4_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void SoftmaxOperationOverload1(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_input = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLOperatorOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg2_options;
    if (info[1]->IsUndefined()) {
        arg2_options = MLOperatorOptions::Create();
    } else {
        arg2_options = NativeValueTraits<MLOperatorOptions>::ArgumentValue(isolate, 1, info[1], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->softmax(arg1_input, arg2_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void SoftmaxOperationOverload2(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_input = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_axis = NativeValueTraits<IDLUnsignedLongEnforceRange>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLOperatorOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg3_options;
    if (info[2]->IsUndefined()) {
        arg3_options = MLOperatorOptions::Create();
    } else {
        arg3_options = NativeValueTraits<MLOperatorOptions>::ArgumentValue(isolate, 2, info[2], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->softmax(arg1_input, arg2_axis, arg3_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void SoftmaxOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_softmax");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.softmax");

    BINDINGS_COOPERATIVE_SCHEDULING_SAFEPOINT();

    const int arg_count = std::min(info.Length(), 3);
    if (arg_count == 3) {
        return SoftmaxOperationOverload2(info);
    }
    if (arg_count == 2) {
        if (info[1]->IsUndefined()) {
            return SoftmaxOperationOverload1(info);
        }
        if (info[1]->IsNullOrUndefined()) {
            return SoftmaxOperationOverload1(info);
        }
        if (info[1]->IsObject()) {
            return SoftmaxOperationOverload1(info);
        }
        if (info[1]->IsNumber()) {
            return SoftmaxOperationOverload2(info);
        }
        return SoftmaxOperationOverload2(info);
    }
    if (arg_count == 1) {
        return SoftmaxOperationOverload1(info);
    }

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }
    V8ThrowException::ThrowTypeError(isolate, "Overload resolution failed.");
    return;
}

void SoftplusOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_softplus");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.softplus");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_input = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLOperatorOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg2_options;
    if (info[1]->IsUndefined()) {
        arg2_options = MLOperatorOptions::Create();
    } else {
        arg2_options = NativeValueTraits<MLOperatorOptions>::ArgumentValue(isolate, 1, info[1], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->softplus(arg1_input, arg2_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void SoftsignOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_softsign");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.softsign");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_input = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLOperatorOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg2_options;
    if (info[1]->IsUndefined()) {
        arg2_options = MLOperatorOptions::Create();
    } else {
        arg2_options = NativeValueTraits<MLOperatorOptions>::ArgumentValue(isolate, 1, info[1], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->softsign(arg1_input, arg2_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void SplitOperationOverload1(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_input = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_splits = NativeValueTraits<IDLUnsignedLongEnforceRange>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLSplitOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg3_options;
    if (info[2]->IsUndefined()) {
        arg3_options = MLSplitOptions::Create();
    } else {
        arg3_options = NativeValueTraits<MLSplitOptions>::ArgumentValue(isolate, 2, info[2], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->split(arg1_input, arg2_splits, arg3_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<IDLSequence<MLOperand>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    v8::Local<v8::Value> v8_return_value = ToV8Traits<IDLSequence<MLOperand>>::ToV8(script_state, return_value);
    bindings::V8SetReturnValue(info, v8_return_value);
}

void SplitOperationOverload2(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    ScriptState* receiver_script_state = ScriptState::ForRelevantRealm(isolate, v8_receiver);
    ScriptState* script_state = receiver_script_state;
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_input = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_splits = NativeValueTraits<IDLSequence<IDLUnsignedLongEnforceRange>>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLSplitOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg3_options;
    if (info[2]->IsUndefined()) {
        arg3_options = MLSplitOptions::Create();
    } else {
        arg3_options = NativeValueTraits<MLSplitOptions>::ArgumentValue(isolate, 2, info[2], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->split(arg1_input, std::move(arg2_splits), arg3_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<IDLSequence<MLOperand>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    v8::Local<v8::Value> v8_return_value = ToV8Traits<IDLSequence<MLOperand>>::ToV8(script_state, return_value);
    bindings::V8SetReturnValue(info, v8_return_value);
}

void SplitOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_split");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.split");

    BINDINGS_COOPERATIVE_SCHEDULING_SAFEPOINT();

    const int arg_count = std::min(info.Length(), 3);
    v8::Isolate* isolate = info.GetIsolate();
    if (arg_count == 3) {
        if (info[1]->IsObject()) {
            ExceptionState exception_state(isolate);
            if (info[1]->IsArray() || bindings::IsEsIterableObject(isolate, info[1], exception_state)) {
                return SplitOperationOverload2(info);
            }
            if (exception_state.HadException()) [[unlikely]] {
                return;
            }
        }
        if (info[1]->IsNumber()) {
            return SplitOperationOverload1(info);
        }
        return SplitOperationOverload1(info);
    }
    if (arg_count == 2) {
        if (info[1]->IsObject()) {
            ExceptionState exception_state(isolate);
            if (info[1]->IsArray() || bindings::IsEsIterableObject(isolate, info[1], exception_state)) {
                return SplitOperationOverload2(info);
            }
            if (exception_state.HadException()) [[unlikely]] {
                return;
            }
        }
        if (info[1]->IsNumber()) {
            return SplitOperationOverload1(info);
        }
        return SplitOperationOverload1(info);
    }

    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }
    V8ThrowException::ThrowTypeError(isolate, "Overload resolution failed.");
    return;
}

void SqrtOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_sqrt");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.sqrt");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_x = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLOperatorOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg2_options;
    if (info[1]->IsUndefined()) {
        arg2_options = MLOperatorOptions::Create();
    } else {
        arg2_options = NativeValueTraits<MLOperatorOptions>::ArgumentValue(isolate, 1, info[1], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->sqrt(arg1_x, arg2_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void SubOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_sub");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.sub");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_a = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_b = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLOperatorOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg3_options;
    if (info[2]->IsUndefined()) {
        arg3_options = MLOperatorOptions::Create();
    } else {
        arg3_options = NativeValueTraits<MLOperatorOptions>::ArgumentValue(isolate, 2, info[2], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->sub(arg1_a, arg2_b, arg3_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void TanOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_tan");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.tan");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_x = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLOperatorOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg2_options;
    if (info[1]->IsUndefined()) {
        arg2_options = MLOperatorOptions::Create();
    } else {
        arg2_options = NativeValueTraits<MLOperatorOptions>::ArgumentValue(isolate, 1, info[1], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->tan(arg1_x, arg2_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void TanhOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_tanh");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.tanh");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_input = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLOperatorOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg2_options;
    if (info[1]->IsUndefined()) {
        arg2_options = MLOperatorOptions::Create();
    } else {
        arg2_options = NativeValueTraits<MLOperatorOptions>::ArgumentValue(isolate, 1, info[1], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->tanh(arg1_input, arg2_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void TileOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_tile");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.tile");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 2) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(2, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_input = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_repetitions = NativeValueTraits<IDLSequence<IDLUnsignedLongEnforceRange>>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLOperatorOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg3_options;
    if (info[2]->IsUndefined()) {
        arg3_options = MLOperatorOptions::Create();
    } else {
        arg3_options = NativeValueTraits<MLOperatorOptions>::ArgumentValue(isolate, 2, info[2], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->tile(arg1_input, std::move(arg2_repetitions), arg3_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void TransposeOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_transpose");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.transpose");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_input = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLTransposeOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg2_options;
    if (info[1]->IsUndefined()) {
        arg2_options = MLTransposeOptions::Create();
    } else {
        arg2_options = NativeValueTraits<MLTransposeOptions>::ArgumentValue(isolate, 1, info[1], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->transpose(arg1_input, arg2_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void TriangularOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_triangular");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.triangular");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_input = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLTriangularOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg2_options;
    if (info[1]->IsUndefined()) {
        arg2_options = MLTriangularOptions::Create();
    } else {
        arg2_options = NativeValueTraits<MLTriangularOptions>::ArgumentValue(isolate, 1, info[1], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->triangular(arg1_input, arg2_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void WhereOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_MLGraphBuilder_where");
    BLINK_BINDINGS_TRACE_EVENT("MLGraphBuilder.where");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 3) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(3, info.Length()));
        return;
    }

    v8::Local<v8::Object> v8_receiver = info.This();
    MLGraphBuilder* blink_receiver = V8MLGraphBuilder::ToWrappableUnsafe(isolate, v8_receiver);
    ExceptionState exception_state(isolate);
    auto&& arg1_condition = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 0, info[0], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg2_true_value = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 1, info[1], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    auto&& arg3_false_value = NativeValueTraits<MLOperand>::ArgumentValue(isolate, 2, info[2], exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    decltype(NativeValueTraits<MLOperatorOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg4_options;
    if (info[3]->IsUndefined()) {
        arg4_options = MLOperatorOptions::Create();
    } else {
        arg4_options = NativeValueTraits<MLOperatorOptions>::ArgumentValue(isolate, 3, info[3], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    auto&& return_value = blink_receiver->where(arg1_condition, arg2_true_value, arg3_false_value, arg4_options, exception_state);
    static_assert(bindings::IsReturnTypeCompatible<MLOperand, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

} // namespace v8_ml_graph_builder

using namespace v8_ml_graph_builder;

} // namespace

void V8MLGraphBuilder::InstallInterfaceTemplate(v8::Isolate* isolate, const DOMWrapperWorld& world, v8::Local<v8::Template> interface_template)
{
    const WrapperTypeInfo* const wrapper_type_info = V8MLGraphBuilder::GetWrapperTypeInfo();
    v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
    v8::Local<v8::ObjectTemplate> instance_object_template = interface_function_template->InstanceTemplate();
    v8::Local<v8::ObjectTemplate> prototype_object_template = interface_function_template->PrototypeTemplate();
    v8::Local<v8::FunctionTemplate> parent_interface_template;
    bindings::SetupIDLInterfaceTemplate(
        isolate, wrapper_type_info, instance_object_template, prototype_object_template, interface_function_template, parent_interface_template);

    interface_function_template->SetCallHandler(ConstructorCallback);
    interface_function_template->SetLength(1);
    interface_function_template->SetInterfaceName(V8String(isolate, "MLGraphBuilder"));
    interface_function_template->SetExceptionContext(v8::ExceptionContext::kConstructor);

    v8::Local<v8::Template> instance_template = instance_object_template;
    v8::Local<v8::Template> prototype_template = prototype_object_template;
    InstallUnconditionalProperties(isolate, world, instance_template, prototype_template, interface_template);
}

void V8MLGraphBuilder::InstallUnconditionalProperties(v8::Isolate* isolate, const DOMWrapperWorld& world, v8::Local<v8::Template> instance_template,
    v8::Local<v8::Template> prototype_template, v8::Local<v8::Template> interface_template)
{
    using bindings::IDLMemberInstaller;

    {
        static const IDLMemberInstaller::OperationConfig kOperationTable[] = {
            { "abs", "MLGraphBuilder", AbsOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "add", "MLGraphBuilder", AddOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "argMax", "MLGraphBuilder", ArgMaxOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "argMin", "MLGraphBuilder", ArgMinOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "averagePool2d", "MLGraphBuilder", AveragePool2dOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "batchNormalization", "MLGraphBuilder", BatchNormalizationOperationCallback, 3, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "build", "MLGraphBuilder", BuildOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kDoNotCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "cast", "MLGraphBuilder", CastOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "ceil", "MLGraphBuilder", CeilOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "clamp", "MLGraphBuilder", ClampOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "concat", "MLGraphBuilder", ConcatOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "constant", "MLGraphBuilder", ConstantOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "conv2d", "MLGraphBuilder", Conv2dOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "convTranspose2d", "MLGraphBuilder", ConvTranspose2dOperationCallback, 2, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "cos", "MLGraphBuilder", CosOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "cumulativeSum", "MLGraphBuilder", CumulativeSumOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "dequantizeLinear", "MLGraphBuilder", DequantizeLinearOperationCallback, 3, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "div", "MLGraphBuilder", DivOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "elu", "MLGraphBuilder", EluOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "equal", "MLGraphBuilder", EqualOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "erf", "MLGraphBuilder", ErfOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "exp", "MLGraphBuilder", ExpOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "expand", "MLGraphBuilder", ExpandOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "floor", "MLGraphBuilder", FloorOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "gather", "MLGraphBuilder", GatherOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "gatherElements", "MLGraphBuilder", GatherElementsOperationCallback, 2, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "gatherND", "MLGraphBuilder", GatherNDOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "gelu", "MLGraphBuilder", GeluOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "gemm", "MLGraphBuilder", GemmOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "greater", "MLGraphBuilder", GreaterOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "greaterOrEqual", "MLGraphBuilder", GreaterOrEqualOperationCallback, 2, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "gru", "MLGraphBuilder", GruOperationCallback, 5, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "gruCell", "MLGraphBuilder", GruCellOperationCallback, 5, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "hardSigmoid", "MLGraphBuilder", HardSigmoidOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "hardSwish", "MLGraphBuilder", HardSwishOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "identity", "MLGraphBuilder", IdentityOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "input", "MLGraphBuilder", InputOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "instanceNormalization", "MLGraphBuilder", InstanceNormalizationOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "l2Pool2d", "MLGraphBuilder", L2Pool2dOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "layerNormalization", "MLGraphBuilder", LayerNormalizationOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "leakyRelu", "MLGraphBuilder", LeakyReluOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "lesser", "MLGraphBuilder", LesserOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "lesserOrEqual", "MLGraphBuilder", LesserOrEqualOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "linear", "MLGraphBuilder", LinearOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "log", "MLGraphBuilder", LogOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "logicalAnd", "MLGraphBuilder", LogicalAndOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "logicalNot", "MLGraphBuilder", LogicalNotOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "logicalOr", "MLGraphBuilder", LogicalOrOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "logicalXor", "MLGraphBuilder", LogicalXorOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "lstm", "MLGraphBuilder", LstmOperationCallback, 5, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "lstmCell", "MLGraphBuilder", LstmCellOperationCallback, 6, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "matmul", "MLGraphBuilder", MatmulOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "max", "MLGraphBuilder", MaxOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "maxPool2d", "MLGraphBuilder", MaxPool2dOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "min", "MLGraphBuilder", MinOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "mul", "MLGraphBuilder", MulOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "neg", "MLGraphBuilder", NegOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "pad", "MLGraphBuilder", PadOperationCallback, 3, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "pow", "MLGraphBuilder", PowOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "prelu", "MLGraphBuilder", PreluOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "quantizeLinear", "MLGraphBuilder", QuantizeLinearOperationCallback, 3, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "reciprocal", "MLGraphBuilder", ReciprocalOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "reduceL1", "MLGraphBuilder", ReduceL1OperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "reduceL2", "MLGraphBuilder", ReduceL2OperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "reduceLogSum", "MLGraphBuilder", ReduceLogSumOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "reduceLogSumExp", "MLGraphBuilder", ReduceLogSumExpOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "reduceMax", "MLGraphBuilder", ReduceMaxOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "reduceMean", "MLGraphBuilder", ReduceMeanOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "reduceMin", "MLGraphBuilder", ReduceMinOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "reduceProduct", "MLGraphBuilder", ReduceProductOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "reduceSum", "MLGraphBuilder", ReduceSumOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "reduceSumSquare", "MLGraphBuilder", ReduceSumSquareOperationCallback, 1, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "relu", "MLGraphBuilder", ReluOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "resample2d", "MLGraphBuilder", Resample2dOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "reshape", "MLGraphBuilder", ReshapeOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "scatterElements", "MLGraphBuilder", ScatterElementsOperationCallback, 3, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasSideEffect) },
            { "scatterND", "MLGraphBuilder", ScatterNDOperationCallback, 3, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "sigmoid", "MLGraphBuilder", SigmoidOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "sign", "MLGraphBuilder", SignOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "sin", "MLGraphBuilder", SinOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "slice", "MLGraphBuilder", SliceOperationCallback, 3, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "softmax", "MLGraphBuilder", SoftmaxOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "softplus", "MLGraphBuilder", SoftplusOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "softsign", "MLGraphBuilder", SoftsignOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "split", "MLGraphBuilder", SplitOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "sqrt", "MLGraphBuilder", SqrtOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "sub", "MLGraphBuilder", SubOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "tan", "MLGraphBuilder", TanOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "tanh", "MLGraphBuilder", TanhOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "tile", "MLGraphBuilder", TileOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "transpose", "MLGraphBuilder", TransposeOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "triangular", "MLGraphBuilder", TriangularOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "where", "MLGraphBuilder", WhereOperationCallback, 3, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
        };
        v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
        v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
        IDLMemberInstaller::InstallOperations(isolate, world, instance_template, prototype_template, interface_template, signature, kOperationTable);
    }
}

} // namespace blink
