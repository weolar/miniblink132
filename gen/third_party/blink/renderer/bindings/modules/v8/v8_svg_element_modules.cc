// Copyright 2019 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// DO NOT EDIT: This file is auto-generated by
// //third_party/blink/renderer/bindings/scripts/generate_bindings.py
//
// Use the GN flag `blink_enable_generated_code_formatting=true` to enable
// formatting of the generated files.

#include "third_party/blink/renderer/bindings/modules/v8/v8_svg_element.h"

#include "third_party/blink/public/mojom/origin_trials/origin_trial_feature.mojom-shared.h"
#include "third_party/blink/renderer/bindings/core/v8/generated_code_helper.h"
#include "third_party/blink/renderer/bindings/core/v8/is_return_type_compatible.h"
#include "third_party/blink/renderer/bindings/core/v8/native_value_traits_impl.h"
#include "third_party/blink/renderer/bindings/core/v8/to_v8_traits.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_css_style_declaration.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_dom_string_map.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_event_handler_non_null.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_focus_options.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_set_return_value_for_core.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_style_property_map.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_svg_animated_string.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_svg_svg_element.h"
#include "third_party/blink/renderer/core/css/css_style_declaration.h"
#include "third_party/blink/renderer/core/css/cssom/style_property_map.h"
#include "third_party/blink/renderer/core/dom/dom_string_map.h"
#include "third_party/blink/renderer/core/execution_context/execution_context.h"
#include "third_party/blink/renderer/core/frame/web_feature.h"
#include "third_party/blink/renderer/core/html/custom/ce_reactions_scope.h"
#include "third_party/blink/renderer/core/svg/svg_animated_string.h"
#include "third_party/blink/renderer/core/svg/svg_element.h"
#include "third_party/blink/renderer/core/svg/svg_svg_element.h"
#include "third_party/blink/renderer/core/svg_names.h"
#include "third_party/blink/renderer/modules/xr/global_event_handlers_xr.h"
#include "third_party/blink/renderer/platform/bindings/exception_messages.h"
#include "third_party/blink/renderer/platform/bindings/idl_member_installer.h"
#include "third_party/blink/renderer/platform/bindings/runtime_call_stats.h"
#include "third_party/blink/renderer/platform/bindings/v8_binding.h"
#include "third_party/blink/renderer/platform/instrumentation/use_counter.h"

namespace blink {

void V8SVGElement::Impl::Init()
{
    V8SVGElement::install_interface_template_func_ = InstallInterfaceTemplate;
    V8SVGElement::install_unconditional_props_func_ = InstallUnconditionalProperties;
    V8SVGElement::install_context_independent_props_func_ = InstallContextIndependentProperties;
    V8SVGElement::install_context_dependent_props_func_ = InstallContextDependentProperties;
}

namespace {

namespace v8_svg_element {

void ClassNameAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_className_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.className.get");
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kSVGClassName);

    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->className();
    static_assert(bindings::IsReturnTypeCompatible<SVGAnimatedString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void OwnerSVGElementAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_ownerSVGElement_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.ownerSVGElement.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ownerSVGElement();
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<SVGSVGElement>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void ViewportElementAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_viewportElement_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.viewportElement.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->viewportElement();
    static_assert(bindings::IsReturnTypeCompatible<IDLNullable<SVGElement>, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void OnbeforexrselectAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onbeforexrselect_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onbeforexrselect.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = GlobalEventHandlersXR::onbeforexrselect(*blink_receiver);
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnbeforexrselectAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onbeforexrselect_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onbeforexrselect.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    GlobalEventHandlersXR::setOnbeforexrselect(*blink_receiver, event_handler);
}

void OnabortAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onabort_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onabort.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onabort();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnabortAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onabort_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onabort.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnabort(event_handler);
}

void OnbeforeinputAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onbeforeinput_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onbeforeinput.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onbeforeinput();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnbeforeinputAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onbeforeinput_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onbeforeinput.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnbeforeinput(event_handler);
}

void OnbeforematchAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onbeforematch_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onbeforematch.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onbeforematch();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnbeforematchAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onbeforematch_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onbeforematch.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnbeforematch(event_handler);
}

void OnbeforetoggleAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onbeforetoggle_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onbeforetoggle.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onbeforetoggle();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnbeforetoggleAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onbeforetoggle_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onbeforetoggle.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnbeforetoggle(event_handler);
}

void OnblurAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onblur_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onblur.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onblur();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnblurAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onblur_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onblur.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnblur(event_handler);
}

void OncancelAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_oncancel_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.oncancel.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->oncancel();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OncancelAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_oncancel_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.oncancel.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOncancel(event_handler);
}

void OncanplayAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_oncanplay_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.oncanplay.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->oncanplay();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OncanplayAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_oncanplay_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.oncanplay.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOncanplay(event_handler);
}

void OncanplaythroughAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_oncanplaythrough_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.oncanplaythrough.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->oncanplaythrough();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OncanplaythroughAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_oncanplaythrough_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.oncanplaythrough.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOncanplaythrough(event_handler);
}

void OnchangeAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onchange_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onchange.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onchange();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnchangeAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onchange_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onchange.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnchange(event_handler);
}

void OnclickAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onclick_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onclick.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onclick();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnclickAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onclick_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onclick.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnclick(event_handler);
}

void OncloseAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onclose_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onclose.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onclose();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OncloseAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onclose_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onclose.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnclose(event_handler);
}

void OncontentvisibilityautostatechangeAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_oncontentvisibilityautostatechange_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.oncontentvisibilityautostatechange.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->oncontentvisibilityautostatechange();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OncontentvisibilityautostatechangeAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_oncontentvisibilityautostatechange_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.oncontentvisibilityautostatechange.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOncontentvisibilityautostatechange(event_handler);
}

void OncontextlostAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_oncontextlost_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.oncontextlost.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->oncontextlost();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OncontextlostAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_oncontextlost_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.oncontextlost.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOncontextlost(event_handler);
}

void OncontextmenuAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_oncontextmenu_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.oncontextmenu.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->oncontextmenu();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OncontextmenuAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_oncontextmenu_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.oncontextmenu.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOncontextmenu(event_handler);
}

void OncontextrestoredAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_oncontextrestored_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.oncontextrestored.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->oncontextrestored();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OncontextrestoredAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_oncontextrestored_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.oncontextrestored.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOncontextrestored(event_handler);
}

void OncuechangeAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_oncuechange_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.oncuechange.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->oncuechange();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OncuechangeAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_oncuechange_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.oncuechange.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOncuechange(event_handler);
}

void OndblclickAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_ondblclick_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.ondblclick.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ondblclick();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OndblclickAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_ondblclick_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.ondblclick.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOndblclick(event_handler);
}

void OndragAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_ondrag_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.ondrag.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ondrag();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OndragAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_ondrag_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.ondrag.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOndrag(event_handler);
}

void OndragendAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_ondragend_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.ondragend.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ondragend();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OndragendAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_ondragend_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.ondragend.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOndragend(event_handler);
}

void OndragenterAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_ondragenter_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.ondragenter.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ondragenter();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OndragenterAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_ondragenter_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.ondragenter.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOndragenter(event_handler);
}

void OndragleaveAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_ondragleave_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.ondragleave.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ondragleave();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OndragleaveAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_ondragleave_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.ondragleave.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOndragleave(event_handler);
}

void OndragoverAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_ondragover_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.ondragover.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ondragover();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OndragoverAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_ondragover_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.ondragover.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOndragover(event_handler);
}

void OndragstartAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_ondragstart_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.ondragstart.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ondragstart();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OndragstartAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_ondragstart_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.ondragstart.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOndragstart(event_handler);
}

void OndropAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_ondrop_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.ondrop.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ondrop();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OndropAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_ondrop_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.ondrop.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOndrop(event_handler);
}

void OndurationchangeAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_ondurationchange_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.ondurationchange.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ondurationchange();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OndurationchangeAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_ondurationchange_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.ondurationchange.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOndurationchange(event_handler);
}

void OnemptiedAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onemptied_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onemptied.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onemptied();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnemptiedAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onemptied_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onemptied.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnemptied(event_handler);
}

void OnendedAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onended_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onended.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onended();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnendedAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onended_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onended.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnended(event_handler);
}

void OnerrorAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onerror_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onerror.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onerror();
    static_assert(bindings::IsReturnTypeCompatible<IDLOnErrorEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnerrorAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onerror_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onerror.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kOnErrorEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnerror(event_handler);
}

void OnfencedtreeclickAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onfencedtreeclick_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onfencedtreeclick.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onfencedtreeclick();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnfencedtreeclickAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onfencedtreeclick_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onfencedtreeclick.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnfencedtreeclick(event_handler);
}

void OnfocusAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onfocus_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onfocus.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onfocus();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnfocusAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onfocus_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onfocus.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnfocus(event_handler);
}

void OnformdataAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onformdata_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onformdata.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onformdata();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnformdataAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onformdata_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onformdata.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnformdata(event_handler);
}

void OninputAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_oninput_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.oninput.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->oninput();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OninputAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_oninput_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.oninput.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOninput(event_handler);
}

void OninvalidAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_oninvalid_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.oninvalid.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->oninvalid();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OninvalidAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_oninvalid_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.oninvalid.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOninvalid(event_handler);
}

void OnkeydownAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onkeydown_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onkeydown.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onkeydown();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnkeydownAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onkeydown_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onkeydown.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnkeydown(event_handler);
}

void OnkeypressAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onkeypress_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onkeypress.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onkeypress();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnkeypressAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onkeypress_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onkeypress.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnkeypress(event_handler);
}

void OnkeyupAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onkeyup_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onkeyup.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onkeyup();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnkeyupAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onkeyup_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onkeyup.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnkeyup(event_handler);
}

void OnloadAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onload_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onload.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onload();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnloadAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onload_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onload.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnload(event_handler);
}

void OnloadeddataAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onloadeddata_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onloadeddata.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onloadeddata();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnloadeddataAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onloadeddata_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onloadeddata.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnloadeddata(event_handler);
}

void OnloadedmetadataAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onloadedmetadata_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onloadedmetadata.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onloadedmetadata();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnloadedmetadataAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onloadedmetadata_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onloadedmetadata.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnloadedmetadata(event_handler);
}

void OnloadstartAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onloadstart_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onloadstart.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onloadstart();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnloadstartAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onloadstart_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onloadstart.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnloadstart(event_handler);
}

void OnmousedownAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onmousedown_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onmousedown.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onmousedown();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnmousedownAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onmousedown_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onmousedown.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnmousedown(event_handler);
}

void OnmouseenterAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    // [LegacyLenientThis]
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    if (!V8SVGElement::HasInstance(isolate, v8_receiver)) {
        return;
    }

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onmouseenter_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onmouseenter.get");

    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onmouseenter();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnmouseenterAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    // [LegacyLenientThis]
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    if (!V8SVGElement::HasInstance(isolate, v8_receiver)) {
        return;
    }

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onmouseenter_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onmouseenter.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnmouseenter(event_handler);
}

void OnmouseleaveAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    // [LegacyLenientThis]
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    if (!V8SVGElement::HasInstance(isolate, v8_receiver)) {
        return;
    }

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onmouseleave_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onmouseleave.get");

    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onmouseleave();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnmouseleaveAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    // [LegacyLenientThis]
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    if (!V8SVGElement::HasInstance(isolate, v8_receiver)) {
        return;
    }

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onmouseleave_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onmouseleave.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnmouseleave(event_handler);
}

void OnmousemoveAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onmousemove_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onmousemove.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onmousemove();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnmousemoveAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onmousemove_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onmousemove.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnmousemove(event_handler);
}

void OnmouseoutAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onmouseout_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onmouseout.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onmouseout();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnmouseoutAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onmouseout_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onmouseout.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnmouseout(event_handler);
}

void OnmouseoverAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onmouseover_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onmouseover.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onmouseover();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnmouseoverAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onmouseover_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onmouseover.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnmouseover(event_handler);
}

void OnmouseupAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onmouseup_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onmouseup.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onmouseup();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnmouseupAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onmouseup_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onmouseup.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnmouseup(event_handler);
}

void OnmousewheelAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onmousewheel_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onmousewheel.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onmousewheel();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnmousewheelAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onmousewheel_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onmousewheel.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnmousewheel(event_handler);
}

void OnoverscrollAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onoverscroll_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onoverscroll.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onoverscroll();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnoverscrollAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onoverscroll_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onoverscroll.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnoverscroll(event_handler);
}

void OnpauseAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onpause_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onpause.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onpause();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnpauseAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onpause_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onpause.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnpause(event_handler);
}

void OnplayAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onplay_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onplay.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onplay();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnplayAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onplay_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onplay.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnplay(event_handler);
}

void OnplayingAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onplaying_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onplaying.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onplaying();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnplayingAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onplaying_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onplaying.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnplaying(event_handler);
}

void OnprogressAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onprogress_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onprogress.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onprogress();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnprogressAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onprogress_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onprogress.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnprogress(event_handler);
}

void OnratechangeAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onratechange_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onratechange.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onratechange();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnratechangeAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onratechange_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onratechange.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnratechange(event_handler);
}

void OnresetAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onreset_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onreset.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onreset();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnresetAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onreset_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onreset.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnreset(event_handler);
}

void OnresizeAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onresize_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onresize.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onresize();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnresizeAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onresize_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onresize.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnresize(event_handler);
}

void OnscrollAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onscroll_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onscroll.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onscroll();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnscrollAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onscroll_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onscroll.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnscroll(event_handler);
}

void OnscrollendAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onscrollend_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onscrollend.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onscrollend();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnscrollendAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onscrollend_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onscrollend.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnscrollend(event_handler);
}

void OnsecuritypolicyviolationAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onsecuritypolicyviolation_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onsecuritypolicyviolation.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onsecuritypolicyviolation();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnsecuritypolicyviolationAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onsecuritypolicyviolation_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onsecuritypolicyviolation.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnsecuritypolicyviolation(event_handler);
}

void OnseekedAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onseeked_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onseeked.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onseeked();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnseekedAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onseeked_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onseeked.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnseeked(event_handler);
}

void OnseekingAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onseeking_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onseeking.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onseeking();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnseekingAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onseeking_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onseeking.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnseeking(event_handler);
}

void OnselectAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onselect_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onselect.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onselect();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnselectAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onselect_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onselect.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnselect(event_handler);
}

void OnslotchangeAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onslotchange_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onslotchange.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onslotchange();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnslotchangeAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onslotchange_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onslotchange.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnslotchange(event_handler);
}

void OnscrollsnapchangeAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onscrollsnapchange_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onscrollsnapchange.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onscrollsnapchange();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnscrollsnapchangeAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onscrollsnapchange_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onscrollsnapchange.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnscrollsnapchange(event_handler);
}

void OnscrollsnapchangingAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onscrollsnapchanging_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onscrollsnapchanging.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onscrollsnapchanging();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnscrollsnapchangingAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onscrollsnapchanging_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onscrollsnapchanging.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnscrollsnapchanging(event_handler);
}

void OnstalledAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onstalled_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onstalled.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onstalled();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnstalledAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onstalled_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onstalled.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnstalled(event_handler);
}

void OnsubmitAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onsubmit_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onsubmit.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onsubmit();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnsubmitAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onsubmit_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onsubmit.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnsubmit(event_handler);
}

void OnsuspendAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onsuspend_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onsuspend.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onsuspend();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnsuspendAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onsuspend_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onsuspend.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnsuspend(event_handler);
}

void OntimeupdateAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_ontimeupdate_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.ontimeupdate.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ontimeupdate();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OntimeupdateAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_ontimeupdate_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.ontimeupdate.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOntimeupdate(event_handler);
}

void OntoggleAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_ontoggle_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.ontoggle.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ontoggle();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OntoggleAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_ontoggle_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.ontoggle.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOntoggle(event_handler);
}

void OnvolumechangeAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onvolumechange_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onvolumechange.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onvolumechange();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnvolumechangeAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onvolumechange_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onvolumechange.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnvolumechange(event_handler);
}

void OnwaitingAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onwaiting_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onwaiting.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onwaiting();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnwaitingAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onwaiting_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onwaiting.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnwaiting(event_handler);
}

void OnwebkitanimationendAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onwebkitanimationend_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onwebkitanimationend.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onwebkitanimationend();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnwebkitanimationendAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onwebkitanimationend_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onwebkitanimationend.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnwebkitanimationend(event_handler);
}

void OnwebkitanimationiterationAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onwebkitanimationiteration_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onwebkitanimationiteration.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onwebkitanimationiteration();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnwebkitanimationiterationAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onwebkitanimationiteration_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onwebkitanimationiteration.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnwebkitanimationiteration(event_handler);
}

void OnwebkitanimationstartAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onwebkitanimationstart_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onwebkitanimationstart.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onwebkitanimationstart();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnwebkitanimationstartAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onwebkitanimationstart_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onwebkitanimationstart.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnwebkitanimationstart(event_handler);
}

void OnwebkittransitionendAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onwebkittransitionend_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onwebkittransitionend.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onwebkittransitionend();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnwebkittransitionendAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onwebkittransitionend_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onwebkittransitionend.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnwebkittransitionend(event_handler);
}

void OnwheelAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onwheel_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onwheel.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onwheel();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnwheelAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onwheel_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onwheel.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnwheel(event_handler);
}

void OnauxclickAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onauxclick_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onauxclick.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onauxclick();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnauxclickAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onauxclick_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onauxclick.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnauxclick(event_handler);
}

void OngotpointercaptureAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_ongotpointercapture_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.ongotpointercapture.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ongotpointercapture();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OngotpointercaptureAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_ongotpointercapture_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.ongotpointercapture.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOngotpointercapture(event_handler);
}

void OnlostpointercaptureAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onlostpointercapture_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onlostpointercapture.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onlostpointercapture();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnlostpointercaptureAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onlostpointercapture_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onlostpointercapture.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnlostpointercapture(event_handler);
}

void OnpointerdownAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onpointerdown_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onpointerdown.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onpointerdown();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnpointerdownAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onpointerdown_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onpointerdown.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnpointerdown(event_handler);
}

void OnpointermoveAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onpointermove_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onpointermove.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onpointermove();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnpointermoveAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onpointermove_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onpointermove.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnpointermove(event_handler);
}

void OnpointerrawupdateAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onpointerrawupdate_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onpointerrawupdate.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onpointerrawupdate();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnpointerrawupdateAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onpointerrawupdate_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onpointerrawupdate.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnpointerrawupdate(event_handler);
}

void OnpointerupAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onpointerup_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onpointerup.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onpointerup();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnpointerupAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onpointerup_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onpointerup.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnpointerup(event_handler);
}

void OnpointercancelAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onpointercancel_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onpointercancel.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onpointercancel();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnpointercancelAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onpointercancel_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onpointercancel.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnpointercancel(event_handler);
}

void OnpointeroverAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onpointerover_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onpointerover.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onpointerover();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnpointeroverAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onpointerover_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onpointerover.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnpointerover(event_handler);
}

void OnpointeroutAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onpointerout_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onpointerout.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onpointerout();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnpointeroutAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onpointerout_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onpointerout.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnpointerout(event_handler);
}

void OnpointerenterAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onpointerenter_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onpointerenter.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onpointerenter();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnpointerenterAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onpointerenter_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onpointerenter.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnpointerenter(event_handler);
}

void OnpointerleaveAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onpointerleave_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onpointerleave.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onpointerleave();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnpointerleaveAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onpointerleave_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onpointerleave.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnpointerleave(event_handler);
}

void OntouchcancelAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_ontouchcancel_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.ontouchcancel.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ontouchcancel();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OntouchcancelAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_ontouchcancel_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.ontouchcancel.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOntouchcancel(event_handler);
}

void OntouchendAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_ontouchend_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.ontouchend.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ontouchend();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OntouchendAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_ontouchend_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.ontouchend.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOntouchend(event_handler);
}

void OntouchmoveAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_ontouchmove_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.ontouchmove.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ontouchmove();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OntouchmoveAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_ontouchmove_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.ontouchmove.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOntouchmove(event_handler);
}

void OntouchstartAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_ontouchstart_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.ontouchstart.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ontouchstart();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OntouchstartAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_ontouchstart_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.ontouchstart.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOntouchstart(event_handler);
}

void OnselectstartAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onselectstart_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onselectstart.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onselectstart();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnselectstartAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onselectstart_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onselectstart.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnselectstart(event_handler);
}

void OnselectionchangeAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onselectionchange_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onselectionchange.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onselectionchange();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnselectionchangeAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onselectionchange_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onselectionchange.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnselectionchange(event_handler);
}

void OnanimationendAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onanimationend_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onanimationend.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onanimationend();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnanimationendAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onanimationend_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onanimationend.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnanimationend(event_handler);
}

void OnanimationiterationAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onanimationiteration_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onanimationiteration.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onanimationiteration();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnanimationiterationAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onanimationiteration_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onanimationiteration.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnanimationiteration(event_handler);
}

void OnanimationstartAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onanimationstart_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onanimationstart.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onanimationstart();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnanimationstartAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onanimationstart_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onanimationstart.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnanimationstart(event_handler);
}

void OntransitionrunAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_ontransitionrun_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.ontransitionrun.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ontransitionrun();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OntransitionrunAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_ontransitionrun_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.ontransitionrun.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOntransitionrun(event_handler);
}

void OntransitionstartAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_ontransitionstart_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.ontransitionstart.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ontransitionstart();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OntransitionstartAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_ontransitionstart_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.ontransitionstart.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOntransitionstart(event_handler);
}

void OntransitionendAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_ontransitionend_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.ontransitionend.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ontransitionend();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OntransitionendAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_ontransitionend_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.ontransitionend.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOntransitionend(event_handler);
}

void OntransitioncancelAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_ontransitioncancel_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.ontransitioncancel.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->ontransitioncancel();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OntransitioncancelAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_ontransitioncancel_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.ontransitioncancel.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOntransitioncancel(event_handler);
}

void OncopyAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_oncopy_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.oncopy.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->oncopy();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OncopyAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_oncopy_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.oncopy.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOncopy(event_handler);
}

void OncutAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_oncut_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.oncut.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->oncut();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OncutAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_oncut_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.oncut.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOncut(event_handler);
}

void OnpasteAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onpaste_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onpaste.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->onpaste();
    static_assert(bindings::IsReturnTypeCompatible<IDLEventHandler, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnpasteAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_onpaste_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.onpaste.set");

    v8::Local<v8::Value> v8_property_value = info[0];
    EventListener* event_handler = JSEventHandler::CreateOrNull(v8_property_value, JSEventHandler::HandlerType::kEventHandler);
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->setOnpaste(event_handler);
}

void DatasetAttributeGetCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_dataset_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.dataset.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->dataset();
    static_assert(bindings::IsReturnTypeCompatible<DOMStringMap, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::kMainWorld);
}

void DatasetAttributeGetCallbackForNonMainWorlds(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_dataset_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.dataset.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->dataset();
    static_assert(bindings::IsReturnTypeCompatible<DOMStringMap, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void NonceAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_nonce_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.nonce.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->nonce();
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void NonceAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_nonce_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.nonce.set");

    v8::Isolate* isolate = info.GetIsolate();
    ExceptionState exception_state(isolate);

    // [CEReactions]
    CEReactionsScope ce_reactions_scope;

    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    v8::Local<v8::Value> v8_property_value = info[0];
    auto&& arg1_value = NativeValueTraits<IDLString>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setNonce(arg1_value);
}

void AutofocusAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_autofocus_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.autofocus.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->FastHasAttribute(svg_names::kAutofocusAttr);
    static_assert(bindings::IsReturnTypeCompatible<IDLBoolean, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void AutofocusAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_autofocus_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.autofocus.set");

    const char* const class_like_name = "SVGElement";
    const char* const property_name = "autofocus";
    bindings::PerformAttributeSetCEReactionsReflectTypeBoolean(info, svg_names::kAutofocusAttr, class_like_name, property_name);
}

void TabIndexAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_tabIndex_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.tabIndex.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->tabIndex();
    static_assert(bindings::IsReturnTypeCompatible<IDLLong, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<int32_t>());
}

void TabIndexAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_tabIndex_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.tabIndex.set");

    v8::Isolate* isolate = info.GetIsolate();
    ExceptionState exception_state(isolate);

    // [CEReactions]
    CEReactionsScope ce_reactions_scope;

    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    v8::Local<v8::Value> v8_property_value = info[0];
    auto&& arg1_value = NativeValueTraits<IDLLong>::NativeValue(isolate, v8_property_value, exception_state);
    if (exception_state.HadException()) [[unlikely]] {
        return;
    }
    blink_receiver->setTabIndex(arg1_value);
}

void FocusgroupAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_focusgroup_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.focusgroup.get");
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kV8SVGElement_Focusgroup_AttributeGetter);

    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->FastGetAttribute(svg_names::kFocusgroupAttr);
    static_assert(bindings::IsReturnTypeCompatible<IDLString, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void FocusgroupAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_focusgroup_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.focusgroup.set");
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kV8SVGElement_Focusgroup_AttributeSetter);

    const char* const class_like_name = "SVGElement";
    const char* const property_name = "focusgroup";
    bindings::PerformAttributeSetCEReactionsReflectTypeString(info, svg_names::kFocusgroupAttr, class_like_name, property_name);
}

void StyleAttributeGetCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_style_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.style.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->style();
    static_assert(bindings::IsReturnTypeCompatible<CSSStyleDeclaration, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::kMainWorld);
}

void StyleAttributeSetCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_style_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.style.set");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    // [PutForwards]
    v8::Local<v8::Value> target;
    v8::Local<v8::Object> v8_receiver = info.This();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    const char* const property_name = "style";
    if (!v8_receiver->Get(current_context, V8AtomicString(isolate, property_name)).ToLocal(&target)) {
        return;
    }
    if (!target->IsObject()) {
        V8ThrowException::ThrowTypeError(isolate, "The attribute value is not an object");
        return;
    }
    bool did_set;
    v8::Local<v8::Value> v8_property_value = info[0];
    if (!target.As<v8::Object>()->Set(current_context, V8AtomicString(isolate, "cssText"), v8_property_value).To(&did_set)) {
        return;
    }
    return;
}

void StyleAttributeGetCallbackForNonMainWorlds(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_style_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.style.get");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->style();
    static_assert(bindings::IsReturnTypeCompatible<CSSStyleDeclaration, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void StyleAttributeSetCallbackForNonMainWorlds(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_style_Setter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.style.set");

    v8::Isolate* isolate = info.GetIsolate();
    if (info.Length() < 1) [[unlikely]] {
        V8ThrowException::ThrowTypeError(isolate, ExceptionMessages::NotEnoughArguments(1, info.Length()));
        return;
    }

    // [PutForwards]
    v8::Local<v8::Value> target;
    v8::Local<v8::Object> v8_receiver = info.This();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    const char* const property_name = "style";
    if (!v8_receiver->Get(current_context, V8AtomicString(isolate, property_name)).ToLocal(&target)) {
        return;
    }
    if (!target->IsObject()) {
        V8ThrowException::ThrowTypeError(isolate, "The attribute value is not an object");
        return;
    }
    bool did_set;
    v8::Local<v8::Value> v8_property_value = info[0];
    if (!target.As<v8::Object>()->Set(current_context, V8AtomicString(isolate, "cssText"), v8_property_value).To(&did_set)) {
        return;
    }
    return;
}

void AttributeStyleMapAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{

    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_attributeStyleMap_Getter");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.attributeStyleMap.get");
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
    ScriptState* current_script_state = ScriptState::From(isolate, current_context);
    ExecutionContext* current_execution_context = ToExecutionContext(current_script_state);
    // [Measure], [MeasureAs]
    UseCounter::Count(current_execution_context, WebFeature::kCSSTypedOMStylePropertyMap);

    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    auto&& return_value = blink_receiver->attributeStyleMap();
    static_assert(bindings::IsReturnTypeCompatible<StylePropertyMap, std::remove_cvref_t<decltype(return_value)>>,
        "Return type from native call is incompatible to the type specified in IDL");
    bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void BlurOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_blur");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.blur");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    blink_receiver->blur();
}

void FocusOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_SVGElement_focus");
    BLINK_BINDINGS_TRACE_EVENT("SVGElement.focus");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Object> v8_receiver = info.This();
    SVGElement* blink_receiver = V8SVGElement::ToWrappableUnsafe(isolate, v8_receiver);
    decltype(NativeValueTraits<FocusOptions>::NativeValue(
        std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg1_options;
    if (info[0]->IsUndefined()) {
        arg1_options = FocusOptions::Create();
    } else {
        ExceptionState exception_state(isolate);
        arg1_options = NativeValueTraits<FocusOptions>::ArgumentValue(isolate, 0, info[0], exception_state);
        if (exception_state.HadException()) [[unlikely]] {
            return;
        }
    }
    blink_receiver->focusForBindings(arg1_options);
}

} // namespace v8_svg_element

using namespace v8_svg_element;

} // namespace

void V8SVGElement::Impl::InstallInterfaceTemplate(v8::Isolate* isolate, const DOMWrapperWorld& world, v8::Local<v8::Template> interface_template)
{
    const WrapperTypeInfo* const wrapper_type_info = V8SVGElement::GetWrapperTypeInfo();
    v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
    v8::Local<v8::ObjectTemplate> instance_object_template = interface_function_template->InstanceTemplate();
    v8::Local<v8::ObjectTemplate> prototype_object_template = interface_function_template->PrototypeTemplate();
    v8::Local<v8::FunctionTemplate> parent_interface_template = wrapper_type_info->parent_class->GetV8ClassTemplate(isolate, world).As<v8::FunctionTemplate>();
    bindings::SetupIDLInterfaceTemplate(
        isolate, wrapper_type_info, instance_object_template, prototype_object_template, interface_function_template, parent_interface_template);

    v8::Local<v8::Template> instance_template = instance_object_template;
    v8::Local<v8::Template> prototype_template = prototype_object_template;
    InstallUnconditionalProperties(isolate, world, instance_template, prototype_template, interface_template);
    InstallContextIndependentProperties(isolate, world, instance_template, prototype_template, interface_template);
}

void V8SVGElement::Impl::InstallUnconditionalProperties(v8::Isolate* isolate, const DOMWrapperWorld& world, v8::Local<v8::Template> instance_template,
    v8::Local<v8::Template> prototype_template, v8::Local<v8::Template> interface_template)
{
    using bindings::IDLMemberInstaller;

    v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
    v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
    {
        static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
            { "className", "SVGElement", ClassNameAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ownerSVGElement", "SVGElement", OwnerSVGElementAttributeGetCallback, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "viewportElement", "SVGElement", ViewportElementAttributeGetCallback, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onbeforexrselect", "SVGElement", OnbeforexrselectAttributeGetCallback, OnbeforexrselectAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onabort", "SVGElement", OnabortAttributeGetCallback, OnabortAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onbeforeinput", "SVGElement", OnbeforeinputAttributeGetCallback, OnbeforeinputAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onbeforematch", "SVGElement", OnbeforematchAttributeGetCallback, OnbeforematchAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onbeforetoggle", "SVGElement", OnbeforetoggleAttributeGetCallback, OnbeforetoggleAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onblur", "SVGElement", OnblurAttributeGetCallback, OnblurAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "oncancel", "SVGElement", OncancelAttributeGetCallback, OncancelAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "oncanplay", "SVGElement", OncanplayAttributeGetCallback, OncanplayAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "oncanplaythrough", "SVGElement", OncanplaythroughAttributeGetCallback, OncanplaythroughAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onchange", "SVGElement", OnchangeAttributeGetCallback, OnchangeAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onclick", "SVGElement", OnclickAttributeGetCallback, OnclickAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onclose", "SVGElement", OncloseAttributeGetCallback, OncloseAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "oncontentvisibilityautostatechange", "SVGElement", OncontentvisibilityautostatechangeAttributeGetCallback,
                OncontentvisibilityautostatechangeAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "oncontextlost", "SVGElement", OncontextlostAttributeGetCallback, OncontextlostAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "oncontextmenu", "SVGElement", OncontextmenuAttributeGetCallback, OncontextmenuAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "oncontextrestored", "SVGElement", OncontextrestoredAttributeGetCallback, OncontextrestoredAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "oncuechange", "SVGElement", OncuechangeAttributeGetCallback, OncuechangeAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ondblclick", "SVGElement", OndblclickAttributeGetCallback, OndblclickAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ondrag", "SVGElement", OndragAttributeGetCallback, OndragAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ondragend", "SVGElement", OndragendAttributeGetCallback, OndragendAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ondragenter", "SVGElement", OndragenterAttributeGetCallback, OndragenterAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ondragleave", "SVGElement", OndragleaveAttributeGetCallback, OndragleaveAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ondragover", "SVGElement", OndragoverAttributeGetCallback, OndragoverAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ondragstart", "SVGElement", OndragstartAttributeGetCallback, OndragstartAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ondrop", "SVGElement", OndropAttributeGetCallback, OndropAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ondurationchange", "SVGElement", OndurationchangeAttributeGetCallback, OndurationchangeAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onemptied", "SVGElement", OnemptiedAttributeGetCallback, OnemptiedAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onended", "SVGElement", OnendedAttributeGetCallback, OnendedAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onerror", "SVGElement", OnerrorAttributeGetCallback, OnerrorAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onfocus", "SVGElement", OnfocusAttributeGetCallback, OnfocusAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onformdata", "SVGElement", OnformdataAttributeGetCallback, OnformdataAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "oninput", "SVGElement", OninputAttributeGetCallback, OninputAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "oninvalid", "SVGElement", OninvalidAttributeGetCallback, OninvalidAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onkeydown", "SVGElement", OnkeydownAttributeGetCallback, OnkeydownAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onkeypress", "SVGElement", OnkeypressAttributeGetCallback, OnkeypressAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onkeyup", "SVGElement", OnkeyupAttributeGetCallback, OnkeyupAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onload", "SVGElement", OnloadAttributeGetCallback, OnloadAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onloadeddata", "SVGElement", OnloadeddataAttributeGetCallback, OnloadeddataAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onloadedmetadata", "SVGElement", OnloadedmetadataAttributeGetCallback, OnloadedmetadataAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onloadstart", "SVGElement", OnloadstartAttributeGetCallback, OnloadstartAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onmousedown", "SVGElement", OnmousedownAttributeGetCallback, OnmousedownAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onmouseenter", "SVGElement", OnmouseenterAttributeGetCallback, OnmouseenterAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kDoNotCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onmouseleave", "SVGElement", OnmouseleaveAttributeGetCallback, OnmouseleaveAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kDoNotCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onmousemove", "SVGElement", OnmousemoveAttributeGetCallback, OnmousemoveAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onmouseout", "SVGElement", OnmouseoutAttributeGetCallback, OnmouseoutAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onmouseover", "SVGElement", OnmouseoverAttributeGetCallback, OnmouseoverAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onmouseup", "SVGElement", OnmouseupAttributeGetCallback, OnmouseupAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onmousewheel", "SVGElement", OnmousewheelAttributeGetCallback, OnmousewheelAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onpause", "SVGElement", OnpauseAttributeGetCallback, OnpauseAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onplay", "SVGElement", OnplayAttributeGetCallback, OnplayAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onplaying", "SVGElement", OnplayingAttributeGetCallback, OnplayingAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onprogress", "SVGElement", OnprogressAttributeGetCallback, OnprogressAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onratechange", "SVGElement", OnratechangeAttributeGetCallback, OnratechangeAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onreset", "SVGElement", OnresetAttributeGetCallback, OnresetAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onresize", "SVGElement", OnresizeAttributeGetCallback, OnresizeAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onscroll", "SVGElement", OnscrollAttributeGetCallback, OnscrollAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onsecuritypolicyviolation", "SVGElement", OnsecuritypolicyviolationAttributeGetCallback, OnsecuritypolicyviolationAttributeSetCallback,
                unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onseeked", "SVGElement", OnseekedAttributeGetCallback, OnseekedAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onseeking", "SVGElement", OnseekingAttributeGetCallback, OnseekingAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onselect", "SVGElement", OnselectAttributeGetCallback, OnselectAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onslotchange", "SVGElement", OnslotchangeAttributeGetCallback, OnslotchangeAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onstalled", "SVGElement", OnstalledAttributeGetCallback, OnstalledAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onsubmit", "SVGElement", OnsubmitAttributeGetCallback, OnsubmitAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onsuspend", "SVGElement", OnsuspendAttributeGetCallback, OnsuspendAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ontimeupdate", "SVGElement", OntimeupdateAttributeGetCallback, OntimeupdateAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ontoggle", "SVGElement", OntoggleAttributeGetCallback, OntoggleAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onvolumechange", "SVGElement", OnvolumechangeAttributeGetCallback, OnvolumechangeAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onwaiting", "SVGElement", OnwaitingAttributeGetCallback, OnwaitingAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onwebkitanimationend", "SVGElement", OnwebkitanimationendAttributeGetCallback, OnwebkitanimationendAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onwebkitanimationiteration", "SVGElement", OnwebkitanimationiterationAttributeGetCallback, OnwebkitanimationiterationAttributeSetCallback,
                unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onwebkitanimationstart", "SVGElement", OnwebkitanimationstartAttributeGetCallback, OnwebkitanimationstartAttributeSetCallback,
                unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onwebkittransitionend", "SVGElement", OnwebkittransitionendAttributeGetCallback, OnwebkittransitionendAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onwheel", "SVGElement", OnwheelAttributeGetCallback, OnwheelAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onauxclick", "SVGElement", OnauxclickAttributeGetCallback, OnauxclickAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ongotpointercapture", "SVGElement", OngotpointercaptureAttributeGetCallback, OngotpointercaptureAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onlostpointercapture", "SVGElement", OnlostpointercaptureAttributeGetCallback, OnlostpointercaptureAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onpointerdown", "SVGElement", OnpointerdownAttributeGetCallback, OnpointerdownAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onpointermove", "SVGElement", OnpointermoveAttributeGetCallback, OnpointermoveAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onpointerrawupdate", "SVGElement", OnpointerrawupdateAttributeGetCallback, OnpointerrawupdateAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onpointerup", "SVGElement", OnpointerupAttributeGetCallback, OnpointerupAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onpointercancel", "SVGElement", OnpointercancelAttributeGetCallback, OnpointercancelAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onpointerover", "SVGElement", OnpointeroverAttributeGetCallback, OnpointeroverAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onpointerout", "SVGElement", OnpointeroutAttributeGetCallback, OnpointeroutAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onpointerenter", "SVGElement", OnpointerenterAttributeGetCallback, OnpointerenterAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onpointerleave", "SVGElement", OnpointerleaveAttributeGetCallback, OnpointerleaveAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onselectstart", "SVGElement", OnselectstartAttributeGetCallback, OnselectstartAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onselectionchange", "SVGElement", OnselectionchangeAttributeGetCallback, OnselectionchangeAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onanimationend", "SVGElement", OnanimationendAttributeGetCallback, OnanimationendAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onanimationiteration", "SVGElement", OnanimationiterationAttributeGetCallback, OnanimationiterationAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onanimationstart", "SVGElement", OnanimationstartAttributeGetCallback, OnanimationstartAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ontransitionrun", "SVGElement", OntransitionrunAttributeGetCallback, OntransitionrunAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ontransitionstart", "SVGElement", OntransitionstartAttributeGetCallback, OntransitionstartAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ontransitionend", "SVGElement", OntransitionendAttributeGetCallback, OntransitionendAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ontransitioncancel", "SVGElement", OntransitioncancelAttributeGetCallback, OntransitioncancelAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "oncopy", "SVGElement", OncopyAttributeGetCallback, OncopyAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "oncut", "SVGElement", OncutAttributeGetCallback, OncutAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "onpaste", "SVGElement", OnpasteAttributeGetCallback, OnpasteAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "dataset", "SVGElement", DatasetAttributeGetCallbackForMainWorld, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kMainWorld),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "dataset", "SVGElement", DatasetAttributeGetCallbackForNonMainWorlds, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kNonMainWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "nonce", "SVGElement", NonceAttributeGetCallback, NonceAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "autofocus", "SVGElement", AutofocusAttributeGetCallback, AutofocusAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "tabIndex", "SVGElement", TabIndexAttributeGetCallback, TabIndexAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "style", "SVGElement", StyleAttributeGetCallbackForMainWorld, StyleAttributeSetCallbackForMainWorld, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kMainWorld),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "style", "SVGElement", StyleAttributeGetCallbackForNonMainWorlds, StyleAttributeSetCallbackForNonMainWorlds, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kNonMainWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "attributeStyleMap", "SVGElement", AttributeStyleMapAttributeGetCallback, nullptr, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
        };
        IDLMemberInstaller::InstallAttributes(isolate, world, instance_template, prototype_template, interface_template, signature, kAttributeTable);
    }

    {
        static const IDLMemberInstaller::OperationConfig kOperationTable[] = {
            { "blur", "SVGElement", BlurOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
            { "focus", "SVGElement", FocusOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype),
                unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect) },
        };
        IDLMemberInstaller::InstallOperations(isolate, world, instance_template, prototype_template, interface_template, signature, kOperationTable);
    }
}

void V8SVGElement::Impl::InstallContextIndependentProperties(v8::Isolate* isolate, const DOMWrapperWorld& world, v8::Local<v8::Template> instance_template,
    v8::Local<v8::Template> prototype_template, v8::Local<v8::Template> interface_template)
{
    using bindings::IDLMemberInstaller;

    if (RuntimeEnabledFeatures::FencedFramesLocalUnpartitionedDataAccessEnabled()) {
        static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
            { "onfencedtreeclick", "SVGElement", OnfencedtreeclickAttributeGetCallback, OnfencedtreeclickAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
        };
        v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
        v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
        IDLMemberInstaller::InstallAttributes(isolate, world, instance_template, prototype_template, interface_template, signature, kAttributeTable);
    }
    if (RuntimeEnabledFeatures::OverscrollCustomizationEnabled()) {
        static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
            { "onoverscroll", "SVGElement", OnoverscrollAttributeGetCallback, OnoverscrollAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
        };
        v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
        v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
        IDLMemberInstaller::InstallAttributes(isolate, world, instance_template, prototype_template, interface_template, signature, kAttributeTable);
    }
    if (RuntimeEnabledFeatures::ScrollEndEventsEnabled()) {
        static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
            { "onscrollend", "SVGElement", OnscrollendAttributeGetCallback, OnscrollendAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
        };
        v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
        v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
        IDLMemberInstaller::InstallAttributes(isolate, world, instance_template, prototype_template, interface_template, signature, kAttributeTable);
    }
    if (RuntimeEnabledFeatures::CSSScrollSnapChangeEventEnabled()) {
        static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
            { "onscrollsnapchange", "SVGElement", OnscrollsnapchangeAttributeGetCallback, OnscrollsnapchangeAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
        };
        v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
        v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
        IDLMemberInstaller::InstallAttributes(isolate, world, instance_template, prototype_template, interface_template, signature, kAttributeTable);
    }
    if (RuntimeEnabledFeatures::CSSScrollSnapChangingEventEnabled()) {
        static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
            { "onscrollsnapchanging", "SVGElement", OnscrollsnapchangingAttributeGetCallback, OnscrollsnapchangingAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
        };
        v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
        v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
        IDLMemberInstaller::InstallAttributes(isolate, world, instance_template, prototype_template, interface_template, signature, kAttributeTable);
    }
}

void V8SVGElement::Impl::InstallContextDependentProperties(v8::Local<v8::Context> context, const DOMWrapperWorld& world, v8::Local<v8::Object> instance_object,
    v8::Local<v8::Object> prototype_object, v8::Local<v8::Object> interface_object, v8::Local<v8::Template> interface_template,
    FeatureSelector feature_selector)
{
    using bindings::IDLMemberInstaller;

    v8::Isolate* isolate = context->GetIsolate();
    ScriptState* script_state = ScriptState::From(isolate, context);
    ExecutionContext* execution_context = ToExecutionContext(script_state);
    if ((feature_selector.IsAll() && RuntimeEnabledFeatures::TouchEventFeatureDetectionEnabled(execution_context))
        || feature_selector.IsAnyOf(mojom::blink::OriginTrialFeature::kTouchEventFeatureDetection)) {
        static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
            { "ontouchcancel", "SVGElement", OntouchcancelAttributeGetCallback, OntouchcancelAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ontouchend", "SVGElement", OntouchendAttributeGetCallback, OntouchendAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ontouchmove", "SVGElement", OntouchmoveAttributeGetCallback, OntouchmoveAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
            { "ontouchstart", "SVGElement", OntouchstartAttributeGetCallback, OntouchstartAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
        };
        v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
        v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
        IDLMemberInstaller::InstallAttributes(isolate, world, instance_object, prototype_object, interface_object, signature, kAttributeTable);
    }
    if ((feature_selector.IsAll() && RuntimeEnabledFeatures::FocusgroupEnabled(execution_context))
        || feature_selector.IsAnyOf(mojom::blink::OriginTrialFeature::kFocusgroup)) {
        static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
            { "focusgroup", "SVGElement", FocusgroupAttributeGetCallback, FocusgroupAttributeSetCallback, unsigned(v8::None),
                unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds),
                unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck),
                unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect),
                unsigned(V8PrivateProperty::CachedAccessor::kNone) },
        };
        v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
        v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
        IDLMemberInstaller::InstallAttributes(isolate, world, instance_object, prototype_object, interface_object, signature, kAttributeTable);
    }
}

} // namespace blink
