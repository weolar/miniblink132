// This file is generated by TypeBuilder_h.template.

// Copyright 2016 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef blink_protocol_Page_h
#define blink_protocol_Page_h

#include "third_party/blink/renderer/core/core_export.h"
#include "third_party/blink/renderer/core/inspector/protocol/protocol.h"
// For each imported domain we generate a ValueConversions struct instead of a full domain definition
// and include Domain::API version from there.
#include "third_party/blink/renderer/core/inspector/protocol/debugger.h"
#include "third_party/blink/renderer/core/inspector/protocol/dom.h"
#include "third_party/blink/renderer/core/inspector/protocol/io.h"
#include "third_party/blink/renderer/core/inspector/protocol/network.h"
#include "third_party/blink/renderer/core/inspector/protocol/runtime.h"

namespace blink {
namespace protocol {
namespace Page {
using FrameId = String;
using AdFrameType = String;
using AdFrameExplanation = String;
class AdFrameStatus;
class AdScriptId;
using SecureContextType = String;
using CrossOriginIsolatedContextType = String;
using GatedAPIFeatures = String;
using PermissionsPolicyFeature = String;
using PermissionsPolicyBlockReason = String;
class PermissionsPolicyBlockLocator;
class PermissionsPolicyFeatureState;
using OriginTrialTokenStatus = String;
using OriginTrialStatus = String;
using OriginTrialUsageRestriction = String;
class OriginTrialToken;
class OriginTrialTokenWithStatus;
class OriginTrial;
class Frame;
class FrameResource;
class FrameResourceTree;
class FrameTree;
using ScriptIdentifier = String;
class LayoutViewport;
class VisualViewport;
class Viewport;
class FontFamilies;
class ScriptFontFamilies;
class FontSizes;
using ClientNavigationReason = String;
using ClientNavigationDisposition = String;
class CompilationCacheParams;
using NavigationType = String;
using BackForwardCacheNotRestoredReason = String;
using BackForwardCacheNotRestoredReasonType = String;
class BackForwardCacheBlockingDetails;
class BackForwardCacheNotRestoredExplanation;
class BackForwardCacheNotRestoredExplanationTree;

// ------------- Forward and enum declarations.

namespace AdFrameTypeEnum {
CORE_EXPORT extern const char None[];
CORE_EXPORT extern const char Child[];
CORE_EXPORT extern const char Root[];
} // namespace AdFrameTypeEnum

namespace AdFrameExplanationEnum {
CORE_EXPORT extern const char ParentIsAd[];
CORE_EXPORT extern const char CreatedByAdScript[];
CORE_EXPORT extern const char MatchedBlockingRule[];
} // namespace AdFrameExplanationEnum

namespace SecureContextTypeEnum {
CORE_EXPORT extern const char Secure[];
CORE_EXPORT extern const char SecureLocalhost[];
CORE_EXPORT extern const char InsecureScheme[];
CORE_EXPORT extern const char InsecureAncestor[];
} // namespace SecureContextTypeEnum

namespace CrossOriginIsolatedContextTypeEnum {
CORE_EXPORT extern const char Isolated[];
CORE_EXPORT extern const char NotIsolated[];
CORE_EXPORT extern const char NotIsolatedFeatureDisabled[];
} // namespace CrossOriginIsolatedContextTypeEnum

namespace GatedAPIFeaturesEnum {
CORE_EXPORT extern const char SharedArrayBuffers[];
CORE_EXPORT extern const char SharedArrayBuffersTransferAllowed[];
CORE_EXPORT extern const char PerformanceMeasureMemory[];
CORE_EXPORT extern const char PerformanceProfile[];
} // namespace GatedAPIFeaturesEnum

namespace PermissionsPolicyFeatureEnum {
CORE_EXPORT extern const char Accelerometer[];
CORE_EXPORT extern const char AllScreensCapture[];
CORE_EXPORT extern const char AmbientLightSensor[];
CORE_EXPORT extern const char AttributionReporting[];
CORE_EXPORT extern const char Autoplay[];
CORE_EXPORT extern const char Bluetooth[];
CORE_EXPORT extern const char BrowsingTopics[];
CORE_EXPORT extern const char Camera[];
CORE_EXPORT extern const char CapturedSurfaceControl[];
CORE_EXPORT extern const char ChDpr[];
CORE_EXPORT extern const char ChDeviceMemory[];
CORE_EXPORT extern const char ChDownlink[];
CORE_EXPORT extern const char ChEct[];
CORE_EXPORT extern const char ChPrefersColorScheme[];
CORE_EXPORT extern const char ChPrefersReducedMotion[];
CORE_EXPORT extern const char ChPrefersReducedTransparency[];
CORE_EXPORT extern const char ChRtt[];
CORE_EXPORT extern const char ChSaveData[];
CORE_EXPORT extern const char ChUa[];
CORE_EXPORT extern const char ChUaArch[];
CORE_EXPORT extern const char ChUaBitness[];
CORE_EXPORT extern const char ChUaPlatform[];
CORE_EXPORT extern const char ChUaModel[];
CORE_EXPORT extern const char ChUaMobile[];
CORE_EXPORT extern const char ChUaFormFactors[];
CORE_EXPORT extern const char ChUaFullVersion[];
CORE_EXPORT extern const char ChUaFullVersionList[];
CORE_EXPORT extern const char ChUaPlatformVersion[];
CORE_EXPORT extern const char ChUaWow64[];
CORE_EXPORT extern const char ChViewportHeight[];
CORE_EXPORT extern const char ChViewportWidth[];
CORE_EXPORT extern const char ChWidth[];
CORE_EXPORT extern const char ClipboardRead[];
CORE_EXPORT extern const char ClipboardWrite[];
CORE_EXPORT extern const char ComputePressure[];
CORE_EXPORT extern const char ControlledFrame[];
CORE_EXPORT extern const char CrossOriginIsolated[];
CORE_EXPORT extern const char DeferredFetch[];
CORE_EXPORT extern const char DigitalCredentialsGet[];
CORE_EXPORT extern const char DirectSockets[];
CORE_EXPORT extern const char DirectSocketsPrivate[];
CORE_EXPORT extern const char DisplayCapture[];
CORE_EXPORT extern const char DocumentDomain[];
CORE_EXPORT extern const char EncryptedMedia[];
CORE_EXPORT extern const char ExecutionWhileOutOfViewport[];
CORE_EXPORT extern const char ExecutionWhileNotRendered[];
CORE_EXPORT extern const char FencedUnpartitionedStorageRead[];
CORE_EXPORT extern const char FocusWithoutUserActivation[];
CORE_EXPORT extern const char Fullscreen[];
CORE_EXPORT extern const char Frobulate[];
CORE_EXPORT extern const char Gamepad[];
CORE_EXPORT extern const char Geolocation[];
CORE_EXPORT extern const char Gyroscope[];
CORE_EXPORT extern const char Hid[];
CORE_EXPORT extern const char IdentityCredentialsGet[];
CORE_EXPORT extern const char IdleDetection[];
CORE_EXPORT extern const char InterestCohort[];
CORE_EXPORT extern const char JoinAdInterestGroup[];
CORE_EXPORT extern const char KeyboardMap[];
CORE_EXPORT extern const char LocalFonts[];
CORE_EXPORT extern const char Magnetometer[];
CORE_EXPORT extern const char MediaPlaybackWhileNotVisible[];
CORE_EXPORT extern const char Microphone[];
CORE_EXPORT extern const char Midi[];
CORE_EXPORT extern const char OtpCredentials[];
CORE_EXPORT extern const char Payment[];
CORE_EXPORT extern const char PictureInPicture[];
CORE_EXPORT extern const char Popins[];
CORE_EXPORT extern const char PrivateAggregation[];
CORE_EXPORT extern const char PrivateStateTokenIssuance[];
CORE_EXPORT extern const char PrivateStateTokenRedemption[];
CORE_EXPORT extern const char PublickeyCredentialsCreate[];
CORE_EXPORT extern const char PublickeyCredentialsGet[];
CORE_EXPORT extern const char RunAdAuction[];
CORE_EXPORT extern const char ScreenWakeLock[];
CORE_EXPORT extern const char Serial[];
CORE_EXPORT extern const char SharedAutofill[];
CORE_EXPORT extern const char SharedStorage[];
CORE_EXPORT extern const char SharedStorageSelectUrl[];
CORE_EXPORT extern const char SmartCard[];
CORE_EXPORT extern const char SpeakerSelection[];
CORE_EXPORT extern const char StorageAccess[];
CORE_EXPORT extern const char SubApps[];
CORE_EXPORT extern const char SyncXhr[];
CORE_EXPORT extern const char Unload[];
CORE_EXPORT extern const char Usb[];
CORE_EXPORT extern const char UsbUnrestricted[];
CORE_EXPORT extern const char VerticalScroll[];
CORE_EXPORT extern const char WebAppInstallation[];
CORE_EXPORT extern const char WebPrinting[];
CORE_EXPORT extern const char WebShare[];
CORE_EXPORT extern const char WindowManagement[];
CORE_EXPORT extern const char XrSpatialTracking[];
} // namespace PermissionsPolicyFeatureEnum

namespace PermissionsPolicyBlockReasonEnum {
CORE_EXPORT extern const char Header[];
CORE_EXPORT extern const char IframeAttribute[];
CORE_EXPORT extern const char InFencedFrameTree[];
CORE_EXPORT extern const char InIsolatedApp[];
} // namespace PermissionsPolicyBlockReasonEnum

namespace OriginTrialTokenStatusEnum {
CORE_EXPORT extern const char Success[];
CORE_EXPORT extern const char NotSupported[];
CORE_EXPORT extern const char Insecure[];
CORE_EXPORT extern const char Expired[];
CORE_EXPORT extern const char WrongOrigin[];
CORE_EXPORT extern const char InvalidSignature[];
CORE_EXPORT extern const char Malformed[];
CORE_EXPORT extern const char WrongVersion[];
CORE_EXPORT extern const char FeatureDisabled[];
CORE_EXPORT extern const char TokenDisabled[];
CORE_EXPORT extern const char FeatureDisabledForUser[];
CORE_EXPORT extern const char UnknownTrial[];
} // namespace OriginTrialTokenStatusEnum

namespace OriginTrialStatusEnum {
CORE_EXPORT extern const char Enabled[];
CORE_EXPORT extern const char ValidTokenNotProvided[];
CORE_EXPORT extern const char OSNotSupported[];
CORE_EXPORT extern const char TrialNotAllowed[];
} // namespace OriginTrialStatusEnum

namespace OriginTrialUsageRestrictionEnum {
CORE_EXPORT extern const char None[];
CORE_EXPORT extern const char Subset[];
} // namespace OriginTrialUsageRestrictionEnum

namespace ClientNavigationReasonEnum {
CORE_EXPORT extern const char AnchorClick[];
CORE_EXPORT extern const char FormSubmissionGet[];
CORE_EXPORT extern const char FormSubmissionPost[];
CORE_EXPORT extern const char HttpHeaderRefresh[];
CORE_EXPORT extern const char InitialFrameNavigation[];
CORE_EXPORT extern const char MetaTagRefresh[];
CORE_EXPORT extern const char Other[];
CORE_EXPORT extern const char PageBlockInterstitial[];
CORE_EXPORT extern const char Reload[];
CORE_EXPORT extern const char ScriptInitiated[];
} // namespace ClientNavigationReasonEnum

namespace ClientNavigationDispositionEnum {
CORE_EXPORT extern const char CurrentTab[];
CORE_EXPORT extern const char NewTab[];
CORE_EXPORT extern const char NewWindow[];
CORE_EXPORT extern const char Download[];
} // namespace ClientNavigationDispositionEnum

namespace NavigationTypeEnum {
CORE_EXPORT extern const char Navigation[];
CORE_EXPORT extern const char BackForwardCacheRestore[];
} // namespace NavigationTypeEnum

namespace BackForwardCacheNotRestoredReasonEnum {
CORE_EXPORT extern const char NotPrimaryMainFrame[];
CORE_EXPORT extern const char BackForwardCacheDisabled[];
CORE_EXPORT extern const char RelatedActiveContentsExist[];
CORE_EXPORT extern const char HTTPStatusNotOK[];
CORE_EXPORT extern const char SchemeNotHTTPOrHTTPS[];
CORE_EXPORT extern const char Loading[];
CORE_EXPORT extern const char WasGrantedMediaAccess[];
CORE_EXPORT extern const char DisableForRenderFrameHostCalled[];
CORE_EXPORT extern const char DomainNotAllowed[];
CORE_EXPORT extern const char HTTPMethodNotGET[];
CORE_EXPORT extern const char SubframeIsNavigating[];
CORE_EXPORT extern const char Timeout[];
CORE_EXPORT extern const char CacheLimit[];
CORE_EXPORT extern const char JavaScriptExecution[];
CORE_EXPORT extern const char RendererProcessKilled[];
CORE_EXPORT extern const char RendererProcessCrashed[];
CORE_EXPORT extern const char SchedulerTrackedFeatureUsed[];
CORE_EXPORT extern const char ConflictingBrowsingInstance[];
CORE_EXPORT extern const char CacheFlushed[];
CORE_EXPORT extern const char ServiceWorkerVersionActivation[];
CORE_EXPORT extern const char SessionRestored[];
CORE_EXPORT extern const char ServiceWorkerPostMessage[];
CORE_EXPORT extern const char EnteredBackForwardCacheBeforeServiceWorkerHostAdded[];
CORE_EXPORT extern const char RenderFrameHostReused_SameSite[];
CORE_EXPORT extern const char RenderFrameHostReused_CrossSite[];
CORE_EXPORT extern const char ServiceWorkerClaim[];
CORE_EXPORT extern const char IgnoreEventAndEvict[];
CORE_EXPORT extern const char HaveInnerContents[];
CORE_EXPORT extern const char TimeoutPuttingInCache[];
CORE_EXPORT extern const char BackForwardCacheDisabledByLowMemory[];
CORE_EXPORT extern const char BackForwardCacheDisabledByCommandLine[];
CORE_EXPORT extern const char NetworkRequestDatapipeDrainedAsBytesConsumer[];
CORE_EXPORT extern const char NetworkRequestRedirected[];
CORE_EXPORT extern const char NetworkRequestTimeout[];
CORE_EXPORT extern const char NetworkExceedsBufferLimit[];
CORE_EXPORT extern const char NavigationCancelledWhileRestoring[];
CORE_EXPORT extern const char NotMostRecentNavigationEntry[];
CORE_EXPORT extern const char BackForwardCacheDisabledForPrerender[];
CORE_EXPORT extern const char UserAgentOverrideDiffers[];
CORE_EXPORT extern const char ForegroundCacheLimit[];
CORE_EXPORT extern const char BrowsingInstanceNotSwapped[];
CORE_EXPORT extern const char BackForwardCacheDisabledForDelegate[];
CORE_EXPORT extern const char UnloadHandlerExistsInMainFrame[];
CORE_EXPORT extern const char UnloadHandlerExistsInSubFrame[];
CORE_EXPORT extern const char ServiceWorkerUnregistration[];
CORE_EXPORT extern const char CacheControlNoStore[];
CORE_EXPORT extern const char CacheControlNoStoreCookieModified[];
CORE_EXPORT extern const char CacheControlNoStoreHTTPOnlyCookieModified[];
CORE_EXPORT extern const char NoResponseHead[];
CORE_EXPORT extern const char Unknown[];
CORE_EXPORT extern const char ActivationNavigationsDisallowedForBug1234857[];
CORE_EXPORT extern const char ErrorDocument[];
CORE_EXPORT extern const char FencedFramesEmbedder[];
CORE_EXPORT extern const char CookieDisabled[];
CORE_EXPORT extern const char HTTPAuthRequired[];
CORE_EXPORT extern const char CookieFlushed[];
CORE_EXPORT extern const char BroadcastChannelOnMessage[];
CORE_EXPORT extern const char WebViewSettingsChanged[];
CORE_EXPORT extern const char WebViewJavaScriptObjectChanged[];
CORE_EXPORT extern const char WebViewMessageListenerInjected[];
CORE_EXPORT extern const char WebViewSafeBrowsingAllowlistChanged[];
CORE_EXPORT extern const char WebViewDocumentStartJavascriptChanged[];
CORE_EXPORT extern const char WebSocket[];
CORE_EXPORT extern const char WebTransport[];
CORE_EXPORT extern const char WebRTC[];
CORE_EXPORT extern const char MainResourceHasCacheControlNoStore[];
CORE_EXPORT extern const char MainResourceHasCacheControlNoCache[];
CORE_EXPORT extern const char SubresourceHasCacheControlNoStore[];
CORE_EXPORT extern const char SubresourceHasCacheControlNoCache[];
CORE_EXPORT extern const char ContainsPlugins[];
CORE_EXPORT extern const char DocumentLoaded[];
CORE_EXPORT extern const char OutstandingNetworkRequestOthers[];
CORE_EXPORT extern const char RequestedMIDIPermission[];
CORE_EXPORT extern const char RequestedAudioCapturePermission[];
CORE_EXPORT extern const char RequestedVideoCapturePermission[];
CORE_EXPORT extern const char RequestedBackForwardCacheBlockedSensors[];
CORE_EXPORT extern const char RequestedBackgroundWorkPermission[];
CORE_EXPORT extern const char BroadcastChannel[];
CORE_EXPORT extern const char WebXR[];
CORE_EXPORT extern const char SharedWorker[];
CORE_EXPORT extern const char WebLocks[];
CORE_EXPORT extern const char WebHID[];
CORE_EXPORT extern const char WebShare[];
CORE_EXPORT extern const char RequestedStorageAccessGrant[];
CORE_EXPORT extern const char WebNfc[];
CORE_EXPORT extern const char OutstandingNetworkRequestFetch[];
CORE_EXPORT extern const char OutstandingNetworkRequestXHR[];
CORE_EXPORT extern const char AppBanner[];
CORE_EXPORT extern const char Printing[];
CORE_EXPORT extern const char WebDatabase[];
CORE_EXPORT extern const char PictureInPicture[];
CORE_EXPORT extern const char SpeechRecognizer[];
CORE_EXPORT extern const char IdleManager[];
CORE_EXPORT extern const char PaymentManager[];
CORE_EXPORT extern const char SpeechSynthesis[];
CORE_EXPORT extern const char KeyboardLock[];
CORE_EXPORT extern const char WebOTPService[];
CORE_EXPORT extern const char OutstandingNetworkRequestDirectSocket[];
CORE_EXPORT extern const char InjectedJavascript[];
CORE_EXPORT extern const char InjectedStyleSheet[];
CORE_EXPORT extern const char KeepaliveRequest[];
CORE_EXPORT extern const char IndexedDBEvent[];
CORE_EXPORT extern const char Dummy[];
CORE_EXPORT extern const char JsNetworkRequestReceivedCacheControlNoStoreResource[];
CORE_EXPORT extern const char WebRTCSticky[];
CORE_EXPORT extern const char WebTransportSticky[];
CORE_EXPORT extern const char WebSocketSticky[];
CORE_EXPORT extern const char SmartCard[];
CORE_EXPORT extern const char LiveMediaStreamTrack[];
CORE_EXPORT extern const char UnloadHandler[];
CORE_EXPORT extern const char ParserAborted[];
CORE_EXPORT extern const char ContentSecurityHandler[];
CORE_EXPORT extern const char ContentWebAuthenticationAPI[];
CORE_EXPORT extern const char ContentFileChooser[];
CORE_EXPORT extern const char ContentSerial[];
CORE_EXPORT extern const char ContentFileSystemAccess[];
CORE_EXPORT extern const char ContentMediaDevicesDispatcherHost[];
CORE_EXPORT extern const char ContentWebBluetooth[];
CORE_EXPORT extern const char ContentWebUSB[];
CORE_EXPORT extern const char ContentMediaSessionService[];
CORE_EXPORT extern const char ContentScreenReader[];
CORE_EXPORT extern const char ContentDiscarded[];
CORE_EXPORT extern const char EmbedderPopupBlockerTabHelper[];
CORE_EXPORT extern const char EmbedderSafeBrowsingTriggeredPopupBlocker[];
CORE_EXPORT extern const char EmbedderSafeBrowsingThreatDetails[];
CORE_EXPORT extern const char EmbedderAppBannerManager[];
CORE_EXPORT extern const char EmbedderDomDistillerViewerSource[];
CORE_EXPORT extern const char EmbedderDomDistillerSelfDeletingRequestDelegate[];
CORE_EXPORT extern const char EmbedderOomInterventionTabHelper[];
CORE_EXPORT extern const char EmbedderOfflinePage[];
CORE_EXPORT extern const char EmbedderChromePasswordManagerClientBindCredentialManager[];
CORE_EXPORT extern const char EmbedderPermissionRequestManager[];
CORE_EXPORT extern const char EmbedderModalDialog[];
CORE_EXPORT extern const char EmbedderExtensions[];
CORE_EXPORT extern const char EmbedderExtensionMessaging[];
CORE_EXPORT extern const char EmbedderExtensionMessagingForOpenPort[];
CORE_EXPORT extern const char EmbedderExtensionSentMessageToCachedFrame[];
CORE_EXPORT extern const char RequestedByWebViewClient[];
CORE_EXPORT extern const char PostMessageByWebViewClient[];
} // namespace BackForwardCacheNotRestoredReasonEnum

namespace BackForwardCacheNotRestoredReasonTypeEnum {
CORE_EXPORT extern const char SupportPending[];
CORE_EXPORT extern const char PageSupportNeeded[];
CORE_EXPORT extern const char Circumstantial[];
} // namespace BackForwardCacheNotRestoredReasonTypeEnum

namespace CaptureScreenshot {
namespace FormatEnum {
CORE_EXPORT extern const char* Jpeg;
CORE_EXPORT extern const char* Png;
CORE_EXPORT extern const char* Webp;
} // FormatEnum
} // CaptureScreenshot

namespace CaptureSnapshot {
namespace FormatEnum {
CORE_EXPORT extern const char* Mhtml;
} // FormatEnum
} // CaptureSnapshot

namespace PrintToPDF {
namespace TransferModeEnum {
CORE_EXPORT extern const char* ReturnAsBase64;
CORE_EXPORT extern const char* ReturnAsStream;
} // TransferModeEnum
} // PrintToPDF

namespace SetDownloadBehavior {
namespace BehaviorEnum {
CORE_EXPORT extern const char* Deny;
CORE_EXPORT extern const char* Allow;
CORE_EXPORT extern const char* Default;
} // BehaviorEnum
} // SetDownloadBehavior

namespace SetTouchEmulationEnabled {
namespace ConfigurationEnum {
CORE_EXPORT extern const char* Mobile;
CORE_EXPORT extern const char* Desktop;
} // ConfigurationEnum
} // SetTouchEmulationEnabled

namespace StartScreencast {
namespace FormatEnum {
CORE_EXPORT extern const char* Jpeg;
CORE_EXPORT extern const char* Png;
} // FormatEnum
} // StartScreencast

namespace SetWebLifecycleState {
namespace StateEnum {
CORE_EXPORT extern const char* Frozen;
CORE_EXPORT extern const char* Active;
} // StateEnum
} // SetWebLifecycleState

namespace FileChooserOpened {
namespace ModeEnum {
CORE_EXPORT extern const char* SelectSingle;
CORE_EXPORT extern const char* SelectMultiple;
} // ModeEnum
} // FileChooserOpened

namespace FrameDetached {
namespace ReasonEnum {
CORE_EXPORT extern const char* Remove;
CORE_EXPORT extern const char* Swap;
} // ReasonEnum
} // FrameDetached

namespace DownloadProgress {
namespace StateEnum {
CORE_EXPORT extern const char* InProgress;
CORE_EXPORT extern const char* Completed;
CORE_EXPORT extern const char* Canceled;
} // StateEnum
} // DownloadProgress

namespace NavigatedWithinDocument {
namespace NavigationTypeEnum {
CORE_EXPORT extern const char* Fragment;
CORE_EXPORT extern const char* HistoryApi;
CORE_EXPORT extern const char* Other;
} // NavigationTypeEnum
} // NavigatedWithinDocument

// ------------- Type and builder declarations.

class CORE_EXPORT AdFrameStatus : public ::crdtp::ProtocolObject<AdFrameStatus> {
public:
    ~AdFrameStatus() override
    {
    }

    String getAdFrameType()
    {
        return m_adFrameType;
    }
    void setAdFrameType(const String& value)
    {
        m_adFrameType = value;
    }

    bool hasExplanations()
    {
        return m_explanations.has_value();
    }
    protocol::Array<String>* getExplanations(protocol::Array<String>* defaultValue)
    {
        return m_explanations.has_value() ? &m_explanations.value() : defaultValue;
    }
    void setExplanations(std::unique_ptr<protocol::Array<String>> value)
    {
        m_explanations = std::move(value);
    }

    template <int STATE> class AdFrameStatusBuilder {
    public:
        enum { NoFieldsSet = 0, AdFrameTypeSet = 1 << 1, AllFieldsSet = (AdFrameTypeSet | 0) };

        AdFrameStatusBuilder<STATE | AdFrameTypeSet>& setAdFrameType(const String& value)
        {
            static_assert(!(STATE & AdFrameTypeSet), "property adFrameType should not be set yet");
            m_result->setAdFrameType(value);
            return castState<AdFrameTypeSet>();
        }

        AdFrameStatusBuilder<STATE>& setExplanations(std::unique_ptr<protocol::Array<String>> value)
        {
            m_result->setExplanations(std::move(value));
            return *this;
        }

        std::unique_ptr<AdFrameStatus> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class AdFrameStatus;
        AdFrameStatusBuilder()
            : m_result(new AdFrameStatus())
        {
        }

        template <int STEP> AdFrameStatusBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<AdFrameStatusBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Page::AdFrameStatus> m_result;
    };

    static AdFrameStatusBuilder<0> create()
    {
        return AdFrameStatusBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    AdFrameStatus()
    {
    }

    String m_adFrameType;
    Maybe<protocol::Array<String>> m_explanations;
};

class CORE_EXPORT AdScriptId : public ::crdtp::ProtocolObject<AdScriptId> {
public:
    ~AdScriptId() override
    {
    }

    String getScriptId()
    {
        return m_scriptId;
    }
    void setScriptId(const String& value)
    {
        m_scriptId = value;
    }

    String getDebuggerId()
    {
        return m_debuggerId;
    }
    void setDebuggerId(const String& value)
    {
        m_debuggerId = value;
    }

    template <int STATE> class AdScriptIdBuilder {
    public:
        enum { NoFieldsSet = 0, ScriptIdSet = 1 << 1, DebuggerIdSet = 1 << 2, AllFieldsSet = (ScriptIdSet | DebuggerIdSet | 0) };

        AdScriptIdBuilder<STATE | ScriptIdSet>& setScriptId(const String& value)
        {
            static_assert(!(STATE & ScriptIdSet), "property scriptId should not be set yet");
            m_result->setScriptId(value);
            return castState<ScriptIdSet>();
        }

        AdScriptIdBuilder<STATE | DebuggerIdSet>& setDebuggerId(const String& value)
        {
            static_assert(!(STATE & DebuggerIdSet), "property debuggerId should not be set yet");
            m_result->setDebuggerId(value);
            return castState<DebuggerIdSet>();
        }

        std::unique_ptr<AdScriptId> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class AdScriptId;
        AdScriptIdBuilder()
            : m_result(new AdScriptId())
        {
        }

        template <int STEP> AdScriptIdBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<AdScriptIdBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Page::AdScriptId> m_result;
    };

    static AdScriptIdBuilder<0> create()
    {
        return AdScriptIdBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    AdScriptId()
    {
    }

    String m_scriptId;
    String m_debuggerId;
};

class CORE_EXPORT PermissionsPolicyBlockLocator : public ::crdtp::ProtocolObject<PermissionsPolicyBlockLocator> {
public:
    ~PermissionsPolicyBlockLocator() override
    {
    }

    String getFrameId()
    {
        return m_frameId;
    }
    void setFrameId(const String& value)
    {
        m_frameId = value;
    }

    String getBlockReason()
    {
        return m_blockReason;
    }
    void setBlockReason(const String& value)
    {
        m_blockReason = value;
    }

    template <int STATE> class PermissionsPolicyBlockLocatorBuilder {
    public:
        enum { NoFieldsSet = 0, FrameIdSet = 1 << 1, BlockReasonSet = 1 << 2, AllFieldsSet = (FrameIdSet | BlockReasonSet | 0) };

        PermissionsPolicyBlockLocatorBuilder<STATE | FrameIdSet>& setFrameId(const String& value)
        {
            static_assert(!(STATE & FrameIdSet), "property frameId should not be set yet");
            m_result->setFrameId(value);
            return castState<FrameIdSet>();
        }

        PermissionsPolicyBlockLocatorBuilder<STATE | BlockReasonSet>& setBlockReason(const String& value)
        {
            static_assert(!(STATE & BlockReasonSet), "property blockReason should not be set yet");
            m_result->setBlockReason(value);
            return castState<BlockReasonSet>();
        }

        std::unique_ptr<PermissionsPolicyBlockLocator> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class PermissionsPolicyBlockLocator;
        PermissionsPolicyBlockLocatorBuilder()
            : m_result(new PermissionsPolicyBlockLocator())
        {
        }

        template <int STEP> PermissionsPolicyBlockLocatorBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<PermissionsPolicyBlockLocatorBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Page::PermissionsPolicyBlockLocator> m_result;
    };

    static PermissionsPolicyBlockLocatorBuilder<0> create()
    {
        return PermissionsPolicyBlockLocatorBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    PermissionsPolicyBlockLocator()
    {
    }

    String m_frameId;
    String m_blockReason;
};

class CORE_EXPORT PermissionsPolicyFeatureState : public ::crdtp::ProtocolObject<PermissionsPolicyFeatureState> {
public:
    ~PermissionsPolicyFeatureState() override
    {
    }

    String getFeature()
    {
        return m_feature;
    }
    void setFeature(const String& value)
    {
        m_feature = value;
    }

    bool getAllowed()
    {
        return m_allowed;
    }
    void setAllowed(bool value)
    {
        m_allowed = value;
    }

    bool hasLocator()
    {
        return m_locator.has_value();
    }
    protocol::Page::PermissionsPolicyBlockLocator* getLocator(protocol::Page::PermissionsPolicyBlockLocator* defaultValue)
    {
        return m_locator.has_value() ? &m_locator.value() : defaultValue;
    }
    void setLocator(std::unique_ptr<protocol::Page::PermissionsPolicyBlockLocator> value)
    {
        m_locator = std::move(value);
    }

    template <int STATE> class PermissionsPolicyFeatureStateBuilder {
    public:
        enum { NoFieldsSet = 0, FeatureSet = 1 << 1, AllowedSet = 1 << 2, AllFieldsSet = (FeatureSet | AllowedSet | 0) };

        PermissionsPolicyFeatureStateBuilder<STATE | FeatureSet>& setFeature(const String& value)
        {
            static_assert(!(STATE & FeatureSet), "property feature should not be set yet");
            m_result->setFeature(value);
            return castState<FeatureSet>();
        }

        PermissionsPolicyFeatureStateBuilder<STATE | AllowedSet>& setAllowed(bool value)
        {
            static_assert(!(STATE & AllowedSet), "property allowed should not be set yet");
            m_result->setAllowed(value);
            return castState<AllowedSet>();
        }

        PermissionsPolicyFeatureStateBuilder<STATE>& setLocator(std::unique_ptr<protocol::Page::PermissionsPolicyBlockLocator> value)
        {
            m_result->setLocator(std::move(value));
            return *this;
        }

        std::unique_ptr<PermissionsPolicyFeatureState> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class PermissionsPolicyFeatureState;
        PermissionsPolicyFeatureStateBuilder()
            : m_result(new PermissionsPolicyFeatureState())
        {
        }

        template <int STEP> PermissionsPolicyFeatureStateBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<PermissionsPolicyFeatureStateBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Page::PermissionsPolicyFeatureState> m_result;
    };

    static PermissionsPolicyFeatureStateBuilder<0> create()
    {
        return PermissionsPolicyFeatureStateBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    PermissionsPolicyFeatureState()
    {
        m_allowed = false;
    }

    String m_feature;
    bool m_allowed;
    Maybe<protocol::Page::PermissionsPolicyBlockLocator> m_locator;
};

class CORE_EXPORT OriginTrialToken : public ::crdtp::ProtocolObject<OriginTrialToken> {
public:
    ~OriginTrialToken() override
    {
    }

    String getOrigin()
    {
        return m_origin;
    }
    void setOrigin(const String& value)
    {
        m_origin = value;
    }

    bool getMatchSubDomains()
    {
        return m_matchSubDomains;
    }
    void setMatchSubDomains(bool value)
    {
        m_matchSubDomains = value;
    }

    String getTrialName()
    {
        return m_trialName;
    }
    void setTrialName(const String& value)
    {
        m_trialName = value;
    }

    double getExpiryTime()
    {
        return m_expiryTime;
    }
    void setExpiryTime(double value)
    {
        m_expiryTime = value;
    }

    bool getIsThirdParty()
    {
        return m_isThirdParty;
    }
    void setIsThirdParty(bool value)
    {
        m_isThirdParty = value;
    }

    String getUsageRestriction()
    {
        return m_usageRestriction;
    }
    void setUsageRestriction(const String& value)
    {
        m_usageRestriction = value;
    }

    template <int STATE> class OriginTrialTokenBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            OriginSet = 1 << 1,
            MatchSubDomainsSet = 1 << 2,
            TrialNameSet = 1 << 3,
            ExpiryTimeSet = 1 << 4,
            IsThirdPartySet = 1 << 5,
            UsageRestrictionSet = 1 << 6,
            AllFieldsSet = (OriginSet | MatchSubDomainsSet | TrialNameSet | ExpiryTimeSet | IsThirdPartySet | UsageRestrictionSet | 0)
        };

        OriginTrialTokenBuilder<STATE | OriginSet>& setOrigin(const String& value)
        {
            static_assert(!(STATE & OriginSet), "property origin should not be set yet");
            m_result->setOrigin(value);
            return castState<OriginSet>();
        }

        OriginTrialTokenBuilder<STATE | MatchSubDomainsSet>& setMatchSubDomains(bool value)
        {
            static_assert(!(STATE & MatchSubDomainsSet), "property matchSubDomains should not be set yet");
            m_result->setMatchSubDomains(value);
            return castState<MatchSubDomainsSet>();
        }

        OriginTrialTokenBuilder<STATE | TrialNameSet>& setTrialName(const String& value)
        {
            static_assert(!(STATE & TrialNameSet), "property trialName should not be set yet");
            m_result->setTrialName(value);
            return castState<TrialNameSet>();
        }

        OriginTrialTokenBuilder<STATE | ExpiryTimeSet>& setExpiryTime(double value)
        {
            static_assert(!(STATE & ExpiryTimeSet), "property expiryTime should not be set yet");
            m_result->setExpiryTime(value);
            return castState<ExpiryTimeSet>();
        }

        OriginTrialTokenBuilder<STATE | IsThirdPartySet>& setIsThirdParty(bool value)
        {
            static_assert(!(STATE & IsThirdPartySet), "property isThirdParty should not be set yet");
            m_result->setIsThirdParty(value);
            return castState<IsThirdPartySet>();
        }

        OriginTrialTokenBuilder<STATE | UsageRestrictionSet>& setUsageRestriction(const String& value)
        {
            static_assert(!(STATE & UsageRestrictionSet), "property usageRestriction should not be set yet");
            m_result->setUsageRestriction(value);
            return castState<UsageRestrictionSet>();
        }

        std::unique_ptr<OriginTrialToken> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class OriginTrialToken;
        OriginTrialTokenBuilder()
            : m_result(new OriginTrialToken())
        {
        }

        template <int STEP> OriginTrialTokenBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<OriginTrialTokenBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Page::OriginTrialToken> m_result;
    };

    static OriginTrialTokenBuilder<0> create()
    {
        return OriginTrialTokenBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    OriginTrialToken()
    {
        m_matchSubDomains = false;
        m_expiryTime = 0;
        m_isThirdParty = false;
    }

    String m_origin;
    bool m_matchSubDomains;
    String m_trialName;
    double m_expiryTime;
    bool m_isThirdParty;
    String m_usageRestriction;
};

class CORE_EXPORT OriginTrialTokenWithStatus : public ::crdtp::ProtocolObject<OriginTrialTokenWithStatus> {
public:
    ~OriginTrialTokenWithStatus() override
    {
    }

    String getRawTokenText()
    {
        return m_rawTokenText;
    }
    void setRawTokenText(const String& value)
    {
        m_rawTokenText = value;
    }

    bool hasParsedToken()
    {
        return m_parsedToken.has_value();
    }
    protocol::Page::OriginTrialToken* getParsedToken(protocol::Page::OriginTrialToken* defaultValue)
    {
        return m_parsedToken.has_value() ? &m_parsedToken.value() : defaultValue;
    }
    void setParsedToken(std::unique_ptr<protocol::Page::OriginTrialToken> value)
    {
        m_parsedToken = std::move(value);
    }

    String getStatus()
    {
        return m_status;
    }
    void setStatus(const String& value)
    {
        m_status = value;
    }

    template <int STATE> class OriginTrialTokenWithStatusBuilder {
    public:
        enum { NoFieldsSet = 0, RawTokenTextSet = 1 << 1, StatusSet = 1 << 2, AllFieldsSet = (RawTokenTextSet | StatusSet | 0) };

        OriginTrialTokenWithStatusBuilder<STATE | RawTokenTextSet>& setRawTokenText(const String& value)
        {
            static_assert(!(STATE & RawTokenTextSet), "property rawTokenText should not be set yet");
            m_result->setRawTokenText(value);
            return castState<RawTokenTextSet>();
        }

        OriginTrialTokenWithStatusBuilder<STATE>& setParsedToken(std::unique_ptr<protocol::Page::OriginTrialToken> value)
        {
            m_result->setParsedToken(std::move(value));
            return *this;
        }

        OriginTrialTokenWithStatusBuilder<STATE | StatusSet>& setStatus(const String& value)
        {
            static_assert(!(STATE & StatusSet), "property status should not be set yet");
            m_result->setStatus(value);
            return castState<StatusSet>();
        }

        std::unique_ptr<OriginTrialTokenWithStatus> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class OriginTrialTokenWithStatus;
        OriginTrialTokenWithStatusBuilder()
            : m_result(new OriginTrialTokenWithStatus())
        {
        }

        template <int STEP> OriginTrialTokenWithStatusBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<OriginTrialTokenWithStatusBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Page::OriginTrialTokenWithStatus> m_result;
    };

    static OriginTrialTokenWithStatusBuilder<0> create()
    {
        return OriginTrialTokenWithStatusBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    OriginTrialTokenWithStatus()
    {
    }

    String m_rawTokenText;
    Maybe<protocol::Page::OriginTrialToken> m_parsedToken;
    String m_status;
};

class CORE_EXPORT OriginTrial : public ::crdtp::ProtocolObject<OriginTrial> {
public:
    ~OriginTrial() override
    {
    }

    String getTrialName()
    {
        return m_trialName;
    }
    void setTrialName(const String& value)
    {
        m_trialName = value;
    }

    String getStatus()
    {
        return m_status;
    }
    void setStatus(const String& value)
    {
        m_status = value;
    }

    protocol::Array<protocol::Page::OriginTrialTokenWithStatus>* getTokensWithStatus()
    {
        return m_tokensWithStatus.get();
    }
    void setTokensWithStatus(std::unique_ptr<protocol::Array<protocol::Page::OriginTrialTokenWithStatus>> value)
    {
        m_tokensWithStatus = std::move(value);
    }

    template <int STATE> class OriginTrialBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            TrialNameSet = 1 << 1,
            StatusSet = 1 << 2,
            TokensWithStatusSet = 1 << 3,
            AllFieldsSet = (TrialNameSet | StatusSet | TokensWithStatusSet | 0)
        };

        OriginTrialBuilder<STATE | TrialNameSet>& setTrialName(const String& value)
        {
            static_assert(!(STATE & TrialNameSet), "property trialName should not be set yet");
            m_result->setTrialName(value);
            return castState<TrialNameSet>();
        }

        OriginTrialBuilder<STATE | StatusSet>& setStatus(const String& value)
        {
            static_assert(!(STATE & StatusSet), "property status should not be set yet");
            m_result->setStatus(value);
            return castState<StatusSet>();
        }

        OriginTrialBuilder<STATE | TokensWithStatusSet>& setTokensWithStatus(std::unique_ptr<protocol::Array<protocol::Page::OriginTrialTokenWithStatus>> value)
        {
            static_assert(!(STATE & TokensWithStatusSet), "property tokensWithStatus should not be set yet");
            m_result->setTokensWithStatus(std::move(value));
            return castState<TokensWithStatusSet>();
        }

        std::unique_ptr<OriginTrial> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class OriginTrial;
        OriginTrialBuilder()
            : m_result(new OriginTrial())
        {
        }

        template <int STEP> OriginTrialBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<OriginTrialBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Page::OriginTrial> m_result;
    };

    static OriginTrialBuilder<0> create()
    {
        return OriginTrialBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    OriginTrial()
    {
    }

    String m_trialName;
    String m_status;
    std::unique_ptr<protocol::Array<protocol::Page::OriginTrialTokenWithStatus>> m_tokensWithStatus;
};

class CORE_EXPORT Frame : public ::crdtp::ProtocolObject<Frame> {
public:
    ~Frame() override
    {
    }

    String getId()
    {
        return m_id;
    }
    void setId(const String& value)
    {
        m_id = value;
    }

    bool hasParentId()
    {
        return m_parentId.has_value();
    }
    String getParentId(const String& defaultValue) const
    {
        return m_parentId.value_or(defaultValue);
    }
    void setParentId(const String& value)
    {
        m_parentId = value;
    }

    String getLoaderId()
    {
        return m_loaderId;
    }
    void setLoaderId(const String& value)
    {
        m_loaderId = value;
    }

    bool hasName()
    {
        return m_name.has_value();
    }
    String getName(const String& defaultValue) const
    {
        return m_name.value_or(defaultValue);
    }
    void setName(const String& value)
    {
        m_name = value;
    }

    String getUrl()
    {
        return m_url;
    }
    void setUrl(const String& value)
    {
        m_url = value;
    }

    bool hasUrlFragment()
    {
        return m_urlFragment.has_value();
    }
    String getUrlFragment(const String& defaultValue) const
    {
        return m_urlFragment.value_or(defaultValue);
    }
    void setUrlFragment(const String& value)
    {
        m_urlFragment = value;
    }

    String getDomainAndRegistry()
    {
        return m_domainAndRegistry;
    }
    void setDomainAndRegistry(const String& value)
    {
        m_domainAndRegistry = value;
    }

    String getSecurityOrigin()
    {
        return m_securityOrigin;
    }
    void setSecurityOrigin(const String& value)
    {
        m_securityOrigin = value;
    }

    String getMimeType()
    {
        return m_mimeType;
    }
    void setMimeType(const String& value)
    {
        m_mimeType = value;
    }

    bool hasUnreachableUrl()
    {
        return m_unreachableUrl.has_value();
    }
    String getUnreachableUrl(const String& defaultValue) const
    {
        return m_unreachableUrl.value_or(defaultValue);
    }
    void setUnreachableUrl(const String& value)
    {
        m_unreachableUrl = value;
    }

    bool hasAdFrameStatus()
    {
        return m_adFrameStatus.has_value();
    }
    protocol::Page::AdFrameStatus* getAdFrameStatus(protocol::Page::AdFrameStatus* defaultValue)
    {
        return m_adFrameStatus.has_value() ? &m_adFrameStatus.value() : defaultValue;
    }
    void setAdFrameStatus(std::unique_ptr<protocol::Page::AdFrameStatus> value)
    {
        m_adFrameStatus = std::move(value);
    }

    String getSecureContextType()
    {
        return m_secureContextType;
    }
    void setSecureContextType(const String& value)
    {
        m_secureContextType = value;
    }

    String getCrossOriginIsolatedContextType()
    {
        return m_crossOriginIsolatedContextType;
    }
    void setCrossOriginIsolatedContextType(const String& value)
    {
        m_crossOriginIsolatedContextType = value;
    }

    protocol::Array<String>* getGatedAPIFeatures()
    {
        return m_gatedAPIFeatures.get();
    }
    void setGatedAPIFeatures(std::unique_ptr<protocol::Array<String>> value)
    {
        m_gatedAPIFeatures = std::move(value);
    }

    template <int STATE> class FrameBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            IdSet = 1 << 1,
            LoaderIdSet = 1 << 2,
            UrlSet = 1 << 3,
            DomainAndRegistrySet = 1 << 4,
            SecurityOriginSet = 1 << 5,
            MimeTypeSet = 1 << 6,
            SecureContextTypeSet = 1 << 7,
            CrossOriginIsolatedContextTypeSet = 1 << 8,
            GatedAPIFeaturesSet = 1 << 9,
            AllFieldsSet = (IdSet | LoaderIdSet | UrlSet | DomainAndRegistrySet | SecurityOriginSet | MimeTypeSet | SecureContextTypeSet
                | CrossOriginIsolatedContextTypeSet | GatedAPIFeaturesSet | 0)
        };

        FrameBuilder<STATE | IdSet>& setId(const String& value)
        {
            static_assert(!(STATE & IdSet), "property id should not be set yet");
            m_result->setId(value);
            return castState<IdSet>();
        }

        FrameBuilder<STATE>& setParentId(const String& value)
        {
            m_result->setParentId(value);
            return *this;
        }

        FrameBuilder<STATE | LoaderIdSet>& setLoaderId(const String& value)
        {
            static_assert(!(STATE & LoaderIdSet), "property loaderId should not be set yet");
            m_result->setLoaderId(value);
            return castState<LoaderIdSet>();
        }

        FrameBuilder<STATE>& setName(const String& value)
        {
            m_result->setName(value);
            return *this;
        }

        FrameBuilder<STATE | UrlSet>& setUrl(const String& value)
        {
            static_assert(!(STATE & UrlSet), "property url should not be set yet");
            m_result->setUrl(value);
            return castState<UrlSet>();
        }

        FrameBuilder<STATE>& setUrlFragment(const String& value)
        {
            m_result->setUrlFragment(value);
            return *this;
        }

        FrameBuilder<STATE | DomainAndRegistrySet>& setDomainAndRegistry(const String& value)
        {
            static_assert(!(STATE & DomainAndRegistrySet), "property domainAndRegistry should not be set yet");
            m_result->setDomainAndRegistry(value);
            return castState<DomainAndRegistrySet>();
        }

        FrameBuilder<STATE | SecurityOriginSet>& setSecurityOrigin(const String& value)
        {
            static_assert(!(STATE & SecurityOriginSet), "property securityOrigin should not be set yet");
            m_result->setSecurityOrigin(value);
            return castState<SecurityOriginSet>();
        }

        FrameBuilder<STATE | MimeTypeSet>& setMimeType(const String& value)
        {
            static_assert(!(STATE & MimeTypeSet), "property mimeType should not be set yet");
            m_result->setMimeType(value);
            return castState<MimeTypeSet>();
        }

        FrameBuilder<STATE>& setUnreachableUrl(const String& value)
        {
            m_result->setUnreachableUrl(value);
            return *this;
        }

        FrameBuilder<STATE>& setAdFrameStatus(std::unique_ptr<protocol::Page::AdFrameStatus> value)
        {
            m_result->setAdFrameStatus(std::move(value));
            return *this;
        }

        FrameBuilder<STATE | SecureContextTypeSet>& setSecureContextType(const String& value)
        {
            static_assert(!(STATE & SecureContextTypeSet), "property secureContextType should not be set yet");
            m_result->setSecureContextType(value);
            return castState<SecureContextTypeSet>();
        }

        FrameBuilder<STATE | CrossOriginIsolatedContextTypeSet>& setCrossOriginIsolatedContextType(const String& value)
        {
            static_assert(!(STATE & CrossOriginIsolatedContextTypeSet), "property crossOriginIsolatedContextType should not be set yet");
            m_result->setCrossOriginIsolatedContextType(value);
            return castState<CrossOriginIsolatedContextTypeSet>();
        }

        FrameBuilder<STATE | GatedAPIFeaturesSet>& setGatedAPIFeatures(std::unique_ptr<protocol::Array<String>> value)
        {
            static_assert(!(STATE & GatedAPIFeaturesSet), "property gatedAPIFeatures should not be set yet");
            m_result->setGatedAPIFeatures(std::move(value));
            return castState<GatedAPIFeaturesSet>();
        }

        std::unique_ptr<Frame> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class Frame;
        FrameBuilder()
            : m_result(new Frame())
        {
        }

        template <int STEP> FrameBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<FrameBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Page::Frame> m_result;
    };

    static FrameBuilder<0> create()
    {
        return FrameBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    Frame()
    {
    }

    String m_id;
    Maybe<String> m_parentId;
    String m_loaderId;
    Maybe<String> m_name;
    String m_url;
    Maybe<String> m_urlFragment;
    String m_domainAndRegistry;
    String m_securityOrigin;
    String m_mimeType;
    Maybe<String> m_unreachableUrl;
    Maybe<protocol::Page::AdFrameStatus> m_adFrameStatus;
    String m_secureContextType;
    String m_crossOriginIsolatedContextType;
    std::unique_ptr<protocol::Array<String>> m_gatedAPIFeatures;
};

class CORE_EXPORT FrameResource : public ::crdtp::ProtocolObject<FrameResource> {
public:
    ~FrameResource() override
    {
    }

    String getUrl()
    {
        return m_url;
    }
    void setUrl(const String& value)
    {
        m_url = value;
    }

    String getType()
    {
        return m_type;
    }
    void setType(const String& value)
    {
        m_type = value;
    }

    String getMimeType()
    {
        return m_mimeType;
    }
    void setMimeType(const String& value)
    {
        m_mimeType = value;
    }

    bool hasLastModified()
    {
        return m_lastModified.has_value();
    }
    double getLastModified(double defaultValue) const
    {
        return m_lastModified.value_or(defaultValue);
    }
    void setLastModified(double value)
    {
        m_lastModified = value;
    }

    bool hasContentSize()
    {
        return m_contentSize.has_value();
    }
    double getContentSize(double defaultValue) const
    {
        return m_contentSize.value_or(defaultValue);
    }
    void setContentSize(double value)
    {
        m_contentSize = value;
    }

    bool hasFailed()
    {
        return m_failed.has_value();
    }
    bool getFailed(bool defaultValue) const
    {
        return m_failed.value_or(defaultValue);
    }
    void setFailed(bool value)
    {
        m_failed = value;
    }

    bool hasCanceled()
    {
        return m_canceled.has_value();
    }
    bool getCanceled(bool defaultValue) const
    {
        return m_canceled.value_or(defaultValue);
    }
    void setCanceled(bool value)
    {
        m_canceled = value;
    }

    template <int STATE> class FrameResourceBuilder {
    public:
        enum { NoFieldsSet = 0, UrlSet = 1 << 1, TypeSet = 1 << 2, MimeTypeSet = 1 << 3, AllFieldsSet = (UrlSet | TypeSet | MimeTypeSet | 0) };

        FrameResourceBuilder<STATE | UrlSet>& setUrl(const String& value)
        {
            static_assert(!(STATE & UrlSet), "property url should not be set yet");
            m_result->setUrl(value);
            return castState<UrlSet>();
        }

        FrameResourceBuilder<STATE | TypeSet>& setType(const String& value)
        {
            static_assert(!(STATE & TypeSet), "property type should not be set yet");
            m_result->setType(value);
            return castState<TypeSet>();
        }

        FrameResourceBuilder<STATE | MimeTypeSet>& setMimeType(const String& value)
        {
            static_assert(!(STATE & MimeTypeSet), "property mimeType should not be set yet");
            m_result->setMimeType(value);
            return castState<MimeTypeSet>();
        }

        FrameResourceBuilder<STATE>& setLastModified(double value)
        {
            m_result->setLastModified(value);
            return *this;
        }

        FrameResourceBuilder<STATE>& setContentSize(double value)
        {
            m_result->setContentSize(value);
            return *this;
        }

        FrameResourceBuilder<STATE>& setFailed(bool value)
        {
            m_result->setFailed(value);
            return *this;
        }

        FrameResourceBuilder<STATE>& setCanceled(bool value)
        {
            m_result->setCanceled(value);
            return *this;
        }

        std::unique_ptr<FrameResource> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class FrameResource;
        FrameResourceBuilder()
            : m_result(new FrameResource())
        {
        }

        template <int STEP> FrameResourceBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<FrameResourceBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Page::FrameResource> m_result;
    };

    static FrameResourceBuilder<0> create()
    {
        return FrameResourceBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    FrameResource()
    {
    }

    String m_url;
    String m_type;
    String m_mimeType;
    Maybe<double> m_lastModified;
    Maybe<double> m_contentSize;
    Maybe<bool> m_failed;
    Maybe<bool> m_canceled;
};

class CORE_EXPORT FrameResourceTree : public ::crdtp::ProtocolObject<FrameResourceTree> {
public:
    ~FrameResourceTree() override
    {
    }

    protocol::Page::Frame* getFrame()
    {
        return m_frame.get();
    }
    void setFrame(std::unique_ptr<protocol::Page::Frame> value)
    {
        m_frame = std::move(value);
    }

    bool hasChildFrames()
    {
        return m_childFrames.has_value();
    }
    protocol::Array<protocol::Page::FrameResourceTree>* getChildFrames(protocol::Array<protocol::Page::FrameResourceTree>* defaultValue)
    {
        return m_childFrames.has_value() ? &m_childFrames.value() : defaultValue;
    }
    void setChildFrames(std::unique_ptr<protocol::Array<protocol::Page::FrameResourceTree>> value)
    {
        m_childFrames = std::move(value);
    }

    protocol::Array<protocol::Page::FrameResource>* getResources()
    {
        return m_resources.get();
    }
    void setResources(std::unique_ptr<protocol::Array<protocol::Page::FrameResource>> value)
    {
        m_resources = std::move(value);
    }

    template <int STATE> class FrameResourceTreeBuilder {
    public:
        enum { NoFieldsSet = 0, FrameSet = 1 << 1, ResourcesSet = 1 << 2, AllFieldsSet = (FrameSet | ResourcesSet | 0) };

        FrameResourceTreeBuilder<STATE | FrameSet>& setFrame(std::unique_ptr<protocol::Page::Frame> value)
        {
            static_assert(!(STATE & FrameSet), "property frame should not be set yet");
            m_result->setFrame(std::move(value));
            return castState<FrameSet>();
        }

        FrameResourceTreeBuilder<STATE>& setChildFrames(std::unique_ptr<protocol::Array<protocol::Page::FrameResourceTree>> value)
        {
            m_result->setChildFrames(std::move(value));
            return *this;
        }

        FrameResourceTreeBuilder<STATE | ResourcesSet>& setResources(std::unique_ptr<protocol::Array<protocol::Page::FrameResource>> value)
        {
            static_assert(!(STATE & ResourcesSet), "property resources should not be set yet");
            m_result->setResources(std::move(value));
            return castState<ResourcesSet>();
        }

        std::unique_ptr<FrameResourceTree> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class FrameResourceTree;
        FrameResourceTreeBuilder()
            : m_result(new FrameResourceTree())
        {
        }

        template <int STEP> FrameResourceTreeBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<FrameResourceTreeBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Page::FrameResourceTree> m_result;
    };

    static FrameResourceTreeBuilder<0> create()
    {
        return FrameResourceTreeBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    FrameResourceTree()
    {
    }

    std::unique_ptr<protocol::Page::Frame> m_frame;
    Maybe<protocol::Array<protocol::Page::FrameResourceTree>> m_childFrames;
    std::unique_ptr<protocol::Array<protocol::Page::FrameResource>> m_resources;
};

class CORE_EXPORT FrameTree : public ::crdtp::ProtocolObject<FrameTree> {
public:
    ~FrameTree() override
    {
    }

    protocol::Page::Frame* getFrame()
    {
        return m_frame.get();
    }
    void setFrame(std::unique_ptr<protocol::Page::Frame> value)
    {
        m_frame = std::move(value);
    }

    bool hasChildFrames()
    {
        return m_childFrames.has_value();
    }
    protocol::Array<protocol::Page::FrameTree>* getChildFrames(protocol::Array<protocol::Page::FrameTree>* defaultValue)
    {
        return m_childFrames.has_value() ? &m_childFrames.value() : defaultValue;
    }
    void setChildFrames(std::unique_ptr<protocol::Array<protocol::Page::FrameTree>> value)
    {
        m_childFrames = std::move(value);
    }

    template <int STATE> class FrameTreeBuilder {
    public:
        enum { NoFieldsSet = 0, FrameSet = 1 << 1, AllFieldsSet = (FrameSet | 0) };

        FrameTreeBuilder<STATE | FrameSet>& setFrame(std::unique_ptr<protocol::Page::Frame> value)
        {
            static_assert(!(STATE & FrameSet), "property frame should not be set yet");
            m_result->setFrame(std::move(value));
            return castState<FrameSet>();
        }

        FrameTreeBuilder<STATE>& setChildFrames(std::unique_ptr<protocol::Array<protocol::Page::FrameTree>> value)
        {
            m_result->setChildFrames(std::move(value));
            return *this;
        }

        std::unique_ptr<FrameTree> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class FrameTree;
        FrameTreeBuilder()
            : m_result(new FrameTree())
        {
        }

        template <int STEP> FrameTreeBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<FrameTreeBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Page::FrameTree> m_result;
    };

    static FrameTreeBuilder<0> create()
    {
        return FrameTreeBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    FrameTree()
    {
    }

    std::unique_ptr<protocol::Page::Frame> m_frame;
    Maybe<protocol::Array<protocol::Page::FrameTree>> m_childFrames;
};

class CORE_EXPORT LayoutViewport : public ::crdtp::ProtocolObject<LayoutViewport> {
public:
    ~LayoutViewport() override
    {
    }

    int getPageX()
    {
        return m_pageX;
    }
    void setPageX(int value)
    {
        m_pageX = value;
    }

    int getPageY()
    {
        return m_pageY;
    }
    void setPageY(int value)
    {
        m_pageY = value;
    }

    int getClientWidth()
    {
        return m_clientWidth;
    }
    void setClientWidth(int value)
    {
        m_clientWidth = value;
    }

    int getClientHeight()
    {
        return m_clientHeight;
    }
    void setClientHeight(int value)
    {
        m_clientHeight = value;
    }

    template <int STATE> class LayoutViewportBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            PageXSet = 1 << 1,
            PageYSet = 1 << 2,
            ClientWidthSet = 1 << 3,
            ClientHeightSet = 1 << 4,
            AllFieldsSet = (PageXSet | PageYSet | ClientWidthSet | ClientHeightSet | 0)
        };

        LayoutViewportBuilder<STATE | PageXSet>& setPageX(int value)
        {
            static_assert(!(STATE & PageXSet), "property pageX should not be set yet");
            m_result->setPageX(value);
            return castState<PageXSet>();
        }

        LayoutViewportBuilder<STATE | PageYSet>& setPageY(int value)
        {
            static_assert(!(STATE & PageYSet), "property pageY should not be set yet");
            m_result->setPageY(value);
            return castState<PageYSet>();
        }

        LayoutViewportBuilder<STATE | ClientWidthSet>& setClientWidth(int value)
        {
            static_assert(!(STATE & ClientWidthSet), "property clientWidth should not be set yet");
            m_result->setClientWidth(value);
            return castState<ClientWidthSet>();
        }

        LayoutViewportBuilder<STATE | ClientHeightSet>& setClientHeight(int value)
        {
            static_assert(!(STATE & ClientHeightSet), "property clientHeight should not be set yet");
            m_result->setClientHeight(value);
            return castState<ClientHeightSet>();
        }

        std::unique_ptr<LayoutViewport> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class LayoutViewport;
        LayoutViewportBuilder()
            : m_result(new LayoutViewport())
        {
        }

        template <int STEP> LayoutViewportBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<LayoutViewportBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Page::LayoutViewport> m_result;
    };

    static LayoutViewportBuilder<0> create()
    {
        return LayoutViewportBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    LayoutViewport()
    {
        m_pageX = 0;
        m_pageY = 0;
        m_clientWidth = 0;
        m_clientHeight = 0;
    }

    int m_pageX;
    int m_pageY;
    int m_clientWidth;
    int m_clientHeight;
};

class CORE_EXPORT VisualViewport : public ::crdtp::ProtocolObject<VisualViewport> {
public:
    ~VisualViewport() override
    {
    }

    double getOffsetX()
    {
        return m_offsetX;
    }
    void setOffsetX(double value)
    {
        m_offsetX = value;
    }

    double getOffsetY()
    {
        return m_offsetY;
    }
    void setOffsetY(double value)
    {
        m_offsetY = value;
    }

    double getPageX()
    {
        return m_pageX;
    }
    void setPageX(double value)
    {
        m_pageX = value;
    }

    double getPageY()
    {
        return m_pageY;
    }
    void setPageY(double value)
    {
        m_pageY = value;
    }

    double getClientWidth()
    {
        return m_clientWidth;
    }
    void setClientWidth(double value)
    {
        m_clientWidth = value;
    }

    double getClientHeight()
    {
        return m_clientHeight;
    }
    void setClientHeight(double value)
    {
        m_clientHeight = value;
    }

    double getScale()
    {
        return m_scale;
    }
    void setScale(double value)
    {
        m_scale = value;
    }

    bool hasZoom()
    {
        return m_zoom.has_value();
    }
    double getZoom(double defaultValue) const
    {
        return m_zoom.value_or(defaultValue);
    }
    void setZoom(double value)
    {
        m_zoom = value;
    }

    template <int STATE> class VisualViewportBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            OffsetXSet = 1 << 1,
            OffsetYSet = 1 << 2,
            PageXSet = 1 << 3,
            PageYSet = 1 << 4,
            ClientWidthSet = 1 << 5,
            ClientHeightSet = 1 << 6,
            ScaleSet = 1 << 7,
            AllFieldsSet = (OffsetXSet | OffsetYSet | PageXSet | PageYSet | ClientWidthSet | ClientHeightSet | ScaleSet | 0)
        };

        VisualViewportBuilder<STATE | OffsetXSet>& setOffsetX(double value)
        {
            static_assert(!(STATE & OffsetXSet), "property offsetX should not be set yet");
            m_result->setOffsetX(value);
            return castState<OffsetXSet>();
        }

        VisualViewportBuilder<STATE | OffsetYSet>& setOffsetY(double value)
        {
            static_assert(!(STATE & OffsetYSet), "property offsetY should not be set yet");
            m_result->setOffsetY(value);
            return castState<OffsetYSet>();
        }

        VisualViewportBuilder<STATE | PageXSet>& setPageX(double value)
        {
            static_assert(!(STATE & PageXSet), "property pageX should not be set yet");
            m_result->setPageX(value);
            return castState<PageXSet>();
        }

        VisualViewportBuilder<STATE | PageYSet>& setPageY(double value)
        {
            static_assert(!(STATE & PageYSet), "property pageY should not be set yet");
            m_result->setPageY(value);
            return castState<PageYSet>();
        }

        VisualViewportBuilder<STATE | ClientWidthSet>& setClientWidth(double value)
        {
            static_assert(!(STATE & ClientWidthSet), "property clientWidth should not be set yet");
            m_result->setClientWidth(value);
            return castState<ClientWidthSet>();
        }

        VisualViewportBuilder<STATE | ClientHeightSet>& setClientHeight(double value)
        {
            static_assert(!(STATE & ClientHeightSet), "property clientHeight should not be set yet");
            m_result->setClientHeight(value);
            return castState<ClientHeightSet>();
        }

        VisualViewportBuilder<STATE | ScaleSet>& setScale(double value)
        {
            static_assert(!(STATE & ScaleSet), "property scale should not be set yet");
            m_result->setScale(value);
            return castState<ScaleSet>();
        }

        VisualViewportBuilder<STATE>& setZoom(double value)
        {
            m_result->setZoom(value);
            return *this;
        }

        std::unique_ptr<VisualViewport> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class VisualViewport;
        VisualViewportBuilder()
            : m_result(new VisualViewport())
        {
        }

        template <int STEP> VisualViewportBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<VisualViewportBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Page::VisualViewport> m_result;
    };

    static VisualViewportBuilder<0> create()
    {
        return VisualViewportBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    VisualViewport()
    {
        m_offsetX = 0;
        m_offsetY = 0;
        m_pageX = 0;
        m_pageY = 0;
        m_clientWidth = 0;
        m_clientHeight = 0;
        m_scale = 0;
    }

    double m_offsetX;
    double m_offsetY;
    double m_pageX;
    double m_pageY;
    double m_clientWidth;
    double m_clientHeight;
    double m_scale;
    Maybe<double> m_zoom;
};

class CORE_EXPORT Viewport : public ::crdtp::ProtocolObject<Viewport> {
public:
    ~Viewport() override
    {
    }

    double getX()
    {
        return m_x;
    }
    void setX(double value)
    {
        m_x = value;
    }

    double getY()
    {
        return m_y;
    }
    void setY(double value)
    {
        m_y = value;
    }

    double getWidth()
    {
        return m_width;
    }
    void setWidth(double value)
    {
        m_width = value;
    }

    double getHeight()
    {
        return m_height;
    }
    void setHeight(double value)
    {
        m_height = value;
    }

    double getScale()
    {
        return m_scale;
    }
    void setScale(double value)
    {
        m_scale = value;
    }

    template <int STATE> class ViewportBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            XSet = 1 << 1,
            YSet = 1 << 2,
            WidthSet = 1 << 3,
            HeightSet = 1 << 4,
            ScaleSet = 1 << 5,
            AllFieldsSet = (XSet | YSet | WidthSet | HeightSet | ScaleSet | 0)
        };

        ViewportBuilder<STATE | XSet>& setX(double value)
        {
            static_assert(!(STATE & XSet), "property x should not be set yet");
            m_result->setX(value);
            return castState<XSet>();
        }

        ViewportBuilder<STATE | YSet>& setY(double value)
        {
            static_assert(!(STATE & YSet), "property y should not be set yet");
            m_result->setY(value);
            return castState<YSet>();
        }

        ViewportBuilder<STATE | WidthSet>& setWidth(double value)
        {
            static_assert(!(STATE & WidthSet), "property width should not be set yet");
            m_result->setWidth(value);
            return castState<WidthSet>();
        }

        ViewportBuilder<STATE | HeightSet>& setHeight(double value)
        {
            static_assert(!(STATE & HeightSet), "property height should not be set yet");
            m_result->setHeight(value);
            return castState<HeightSet>();
        }

        ViewportBuilder<STATE | ScaleSet>& setScale(double value)
        {
            static_assert(!(STATE & ScaleSet), "property scale should not be set yet");
            m_result->setScale(value);
            return castState<ScaleSet>();
        }

        std::unique_ptr<Viewport> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class Viewport;
        ViewportBuilder()
            : m_result(new Viewport())
        {
        }

        template <int STEP> ViewportBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<ViewportBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Page::Viewport> m_result;
    };

    static ViewportBuilder<0> create()
    {
        return ViewportBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    Viewport()
    {
        m_x = 0;
        m_y = 0;
        m_width = 0;
        m_height = 0;
        m_scale = 0;
    }

    double m_x;
    double m_y;
    double m_width;
    double m_height;
    double m_scale;
};

class CORE_EXPORT FontFamilies : public ::crdtp::ProtocolObject<FontFamilies> {
public:
    ~FontFamilies() override
    {
    }

    bool hasStandard()
    {
        return m_standard.has_value();
    }
    String getStandard(const String& defaultValue) const
    {
        return m_standard.value_or(defaultValue);
    }
    void setStandard(const String& value)
    {
        m_standard = value;
    }

    bool hasFixed()
    {
        return m_fixed.has_value();
    }
    String getFixed(const String& defaultValue) const
    {
        return m_fixed.value_or(defaultValue);
    }
    void setFixed(const String& value)
    {
        m_fixed = value;
    }

    bool hasSerif()
    {
        return m_serif.has_value();
    }
    String getSerif(const String& defaultValue) const
    {
        return m_serif.value_or(defaultValue);
    }
    void setSerif(const String& value)
    {
        m_serif = value;
    }

    bool hasSansSerif()
    {
        return m_sansSerif.has_value();
    }
    String getSansSerif(const String& defaultValue) const
    {
        return m_sansSerif.value_or(defaultValue);
    }
    void setSansSerif(const String& value)
    {
        m_sansSerif = value;
    }

    bool hasCursive()
    {
        return m_cursive.has_value();
    }
    String getCursive(const String& defaultValue) const
    {
        return m_cursive.value_or(defaultValue);
    }
    void setCursive(const String& value)
    {
        m_cursive = value;
    }

    bool hasFantasy()
    {
        return m_fantasy.has_value();
    }
    String getFantasy(const String& defaultValue) const
    {
        return m_fantasy.value_or(defaultValue);
    }
    void setFantasy(const String& value)
    {
        m_fantasy = value;
    }

    bool hasMath()
    {
        return m_math.has_value();
    }
    String getMath(const String& defaultValue) const
    {
        return m_math.value_or(defaultValue);
    }
    void setMath(const String& value)
    {
        m_math = value;
    }

    template <int STATE> class FontFamiliesBuilder {
    public:
        enum { NoFieldsSet = 0, AllFieldsSet = (0) };

        FontFamiliesBuilder<STATE>& setStandard(const String& value)
        {
            m_result->setStandard(value);
            return *this;
        }

        FontFamiliesBuilder<STATE>& setFixed(const String& value)
        {
            m_result->setFixed(value);
            return *this;
        }

        FontFamiliesBuilder<STATE>& setSerif(const String& value)
        {
            m_result->setSerif(value);
            return *this;
        }

        FontFamiliesBuilder<STATE>& setSansSerif(const String& value)
        {
            m_result->setSansSerif(value);
            return *this;
        }

        FontFamiliesBuilder<STATE>& setCursive(const String& value)
        {
            m_result->setCursive(value);
            return *this;
        }

        FontFamiliesBuilder<STATE>& setFantasy(const String& value)
        {
            m_result->setFantasy(value);
            return *this;
        }

        FontFamiliesBuilder<STATE>& setMath(const String& value)
        {
            m_result->setMath(value);
            return *this;
        }

        std::unique_ptr<FontFamilies> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class FontFamilies;
        FontFamiliesBuilder()
            : m_result(new FontFamilies())
        {
        }

        template <int STEP> FontFamiliesBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<FontFamiliesBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Page::FontFamilies> m_result;
    };

    static FontFamiliesBuilder<0> create()
    {
        return FontFamiliesBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    FontFamilies()
    {
    }

    Maybe<String> m_standard;
    Maybe<String> m_fixed;
    Maybe<String> m_serif;
    Maybe<String> m_sansSerif;
    Maybe<String> m_cursive;
    Maybe<String> m_fantasy;
    Maybe<String> m_math;
};

class CORE_EXPORT ScriptFontFamilies : public ::crdtp::ProtocolObject<ScriptFontFamilies> {
public:
    ~ScriptFontFamilies() override
    {
    }

    String getScript()
    {
        return m_script;
    }
    void setScript(const String& value)
    {
        m_script = value;
    }

    protocol::Page::FontFamilies* getFontFamilies()
    {
        return m_fontFamilies.get();
    }
    void setFontFamilies(std::unique_ptr<protocol::Page::FontFamilies> value)
    {
        m_fontFamilies = std::move(value);
    }

    template <int STATE> class ScriptFontFamiliesBuilder {
    public:
        enum { NoFieldsSet = 0, ScriptSet = 1 << 1, FontFamiliesSet = 1 << 2, AllFieldsSet = (ScriptSet | FontFamiliesSet | 0) };

        ScriptFontFamiliesBuilder<STATE | ScriptSet>& setScript(const String& value)
        {
            static_assert(!(STATE & ScriptSet), "property script should not be set yet");
            m_result->setScript(value);
            return castState<ScriptSet>();
        }

        ScriptFontFamiliesBuilder<STATE | FontFamiliesSet>& setFontFamilies(std::unique_ptr<protocol::Page::FontFamilies> value)
        {
            static_assert(!(STATE & FontFamiliesSet), "property fontFamilies should not be set yet");
            m_result->setFontFamilies(std::move(value));
            return castState<FontFamiliesSet>();
        }

        std::unique_ptr<ScriptFontFamilies> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class ScriptFontFamilies;
        ScriptFontFamiliesBuilder()
            : m_result(new ScriptFontFamilies())
        {
        }

        template <int STEP> ScriptFontFamiliesBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<ScriptFontFamiliesBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Page::ScriptFontFamilies> m_result;
    };

    static ScriptFontFamiliesBuilder<0> create()
    {
        return ScriptFontFamiliesBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    ScriptFontFamilies()
    {
    }

    String m_script;
    std::unique_ptr<protocol::Page::FontFamilies> m_fontFamilies;
};

class CORE_EXPORT FontSizes : public ::crdtp::ProtocolObject<FontSizes> {
public:
    ~FontSizes() override
    {
    }

    bool hasStandard()
    {
        return m_standard.has_value();
    }
    int getStandard(int defaultValue) const
    {
        return m_standard.value_or(defaultValue);
    }
    void setStandard(int value)
    {
        m_standard = value;
    }

    bool hasFixed()
    {
        return m_fixed.has_value();
    }
    int getFixed(int defaultValue) const
    {
        return m_fixed.value_or(defaultValue);
    }
    void setFixed(int value)
    {
        m_fixed = value;
    }

    template <int STATE> class FontSizesBuilder {
    public:
        enum { NoFieldsSet = 0, AllFieldsSet = (0) };

        FontSizesBuilder<STATE>& setStandard(int value)
        {
            m_result->setStandard(value);
            return *this;
        }

        FontSizesBuilder<STATE>& setFixed(int value)
        {
            m_result->setFixed(value);
            return *this;
        }

        std::unique_ptr<FontSizes> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class FontSizes;
        FontSizesBuilder()
            : m_result(new FontSizes())
        {
        }

        template <int STEP> FontSizesBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<FontSizesBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Page::FontSizes> m_result;
    };

    static FontSizesBuilder<0> create()
    {
        return FontSizesBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    FontSizes()
    {
    }

    Maybe<int> m_standard;
    Maybe<int> m_fixed;
};

class CORE_EXPORT CompilationCacheParams : public ::crdtp::ProtocolObject<CompilationCacheParams> {
public:
    ~CompilationCacheParams() override
    {
    }

    String getUrl()
    {
        return m_url;
    }
    void setUrl(const String& value)
    {
        m_url = value;
    }

    bool hasEager()
    {
        return m_eager.has_value();
    }
    bool getEager(bool defaultValue) const
    {
        return m_eager.value_or(defaultValue);
    }
    void setEager(bool value)
    {
        m_eager = value;
    }

    template <int STATE> class CompilationCacheParamsBuilder {
    public:
        enum { NoFieldsSet = 0, UrlSet = 1 << 1, AllFieldsSet = (UrlSet | 0) };

        CompilationCacheParamsBuilder<STATE | UrlSet>& setUrl(const String& value)
        {
            static_assert(!(STATE & UrlSet), "property url should not be set yet");
            m_result->setUrl(value);
            return castState<UrlSet>();
        }

        CompilationCacheParamsBuilder<STATE>& setEager(bool value)
        {
            m_result->setEager(value);
            return *this;
        }

        std::unique_ptr<CompilationCacheParams> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class CompilationCacheParams;
        CompilationCacheParamsBuilder()
            : m_result(new CompilationCacheParams())
        {
        }

        template <int STEP> CompilationCacheParamsBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<CompilationCacheParamsBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Page::CompilationCacheParams> m_result;
    };

    static CompilationCacheParamsBuilder<0> create()
    {
        return CompilationCacheParamsBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    CompilationCacheParams()
    {
    }

    String m_url;
    Maybe<bool> m_eager;
};

class CORE_EXPORT BackForwardCacheBlockingDetails : public ::crdtp::ProtocolObject<BackForwardCacheBlockingDetails> {
public:
    ~BackForwardCacheBlockingDetails() override
    {
    }

    bool hasUrl()
    {
        return m_url.has_value();
    }
    String getUrl(const String& defaultValue) const
    {
        return m_url.value_or(defaultValue);
    }
    void setUrl(const String& value)
    {
        m_url = value;
    }

    bool hasFunction()
    {
        return m_function.has_value();
    }
    String getFunction(const String& defaultValue) const
    {
        return m_function.value_or(defaultValue);
    }
    void setFunction(const String& value)
    {
        m_function = value;
    }

    int getLineNumber()
    {
        return m_lineNumber;
    }
    void setLineNumber(int value)
    {
        m_lineNumber = value;
    }

    int getColumnNumber()
    {
        return m_columnNumber;
    }
    void setColumnNumber(int value)
    {
        m_columnNumber = value;
    }

    template <int STATE> class BackForwardCacheBlockingDetailsBuilder {
    public:
        enum { NoFieldsSet = 0, LineNumberSet = 1 << 1, ColumnNumberSet = 1 << 2, AllFieldsSet = (LineNumberSet | ColumnNumberSet | 0) };

        BackForwardCacheBlockingDetailsBuilder<STATE>& setUrl(const String& value)
        {
            m_result->setUrl(value);
            return *this;
        }

        BackForwardCacheBlockingDetailsBuilder<STATE>& setFunction(const String& value)
        {
            m_result->setFunction(value);
            return *this;
        }

        BackForwardCacheBlockingDetailsBuilder<STATE | LineNumberSet>& setLineNumber(int value)
        {
            static_assert(!(STATE & LineNumberSet), "property lineNumber should not be set yet");
            m_result->setLineNumber(value);
            return castState<LineNumberSet>();
        }

        BackForwardCacheBlockingDetailsBuilder<STATE | ColumnNumberSet>& setColumnNumber(int value)
        {
            static_assert(!(STATE & ColumnNumberSet), "property columnNumber should not be set yet");
            m_result->setColumnNumber(value);
            return castState<ColumnNumberSet>();
        }

        std::unique_ptr<BackForwardCacheBlockingDetails> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class BackForwardCacheBlockingDetails;
        BackForwardCacheBlockingDetailsBuilder()
            : m_result(new BackForwardCacheBlockingDetails())
        {
        }

        template <int STEP> BackForwardCacheBlockingDetailsBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<BackForwardCacheBlockingDetailsBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Page::BackForwardCacheBlockingDetails> m_result;
    };

    static BackForwardCacheBlockingDetailsBuilder<0> create()
    {
        return BackForwardCacheBlockingDetailsBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    BackForwardCacheBlockingDetails()
    {
        m_lineNumber = 0;
        m_columnNumber = 0;
    }

    Maybe<String> m_url;
    Maybe<String> m_function;
    int m_lineNumber;
    int m_columnNumber;
};

class CORE_EXPORT BackForwardCacheNotRestoredExplanation : public ::crdtp::ProtocolObject<BackForwardCacheNotRestoredExplanation> {
public:
    ~BackForwardCacheNotRestoredExplanation() override
    {
    }

    String getType()
    {
        return m_type;
    }
    void setType(const String& value)
    {
        m_type = value;
    }

    String getReason()
    {
        return m_reason;
    }
    void setReason(const String& value)
    {
        m_reason = value;
    }

    bool hasContext()
    {
        return m_context.has_value();
    }
    String getContext(const String& defaultValue) const
    {
        return m_context.value_or(defaultValue);
    }
    void setContext(const String& value)
    {
        m_context = value;
    }

    bool hasDetails()
    {
        return m_details.has_value();
    }
    protocol::Array<protocol::Page::BackForwardCacheBlockingDetails>* getDetails(protocol::Array<protocol::Page::BackForwardCacheBlockingDetails>* defaultValue)
    {
        return m_details.has_value() ? &m_details.value() : defaultValue;
    }
    void setDetails(std::unique_ptr<protocol::Array<protocol::Page::BackForwardCacheBlockingDetails>> value)
    {
        m_details = std::move(value);
    }

    template <int STATE> class BackForwardCacheNotRestoredExplanationBuilder {
    public:
        enum { NoFieldsSet = 0, TypeSet = 1 << 1, ReasonSet = 1 << 2, AllFieldsSet = (TypeSet | ReasonSet | 0) };

        BackForwardCacheNotRestoredExplanationBuilder<STATE | TypeSet>& setType(const String& value)
        {
            static_assert(!(STATE & TypeSet), "property type should not be set yet");
            m_result->setType(value);
            return castState<TypeSet>();
        }

        BackForwardCacheNotRestoredExplanationBuilder<STATE | ReasonSet>& setReason(const String& value)
        {
            static_assert(!(STATE & ReasonSet), "property reason should not be set yet");
            m_result->setReason(value);
            return castState<ReasonSet>();
        }

        BackForwardCacheNotRestoredExplanationBuilder<STATE>& setContext(const String& value)
        {
            m_result->setContext(value);
            return *this;
        }

        BackForwardCacheNotRestoredExplanationBuilder<STATE>& setDetails(
            std::unique_ptr<protocol::Array<protocol::Page::BackForwardCacheBlockingDetails>> value)
        {
            m_result->setDetails(std::move(value));
            return *this;
        }

        std::unique_ptr<BackForwardCacheNotRestoredExplanation> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class BackForwardCacheNotRestoredExplanation;
        BackForwardCacheNotRestoredExplanationBuilder()
            : m_result(new BackForwardCacheNotRestoredExplanation())
        {
        }

        template <int STEP> BackForwardCacheNotRestoredExplanationBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<BackForwardCacheNotRestoredExplanationBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Page::BackForwardCacheNotRestoredExplanation> m_result;
    };

    static BackForwardCacheNotRestoredExplanationBuilder<0> create()
    {
        return BackForwardCacheNotRestoredExplanationBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    BackForwardCacheNotRestoredExplanation()
    {
    }

    String m_type;
    String m_reason;
    Maybe<String> m_context;
    Maybe<protocol::Array<protocol::Page::BackForwardCacheBlockingDetails>> m_details;
};

class CORE_EXPORT BackForwardCacheNotRestoredExplanationTree : public ::crdtp::ProtocolObject<BackForwardCacheNotRestoredExplanationTree> {
public:
    ~BackForwardCacheNotRestoredExplanationTree() override
    {
    }

    String getUrl()
    {
        return m_url;
    }
    void setUrl(const String& value)
    {
        m_url = value;
    }

    protocol::Array<protocol::Page::BackForwardCacheNotRestoredExplanation>* getExplanations()
    {
        return m_explanations.get();
    }
    void setExplanations(std::unique_ptr<protocol::Array<protocol::Page::BackForwardCacheNotRestoredExplanation>> value)
    {
        m_explanations = std::move(value);
    }

    protocol::Array<protocol::Page::BackForwardCacheNotRestoredExplanationTree>* getChildren()
    {
        return m_children.get();
    }
    void setChildren(std::unique_ptr<protocol::Array<protocol::Page::BackForwardCacheNotRestoredExplanationTree>> value)
    {
        m_children = std::move(value);
    }

    template <int STATE> class BackForwardCacheNotRestoredExplanationTreeBuilder {
    public:
        enum { NoFieldsSet = 0, UrlSet = 1 << 1, ExplanationsSet = 1 << 2, ChildrenSet = 1 << 3, AllFieldsSet = (UrlSet | ExplanationsSet | ChildrenSet | 0) };

        BackForwardCacheNotRestoredExplanationTreeBuilder<STATE | UrlSet>& setUrl(const String& value)
        {
            static_assert(!(STATE & UrlSet), "property url should not be set yet");
            m_result->setUrl(value);
            return castState<UrlSet>();
        }

        BackForwardCacheNotRestoredExplanationTreeBuilder<STATE | ExplanationsSet>& setExplanations(
            std::unique_ptr<protocol::Array<protocol::Page::BackForwardCacheNotRestoredExplanation>> value)
        {
            static_assert(!(STATE & ExplanationsSet), "property explanations should not be set yet");
            m_result->setExplanations(std::move(value));
            return castState<ExplanationsSet>();
        }

        BackForwardCacheNotRestoredExplanationTreeBuilder<STATE | ChildrenSet>& setChildren(
            std::unique_ptr<protocol::Array<protocol::Page::BackForwardCacheNotRestoredExplanationTree>> value)
        {
            static_assert(!(STATE & ChildrenSet), "property children should not be set yet");
            m_result->setChildren(std::move(value));
            return castState<ChildrenSet>();
        }

        std::unique_ptr<BackForwardCacheNotRestoredExplanationTree> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class BackForwardCacheNotRestoredExplanationTree;
        BackForwardCacheNotRestoredExplanationTreeBuilder()
            : m_result(new BackForwardCacheNotRestoredExplanationTree())
        {
        }

        template <int STEP> BackForwardCacheNotRestoredExplanationTreeBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<BackForwardCacheNotRestoredExplanationTreeBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Page::BackForwardCacheNotRestoredExplanationTree> m_result;
    };

    static BackForwardCacheNotRestoredExplanationTreeBuilder<0> create()
    {
        return BackForwardCacheNotRestoredExplanationTreeBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    BackForwardCacheNotRestoredExplanationTree()
    {
    }

    String m_url;
    std::unique_ptr<protocol::Array<protocol::Page::BackForwardCacheNotRestoredExplanation>> m_explanations;
    std::unique_ptr<protocol::Array<protocol::Page::BackForwardCacheNotRestoredExplanationTree>> m_children;
};

// ------------- Backend interface.

class CORE_EXPORT Backend {
public:
    virtual ~Backend()
    {
    }

    virtual DispatchResponse addScriptToEvaluateOnLoad(const String& in_scriptSource, String* out_identifier) = 0;
    virtual DispatchResponse addScriptToEvaluateOnNewDocument(
        const String& in_source, Maybe<String> in_worldName, Maybe<bool> in_includeCommandLineAPI, Maybe<bool> in_runImmediately, String* out_identifier)
        = 0;
    class CORE_EXPORT CreateIsolatedWorldCallback {
    public:
        virtual void sendSuccess(int executionContextId) = 0;
        virtual void sendFailure(const DispatchResponse&) = 0;
        virtual void fallThrough() = 0;
        virtual ~CreateIsolatedWorldCallback()
        {
        }
    };
    virtual void createIsolatedWorld(
        const String& in_frameId, Maybe<String> in_worldName, Maybe<bool> in_grantUniveralAccess, std::unique_ptr<CreateIsolatedWorldCallback> callback)
        = 0;
    virtual DispatchResponse disable() = 0;
    virtual DispatchResponse enable() = 0;
    virtual DispatchResponse getAdScriptId(const String& in_frameId, Maybe<protocol::Page::AdScriptId>* out_adScriptId) = 0;
    virtual DispatchResponse getFrameTree(std::unique_ptr<protocol::Page::FrameTree>* out_frameTree) = 0;
    virtual DispatchResponse getLayoutMetrics(std::unique_ptr<protocol::Page::LayoutViewport>* out_layoutViewport,
        std::unique_ptr<protocol::Page::VisualViewport>* out_visualViewport, std::unique_ptr<protocol::DOM::Rect>* out_contentSize,
        std::unique_ptr<protocol::Page::LayoutViewport>* out_cssLayoutViewport, std::unique_ptr<protocol::Page::VisualViewport>* out_cssVisualViewport,
        std::unique_ptr<protocol::DOM::Rect>* out_cssContentSize)
        = 0;
    class CORE_EXPORT GetResourceContentCallback {
    public:
        virtual void sendSuccess(const String& content, bool base64Encoded) = 0;
        virtual void sendFailure(const DispatchResponse&) = 0;
        virtual void fallThrough() = 0;
        virtual ~GetResourceContentCallback()
        {
        }
    };
    virtual void getResourceContent(const String& in_frameId, const String& in_url, std::unique_ptr<GetResourceContentCallback> callback) = 0;
    virtual DispatchResponse getResourceTree(std::unique_ptr<protocol::Page::FrameResourceTree>* out_frameTree) = 0;
    virtual DispatchResponse reload(Maybe<bool> in_ignoreCache, Maybe<String> in_scriptToEvaluateOnLoad, Maybe<String> in_loaderId) = 0;
    virtual DispatchResponse removeScriptToEvaluateOnLoad(const String& in_identifier) = 0;
    virtual DispatchResponse removeScriptToEvaluateOnNewDocument(const String& in_identifier) = 0;
    class CORE_EXPORT SearchInResourceCallback {
    public:
        virtual void sendSuccess(std::unique_ptr<protocol::Array<v8_inspector::protocol::Debugger::API::SearchMatch>> result) = 0;
        virtual void sendFailure(const DispatchResponse&) = 0;
        virtual void fallThrough() = 0;
        virtual ~SearchInResourceCallback()
        {
        }
    };
    virtual void searchInResource(const String& in_frameId, const String& in_url, const String& in_query, Maybe<bool> in_caseSensitive, Maybe<bool> in_isRegex,
        std::unique_ptr<SearchInResourceCallback> callback)
        = 0;
    virtual DispatchResponse setAdBlockingEnabled(bool in_enabled) = 0;
    virtual DispatchResponse setBypassCSP(bool in_enabled) = 0;
    virtual DispatchResponse getPermissionsPolicyState(
        const String& in_frameId, std::unique_ptr<protocol::Array<protocol::Page::PermissionsPolicyFeatureState>>* out_states)
        = 0;
    virtual DispatchResponse getOriginTrials(const String& in_frameId, std::unique_ptr<protocol::Array<protocol::Page::OriginTrial>>* out_originTrials) = 0;
    virtual DispatchResponse setFontFamilies(
        std::unique_ptr<protocol::Page::FontFamilies> in_fontFamilies, Maybe<protocol::Array<protocol::Page::ScriptFontFamilies>> in_forScripts)
        = 0;
    virtual DispatchResponse setFontSizes(std::unique_ptr<protocol::Page::FontSizes> in_fontSizes) = 0;
    virtual DispatchResponse setDocumentContent(const String& in_frameId, const String& in_html) = 0;
    virtual DispatchResponse setLifecycleEventsEnabled(bool in_enabled) = 0;
    virtual DispatchResponse startScreencast(
        Maybe<String> in_format, Maybe<int> in_quality, Maybe<int> in_maxWidth, Maybe<int> in_maxHeight, Maybe<int> in_everyNthFrame)
        = 0;
    virtual DispatchResponse stopLoading() = 0;
    virtual DispatchResponse stopScreencast() = 0;
    virtual DispatchResponse produceCompilationCache(std::unique_ptr<protocol::Array<protocol::Page::CompilationCacheParams>> in_scripts) = 0;
    virtual DispatchResponse addCompilationCache(const String& in_url, const Binary& in_data) = 0;
    virtual DispatchResponse clearCompilationCache() = 0;
    virtual DispatchResponse generateTestReport(const String& in_message, Maybe<String> in_group) = 0;
    virtual DispatchResponse waitForDebugger() = 0;
    virtual DispatchResponse setInterceptFileChooserDialog(bool in_enabled) = 0;
};

// ------------- Frontend interface.

class CORE_EXPORT Frontend {
public:
    explicit Frontend(FrontendChannel* frontend_channel)
        : frontend_channel_(frontend_channel)
    {
    }
    void domContentEventFired(double timestamp);
    void fileChooserOpened(const String& frameId, const String& mode, Maybe<int> backendNodeId = Maybe<int>());
    void frameAttached(const String& frameId, const String& parentFrameId,
        Maybe<v8_inspector::protocol::Runtime::API::StackTrace> stack = Maybe<v8_inspector::protocol::Runtime::API::StackTrace>());
    void frameClearedScheduledNavigation(const String& frameId);
    void frameDetached(const String& frameId, const String& reason);
    void frameSubtreeWillBeDetached(const String& frameId);
    void frameNavigated(std::unique_ptr<protocol::Page::Frame> frame, const String& type);
    void documentOpened(std::unique_ptr<protocol::Page::Frame> frame);
    void frameResized();
    void frameRequestedNavigation(const String& frameId, const String& reason, const String& url, const String& disposition);
    void frameScheduledNavigation(const String& frameId, double delay, const String& reason, const String& url);
    void downloadWillBegin(const String& frameId, const String& guid, const String& url, const String& suggestedFilename);
    void downloadProgress(const String& guid, double totalBytes, double receivedBytes, const String& state);
    void lifecycleEvent(const String& frameId, const String& loaderId, const String& name, double timestamp);
    void backForwardCacheNotUsed(const String& loaderId, const String& frameId,
        std::unique_ptr<protocol::Array<protocol::Page::BackForwardCacheNotRestoredExplanation>> notRestoredExplanations,
        Maybe<protocol::Page::BackForwardCacheNotRestoredExplanationTree> notRestoredExplanationsTree
        = Maybe<protocol::Page::BackForwardCacheNotRestoredExplanationTree>());
    void loadEventFired(double timestamp);
    void navigatedWithinDocument(const String& frameId, const String& url, const String& navigationType);
    void windowOpen(const String& url, const String& windowName, std::unique_ptr<protocol::Array<String>> windowFeatures, bool userGesture);
    void compilationCacheProduced(const String& url, const Binary& data);

    void flush();
    void sendRawNotification(std::unique_ptr<Serializable>);

private:
    FrontendChannel* frontend_channel_;
};

// ------------- Dispatcher.

class CORE_EXPORT Dispatcher {
public:
    static void wire(UberDispatcher*, Backend*);

private:
    Dispatcher()
    {
    }
};

// ------------- Metainfo.

class CORE_EXPORT Metainfo {
public:
    using BackendClass = Backend;
    using FrontendClass = Frontend;
    using DispatcherClass = Dispatcher;
    static const char domainName[];
    static const char commandPrefix[];
    static const char version[];
};

} // namespace Page
} // namespace blink
} // namespace protocol

#endif // !defined(blink_protocol_Page_h)
