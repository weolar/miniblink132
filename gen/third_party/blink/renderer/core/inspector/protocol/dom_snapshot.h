// This file is generated by TypeBuilder_h.template.

// Copyright 2016 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef blink_protocol_DOMSnapshot_h
#define blink_protocol_DOMSnapshot_h

#include "third_party/blink/renderer/core/core_export.h"
#include "third_party/blink/renderer/core/inspector/protocol/protocol.h"
// For each imported domain we generate a ValueConversions struct instead of a full domain definition
// and include Domain::API version from there.
#include "third_party/blink/renderer/core/inspector/protocol/css.h"
#include "third_party/blink/renderer/core/inspector/protocol/dom.h"
#include "third_party/blink/renderer/core/inspector/protocol/dom_debugger.h"
#include "third_party/blink/renderer/core/inspector/protocol/page.h"

namespace blink {
namespace protocol {
namespace DOMSnapshot {
class DOMNode;
class InlineTextBox;
class LayoutTreeNode;
class ComputedStyle;
class NameValue;
using StringIndex = int;
class RareStringData;
class RareBooleanData;
class RareIntegerData;
class DocumentSnapshot;
class NodeTreeSnapshot;
class LayoutTreeSnapshot;
class TextBoxSnapshot;

// ------------- Forward and enum declarations.

// ------------- Type and builder declarations.

class CORE_EXPORT DOMNode : public ::crdtp::ProtocolObject<DOMNode> {
public:
    ~DOMNode() override
    {
    }

    int getNodeType()
    {
        return m_nodeType;
    }
    void setNodeType(int value)
    {
        m_nodeType = value;
    }

    String getNodeName()
    {
        return m_nodeName;
    }
    void setNodeName(const String& value)
    {
        m_nodeName = value;
    }

    String getNodeValue()
    {
        return m_nodeValue;
    }
    void setNodeValue(const String& value)
    {
        m_nodeValue = value;
    }

    bool hasTextValue()
    {
        return m_textValue.has_value();
    }
    String getTextValue(const String& defaultValue) const
    {
        return m_textValue.value_or(defaultValue);
    }
    void setTextValue(const String& value)
    {
        m_textValue = value;
    }

    bool hasInputValue()
    {
        return m_inputValue.has_value();
    }
    String getInputValue(const String& defaultValue) const
    {
        return m_inputValue.value_or(defaultValue);
    }
    void setInputValue(const String& value)
    {
        m_inputValue = value;
    }

    bool hasInputChecked()
    {
        return m_inputChecked.has_value();
    }
    bool getInputChecked(bool defaultValue) const
    {
        return m_inputChecked.value_or(defaultValue);
    }
    void setInputChecked(bool value)
    {
        m_inputChecked = value;
    }

    bool hasOptionSelected()
    {
        return m_optionSelected.has_value();
    }
    bool getOptionSelected(bool defaultValue) const
    {
        return m_optionSelected.value_or(defaultValue);
    }
    void setOptionSelected(bool value)
    {
        m_optionSelected = value;
    }

    int getBackendNodeId()
    {
        return m_backendNodeId;
    }
    void setBackendNodeId(int value)
    {
        m_backendNodeId = value;
    }

    bool hasChildNodeIndexes()
    {
        return m_childNodeIndexes.has_value();
    }
    protocol::Array<int>* getChildNodeIndexes(protocol::Array<int>* defaultValue)
    {
        return m_childNodeIndexes.has_value() ? &m_childNodeIndexes.value() : defaultValue;
    }
    void setChildNodeIndexes(std::unique_ptr<protocol::Array<int>> value)
    {
        m_childNodeIndexes = std::move(value);
    }

    bool hasAttributes()
    {
        return m_attributes.has_value();
    }
    protocol::Array<protocol::DOMSnapshot::NameValue>* getAttributes(protocol::Array<protocol::DOMSnapshot::NameValue>* defaultValue)
    {
        return m_attributes.has_value() ? &m_attributes.value() : defaultValue;
    }
    void setAttributes(std::unique_ptr<protocol::Array<protocol::DOMSnapshot::NameValue>> value)
    {
        m_attributes = std::move(value);
    }

    bool hasPseudoElementIndexes()
    {
        return m_pseudoElementIndexes.has_value();
    }
    protocol::Array<int>* getPseudoElementIndexes(protocol::Array<int>* defaultValue)
    {
        return m_pseudoElementIndexes.has_value() ? &m_pseudoElementIndexes.value() : defaultValue;
    }
    void setPseudoElementIndexes(std::unique_ptr<protocol::Array<int>> value)
    {
        m_pseudoElementIndexes = std::move(value);
    }

    bool hasLayoutNodeIndex()
    {
        return m_layoutNodeIndex.has_value();
    }
    int getLayoutNodeIndex(int defaultValue) const
    {
        return m_layoutNodeIndex.value_or(defaultValue);
    }
    void setLayoutNodeIndex(int value)
    {
        m_layoutNodeIndex = value;
    }

    bool hasDocumentURL()
    {
        return m_documentURL.has_value();
    }
    String getDocumentURL(const String& defaultValue) const
    {
        return m_documentURL.value_or(defaultValue);
    }
    void setDocumentURL(const String& value)
    {
        m_documentURL = value;
    }

    bool hasBaseURL()
    {
        return m_baseURL.has_value();
    }
    String getBaseURL(const String& defaultValue) const
    {
        return m_baseURL.value_or(defaultValue);
    }
    void setBaseURL(const String& value)
    {
        m_baseURL = value;
    }

    bool hasContentLanguage()
    {
        return m_contentLanguage.has_value();
    }
    String getContentLanguage(const String& defaultValue) const
    {
        return m_contentLanguage.value_or(defaultValue);
    }
    void setContentLanguage(const String& value)
    {
        m_contentLanguage = value;
    }

    bool hasDocumentEncoding()
    {
        return m_documentEncoding.has_value();
    }
    String getDocumentEncoding(const String& defaultValue) const
    {
        return m_documentEncoding.value_or(defaultValue);
    }
    void setDocumentEncoding(const String& value)
    {
        m_documentEncoding = value;
    }

    bool hasPublicId()
    {
        return m_publicId.has_value();
    }
    String getPublicId(const String& defaultValue) const
    {
        return m_publicId.value_or(defaultValue);
    }
    void setPublicId(const String& value)
    {
        m_publicId = value;
    }

    bool hasSystemId()
    {
        return m_systemId.has_value();
    }
    String getSystemId(const String& defaultValue) const
    {
        return m_systemId.value_or(defaultValue);
    }
    void setSystemId(const String& value)
    {
        m_systemId = value;
    }

    bool hasFrameId()
    {
        return m_frameId.has_value();
    }
    String getFrameId(const String& defaultValue) const
    {
        return m_frameId.value_or(defaultValue);
    }
    void setFrameId(const String& value)
    {
        m_frameId = value;
    }

    bool hasContentDocumentIndex()
    {
        return m_contentDocumentIndex.has_value();
    }
    int getContentDocumentIndex(int defaultValue) const
    {
        return m_contentDocumentIndex.value_or(defaultValue);
    }
    void setContentDocumentIndex(int value)
    {
        m_contentDocumentIndex = value;
    }

    bool hasPseudoType()
    {
        return m_pseudoType.has_value();
    }
    String getPseudoType(const String& defaultValue) const
    {
        return m_pseudoType.value_or(defaultValue);
    }
    void setPseudoType(const String& value)
    {
        m_pseudoType = value;
    }

    bool hasShadowRootType()
    {
        return m_shadowRootType.has_value();
    }
    String getShadowRootType(const String& defaultValue) const
    {
        return m_shadowRootType.value_or(defaultValue);
    }
    void setShadowRootType(const String& value)
    {
        m_shadowRootType = value;
    }

    bool hasIsClickable()
    {
        return m_isClickable.has_value();
    }
    bool getIsClickable(bool defaultValue) const
    {
        return m_isClickable.value_or(defaultValue);
    }
    void setIsClickable(bool value)
    {
        m_isClickable = value;
    }

    bool hasEventListeners()
    {
        return m_eventListeners.has_value();
    }
    protocol::Array<protocol::DOMDebugger::EventListener>* getEventListeners(protocol::Array<protocol::DOMDebugger::EventListener>* defaultValue)
    {
        return m_eventListeners.has_value() ? &m_eventListeners.value() : defaultValue;
    }
    void setEventListeners(std::unique_ptr<protocol::Array<protocol::DOMDebugger::EventListener>> value)
    {
        m_eventListeners = std::move(value);
    }

    bool hasCurrentSourceURL()
    {
        return m_currentSourceURL.has_value();
    }
    String getCurrentSourceURL(const String& defaultValue) const
    {
        return m_currentSourceURL.value_or(defaultValue);
    }
    void setCurrentSourceURL(const String& value)
    {
        m_currentSourceURL = value;
    }

    bool hasOriginURL()
    {
        return m_originURL.has_value();
    }
    String getOriginURL(const String& defaultValue) const
    {
        return m_originURL.value_or(defaultValue);
    }
    void setOriginURL(const String& value)
    {
        m_originURL = value;
    }

    bool hasScrollOffsetX()
    {
        return m_scrollOffsetX.has_value();
    }
    double getScrollOffsetX(double defaultValue) const
    {
        return m_scrollOffsetX.value_or(defaultValue);
    }
    void setScrollOffsetX(double value)
    {
        m_scrollOffsetX = value;
    }

    bool hasScrollOffsetY()
    {
        return m_scrollOffsetY.has_value();
    }
    double getScrollOffsetY(double defaultValue) const
    {
        return m_scrollOffsetY.value_or(defaultValue);
    }
    void setScrollOffsetY(double value)
    {
        m_scrollOffsetY = value;
    }

    template <int STATE> class DOMNodeBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            NodeTypeSet = 1 << 1,
            NodeNameSet = 1 << 2,
            NodeValueSet = 1 << 3,
            BackendNodeIdSet = 1 << 4,
            AllFieldsSet = (NodeTypeSet | NodeNameSet | NodeValueSet | BackendNodeIdSet | 0)
        };

        DOMNodeBuilder<STATE | NodeTypeSet>& setNodeType(int value)
        {
            static_assert(!(STATE & NodeTypeSet), "property nodeType should not be set yet");
            m_result->setNodeType(value);
            return castState<NodeTypeSet>();
        }

        DOMNodeBuilder<STATE | NodeNameSet>& setNodeName(const String& value)
        {
            static_assert(!(STATE & NodeNameSet), "property nodeName should not be set yet");
            m_result->setNodeName(value);
            return castState<NodeNameSet>();
        }

        DOMNodeBuilder<STATE | NodeValueSet>& setNodeValue(const String& value)
        {
            static_assert(!(STATE & NodeValueSet), "property nodeValue should not be set yet");
            m_result->setNodeValue(value);
            return castState<NodeValueSet>();
        }

        DOMNodeBuilder<STATE>& setTextValue(const String& value)
        {
            m_result->setTextValue(value);
            return *this;
        }

        DOMNodeBuilder<STATE>& setInputValue(const String& value)
        {
            m_result->setInputValue(value);
            return *this;
        }

        DOMNodeBuilder<STATE>& setInputChecked(bool value)
        {
            m_result->setInputChecked(value);
            return *this;
        }

        DOMNodeBuilder<STATE>& setOptionSelected(bool value)
        {
            m_result->setOptionSelected(value);
            return *this;
        }

        DOMNodeBuilder<STATE | BackendNodeIdSet>& setBackendNodeId(int value)
        {
            static_assert(!(STATE & BackendNodeIdSet), "property backendNodeId should not be set yet");
            m_result->setBackendNodeId(value);
            return castState<BackendNodeIdSet>();
        }

        DOMNodeBuilder<STATE>& setChildNodeIndexes(std::unique_ptr<protocol::Array<int>> value)
        {
            m_result->setChildNodeIndexes(std::move(value));
            return *this;
        }

        DOMNodeBuilder<STATE>& setAttributes(std::unique_ptr<protocol::Array<protocol::DOMSnapshot::NameValue>> value)
        {
            m_result->setAttributes(std::move(value));
            return *this;
        }

        DOMNodeBuilder<STATE>& setPseudoElementIndexes(std::unique_ptr<protocol::Array<int>> value)
        {
            m_result->setPseudoElementIndexes(std::move(value));
            return *this;
        }

        DOMNodeBuilder<STATE>& setLayoutNodeIndex(int value)
        {
            m_result->setLayoutNodeIndex(value);
            return *this;
        }

        DOMNodeBuilder<STATE>& setDocumentURL(const String& value)
        {
            m_result->setDocumentURL(value);
            return *this;
        }

        DOMNodeBuilder<STATE>& setBaseURL(const String& value)
        {
            m_result->setBaseURL(value);
            return *this;
        }

        DOMNodeBuilder<STATE>& setContentLanguage(const String& value)
        {
            m_result->setContentLanguage(value);
            return *this;
        }

        DOMNodeBuilder<STATE>& setDocumentEncoding(const String& value)
        {
            m_result->setDocumentEncoding(value);
            return *this;
        }

        DOMNodeBuilder<STATE>& setPublicId(const String& value)
        {
            m_result->setPublicId(value);
            return *this;
        }

        DOMNodeBuilder<STATE>& setSystemId(const String& value)
        {
            m_result->setSystemId(value);
            return *this;
        }

        DOMNodeBuilder<STATE>& setFrameId(const String& value)
        {
            m_result->setFrameId(value);
            return *this;
        }

        DOMNodeBuilder<STATE>& setContentDocumentIndex(int value)
        {
            m_result->setContentDocumentIndex(value);
            return *this;
        }

        DOMNodeBuilder<STATE>& setPseudoType(const String& value)
        {
            m_result->setPseudoType(value);
            return *this;
        }

        DOMNodeBuilder<STATE>& setShadowRootType(const String& value)
        {
            m_result->setShadowRootType(value);
            return *this;
        }

        DOMNodeBuilder<STATE>& setIsClickable(bool value)
        {
            m_result->setIsClickable(value);
            return *this;
        }

        DOMNodeBuilder<STATE>& setEventListeners(std::unique_ptr<protocol::Array<protocol::DOMDebugger::EventListener>> value)
        {
            m_result->setEventListeners(std::move(value));
            return *this;
        }

        DOMNodeBuilder<STATE>& setCurrentSourceURL(const String& value)
        {
            m_result->setCurrentSourceURL(value);
            return *this;
        }

        DOMNodeBuilder<STATE>& setOriginURL(const String& value)
        {
            m_result->setOriginURL(value);
            return *this;
        }

        DOMNodeBuilder<STATE>& setScrollOffsetX(double value)
        {
            m_result->setScrollOffsetX(value);
            return *this;
        }

        DOMNodeBuilder<STATE>& setScrollOffsetY(double value)
        {
            m_result->setScrollOffsetY(value);
            return *this;
        }

        std::unique_ptr<DOMNode> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class DOMNode;
        DOMNodeBuilder()
            : m_result(new DOMNode())
        {
        }

        template <int STEP> DOMNodeBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<DOMNodeBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::DOMSnapshot::DOMNode> m_result;
    };

    static DOMNodeBuilder<0> create()
    {
        return DOMNodeBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    DOMNode()
    {
        m_nodeType = 0;
        m_backendNodeId = 0;
    }

    int m_nodeType;
    String m_nodeName;
    String m_nodeValue;
    Maybe<String> m_textValue;
    Maybe<String> m_inputValue;
    Maybe<bool> m_inputChecked;
    Maybe<bool> m_optionSelected;
    int m_backendNodeId;
    Maybe<protocol::Array<int>> m_childNodeIndexes;
    Maybe<protocol::Array<protocol::DOMSnapshot::NameValue>> m_attributes;
    Maybe<protocol::Array<int>> m_pseudoElementIndexes;
    Maybe<int> m_layoutNodeIndex;
    Maybe<String> m_documentURL;
    Maybe<String> m_baseURL;
    Maybe<String> m_contentLanguage;
    Maybe<String> m_documentEncoding;
    Maybe<String> m_publicId;
    Maybe<String> m_systemId;
    Maybe<String> m_frameId;
    Maybe<int> m_contentDocumentIndex;
    Maybe<String> m_pseudoType;
    Maybe<String> m_shadowRootType;
    Maybe<bool> m_isClickable;
    Maybe<protocol::Array<protocol::DOMDebugger::EventListener>> m_eventListeners;
    Maybe<String> m_currentSourceURL;
    Maybe<String> m_originURL;
    Maybe<double> m_scrollOffsetX;
    Maybe<double> m_scrollOffsetY;
};

class CORE_EXPORT InlineTextBox : public ::crdtp::ProtocolObject<InlineTextBox> {
public:
    ~InlineTextBox() override
    {
    }

    protocol::DOM::Rect* getBoundingBox()
    {
        return m_boundingBox.get();
    }
    void setBoundingBox(std::unique_ptr<protocol::DOM::Rect> value)
    {
        m_boundingBox = std::move(value);
    }

    int getStartCharacterIndex()
    {
        return m_startCharacterIndex;
    }
    void setStartCharacterIndex(int value)
    {
        m_startCharacterIndex = value;
    }

    int getNumCharacters()
    {
        return m_numCharacters;
    }
    void setNumCharacters(int value)
    {
        m_numCharacters = value;
    }

    template <int STATE> class InlineTextBoxBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            BoundingBoxSet = 1 << 1,
            StartCharacterIndexSet = 1 << 2,
            NumCharactersSet = 1 << 3,
            AllFieldsSet = (BoundingBoxSet | StartCharacterIndexSet | NumCharactersSet | 0)
        };

        InlineTextBoxBuilder<STATE | BoundingBoxSet>& setBoundingBox(std::unique_ptr<protocol::DOM::Rect> value)
        {
            static_assert(!(STATE & BoundingBoxSet), "property boundingBox should not be set yet");
            m_result->setBoundingBox(std::move(value));
            return castState<BoundingBoxSet>();
        }

        InlineTextBoxBuilder<STATE | StartCharacterIndexSet>& setStartCharacterIndex(int value)
        {
            static_assert(!(STATE & StartCharacterIndexSet), "property startCharacterIndex should not be set yet");
            m_result->setStartCharacterIndex(value);
            return castState<StartCharacterIndexSet>();
        }

        InlineTextBoxBuilder<STATE | NumCharactersSet>& setNumCharacters(int value)
        {
            static_assert(!(STATE & NumCharactersSet), "property numCharacters should not be set yet");
            m_result->setNumCharacters(value);
            return castState<NumCharactersSet>();
        }

        std::unique_ptr<InlineTextBox> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class InlineTextBox;
        InlineTextBoxBuilder()
            : m_result(new InlineTextBox())
        {
        }

        template <int STEP> InlineTextBoxBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<InlineTextBoxBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::DOMSnapshot::InlineTextBox> m_result;
    };

    static InlineTextBoxBuilder<0> create()
    {
        return InlineTextBoxBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    InlineTextBox()
    {
        m_startCharacterIndex = 0;
        m_numCharacters = 0;
    }

    std::unique_ptr<protocol::DOM::Rect> m_boundingBox;
    int m_startCharacterIndex;
    int m_numCharacters;
};

class CORE_EXPORT LayoutTreeNode : public ::crdtp::ProtocolObject<LayoutTreeNode> {
public:
    ~LayoutTreeNode() override
    {
    }

    int getDomNodeIndex()
    {
        return m_domNodeIndex;
    }
    void setDomNodeIndex(int value)
    {
        m_domNodeIndex = value;
    }

    protocol::DOM::Rect* getBoundingBox()
    {
        return m_boundingBox.get();
    }
    void setBoundingBox(std::unique_ptr<protocol::DOM::Rect> value)
    {
        m_boundingBox = std::move(value);
    }

    bool hasLayoutText()
    {
        return m_layoutText.has_value();
    }
    String getLayoutText(const String& defaultValue) const
    {
        return m_layoutText.value_or(defaultValue);
    }
    void setLayoutText(const String& value)
    {
        m_layoutText = value;
    }

    bool hasInlineTextNodes()
    {
        return m_inlineTextNodes.has_value();
    }
    protocol::Array<protocol::DOMSnapshot::InlineTextBox>* getInlineTextNodes(protocol::Array<protocol::DOMSnapshot::InlineTextBox>* defaultValue)
    {
        return m_inlineTextNodes.has_value() ? &m_inlineTextNodes.value() : defaultValue;
    }
    void setInlineTextNodes(std::unique_ptr<protocol::Array<protocol::DOMSnapshot::InlineTextBox>> value)
    {
        m_inlineTextNodes = std::move(value);
    }

    bool hasStyleIndex()
    {
        return m_styleIndex.has_value();
    }
    int getStyleIndex(int defaultValue) const
    {
        return m_styleIndex.value_or(defaultValue);
    }
    void setStyleIndex(int value)
    {
        m_styleIndex = value;
    }

    bool hasPaintOrder()
    {
        return m_paintOrder.has_value();
    }
    int getPaintOrder(int defaultValue) const
    {
        return m_paintOrder.value_or(defaultValue);
    }
    void setPaintOrder(int value)
    {
        m_paintOrder = value;
    }

    bool hasIsStackingContext()
    {
        return m_isStackingContext.has_value();
    }
    bool getIsStackingContext(bool defaultValue) const
    {
        return m_isStackingContext.value_or(defaultValue);
    }
    void setIsStackingContext(bool value)
    {
        m_isStackingContext = value;
    }

    template <int STATE> class LayoutTreeNodeBuilder {
    public:
        enum { NoFieldsSet = 0, DomNodeIndexSet = 1 << 1, BoundingBoxSet = 1 << 2, AllFieldsSet = (DomNodeIndexSet | BoundingBoxSet | 0) };

        LayoutTreeNodeBuilder<STATE | DomNodeIndexSet>& setDomNodeIndex(int value)
        {
            static_assert(!(STATE & DomNodeIndexSet), "property domNodeIndex should not be set yet");
            m_result->setDomNodeIndex(value);
            return castState<DomNodeIndexSet>();
        }

        LayoutTreeNodeBuilder<STATE | BoundingBoxSet>& setBoundingBox(std::unique_ptr<protocol::DOM::Rect> value)
        {
            static_assert(!(STATE & BoundingBoxSet), "property boundingBox should not be set yet");
            m_result->setBoundingBox(std::move(value));
            return castState<BoundingBoxSet>();
        }

        LayoutTreeNodeBuilder<STATE>& setLayoutText(const String& value)
        {
            m_result->setLayoutText(value);
            return *this;
        }

        LayoutTreeNodeBuilder<STATE>& setInlineTextNodes(std::unique_ptr<protocol::Array<protocol::DOMSnapshot::InlineTextBox>> value)
        {
            m_result->setInlineTextNodes(std::move(value));
            return *this;
        }

        LayoutTreeNodeBuilder<STATE>& setStyleIndex(int value)
        {
            m_result->setStyleIndex(value);
            return *this;
        }

        LayoutTreeNodeBuilder<STATE>& setPaintOrder(int value)
        {
            m_result->setPaintOrder(value);
            return *this;
        }

        LayoutTreeNodeBuilder<STATE>& setIsStackingContext(bool value)
        {
            m_result->setIsStackingContext(value);
            return *this;
        }

        std::unique_ptr<LayoutTreeNode> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class LayoutTreeNode;
        LayoutTreeNodeBuilder()
            : m_result(new LayoutTreeNode())
        {
        }

        template <int STEP> LayoutTreeNodeBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<LayoutTreeNodeBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::DOMSnapshot::LayoutTreeNode> m_result;
    };

    static LayoutTreeNodeBuilder<0> create()
    {
        return LayoutTreeNodeBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    LayoutTreeNode()
    {
        m_domNodeIndex = 0;
    }

    int m_domNodeIndex;
    std::unique_ptr<protocol::DOM::Rect> m_boundingBox;
    Maybe<String> m_layoutText;
    Maybe<protocol::Array<protocol::DOMSnapshot::InlineTextBox>> m_inlineTextNodes;
    Maybe<int> m_styleIndex;
    Maybe<int> m_paintOrder;
    Maybe<bool> m_isStackingContext;
};

class CORE_EXPORT ComputedStyle : public ::crdtp::ProtocolObject<ComputedStyle> {
public:
    ~ComputedStyle() override
    {
    }

    protocol::Array<protocol::DOMSnapshot::NameValue>* getProperties()
    {
        return m_properties.get();
    }
    void setProperties(std::unique_ptr<protocol::Array<protocol::DOMSnapshot::NameValue>> value)
    {
        m_properties = std::move(value);
    }

    template <int STATE> class ComputedStyleBuilder {
    public:
        enum { NoFieldsSet = 0, PropertiesSet = 1 << 1, AllFieldsSet = (PropertiesSet | 0) };

        ComputedStyleBuilder<STATE | PropertiesSet>& setProperties(std::unique_ptr<protocol::Array<protocol::DOMSnapshot::NameValue>> value)
        {
            static_assert(!(STATE & PropertiesSet), "property properties should not be set yet");
            m_result->setProperties(std::move(value));
            return castState<PropertiesSet>();
        }

        std::unique_ptr<ComputedStyle> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class ComputedStyle;
        ComputedStyleBuilder()
            : m_result(new ComputedStyle())
        {
        }

        template <int STEP> ComputedStyleBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<ComputedStyleBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::DOMSnapshot::ComputedStyle> m_result;
    };

    static ComputedStyleBuilder<0> create()
    {
        return ComputedStyleBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    ComputedStyle()
    {
    }

    std::unique_ptr<protocol::Array<protocol::DOMSnapshot::NameValue>> m_properties;
};

class CORE_EXPORT NameValue : public ::crdtp::ProtocolObject<NameValue> {
public:
    ~NameValue() override
    {
    }

    String getName()
    {
        return m_name;
    }
    void setName(const String& value)
    {
        m_name = value;
    }

    String getValue()
    {
        return m_value;
    }
    void setValue(const String& value)
    {
        m_value = value;
    }

    template <int STATE> class NameValueBuilder {
    public:
        enum { NoFieldsSet = 0, NameSet = 1 << 1, ValueSet = 1 << 2, AllFieldsSet = (NameSet | ValueSet | 0) };

        NameValueBuilder<STATE | NameSet>& setName(const String& value)
        {
            static_assert(!(STATE & NameSet), "property name should not be set yet");
            m_result->setName(value);
            return castState<NameSet>();
        }

        NameValueBuilder<STATE | ValueSet>& setValue(const String& value)
        {
            static_assert(!(STATE & ValueSet), "property value should not be set yet");
            m_result->setValue(value);
            return castState<ValueSet>();
        }

        std::unique_ptr<NameValue> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class NameValue;
        NameValueBuilder()
            : m_result(new NameValue())
        {
        }

        template <int STEP> NameValueBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<NameValueBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::DOMSnapshot::NameValue> m_result;
    };

    static NameValueBuilder<0> create()
    {
        return NameValueBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    NameValue()
    {
    }

    String m_name;
    String m_value;
};

class CORE_EXPORT RareStringData : public ::crdtp::ProtocolObject<RareStringData> {
public:
    ~RareStringData() override
    {
    }

    protocol::Array<int>* getIndex()
    {
        return m_index.get();
    }
    void setIndex(std::unique_ptr<protocol::Array<int>> value)
    {
        m_index = std::move(value);
    }

    protocol::Array<int>* getValue()
    {
        return m_value.get();
    }
    void setValue(std::unique_ptr<protocol::Array<int>> value)
    {
        m_value = std::move(value);
    }

    template <int STATE> class RareStringDataBuilder {
    public:
        enum { NoFieldsSet = 0, IndexSet = 1 << 1, ValueSet = 1 << 2, AllFieldsSet = (IndexSet | ValueSet | 0) };

        RareStringDataBuilder<STATE | IndexSet>& setIndex(std::unique_ptr<protocol::Array<int>> value)
        {
            static_assert(!(STATE & IndexSet), "property index should not be set yet");
            m_result->setIndex(std::move(value));
            return castState<IndexSet>();
        }

        RareStringDataBuilder<STATE | ValueSet>& setValue(std::unique_ptr<protocol::Array<int>> value)
        {
            static_assert(!(STATE & ValueSet), "property value should not be set yet");
            m_result->setValue(std::move(value));
            return castState<ValueSet>();
        }

        std::unique_ptr<RareStringData> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class RareStringData;
        RareStringDataBuilder()
            : m_result(new RareStringData())
        {
        }

        template <int STEP> RareStringDataBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<RareStringDataBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::DOMSnapshot::RareStringData> m_result;
    };

    static RareStringDataBuilder<0> create()
    {
        return RareStringDataBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    RareStringData()
    {
    }

    std::unique_ptr<protocol::Array<int>> m_index;
    std::unique_ptr<protocol::Array<int>> m_value;
};

class CORE_EXPORT RareBooleanData : public ::crdtp::ProtocolObject<RareBooleanData> {
public:
    ~RareBooleanData() override
    {
    }

    protocol::Array<int>* getIndex()
    {
        return m_index.get();
    }
    void setIndex(std::unique_ptr<protocol::Array<int>> value)
    {
        m_index = std::move(value);
    }

    template <int STATE> class RareBooleanDataBuilder {
    public:
        enum { NoFieldsSet = 0, IndexSet = 1 << 1, AllFieldsSet = (IndexSet | 0) };

        RareBooleanDataBuilder<STATE | IndexSet>& setIndex(std::unique_ptr<protocol::Array<int>> value)
        {
            static_assert(!(STATE & IndexSet), "property index should not be set yet");
            m_result->setIndex(std::move(value));
            return castState<IndexSet>();
        }

        std::unique_ptr<RareBooleanData> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class RareBooleanData;
        RareBooleanDataBuilder()
            : m_result(new RareBooleanData())
        {
        }

        template <int STEP> RareBooleanDataBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<RareBooleanDataBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::DOMSnapshot::RareBooleanData> m_result;
    };

    static RareBooleanDataBuilder<0> create()
    {
        return RareBooleanDataBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    RareBooleanData()
    {
    }

    std::unique_ptr<protocol::Array<int>> m_index;
};

class CORE_EXPORT RareIntegerData : public ::crdtp::ProtocolObject<RareIntegerData> {
public:
    ~RareIntegerData() override
    {
    }

    protocol::Array<int>* getIndex()
    {
        return m_index.get();
    }
    void setIndex(std::unique_ptr<protocol::Array<int>> value)
    {
        m_index = std::move(value);
    }

    protocol::Array<int>* getValue()
    {
        return m_value.get();
    }
    void setValue(std::unique_ptr<protocol::Array<int>> value)
    {
        m_value = std::move(value);
    }

    template <int STATE> class RareIntegerDataBuilder {
    public:
        enum { NoFieldsSet = 0, IndexSet = 1 << 1, ValueSet = 1 << 2, AllFieldsSet = (IndexSet | ValueSet | 0) };

        RareIntegerDataBuilder<STATE | IndexSet>& setIndex(std::unique_ptr<protocol::Array<int>> value)
        {
            static_assert(!(STATE & IndexSet), "property index should not be set yet");
            m_result->setIndex(std::move(value));
            return castState<IndexSet>();
        }

        RareIntegerDataBuilder<STATE | ValueSet>& setValue(std::unique_ptr<protocol::Array<int>> value)
        {
            static_assert(!(STATE & ValueSet), "property value should not be set yet");
            m_result->setValue(std::move(value));
            return castState<ValueSet>();
        }

        std::unique_ptr<RareIntegerData> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class RareIntegerData;
        RareIntegerDataBuilder()
            : m_result(new RareIntegerData())
        {
        }

        template <int STEP> RareIntegerDataBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<RareIntegerDataBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::DOMSnapshot::RareIntegerData> m_result;
    };

    static RareIntegerDataBuilder<0> create()
    {
        return RareIntegerDataBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    RareIntegerData()
    {
    }

    std::unique_ptr<protocol::Array<int>> m_index;
    std::unique_ptr<protocol::Array<int>> m_value;
};

class CORE_EXPORT DocumentSnapshot : public ::crdtp::ProtocolObject<DocumentSnapshot> {
public:
    ~DocumentSnapshot() override
    {
    }

    int getDocumentURL()
    {
        return m_documentURL;
    }
    void setDocumentURL(int value)
    {
        m_documentURL = value;
    }

    int getTitle()
    {
        return m_title;
    }
    void setTitle(int value)
    {
        m_title = value;
    }

    int getBaseURL()
    {
        return m_baseURL;
    }
    void setBaseURL(int value)
    {
        m_baseURL = value;
    }

    int getContentLanguage()
    {
        return m_contentLanguage;
    }
    void setContentLanguage(int value)
    {
        m_contentLanguage = value;
    }

    int getEncodingName()
    {
        return m_encodingName;
    }
    void setEncodingName(int value)
    {
        m_encodingName = value;
    }

    int getPublicId()
    {
        return m_publicId;
    }
    void setPublicId(int value)
    {
        m_publicId = value;
    }

    int getSystemId()
    {
        return m_systemId;
    }
    void setSystemId(int value)
    {
        m_systemId = value;
    }

    int getFrameId()
    {
        return m_frameId;
    }
    void setFrameId(int value)
    {
        m_frameId = value;
    }

    protocol::DOMSnapshot::NodeTreeSnapshot* getNodes()
    {
        return m_nodes.get();
    }
    void setNodes(std::unique_ptr<protocol::DOMSnapshot::NodeTreeSnapshot> value)
    {
        m_nodes = std::move(value);
    }

    protocol::DOMSnapshot::LayoutTreeSnapshot* getLayout()
    {
        return m_layout.get();
    }
    void setLayout(std::unique_ptr<protocol::DOMSnapshot::LayoutTreeSnapshot> value)
    {
        m_layout = std::move(value);
    }

    protocol::DOMSnapshot::TextBoxSnapshot* getTextBoxes()
    {
        return m_textBoxes.get();
    }
    void setTextBoxes(std::unique_ptr<protocol::DOMSnapshot::TextBoxSnapshot> value)
    {
        m_textBoxes = std::move(value);
    }

    bool hasScrollOffsetX()
    {
        return m_scrollOffsetX.has_value();
    }
    double getScrollOffsetX(double defaultValue) const
    {
        return m_scrollOffsetX.value_or(defaultValue);
    }
    void setScrollOffsetX(double value)
    {
        m_scrollOffsetX = value;
    }

    bool hasScrollOffsetY()
    {
        return m_scrollOffsetY.has_value();
    }
    double getScrollOffsetY(double defaultValue) const
    {
        return m_scrollOffsetY.value_or(defaultValue);
    }
    void setScrollOffsetY(double value)
    {
        m_scrollOffsetY = value;
    }

    bool hasContentWidth()
    {
        return m_contentWidth.has_value();
    }
    double getContentWidth(double defaultValue) const
    {
        return m_contentWidth.value_or(defaultValue);
    }
    void setContentWidth(double value)
    {
        m_contentWidth = value;
    }

    bool hasContentHeight()
    {
        return m_contentHeight.has_value();
    }
    double getContentHeight(double defaultValue) const
    {
        return m_contentHeight.value_or(defaultValue);
    }
    void setContentHeight(double value)
    {
        m_contentHeight = value;
    }

    template <int STATE> class DocumentSnapshotBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            DocumentURLSet = 1 << 1,
            TitleSet = 1 << 2,
            BaseURLSet = 1 << 3,
            ContentLanguageSet = 1 << 4,
            EncodingNameSet = 1 << 5,
            PublicIdSet = 1 << 6,
            SystemIdSet = 1 << 7,
            FrameIdSet = 1 << 8,
            NodesSet = 1 << 9,
            LayoutSet = 1 << 10,
            TextBoxesSet = 1 << 11,
            AllFieldsSet = (DocumentURLSet | TitleSet | BaseURLSet | ContentLanguageSet | EncodingNameSet | PublicIdSet | SystemIdSet | FrameIdSet | NodesSet
                | LayoutSet | TextBoxesSet | 0)
        };

        DocumentSnapshotBuilder<STATE | DocumentURLSet>& setDocumentURL(int value)
        {
            static_assert(!(STATE & DocumentURLSet), "property documentURL should not be set yet");
            m_result->setDocumentURL(value);
            return castState<DocumentURLSet>();
        }

        DocumentSnapshotBuilder<STATE | TitleSet>& setTitle(int value)
        {
            static_assert(!(STATE & TitleSet), "property title should not be set yet");
            m_result->setTitle(value);
            return castState<TitleSet>();
        }

        DocumentSnapshotBuilder<STATE | BaseURLSet>& setBaseURL(int value)
        {
            static_assert(!(STATE & BaseURLSet), "property baseURL should not be set yet");
            m_result->setBaseURL(value);
            return castState<BaseURLSet>();
        }

        DocumentSnapshotBuilder<STATE | ContentLanguageSet>& setContentLanguage(int value)
        {
            static_assert(!(STATE & ContentLanguageSet), "property contentLanguage should not be set yet");
            m_result->setContentLanguage(value);
            return castState<ContentLanguageSet>();
        }

        DocumentSnapshotBuilder<STATE | EncodingNameSet>& setEncodingName(int value)
        {
            static_assert(!(STATE & EncodingNameSet), "property encodingName should not be set yet");
            m_result->setEncodingName(value);
            return castState<EncodingNameSet>();
        }

        DocumentSnapshotBuilder<STATE | PublicIdSet>& setPublicId(int value)
        {
            static_assert(!(STATE & PublicIdSet), "property publicId should not be set yet");
            m_result->setPublicId(value);
            return castState<PublicIdSet>();
        }

        DocumentSnapshotBuilder<STATE | SystemIdSet>& setSystemId(int value)
        {
            static_assert(!(STATE & SystemIdSet), "property systemId should not be set yet");
            m_result->setSystemId(value);
            return castState<SystemIdSet>();
        }

        DocumentSnapshotBuilder<STATE | FrameIdSet>& setFrameId(int value)
        {
            static_assert(!(STATE & FrameIdSet), "property frameId should not be set yet");
            m_result->setFrameId(value);
            return castState<FrameIdSet>();
        }

        DocumentSnapshotBuilder<STATE | NodesSet>& setNodes(std::unique_ptr<protocol::DOMSnapshot::NodeTreeSnapshot> value)
        {
            static_assert(!(STATE & NodesSet), "property nodes should not be set yet");
            m_result->setNodes(std::move(value));
            return castState<NodesSet>();
        }

        DocumentSnapshotBuilder<STATE | LayoutSet>& setLayout(std::unique_ptr<protocol::DOMSnapshot::LayoutTreeSnapshot> value)
        {
            static_assert(!(STATE & LayoutSet), "property layout should not be set yet");
            m_result->setLayout(std::move(value));
            return castState<LayoutSet>();
        }

        DocumentSnapshotBuilder<STATE | TextBoxesSet>& setTextBoxes(std::unique_ptr<protocol::DOMSnapshot::TextBoxSnapshot> value)
        {
            static_assert(!(STATE & TextBoxesSet), "property textBoxes should not be set yet");
            m_result->setTextBoxes(std::move(value));
            return castState<TextBoxesSet>();
        }

        DocumentSnapshotBuilder<STATE>& setScrollOffsetX(double value)
        {
            m_result->setScrollOffsetX(value);
            return *this;
        }

        DocumentSnapshotBuilder<STATE>& setScrollOffsetY(double value)
        {
            m_result->setScrollOffsetY(value);
            return *this;
        }

        DocumentSnapshotBuilder<STATE>& setContentWidth(double value)
        {
            m_result->setContentWidth(value);
            return *this;
        }

        DocumentSnapshotBuilder<STATE>& setContentHeight(double value)
        {
            m_result->setContentHeight(value);
            return *this;
        }

        std::unique_ptr<DocumentSnapshot> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class DocumentSnapshot;
        DocumentSnapshotBuilder()
            : m_result(new DocumentSnapshot())
        {
        }

        template <int STEP> DocumentSnapshotBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<DocumentSnapshotBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::DOMSnapshot::DocumentSnapshot> m_result;
    };

    static DocumentSnapshotBuilder<0> create()
    {
        return DocumentSnapshotBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    DocumentSnapshot()
    {
        m_documentURL = 0;
        m_title = 0;
        m_baseURL = 0;
        m_contentLanguage = 0;
        m_encodingName = 0;
        m_publicId = 0;
        m_systemId = 0;
        m_frameId = 0;
    }

    int m_documentURL;
    int m_title;
    int m_baseURL;
    int m_contentLanguage;
    int m_encodingName;
    int m_publicId;
    int m_systemId;
    int m_frameId;
    std::unique_ptr<protocol::DOMSnapshot::NodeTreeSnapshot> m_nodes;
    std::unique_ptr<protocol::DOMSnapshot::LayoutTreeSnapshot> m_layout;
    std::unique_ptr<protocol::DOMSnapshot::TextBoxSnapshot> m_textBoxes;
    Maybe<double> m_scrollOffsetX;
    Maybe<double> m_scrollOffsetY;
    Maybe<double> m_contentWidth;
    Maybe<double> m_contentHeight;
};

class CORE_EXPORT NodeTreeSnapshot : public ::crdtp::ProtocolObject<NodeTreeSnapshot> {
public:
    ~NodeTreeSnapshot() override
    {
    }

    bool hasParentIndex()
    {
        return m_parentIndex.has_value();
    }
    protocol::Array<int>* getParentIndex(protocol::Array<int>* defaultValue)
    {
        return m_parentIndex.has_value() ? &m_parentIndex.value() : defaultValue;
    }
    void setParentIndex(std::unique_ptr<protocol::Array<int>> value)
    {
        m_parentIndex = std::move(value);
    }

    bool hasNodeType()
    {
        return m_nodeType.has_value();
    }
    protocol::Array<int>* getNodeType(protocol::Array<int>* defaultValue)
    {
        return m_nodeType.has_value() ? &m_nodeType.value() : defaultValue;
    }
    void setNodeType(std::unique_ptr<protocol::Array<int>> value)
    {
        m_nodeType = std::move(value);
    }

    bool hasShadowRootType()
    {
        return m_shadowRootType.has_value();
    }
    protocol::DOMSnapshot::RareStringData* getShadowRootType(protocol::DOMSnapshot::RareStringData* defaultValue)
    {
        return m_shadowRootType.has_value() ? &m_shadowRootType.value() : defaultValue;
    }
    void setShadowRootType(std::unique_ptr<protocol::DOMSnapshot::RareStringData> value)
    {
        m_shadowRootType = std::move(value);
    }

    bool hasNodeName()
    {
        return m_nodeName.has_value();
    }
    protocol::Array<int>* getNodeName(protocol::Array<int>* defaultValue)
    {
        return m_nodeName.has_value() ? &m_nodeName.value() : defaultValue;
    }
    void setNodeName(std::unique_ptr<protocol::Array<int>> value)
    {
        m_nodeName = std::move(value);
    }

    bool hasNodeValue()
    {
        return m_nodeValue.has_value();
    }
    protocol::Array<int>* getNodeValue(protocol::Array<int>* defaultValue)
    {
        return m_nodeValue.has_value() ? &m_nodeValue.value() : defaultValue;
    }
    void setNodeValue(std::unique_ptr<protocol::Array<int>> value)
    {
        m_nodeValue = std::move(value);
    }

    bool hasBackendNodeId()
    {
        return m_backendNodeId.has_value();
    }
    protocol::Array<int>* getBackendNodeId(protocol::Array<int>* defaultValue)
    {
        return m_backendNodeId.has_value() ? &m_backendNodeId.value() : defaultValue;
    }
    void setBackendNodeId(std::unique_ptr<protocol::Array<int>> value)
    {
        m_backendNodeId = std::move(value);
    }

    bool hasAttributes()
    {
        return m_attributes.has_value();
    }
    protocol::Array<protocol::Array<int>>* getAttributes(protocol::Array<protocol::Array<int>>* defaultValue)
    {
        return m_attributes.has_value() ? &m_attributes.value() : defaultValue;
    }
    void setAttributes(std::unique_ptr<protocol::Array<protocol::Array<int>>> value)
    {
        m_attributes = std::move(value);
    }

    bool hasTextValue()
    {
        return m_textValue.has_value();
    }
    protocol::DOMSnapshot::RareStringData* getTextValue(protocol::DOMSnapshot::RareStringData* defaultValue)
    {
        return m_textValue.has_value() ? &m_textValue.value() : defaultValue;
    }
    void setTextValue(std::unique_ptr<protocol::DOMSnapshot::RareStringData> value)
    {
        m_textValue = std::move(value);
    }

    bool hasInputValue()
    {
        return m_inputValue.has_value();
    }
    protocol::DOMSnapshot::RareStringData* getInputValue(protocol::DOMSnapshot::RareStringData* defaultValue)
    {
        return m_inputValue.has_value() ? &m_inputValue.value() : defaultValue;
    }
    void setInputValue(std::unique_ptr<protocol::DOMSnapshot::RareStringData> value)
    {
        m_inputValue = std::move(value);
    }

    bool hasInputChecked()
    {
        return m_inputChecked.has_value();
    }
    protocol::DOMSnapshot::RareBooleanData* getInputChecked(protocol::DOMSnapshot::RareBooleanData* defaultValue)
    {
        return m_inputChecked.has_value() ? &m_inputChecked.value() : defaultValue;
    }
    void setInputChecked(std::unique_ptr<protocol::DOMSnapshot::RareBooleanData> value)
    {
        m_inputChecked = std::move(value);
    }

    bool hasOptionSelected()
    {
        return m_optionSelected.has_value();
    }
    protocol::DOMSnapshot::RareBooleanData* getOptionSelected(protocol::DOMSnapshot::RareBooleanData* defaultValue)
    {
        return m_optionSelected.has_value() ? &m_optionSelected.value() : defaultValue;
    }
    void setOptionSelected(std::unique_ptr<protocol::DOMSnapshot::RareBooleanData> value)
    {
        m_optionSelected = std::move(value);
    }

    bool hasContentDocumentIndex()
    {
        return m_contentDocumentIndex.has_value();
    }
    protocol::DOMSnapshot::RareIntegerData* getContentDocumentIndex(protocol::DOMSnapshot::RareIntegerData* defaultValue)
    {
        return m_contentDocumentIndex.has_value() ? &m_contentDocumentIndex.value() : defaultValue;
    }
    void setContentDocumentIndex(std::unique_ptr<protocol::DOMSnapshot::RareIntegerData> value)
    {
        m_contentDocumentIndex = std::move(value);
    }

    bool hasPseudoType()
    {
        return m_pseudoType.has_value();
    }
    protocol::DOMSnapshot::RareStringData* getPseudoType(protocol::DOMSnapshot::RareStringData* defaultValue)
    {
        return m_pseudoType.has_value() ? &m_pseudoType.value() : defaultValue;
    }
    void setPseudoType(std::unique_ptr<protocol::DOMSnapshot::RareStringData> value)
    {
        m_pseudoType = std::move(value);
    }

    bool hasPseudoIdentifier()
    {
        return m_pseudoIdentifier.has_value();
    }
    protocol::DOMSnapshot::RareStringData* getPseudoIdentifier(protocol::DOMSnapshot::RareStringData* defaultValue)
    {
        return m_pseudoIdentifier.has_value() ? &m_pseudoIdentifier.value() : defaultValue;
    }
    void setPseudoIdentifier(std::unique_ptr<protocol::DOMSnapshot::RareStringData> value)
    {
        m_pseudoIdentifier = std::move(value);
    }

    bool hasIsClickable()
    {
        return m_isClickable.has_value();
    }
    protocol::DOMSnapshot::RareBooleanData* getIsClickable(protocol::DOMSnapshot::RareBooleanData* defaultValue)
    {
        return m_isClickable.has_value() ? &m_isClickable.value() : defaultValue;
    }
    void setIsClickable(std::unique_ptr<protocol::DOMSnapshot::RareBooleanData> value)
    {
        m_isClickable = std::move(value);
    }

    bool hasCurrentSourceURL()
    {
        return m_currentSourceURL.has_value();
    }
    protocol::DOMSnapshot::RareStringData* getCurrentSourceURL(protocol::DOMSnapshot::RareStringData* defaultValue)
    {
        return m_currentSourceURL.has_value() ? &m_currentSourceURL.value() : defaultValue;
    }
    void setCurrentSourceURL(std::unique_ptr<protocol::DOMSnapshot::RareStringData> value)
    {
        m_currentSourceURL = std::move(value);
    }

    bool hasOriginURL()
    {
        return m_originURL.has_value();
    }
    protocol::DOMSnapshot::RareStringData* getOriginURL(protocol::DOMSnapshot::RareStringData* defaultValue)
    {
        return m_originURL.has_value() ? &m_originURL.value() : defaultValue;
    }
    void setOriginURL(std::unique_ptr<protocol::DOMSnapshot::RareStringData> value)
    {
        m_originURL = std::move(value);
    }

    template <int STATE> class NodeTreeSnapshotBuilder {
    public:
        enum { NoFieldsSet = 0, AllFieldsSet = (0) };

        NodeTreeSnapshotBuilder<STATE>& setParentIndex(std::unique_ptr<protocol::Array<int>> value)
        {
            m_result->setParentIndex(std::move(value));
            return *this;
        }

        NodeTreeSnapshotBuilder<STATE>& setNodeType(std::unique_ptr<protocol::Array<int>> value)
        {
            m_result->setNodeType(std::move(value));
            return *this;
        }

        NodeTreeSnapshotBuilder<STATE>& setShadowRootType(std::unique_ptr<protocol::DOMSnapshot::RareStringData> value)
        {
            m_result->setShadowRootType(std::move(value));
            return *this;
        }

        NodeTreeSnapshotBuilder<STATE>& setNodeName(std::unique_ptr<protocol::Array<int>> value)
        {
            m_result->setNodeName(std::move(value));
            return *this;
        }

        NodeTreeSnapshotBuilder<STATE>& setNodeValue(std::unique_ptr<protocol::Array<int>> value)
        {
            m_result->setNodeValue(std::move(value));
            return *this;
        }

        NodeTreeSnapshotBuilder<STATE>& setBackendNodeId(std::unique_ptr<protocol::Array<int>> value)
        {
            m_result->setBackendNodeId(std::move(value));
            return *this;
        }

        NodeTreeSnapshotBuilder<STATE>& setAttributes(std::unique_ptr<protocol::Array<protocol::Array<int>>> value)
        {
            m_result->setAttributes(std::move(value));
            return *this;
        }

        NodeTreeSnapshotBuilder<STATE>& setTextValue(std::unique_ptr<protocol::DOMSnapshot::RareStringData> value)
        {
            m_result->setTextValue(std::move(value));
            return *this;
        }

        NodeTreeSnapshotBuilder<STATE>& setInputValue(std::unique_ptr<protocol::DOMSnapshot::RareStringData> value)
        {
            m_result->setInputValue(std::move(value));
            return *this;
        }

        NodeTreeSnapshotBuilder<STATE>& setInputChecked(std::unique_ptr<protocol::DOMSnapshot::RareBooleanData> value)
        {
            m_result->setInputChecked(std::move(value));
            return *this;
        }

        NodeTreeSnapshotBuilder<STATE>& setOptionSelected(std::unique_ptr<protocol::DOMSnapshot::RareBooleanData> value)
        {
            m_result->setOptionSelected(std::move(value));
            return *this;
        }

        NodeTreeSnapshotBuilder<STATE>& setContentDocumentIndex(std::unique_ptr<protocol::DOMSnapshot::RareIntegerData> value)
        {
            m_result->setContentDocumentIndex(std::move(value));
            return *this;
        }

        NodeTreeSnapshotBuilder<STATE>& setPseudoType(std::unique_ptr<protocol::DOMSnapshot::RareStringData> value)
        {
            m_result->setPseudoType(std::move(value));
            return *this;
        }

        NodeTreeSnapshotBuilder<STATE>& setPseudoIdentifier(std::unique_ptr<protocol::DOMSnapshot::RareStringData> value)
        {
            m_result->setPseudoIdentifier(std::move(value));
            return *this;
        }

        NodeTreeSnapshotBuilder<STATE>& setIsClickable(std::unique_ptr<protocol::DOMSnapshot::RareBooleanData> value)
        {
            m_result->setIsClickable(std::move(value));
            return *this;
        }

        NodeTreeSnapshotBuilder<STATE>& setCurrentSourceURL(std::unique_ptr<protocol::DOMSnapshot::RareStringData> value)
        {
            m_result->setCurrentSourceURL(std::move(value));
            return *this;
        }

        NodeTreeSnapshotBuilder<STATE>& setOriginURL(std::unique_ptr<protocol::DOMSnapshot::RareStringData> value)
        {
            m_result->setOriginURL(std::move(value));
            return *this;
        }

        std::unique_ptr<NodeTreeSnapshot> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class NodeTreeSnapshot;
        NodeTreeSnapshotBuilder()
            : m_result(new NodeTreeSnapshot())
        {
        }

        template <int STEP> NodeTreeSnapshotBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<NodeTreeSnapshotBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::DOMSnapshot::NodeTreeSnapshot> m_result;
    };

    static NodeTreeSnapshotBuilder<0> create()
    {
        return NodeTreeSnapshotBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    NodeTreeSnapshot()
    {
    }

    Maybe<protocol::Array<int>> m_parentIndex;
    Maybe<protocol::Array<int>> m_nodeType;
    Maybe<protocol::DOMSnapshot::RareStringData> m_shadowRootType;
    Maybe<protocol::Array<int>> m_nodeName;
    Maybe<protocol::Array<int>> m_nodeValue;
    Maybe<protocol::Array<int>> m_backendNodeId;
    Maybe<protocol::Array<protocol::Array<int>>> m_attributes;
    Maybe<protocol::DOMSnapshot::RareStringData> m_textValue;
    Maybe<protocol::DOMSnapshot::RareStringData> m_inputValue;
    Maybe<protocol::DOMSnapshot::RareBooleanData> m_inputChecked;
    Maybe<protocol::DOMSnapshot::RareBooleanData> m_optionSelected;
    Maybe<protocol::DOMSnapshot::RareIntegerData> m_contentDocumentIndex;
    Maybe<protocol::DOMSnapshot::RareStringData> m_pseudoType;
    Maybe<protocol::DOMSnapshot::RareStringData> m_pseudoIdentifier;
    Maybe<protocol::DOMSnapshot::RareBooleanData> m_isClickable;
    Maybe<protocol::DOMSnapshot::RareStringData> m_currentSourceURL;
    Maybe<protocol::DOMSnapshot::RareStringData> m_originURL;
};

class CORE_EXPORT LayoutTreeSnapshot : public ::crdtp::ProtocolObject<LayoutTreeSnapshot> {
public:
    ~LayoutTreeSnapshot() override
    {
    }

    protocol::Array<int>* getNodeIndex()
    {
        return m_nodeIndex.get();
    }
    void setNodeIndex(std::unique_ptr<protocol::Array<int>> value)
    {
        m_nodeIndex = std::move(value);
    }

    protocol::Array<protocol::Array<int>>* getStyles()
    {
        return m_styles.get();
    }
    void setStyles(std::unique_ptr<protocol::Array<protocol::Array<int>>> value)
    {
        m_styles = std::move(value);
    }

    protocol::Array<protocol::Array<double>>* getBounds()
    {
        return m_bounds.get();
    }
    void setBounds(std::unique_ptr<protocol::Array<protocol::Array<double>>> value)
    {
        m_bounds = std::move(value);
    }

    protocol::Array<int>* getText()
    {
        return m_text.get();
    }
    void setText(std::unique_ptr<protocol::Array<int>> value)
    {
        m_text = std::move(value);
    }

    protocol::DOMSnapshot::RareBooleanData* getStackingContexts()
    {
        return m_stackingContexts.get();
    }
    void setStackingContexts(std::unique_ptr<protocol::DOMSnapshot::RareBooleanData> value)
    {
        m_stackingContexts = std::move(value);
    }

    bool hasPaintOrders()
    {
        return m_paintOrders.has_value();
    }
    protocol::Array<int>* getPaintOrders(protocol::Array<int>* defaultValue)
    {
        return m_paintOrders.has_value() ? &m_paintOrders.value() : defaultValue;
    }
    void setPaintOrders(std::unique_ptr<protocol::Array<int>> value)
    {
        m_paintOrders = std::move(value);
    }

    bool hasOffsetRects()
    {
        return m_offsetRects.has_value();
    }
    protocol::Array<protocol::Array<double>>* getOffsetRects(protocol::Array<protocol::Array<double>>* defaultValue)
    {
        return m_offsetRects.has_value() ? &m_offsetRects.value() : defaultValue;
    }
    void setOffsetRects(std::unique_ptr<protocol::Array<protocol::Array<double>>> value)
    {
        m_offsetRects = std::move(value);
    }

    bool hasScrollRects()
    {
        return m_scrollRects.has_value();
    }
    protocol::Array<protocol::Array<double>>* getScrollRects(protocol::Array<protocol::Array<double>>* defaultValue)
    {
        return m_scrollRects.has_value() ? &m_scrollRects.value() : defaultValue;
    }
    void setScrollRects(std::unique_ptr<protocol::Array<protocol::Array<double>>> value)
    {
        m_scrollRects = std::move(value);
    }

    bool hasClientRects()
    {
        return m_clientRects.has_value();
    }
    protocol::Array<protocol::Array<double>>* getClientRects(protocol::Array<protocol::Array<double>>* defaultValue)
    {
        return m_clientRects.has_value() ? &m_clientRects.value() : defaultValue;
    }
    void setClientRects(std::unique_ptr<protocol::Array<protocol::Array<double>>> value)
    {
        m_clientRects = std::move(value);
    }

    bool hasBlendedBackgroundColors()
    {
        return m_blendedBackgroundColors.has_value();
    }
    protocol::Array<int>* getBlendedBackgroundColors(protocol::Array<int>* defaultValue)
    {
        return m_blendedBackgroundColors.has_value() ? &m_blendedBackgroundColors.value() : defaultValue;
    }
    void setBlendedBackgroundColors(std::unique_ptr<protocol::Array<int>> value)
    {
        m_blendedBackgroundColors = std::move(value);
    }

    bool hasTextColorOpacities()
    {
        return m_textColorOpacities.has_value();
    }
    protocol::Array<double>* getTextColorOpacities(protocol::Array<double>* defaultValue)
    {
        return m_textColorOpacities.has_value() ? &m_textColorOpacities.value() : defaultValue;
    }
    void setTextColorOpacities(std::unique_ptr<protocol::Array<double>> value)
    {
        m_textColorOpacities = std::move(value);
    }

    template <int STATE> class LayoutTreeSnapshotBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            NodeIndexSet = 1 << 1,
            StylesSet = 1 << 2,
            BoundsSet = 1 << 3,
            TextSet = 1 << 4,
            StackingContextsSet = 1 << 5,
            AllFieldsSet = (NodeIndexSet | StylesSet | BoundsSet | TextSet | StackingContextsSet | 0)
        };

        LayoutTreeSnapshotBuilder<STATE | NodeIndexSet>& setNodeIndex(std::unique_ptr<protocol::Array<int>> value)
        {
            static_assert(!(STATE & NodeIndexSet), "property nodeIndex should not be set yet");
            m_result->setNodeIndex(std::move(value));
            return castState<NodeIndexSet>();
        }

        LayoutTreeSnapshotBuilder<STATE | StylesSet>& setStyles(std::unique_ptr<protocol::Array<protocol::Array<int>>> value)
        {
            static_assert(!(STATE & StylesSet), "property styles should not be set yet");
            m_result->setStyles(std::move(value));
            return castState<StylesSet>();
        }

        LayoutTreeSnapshotBuilder<STATE | BoundsSet>& setBounds(std::unique_ptr<protocol::Array<protocol::Array<double>>> value)
        {
            static_assert(!(STATE & BoundsSet), "property bounds should not be set yet");
            m_result->setBounds(std::move(value));
            return castState<BoundsSet>();
        }

        LayoutTreeSnapshotBuilder<STATE | TextSet>& setText(std::unique_ptr<protocol::Array<int>> value)
        {
            static_assert(!(STATE & TextSet), "property text should not be set yet");
            m_result->setText(std::move(value));
            return castState<TextSet>();
        }

        LayoutTreeSnapshotBuilder<STATE | StackingContextsSet>& setStackingContexts(std::unique_ptr<protocol::DOMSnapshot::RareBooleanData> value)
        {
            static_assert(!(STATE & StackingContextsSet), "property stackingContexts should not be set yet");
            m_result->setStackingContexts(std::move(value));
            return castState<StackingContextsSet>();
        }

        LayoutTreeSnapshotBuilder<STATE>& setPaintOrders(std::unique_ptr<protocol::Array<int>> value)
        {
            m_result->setPaintOrders(std::move(value));
            return *this;
        }

        LayoutTreeSnapshotBuilder<STATE>& setOffsetRects(std::unique_ptr<protocol::Array<protocol::Array<double>>> value)
        {
            m_result->setOffsetRects(std::move(value));
            return *this;
        }

        LayoutTreeSnapshotBuilder<STATE>& setScrollRects(std::unique_ptr<protocol::Array<protocol::Array<double>>> value)
        {
            m_result->setScrollRects(std::move(value));
            return *this;
        }

        LayoutTreeSnapshotBuilder<STATE>& setClientRects(std::unique_ptr<protocol::Array<protocol::Array<double>>> value)
        {
            m_result->setClientRects(std::move(value));
            return *this;
        }

        LayoutTreeSnapshotBuilder<STATE>& setBlendedBackgroundColors(std::unique_ptr<protocol::Array<int>> value)
        {
            m_result->setBlendedBackgroundColors(std::move(value));
            return *this;
        }

        LayoutTreeSnapshotBuilder<STATE>& setTextColorOpacities(std::unique_ptr<protocol::Array<double>> value)
        {
            m_result->setTextColorOpacities(std::move(value));
            return *this;
        }

        std::unique_ptr<LayoutTreeSnapshot> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class LayoutTreeSnapshot;
        LayoutTreeSnapshotBuilder()
            : m_result(new LayoutTreeSnapshot())
        {
        }

        template <int STEP> LayoutTreeSnapshotBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<LayoutTreeSnapshotBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::DOMSnapshot::LayoutTreeSnapshot> m_result;
    };

    static LayoutTreeSnapshotBuilder<0> create()
    {
        return LayoutTreeSnapshotBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    LayoutTreeSnapshot()
    {
    }

    std::unique_ptr<protocol::Array<int>> m_nodeIndex;
    std::unique_ptr<protocol::Array<protocol::Array<int>>> m_styles;
    std::unique_ptr<protocol::Array<protocol::Array<double>>> m_bounds;
    std::unique_ptr<protocol::Array<int>> m_text;
    std::unique_ptr<protocol::DOMSnapshot::RareBooleanData> m_stackingContexts;
    Maybe<protocol::Array<int>> m_paintOrders;
    Maybe<protocol::Array<protocol::Array<double>>> m_offsetRects;
    Maybe<protocol::Array<protocol::Array<double>>> m_scrollRects;
    Maybe<protocol::Array<protocol::Array<double>>> m_clientRects;
    Maybe<protocol::Array<int>> m_blendedBackgroundColors;
    Maybe<protocol::Array<double>> m_textColorOpacities;
};

class CORE_EXPORT TextBoxSnapshot : public ::crdtp::ProtocolObject<TextBoxSnapshot> {
public:
    ~TextBoxSnapshot() override
    {
    }

    protocol::Array<int>* getLayoutIndex()
    {
        return m_layoutIndex.get();
    }
    void setLayoutIndex(std::unique_ptr<protocol::Array<int>> value)
    {
        m_layoutIndex = std::move(value);
    }

    protocol::Array<protocol::Array<double>>* getBounds()
    {
        return m_bounds.get();
    }
    void setBounds(std::unique_ptr<protocol::Array<protocol::Array<double>>> value)
    {
        m_bounds = std::move(value);
    }

    protocol::Array<int>* getStart()
    {
        return m_start.get();
    }
    void setStart(std::unique_ptr<protocol::Array<int>> value)
    {
        m_start = std::move(value);
    }

    protocol::Array<int>* getLength()
    {
        return m_length.get();
    }
    void setLength(std::unique_ptr<protocol::Array<int>> value)
    {
        m_length = std::move(value);
    }

    template <int STATE> class TextBoxSnapshotBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            LayoutIndexSet = 1 << 1,
            BoundsSet = 1 << 2,
            StartSet = 1 << 3,
            LengthSet = 1 << 4,
            AllFieldsSet = (LayoutIndexSet | BoundsSet | StartSet | LengthSet | 0)
        };

        TextBoxSnapshotBuilder<STATE | LayoutIndexSet>& setLayoutIndex(std::unique_ptr<protocol::Array<int>> value)
        {
            static_assert(!(STATE & LayoutIndexSet), "property layoutIndex should not be set yet");
            m_result->setLayoutIndex(std::move(value));
            return castState<LayoutIndexSet>();
        }

        TextBoxSnapshotBuilder<STATE | BoundsSet>& setBounds(std::unique_ptr<protocol::Array<protocol::Array<double>>> value)
        {
            static_assert(!(STATE & BoundsSet), "property bounds should not be set yet");
            m_result->setBounds(std::move(value));
            return castState<BoundsSet>();
        }

        TextBoxSnapshotBuilder<STATE | StartSet>& setStart(std::unique_ptr<protocol::Array<int>> value)
        {
            static_assert(!(STATE & StartSet), "property start should not be set yet");
            m_result->setStart(std::move(value));
            return castState<StartSet>();
        }

        TextBoxSnapshotBuilder<STATE | LengthSet>& setLength(std::unique_ptr<protocol::Array<int>> value)
        {
            static_assert(!(STATE & LengthSet), "property length should not be set yet");
            m_result->setLength(std::move(value));
            return castState<LengthSet>();
        }

        std::unique_ptr<TextBoxSnapshot> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class TextBoxSnapshot;
        TextBoxSnapshotBuilder()
            : m_result(new TextBoxSnapshot())
        {
        }

        template <int STEP> TextBoxSnapshotBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<TextBoxSnapshotBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::DOMSnapshot::TextBoxSnapshot> m_result;
    };

    static TextBoxSnapshotBuilder<0> create()
    {
        return TextBoxSnapshotBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    TextBoxSnapshot()
    {
    }

    std::unique_ptr<protocol::Array<int>> m_layoutIndex;
    std::unique_ptr<protocol::Array<protocol::Array<double>>> m_bounds;
    std::unique_ptr<protocol::Array<int>> m_start;
    std::unique_ptr<protocol::Array<int>> m_length;
};

// ------------- Backend interface.

class CORE_EXPORT Backend {
public:
    virtual ~Backend()
    {
    }

    virtual DispatchResponse disable() = 0;
    virtual DispatchResponse enable() = 0;
    virtual DispatchResponse getSnapshot(std::unique_ptr<protocol::Array<String>> in_computedStyleWhitelist, Maybe<bool> in_includeEventListeners,
        Maybe<bool> in_includePaintOrder, Maybe<bool> in_includeUserAgentShadowTree,
        std::unique_ptr<protocol::Array<protocol::DOMSnapshot::DOMNode>>* out_domNodes,
        std::unique_ptr<protocol::Array<protocol::DOMSnapshot::LayoutTreeNode>>* out_layoutTreeNodes,
        std::unique_ptr<protocol::Array<protocol::DOMSnapshot::ComputedStyle>>* out_computedStyles)
        = 0;
    virtual DispatchResponse captureSnapshot(std::unique_ptr<protocol::Array<String>> in_computedStyles, Maybe<bool> in_includePaintOrder,
        Maybe<bool> in_includeDOMRects, Maybe<bool> in_includeBlendedBackgroundColors, Maybe<bool> in_includeTextColorOpacities,
        std::unique_ptr<protocol::Array<protocol::DOMSnapshot::DocumentSnapshot>>* out_documents, std::unique_ptr<protocol::Array<String>>* out_strings)
        = 0;
};

// ------------- Frontend interface.

class CORE_EXPORT Frontend {
public:
    explicit Frontend(FrontendChannel* frontend_channel)
        : frontend_channel_(frontend_channel)
    {
    }

    void flush();
    void sendRawNotification(std::unique_ptr<Serializable>);

private:
    FrontendChannel* frontend_channel_;
};

// ------------- Dispatcher.

class CORE_EXPORT Dispatcher {
public:
    static void wire(UberDispatcher*, Backend*);

private:
    Dispatcher()
    {
    }
};

// ------------- Metainfo.

class CORE_EXPORT Metainfo {
public:
    using BackendClass = Backend;
    using FrontendClass = Frontend;
    using DispatcherClass = Dispatcher;
    static const char domainName[];
    static const char commandPrefix[];
    static const char version[];
};

} // namespace DOMSnapshot
} // namespace blink
} // namespace protocol

#endif // !defined(blink_protocol_DOMSnapshot_h)
