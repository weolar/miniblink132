// This file is generated by TypeBuilder_h.template.

// Copyright 2016 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef blink_protocol_Overlay_h
#define blink_protocol_Overlay_h

#include "third_party/blink/renderer/core/core_export.h"
#include "third_party/blink/renderer/core/inspector/protocol/protocol.h"
// For each imported domain we generate a ValueConversions struct instead of a full domain definition
// and include Domain::API version from there.
#include "third_party/blink/renderer/core/inspector/protocol/dom.h"
#include "third_party/blink/renderer/core/inspector/protocol/page.h"
#include "third_party/blink/renderer/core/inspector/protocol/runtime.h"

namespace blink {
namespace protocol {
namespace Overlay {
class SourceOrderConfig;
class GridHighlightConfig;
class FlexContainerHighlightConfig;
class FlexItemHighlightConfig;
class LineStyle;
class BoxStyle;
using ContrastAlgorithm = String;
class HighlightConfig;
using ColorFormat = String;
class GridNodeHighlightConfig;
class FlexNodeHighlightConfig;
class ScrollSnapContainerHighlightConfig;
class ScrollSnapHighlightConfig;
class HingeConfig;
class WindowControlsOverlayConfig;
class ContainerQueryHighlightConfig;
class ContainerQueryContainerHighlightConfig;
class IsolatedElementHighlightConfig;
class IsolationModeHighlightConfig;
using InspectMode = String;

// ------------- Forward and enum declarations.

namespace ContrastAlgorithmEnum {
CORE_EXPORT extern const char Aa[];
CORE_EXPORT extern const char Aaa[];
CORE_EXPORT extern const char Apca[];
} // namespace ContrastAlgorithmEnum

namespace ColorFormatEnum {
CORE_EXPORT extern const char Rgb[];
CORE_EXPORT extern const char Hsl[];
CORE_EXPORT extern const char Hwb[];
CORE_EXPORT extern const char Hex[];
} // namespace ColorFormatEnum

namespace InspectModeEnum {
CORE_EXPORT extern const char SearchForNode[];
CORE_EXPORT extern const char SearchForUAShadowDOM[];
CORE_EXPORT extern const char CaptureAreaScreenshot[];
CORE_EXPORT extern const char ShowDistances[];
CORE_EXPORT extern const char None[];
} // namespace InspectModeEnum

// ------------- Type and builder declarations.

class CORE_EXPORT SourceOrderConfig : public ::crdtp::ProtocolObject<SourceOrderConfig> {
public:
    ~SourceOrderConfig() override
    {
    }

    protocol::DOM::RGBA* getParentOutlineColor()
    {
        return m_parentOutlineColor.get();
    }
    void setParentOutlineColor(std::unique_ptr<protocol::DOM::RGBA> value)
    {
        m_parentOutlineColor = std::move(value);
    }

    protocol::DOM::RGBA* getChildOutlineColor()
    {
        return m_childOutlineColor.get();
    }
    void setChildOutlineColor(std::unique_ptr<protocol::DOM::RGBA> value)
    {
        m_childOutlineColor = std::move(value);
    }

    template <int STATE> class SourceOrderConfigBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            ParentOutlineColorSet = 1 << 1,
            ChildOutlineColorSet = 1 << 2,
            AllFieldsSet = (ParentOutlineColorSet | ChildOutlineColorSet | 0)
        };

        SourceOrderConfigBuilder<STATE | ParentOutlineColorSet>& setParentOutlineColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            static_assert(!(STATE & ParentOutlineColorSet), "property parentOutlineColor should not be set yet");
            m_result->setParentOutlineColor(std::move(value));
            return castState<ParentOutlineColorSet>();
        }

        SourceOrderConfigBuilder<STATE | ChildOutlineColorSet>& setChildOutlineColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            static_assert(!(STATE & ChildOutlineColorSet), "property childOutlineColor should not be set yet");
            m_result->setChildOutlineColor(std::move(value));
            return castState<ChildOutlineColorSet>();
        }

        std::unique_ptr<SourceOrderConfig> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class SourceOrderConfig;
        SourceOrderConfigBuilder()
            : m_result(new SourceOrderConfig())
        {
        }

        template <int STEP> SourceOrderConfigBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<SourceOrderConfigBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Overlay::SourceOrderConfig> m_result;
    };

    static SourceOrderConfigBuilder<0> create()
    {
        return SourceOrderConfigBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    SourceOrderConfig()
    {
    }

    std::unique_ptr<protocol::DOM::RGBA> m_parentOutlineColor;
    std::unique_ptr<protocol::DOM::RGBA> m_childOutlineColor;
};

class CORE_EXPORT GridHighlightConfig : public ::crdtp::ProtocolObject<GridHighlightConfig> {
public:
    ~GridHighlightConfig() override
    {
    }

    bool hasShowGridExtensionLines()
    {
        return m_showGridExtensionLines.has_value();
    }
    bool getShowGridExtensionLines(bool defaultValue) const
    {
        return m_showGridExtensionLines.value_or(defaultValue);
    }
    void setShowGridExtensionLines(bool value)
    {
        m_showGridExtensionLines = value;
    }

    bool hasShowPositiveLineNumbers()
    {
        return m_showPositiveLineNumbers.has_value();
    }
    bool getShowPositiveLineNumbers(bool defaultValue) const
    {
        return m_showPositiveLineNumbers.value_or(defaultValue);
    }
    void setShowPositiveLineNumbers(bool value)
    {
        m_showPositiveLineNumbers = value;
    }

    bool hasShowNegativeLineNumbers()
    {
        return m_showNegativeLineNumbers.has_value();
    }
    bool getShowNegativeLineNumbers(bool defaultValue) const
    {
        return m_showNegativeLineNumbers.value_or(defaultValue);
    }
    void setShowNegativeLineNumbers(bool value)
    {
        m_showNegativeLineNumbers = value;
    }

    bool hasShowAreaNames()
    {
        return m_showAreaNames.has_value();
    }
    bool getShowAreaNames(bool defaultValue) const
    {
        return m_showAreaNames.value_or(defaultValue);
    }
    void setShowAreaNames(bool value)
    {
        m_showAreaNames = value;
    }

    bool hasShowLineNames()
    {
        return m_showLineNames.has_value();
    }
    bool getShowLineNames(bool defaultValue) const
    {
        return m_showLineNames.value_or(defaultValue);
    }
    void setShowLineNames(bool value)
    {
        m_showLineNames = value;
    }

    bool hasShowTrackSizes()
    {
        return m_showTrackSizes.has_value();
    }
    bool getShowTrackSizes(bool defaultValue) const
    {
        return m_showTrackSizes.value_or(defaultValue);
    }
    void setShowTrackSizes(bool value)
    {
        m_showTrackSizes = value;
    }

    bool hasGridBorderColor()
    {
        return m_gridBorderColor.has_value();
    }
    protocol::DOM::RGBA* getGridBorderColor(protocol::DOM::RGBA* defaultValue)
    {
        return m_gridBorderColor.has_value() ? &m_gridBorderColor.value() : defaultValue;
    }
    void setGridBorderColor(std::unique_ptr<protocol::DOM::RGBA> value)
    {
        m_gridBorderColor = std::move(value);
    }

    bool hasCellBorderColor()
    {
        return m_cellBorderColor.has_value();
    }
    protocol::DOM::RGBA* getCellBorderColor(protocol::DOM::RGBA* defaultValue)
    {
        return m_cellBorderColor.has_value() ? &m_cellBorderColor.value() : defaultValue;
    }
    void setCellBorderColor(std::unique_ptr<protocol::DOM::RGBA> value)
    {
        m_cellBorderColor = std::move(value);
    }

    bool hasRowLineColor()
    {
        return m_rowLineColor.has_value();
    }
    protocol::DOM::RGBA* getRowLineColor(protocol::DOM::RGBA* defaultValue)
    {
        return m_rowLineColor.has_value() ? &m_rowLineColor.value() : defaultValue;
    }
    void setRowLineColor(std::unique_ptr<protocol::DOM::RGBA> value)
    {
        m_rowLineColor = std::move(value);
    }

    bool hasColumnLineColor()
    {
        return m_columnLineColor.has_value();
    }
    protocol::DOM::RGBA* getColumnLineColor(protocol::DOM::RGBA* defaultValue)
    {
        return m_columnLineColor.has_value() ? &m_columnLineColor.value() : defaultValue;
    }
    void setColumnLineColor(std::unique_ptr<protocol::DOM::RGBA> value)
    {
        m_columnLineColor = std::move(value);
    }

    bool hasGridBorderDash()
    {
        return m_gridBorderDash.has_value();
    }
    bool getGridBorderDash(bool defaultValue) const
    {
        return m_gridBorderDash.value_or(defaultValue);
    }
    void setGridBorderDash(bool value)
    {
        m_gridBorderDash = value;
    }

    bool hasCellBorderDash()
    {
        return m_cellBorderDash.has_value();
    }
    bool getCellBorderDash(bool defaultValue) const
    {
        return m_cellBorderDash.value_or(defaultValue);
    }
    void setCellBorderDash(bool value)
    {
        m_cellBorderDash = value;
    }

    bool hasRowLineDash()
    {
        return m_rowLineDash.has_value();
    }
    bool getRowLineDash(bool defaultValue) const
    {
        return m_rowLineDash.value_or(defaultValue);
    }
    void setRowLineDash(bool value)
    {
        m_rowLineDash = value;
    }

    bool hasColumnLineDash()
    {
        return m_columnLineDash.has_value();
    }
    bool getColumnLineDash(bool defaultValue) const
    {
        return m_columnLineDash.value_or(defaultValue);
    }
    void setColumnLineDash(bool value)
    {
        m_columnLineDash = value;
    }

    bool hasRowGapColor()
    {
        return m_rowGapColor.has_value();
    }
    protocol::DOM::RGBA* getRowGapColor(protocol::DOM::RGBA* defaultValue)
    {
        return m_rowGapColor.has_value() ? &m_rowGapColor.value() : defaultValue;
    }
    void setRowGapColor(std::unique_ptr<protocol::DOM::RGBA> value)
    {
        m_rowGapColor = std::move(value);
    }

    bool hasRowHatchColor()
    {
        return m_rowHatchColor.has_value();
    }
    protocol::DOM::RGBA* getRowHatchColor(protocol::DOM::RGBA* defaultValue)
    {
        return m_rowHatchColor.has_value() ? &m_rowHatchColor.value() : defaultValue;
    }
    void setRowHatchColor(std::unique_ptr<protocol::DOM::RGBA> value)
    {
        m_rowHatchColor = std::move(value);
    }

    bool hasColumnGapColor()
    {
        return m_columnGapColor.has_value();
    }
    protocol::DOM::RGBA* getColumnGapColor(protocol::DOM::RGBA* defaultValue)
    {
        return m_columnGapColor.has_value() ? &m_columnGapColor.value() : defaultValue;
    }
    void setColumnGapColor(std::unique_ptr<protocol::DOM::RGBA> value)
    {
        m_columnGapColor = std::move(value);
    }

    bool hasColumnHatchColor()
    {
        return m_columnHatchColor.has_value();
    }
    protocol::DOM::RGBA* getColumnHatchColor(protocol::DOM::RGBA* defaultValue)
    {
        return m_columnHatchColor.has_value() ? &m_columnHatchColor.value() : defaultValue;
    }
    void setColumnHatchColor(std::unique_ptr<protocol::DOM::RGBA> value)
    {
        m_columnHatchColor = std::move(value);
    }

    bool hasAreaBorderColor()
    {
        return m_areaBorderColor.has_value();
    }
    protocol::DOM::RGBA* getAreaBorderColor(protocol::DOM::RGBA* defaultValue)
    {
        return m_areaBorderColor.has_value() ? &m_areaBorderColor.value() : defaultValue;
    }
    void setAreaBorderColor(std::unique_ptr<protocol::DOM::RGBA> value)
    {
        m_areaBorderColor = std::move(value);
    }

    bool hasGridBackgroundColor()
    {
        return m_gridBackgroundColor.has_value();
    }
    protocol::DOM::RGBA* getGridBackgroundColor(protocol::DOM::RGBA* defaultValue)
    {
        return m_gridBackgroundColor.has_value() ? &m_gridBackgroundColor.value() : defaultValue;
    }
    void setGridBackgroundColor(std::unique_ptr<protocol::DOM::RGBA> value)
    {
        m_gridBackgroundColor = std::move(value);
    }

    template <int STATE> class GridHighlightConfigBuilder {
    public:
        enum { NoFieldsSet = 0, AllFieldsSet = (0) };

        GridHighlightConfigBuilder<STATE>& setShowGridExtensionLines(bool value)
        {
            m_result->setShowGridExtensionLines(value);
            return *this;
        }

        GridHighlightConfigBuilder<STATE>& setShowPositiveLineNumbers(bool value)
        {
            m_result->setShowPositiveLineNumbers(value);
            return *this;
        }

        GridHighlightConfigBuilder<STATE>& setShowNegativeLineNumbers(bool value)
        {
            m_result->setShowNegativeLineNumbers(value);
            return *this;
        }

        GridHighlightConfigBuilder<STATE>& setShowAreaNames(bool value)
        {
            m_result->setShowAreaNames(value);
            return *this;
        }

        GridHighlightConfigBuilder<STATE>& setShowLineNames(bool value)
        {
            m_result->setShowLineNames(value);
            return *this;
        }

        GridHighlightConfigBuilder<STATE>& setShowTrackSizes(bool value)
        {
            m_result->setShowTrackSizes(value);
            return *this;
        }

        GridHighlightConfigBuilder<STATE>& setGridBorderColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setGridBorderColor(std::move(value));
            return *this;
        }

        GridHighlightConfigBuilder<STATE>& setCellBorderColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setCellBorderColor(std::move(value));
            return *this;
        }

        GridHighlightConfigBuilder<STATE>& setRowLineColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setRowLineColor(std::move(value));
            return *this;
        }

        GridHighlightConfigBuilder<STATE>& setColumnLineColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setColumnLineColor(std::move(value));
            return *this;
        }

        GridHighlightConfigBuilder<STATE>& setGridBorderDash(bool value)
        {
            m_result->setGridBorderDash(value);
            return *this;
        }

        GridHighlightConfigBuilder<STATE>& setCellBorderDash(bool value)
        {
            m_result->setCellBorderDash(value);
            return *this;
        }

        GridHighlightConfigBuilder<STATE>& setRowLineDash(bool value)
        {
            m_result->setRowLineDash(value);
            return *this;
        }

        GridHighlightConfigBuilder<STATE>& setColumnLineDash(bool value)
        {
            m_result->setColumnLineDash(value);
            return *this;
        }

        GridHighlightConfigBuilder<STATE>& setRowGapColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setRowGapColor(std::move(value));
            return *this;
        }

        GridHighlightConfigBuilder<STATE>& setRowHatchColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setRowHatchColor(std::move(value));
            return *this;
        }

        GridHighlightConfigBuilder<STATE>& setColumnGapColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setColumnGapColor(std::move(value));
            return *this;
        }

        GridHighlightConfigBuilder<STATE>& setColumnHatchColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setColumnHatchColor(std::move(value));
            return *this;
        }

        GridHighlightConfigBuilder<STATE>& setAreaBorderColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setAreaBorderColor(std::move(value));
            return *this;
        }

        GridHighlightConfigBuilder<STATE>& setGridBackgroundColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setGridBackgroundColor(std::move(value));
            return *this;
        }

        std::unique_ptr<GridHighlightConfig> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class GridHighlightConfig;
        GridHighlightConfigBuilder()
            : m_result(new GridHighlightConfig())
        {
        }

        template <int STEP> GridHighlightConfigBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<GridHighlightConfigBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Overlay::GridHighlightConfig> m_result;
    };

    static GridHighlightConfigBuilder<0> create()
    {
        return GridHighlightConfigBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    GridHighlightConfig()
    {
    }

    Maybe<bool> m_showGridExtensionLines;
    Maybe<bool> m_showPositiveLineNumbers;
    Maybe<bool> m_showNegativeLineNumbers;
    Maybe<bool> m_showAreaNames;
    Maybe<bool> m_showLineNames;
    Maybe<bool> m_showTrackSizes;
    Maybe<protocol::DOM::RGBA> m_gridBorderColor;
    Maybe<protocol::DOM::RGBA> m_cellBorderColor;
    Maybe<protocol::DOM::RGBA> m_rowLineColor;
    Maybe<protocol::DOM::RGBA> m_columnLineColor;
    Maybe<bool> m_gridBorderDash;
    Maybe<bool> m_cellBorderDash;
    Maybe<bool> m_rowLineDash;
    Maybe<bool> m_columnLineDash;
    Maybe<protocol::DOM::RGBA> m_rowGapColor;
    Maybe<protocol::DOM::RGBA> m_rowHatchColor;
    Maybe<protocol::DOM::RGBA> m_columnGapColor;
    Maybe<protocol::DOM::RGBA> m_columnHatchColor;
    Maybe<protocol::DOM::RGBA> m_areaBorderColor;
    Maybe<protocol::DOM::RGBA> m_gridBackgroundColor;
};

class CORE_EXPORT FlexContainerHighlightConfig : public ::crdtp::ProtocolObject<FlexContainerHighlightConfig> {
public:
    ~FlexContainerHighlightConfig() override
    {
    }

    bool hasContainerBorder()
    {
        return m_containerBorder.has_value();
    }
    protocol::Overlay::LineStyle* getContainerBorder(protocol::Overlay::LineStyle* defaultValue)
    {
        return m_containerBorder.has_value() ? &m_containerBorder.value() : defaultValue;
    }
    void setContainerBorder(std::unique_ptr<protocol::Overlay::LineStyle> value)
    {
        m_containerBorder = std::move(value);
    }

    bool hasLineSeparator()
    {
        return m_lineSeparator.has_value();
    }
    protocol::Overlay::LineStyle* getLineSeparator(protocol::Overlay::LineStyle* defaultValue)
    {
        return m_lineSeparator.has_value() ? &m_lineSeparator.value() : defaultValue;
    }
    void setLineSeparator(std::unique_ptr<protocol::Overlay::LineStyle> value)
    {
        m_lineSeparator = std::move(value);
    }

    bool hasItemSeparator()
    {
        return m_itemSeparator.has_value();
    }
    protocol::Overlay::LineStyle* getItemSeparator(protocol::Overlay::LineStyle* defaultValue)
    {
        return m_itemSeparator.has_value() ? &m_itemSeparator.value() : defaultValue;
    }
    void setItemSeparator(std::unique_ptr<protocol::Overlay::LineStyle> value)
    {
        m_itemSeparator = std::move(value);
    }

    bool hasMainDistributedSpace()
    {
        return m_mainDistributedSpace.has_value();
    }
    protocol::Overlay::BoxStyle* getMainDistributedSpace(protocol::Overlay::BoxStyle* defaultValue)
    {
        return m_mainDistributedSpace.has_value() ? &m_mainDistributedSpace.value() : defaultValue;
    }
    void setMainDistributedSpace(std::unique_ptr<protocol::Overlay::BoxStyle> value)
    {
        m_mainDistributedSpace = std::move(value);
    }

    bool hasCrossDistributedSpace()
    {
        return m_crossDistributedSpace.has_value();
    }
    protocol::Overlay::BoxStyle* getCrossDistributedSpace(protocol::Overlay::BoxStyle* defaultValue)
    {
        return m_crossDistributedSpace.has_value() ? &m_crossDistributedSpace.value() : defaultValue;
    }
    void setCrossDistributedSpace(std::unique_ptr<protocol::Overlay::BoxStyle> value)
    {
        m_crossDistributedSpace = std::move(value);
    }

    bool hasRowGapSpace()
    {
        return m_rowGapSpace.has_value();
    }
    protocol::Overlay::BoxStyle* getRowGapSpace(protocol::Overlay::BoxStyle* defaultValue)
    {
        return m_rowGapSpace.has_value() ? &m_rowGapSpace.value() : defaultValue;
    }
    void setRowGapSpace(std::unique_ptr<protocol::Overlay::BoxStyle> value)
    {
        m_rowGapSpace = std::move(value);
    }

    bool hasColumnGapSpace()
    {
        return m_columnGapSpace.has_value();
    }
    protocol::Overlay::BoxStyle* getColumnGapSpace(protocol::Overlay::BoxStyle* defaultValue)
    {
        return m_columnGapSpace.has_value() ? &m_columnGapSpace.value() : defaultValue;
    }
    void setColumnGapSpace(std::unique_ptr<protocol::Overlay::BoxStyle> value)
    {
        m_columnGapSpace = std::move(value);
    }

    bool hasCrossAlignment()
    {
        return m_crossAlignment.has_value();
    }
    protocol::Overlay::LineStyle* getCrossAlignment(protocol::Overlay::LineStyle* defaultValue)
    {
        return m_crossAlignment.has_value() ? &m_crossAlignment.value() : defaultValue;
    }
    void setCrossAlignment(std::unique_ptr<protocol::Overlay::LineStyle> value)
    {
        m_crossAlignment = std::move(value);
    }

    template <int STATE> class FlexContainerHighlightConfigBuilder {
    public:
        enum { NoFieldsSet = 0, AllFieldsSet = (0) };

        FlexContainerHighlightConfigBuilder<STATE>& setContainerBorder(std::unique_ptr<protocol::Overlay::LineStyle> value)
        {
            m_result->setContainerBorder(std::move(value));
            return *this;
        }

        FlexContainerHighlightConfigBuilder<STATE>& setLineSeparator(std::unique_ptr<protocol::Overlay::LineStyle> value)
        {
            m_result->setLineSeparator(std::move(value));
            return *this;
        }

        FlexContainerHighlightConfigBuilder<STATE>& setItemSeparator(std::unique_ptr<protocol::Overlay::LineStyle> value)
        {
            m_result->setItemSeparator(std::move(value));
            return *this;
        }

        FlexContainerHighlightConfigBuilder<STATE>& setMainDistributedSpace(std::unique_ptr<protocol::Overlay::BoxStyle> value)
        {
            m_result->setMainDistributedSpace(std::move(value));
            return *this;
        }

        FlexContainerHighlightConfigBuilder<STATE>& setCrossDistributedSpace(std::unique_ptr<protocol::Overlay::BoxStyle> value)
        {
            m_result->setCrossDistributedSpace(std::move(value));
            return *this;
        }

        FlexContainerHighlightConfigBuilder<STATE>& setRowGapSpace(std::unique_ptr<protocol::Overlay::BoxStyle> value)
        {
            m_result->setRowGapSpace(std::move(value));
            return *this;
        }

        FlexContainerHighlightConfigBuilder<STATE>& setColumnGapSpace(std::unique_ptr<protocol::Overlay::BoxStyle> value)
        {
            m_result->setColumnGapSpace(std::move(value));
            return *this;
        }

        FlexContainerHighlightConfigBuilder<STATE>& setCrossAlignment(std::unique_ptr<protocol::Overlay::LineStyle> value)
        {
            m_result->setCrossAlignment(std::move(value));
            return *this;
        }

        std::unique_ptr<FlexContainerHighlightConfig> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class FlexContainerHighlightConfig;
        FlexContainerHighlightConfigBuilder()
            : m_result(new FlexContainerHighlightConfig())
        {
        }

        template <int STEP> FlexContainerHighlightConfigBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<FlexContainerHighlightConfigBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Overlay::FlexContainerHighlightConfig> m_result;
    };

    static FlexContainerHighlightConfigBuilder<0> create()
    {
        return FlexContainerHighlightConfigBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    FlexContainerHighlightConfig()
    {
    }

    Maybe<protocol::Overlay::LineStyle> m_containerBorder;
    Maybe<protocol::Overlay::LineStyle> m_lineSeparator;
    Maybe<protocol::Overlay::LineStyle> m_itemSeparator;
    Maybe<protocol::Overlay::BoxStyle> m_mainDistributedSpace;
    Maybe<protocol::Overlay::BoxStyle> m_crossDistributedSpace;
    Maybe<protocol::Overlay::BoxStyle> m_rowGapSpace;
    Maybe<protocol::Overlay::BoxStyle> m_columnGapSpace;
    Maybe<protocol::Overlay::LineStyle> m_crossAlignment;
};

class CORE_EXPORT FlexItemHighlightConfig : public ::crdtp::ProtocolObject<FlexItemHighlightConfig> {
public:
    ~FlexItemHighlightConfig() override
    {
    }

    bool hasBaseSizeBox()
    {
        return m_baseSizeBox.has_value();
    }
    protocol::Overlay::BoxStyle* getBaseSizeBox(protocol::Overlay::BoxStyle* defaultValue)
    {
        return m_baseSizeBox.has_value() ? &m_baseSizeBox.value() : defaultValue;
    }
    void setBaseSizeBox(std::unique_ptr<protocol::Overlay::BoxStyle> value)
    {
        m_baseSizeBox = std::move(value);
    }

    bool hasBaseSizeBorder()
    {
        return m_baseSizeBorder.has_value();
    }
    protocol::Overlay::LineStyle* getBaseSizeBorder(protocol::Overlay::LineStyle* defaultValue)
    {
        return m_baseSizeBorder.has_value() ? &m_baseSizeBorder.value() : defaultValue;
    }
    void setBaseSizeBorder(std::unique_ptr<protocol::Overlay::LineStyle> value)
    {
        m_baseSizeBorder = std::move(value);
    }

    bool hasFlexibilityArrow()
    {
        return m_flexibilityArrow.has_value();
    }
    protocol::Overlay::LineStyle* getFlexibilityArrow(protocol::Overlay::LineStyle* defaultValue)
    {
        return m_flexibilityArrow.has_value() ? &m_flexibilityArrow.value() : defaultValue;
    }
    void setFlexibilityArrow(std::unique_ptr<protocol::Overlay::LineStyle> value)
    {
        m_flexibilityArrow = std::move(value);
    }

    template <int STATE> class FlexItemHighlightConfigBuilder {
    public:
        enum { NoFieldsSet = 0, AllFieldsSet = (0) };

        FlexItemHighlightConfigBuilder<STATE>& setBaseSizeBox(std::unique_ptr<protocol::Overlay::BoxStyle> value)
        {
            m_result->setBaseSizeBox(std::move(value));
            return *this;
        }

        FlexItemHighlightConfigBuilder<STATE>& setBaseSizeBorder(std::unique_ptr<protocol::Overlay::LineStyle> value)
        {
            m_result->setBaseSizeBorder(std::move(value));
            return *this;
        }

        FlexItemHighlightConfigBuilder<STATE>& setFlexibilityArrow(std::unique_ptr<protocol::Overlay::LineStyle> value)
        {
            m_result->setFlexibilityArrow(std::move(value));
            return *this;
        }

        std::unique_ptr<FlexItemHighlightConfig> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class FlexItemHighlightConfig;
        FlexItemHighlightConfigBuilder()
            : m_result(new FlexItemHighlightConfig())
        {
        }

        template <int STEP> FlexItemHighlightConfigBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<FlexItemHighlightConfigBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Overlay::FlexItemHighlightConfig> m_result;
    };

    static FlexItemHighlightConfigBuilder<0> create()
    {
        return FlexItemHighlightConfigBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    FlexItemHighlightConfig()
    {
    }

    Maybe<protocol::Overlay::BoxStyle> m_baseSizeBox;
    Maybe<protocol::Overlay::LineStyle> m_baseSizeBorder;
    Maybe<protocol::Overlay::LineStyle> m_flexibilityArrow;
};

class CORE_EXPORT LineStyle : public ::crdtp::ProtocolObject<LineStyle> {
public:
    ~LineStyle() override
    {
    }

    bool hasColor()
    {
        return m_color.has_value();
    }
    protocol::DOM::RGBA* getColor(protocol::DOM::RGBA* defaultValue)
    {
        return m_color.has_value() ? &m_color.value() : defaultValue;
    }
    void setColor(std::unique_ptr<protocol::DOM::RGBA> value)
    {
        m_color = std::move(value);
    }

    struct CORE_EXPORT PatternEnum {
        static const char* Dashed;
        static const char* Dotted;
    }; // PatternEnum

    bool hasPattern()
    {
        return m_pattern.has_value();
    }
    String getPattern(const String& defaultValue) const
    {
        return m_pattern.value_or(defaultValue);
    }
    void setPattern(const String& value)
    {
        m_pattern = value;
    }

    template <int STATE> class LineStyleBuilder {
    public:
        enum { NoFieldsSet = 0, AllFieldsSet = (0) };

        LineStyleBuilder<STATE>& setColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setColor(std::move(value));
            return *this;
        }

        LineStyleBuilder<STATE>& setPattern(const String& value)
        {
            m_result->setPattern(value);
            return *this;
        }

        std::unique_ptr<LineStyle> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class LineStyle;
        LineStyleBuilder()
            : m_result(new LineStyle())
        {
        }

        template <int STEP> LineStyleBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<LineStyleBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Overlay::LineStyle> m_result;
    };

    static LineStyleBuilder<0> create()
    {
        return LineStyleBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    LineStyle()
    {
    }

    Maybe<protocol::DOM::RGBA> m_color;
    Maybe<String> m_pattern;
};

class CORE_EXPORT BoxStyle : public ::crdtp::ProtocolObject<BoxStyle> {
public:
    ~BoxStyle() override
    {
    }

    bool hasFillColor()
    {
        return m_fillColor.has_value();
    }
    protocol::DOM::RGBA* getFillColor(protocol::DOM::RGBA* defaultValue)
    {
        return m_fillColor.has_value() ? &m_fillColor.value() : defaultValue;
    }
    void setFillColor(std::unique_ptr<protocol::DOM::RGBA> value)
    {
        m_fillColor = std::move(value);
    }

    bool hasHatchColor()
    {
        return m_hatchColor.has_value();
    }
    protocol::DOM::RGBA* getHatchColor(protocol::DOM::RGBA* defaultValue)
    {
        return m_hatchColor.has_value() ? &m_hatchColor.value() : defaultValue;
    }
    void setHatchColor(std::unique_ptr<protocol::DOM::RGBA> value)
    {
        m_hatchColor = std::move(value);
    }

    template <int STATE> class BoxStyleBuilder {
    public:
        enum { NoFieldsSet = 0, AllFieldsSet = (0) };

        BoxStyleBuilder<STATE>& setFillColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setFillColor(std::move(value));
            return *this;
        }

        BoxStyleBuilder<STATE>& setHatchColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setHatchColor(std::move(value));
            return *this;
        }

        std::unique_ptr<BoxStyle> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class BoxStyle;
        BoxStyleBuilder()
            : m_result(new BoxStyle())
        {
        }

        template <int STEP> BoxStyleBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<BoxStyleBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Overlay::BoxStyle> m_result;
    };

    static BoxStyleBuilder<0> create()
    {
        return BoxStyleBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    BoxStyle()
    {
    }

    Maybe<protocol::DOM::RGBA> m_fillColor;
    Maybe<protocol::DOM::RGBA> m_hatchColor;
};

class CORE_EXPORT HighlightConfig : public ::crdtp::ProtocolObject<HighlightConfig> {
public:
    ~HighlightConfig() override
    {
    }

    bool hasShowInfo()
    {
        return m_showInfo.has_value();
    }
    bool getShowInfo(bool defaultValue) const
    {
        return m_showInfo.value_or(defaultValue);
    }
    void setShowInfo(bool value)
    {
        m_showInfo = value;
    }

    bool hasShowStyles()
    {
        return m_showStyles.has_value();
    }
    bool getShowStyles(bool defaultValue) const
    {
        return m_showStyles.value_or(defaultValue);
    }
    void setShowStyles(bool value)
    {
        m_showStyles = value;
    }

    bool hasShowRulers()
    {
        return m_showRulers.has_value();
    }
    bool getShowRulers(bool defaultValue) const
    {
        return m_showRulers.value_or(defaultValue);
    }
    void setShowRulers(bool value)
    {
        m_showRulers = value;
    }

    bool hasShowAccessibilityInfo()
    {
        return m_showAccessibilityInfo.has_value();
    }
    bool getShowAccessibilityInfo(bool defaultValue) const
    {
        return m_showAccessibilityInfo.value_or(defaultValue);
    }
    void setShowAccessibilityInfo(bool value)
    {
        m_showAccessibilityInfo = value;
    }

    bool hasShowExtensionLines()
    {
        return m_showExtensionLines.has_value();
    }
    bool getShowExtensionLines(bool defaultValue) const
    {
        return m_showExtensionLines.value_or(defaultValue);
    }
    void setShowExtensionLines(bool value)
    {
        m_showExtensionLines = value;
    }

    bool hasContentColor()
    {
        return m_contentColor.has_value();
    }
    protocol::DOM::RGBA* getContentColor(protocol::DOM::RGBA* defaultValue)
    {
        return m_contentColor.has_value() ? &m_contentColor.value() : defaultValue;
    }
    void setContentColor(std::unique_ptr<protocol::DOM::RGBA> value)
    {
        m_contentColor = std::move(value);
    }

    bool hasPaddingColor()
    {
        return m_paddingColor.has_value();
    }
    protocol::DOM::RGBA* getPaddingColor(protocol::DOM::RGBA* defaultValue)
    {
        return m_paddingColor.has_value() ? &m_paddingColor.value() : defaultValue;
    }
    void setPaddingColor(std::unique_ptr<protocol::DOM::RGBA> value)
    {
        m_paddingColor = std::move(value);
    }

    bool hasBorderColor()
    {
        return m_borderColor.has_value();
    }
    protocol::DOM::RGBA* getBorderColor(protocol::DOM::RGBA* defaultValue)
    {
        return m_borderColor.has_value() ? &m_borderColor.value() : defaultValue;
    }
    void setBorderColor(std::unique_ptr<protocol::DOM::RGBA> value)
    {
        m_borderColor = std::move(value);
    }

    bool hasMarginColor()
    {
        return m_marginColor.has_value();
    }
    protocol::DOM::RGBA* getMarginColor(protocol::DOM::RGBA* defaultValue)
    {
        return m_marginColor.has_value() ? &m_marginColor.value() : defaultValue;
    }
    void setMarginColor(std::unique_ptr<protocol::DOM::RGBA> value)
    {
        m_marginColor = std::move(value);
    }

    bool hasEventTargetColor()
    {
        return m_eventTargetColor.has_value();
    }
    protocol::DOM::RGBA* getEventTargetColor(protocol::DOM::RGBA* defaultValue)
    {
        return m_eventTargetColor.has_value() ? &m_eventTargetColor.value() : defaultValue;
    }
    void setEventTargetColor(std::unique_ptr<protocol::DOM::RGBA> value)
    {
        m_eventTargetColor = std::move(value);
    }

    bool hasShapeColor()
    {
        return m_shapeColor.has_value();
    }
    protocol::DOM::RGBA* getShapeColor(protocol::DOM::RGBA* defaultValue)
    {
        return m_shapeColor.has_value() ? &m_shapeColor.value() : defaultValue;
    }
    void setShapeColor(std::unique_ptr<protocol::DOM::RGBA> value)
    {
        m_shapeColor = std::move(value);
    }

    bool hasShapeMarginColor()
    {
        return m_shapeMarginColor.has_value();
    }
    protocol::DOM::RGBA* getShapeMarginColor(protocol::DOM::RGBA* defaultValue)
    {
        return m_shapeMarginColor.has_value() ? &m_shapeMarginColor.value() : defaultValue;
    }
    void setShapeMarginColor(std::unique_ptr<protocol::DOM::RGBA> value)
    {
        m_shapeMarginColor = std::move(value);
    }

    bool hasCssGridColor()
    {
        return m_cssGridColor.has_value();
    }
    protocol::DOM::RGBA* getCssGridColor(protocol::DOM::RGBA* defaultValue)
    {
        return m_cssGridColor.has_value() ? &m_cssGridColor.value() : defaultValue;
    }
    void setCssGridColor(std::unique_ptr<protocol::DOM::RGBA> value)
    {
        m_cssGridColor = std::move(value);
    }

    bool hasColorFormat()
    {
        return m_colorFormat.has_value();
    }
    String getColorFormat(const String& defaultValue) const
    {
        return m_colorFormat.value_or(defaultValue);
    }
    void setColorFormat(const String& value)
    {
        m_colorFormat = value;
    }

    bool hasGridHighlightConfig()
    {
        return m_gridHighlightConfig.has_value();
    }
    protocol::Overlay::GridHighlightConfig* getGridHighlightConfig(protocol::Overlay::GridHighlightConfig* defaultValue)
    {
        return m_gridHighlightConfig.has_value() ? &m_gridHighlightConfig.value() : defaultValue;
    }
    void setGridHighlightConfig(std::unique_ptr<protocol::Overlay::GridHighlightConfig> value)
    {
        m_gridHighlightConfig = std::move(value);
    }

    bool hasFlexContainerHighlightConfig()
    {
        return m_flexContainerHighlightConfig.has_value();
    }
    protocol::Overlay::FlexContainerHighlightConfig* getFlexContainerHighlightConfig(protocol::Overlay::FlexContainerHighlightConfig* defaultValue)
    {
        return m_flexContainerHighlightConfig.has_value() ? &m_flexContainerHighlightConfig.value() : defaultValue;
    }
    void setFlexContainerHighlightConfig(std::unique_ptr<protocol::Overlay::FlexContainerHighlightConfig> value)
    {
        m_flexContainerHighlightConfig = std::move(value);
    }

    bool hasFlexItemHighlightConfig()
    {
        return m_flexItemHighlightConfig.has_value();
    }
    protocol::Overlay::FlexItemHighlightConfig* getFlexItemHighlightConfig(protocol::Overlay::FlexItemHighlightConfig* defaultValue)
    {
        return m_flexItemHighlightConfig.has_value() ? &m_flexItemHighlightConfig.value() : defaultValue;
    }
    void setFlexItemHighlightConfig(std::unique_ptr<protocol::Overlay::FlexItemHighlightConfig> value)
    {
        m_flexItemHighlightConfig = std::move(value);
    }

    bool hasContrastAlgorithm()
    {
        return m_contrastAlgorithm.has_value();
    }
    String getContrastAlgorithm(const String& defaultValue) const
    {
        return m_contrastAlgorithm.value_or(defaultValue);
    }
    void setContrastAlgorithm(const String& value)
    {
        m_contrastAlgorithm = value;
    }

    bool hasContainerQueryContainerHighlightConfig()
    {
        return m_containerQueryContainerHighlightConfig.has_value();
    }
    protocol::Overlay::ContainerQueryContainerHighlightConfig* getContainerQueryContainerHighlightConfig(
        protocol::Overlay::ContainerQueryContainerHighlightConfig* defaultValue)
    {
        return m_containerQueryContainerHighlightConfig.has_value() ? &m_containerQueryContainerHighlightConfig.value() : defaultValue;
    }
    void setContainerQueryContainerHighlightConfig(std::unique_ptr<protocol::Overlay::ContainerQueryContainerHighlightConfig> value)
    {
        m_containerQueryContainerHighlightConfig = std::move(value);
    }

    template <int STATE> class HighlightConfigBuilder {
    public:
        enum { NoFieldsSet = 0, AllFieldsSet = (0) };

        HighlightConfigBuilder<STATE>& setShowInfo(bool value)
        {
            m_result->setShowInfo(value);
            return *this;
        }

        HighlightConfigBuilder<STATE>& setShowStyles(bool value)
        {
            m_result->setShowStyles(value);
            return *this;
        }

        HighlightConfigBuilder<STATE>& setShowRulers(bool value)
        {
            m_result->setShowRulers(value);
            return *this;
        }

        HighlightConfigBuilder<STATE>& setShowAccessibilityInfo(bool value)
        {
            m_result->setShowAccessibilityInfo(value);
            return *this;
        }

        HighlightConfigBuilder<STATE>& setShowExtensionLines(bool value)
        {
            m_result->setShowExtensionLines(value);
            return *this;
        }

        HighlightConfigBuilder<STATE>& setContentColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setContentColor(std::move(value));
            return *this;
        }

        HighlightConfigBuilder<STATE>& setPaddingColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setPaddingColor(std::move(value));
            return *this;
        }

        HighlightConfigBuilder<STATE>& setBorderColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setBorderColor(std::move(value));
            return *this;
        }

        HighlightConfigBuilder<STATE>& setMarginColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setMarginColor(std::move(value));
            return *this;
        }

        HighlightConfigBuilder<STATE>& setEventTargetColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setEventTargetColor(std::move(value));
            return *this;
        }

        HighlightConfigBuilder<STATE>& setShapeColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setShapeColor(std::move(value));
            return *this;
        }

        HighlightConfigBuilder<STATE>& setShapeMarginColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setShapeMarginColor(std::move(value));
            return *this;
        }

        HighlightConfigBuilder<STATE>& setCssGridColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setCssGridColor(std::move(value));
            return *this;
        }

        HighlightConfigBuilder<STATE>& setColorFormat(const String& value)
        {
            m_result->setColorFormat(value);
            return *this;
        }

        HighlightConfigBuilder<STATE>& setGridHighlightConfig(std::unique_ptr<protocol::Overlay::GridHighlightConfig> value)
        {
            m_result->setGridHighlightConfig(std::move(value));
            return *this;
        }

        HighlightConfigBuilder<STATE>& setFlexContainerHighlightConfig(std::unique_ptr<protocol::Overlay::FlexContainerHighlightConfig> value)
        {
            m_result->setFlexContainerHighlightConfig(std::move(value));
            return *this;
        }

        HighlightConfigBuilder<STATE>& setFlexItemHighlightConfig(std::unique_ptr<protocol::Overlay::FlexItemHighlightConfig> value)
        {
            m_result->setFlexItemHighlightConfig(std::move(value));
            return *this;
        }

        HighlightConfigBuilder<STATE>& setContrastAlgorithm(const String& value)
        {
            m_result->setContrastAlgorithm(value);
            return *this;
        }

        HighlightConfigBuilder<STATE>& setContainerQueryContainerHighlightConfig(
            std::unique_ptr<protocol::Overlay::ContainerQueryContainerHighlightConfig> value)
        {
            m_result->setContainerQueryContainerHighlightConfig(std::move(value));
            return *this;
        }

        std::unique_ptr<HighlightConfig> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class HighlightConfig;
        HighlightConfigBuilder()
            : m_result(new HighlightConfig())
        {
        }

        template <int STEP> HighlightConfigBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<HighlightConfigBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Overlay::HighlightConfig> m_result;
    };

    static HighlightConfigBuilder<0> create()
    {
        return HighlightConfigBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    HighlightConfig()
    {
    }

    Maybe<bool> m_showInfo;
    Maybe<bool> m_showStyles;
    Maybe<bool> m_showRulers;
    Maybe<bool> m_showAccessibilityInfo;
    Maybe<bool> m_showExtensionLines;
    Maybe<protocol::DOM::RGBA> m_contentColor;
    Maybe<protocol::DOM::RGBA> m_paddingColor;
    Maybe<protocol::DOM::RGBA> m_borderColor;
    Maybe<protocol::DOM::RGBA> m_marginColor;
    Maybe<protocol::DOM::RGBA> m_eventTargetColor;
    Maybe<protocol::DOM::RGBA> m_shapeColor;
    Maybe<protocol::DOM::RGBA> m_shapeMarginColor;
    Maybe<protocol::DOM::RGBA> m_cssGridColor;
    Maybe<String> m_colorFormat;
    Maybe<protocol::Overlay::GridHighlightConfig> m_gridHighlightConfig;
    Maybe<protocol::Overlay::FlexContainerHighlightConfig> m_flexContainerHighlightConfig;
    Maybe<protocol::Overlay::FlexItemHighlightConfig> m_flexItemHighlightConfig;
    Maybe<String> m_contrastAlgorithm;
    Maybe<protocol::Overlay::ContainerQueryContainerHighlightConfig> m_containerQueryContainerHighlightConfig;
};

class CORE_EXPORT GridNodeHighlightConfig : public ::crdtp::ProtocolObject<GridNodeHighlightConfig> {
public:
    ~GridNodeHighlightConfig() override
    {
    }

    protocol::Overlay::GridHighlightConfig* getGridHighlightConfig()
    {
        return m_gridHighlightConfig.get();
    }
    void setGridHighlightConfig(std::unique_ptr<protocol::Overlay::GridHighlightConfig> value)
    {
        m_gridHighlightConfig = std::move(value);
    }

    int getNodeId()
    {
        return m_nodeId;
    }
    void setNodeId(int value)
    {
        m_nodeId = value;
    }

    template <int STATE> class GridNodeHighlightConfigBuilder {
    public:
        enum { NoFieldsSet = 0, GridHighlightConfigSet = 1 << 1, NodeIdSet = 1 << 2, AllFieldsSet = (GridHighlightConfigSet | NodeIdSet | 0) };

        GridNodeHighlightConfigBuilder<STATE | GridHighlightConfigSet>& setGridHighlightConfig(std::unique_ptr<protocol::Overlay::GridHighlightConfig> value)
        {
            static_assert(!(STATE & GridHighlightConfigSet), "property gridHighlightConfig should not be set yet");
            m_result->setGridHighlightConfig(std::move(value));
            return castState<GridHighlightConfigSet>();
        }

        GridNodeHighlightConfigBuilder<STATE | NodeIdSet>& setNodeId(int value)
        {
            static_assert(!(STATE & NodeIdSet), "property nodeId should not be set yet");
            m_result->setNodeId(value);
            return castState<NodeIdSet>();
        }

        std::unique_ptr<GridNodeHighlightConfig> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class GridNodeHighlightConfig;
        GridNodeHighlightConfigBuilder()
            : m_result(new GridNodeHighlightConfig())
        {
        }

        template <int STEP> GridNodeHighlightConfigBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<GridNodeHighlightConfigBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Overlay::GridNodeHighlightConfig> m_result;
    };

    static GridNodeHighlightConfigBuilder<0> create()
    {
        return GridNodeHighlightConfigBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    GridNodeHighlightConfig()
    {
        m_nodeId = 0;
    }

    std::unique_ptr<protocol::Overlay::GridHighlightConfig> m_gridHighlightConfig;
    int m_nodeId;
};

class CORE_EXPORT FlexNodeHighlightConfig : public ::crdtp::ProtocolObject<FlexNodeHighlightConfig> {
public:
    ~FlexNodeHighlightConfig() override
    {
    }

    protocol::Overlay::FlexContainerHighlightConfig* getFlexContainerHighlightConfig()
    {
        return m_flexContainerHighlightConfig.get();
    }
    void setFlexContainerHighlightConfig(std::unique_ptr<protocol::Overlay::FlexContainerHighlightConfig> value)
    {
        m_flexContainerHighlightConfig = std::move(value);
    }

    int getNodeId()
    {
        return m_nodeId;
    }
    void setNodeId(int value)
    {
        m_nodeId = value;
    }

    template <int STATE> class FlexNodeHighlightConfigBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            FlexContainerHighlightConfigSet = 1 << 1,
            NodeIdSet = 1 << 2,
            AllFieldsSet = (FlexContainerHighlightConfigSet | NodeIdSet | 0)
        };

        FlexNodeHighlightConfigBuilder<STATE | FlexContainerHighlightConfigSet>& setFlexContainerHighlightConfig(
            std::unique_ptr<protocol::Overlay::FlexContainerHighlightConfig> value)
        {
            static_assert(!(STATE & FlexContainerHighlightConfigSet), "property flexContainerHighlightConfig should not be set yet");
            m_result->setFlexContainerHighlightConfig(std::move(value));
            return castState<FlexContainerHighlightConfigSet>();
        }

        FlexNodeHighlightConfigBuilder<STATE | NodeIdSet>& setNodeId(int value)
        {
            static_assert(!(STATE & NodeIdSet), "property nodeId should not be set yet");
            m_result->setNodeId(value);
            return castState<NodeIdSet>();
        }

        std::unique_ptr<FlexNodeHighlightConfig> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class FlexNodeHighlightConfig;
        FlexNodeHighlightConfigBuilder()
            : m_result(new FlexNodeHighlightConfig())
        {
        }

        template <int STEP> FlexNodeHighlightConfigBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<FlexNodeHighlightConfigBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Overlay::FlexNodeHighlightConfig> m_result;
    };

    static FlexNodeHighlightConfigBuilder<0> create()
    {
        return FlexNodeHighlightConfigBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    FlexNodeHighlightConfig()
    {
        m_nodeId = 0;
    }

    std::unique_ptr<protocol::Overlay::FlexContainerHighlightConfig> m_flexContainerHighlightConfig;
    int m_nodeId;
};

class CORE_EXPORT ScrollSnapContainerHighlightConfig : public ::crdtp::ProtocolObject<ScrollSnapContainerHighlightConfig> {
public:
    ~ScrollSnapContainerHighlightConfig() override
    {
    }

    bool hasSnapportBorder()
    {
        return m_snapportBorder.has_value();
    }
    protocol::Overlay::LineStyle* getSnapportBorder(protocol::Overlay::LineStyle* defaultValue)
    {
        return m_snapportBorder.has_value() ? &m_snapportBorder.value() : defaultValue;
    }
    void setSnapportBorder(std::unique_ptr<protocol::Overlay::LineStyle> value)
    {
        m_snapportBorder = std::move(value);
    }

    bool hasSnapAreaBorder()
    {
        return m_snapAreaBorder.has_value();
    }
    protocol::Overlay::LineStyle* getSnapAreaBorder(protocol::Overlay::LineStyle* defaultValue)
    {
        return m_snapAreaBorder.has_value() ? &m_snapAreaBorder.value() : defaultValue;
    }
    void setSnapAreaBorder(std::unique_ptr<protocol::Overlay::LineStyle> value)
    {
        m_snapAreaBorder = std::move(value);
    }

    bool hasScrollMarginColor()
    {
        return m_scrollMarginColor.has_value();
    }
    protocol::DOM::RGBA* getScrollMarginColor(protocol::DOM::RGBA* defaultValue)
    {
        return m_scrollMarginColor.has_value() ? &m_scrollMarginColor.value() : defaultValue;
    }
    void setScrollMarginColor(std::unique_ptr<protocol::DOM::RGBA> value)
    {
        m_scrollMarginColor = std::move(value);
    }

    bool hasScrollPaddingColor()
    {
        return m_scrollPaddingColor.has_value();
    }
    protocol::DOM::RGBA* getScrollPaddingColor(protocol::DOM::RGBA* defaultValue)
    {
        return m_scrollPaddingColor.has_value() ? &m_scrollPaddingColor.value() : defaultValue;
    }
    void setScrollPaddingColor(std::unique_ptr<protocol::DOM::RGBA> value)
    {
        m_scrollPaddingColor = std::move(value);
    }

    template <int STATE> class ScrollSnapContainerHighlightConfigBuilder {
    public:
        enum { NoFieldsSet = 0, AllFieldsSet = (0) };

        ScrollSnapContainerHighlightConfigBuilder<STATE>& setSnapportBorder(std::unique_ptr<protocol::Overlay::LineStyle> value)
        {
            m_result->setSnapportBorder(std::move(value));
            return *this;
        }

        ScrollSnapContainerHighlightConfigBuilder<STATE>& setSnapAreaBorder(std::unique_ptr<protocol::Overlay::LineStyle> value)
        {
            m_result->setSnapAreaBorder(std::move(value));
            return *this;
        }

        ScrollSnapContainerHighlightConfigBuilder<STATE>& setScrollMarginColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setScrollMarginColor(std::move(value));
            return *this;
        }

        ScrollSnapContainerHighlightConfigBuilder<STATE>& setScrollPaddingColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setScrollPaddingColor(std::move(value));
            return *this;
        }

        std::unique_ptr<ScrollSnapContainerHighlightConfig> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class ScrollSnapContainerHighlightConfig;
        ScrollSnapContainerHighlightConfigBuilder()
            : m_result(new ScrollSnapContainerHighlightConfig())
        {
        }

        template <int STEP> ScrollSnapContainerHighlightConfigBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<ScrollSnapContainerHighlightConfigBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Overlay::ScrollSnapContainerHighlightConfig> m_result;
    };

    static ScrollSnapContainerHighlightConfigBuilder<0> create()
    {
        return ScrollSnapContainerHighlightConfigBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    ScrollSnapContainerHighlightConfig()
    {
    }

    Maybe<protocol::Overlay::LineStyle> m_snapportBorder;
    Maybe<protocol::Overlay::LineStyle> m_snapAreaBorder;
    Maybe<protocol::DOM::RGBA> m_scrollMarginColor;
    Maybe<protocol::DOM::RGBA> m_scrollPaddingColor;
};

class CORE_EXPORT ScrollSnapHighlightConfig : public ::crdtp::ProtocolObject<ScrollSnapHighlightConfig> {
public:
    ~ScrollSnapHighlightConfig() override
    {
    }

    protocol::Overlay::ScrollSnapContainerHighlightConfig* getScrollSnapContainerHighlightConfig()
    {
        return m_scrollSnapContainerHighlightConfig.get();
    }
    void setScrollSnapContainerHighlightConfig(std::unique_ptr<protocol::Overlay::ScrollSnapContainerHighlightConfig> value)
    {
        m_scrollSnapContainerHighlightConfig = std::move(value);
    }

    int getNodeId()
    {
        return m_nodeId;
    }
    void setNodeId(int value)
    {
        m_nodeId = value;
    }

    template <int STATE> class ScrollSnapHighlightConfigBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            ScrollSnapContainerHighlightConfigSet = 1 << 1,
            NodeIdSet = 1 << 2,
            AllFieldsSet = (ScrollSnapContainerHighlightConfigSet | NodeIdSet | 0)
        };

        ScrollSnapHighlightConfigBuilder<STATE | ScrollSnapContainerHighlightConfigSet>& setScrollSnapContainerHighlightConfig(
            std::unique_ptr<protocol::Overlay::ScrollSnapContainerHighlightConfig> value)
        {
            static_assert(!(STATE & ScrollSnapContainerHighlightConfigSet), "property scrollSnapContainerHighlightConfig should not be set yet");
            m_result->setScrollSnapContainerHighlightConfig(std::move(value));
            return castState<ScrollSnapContainerHighlightConfigSet>();
        }

        ScrollSnapHighlightConfigBuilder<STATE | NodeIdSet>& setNodeId(int value)
        {
            static_assert(!(STATE & NodeIdSet), "property nodeId should not be set yet");
            m_result->setNodeId(value);
            return castState<NodeIdSet>();
        }

        std::unique_ptr<ScrollSnapHighlightConfig> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class ScrollSnapHighlightConfig;
        ScrollSnapHighlightConfigBuilder()
            : m_result(new ScrollSnapHighlightConfig())
        {
        }

        template <int STEP> ScrollSnapHighlightConfigBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<ScrollSnapHighlightConfigBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Overlay::ScrollSnapHighlightConfig> m_result;
    };

    static ScrollSnapHighlightConfigBuilder<0> create()
    {
        return ScrollSnapHighlightConfigBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    ScrollSnapHighlightConfig()
    {
        m_nodeId = 0;
    }

    std::unique_ptr<protocol::Overlay::ScrollSnapContainerHighlightConfig> m_scrollSnapContainerHighlightConfig;
    int m_nodeId;
};

class CORE_EXPORT HingeConfig : public ::crdtp::ProtocolObject<HingeConfig> {
public:
    ~HingeConfig() override
    {
    }

    protocol::DOM::Rect* getRect()
    {
        return m_rect.get();
    }
    void setRect(std::unique_ptr<protocol::DOM::Rect> value)
    {
        m_rect = std::move(value);
    }

    bool hasContentColor()
    {
        return m_contentColor.has_value();
    }
    protocol::DOM::RGBA* getContentColor(protocol::DOM::RGBA* defaultValue)
    {
        return m_contentColor.has_value() ? &m_contentColor.value() : defaultValue;
    }
    void setContentColor(std::unique_ptr<protocol::DOM::RGBA> value)
    {
        m_contentColor = std::move(value);
    }

    bool hasOutlineColor()
    {
        return m_outlineColor.has_value();
    }
    protocol::DOM::RGBA* getOutlineColor(protocol::DOM::RGBA* defaultValue)
    {
        return m_outlineColor.has_value() ? &m_outlineColor.value() : defaultValue;
    }
    void setOutlineColor(std::unique_ptr<protocol::DOM::RGBA> value)
    {
        m_outlineColor = std::move(value);
    }

    template <int STATE> class HingeConfigBuilder {
    public:
        enum { NoFieldsSet = 0, RectSet = 1 << 1, AllFieldsSet = (RectSet | 0) };

        HingeConfigBuilder<STATE | RectSet>& setRect(std::unique_ptr<protocol::DOM::Rect> value)
        {
            static_assert(!(STATE & RectSet), "property rect should not be set yet");
            m_result->setRect(std::move(value));
            return castState<RectSet>();
        }

        HingeConfigBuilder<STATE>& setContentColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setContentColor(std::move(value));
            return *this;
        }

        HingeConfigBuilder<STATE>& setOutlineColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setOutlineColor(std::move(value));
            return *this;
        }

        std::unique_ptr<HingeConfig> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class HingeConfig;
        HingeConfigBuilder()
            : m_result(new HingeConfig())
        {
        }

        template <int STEP> HingeConfigBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<HingeConfigBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Overlay::HingeConfig> m_result;
    };

    static HingeConfigBuilder<0> create()
    {
        return HingeConfigBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    HingeConfig()
    {
    }

    std::unique_ptr<protocol::DOM::Rect> m_rect;
    Maybe<protocol::DOM::RGBA> m_contentColor;
    Maybe<protocol::DOM::RGBA> m_outlineColor;
};

class CORE_EXPORT WindowControlsOverlayConfig : public ::crdtp::ProtocolObject<WindowControlsOverlayConfig> {
public:
    ~WindowControlsOverlayConfig() override
    {
    }

    bool getShowCSS()
    {
        return m_showCSS;
    }
    void setShowCSS(bool value)
    {
        m_showCSS = value;
    }

    String getSelectedPlatform()
    {
        return m_selectedPlatform;
    }
    void setSelectedPlatform(const String& value)
    {
        m_selectedPlatform = value;
    }

    String getThemeColor()
    {
        return m_themeColor;
    }
    void setThemeColor(const String& value)
    {
        m_themeColor = value;
    }

    template <int STATE> class WindowControlsOverlayConfigBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            ShowCSSSet = 1 << 1,
            SelectedPlatformSet = 1 << 2,
            ThemeColorSet = 1 << 3,
            AllFieldsSet = (ShowCSSSet | SelectedPlatformSet | ThemeColorSet | 0)
        };

        WindowControlsOverlayConfigBuilder<STATE | ShowCSSSet>& setShowCSS(bool value)
        {
            static_assert(!(STATE & ShowCSSSet), "property showCSS should not be set yet");
            m_result->setShowCSS(value);
            return castState<ShowCSSSet>();
        }

        WindowControlsOverlayConfigBuilder<STATE | SelectedPlatformSet>& setSelectedPlatform(const String& value)
        {
            static_assert(!(STATE & SelectedPlatformSet), "property selectedPlatform should not be set yet");
            m_result->setSelectedPlatform(value);
            return castState<SelectedPlatformSet>();
        }

        WindowControlsOverlayConfigBuilder<STATE | ThemeColorSet>& setThemeColor(const String& value)
        {
            static_assert(!(STATE & ThemeColorSet), "property themeColor should not be set yet");
            m_result->setThemeColor(value);
            return castState<ThemeColorSet>();
        }

        std::unique_ptr<WindowControlsOverlayConfig> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class WindowControlsOverlayConfig;
        WindowControlsOverlayConfigBuilder()
            : m_result(new WindowControlsOverlayConfig())
        {
        }

        template <int STEP> WindowControlsOverlayConfigBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<WindowControlsOverlayConfigBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Overlay::WindowControlsOverlayConfig> m_result;
    };

    static WindowControlsOverlayConfigBuilder<0> create()
    {
        return WindowControlsOverlayConfigBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    WindowControlsOverlayConfig()
    {
        m_showCSS = false;
    }

    bool m_showCSS;
    String m_selectedPlatform;
    String m_themeColor;
};

class CORE_EXPORT ContainerQueryHighlightConfig : public ::crdtp::ProtocolObject<ContainerQueryHighlightConfig> {
public:
    ~ContainerQueryHighlightConfig() override
    {
    }

    protocol::Overlay::ContainerQueryContainerHighlightConfig* getContainerQueryContainerHighlightConfig()
    {
        return m_containerQueryContainerHighlightConfig.get();
    }
    void setContainerQueryContainerHighlightConfig(std::unique_ptr<protocol::Overlay::ContainerQueryContainerHighlightConfig> value)
    {
        m_containerQueryContainerHighlightConfig = std::move(value);
    }

    int getNodeId()
    {
        return m_nodeId;
    }
    void setNodeId(int value)
    {
        m_nodeId = value;
    }

    template <int STATE> class ContainerQueryHighlightConfigBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            ContainerQueryContainerHighlightConfigSet = 1 << 1,
            NodeIdSet = 1 << 2,
            AllFieldsSet = (ContainerQueryContainerHighlightConfigSet | NodeIdSet | 0)
        };

        ContainerQueryHighlightConfigBuilder<STATE | ContainerQueryContainerHighlightConfigSet>& setContainerQueryContainerHighlightConfig(
            std::unique_ptr<protocol::Overlay::ContainerQueryContainerHighlightConfig> value)
        {
            static_assert(!(STATE & ContainerQueryContainerHighlightConfigSet), "property containerQueryContainerHighlightConfig should not be set yet");
            m_result->setContainerQueryContainerHighlightConfig(std::move(value));
            return castState<ContainerQueryContainerHighlightConfigSet>();
        }

        ContainerQueryHighlightConfigBuilder<STATE | NodeIdSet>& setNodeId(int value)
        {
            static_assert(!(STATE & NodeIdSet), "property nodeId should not be set yet");
            m_result->setNodeId(value);
            return castState<NodeIdSet>();
        }

        std::unique_ptr<ContainerQueryHighlightConfig> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class ContainerQueryHighlightConfig;
        ContainerQueryHighlightConfigBuilder()
            : m_result(new ContainerQueryHighlightConfig())
        {
        }

        template <int STEP> ContainerQueryHighlightConfigBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<ContainerQueryHighlightConfigBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Overlay::ContainerQueryHighlightConfig> m_result;
    };

    static ContainerQueryHighlightConfigBuilder<0> create()
    {
        return ContainerQueryHighlightConfigBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    ContainerQueryHighlightConfig()
    {
        m_nodeId = 0;
    }

    std::unique_ptr<protocol::Overlay::ContainerQueryContainerHighlightConfig> m_containerQueryContainerHighlightConfig;
    int m_nodeId;
};

class CORE_EXPORT ContainerQueryContainerHighlightConfig : public ::crdtp::ProtocolObject<ContainerQueryContainerHighlightConfig> {
public:
    ~ContainerQueryContainerHighlightConfig() override
    {
    }

    bool hasContainerBorder()
    {
        return m_containerBorder.has_value();
    }
    protocol::Overlay::LineStyle* getContainerBorder(protocol::Overlay::LineStyle* defaultValue)
    {
        return m_containerBorder.has_value() ? &m_containerBorder.value() : defaultValue;
    }
    void setContainerBorder(std::unique_ptr<protocol::Overlay::LineStyle> value)
    {
        m_containerBorder = std::move(value);
    }

    bool hasDescendantBorder()
    {
        return m_descendantBorder.has_value();
    }
    protocol::Overlay::LineStyle* getDescendantBorder(protocol::Overlay::LineStyle* defaultValue)
    {
        return m_descendantBorder.has_value() ? &m_descendantBorder.value() : defaultValue;
    }
    void setDescendantBorder(std::unique_ptr<protocol::Overlay::LineStyle> value)
    {
        m_descendantBorder = std::move(value);
    }

    template <int STATE> class ContainerQueryContainerHighlightConfigBuilder {
    public:
        enum { NoFieldsSet = 0, AllFieldsSet = (0) };

        ContainerQueryContainerHighlightConfigBuilder<STATE>& setContainerBorder(std::unique_ptr<protocol::Overlay::LineStyle> value)
        {
            m_result->setContainerBorder(std::move(value));
            return *this;
        }

        ContainerQueryContainerHighlightConfigBuilder<STATE>& setDescendantBorder(std::unique_ptr<protocol::Overlay::LineStyle> value)
        {
            m_result->setDescendantBorder(std::move(value));
            return *this;
        }

        std::unique_ptr<ContainerQueryContainerHighlightConfig> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class ContainerQueryContainerHighlightConfig;
        ContainerQueryContainerHighlightConfigBuilder()
            : m_result(new ContainerQueryContainerHighlightConfig())
        {
        }

        template <int STEP> ContainerQueryContainerHighlightConfigBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<ContainerQueryContainerHighlightConfigBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Overlay::ContainerQueryContainerHighlightConfig> m_result;
    };

    static ContainerQueryContainerHighlightConfigBuilder<0> create()
    {
        return ContainerQueryContainerHighlightConfigBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    ContainerQueryContainerHighlightConfig()
    {
    }

    Maybe<protocol::Overlay::LineStyle> m_containerBorder;
    Maybe<protocol::Overlay::LineStyle> m_descendantBorder;
};

class CORE_EXPORT IsolatedElementHighlightConfig : public ::crdtp::ProtocolObject<IsolatedElementHighlightConfig> {
public:
    ~IsolatedElementHighlightConfig() override
    {
    }

    protocol::Overlay::IsolationModeHighlightConfig* getIsolationModeHighlightConfig()
    {
        return m_isolationModeHighlightConfig.get();
    }
    void setIsolationModeHighlightConfig(std::unique_ptr<protocol::Overlay::IsolationModeHighlightConfig> value)
    {
        m_isolationModeHighlightConfig = std::move(value);
    }

    int getNodeId()
    {
        return m_nodeId;
    }
    void setNodeId(int value)
    {
        m_nodeId = value;
    }

    template <int STATE> class IsolatedElementHighlightConfigBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            IsolationModeHighlightConfigSet = 1 << 1,
            NodeIdSet = 1 << 2,
            AllFieldsSet = (IsolationModeHighlightConfigSet | NodeIdSet | 0)
        };

        IsolatedElementHighlightConfigBuilder<STATE | IsolationModeHighlightConfigSet>& setIsolationModeHighlightConfig(
            std::unique_ptr<protocol::Overlay::IsolationModeHighlightConfig> value)
        {
            static_assert(!(STATE & IsolationModeHighlightConfigSet), "property isolationModeHighlightConfig should not be set yet");
            m_result->setIsolationModeHighlightConfig(std::move(value));
            return castState<IsolationModeHighlightConfigSet>();
        }

        IsolatedElementHighlightConfigBuilder<STATE | NodeIdSet>& setNodeId(int value)
        {
            static_assert(!(STATE & NodeIdSet), "property nodeId should not be set yet");
            m_result->setNodeId(value);
            return castState<NodeIdSet>();
        }

        std::unique_ptr<IsolatedElementHighlightConfig> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class IsolatedElementHighlightConfig;
        IsolatedElementHighlightConfigBuilder()
            : m_result(new IsolatedElementHighlightConfig())
        {
        }

        template <int STEP> IsolatedElementHighlightConfigBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<IsolatedElementHighlightConfigBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Overlay::IsolatedElementHighlightConfig> m_result;
    };

    static IsolatedElementHighlightConfigBuilder<0> create()
    {
        return IsolatedElementHighlightConfigBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    IsolatedElementHighlightConfig()
    {
        m_nodeId = 0;
    }

    std::unique_ptr<protocol::Overlay::IsolationModeHighlightConfig> m_isolationModeHighlightConfig;
    int m_nodeId;
};

class CORE_EXPORT IsolationModeHighlightConfig : public ::crdtp::ProtocolObject<IsolationModeHighlightConfig> {
public:
    ~IsolationModeHighlightConfig() override
    {
    }

    bool hasResizerColor()
    {
        return m_resizerColor.has_value();
    }
    protocol::DOM::RGBA* getResizerColor(protocol::DOM::RGBA* defaultValue)
    {
        return m_resizerColor.has_value() ? &m_resizerColor.value() : defaultValue;
    }
    void setResizerColor(std::unique_ptr<protocol::DOM::RGBA> value)
    {
        m_resizerColor = std::move(value);
    }

    bool hasResizerHandleColor()
    {
        return m_resizerHandleColor.has_value();
    }
    protocol::DOM::RGBA* getResizerHandleColor(protocol::DOM::RGBA* defaultValue)
    {
        return m_resizerHandleColor.has_value() ? &m_resizerHandleColor.value() : defaultValue;
    }
    void setResizerHandleColor(std::unique_ptr<protocol::DOM::RGBA> value)
    {
        m_resizerHandleColor = std::move(value);
    }

    bool hasMaskColor()
    {
        return m_maskColor.has_value();
    }
    protocol::DOM::RGBA* getMaskColor(protocol::DOM::RGBA* defaultValue)
    {
        return m_maskColor.has_value() ? &m_maskColor.value() : defaultValue;
    }
    void setMaskColor(std::unique_ptr<protocol::DOM::RGBA> value)
    {
        m_maskColor = std::move(value);
    }

    template <int STATE> class IsolationModeHighlightConfigBuilder {
    public:
        enum { NoFieldsSet = 0, AllFieldsSet = (0) };

        IsolationModeHighlightConfigBuilder<STATE>& setResizerColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setResizerColor(std::move(value));
            return *this;
        }

        IsolationModeHighlightConfigBuilder<STATE>& setResizerHandleColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setResizerHandleColor(std::move(value));
            return *this;
        }

        IsolationModeHighlightConfigBuilder<STATE>& setMaskColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setMaskColor(std::move(value));
            return *this;
        }

        std::unique_ptr<IsolationModeHighlightConfig> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class IsolationModeHighlightConfig;
        IsolationModeHighlightConfigBuilder()
            : m_result(new IsolationModeHighlightConfig())
        {
        }

        template <int STEP> IsolationModeHighlightConfigBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<IsolationModeHighlightConfigBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Overlay::IsolationModeHighlightConfig> m_result;
    };

    static IsolationModeHighlightConfigBuilder<0> create()
    {
        return IsolationModeHighlightConfigBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    IsolationModeHighlightConfig()
    {
    }

    Maybe<protocol::DOM::RGBA> m_resizerColor;
    Maybe<protocol::DOM::RGBA> m_resizerHandleColor;
    Maybe<protocol::DOM::RGBA> m_maskColor;
};

// ------------- Backend interface.

class CORE_EXPORT Backend {
public:
    virtual ~Backend()
    {
    }

    virtual DispatchResponse disable() = 0;
    virtual DispatchResponse enable() = 0;
    virtual DispatchResponse getHighlightObjectForTest(int in_nodeId, Maybe<bool> in_includeDistance, Maybe<bool> in_includeStyle, Maybe<String> in_colorFormat,
        Maybe<bool> in_showAccessibilityInfo, std::unique_ptr<protocol::DictionaryValue>* out_highlight)
        = 0;
    virtual DispatchResponse getGridHighlightObjectsForTest(
        std::unique_ptr<protocol::Array<int>> in_nodeIds, std::unique_ptr<protocol::DictionaryValue>* out_highlights)
        = 0;
    virtual DispatchResponse getSourceOrderHighlightObjectForTest(int in_nodeId, std::unique_ptr<protocol::DictionaryValue>* out_highlight) = 0;
    virtual DispatchResponse hideHighlight() = 0;
    virtual DispatchResponse highlightFrame(
        const String& in_frameId, Maybe<protocol::DOM::RGBA> in_contentColor, Maybe<protocol::DOM::RGBA> in_contentOutlineColor)
        = 0;
    virtual DispatchResponse highlightNode(std::unique_ptr<protocol::Overlay::HighlightConfig> in_highlightConfig, Maybe<int> in_nodeId,
        Maybe<int> in_backendNodeId, Maybe<String> in_objectId, Maybe<String> in_selector)
        = 0;
    virtual DispatchResponse highlightQuad(
        std::unique_ptr<protocol::Array<double>> in_quad, Maybe<protocol::DOM::RGBA> in_color, Maybe<protocol::DOM::RGBA> in_outlineColor)
        = 0;
    virtual DispatchResponse highlightRect(
        int in_x, int in_y, int in_width, int in_height, Maybe<protocol::DOM::RGBA> in_color, Maybe<protocol::DOM::RGBA> in_outlineColor)
        = 0;
    virtual DispatchResponse highlightSourceOrder(std::unique_ptr<protocol::Overlay::SourceOrderConfig> in_sourceOrderConfig, Maybe<int> in_nodeId,
        Maybe<int> in_backendNodeId, Maybe<String> in_objectId)
        = 0;
    virtual DispatchResponse setInspectMode(const String& in_mode, Maybe<protocol::Overlay::HighlightConfig> in_highlightConfig) = 0;
    virtual DispatchResponse setShowAdHighlights(bool in_show) = 0;
    virtual DispatchResponse setPausedInDebuggerMessage(Maybe<String> in_message) = 0;
    virtual DispatchResponse setShowDebugBorders(bool in_show) = 0;
    virtual DispatchResponse setShowFPSCounter(bool in_show) = 0;
    virtual DispatchResponse setShowGridOverlays(std::unique_ptr<protocol::Array<protocol::Overlay::GridNodeHighlightConfig>> in_gridNodeHighlightConfigs) = 0;
    virtual DispatchResponse setShowFlexOverlays(std::unique_ptr<protocol::Array<protocol::Overlay::FlexNodeHighlightConfig>> in_flexNodeHighlightConfigs) = 0;
    virtual DispatchResponse setShowScrollSnapOverlays(
        std::unique_ptr<protocol::Array<protocol::Overlay::ScrollSnapHighlightConfig>> in_scrollSnapHighlightConfigs)
        = 0;
    virtual DispatchResponse setShowContainerQueryOverlays(
        std::unique_ptr<protocol::Array<protocol::Overlay::ContainerQueryHighlightConfig>> in_containerQueryHighlightConfigs)
        = 0;
    virtual DispatchResponse setShowPaintRects(bool in_result) = 0;
    virtual DispatchResponse setShowLayoutShiftRegions(bool in_result) = 0;
    virtual DispatchResponse setShowScrollBottleneckRects(bool in_show) = 0;
    virtual DispatchResponse setShowHitTestBorders(bool in_show) = 0;
    virtual DispatchResponse setShowWebVitals(bool in_show) = 0;
    virtual DispatchResponse setShowViewportSizeOnResize(bool in_show) = 0;
    virtual DispatchResponse setShowHinge(Maybe<protocol::Overlay::HingeConfig> in_hingeConfig) = 0;
    virtual DispatchResponse setShowIsolatedElements(
        std::unique_ptr<protocol::Array<protocol::Overlay::IsolatedElementHighlightConfig>> in_isolatedElementHighlightConfigs)
        = 0;
    virtual DispatchResponse setShowWindowControlsOverlay(Maybe<protocol::Overlay::WindowControlsOverlayConfig> in_windowControlsOverlayConfig) = 0;
};

// ------------- Frontend interface.

class CORE_EXPORT Frontend {
public:
    explicit Frontend(FrontendChannel* frontend_channel)
        : frontend_channel_(frontend_channel)
    {
    }
    void inspectNodeRequested(int backendNodeId);
    void nodeHighlightRequested(int nodeId);
    void screenshotRequested(std::unique_ptr<protocol::Page::Viewport> viewport);
    void inspectModeCanceled();

    void flush();
    void sendRawNotification(std::unique_ptr<Serializable>);

private:
    FrontendChannel* frontend_channel_;
};

// ------------- Dispatcher.

class CORE_EXPORT Dispatcher {
public:
    static void wire(UberDispatcher*, Backend*);

private:
    Dispatcher()
    {
    }
};

// ------------- Metainfo.

class CORE_EXPORT Metainfo {
public:
    using BackendClass = Backend;
    using FrontendClass = Frontend;
    using DispatcherClass = Dispatcher;
    static const char domainName[];
    static const char commandPrefix[];
    static const char version[];
};

} // namespace Overlay
} // namespace blink
} // namespace protocol

#endif // !defined(blink_protocol_Overlay_h)
