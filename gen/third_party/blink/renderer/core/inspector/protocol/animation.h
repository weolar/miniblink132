// This file is generated by TypeBuilder_h.template.

// Copyright 2016 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef blink_protocol_Animation_h
#define blink_protocol_Animation_h

#include "third_party/blink/renderer/core/core_export.h"
#include "third_party/blink/renderer/core/inspector/protocol/protocol.h"
// For each imported domain we generate a ValueConversions struct instead of a full domain definition
// and include Domain::API version from there.
#include "third_party/blink/renderer/core/inspector/protocol/runtime.h"
#include "third_party/blink/renderer/core/inspector/protocol/dom.h"

namespace blink {
namespace protocol {
namespace Animation {
class Animation;
class ViewOrScrollTimeline;
class AnimationEffect;
class KeyframesRule;
class KeyframeStyle;

// ------------- Forward and enum declarations.

// ------------- Type and builder declarations.

class CORE_EXPORT Animation : public ::crdtp::ProtocolObject<Animation> {
public:
    ~Animation() override
    {
    }

    String getId()
    {
        return m_id;
    }
    void setId(const String& value)
    {
        m_id = value;
    }

    String getName()
    {
        return m_name;
    }
    void setName(const String& value)
    {
        m_name = value;
    }

    bool getPausedState()
    {
        return m_pausedState;
    }
    void setPausedState(bool value)
    {
        m_pausedState = value;
    }

    String getPlayState()
    {
        return m_playState;
    }
    void setPlayState(const String& value)
    {
        m_playState = value;
    }

    double getPlaybackRate()
    {
        return m_playbackRate;
    }
    void setPlaybackRate(double value)
    {
        m_playbackRate = value;
    }

    double getStartTime()
    {
        return m_startTime;
    }
    void setStartTime(double value)
    {
        m_startTime = value;
    }

    double getCurrentTime()
    {
        return m_currentTime;
    }
    void setCurrentTime(double value)
    {
        m_currentTime = value;
    }

    struct CORE_EXPORT TypeEnum {
        static const char* CSSTransition;
        static const char* CSSAnimation;
        static const char* WebAnimation;
    }; // TypeEnum

    String getType()
    {
        return m_type;
    }
    void setType(const String& value)
    {
        m_type = value;
    }

    bool hasSource()
    {
        return m_source.has_value();
    }
    protocol::Animation::AnimationEffect* getSource(protocol::Animation::AnimationEffect* defaultValue)
    {
        return m_source.has_value() ? &m_source.value() : defaultValue;
    }
    void setSource(std::unique_ptr<protocol::Animation::AnimationEffect> value)
    {
        m_source = std::move(value);
    }

    bool hasCssId()
    {
        return m_cssId.has_value();
    }
    String getCssId(const String& defaultValue) const
    {
        return m_cssId.value_or(defaultValue);
    }
    void setCssId(const String& value)
    {
        m_cssId = value;
    }

    bool hasViewOrScrollTimeline()
    {
        return m_viewOrScrollTimeline.has_value();
    }
    protocol::Animation::ViewOrScrollTimeline* getViewOrScrollTimeline(protocol::Animation::ViewOrScrollTimeline* defaultValue)
    {
        return m_viewOrScrollTimeline.has_value() ? &m_viewOrScrollTimeline.value() : defaultValue;
    }
    void setViewOrScrollTimeline(std::unique_ptr<protocol::Animation::ViewOrScrollTimeline> value)
    {
        m_viewOrScrollTimeline = std::move(value);
    }

    template <int STATE> class AnimationBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            IdSet = 1 << 1,
            NameSet = 1 << 2,
            PausedStateSet = 1 << 3,
            PlayStateSet = 1 << 4,
            PlaybackRateSet = 1 << 5,
            StartTimeSet = 1 << 6,
            CurrentTimeSet = 1 << 7,
            TypeSet = 1 << 8,
            AllFieldsSet = (IdSet | NameSet | PausedStateSet | PlayStateSet | PlaybackRateSet | StartTimeSet | CurrentTimeSet | TypeSet | 0)
        };

        AnimationBuilder<STATE | IdSet>& setId(const String& value)
        {
            static_assert(!(STATE & IdSet), "property id should not be set yet");
            m_result->setId(value);
            return castState<IdSet>();
        }

        AnimationBuilder<STATE | NameSet>& setName(const String& value)
        {
            static_assert(!(STATE & NameSet), "property name should not be set yet");
            m_result->setName(value);
            return castState<NameSet>();
        }

        AnimationBuilder<STATE | PausedStateSet>& setPausedState(bool value)
        {
            static_assert(!(STATE & PausedStateSet), "property pausedState should not be set yet");
            m_result->setPausedState(value);
            return castState<PausedStateSet>();
        }

        AnimationBuilder<STATE | PlayStateSet>& setPlayState(const String& value)
        {
            static_assert(!(STATE & PlayStateSet), "property playState should not be set yet");
            m_result->setPlayState(value);
            return castState<PlayStateSet>();
        }

        AnimationBuilder<STATE | PlaybackRateSet>& setPlaybackRate(double value)
        {
            static_assert(!(STATE & PlaybackRateSet), "property playbackRate should not be set yet");
            m_result->setPlaybackRate(value);
            return castState<PlaybackRateSet>();
        }

        AnimationBuilder<STATE | StartTimeSet>& setStartTime(double value)
        {
            static_assert(!(STATE & StartTimeSet), "property startTime should not be set yet");
            m_result->setStartTime(value);
            return castState<StartTimeSet>();
        }

        AnimationBuilder<STATE | CurrentTimeSet>& setCurrentTime(double value)
        {
            static_assert(!(STATE & CurrentTimeSet), "property currentTime should not be set yet");
            m_result->setCurrentTime(value);
            return castState<CurrentTimeSet>();
        }

        AnimationBuilder<STATE | TypeSet>& setType(const String& value)
        {
            static_assert(!(STATE & TypeSet), "property type should not be set yet");
            m_result->setType(value);
            return castState<TypeSet>();
        }

        AnimationBuilder<STATE>& setSource(std::unique_ptr<protocol::Animation::AnimationEffect> value)
        {
            m_result->setSource(std::move(value));
            return *this;
        }

        AnimationBuilder<STATE>& setCssId(const String& value)
        {
            m_result->setCssId(value);
            return *this;
        }

        AnimationBuilder<STATE>& setViewOrScrollTimeline(std::unique_ptr<protocol::Animation::ViewOrScrollTimeline> value)
        {
            m_result->setViewOrScrollTimeline(std::move(value));
            return *this;
        }

        std::unique_ptr<Animation> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class Animation;
        AnimationBuilder()
            : m_result(new Animation())
        {
        }

        template <int STEP> AnimationBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<AnimationBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Animation::Animation> m_result;
    };

    static AnimationBuilder<0> create()
    {
        return AnimationBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    Animation()
    {
        m_pausedState = false;
        m_playbackRate = 0;
        m_startTime = 0;
        m_currentTime = 0;
    }

    String m_id;
    String m_name;
    bool m_pausedState;
    String m_playState;
    double m_playbackRate;
    double m_startTime;
    double m_currentTime;
    String m_type;
    Maybe<protocol::Animation::AnimationEffect> m_source;
    Maybe<String> m_cssId;
    Maybe<protocol::Animation::ViewOrScrollTimeline> m_viewOrScrollTimeline;
};

class CORE_EXPORT ViewOrScrollTimeline : public ::crdtp::ProtocolObject<ViewOrScrollTimeline> {
public:
    ~ViewOrScrollTimeline() override
    {
    }

    bool hasSourceNodeId()
    {
        return m_sourceNodeId.has_value();
    }
    int getSourceNodeId(int defaultValue) const
    {
        return m_sourceNodeId.value_or(defaultValue);
    }
    void setSourceNodeId(int value)
    {
        m_sourceNodeId = value;
    }

    bool hasStartOffset()
    {
        return m_startOffset.has_value();
    }
    double getStartOffset(double defaultValue) const
    {
        return m_startOffset.value_or(defaultValue);
    }
    void setStartOffset(double value)
    {
        m_startOffset = value;
    }

    bool hasEndOffset()
    {
        return m_endOffset.has_value();
    }
    double getEndOffset(double defaultValue) const
    {
        return m_endOffset.value_or(defaultValue);
    }
    void setEndOffset(double value)
    {
        m_endOffset = value;
    }

    bool hasSubjectNodeId()
    {
        return m_subjectNodeId.has_value();
    }
    int getSubjectNodeId(int defaultValue) const
    {
        return m_subjectNodeId.value_or(defaultValue);
    }
    void setSubjectNodeId(int value)
    {
        m_subjectNodeId = value;
    }

    String getAxis()
    {
        return m_axis;
    }
    void setAxis(const String& value)
    {
        m_axis = value;
    }

    template <int STATE> class ViewOrScrollTimelineBuilder {
    public:
        enum { NoFieldsSet = 0, AxisSet = 1 << 1, AllFieldsSet = (AxisSet | 0) };

        ViewOrScrollTimelineBuilder<STATE>& setSourceNodeId(int value)
        {
            m_result->setSourceNodeId(value);
            return *this;
        }

        ViewOrScrollTimelineBuilder<STATE>& setStartOffset(double value)
        {
            m_result->setStartOffset(value);
            return *this;
        }

        ViewOrScrollTimelineBuilder<STATE>& setEndOffset(double value)
        {
            m_result->setEndOffset(value);
            return *this;
        }

        ViewOrScrollTimelineBuilder<STATE>& setSubjectNodeId(int value)
        {
            m_result->setSubjectNodeId(value);
            return *this;
        }

        ViewOrScrollTimelineBuilder<STATE | AxisSet>& setAxis(const String& value)
        {
            static_assert(!(STATE & AxisSet), "property axis should not be set yet");
            m_result->setAxis(value);
            return castState<AxisSet>();
        }

        std::unique_ptr<ViewOrScrollTimeline> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class ViewOrScrollTimeline;
        ViewOrScrollTimelineBuilder()
            : m_result(new ViewOrScrollTimeline())
        {
        }

        template <int STEP> ViewOrScrollTimelineBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<ViewOrScrollTimelineBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Animation::ViewOrScrollTimeline> m_result;
    };

    static ViewOrScrollTimelineBuilder<0> create()
    {
        return ViewOrScrollTimelineBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    ViewOrScrollTimeline()
    {
    }

    Maybe<int> m_sourceNodeId;
    Maybe<double> m_startOffset;
    Maybe<double> m_endOffset;
    Maybe<int> m_subjectNodeId;
    String m_axis;
};

class CORE_EXPORT AnimationEffect : public ::crdtp::ProtocolObject<AnimationEffect> {
public:
    ~AnimationEffect() override
    {
    }

    double getDelay()
    {
        return m_delay;
    }
    void setDelay(double value)
    {
        m_delay = value;
    }

    double getEndDelay()
    {
        return m_endDelay;
    }
    void setEndDelay(double value)
    {
        m_endDelay = value;
    }

    double getIterationStart()
    {
        return m_iterationStart;
    }
    void setIterationStart(double value)
    {
        m_iterationStart = value;
    }

    double getIterations()
    {
        return m_iterations;
    }
    void setIterations(double value)
    {
        m_iterations = value;
    }

    double getDuration()
    {
        return m_duration;
    }
    void setDuration(double value)
    {
        m_duration = value;
    }

    String getDirection()
    {
        return m_direction;
    }
    void setDirection(const String& value)
    {
        m_direction = value;
    }

    String getFill()
    {
        return m_fill;
    }
    void setFill(const String& value)
    {
        m_fill = value;
    }

    bool hasBackendNodeId()
    {
        return m_backendNodeId.has_value();
    }
    int getBackendNodeId(int defaultValue) const
    {
        return m_backendNodeId.value_or(defaultValue);
    }
    void setBackendNodeId(int value)
    {
        m_backendNodeId = value;
    }

    bool hasKeyframesRule()
    {
        return m_keyframesRule.has_value();
    }
    protocol::Animation::KeyframesRule* getKeyframesRule(protocol::Animation::KeyframesRule* defaultValue)
    {
        return m_keyframesRule.has_value() ? &m_keyframesRule.value() : defaultValue;
    }
    void setKeyframesRule(std::unique_ptr<protocol::Animation::KeyframesRule> value)
    {
        m_keyframesRule = std::move(value);
    }

    String getEasing()
    {
        return m_easing;
    }
    void setEasing(const String& value)
    {
        m_easing = value;
    }

    template <int STATE> class AnimationEffectBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            DelaySet = 1 << 1,
            EndDelaySet = 1 << 2,
            IterationStartSet = 1 << 3,
            IterationsSet = 1 << 4,
            DurationSet = 1 << 5,
            DirectionSet = 1 << 6,
            FillSet = 1 << 7,
            EasingSet = 1 << 8,
            AllFieldsSet = (DelaySet | EndDelaySet | IterationStartSet | IterationsSet | DurationSet | DirectionSet | FillSet | EasingSet | 0)
        };

        AnimationEffectBuilder<STATE | DelaySet>& setDelay(double value)
        {
            static_assert(!(STATE & DelaySet), "property delay should not be set yet");
            m_result->setDelay(value);
            return castState<DelaySet>();
        }

        AnimationEffectBuilder<STATE | EndDelaySet>& setEndDelay(double value)
        {
            static_assert(!(STATE & EndDelaySet), "property endDelay should not be set yet");
            m_result->setEndDelay(value);
            return castState<EndDelaySet>();
        }

        AnimationEffectBuilder<STATE | IterationStartSet>& setIterationStart(double value)
        {
            static_assert(!(STATE & IterationStartSet), "property iterationStart should not be set yet");
            m_result->setIterationStart(value);
            return castState<IterationStartSet>();
        }

        AnimationEffectBuilder<STATE | IterationsSet>& setIterations(double value)
        {
            static_assert(!(STATE & IterationsSet), "property iterations should not be set yet");
            m_result->setIterations(value);
            return castState<IterationsSet>();
        }

        AnimationEffectBuilder<STATE | DurationSet>& setDuration(double value)
        {
            static_assert(!(STATE & DurationSet), "property duration should not be set yet");
            m_result->setDuration(value);
            return castState<DurationSet>();
        }

        AnimationEffectBuilder<STATE | DirectionSet>& setDirection(const String& value)
        {
            static_assert(!(STATE & DirectionSet), "property direction should not be set yet");
            m_result->setDirection(value);
            return castState<DirectionSet>();
        }

        AnimationEffectBuilder<STATE | FillSet>& setFill(const String& value)
        {
            static_assert(!(STATE & FillSet), "property fill should not be set yet");
            m_result->setFill(value);
            return castState<FillSet>();
        }

        AnimationEffectBuilder<STATE>& setBackendNodeId(int value)
        {
            m_result->setBackendNodeId(value);
            return *this;
        }

        AnimationEffectBuilder<STATE>& setKeyframesRule(std::unique_ptr<protocol::Animation::KeyframesRule> value)
        {
            m_result->setKeyframesRule(std::move(value));
            return *this;
        }

        AnimationEffectBuilder<STATE | EasingSet>& setEasing(const String& value)
        {
            static_assert(!(STATE & EasingSet), "property easing should not be set yet");
            m_result->setEasing(value);
            return castState<EasingSet>();
        }

        std::unique_ptr<AnimationEffect> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class AnimationEffect;
        AnimationEffectBuilder()
            : m_result(new AnimationEffect())
        {
        }

        template <int STEP> AnimationEffectBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<AnimationEffectBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Animation::AnimationEffect> m_result;
    };

    static AnimationEffectBuilder<0> create()
    {
        return AnimationEffectBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    AnimationEffect()
    {
        m_delay = 0;
        m_endDelay = 0;
        m_iterationStart = 0;
        m_iterations = 0;
        m_duration = 0;
    }

    double m_delay;
    double m_endDelay;
    double m_iterationStart;
    double m_iterations;
    double m_duration;
    String m_direction;
    String m_fill;
    Maybe<int> m_backendNodeId;
    Maybe<protocol::Animation::KeyframesRule> m_keyframesRule;
    String m_easing;
};

class CORE_EXPORT KeyframesRule : public ::crdtp::ProtocolObject<KeyframesRule> {
public:
    ~KeyframesRule() override
    {
    }

    bool hasName()
    {
        return m_name.has_value();
    }
    String getName(const String& defaultValue) const
    {
        return m_name.value_or(defaultValue);
    }
    void setName(const String& value)
    {
        m_name = value;
    }

    protocol::Array<protocol::Animation::KeyframeStyle>* getKeyframes()
    {
        return m_keyframes.get();
    }
    void setKeyframes(std::unique_ptr<protocol::Array<protocol::Animation::KeyframeStyle>> value)
    {
        m_keyframes = std::move(value);
    }

    template <int STATE> class KeyframesRuleBuilder {
    public:
        enum { NoFieldsSet = 0, KeyframesSet = 1 << 1, AllFieldsSet = (KeyframesSet | 0) };

        KeyframesRuleBuilder<STATE>& setName(const String& value)
        {
            m_result->setName(value);
            return *this;
        }

        KeyframesRuleBuilder<STATE | KeyframesSet>& setKeyframes(std::unique_ptr<protocol::Array<protocol::Animation::KeyframeStyle>> value)
        {
            static_assert(!(STATE & KeyframesSet), "property keyframes should not be set yet");
            m_result->setKeyframes(std::move(value));
            return castState<KeyframesSet>();
        }

        std::unique_ptr<KeyframesRule> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class KeyframesRule;
        KeyframesRuleBuilder()
            : m_result(new KeyframesRule())
        {
        }

        template <int STEP> KeyframesRuleBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<KeyframesRuleBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Animation::KeyframesRule> m_result;
    };

    static KeyframesRuleBuilder<0> create()
    {
        return KeyframesRuleBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    KeyframesRule()
    {
    }

    Maybe<String> m_name;
    std::unique_ptr<protocol::Array<protocol::Animation::KeyframeStyle>> m_keyframes;
};

class CORE_EXPORT KeyframeStyle : public ::crdtp::ProtocolObject<KeyframeStyle> {
public:
    ~KeyframeStyle() override
    {
    }

    String getOffset()
    {
        return m_offset;
    }
    void setOffset(const String& value)
    {
        m_offset = value;
    }

    String getEasing()
    {
        return m_easing;
    }
    void setEasing(const String& value)
    {
        m_easing = value;
    }

    template <int STATE> class KeyframeStyleBuilder {
    public:
        enum { NoFieldsSet = 0, OffsetSet = 1 << 1, EasingSet = 1 << 2, AllFieldsSet = (OffsetSet | EasingSet | 0) };

        KeyframeStyleBuilder<STATE | OffsetSet>& setOffset(const String& value)
        {
            static_assert(!(STATE & OffsetSet), "property offset should not be set yet");
            m_result->setOffset(value);
            return castState<OffsetSet>();
        }

        KeyframeStyleBuilder<STATE | EasingSet>& setEasing(const String& value)
        {
            static_assert(!(STATE & EasingSet), "property easing should not be set yet");
            m_result->setEasing(value);
            return castState<EasingSet>();
        }

        std::unique_ptr<KeyframeStyle> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class KeyframeStyle;
        KeyframeStyleBuilder()
            : m_result(new KeyframeStyle())
        {
        }

        template <int STEP> KeyframeStyleBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<KeyframeStyleBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Animation::KeyframeStyle> m_result;
    };

    static KeyframeStyleBuilder<0> create()
    {
        return KeyframeStyleBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    KeyframeStyle()
    {
    }

    String m_offset;
    String m_easing;
};

// ------------- Backend interface.

class CORE_EXPORT Backend {
public:
    virtual ~Backend()
    {
    }

    virtual DispatchResponse disable() = 0;
    virtual DispatchResponse enable() = 0;
    virtual DispatchResponse getCurrentTime(const String& in_id, double* out_currentTime) = 0;
    virtual DispatchResponse getPlaybackRate(double* out_playbackRate) = 0;
    virtual DispatchResponse releaseAnimations(std::unique_ptr<protocol::Array<String>> in_animations) = 0;
    virtual DispatchResponse resolveAnimation(
        const String& in_animationId, std::unique_ptr<v8_inspector::protocol::Runtime::API::RemoteObject>* out_remoteObject)
        = 0;
    virtual DispatchResponse seekAnimations(std::unique_ptr<protocol::Array<String>> in_animations, double in_currentTime) = 0;
    virtual DispatchResponse setPaused(std::unique_ptr<protocol::Array<String>> in_animations, bool in_paused) = 0;
    virtual DispatchResponse setPlaybackRate(double in_playbackRate) = 0;
    virtual DispatchResponse setTiming(const String& in_animationId, double in_duration, double in_delay) = 0;
};

// ------------- Frontend interface.

class CORE_EXPORT Frontend {
public:
    explicit Frontend(FrontendChannel* frontend_channel)
        : frontend_channel_(frontend_channel)
    {
    }
    void animationCanceled(const String& id);
    void animationCreated(const String& id);
    void animationStarted(std::unique_ptr<protocol::Animation::Animation> animation);
    void animationUpdated(std::unique_ptr<protocol::Animation::Animation> animation);

    void flush();
    void sendRawNotification(std::unique_ptr<Serializable>);

private:
    FrontendChannel* frontend_channel_;
};

// ------------- Dispatcher.

class CORE_EXPORT Dispatcher {
public:
    static void wire(UberDispatcher*, Backend*);

private:
    Dispatcher()
    {
    }
};

// ------------- Metainfo.

class CORE_EXPORT Metainfo {
public:
    using BackendClass = Backend;
    using FrontendClass = Frontend;
    using DispatcherClass = Dispatcher;
    static const char domainName[];
    static const char commandPrefix[];
    static const char version[];
};

} // namespace Animation
} // namespace blink
} // namespace protocol

#endif // !defined(blink_protocol_Animation_h)
