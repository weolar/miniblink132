// This file is generated by TypeBuilder_h.template.

// Copyright 2016 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef blink_protocol_Preload_h
#define blink_protocol_Preload_h

#include "third_party/blink/renderer/core/core_export.h"
#include "third_party/blink/renderer/core/inspector/protocol/protocol.h"
// For each imported domain we generate a ValueConversions struct instead of a full domain definition
// and include Domain::API version from there.

namespace blink {
namespace protocol {
namespace Preload {
using RuleSetId = String;
class RuleSet;
using RuleSetErrorType = String;
using SpeculationAction = String;
using SpeculationTargetHint = String;
class PreloadingAttemptKey;
class PreloadingAttemptSource;
using PrerenderFinalStatus = String;
using PreloadingStatus = String;
using PrefetchStatus = String;
class PrerenderMismatchedHeaders;

// ------------- Forward and enum declarations.

namespace RuleSetErrorTypeEnum {
CORE_EXPORT extern const char SourceIsNotJsonObject[];
CORE_EXPORT extern const char InvalidRulesSkipped[];
} // namespace RuleSetErrorTypeEnum

namespace SpeculationActionEnum {
CORE_EXPORT extern const char Prefetch[];
CORE_EXPORT extern const char Prerender[];
} // namespace SpeculationActionEnum

namespace SpeculationTargetHintEnum {
CORE_EXPORT extern const char Blank[];
CORE_EXPORT extern const char Self[];
} // namespace SpeculationTargetHintEnum

namespace PrerenderFinalStatusEnum {
CORE_EXPORT extern const char Activated[];
CORE_EXPORT extern const char Destroyed[];
CORE_EXPORT extern const char LowEndDevice[];
CORE_EXPORT extern const char InvalidSchemeRedirect[];
CORE_EXPORT extern const char InvalidSchemeNavigation[];
CORE_EXPORT extern const char NavigationRequestBlockedByCsp[];
CORE_EXPORT extern const char MainFrameNavigation[];
CORE_EXPORT extern const char MojoBinderPolicy[];
CORE_EXPORT extern const char RendererProcessCrashed[];
CORE_EXPORT extern const char RendererProcessKilled[];
CORE_EXPORT extern const char Download[];
CORE_EXPORT extern const char TriggerDestroyed[];
CORE_EXPORT extern const char NavigationNotCommitted[];
CORE_EXPORT extern const char NavigationBadHttpStatus[];
CORE_EXPORT extern const char ClientCertRequested[];
CORE_EXPORT extern const char NavigationRequestNetworkError[];
CORE_EXPORT extern const char CancelAllHostsForTesting[];
CORE_EXPORT extern const char DidFailLoad[];
CORE_EXPORT extern const char Stop[];
CORE_EXPORT extern const char SslCertificateError[];
CORE_EXPORT extern const char LoginAuthRequested[];
CORE_EXPORT extern const char UaChangeRequiresReload[];
CORE_EXPORT extern const char BlockedByClient[];
CORE_EXPORT extern const char AudioOutputDeviceRequested[];
CORE_EXPORT extern const char MixedContent[];
CORE_EXPORT extern const char TriggerBackgrounded[];
CORE_EXPORT extern const char MemoryLimitExceeded[];
CORE_EXPORT extern const char DataSaverEnabled[];
CORE_EXPORT extern const char TriggerUrlHasEffectiveUrl[];
CORE_EXPORT extern const char ActivatedBeforeStarted[];
CORE_EXPORT extern const char InactivePageRestriction[];
CORE_EXPORT extern const char StartFailed[];
CORE_EXPORT extern const char TimeoutBackgrounded[];
CORE_EXPORT extern const char CrossSiteRedirectInInitialNavigation[];
CORE_EXPORT extern const char CrossSiteNavigationInInitialNavigation[];
CORE_EXPORT extern const char SameSiteCrossOriginRedirectNotOptInInInitialNavigation[];
CORE_EXPORT extern const char SameSiteCrossOriginNavigationNotOptInInInitialNavigation[];
CORE_EXPORT extern const char ActivationNavigationParameterMismatch[];
CORE_EXPORT extern const char ActivatedInBackground[];
CORE_EXPORT extern const char EmbedderHostDisallowed[];
CORE_EXPORT extern const char ActivationNavigationDestroyedBeforeSuccess[];
CORE_EXPORT extern const char TabClosedByUserGesture[];
CORE_EXPORT extern const char TabClosedWithoutUserGesture[];
CORE_EXPORT extern const char PrimaryMainFrameRendererProcessCrashed[];
CORE_EXPORT extern const char PrimaryMainFrameRendererProcessKilled[];
CORE_EXPORT extern const char ActivationFramePolicyNotCompatible[];
CORE_EXPORT extern const char PreloadingDisabled[];
CORE_EXPORT extern const char BatterySaverEnabled[];
CORE_EXPORT extern const char ActivatedDuringMainFrameNavigation[];
CORE_EXPORT extern const char PreloadingUnsupportedByWebContents[];
CORE_EXPORT extern const char CrossSiteRedirectInMainFrameNavigation[];
CORE_EXPORT extern const char CrossSiteNavigationInMainFrameNavigation[];
CORE_EXPORT extern const char SameSiteCrossOriginRedirectNotOptInInMainFrameNavigation[];
CORE_EXPORT extern const char SameSiteCrossOriginNavigationNotOptInInMainFrameNavigation[];
CORE_EXPORT extern const char MemoryPressureOnTrigger[];
CORE_EXPORT extern const char MemoryPressureAfterTriggered[];
CORE_EXPORT extern const char PrerenderingDisabledByDevTools[];
CORE_EXPORT extern const char SpeculationRuleRemoved[];
CORE_EXPORT extern const char ActivatedWithAuxiliaryBrowsingContexts[];
CORE_EXPORT extern const char MaxNumOfRunningEagerPrerendersExceeded[];
CORE_EXPORT extern const char MaxNumOfRunningNonEagerPrerendersExceeded[];
CORE_EXPORT extern const char MaxNumOfRunningEmbedderPrerendersExceeded[];
CORE_EXPORT extern const char PrerenderingUrlHasEffectiveUrl[];
CORE_EXPORT extern const char RedirectedPrerenderingUrlHasEffectiveUrl[];
CORE_EXPORT extern const char ActivationUrlHasEffectiveUrl[];
CORE_EXPORT extern const char JavaScriptInterfaceAdded[];
CORE_EXPORT extern const char JavaScriptInterfaceRemoved[];
CORE_EXPORT extern const char AllPrerenderingCanceled[];
CORE_EXPORT extern const char WindowClosed[];
CORE_EXPORT extern const char SlowNetwork[];
CORE_EXPORT extern const char OtherPrerenderedPageActivated[];
CORE_EXPORT extern const char V8OptimizerDisabled[];
CORE_EXPORT extern const char PrerenderFailedDuringPrefetch[];
} // namespace PrerenderFinalStatusEnum

namespace PreloadingStatusEnum {
CORE_EXPORT extern const char Pending[];
CORE_EXPORT extern const char Running[];
CORE_EXPORT extern const char Ready[];
CORE_EXPORT extern const char Success[];
CORE_EXPORT extern const char Failure[];
CORE_EXPORT extern const char NotSupported[];
} // namespace PreloadingStatusEnum

namespace PrefetchStatusEnum {
CORE_EXPORT extern const char PrefetchAllowed[];
CORE_EXPORT extern const char PrefetchFailedIneligibleRedirect[];
CORE_EXPORT extern const char PrefetchFailedInvalidRedirect[];
CORE_EXPORT extern const char PrefetchFailedMIMENotSupported[];
CORE_EXPORT extern const char PrefetchFailedNetError[];
CORE_EXPORT extern const char PrefetchFailedNon2XX[];
CORE_EXPORT extern const char PrefetchEvictedAfterCandidateRemoved[];
CORE_EXPORT extern const char PrefetchEvictedForNewerPrefetch[];
CORE_EXPORT extern const char PrefetchHeldback[];
CORE_EXPORT extern const char PrefetchIneligibleRetryAfter[];
CORE_EXPORT extern const char PrefetchIsPrivacyDecoy[];
CORE_EXPORT extern const char PrefetchIsStale[];
CORE_EXPORT extern const char PrefetchNotEligibleBrowserContextOffTheRecord[];
CORE_EXPORT extern const char PrefetchNotEligibleDataSaverEnabled[];
CORE_EXPORT extern const char PrefetchNotEligibleExistingProxy[];
CORE_EXPORT extern const char PrefetchNotEligibleHostIsNonUnique[];
CORE_EXPORT extern const char PrefetchNotEligibleNonDefaultStoragePartition[];
CORE_EXPORT extern const char PrefetchNotEligibleSameSiteCrossOriginPrefetchRequiredProxy[];
CORE_EXPORT extern const char PrefetchNotEligibleSchemeIsNotHttps[];
CORE_EXPORT extern const char PrefetchNotEligibleUserHasCookies[];
CORE_EXPORT extern const char PrefetchNotEligibleUserHasServiceWorker[];
CORE_EXPORT extern const char PrefetchNotEligibleBatterySaverEnabled[];
CORE_EXPORT extern const char PrefetchNotEligiblePreloadingDisabled[];
CORE_EXPORT extern const char PrefetchNotFinishedInTime[];
CORE_EXPORT extern const char PrefetchNotStarted[];
CORE_EXPORT extern const char PrefetchNotUsedCookiesChanged[];
CORE_EXPORT extern const char PrefetchProxyNotAvailable[];
CORE_EXPORT extern const char PrefetchResponseUsed[];
CORE_EXPORT extern const char PrefetchSuccessfulButNotUsed[];
CORE_EXPORT extern const char PrefetchNotUsedProbeFailed[];
} // namespace PrefetchStatusEnum

// ------------- Type and builder declarations.

class CORE_EXPORT RuleSet : public ::crdtp::ProtocolObject<RuleSet> {
public:
    ~RuleSet() override
    {
    }

    String getId()
    {
        return m_id;
    }
    void setId(const String& value)
    {
        m_id = value;
    }

    String getLoaderId()
    {
        return m_loaderId;
    }
    void setLoaderId(const String& value)
    {
        m_loaderId = value;
    }

    String getSourceText()
    {
        return m_sourceText;
    }
    void setSourceText(const String& value)
    {
        m_sourceText = value;
    }

    bool hasBackendNodeId()
    {
        return m_backendNodeId.has_value();
    }
    int getBackendNodeId(int defaultValue) const
    {
        return m_backendNodeId.value_or(defaultValue);
    }
    void setBackendNodeId(int value)
    {
        m_backendNodeId = value;
    }

    bool hasUrl()
    {
        return m_url.has_value();
    }
    String getUrl(const String& defaultValue) const
    {
        return m_url.value_or(defaultValue);
    }
    void setUrl(const String& value)
    {
        m_url = value;
    }

    bool hasRequestId()
    {
        return m_requestId.has_value();
    }
    String getRequestId(const String& defaultValue) const
    {
        return m_requestId.value_or(defaultValue);
    }
    void setRequestId(const String& value)
    {
        m_requestId = value;
    }

    bool hasErrorType()
    {
        return m_errorType.has_value();
    }
    String getErrorType(const String& defaultValue) const
    {
        return m_errorType.value_or(defaultValue);
    }
    void setErrorType(const String& value)
    {
        m_errorType = value;
    }

    bool hasErrorMessage()
    {
        return m_errorMessage.has_value();
    }
    String getErrorMessage(const String& defaultValue) const
    {
        return m_errorMessage.value_or(defaultValue);
    }
    void setErrorMessage(const String& value)
    {
        m_errorMessage = value;
    }

    template <int STATE> class RuleSetBuilder {
    public:
        enum { NoFieldsSet = 0, IdSet = 1 << 1, LoaderIdSet = 1 << 2, SourceTextSet = 1 << 3, AllFieldsSet = (IdSet | LoaderIdSet | SourceTextSet | 0) };

        RuleSetBuilder<STATE | IdSet>& setId(const String& value)
        {
            static_assert(!(STATE & IdSet), "property id should not be set yet");
            m_result->setId(value);
            return castState<IdSet>();
        }

        RuleSetBuilder<STATE | LoaderIdSet>& setLoaderId(const String& value)
        {
            static_assert(!(STATE & LoaderIdSet), "property loaderId should not be set yet");
            m_result->setLoaderId(value);
            return castState<LoaderIdSet>();
        }

        RuleSetBuilder<STATE | SourceTextSet>& setSourceText(const String& value)
        {
            static_assert(!(STATE & SourceTextSet), "property sourceText should not be set yet");
            m_result->setSourceText(value);
            return castState<SourceTextSet>();
        }

        RuleSetBuilder<STATE>& setBackendNodeId(int value)
        {
            m_result->setBackendNodeId(value);
            return *this;
        }

        RuleSetBuilder<STATE>& setUrl(const String& value)
        {
            m_result->setUrl(value);
            return *this;
        }

        RuleSetBuilder<STATE>& setRequestId(const String& value)
        {
            m_result->setRequestId(value);
            return *this;
        }

        RuleSetBuilder<STATE>& setErrorType(const String& value)
        {
            m_result->setErrorType(value);
            return *this;
        }

        RuleSetBuilder<STATE>& setErrorMessage(const String& value)
        {
            m_result->setErrorMessage(value);
            return *this;
        }

        std::unique_ptr<RuleSet> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class RuleSet;
        RuleSetBuilder()
            : m_result(new RuleSet())
        {
        }

        template <int STEP> RuleSetBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<RuleSetBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Preload::RuleSet> m_result;
    };

    static RuleSetBuilder<0> create()
    {
        return RuleSetBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    RuleSet()
    {
    }

    String m_id;
    String m_loaderId;
    String m_sourceText;
    Maybe<int> m_backendNodeId;
    Maybe<String> m_url;
    Maybe<String> m_requestId;
    Maybe<String> m_errorType;
    Maybe<String> m_errorMessage;
};

class CORE_EXPORT PreloadingAttemptKey : public ::crdtp::ProtocolObject<PreloadingAttemptKey> {
public:
    ~PreloadingAttemptKey() override
    {
    }

    String getLoaderId()
    {
        return m_loaderId;
    }
    void setLoaderId(const String& value)
    {
        m_loaderId = value;
    }

    String getAction()
    {
        return m_action;
    }
    void setAction(const String& value)
    {
        m_action = value;
    }

    String getUrl()
    {
        return m_url;
    }
    void setUrl(const String& value)
    {
        m_url = value;
    }

    bool hasTargetHint()
    {
        return m_targetHint.has_value();
    }
    String getTargetHint(const String& defaultValue) const
    {
        return m_targetHint.value_or(defaultValue);
    }
    void setTargetHint(const String& value)
    {
        m_targetHint = value;
    }

    template <int STATE> class PreloadingAttemptKeyBuilder {
    public:
        enum { NoFieldsSet = 0, LoaderIdSet = 1 << 1, ActionSet = 1 << 2, UrlSet = 1 << 3, AllFieldsSet = (LoaderIdSet | ActionSet | UrlSet | 0) };

        PreloadingAttemptKeyBuilder<STATE | LoaderIdSet>& setLoaderId(const String& value)
        {
            static_assert(!(STATE & LoaderIdSet), "property loaderId should not be set yet");
            m_result->setLoaderId(value);
            return castState<LoaderIdSet>();
        }

        PreloadingAttemptKeyBuilder<STATE | ActionSet>& setAction(const String& value)
        {
            static_assert(!(STATE & ActionSet), "property action should not be set yet");
            m_result->setAction(value);
            return castState<ActionSet>();
        }

        PreloadingAttemptKeyBuilder<STATE | UrlSet>& setUrl(const String& value)
        {
            static_assert(!(STATE & UrlSet), "property url should not be set yet");
            m_result->setUrl(value);
            return castState<UrlSet>();
        }

        PreloadingAttemptKeyBuilder<STATE>& setTargetHint(const String& value)
        {
            m_result->setTargetHint(value);
            return *this;
        }

        std::unique_ptr<PreloadingAttemptKey> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class PreloadingAttemptKey;
        PreloadingAttemptKeyBuilder()
            : m_result(new PreloadingAttemptKey())
        {
        }

        template <int STEP> PreloadingAttemptKeyBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<PreloadingAttemptKeyBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Preload::PreloadingAttemptKey> m_result;
    };

    static PreloadingAttemptKeyBuilder<0> create()
    {
        return PreloadingAttemptKeyBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    PreloadingAttemptKey()
    {
    }

    String m_loaderId;
    String m_action;
    String m_url;
    Maybe<String> m_targetHint;
};

class CORE_EXPORT PreloadingAttemptSource : public ::crdtp::ProtocolObject<PreloadingAttemptSource> {
public:
    ~PreloadingAttemptSource() override
    {
    }

    protocol::Preload::PreloadingAttemptKey* getKey()
    {
        return m_key.get();
    }
    void setKey(std::unique_ptr<protocol::Preload::PreloadingAttemptKey> value)
    {
        m_key = std::move(value);
    }

    protocol::Array<String>* getRuleSetIds()
    {
        return m_ruleSetIds.get();
    }
    void setRuleSetIds(std::unique_ptr<protocol::Array<String>> value)
    {
        m_ruleSetIds = std::move(value);
    }

    protocol::Array<int>* getNodeIds()
    {
        return m_nodeIds.get();
    }
    void setNodeIds(std::unique_ptr<protocol::Array<int>> value)
    {
        m_nodeIds = std::move(value);
    }

    template <int STATE> class PreloadingAttemptSourceBuilder {
    public:
        enum { NoFieldsSet = 0, KeySet = 1 << 1, RuleSetIdsSet = 1 << 2, NodeIdsSet = 1 << 3, AllFieldsSet = (KeySet | RuleSetIdsSet | NodeIdsSet | 0) };

        PreloadingAttemptSourceBuilder<STATE | KeySet>& setKey(std::unique_ptr<protocol::Preload::PreloadingAttemptKey> value)
        {
            static_assert(!(STATE & KeySet), "property key should not be set yet");
            m_result->setKey(std::move(value));
            return castState<KeySet>();
        }

        PreloadingAttemptSourceBuilder<STATE | RuleSetIdsSet>& setRuleSetIds(std::unique_ptr<protocol::Array<String>> value)
        {
            static_assert(!(STATE & RuleSetIdsSet), "property ruleSetIds should not be set yet");
            m_result->setRuleSetIds(std::move(value));
            return castState<RuleSetIdsSet>();
        }

        PreloadingAttemptSourceBuilder<STATE | NodeIdsSet>& setNodeIds(std::unique_ptr<protocol::Array<int>> value)
        {
            static_assert(!(STATE & NodeIdsSet), "property nodeIds should not be set yet");
            m_result->setNodeIds(std::move(value));
            return castState<NodeIdsSet>();
        }

        std::unique_ptr<PreloadingAttemptSource> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class PreloadingAttemptSource;
        PreloadingAttemptSourceBuilder()
            : m_result(new PreloadingAttemptSource())
        {
        }

        template <int STEP> PreloadingAttemptSourceBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<PreloadingAttemptSourceBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Preload::PreloadingAttemptSource> m_result;
    };

    static PreloadingAttemptSourceBuilder<0> create()
    {
        return PreloadingAttemptSourceBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    PreloadingAttemptSource()
    {
    }

    std::unique_ptr<protocol::Preload::PreloadingAttemptKey> m_key;
    std::unique_ptr<protocol::Array<String>> m_ruleSetIds;
    std::unique_ptr<protocol::Array<int>> m_nodeIds;
};

class CORE_EXPORT PrerenderMismatchedHeaders : public ::crdtp::ProtocolObject<PrerenderMismatchedHeaders> {
public:
    ~PrerenderMismatchedHeaders() override
    {
    }

    String getHeaderName()
    {
        return m_headerName;
    }
    void setHeaderName(const String& value)
    {
        m_headerName = value;
    }

    bool hasInitialValue()
    {
        return m_initialValue.has_value();
    }
    String getInitialValue(const String& defaultValue) const
    {
        return m_initialValue.value_or(defaultValue);
    }
    void setInitialValue(const String& value)
    {
        m_initialValue = value;
    }

    bool hasActivationValue()
    {
        return m_activationValue.has_value();
    }
    String getActivationValue(const String& defaultValue) const
    {
        return m_activationValue.value_or(defaultValue);
    }
    void setActivationValue(const String& value)
    {
        m_activationValue = value;
    }

    template <int STATE> class PrerenderMismatchedHeadersBuilder {
    public:
        enum { NoFieldsSet = 0, HeaderNameSet = 1 << 1, AllFieldsSet = (HeaderNameSet | 0) };

        PrerenderMismatchedHeadersBuilder<STATE | HeaderNameSet>& setHeaderName(const String& value)
        {
            static_assert(!(STATE & HeaderNameSet), "property headerName should not be set yet");
            m_result->setHeaderName(value);
            return castState<HeaderNameSet>();
        }

        PrerenderMismatchedHeadersBuilder<STATE>& setInitialValue(const String& value)
        {
            m_result->setInitialValue(value);
            return *this;
        }

        PrerenderMismatchedHeadersBuilder<STATE>& setActivationValue(const String& value)
        {
            m_result->setActivationValue(value);
            return *this;
        }

        std::unique_ptr<PrerenderMismatchedHeaders> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class PrerenderMismatchedHeaders;
        PrerenderMismatchedHeadersBuilder()
            : m_result(new PrerenderMismatchedHeaders())
        {
        }

        template <int STEP> PrerenderMismatchedHeadersBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<PrerenderMismatchedHeadersBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Preload::PrerenderMismatchedHeaders> m_result;
    };

    static PrerenderMismatchedHeadersBuilder<0> create()
    {
        return PrerenderMismatchedHeadersBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    PrerenderMismatchedHeaders()
    {
    }

    String m_headerName;
    Maybe<String> m_initialValue;
    Maybe<String> m_activationValue;
};

// ------------- Backend interface.

class CORE_EXPORT Backend {
public:
    virtual ~Backend()
    {
    }

    virtual DispatchResponse enable() = 0;
    virtual DispatchResponse disable() = 0;
};

// ------------- Frontend interface.

class CORE_EXPORT Frontend {
public:
    explicit Frontend(FrontendChannel* frontend_channel)
        : frontend_channel_(frontend_channel)
    {
    }
    void ruleSetUpdated(std::unique_ptr<protocol::Preload::RuleSet> ruleSet);
    void ruleSetRemoved(const String& id);
    void preloadEnabledStateUpdated(bool disabledByPreference, bool disabledByDataSaver, bool disabledByBatterySaver,
        bool disabledByHoldbackPrefetchSpeculationRules, bool disabledByHoldbackPrerenderSpeculationRules);
    void prefetchStatusUpdated(std::unique_ptr<protocol::Preload::PreloadingAttemptKey> key, const String& initiatingFrameId, const String& prefetchUrl,
        const String& status, const String& prefetchStatus, const String& requestId);
    void prerenderStatusUpdated(std::unique_ptr<protocol::Preload::PreloadingAttemptKey> key, const String& status,
        Maybe<String> prerenderStatus = Maybe<String>(), Maybe<String> disallowedMojoInterface = Maybe<String>(),
        Maybe<protocol::Array<protocol::Preload::PrerenderMismatchedHeaders>> mismatchedHeaders
        = Maybe<protocol::Array<protocol::Preload::PrerenderMismatchedHeaders>>());
    void preloadingAttemptSourcesUpdated(
        const String& loaderId, std::unique_ptr<protocol::Array<protocol::Preload::PreloadingAttemptSource>> preloadingAttemptSources);

    void flush();
    void sendRawNotification(std::unique_ptr<Serializable>);

private:
    FrontendChannel* frontend_channel_;
};

// ------------- Dispatcher.

class CORE_EXPORT Dispatcher {
public:
    static void wire(UberDispatcher*, Backend*);

private:
    Dispatcher()
    {
    }
};

// ------------- Metainfo.

class CORE_EXPORT Metainfo {
public:
    using BackendClass = Backend;
    using FrontendClass = Frontend;
    using DispatcherClass = Dispatcher;
    static const char domainName[];
    static const char commandPrefix[];
    static const char version[];
};

} // namespace Preload
} // namespace blink
} // namespace protocol

#endif // !defined(blink_protocol_Preload_h)
