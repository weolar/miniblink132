// This file is generated by TypeBuilder_h.template.

// Copyright 2016 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef blink_protocol_Storage_h
#define blink_protocol_Storage_h

#include "third_party/blink/renderer/core/core_export.h"
#include "third_party/blink/renderer/core/inspector/protocol/protocol.h"
// For each imported domain we generate a ValueConversions struct instead of a full domain definition
// and include Domain::API version from there.
#include "third_party/blink/renderer/core/inspector/protocol/network.h"

namespace blink {
namespace protocol {
namespace Storage {
using SerializedStorageKey = String;
using StorageType = String;
class UsageForType;
class TrustTokens;
using InterestGroupAuctionId = String;
using InterestGroupAccessType = String;
using InterestGroupAuctionEventType = String;
using InterestGroupAuctionFetchType = String;
using SharedStorageAccessType = String;
class SharedStorageEntry;
class SharedStorageMetadata;
class SharedStorageReportingMetadata;
class SharedStorageUrlWithMetadata;
class SharedStorageAccessParams;
using StorageBucketsDurability = String;
class StorageBucket;
class StorageBucketInfo;
using AttributionReportingSourceType = String;
using UnsignedInt64AsBase10 = String;
using UnsignedInt128AsBase16 = String;
using SignedInt64AsBase10 = String;
class AttributionReportingFilterDataEntry;
class AttributionReportingFilterConfig;
class AttributionReportingFilterPair;
class AttributionReportingAggregationKeysEntry;
class AttributionReportingEventReportWindows;
class AttributionReportingTriggerSpec;
using AttributionReportingTriggerDataMatching = String;
class AttributionReportingAggregatableDebugReportingData;
class AttributionReportingAggregatableDebugReportingConfig;
class AttributionScopesData;
class AttributionReportingSourceRegistration;
using AttributionReportingSourceRegistrationResult = String;
using AttributionReportingSourceRegistrationTimeConfig = String;
class AttributionReportingAggregatableValueDictEntry;
class AttributionReportingAggregatableValueEntry;
class AttributionReportingEventTriggerData;
class AttributionReportingAggregatableTriggerData;
class AttributionReportingAggregatableDedupKey;
class AttributionReportingTriggerRegistration;
using AttributionReportingEventLevelResult = String;
using AttributionReportingAggregatableResult = String;
class RelatedWebsiteSet;

// ------------- Forward and enum declarations.

namespace StorageTypeEnum {
CORE_EXPORT extern const char Appcache[];
CORE_EXPORT extern const char Cookies[];
CORE_EXPORT extern const char File_systems[];
CORE_EXPORT extern const char Indexeddb[];
CORE_EXPORT extern const char Local_storage[];
CORE_EXPORT extern const char Shader_cache[];
CORE_EXPORT extern const char Websql[];
CORE_EXPORT extern const char Service_workers[];
CORE_EXPORT extern const char Cache_storage[];
CORE_EXPORT extern const char Interest_groups[];
CORE_EXPORT extern const char Shared_storage[];
CORE_EXPORT extern const char Storage_buckets[];
CORE_EXPORT extern const char All[];
CORE_EXPORT extern const char Other[];
} // namespace StorageTypeEnum

namespace InterestGroupAccessTypeEnum {
CORE_EXPORT extern const char Join[];
CORE_EXPORT extern const char Leave[];
CORE_EXPORT extern const char Update[];
CORE_EXPORT extern const char Loaded[];
CORE_EXPORT extern const char Bid[];
CORE_EXPORT extern const char Win[];
CORE_EXPORT extern const char AdditionalBid[];
CORE_EXPORT extern const char AdditionalBidWin[];
CORE_EXPORT extern const char TopLevelBid[];
CORE_EXPORT extern const char TopLevelAdditionalBid[];
CORE_EXPORT extern const char Clear[];
} // namespace InterestGroupAccessTypeEnum

namespace InterestGroupAuctionEventTypeEnum {
CORE_EXPORT extern const char Started[];
CORE_EXPORT extern const char ConfigResolved[];
} // namespace InterestGroupAuctionEventTypeEnum

namespace InterestGroupAuctionFetchTypeEnum {
CORE_EXPORT extern const char BidderJs[];
CORE_EXPORT extern const char BidderWasm[];
CORE_EXPORT extern const char SellerJs[];
CORE_EXPORT extern const char BidderTrustedSignals[];
CORE_EXPORT extern const char SellerTrustedSignals[];
} // namespace InterestGroupAuctionFetchTypeEnum

namespace SharedStorageAccessTypeEnum {
CORE_EXPORT extern const char DocumentAddModule[];
CORE_EXPORT extern const char DocumentSelectURL[];
CORE_EXPORT extern const char DocumentRun[];
CORE_EXPORT extern const char DocumentSet[];
CORE_EXPORT extern const char DocumentAppend[];
CORE_EXPORT extern const char DocumentDelete[];
CORE_EXPORT extern const char DocumentClear[];
CORE_EXPORT extern const char DocumentGet[];
CORE_EXPORT extern const char WorkletSet[];
CORE_EXPORT extern const char WorkletAppend[];
CORE_EXPORT extern const char WorkletDelete[];
CORE_EXPORT extern const char WorkletClear[];
CORE_EXPORT extern const char WorkletGet[];
CORE_EXPORT extern const char WorkletKeys[];
CORE_EXPORT extern const char WorkletEntries[];
CORE_EXPORT extern const char WorkletLength[];
CORE_EXPORT extern const char WorkletRemainingBudget[];
CORE_EXPORT extern const char HeaderSet[];
CORE_EXPORT extern const char HeaderAppend[];
CORE_EXPORT extern const char HeaderDelete[];
CORE_EXPORT extern const char HeaderClear[];
} // namespace SharedStorageAccessTypeEnum

namespace StorageBucketsDurabilityEnum {
CORE_EXPORT extern const char Relaxed[];
CORE_EXPORT extern const char Strict[];
} // namespace StorageBucketsDurabilityEnum

namespace AttributionReportingSourceTypeEnum {
CORE_EXPORT extern const char Navigation[];
CORE_EXPORT extern const char Event[];
} // namespace AttributionReportingSourceTypeEnum

namespace AttributionReportingTriggerDataMatchingEnum {
CORE_EXPORT extern const char Exact[];
CORE_EXPORT extern const char Modulus[];
} // namespace AttributionReportingTriggerDataMatchingEnum

namespace AttributionReportingSourceRegistrationResultEnum {
CORE_EXPORT extern const char Success[];
CORE_EXPORT extern const char InternalError[];
CORE_EXPORT extern const char InsufficientSourceCapacity[];
CORE_EXPORT extern const char InsufficientUniqueDestinationCapacity[];
CORE_EXPORT extern const char ExcessiveReportingOrigins[];
CORE_EXPORT extern const char ProhibitedByBrowserPolicy[];
CORE_EXPORT extern const char SuccessNoised[];
CORE_EXPORT extern const char DestinationReportingLimitReached[];
CORE_EXPORT extern const char DestinationGlobalLimitReached[];
CORE_EXPORT extern const char DestinationBothLimitsReached[];
CORE_EXPORT extern const char ReportingOriginsPerSiteLimitReached[];
CORE_EXPORT extern const char ExceedsMaxChannelCapacity[];
CORE_EXPORT extern const char ExceedsMaxScopesChannelCapacity[];
CORE_EXPORT extern const char ExceedsMaxTriggerStateCardinality[];
CORE_EXPORT extern const char ExceedsMaxEventStatesLimit[];
CORE_EXPORT extern const char DestinationPerDayReportingLimitReached[];
} // namespace AttributionReportingSourceRegistrationResultEnum

namespace AttributionReportingSourceRegistrationTimeConfigEnum {
CORE_EXPORT extern const char Include[];
CORE_EXPORT extern const char Exclude[];
} // namespace AttributionReportingSourceRegistrationTimeConfigEnum

namespace AttributionReportingEventLevelResultEnum {
CORE_EXPORT extern const char Success[];
CORE_EXPORT extern const char SuccessDroppedLowerPriority[];
CORE_EXPORT extern const char InternalError[];
CORE_EXPORT extern const char NoCapacityForAttributionDestination[];
CORE_EXPORT extern const char NoMatchingSources[];
CORE_EXPORT extern const char Deduplicated[];
CORE_EXPORT extern const char ExcessiveAttributions[];
CORE_EXPORT extern const char PriorityTooLow[];
CORE_EXPORT extern const char NeverAttributedSource[];
CORE_EXPORT extern const char ExcessiveReportingOrigins[];
CORE_EXPORT extern const char NoMatchingSourceFilterData[];
CORE_EXPORT extern const char ProhibitedByBrowserPolicy[];
CORE_EXPORT extern const char NoMatchingConfigurations[];
CORE_EXPORT extern const char ExcessiveReports[];
CORE_EXPORT extern const char FalselyAttributedSource[];
CORE_EXPORT extern const char ReportWindowPassed[];
CORE_EXPORT extern const char NotRegistered[];
CORE_EXPORT extern const char ReportWindowNotStarted[];
CORE_EXPORT extern const char NoMatchingTriggerData[];
} // namespace AttributionReportingEventLevelResultEnum

namespace AttributionReportingAggregatableResultEnum {
CORE_EXPORT extern const char Success[];
CORE_EXPORT extern const char InternalError[];
CORE_EXPORT extern const char NoCapacityForAttributionDestination[];
CORE_EXPORT extern const char NoMatchingSources[];
CORE_EXPORT extern const char ExcessiveAttributions[];
CORE_EXPORT extern const char ExcessiveReportingOrigins[];
CORE_EXPORT extern const char NoHistograms[];
CORE_EXPORT extern const char InsufficientBudget[];
CORE_EXPORT extern const char InsufficientNamedBudget[];
CORE_EXPORT extern const char NoMatchingSourceFilterData[];
CORE_EXPORT extern const char NotRegistered[];
CORE_EXPORT extern const char ProhibitedByBrowserPolicy[];
CORE_EXPORT extern const char Deduplicated[];
CORE_EXPORT extern const char ReportWindowPassed[];
CORE_EXPORT extern const char ExcessiveReports[];
} // namespace AttributionReportingAggregatableResultEnum

// ------------- Type and builder declarations.

class CORE_EXPORT UsageForType : public ::crdtp::ProtocolObject<UsageForType> {
public:
    ~UsageForType() override
    {
    }

    String getStorageType()
    {
        return m_storageType;
    }
    void setStorageType(const String& value)
    {
        m_storageType = value;
    }

    double getUsage()
    {
        return m_usage;
    }
    void setUsage(double value)
    {
        m_usage = value;
    }

    template <int STATE> class UsageForTypeBuilder {
    public:
        enum { NoFieldsSet = 0, StorageTypeSet = 1 << 1, UsageSet = 1 << 2, AllFieldsSet = (StorageTypeSet | UsageSet | 0) };

        UsageForTypeBuilder<STATE | StorageTypeSet>& setStorageType(const String& value)
        {
            static_assert(!(STATE & StorageTypeSet), "property storageType should not be set yet");
            m_result->setStorageType(value);
            return castState<StorageTypeSet>();
        }

        UsageForTypeBuilder<STATE | UsageSet>& setUsage(double value)
        {
            static_assert(!(STATE & UsageSet), "property usage should not be set yet");
            m_result->setUsage(value);
            return castState<UsageSet>();
        }

        std::unique_ptr<UsageForType> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class UsageForType;
        UsageForTypeBuilder()
            : m_result(new UsageForType())
        {
        }

        template <int STEP> UsageForTypeBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<UsageForTypeBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Storage::UsageForType> m_result;
    };

    static UsageForTypeBuilder<0> create()
    {
        return UsageForTypeBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    UsageForType()
    {
        m_usage = 0;
    }

    String m_storageType;
    double m_usage;
};

class CORE_EXPORT TrustTokens : public ::crdtp::ProtocolObject<TrustTokens> {
public:
    ~TrustTokens() override
    {
    }

    String getIssuerOrigin()
    {
        return m_issuerOrigin;
    }
    void setIssuerOrigin(const String& value)
    {
        m_issuerOrigin = value;
    }

    double getCount()
    {
        return m_count;
    }
    void setCount(double value)
    {
        m_count = value;
    }

    template <int STATE> class TrustTokensBuilder {
    public:
        enum { NoFieldsSet = 0, IssuerOriginSet = 1 << 1, CountSet = 1 << 2, AllFieldsSet = (IssuerOriginSet | CountSet | 0) };

        TrustTokensBuilder<STATE | IssuerOriginSet>& setIssuerOrigin(const String& value)
        {
            static_assert(!(STATE & IssuerOriginSet), "property issuerOrigin should not be set yet");
            m_result->setIssuerOrigin(value);
            return castState<IssuerOriginSet>();
        }

        TrustTokensBuilder<STATE | CountSet>& setCount(double value)
        {
            static_assert(!(STATE & CountSet), "property count should not be set yet");
            m_result->setCount(value);
            return castState<CountSet>();
        }

        std::unique_ptr<TrustTokens> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class TrustTokens;
        TrustTokensBuilder()
            : m_result(new TrustTokens())
        {
        }

        template <int STEP> TrustTokensBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<TrustTokensBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Storage::TrustTokens> m_result;
    };

    static TrustTokensBuilder<0> create()
    {
        return TrustTokensBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    TrustTokens()
    {
        m_count = 0;
    }

    String m_issuerOrigin;
    double m_count;
};

class CORE_EXPORT SharedStorageEntry : public ::crdtp::ProtocolObject<SharedStorageEntry> {
public:
    ~SharedStorageEntry() override
    {
    }

    String getKey()
    {
        return m_key;
    }
    void setKey(const String& value)
    {
        m_key = value;
    }

    String getValue()
    {
        return m_value;
    }
    void setValue(const String& value)
    {
        m_value = value;
    }

    template <int STATE> class SharedStorageEntryBuilder {
    public:
        enum { NoFieldsSet = 0, KeySet = 1 << 1, ValueSet = 1 << 2, AllFieldsSet = (KeySet | ValueSet | 0) };

        SharedStorageEntryBuilder<STATE | KeySet>& setKey(const String& value)
        {
            static_assert(!(STATE & KeySet), "property key should not be set yet");
            m_result->setKey(value);
            return castState<KeySet>();
        }

        SharedStorageEntryBuilder<STATE | ValueSet>& setValue(const String& value)
        {
            static_assert(!(STATE & ValueSet), "property value should not be set yet");
            m_result->setValue(value);
            return castState<ValueSet>();
        }

        std::unique_ptr<SharedStorageEntry> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class SharedStorageEntry;
        SharedStorageEntryBuilder()
            : m_result(new SharedStorageEntry())
        {
        }

        template <int STEP> SharedStorageEntryBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<SharedStorageEntryBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Storage::SharedStorageEntry> m_result;
    };

    static SharedStorageEntryBuilder<0> create()
    {
        return SharedStorageEntryBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    SharedStorageEntry()
    {
    }

    String m_key;
    String m_value;
};

class CORE_EXPORT SharedStorageMetadata : public ::crdtp::ProtocolObject<SharedStorageMetadata> {
public:
    ~SharedStorageMetadata() override
    {
    }

    double getCreationTime()
    {
        return m_creationTime;
    }
    void setCreationTime(double value)
    {
        m_creationTime = value;
    }

    int getLength()
    {
        return m_length;
    }
    void setLength(int value)
    {
        m_length = value;
    }

    double getRemainingBudget()
    {
        return m_remainingBudget;
    }
    void setRemainingBudget(double value)
    {
        m_remainingBudget = value;
    }

    int getBytesUsed()
    {
        return m_bytesUsed;
    }
    void setBytesUsed(int value)
    {
        m_bytesUsed = value;
    }

    template <int STATE> class SharedStorageMetadataBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            CreationTimeSet = 1 << 1,
            LengthSet = 1 << 2,
            RemainingBudgetSet = 1 << 3,
            BytesUsedSet = 1 << 4,
            AllFieldsSet = (CreationTimeSet | LengthSet | RemainingBudgetSet | BytesUsedSet | 0)
        };

        SharedStorageMetadataBuilder<STATE | CreationTimeSet>& setCreationTime(double value)
        {
            static_assert(!(STATE & CreationTimeSet), "property creationTime should not be set yet");
            m_result->setCreationTime(value);
            return castState<CreationTimeSet>();
        }

        SharedStorageMetadataBuilder<STATE | LengthSet>& setLength(int value)
        {
            static_assert(!(STATE & LengthSet), "property length should not be set yet");
            m_result->setLength(value);
            return castState<LengthSet>();
        }

        SharedStorageMetadataBuilder<STATE | RemainingBudgetSet>& setRemainingBudget(double value)
        {
            static_assert(!(STATE & RemainingBudgetSet), "property remainingBudget should not be set yet");
            m_result->setRemainingBudget(value);
            return castState<RemainingBudgetSet>();
        }

        SharedStorageMetadataBuilder<STATE | BytesUsedSet>& setBytesUsed(int value)
        {
            static_assert(!(STATE & BytesUsedSet), "property bytesUsed should not be set yet");
            m_result->setBytesUsed(value);
            return castState<BytesUsedSet>();
        }

        std::unique_ptr<SharedStorageMetadata> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class SharedStorageMetadata;
        SharedStorageMetadataBuilder()
            : m_result(new SharedStorageMetadata())
        {
        }

        template <int STEP> SharedStorageMetadataBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<SharedStorageMetadataBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Storage::SharedStorageMetadata> m_result;
    };

    static SharedStorageMetadataBuilder<0> create()
    {
        return SharedStorageMetadataBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    SharedStorageMetadata()
    {
        m_creationTime = 0;
        m_length = 0;
        m_remainingBudget = 0;
        m_bytesUsed = 0;
    }

    double m_creationTime;
    int m_length;
    double m_remainingBudget;
    int m_bytesUsed;
};

class CORE_EXPORT SharedStorageReportingMetadata : public ::crdtp::ProtocolObject<SharedStorageReportingMetadata> {
public:
    ~SharedStorageReportingMetadata() override
    {
    }

    String getEventType()
    {
        return m_eventType;
    }
    void setEventType(const String& value)
    {
        m_eventType = value;
    }

    String getReportingUrl()
    {
        return m_reportingUrl;
    }
    void setReportingUrl(const String& value)
    {
        m_reportingUrl = value;
    }

    template <int STATE> class SharedStorageReportingMetadataBuilder {
    public:
        enum { NoFieldsSet = 0, EventTypeSet = 1 << 1, ReportingUrlSet = 1 << 2, AllFieldsSet = (EventTypeSet | ReportingUrlSet | 0) };

        SharedStorageReportingMetadataBuilder<STATE | EventTypeSet>& setEventType(const String& value)
        {
            static_assert(!(STATE & EventTypeSet), "property eventType should not be set yet");
            m_result->setEventType(value);
            return castState<EventTypeSet>();
        }

        SharedStorageReportingMetadataBuilder<STATE | ReportingUrlSet>& setReportingUrl(const String& value)
        {
            static_assert(!(STATE & ReportingUrlSet), "property reportingUrl should not be set yet");
            m_result->setReportingUrl(value);
            return castState<ReportingUrlSet>();
        }

        std::unique_ptr<SharedStorageReportingMetadata> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class SharedStorageReportingMetadata;
        SharedStorageReportingMetadataBuilder()
            : m_result(new SharedStorageReportingMetadata())
        {
        }

        template <int STEP> SharedStorageReportingMetadataBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<SharedStorageReportingMetadataBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Storage::SharedStorageReportingMetadata> m_result;
    };

    static SharedStorageReportingMetadataBuilder<0> create()
    {
        return SharedStorageReportingMetadataBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    SharedStorageReportingMetadata()
    {
    }

    String m_eventType;
    String m_reportingUrl;
};

class CORE_EXPORT SharedStorageUrlWithMetadata : public ::crdtp::ProtocolObject<SharedStorageUrlWithMetadata> {
public:
    ~SharedStorageUrlWithMetadata() override
    {
    }

    String getUrl()
    {
        return m_url;
    }
    void setUrl(const String& value)
    {
        m_url = value;
    }

    protocol::Array<protocol::Storage::SharedStorageReportingMetadata>* getReportingMetadata()
    {
        return m_reportingMetadata.get();
    }
    void setReportingMetadata(std::unique_ptr<protocol::Array<protocol::Storage::SharedStorageReportingMetadata>> value)
    {
        m_reportingMetadata = std::move(value);
    }

    template <int STATE> class SharedStorageUrlWithMetadataBuilder {
    public:
        enum { NoFieldsSet = 0, UrlSet = 1 << 1, ReportingMetadataSet = 1 << 2, AllFieldsSet = (UrlSet | ReportingMetadataSet | 0) };

        SharedStorageUrlWithMetadataBuilder<STATE | UrlSet>& setUrl(const String& value)
        {
            static_assert(!(STATE & UrlSet), "property url should not be set yet");
            m_result->setUrl(value);
            return castState<UrlSet>();
        }

        SharedStorageUrlWithMetadataBuilder<STATE | ReportingMetadataSet>& setReportingMetadata(
            std::unique_ptr<protocol::Array<protocol::Storage::SharedStorageReportingMetadata>> value)
        {
            static_assert(!(STATE & ReportingMetadataSet), "property reportingMetadata should not be set yet");
            m_result->setReportingMetadata(std::move(value));
            return castState<ReportingMetadataSet>();
        }

        std::unique_ptr<SharedStorageUrlWithMetadata> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class SharedStorageUrlWithMetadata;
        SharedStorageUrlWithMetadataBuilder()
            : m_result(new SharedStorageUrlWithMetadata())
        {
        }

        template <int STEP> SharedStorageUrlWithMetadataBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<SharedStorageUrlWithMetadataBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Storage::SharedStorageUrlWithMetadata> m_result;
    };

    static SharedStorageUrlWithMetadataBuilder<0> create()
    {
        return SharedStorageUrlWithMetadataBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    SharedStorageUrlWithMetadata()
    {
    }

    String m_url;
    std::unique_ptr<protocol::Array<protocol::Storage::SharedStorageReportingMetadata>> m_reportingMetadata;
};

class CORE_EXPORT SharedStorageAccessParams : public ::crdtp::ProtocolObject<SharedStorageAccessParams> {
public:
    ~SharedStorageAccessParams() override
    {
    }

    bool hasScriptSourceUrl()
    {
        return m_scriptSourceUrl.has_value();
    }
    String getScriptSourceUrl(const String& defaultValue) const
    {
        return m_scriptSourceUrl.value_or(defaultValue);
    }
    void setScriptSourceUrl(const String& value)
    {
        m_scriptSourceUrl = value;
    }

    bool hasOperationName()
    {
        return m_operationName.has_value();
    }
    String getOperationName(const String& defaultValue) const
    {
        return m_operationName.value_or(defaultValue);
    }
    void setOperationName(const String& value)
    {
        m_operationName = value;
    }

    bool hasSerializedData()
    {
        return m_serializedData.has_value();
    }
    String getSerializedData(const String& defaultValue) const
    {
        return m_serializedData.value_or(defaultValue);
    }
    void setSerializedData(const String& value)
    {
        m_serializedData = value;
    }

    bool hasUrlsWithMetadata()
    {
        return m_urlsWithMetadata.has_value();
    }
    protocol::Array<protocol::Storage::SharedStorageUrlWithMetadata>* getUrlsWithMetadata(
        protocol::Array<protocol::Storage::SharedStorageUrlWithMetadata>* defaultValue)
    {
        return m_urlsWithMetadata.has_value() ? &m_urlsWithMetadata.value() : defaultValue;
    }
    void setUrlsWithMetadata(std::unique_ptr<protocol::Array<protocol::Storage::SharedStorageUrlWithMetadata>> value)
    {
        m_urlsWithMetadata = std::move(value);
    }

    bool hasKey()
    {
        return m_key.has_value();
    }
    String getKey(const String& defaultValue) const
    {
        return m_key.value_or(defaultValue);
    }
    void setKey(const String& value)
    {
        m_key = value;
    }

    bool hasValue()
    {
        return m_value.has_value();
    }
    String getValue(const String& defaultValue) const
    {
        return m_value.value_or(defaultValue);
    }
    void setValue(const String& value)
    {
        m_value = value;
    }

    bool hasIgnoreIfPresent()
    {
        return m_ignoreIfPresent.has_value();
    }
    bool getIgnoreIfPresent(bool defaultValue) const
    {
        return m_ignoreIfPresent.value_or(defaultValue);
    }
    void setIgnoreIfPresent(bool value)
    {
        m_ignoreIfPresent = value;
    }

    template <int STATE> class SharedStorageAccessParamsBuilder {
    public:
        enum { NoFieldsSet = 0, AllFieldsSet = (0) };

        SharedStorageAccessParamsBuilder<STATE>& setScriptSourceUrl(const String& value)
        {
            m_result->setScriptSourceUrl(value);
            return *this;
        }

        SharedStorageAccessParamsBuilder<STATE>& setOperationName(const String& value)
        {
            m_result->setOperationName(value);
            return *this;
        }

        SharedStorageAccessParamsBuilder<STATE>& setSerializedData(const String& value)
        {
            m_result->setSerializedData(value);
            return *this;
        }

        SharedStorageAccessParamsBuilder<STATE>& setUrlsWithMetadata(std::unique_ptr<protocol::Array<protocol::Storage::SharedStorageUrlWithMetadata>> value)
        {
            m_result->setUrlsWithMetadata(std::move(value));
            return *this;
        }

        SharedStorageAccessParamsBuilder<STATE>& setKey(const String& value)
        {
            m_result->setKey(value);
            return *this;
        }

        SharedStorageAccessParamsBuilder<STATE>& setValue(const String& value)
        {
            m_result->setValue(value);
            return *this;
        }

        SharedStorageAccessParamsBuilder<STATE>& setIgnoreIfPresent(bool value)
        {
            m_result->setIgnoreIfPresent(value);
            return *this;
        }

        std::unique_ptr<SharedStorageAccessParams> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class SharedStorageAccessParams;
        SharedStorageAccessParamsBuilder()
            : m_result(new SharedStorageAccessParams())
        {
        }

        template <int STEP> SharedStorageAccessParamsBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<SharedStorageAccessParamsBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Storage::SharedStorageAccessParams> m_result;
    };

    static SharedStorageAccessParamsBuilder<0> create()
    {
        return SharedStorageAccessParamsBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    SharedStorageAccessParams()
    {
    }

    Maybe<String> m_scriptSourceUrl;
    Maybe<String> m_operationName;
    Maybe<String> m_serializedData;
    Maybe<protocol::Array<protocol::Storage::SharedStorageUrlWithMetadata>> m_urlsWithMetadata;
    Maybe<String> m_key;
    Maybe<String> m_value;
    Maybe<bool> m_ignoreIfPresent;
};

class CORE_EXPORT StorageBucket : public ::crdtp::ProtocolObject<StorageBucket> {
public:
    ~StorageBucket() override
    {
    }

    String getStorageKey()
    {
        return m_storageKey;
    }
    void setStorageKey(const String& value)
    {
        m_storageKey = value;
    }

    bool hasName()
    {
        return m_name.has_value();
    }
    String getName(const String& defaultValue) const
    {
        return m_name.value_or(defaultValue);
    }
    void setName(const String& value)
    {
        m_name = value;
    }

    template <int STATE> class StorageBucketBuilder {
    public:
        enum { NoFieldsSet = 0, StorageKeySet = 1 << 1, AllFieldsSet = (StorageKeySet | 0) };

        StorageBucketBuilder<STATE | StorageKeySet>& setStorageKey(const String& value)
        {
            static_assert(!(STATE & StorageKeySet), "property storageKey should not be set yet");
            m_result->setStorageKey(value);
            return castState<StorageKeySet>();
        }

        StorageBucketBuilder<STATE>& setName(const String& value)
        {
            m_result->setName(value);
            return *this;
        }

        std::unique_ptr<StorageBucket> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class StorageBucket;
        StorageBucketBuilder()
            : m_result(new StorageBucket())
        {
        }

        template <int STEP> StorageBucketBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<StorageBucketBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Storage::StorageBucket> m_result;
    };

    static StorageBucketBuilder<0> create()
    {
        return StorageBucketBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    StorageBucket()
    {
    }

    String m_storageKey;
    Maybe<String> m_name;
};

class CORE_EXPORT StorageBucketInfo : public ::crdtp::ProtocolObject<StorageBucketInfo> {
public:
    ~StorageBucketInfo() override
    {
    }

    protocol::Storage::StorageBucket* getBucket()
    {
        return m_bucket.get();
    }
    void setBucket(std::unique_ptr<protocol::Storage::StorageBucket> value)
    {
        m_bucket = std::move(value);
    }

    String getId()
    {
        return m_id;
    }
    void setId(const String& value)
    {
        m_id = value;
    }

    double getExpiration()
    {
        return m_expiration;
    }
    void setExpiration(double value)
    {
        m_expiration = value;
    }

    double getQuota()
    {
        return m_quota;
    }
    void setQuota(double value)
    {
        m_quota = value;
    }

    bool getPersistent()
    {
        return m_persistent;
    }
    void setPersistent(bool value)
    {
        m_persistent = value;
    }

    String getDurability()
    {
        return m_durability;
    }
    void setDurability(const String& value)
    {
        m_durability = value;
    }

    template <int STATE> class StorageBucketInfoBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            BucketSet = 1 << 1,
            IdSet = 1 << 2,
            ExpirationSet = 1 << 3,
            QuotaSet = 1 << 4,
            PersistentSet = 1 << 5,
            DurabilitySet = 1 << 6,
            AllFieldsSet = (BucketSet | IdSet | ExpirationSet | QuotaSet | PersistentSet | DurabilitySet | 0)
        };

        StorageBucketInfoBuilder<STATE | BucketSet>& setBucket(std::unique_ptr<protocol::Storage::StorageBucket> value)
        {
            static_assert(!(STATE & BucketSet), "property bucket should not be set yet");
            m_result->setBucket(std::move(value));
            return castState<BucketSet>();
        }

        StorageBucketInfoBuilder<STATE | IdSet>& setId(const String& value)
        {
            static_assert(!(STATE & IdSet), "property id should not be set yet");
            m_result->setId(value);
            return castState<IdSet>();
        }

        StorageBucketInfoBuilder<STATE | ExpirationSet>& setExpiration(double value)
        {
            static_assert(!(STATE & ExpirationSet), "property expiration should not be set yet");
            m_result->setExpiration(value);
            return castState<ExpirationSet>();
        }

        StorageBucketInfoBuilder<STATE | QuotaSet>& setQuota(double value)
        {
            static_assert(!(STATE & QuotaSet), "property quota should not be set yet");
            m_result->setQuota(value);
            return castState<QuotaSet>();
        }

        StorageBucketInfoBuilder<STATE | PersistentSet>& setPersistent(bool value)
        {
            static_assert(!(STATE & PersistentSet), "property persistent should not be set yet");
            m_result->setPersistent(value);
            return castState<PersistentSet>();
        }

        StorageBucketInfoBuilder<STATE | DurabilitySet>& setDurability(const String& value)
        {
            static_assert(!(STATE & DurabilitySet), "property durability should not be set yet");
            m_result->setDurability(value);
            return castState<DurabilitySet>();
        }

        std::unique_ptr<StorageBucketInfo> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class StorageBucketInfo;
        StorageBucketInfoBuilder()
            : m_result(new StorageBucketInfo())
        {
        }

        template <int STEP> StorageBucketInfoBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<StorageBucketInfoBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Storage::StorageBucketInfo> m_result;
    };

    static StorageBucketInfoBuilder<0> create()
    {
        return StorageBucketInfoBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    StorageBucketInfo()
    {
        m_expiration = 0;
        m_quota = 0;
        m_persistent = false;
    }

    std::unique_ptr<protocol::Storage::StorageBucket> m_bucket;
    String m_id;
    double m_expiration;
    double m_quota;
    bool m_persistent;
    String m_durability;
};

class CORE_EXPORT AttributionReportingFilterDataEntry : public ::crdtp::ProtocolObject<AttributionReportingFilterDataEntry> {
public:
    ~AttributionReportingFilterDataEntry() override
    {
    }

    String getKey()
    {
        return m_key;
    }
    void setKey(const String& value)
    {
        m_key = value;
    }

    protocol::Array<String>* getValues()
    {
        return m_values.get();
    }
    void setValues(std::unique_ptr<protocol::Array<String>> value)
    {
        m_values = std::move(value);
    }

    template <int STATE> class AttributionReportingFilterDataEntryBuilder {
    public:
        enum { NoFieldsSet = 0, KeySet = 1 << 1, ValuesSet = 1 << 2, AllFieldsSet = (KeySet | ValuesSet | 0) };

        AttributionReportingFilterDataEntryBuilder<STATE | KeySet>& setKey(const String& value)
        {
            static_assert(!(STATE & KeySet), "property key should not be set yet");
            m_result->setKey(value);
            return castState<KeySet>();
        }

        AttributionReportingFilterDataEntryBuilder<STATE | ValuesSet>& setValues(std::unique_ptr<protocol::Array<String>> value)
        {
            static_assert(!(STATE & ValuesSet), "property values should not be set yet");
            m_result->setValues(std::move(value));
            return castState<ValuesSet>();
        }

        std::unique_ptr<AttributionReportingFilterDataEntry> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class AttributionReportingFilterDataEntry;
        AttributionReportingFilterDataEntryBuilder()
            : m_result(new AttributionReportingFilterDataEntry())
        {
        }

        template <int STEP> AttributionReportingFilterDataEntryBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<AttributionReportingFilterDataEntryBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Storage::AttributionReportingFilterDataEntry> m_result;
    };

    static AttributionReportingFilterDataEntryBuilder<0> create()
    {
        return AttributionReportingFilterDataEntryBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    AttributionReportingFilterDataEntry()
    {
    }

    String m_key;
    std::unique_ptr<protocol::Array<String>> m_values;
};

class CORE_EXPORT AttributionReportingFilterConfig : public ::crdtp::ProtocolObject<AttributionReportingFilterConfig> {
public:
    ~AttributionReportingFilterConfig() override
    {
    }

    protocol::Array<protocol::Storage::AttributionReportingFilterDataEntry>* getFilterValues()
    {
        return m_filterValues.get();
    }
    void setFilterValues(std::unique_ptr<protocol::Array<protocol::Storage::AttributionReportingFilterDataEntry>> value)
    {
        m_filterValues = std::move(value);
    }

    bool hasLookbackWindow()
    {
        return m_lookbackWindow.has_value();
    }
    int getLookbackWindow(int defaultValue) const
    {
        return m_lookbackWindow.value_or(defaultValue);
    }
    void setLookbackWindow(int value)
    {
        m_lookbackWindow = value;
    }

    template <int STATE> class AttributionReportingFilterConfigBuilder {
    public:
        enum { NoFieldsSet = 0, FilterValuesSet = 1 << 1, AllFieldsSet = (FilterValuesSet | 0) };

        AttributionReportingFilterConfigBuilder<STATE | FilterValuesSet>& setFilterValues(
            std::unique_ptr<protocol::Array<protocol::Storage::AttributionReportingFilterDataEntry>> value)
        {
            static_assert(!(STATE & FilterValuesSet), "property filterValues should not be set yet");
            m_result->setFilterValues(std::move(value));
            return castState<FilterValuesSet>();
        }

        AttributionReportingFilterConfigBuilder<STATE>& setLookbackWindow(int value)
        {
            m_result->setLookbackWindow(value);
            return *this;
        }

        std::unique_ptr<AttributionReportingFilterConfig> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class AttributionReportingFilterConfig;
        AttributionReportingFilterConfigBuilder()
            : m_result(new AttributionReportingFilterConfig())
        {
        }

        template <int STEP> AttributionReportingFilterConfigBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<AttributionReportingFilterConfigBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Storage::AttributionReportingFilterConfig> m_result;
    };

    static AttributionReportingFilterConfigBuilder<0> create()
    {
        return AttributionReportingFilterConfigBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    AttributionReportingFilterConfig()
    {
    }

    std::unique_ptr<protocol::Array<protocol::Storage::AttributionReportingFilterDataEntry>> m_filterValues;
    Maybe<int> m_lookbackWindow;
};

class CORE_EXPORT AttributionReportingFilterPair : public ::crdtp::ProtocolObject<AttributionReportingFilterPair> {
public:
    ~AttributionReportingFilterPair() override
    {
    }

    protocol::Array<protocol::Storage::AttributionReportingFilterConfig>* getFilters()
    {
        return m_filters.get();
    }
    void setFilters(std::unique_ptr<protocol::Array<protocol::Storage::AttributionReportingFilterConfig>> value)
    {
        m_filters = std::move(value);
    }

    protocol::Array<protocol::Storage::AttributionReportingFilterConfig>* getNotFilters()
    {
        return m_notFilters.get();
    }
    void setNotFilters(std::unique_ptr<protocol::Array<protocol::Storage::AttributionReportingFilterConfig>> value)
    {
        m_notFilters = std::move(value);
    }

    template <int STATE> class AttributionReportingFilterPairBuilder {
    public:
        enum { NoFieldsSet = 0, FiltersSet = 1 << 1, NotFiltersSet = 1 << 2, AllFieldsSet = (FiltersSet | NotFiltersSet | 0) };

        AttributionReportingFilterPairBuilder<STATE | FiltersSet>& setFilters(
            std::unique_ptr<protocol::Array<protocol::Storage::AttributionReportingFilterConfig>> value)
        {
            static_assert(!(STATE & FiltersSet), "property filters should not be set yet");
            m_result->setFilters(std::move(value));
            return castState<FiltersSet>();
        }

        AttributionReportingFilterPairBuilder<STATE | NotFiltersSet>& setNotFilters(
            std::unique_ptr<protocol::Array<protocol::Storage::AttributionReportingFilterConfig>> value)
        {
            static_assert(!(STATE & NotFiltersSet), "property notFilters should not be set yet");
            m_result->setNotFilters(std::move(value));
            return castState<NotFiltersSet>();
        }

        std::unique_ptr<AttributionReportingFilterPair> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class AttributionReportingFilterPair;
        AttributionReportingFilterPairBuilder()
            : m_result(new AttributionReportingFilterPair())
        {
        }

        template <int STEP> AttributionReportingFilterPairBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<AttributionReportingFilterPairBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Storage::AttributionReportingFilterPair> m_result;
    };

    static AttributionReportingFilterPairBuilder<0> create()
    {
        return AttributionReportingFilterPairBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    AttributionReportingFilterPair()
    {
    }

    std::unique_ptr<protocol::Array<protocol::Storage::AttributionReportingFilterConfig>> m_filters;
    std::unique_ptr<protocol::Array<protocol::Storage::AttributionReportingFilterConfig>> m_notFilters;
};

class CORE_EXPORT AttributionReportingAggregationKeysEntry : public ::crdtp::ProtocolObject<AttributionReportingAggregationKeysEntry> {
public:
    ~AttributionReportingAggregationKeysEntry() override
    {
    }

    String getKey()
    {
        return m_key;
    }
    void setKey(const String& value)
    {
        m_key = value;
    }

    String getValue()
    {
        return m_value;
    }
    void setValue(const String& value)
    {
        m_value = value;
    }

    template <int STATE> class AttributionReportingAggregationKeysEntryBuilder {
    public:
        enum { NoFieldsSet = 0, KeySet = 1 << 1, ValueSet = 1 << 2, AllFieldsSet = (KeySet | ValueSet | 0) };

        AttributionReportingAggregationKeysEntryBuilder<STATE | KeySet>& setKey(const String& value)
        {
            static_assert(!(STATE & KeySet), "property key should not be set yet");
            m_result->setKey(value);
            return castState<KeySet>();
        }

        AttributionReportingAggregationKeysEntryBuilder<STATE | ValueSet>& setValue(const String& value)
        {
            static_assert(!(STATE & ValueSet), "property value should not be set yet");
            m_result->setValue(value);
            return castState<ValueSet>();
        }

        std::unique_ptr<AttributionReportingAggregationKeysEntry> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class AttributionReportingAggregationKeysEntry;
        AttributionReportingAggregationKeysEntryBuilder()
            : m_result(new AttributionReportingAggregationKeysEntry())
        {
        }

        template <int STEP> AttributionReportingAggregationKeysEntryBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<AttributionReportingAggregationKeysEntryBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Storage::AttributionReportingAggregationKeysEntry> m_result;
    };

    static AttributionReportingAggregationKeysEntryBuilder<0> create()
    {
        return AttributionReportingAggregationKeysEntryBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    AttributionReportingAggregationKeysEntry()
    {
    }

    String m_key;
    String m_value;
};

class CORE_EXPORT AttributionReportingEventReportWindows : public ::crdtp::ProtocolObject<AttributionReportingEventReportWindows> {
public:
    ~AttributionReportingEventReportWindows() override
    {
    }

    int getStart()
    {
        return m_start;
    }
    void setStart(int value)
    {
        m_start = value;
    }

    protocol::Array<int>* getEnds()
    {
        return m_ends.get();
    }
    void setEnds(std::unique_ptr<protocol::Array<int>> value)
    {
        m_ends = std::move(value);
    }

    template <int STATE> class AttributionReportingEventReportWindowsBuilder {
    public:
        enum { NoFieldsSet = 0, StartSet = 1 << 1, EndsSet = 1 << 2, AllFieldsSet = (StartSet | EndsSet | 0) };

        AttributionReportingEventReportWindowsBuilder<STATE | StartSet>& setStart(int value)
        {
            static_assert(!(STATE & StartSet), "property start should not be set yet");
            m_result->setStart(value);
            return castState<StartSet>();
        }

        AttributionReportingEventReportWindowsBuilder<STATE | EndsSet>& setEnds(std::unique_ptr<protocol::Array<int>> value)
        {
            static_assert(!(STATE & EndsSet), "property ends should not be set yet");
            m_result->setEnds(std::move(value));
            return castState<EndsSet>();
        }

        std::unique_ptr<AttributionReportingEventReportWindows> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class AttributionReportingEventReportWindows;
        AttributionReportingEventReportWindowsBuilder()
            : m_result(new AttributionReportingEventReportWindows())
        {
        }

        template <int STEP> AttributionReportingEventReportWindowsBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<AttributionReportingEventReportWindowsBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Storage::AttributionReportingEventReportWindows> m_result;
    };

    static AttributionReportingEventReportWindowsBuilder<0> create()
    {
        return AttributionReportingEventReportWindowsBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    AttributionReportingEventReportWindows()
    {
        m_start = 0;
    }

    int m_start;
    std::unique_ptr<protocol::Array<int>> m_ends;
};

class CORE_EXPORT AttributionReportingTriggerSpec : public ::crdtp::ProtocolObject<AttributionReportingTriggerSpec> {
public:
    ~AttributionReportingTriggerSpec() override
    {
    }

    protocol::Array<double>* getTriggerData()
    {
        return m_triggerData.get();
    }
    void setTriggerData(std::unique_ptr<protocol::Array<double>> value)
    {
        m_triggerData = std::move(value);
    }

    protocol::Storage::AttributionReportingEventReportWindows* getEventReportWindows()
    {
        return m_eventReportWindows.get();
    }
    void setEventReportWindows(std::unique_ptr<protocol::Storage::AttributionReportingEventReportWindows> value)
    {
        m_eventReportWindows = std::move(value);
    }

    template <int STATE> class AttributionReportingTriggerSpecBuilder {
    public:
        enum { NoFieldsSet = 0, TriggerDataSet = 1 << 1, EventReportWindowsSet = 1 << 2, AllFieldsSet = (TriggerDataSet | EventReportWindowsSet | 0) };

        AttributionReportingTriggerSpecBuilder<STATE | TriggerDataSet>& setTriggerData(std::unique_ptr<protocol::Array<double>> value)
        {
            static_assert(!(STATE & TriggerDataSet), "property triggerData should not be set yet");
            m_result->setTriggerData(std::move(value));
            return castState<TriggerDataSet>();
        }

        AttributionReportingTriggerSpecBuilder<STATE | EventReportWindowsSet>& setEventReportWindows(
            std::unique_ptr<protocol::Storage::AttributionReportingEventReportWindows> value)
        {
            static_assert(!(STATE & EventReportWindowsSet), "property eventReportWindows should not be set yet");
            m_result->setEventReportWindows(std::move(value));
            return castState<EventReportWindowsSet>();
        }

        std::unique_ptr<AttributionReportingTriggerSpec> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class AttributionReportingTriggerSpec;
        AttributionReportingTriggerSpecBuilder()
            : m_result(new AttributionReportingTriggerSpec())
        {
        }

        template <int STEP> AttributionReportingTriggerSpecBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<AttributionReportingTriggerSpecBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Storage::AttributionReportingTriggerSpec> m_result;
    };

    static AttributionReportingTriggerSpecBuilder<0> create()
    {
        return AttributionReportingTriggerSpecBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    AttributionReportingTriggerSpec()
    {
    }

    std::unique_ptr<protocol::Array<double>> m_triggerData;
    std::unique_ptr<protocol::Storage::AttributionReportingEventReportWindows> m_eventReportWindows;
};

class CORE_EXPORT AttributionReportingAggregatableDebugReportingData : public ::crdtp::ProtocolObject<AttributionReportingAggregatableDebugReportingData> {
public:
    ~AttributionReportingAggregatableDebugReportingData() override
    {
    }

    String getKeyPiece()
    {
        return m_keyPiece;
    }
    void setKeyPiece(const String& value)
    {
        m_keyPiece = value;
    }

    double getValue()
    {
        return m_value;
    }
    void setValue(double value)
    {
        m_value = value;
    }

    protocol::Array<String>* getTypes()
    {
        return m_types.get();
    }
    void setTypes(std::unique_ptr<protocol::Array<String>> value)
    {
        m_types = std::move(value);
    }

    template <int STATE> class AttributionReportingAggregatableDebugReportingDataBuilder {
    public:
        enum { NoFieldsSet = 0, KeyPieceSet = 1 << 1, ValueSet = 1 << 2, TypesSet = 1 << 3, AllFieldsSet = (KeyPieceSet | ValueSet | TypesSet | 0) };

        AttributionReportingAggregatableDebugReportingDataBuilder<STATE | KeyPieceSet>& setKeyPiece(const String& value)
        {
            static_assert(!(STATE & KeyPieceSet), "property keyPiece should not be set yet");
            m_result->setKeyPiece(value);
            return castState<KeyPieceSet>();
        }

        AttributionReportingAggregatableDebugReportingDataBuilder<STATE | ValueSet>& setValue(double value)
        {
            static_assert(!(STATE & ValueSet), "property value should not be set yet");
            m_result->setValue(value);
            return castState<ValueSet>();
        }

        AttributionReportingAggregatableDebugReportingDataBuilder<STATE | TypesSet>& setTypes(std::unique_ptr<protocol::Array<String>> value)
        {
            static_assert(!(STATE & TypesSet), "property types should not be set yet");
            m_result->setTypes(std::move(value));
            return castState<TypesSet>();
        }

        std::unique_ptr<AttributionReportingAggregatableDebugReportingData> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class AttributionReportingAggregatableDebugReportingData;
        AttributionReportingAggregatableDebugReportingDataBuilder()
            : m_result(new AttributionReportingAggregatableDebugReportingData())
        {
        }

        template <int STEP> AttributionReportingAggregatableDebugReportingDataBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<AttributionReportingAggregatableDebugReportingDataBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Storage::AttributionReportingAggregatableDebugReportingData> m_result;
    };

    static AttributionReportingAggregatableDebugReportingDataBuilder<0> create()
    {
        return AttributionReportingAggregatableDebugReportingDataBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    AttributionReportingAggregatableDebugReportingData()
    {
        m_value = 0;
    }

    String m_keyPiece;
    double m_value;
    std::unique_ptr<protocol::Array<String>> m_types;
};

class CORE_EXPORT AttributionReportingAggregatableDebugReportingConfig : public ::crdtp::ProtocolObject<AttributionReportingAggregatableDebugReportingConfig> {
public:
    ~AttributionReportingAggregatableDebugReportingConfig() override
    {
    }

    bool hasBudget()
    {
        return m_budget.has_value();
    }
    double getBudget(double defaultValue) const
    {
        return m_budget.value_or(defaultValue);
    }
    void setBudget(double value)
    {
        m_budget = value;
    }

    String getKeyPiece()
    {
        return m_keyPiece;
    }
    void setKeyPiece(const String& value)
    {
        m_keyPiece = value;
    }

    protocol::Array<protocol::Storage::AttributionReportingAggregatableDebugReportingData>* getDebugData()
    {
        return m_debugData.get();
    }
    void setDebugData(std::unique_ptr<protocol::Array<protocol::Storage::AttributionReportingAggregatableDebugReportingData>> value)
    {
        m_debugData = std::move(value);
    }

    bool hasAggregationCoordinatorOrigin()
    {
        return m_aggregationCoordinatorOrigin.has_value();
    }
    String getAggregationCoordinatorOrigin(const String& defaultValue) const
    {
        return m_aggregationCoordinatorOrigin.value_or(defaultValue);
    }
    void setAggregationCoordinatorOrigin(const String& value)
    {
        m_aggregationCoordinatorOrigin = value;
    }

    template <int STATE> class AttributionReportingAggregatableDebugReportingConfigBuilder {
    public:
        enum { NoFieldsSet = 0, KeyPieceSet = 1 << 1, DebugDataSet = 1 << 2, AllFieldsSet = (KeyPieceSet | DebugDataSet | 0) };

        AttributionReportingAggregatableDebugReportingConfigBuilder<STATE>& setBudget(double value)
        {
            m_result->setBudget(value);
            return *this;
        }

        AttributionReportingAggregatableDebugReportingConfigBuilder<STATE | KeyPieceSet>& setKeyPiece(const String& value)
        {
            static_assert(!(STATE & KeyPieceSet), "property keyPiece should not be set yet");
            m_result->setKeyPiece(value);
            return castState<KeyPieceSet>();
        }

        AttributionReportingAggregatableDebugReportingConfigBuilder<STATE | DebugDataSet>& setDebugData(
            std::unique_ptr<protocol::Array<protocol::Storage::AttributionReportingAggregatableDebugReportingData>> value)
        {
            static_assert(!(STATE & DebugDataSet), "property debugData should not be set yet");
            m_result->setDebugData(std::move(value));
            return castState<DebugDataSet>();
        }

        AttributionReportingAggregatableDebugReportingConfigBuilder<STATE>& setAggregationCoordinatorOrigin(const String& value)
        {
            m_result->setAggregationCoordinatorOrigin(value);
            return *this;
        }

        std::unique_ptr<AttributionReportingAggregatableDebugReportingConfig> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class AttributionReportingAggregatableDebugReportingConfig;
        AttributionReportingAggregatableDebugReportingConfigBuilder()
            : m_result(new AttributionReportingAggregatableDebugReportingConfig())
        {
        }

        template <int STEP> AttributionReportingAggregatableDebugReportingConfigBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<AttributionReportingAggregatableDebugReportingConfigBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Storage::AttributionReportingAggregatableDebugReportingConfig> m_result;
    };

    static AttributionReportingAggregatableDebugReportingConfigBuilder<0> create()
    {
        return AttributionReportingAggregatableDebugReportingConfigBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    AttributionReportingAggregatableDebugReportingConfig()
    {
    }

    Maybe<double> m_budget;
    String m_keyPiece;
    std::unique_ptr<protocol::Array<protocol::Storage::AttributionReportingAggregatableDebugReportingData>> m_debugData;
    Maybe<String> m_aggregationCoordinatorOrigin;
};

class CORE_EXPORT AttributionScopesData : public ::crdtp::ProtocolObject<AttributionScopesData> {
public:
    ~AttributionScopesData() override
    {
    }

    protocol::Array<String>* getValues()
    {
        return m_values.get();
    }
    void setValues(std::unique_ptr<protocol::Array<String>> value)
    {
        m_values = std::move(value);
    }

    double getLimit()
    {
        return m_limit;
    }
    void setLimit(double value)
    {
        m_limit = value;
    }

    double getMaxEventStates()
    {
        return m_maxEventStates;
    }
    void setMaxEventStates(double value)
    {
        m_maxEventStates = value;
    }

    template <int STATE> class AttributionScopesDataBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            ValuesSet = 1 << 1,
            LimitSet = 1 << 2,
            MaxEventStatesSet = 1 << 3,
            AllFieldsSet = (ValuesSet | LimitSet | MaxEventStatesSet | 0)
        };

        AttributionScopesDataBuilder<STATE | ValuesSet>& setValues(std::unique_ptr<protocol::Array<String>> value)
        {
            static_assert(!(STATE & ValuesSet), "property values should not be set yet");
            m_result->setValues(std::move(value));
            return castState<ValuesSet>();
        }

        AttributionScopesDataBuilder<STATE | LimitSet>& setLimit(double value)
        {
            static_assert(!(STATE & LimitSet), "property limit should not be set yet");
            m_result->setLimit(value);
            return castState<LimitSet>();
        }

        AttributionScopesDataBuilder<STATE | MaxEventStatesSet>& setMaxEventStates(double value)
        {
            static_assert(!(STATE & MaxEventStatesSet), "property maxEventStates should not be set yet");
            m_result->setMaxEventStates(value);
            return castState<MaxEventStatesSet>();
        }

        std::unique_ptr<AttributionScopesData> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class AttributionScopesData;
        AttributionScopesDataBuilder()
            : m_result(new AttributionScopesData())
        {
        }

        template <int STEP> AttributionScopesDataBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<AttributionScopesDataBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Storage::AttributionScopesData> m_result;
    };

    static AttributionScopesDataBuilder<0> create()
    {
        return AttributionScopesDataBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    AttributionScopesData()
    {
        m_limit = 0;
        m_maxEventStates = 0;
    }

    std::unique_ptr<protocol::Array<String>> m_values;
    double m_limit;
    double m_maxEventStates;
};

class CORE_EXPORT AttributionReportingSourceRegistration : public ::crdtp::ProtocolObject<AttributionReportingSourceRegistration> {
public:
    ~AttributionReportingSourceRegistration() override
    {
    }

    double getTime()
    {
        return m_time;
    }
    void setTime(double value)
    {
        m_time = value;
    }

    int getExpiry()
    {
        return m_expiry;
    }
    void setExpiry(int value)
    {
        m_expiry = value;
    }

    protocol::Array<protocol::Storage::AttributionReportingTriggerSpec>* getTriggerSpecs()
    {
        return m_triggerSpecs.get();
    }
    void setTriggerSpecs(std::unique_ptr<protocol::Array<protocol::Storage::AttributionReportingTriggerSpec>> value)
    {
        m_triggerSpecs = std::move(value);
    }

    int getAggregatableReportWindow()
    {
        return m_aggregatableReportWindow;
    }
    void setAggregatableReportWindow(int value)
    {
        m_aggregatableReportWindow = value;
    }

    String getType()
    {
        return m_type;
    }
    void setType(const String& value)
    {
        m_type = value;
    }

    String getSourceOrigin()
    {
        return m_sourceOrigin;
    }
    void setSourceOrigin(const String& value)
    {
        m_sourceOrigin = value;
    }

    String getReportingOrigin()
    {
        return m_reportingOrigin;
    }
    void setReportingOrigin(const String& value)
    {
        m_reportingOrigin = value;
    }

    protocol::Array<String>* getDestinationSites()
    {
        return m_destinationSites.get();
    }
    void setDestinationSites(std::unique_ptr<protocol::Array<String>> value)
    {
        m_destinationSites = std::move(value);
    }

    String getEventId()
    {
        return m_eventId;
    }
    void setEventId(const String& value)
    {
        m_eventId = value;
    }

    String getPriority()
    {
        return m_priority;
    }
    void setPriority(const String& value)
    {
        m_priority = value;
    }

    protocol::Array<protocol::Storage::AttributionReportingFilterDataEntry>* getFilterData()
    {
        return m_filterData.get();
    }
    void setFilterData(std::unique_ptr<protocol::Array<protocol::Storage::AttributionReportingFilterDataEntry>> value)
    {
        m_filterData = std::move(value);
    }

    protocol::Array<protocol::Storage::AttributionReportingAggregationKeysEntry>* getAggregationKeys()
    {
        return m_aggregationKeys.get();
    }
    void setAggregationKeys(std::unique_ptr<protocol::Array<protocol::Storage::AttributionReportingAggregationKeysEntry>> value)
    {
        m_aggregationKeys = std::move(value);
    }

    bool hasDebugKey()
    {
        return m_debugKey.has_value();
    }
    String getDebugKey(const String& defaultValue) const
    {
        return m_debugKey.value_or(defaultValue);
    }
    void setDebugKey(const String& value)
    {
        m_debugKey = value;
    }

    String getTriggerDataMatching()
    {
        return m_triggerDataMatching;
    }
    void setTriggerDataMatching(const String& value)
    {
        m_triggerDataMatching = value;
    }

    String getDestinationLimitPriority()
    {
        return m_destinationLimitPriority;
    }
    void setDestinationLimitPriority(const String& value)
    {
        m_destinationLimitPriority = value;
    }

    protocol::Storage::AttributionReportingAggregatableDebugReportingConfig* getAggregatableDebugReportingConfig()
    {
        return m_aggregatableDebugReportingConfig.get();
    }
    void setAggregatableDebugReportingConfig(std::unique_ptr<protocol::Storage::AttributionReportingAggregatableDebugReportingConfig> value)
    {
        m_aggregatableDebugReportingConfig = std::move(value);
    }

    bool hasScopesData()
    {
        return m_scopesData.has_value();
    }
    protocol::Storage::AttributionScopesData* getScopesData(protocol::Storage::AttributionScopesData* defaultValue)
    {
        return m_scopesData.has_value() ? &m_scopesData.value() : defaultValue;
    }
    void setScopesData(std::unique_ptr<protocol::Storage::AttributionScopesData> value)
    {
        m_scopesData = std::move(value);
    }

    int getMaxEventLevelReports()
    {
        return m_maxEventLevelReports;
    }
    void setMaxEventLevelReports(int value)
    {
        m_maxEventLevelReports = value;
    }

    template <int STATE> class AttributionReportingSourceRegistrationBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            TimeSet = 1 << 1,
            ExpirySet = 1 << 2,
            TriggerSpecsSet = 1 << 3,
            AggregatableReportWindowSet = 1 << 4,
            TypeSet = 1 << 5,
            SourceOriginSet = 1 << 6,
            ReportingOriginSet = 1 << 7,
            DestinationSitesSet = 1 << 8,
            EventIdSet = 1 << 9,
            PrioritySet = 1 << 10,
            FilterDataSet = 1 << 11,
            AggregationKeysSet = 1 << 12,
            TriggerDataMatchingSet = 1 << 13,
            DestinationLimitPrioritySet = 1 << 14,
            AggregatableDebugReportingConfigSet = 1 << 15,
            MaxEventLevelReportsSet = 1 << 16,
            AllFieldsSet = (TimeSet | ExpirySet | TriggerSpecsSet | AggregatableReportWindowSet | TypeSet | SourceOriginSet | ReportingOriginSet
                | DestinationSitesSet | EventIdSet | PrioritySet | FilterDataSet | AggregationKeysSet | TriggerDataMatchingSet | DestinationLimitPrioritySet
                | AggregatableDebugReportingConfigSet | MaxEventLevelReportsSet | 0)
        };

        AttributionReportingSourceRegistrationBuilder<STATE | TimeSet>& setTime(double value)
        {
            static_assert(!(STATE & TimeSet), "property time should not be set yet");
            m_result->setTime(value);
            return castState<TimeSet>();
        }

        AttributionReportingSourceRegistrationBuilder<STATE | ExpirySet>& setExpiry(int value)
        {
            static_assert(!(STATE & ExpirySet), "property expiry should not be set yet");
            m_result->setExpiry(value);
            return castState<ExpirySet>();
        }

        AttributionReportingSourceRegistrationBuilder<STATE | TriggerSpecsSet>& setTriggerSpecs(
            std::unique_ptr<protocol::Array<protocol::Storage::AttributionReportingTriggerSpec>> value)
        {
            static_assert(!(STATE & TriggerSpecsSet), "property triggerSpecs should not be set yet");
            m_result->setTriggerSpecs(std::move(value));
            return castState<TriggerSpecsSet>();
        }

        AttributionReportingSourceRegistrationBuilder<STATE | AggregatableReportWindowSet>& setAggregatableReportWindow(int value)
        {
            static_assert(!(STATE & AggregatableReportWindowSet), "property aggregatableReportWindow should not be set yet");
            m_result->setAggregatableReportWindow(value);
            return castState<AggregatableReportWindowSet>();
        }

        AttributionReportingSourceRegistrationBuilder<STATE | TypeSet>& setType(const String& value)
        {
            static_assert(!(STATE & TypeSet), "property type should not be set yet");
            m_result->setType(value);
            return castState<TypeSet>();
        }

        AttributionReportingSourceRegistrationBuilder<STATE | SourceOriginSet>& setSourceOrigin(const String& value)
        {
            static_assert(!(STATE & SourceOriginSet), "property sourceOrigin should not be set yet");
            m_result->setSourceOrigin(value);
            return castState<SourceOriginSet>();
        }

        AttributionReportingSourceRegistrationBuilder<STATE | ReportingOriginSet>& setReportingOrigin(const String& value)
        {
            static_assert(!(STATE & ReportingOriginSet), "property reportingOrigin should not be set yet");
            m_result->setReportingOrigin(value);
            return castState<ReportingOriginSet>();
        }

        AttributionReportingSourceRegistrationBuilder<STATE | DestinationSitesSet>& setDestinationSites(std::unique_ptr<protocol::Array<String>> value)
        {
            static_assert(!(STATE & DestinationSitesSet), "property destinationSites should not be set yet");
            m_result->setDestinationSites(std::move(value));
            return castState<DestinationSitesSet>();
        }

        AttributionReportingSourceRegistrationBuilder<STATE | EventIdSet>& setEventId(const String& value)
        {
            static_assert(!(STATE & EventIdSet), "property eventId should not be set yet");
            m_result->setEventId(value);
            return castState<EventIdSet>();
        }

        AttributionReportingSourceRegistrationBuilder<STATE | PrioritySet>& setPriority(const String& value)
        {
            static_assert(!(STATE & PrioritySet), "property priority should not be set yet");
            m_result->setPriority(value);
            return castState<PrioritySet>();
        }

        AttributionReportingSourceRegistrationBuilder<STATE | FilterDataSet>& setFilterData(
            std::unique_ptr<protocol::Array<protocol::Storage::AttributionReportingFilterDataEntry>> value)
        {
            static_assert(!(STATE & FilterDataSet), "property filterData should not be set yet");
            m_result->setFilterData(std::move(value));
            return castState<FilterDataSet>();
        }

        AttributionReportingSourceRegistrationBuilder<STATE | AggregationKeysSet>& setAggregationKeys(
            std::unique_ptr<protocol::Array<protocol::Storage::AttributionReportingAggregationKeysEntry>> value)
        {
            static_assert(!(STATE & AggregationKeysSet), "property aggregationKeys should not be set yet");
            m_result->setAggregationKeys(std::move(value));
            return castState<AggregationKeysSet>();
        }

        AttributionReportingSourceRegistrationBuilder<STATE>& setDebugKey(const String& value)
        {
            m_result->setDebugKey(value);
            return *this;
        }

        AttributionReportingSourceRegistrationBuilder<STATE | TriggerDataMatchingSet>& setTriggerDataMatching(const String& value)
        {
            static_assert(!(STATE & TriggerDataMatchingSet), "property triggerDataMatching should not be set yet");
            m_result->setTriggerDataMatching(value);
            return castState<TriggerDataMatchingSet>();
        }

        AttributionReportingSourceRegistrationBuilder<STATE | DestinationLimitPrioritySet>& setDestinationLimitPriority(const String& value)
        {
            static_assert(!(STATE & DestinationLimitPrioritySet), "property destinationLimitPriority should not be set yet");
            m_result->setDestinationLimitPriority(value);
            return castState<DestinationLimitPrioritySet>();
        }

        AttributionReportingSourceRegistrationBuilder<STATE | AggregatableDebugReportingConfigSet>& setAggregatableDebugReportingConfig(
            std::unique_ptr<protocol::Storage::AttributionReportingAggregatableDebugReportingConfig> value)
        {
            static_assert(!(STATE & AggregatableDebugReportingConfigSet), "property aggregatableDebugReportingConfig should not be set yet");
            m_result->setAggregatableDebugReportingConfig(std::move(value));
            return castState<AggregatableDebugReportingConfigSet>();
        }

        AttributionReportingSourceRegistrationBuilder<STATE>& setScopesData(std::unique_ptr<protocol::Storage::AttributionScopesData> value)
        {
            m_result->setScopesData(std::move(value));
            return *this;
        }

        AttributionReportingSourceRegistrationBuilder<STATE | MaxEventLevelReportsSet>& setMaxEventLevelReports(int value)
        {
            static_assert(!(STATE & MaxEventLevelReportsSet), "property maxEventLevelReports should not be set yet");
            m_result->setMaxEventLevelReports(value);
            return castState<MaxEventLevelReportsSet>();
        }

        std::unique_ptr<AttributionReportingSourceRegistration> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class AttributionReportingSourceRegistration;
        AttributionReportingSourceRegistrationBuilder()
            : m_result(new AttributionReportingSourceRegistration())
        {
        }

        template <int STEP> AttributionReportingSourceRegistrationBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<AttributionReportingSourceRegistrationBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Storage::AttributionReportingSourceRegistration> m_result;
    };

    static AttributionReportingSourceRegistrationBuilder<0> create()
    {
        return AttributionReportingSourceRegistrationBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    AttributionReportingSourceRegistration()
    {
        m_time = 0;
        m_expiry = 0;
        m_aggregatableReportWindow = 0;
        m_maxEventLevelReports = 0;
    }

    double m_time;
    int m_expiry;
    std::unique_ptr<protocol::Array<protocol::Storage::AttributionReportingTriggerSpec>> m_triggerSpecs;
    int m_aggregatableReportWindow;
    String m_type;
    String m_sourceOrigin;
    String m_reportingOrigin;
    std::unique_ptr<protocol::Array<String>> m_destinationSites;
    String m_eventId;
    String m_priority;
    std::unique_ptr<protocol::Array<protocol::Storage::AttributionReportingFilterDataEntry>> m_filterData;
    std::unique_ptr<protocol::Array<protocol::Storage::AttributionReportingAggregationKeysEntry>> m_aggregationKeys;
    Maybe<String> m_debugKey;
    String m_triggerDataMatching;
    String m_destinationLimitPriority;
    std::unique_ptr<protocol::Storage::AttributionReportingAggregatableDebugReportingConfig> m_aggregatableDebugReportingConfig;
    Maybe<protocol::Storage::AttributionScopesData> m_scopesData;
    int m_maxEventLevelReports;
};

class CORE_EXPORT AttributionReportingAggregatableValueDictEntry : public ::crdtp::ProtocolObject<AttributionReportingAggregatableValueDictEntry> {
public:
    ~AttributionReportingAggregatableValueDictEntry() override
    {
    }

    String getKey()
    {
        return m_key;
    }
    void setKey(const String& value)
    {
        m_key = value;
    }

    double getValue()
    {
        return m_value;
    }
    void setValue(double value)
    {
        m_value = value;
    }

    String getFilteringId()
    {
        return m_filteringId;
    }
    void setFilteringId(const String& value)
    {
        m_filteringId = value;
    }

    template <int STATE> class AttributionReportingAggregatableValueDictEntryBuilder {
    public:
        enum { NoFieldsSet = 0, KeySet = 1 << 1, ValueSet = 1 << 2, FilteringIdSet = 1 << 3, AllFieldsSet = (KeySet | ValueSet | FilteringIdSet | 0) };

        AttributionReportingAggregatableValueDictEntryBuilder<STATE | KeySet>& setKey(const String& value)
        {
            static_assert(!(STATE & KeySet), "property key should not be set yet");
            m_result->setKey(value);
            return castState<KeySet>();
        }

        AttributionReportingAggregatableValueDictEntryBuilder<STATE | ValueSet>& setValue(double value)
        {
            static_assert(!(STATE & ValueSet), "property value should not be set yet");
            m_result->setValue(value);
            return castState<ValueSet>();
        }

        AttributionReportingAggregatableValueDictEntryBuilder<STATE | FilteringIdSet>& setFilteringId(const String& value)
        {
            static_assert(!(STATE & FilteringIdSet), "property filteringId should not be set yet");
            m_result->setFilteringId(value);
            return castState<FilteringIdSet>();
        }

        std::unique_ptr<AttributionReportingAggregatableValueDictEntry> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class AttributionReportingAggregatableValueDictEntry;
        AttributionReportingAggregatableValueDictEntryBuilder()
            : m_result(new AttributionReportingAggregatableValueDictEntry())
        {
        }

        template <int STEP> AttributionReportingAggregatableValueDictEntryBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<AttributionReportingAggregatableValueDictEntryBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Storage::AttributionReportingAggregatableValueDictEntry> m_result;
    };

    static AttributionReportingAggregatableValueDictEntryBuilder<0> create()
    {
        return AttributionReportingAggregatableValueDictEntryBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    AttributionReportingAggregatableValueDictEntry()
    {
        m_value = 0;
    }

    String m_key;
    double m_value;
    String m_filteringId;
};

class CORE_EXPORT AttributionReportingAggregatableValueEntry : public ::crdtp::ProtocolObject<AttributionReportingAggregatableValueEntry> {
public:
    ~AttributionReportingAggregatableValueEntry() override
    {
    }

    protocol::Array<protocol::Storage::AttributionReportingAggregatableValueDictEntry>* getValues()
    {
        return m_values.get();
    }
    void setValues(std::unique_ptr<protocol::Array<protocol::Storage::AttributionReportingAggregatableValueDictEntry>> value)
    {
        m_values = std::move(value);
    }

    protocol::Storage::AttributionReportingFilterPair* getFilters()
    {
        return m_filters.get();
    }
    void setFilters(std::unique_ptr<protocol::Storage::AttributionReportingFilterPair> value)
    {
        m_filters = std::move(value);
    }

    template <int STATE> class AttributionReportingAggregatableValueEntryBuilder {
    public:
        enum { NoFieldsSet = 0, ValuesSet = 1 << 1, FiltersSet = 1 << 2, AllFieldsSet = (ValuesSet | FiltersSet | 0) };

        AttributionReportingAggregatableValueEntryBuilder<STATE | ValuesSet>& setValues(
            std::unique_ptr<protocol::Array<protocol::Storage::AttributionReportingAggregatableValueDictEntry>> value)
        {
            static_assert(!(STATE & ValuesSet), "property values should not be set yet");
            m_result->setValues(std::move(value));
            return castState<ValuesSet>();
        }

        AttributionReportingAggregatableValueEntryBuilder<STATE | FiltersSet>& setFilters(
            std::unique_ptr<protocol::Storage::AttributionReportingFilterPair> value)
        {
            static_assert(!(STATE & FiltersSet), "property filters should not be set yet");
            m_result->setFilters(std::move(value));
            return castState<FiltersSet>();
        }

        std::unique_ptr<AttributionReportingAggregatableValueEntry> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class AttributionReportingAggregatableValueEntry;
        AttributionReportingAggregatableValueEntryBuilder()
            : m_result(new AttributionReportingAggregatableValueEntry())
        {
        }

        template <int STEP> AttributionReportingAggregatableValueEntryBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<AttributionReportingAggregatableValueEntryBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Storage::AttributionReportingAggregatableValueEntry> m_result;
    };

    static AttributionReportingAggregatableValueEntryBuilder<0> create()
    {
        return AttributionReportingAggregatableValueEntryBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    AttributionReportingAggregatableValueEntry()
    {
    }

    std::unique_ptr<protocol::Array<protocol::Storage::AttributionReportingAggregatableValueDictEntry>> m_values;
    std::unique_ptr<protocol::Storage::AttributionReportingFilterPair> m_filters;
};

class CORE_EXPORT AttributionReportingEventTriggerData : public ::crdtp::ProtocolObject<AttributionReportingEventTriggerData> {
public:
    ~AttributionReportingEventTriggerData() override
    {
    }

    String getData()
    {
        return m_data;
    }
    void setData(const String& value)
    {
        m_data = value;
    }

    String getPriority()
    {
        return m_priority;
    }
    void setPriority(const String& value)
    {
        m_priority = value;
    }

    bool hasDedupKey()
    {
        return m_dedupKey.has_value();
    }
    String getDedupKey(const String& defaultValue) const
    {
        return m_dedupKey.value_or(defaultValue);
    }
    void setDedupKey(const String& value)
    {
        m_dedupKey = value;
    }

    protocol::Storage::AttributionReportingFilterPair* getFilters()
    {
        return m_filters.get();
    }
    void setFilters(std::unique_ptr<protocol::Storage::AttributionReportingFilterPair> value)
    {
        m_filters = std::move(value);
    }

    template <int STATE> class AttributionReportingEventTriggerDataBuilder {
    public:
        enum { NoFieldsSet = 0, DataSet = 1 << 1, PrioritySet = 1 << 2, FiltersSet = 1 << 3, AllFieldsSet = (DataSet | PrioritySet | FiltersSet | 0) };

        AttributionReportingEventTriggerDataBuilder<STATE | DataSet>& setData(const String& value)
        {
            static_assert(!(STATE & DataSet), "property data should not be set yet");
            m_result->setData(value);
            return castState<DataSet>();
        }

        AttributionReportingEventTriggerDataBuilder<STATE | PrioritySet>& setPriority(const String& value)
        {
            static_assert(!(STATE & PrioritySet), "property priority should not be set yet");
            m_result->setPriority(value);
            return castState<PrioritySet>();
        }

        AttributionReportingEventTriggerDataBuilder<STATE>& setDedupKey(const String& value)
        {
            m_result->setDedupKey(value);
            return *this;
        }

        AttributionReportingEventTriggerDataBuilder<STATE | FiltersSet>& setFilters(std::unique_ptr<protocol::Storage::AttributionReportingFilterPair> value)
        {
            static_assert(!(STATE & FiltersSet), "property filters should not be set yet");
            m_result->setFilters(std::move(value));
            return castState<FiltersSet>();
        }

        std::unique_ptr<AttributionReportingEventTriggerData> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class AttributionReportingEventTriggerData;
        AttributionReportingEventTriggerDataBuilder()
            : m_result(new AttributionReportingEventTriggerData())
        {
        }

        template <int STEP> AttributionReportingEventTriggerDataBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<AttributionReportingEventTriggerDataBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Storage::AttributionReportingEventTriggerData> m_result;
    };

    static AttributionReportingEventTriggerDataBuilder<0> create()
    {
        return AttributionReportingEventTriggerDataBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    AttributionReportingEventTriggerData()
    {
    }

    String m_data;
    String m_priority;
    Maybe<String> m_dedupKey;
    std::unique_ptr<protocol::Storage::AttributionReportingFilterPair> m_filters;
};

class CORE_EXPORT AttributionReportingAggregatableTriggerData : public ::crdtp::ProtocolObject<AttributionReportingAggregatableTriggerData> {
public:
    ~AttributionReportingAggregatableTriggerData() override
    {
    }

    String getKeyPiece()
    {
        return m_keyPiece;
    }
    void setKeyPiece(const String& value)
    {
        m_keyPiece = value;
    }

    protocol::Array<String>* getSourceKeys()
    {
        return m_sourceKeys.get();
    }
    void setSourceKeys(std::unique_ptr<protocol::Array<String>> value)
    {
        m_sourceKeys = std::move(value);
    }

    protocol::Storage::AttributionReportingFilterPair* getFilters()
    {
        return m_filters.get();
    }
    void setFilters(std::unique_ptr<protocol::Storage::AttributionReportingFilterPair> value)
    {
        m_filters = std::move(value);
    }

    template <int STATE> class AttributionReportingAggregatableTriggerDataBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            KeyPieceSet = 1 << 1,
            SourceKeysSet = 1 << 2,
            FiltersSet = 1 << 3,
            AllFieldsSet = (KeyPieceSet | SourceKeysSet | FiltersSet | 0)
        };

        AttributionReportingAggregatableTriggerDataBuilder<STATE | KeyPieceSet>& setKeyPiece(const String& value)
        {
            static_assert(!(STATE & KeyPieceSet), "property keyPiece should not be set yet");
            m_result->setKeyPiece(value);
            return castState<KeyPieceSet>();
        }

        AttributionReportingAggregatableTriggerDataBuilder<STATE | SourceKeysSet>& setSourceKeys(std::unique_ptr<protocol::Array<String>> value)
        {
            static_assert(!(STATE & SourceKeysSet), "property sourceKeys should not be set yet");
            m_result->setSourceKeys(std::move(value));
            return castState<SourceKeysSet>();
        }

        AttributionReportingAggregatableTriggerDataBuilder<STATE | FiltersSet>& setFilters(
            std::unique_ptr<protocol::Storage::AttributionReportingFilterPair> value)
        {
            static_assert(!(STATE & FiltersSet), "property filters should not be set yet");
            m_result->setFilters(std::move(value));
            return castState<FiltersSet>();
        }

        std::unique_ptr<AttributionReportingAggregatableTriggerData> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class AttributionReportingAggregatableTriggerData;
        AttributionReportingAggregatableTriggerDataBuilder()
            : m_result(new AttributionReportingAggregatableTriggerData())
        {
        }

        template <int STEP> AttributionReportingAggregatableTriggerDataBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<AttributionReportingAggregatableTriggerDataBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Storage::AttributionReportingAggregatableTriggerData> m_result;
    };

    static AttributionReportingAggregatableTriggerDataBuilder<0> create()
    {
        return AttributionReportingAggregatableTriggerDataBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    AttributionReportingAggregatableTriggerData()
    {
    }

    String m_keyPiece;
    std::unique_ptr<protocol::Array<String>> m_sourceKeys;
    std::unique_ptr<protocol::Storage::AttributionReportingFilterPair> m_filters;
};

class CORE_EXPORT AttributionReportingAggregatableDedupKey : public ::crdtp::ProtocolObject<AttributionReportingAggregatableDedupKey> {
public:
    ~AttributionReportingAggregatableDedupKey() override
    {
    }

    bool hasDedupKey()
    {
        return m_dedupKey.has_value();
    }
    String getDedupKey(const String& defaultValue) const
    {
        return m_dedupKey.value_or(defaultValue);
    }
    void setDedupKey(const String& value)
    {
        m_dedupKey = value;
    }

    protocol::Storage::AttributionReportingFilterPair* getFilters()
    {
        return m_filters.get();
    }
    void setFilters(std::unique_ptr<protocol::Storage::AttributionReportingFilterPair> value)
    {
        m_filters = std::move(value);
    }

    template <int STATE> class AttributionReportingAggregatableDedupKeyBuilder {
    public:
        enum { NoFieldsSet = 0, FiltersSet = 1 << 1, AllFieldsSet = (FiltersSet | 0) };

        AttributionReportingAggregatableDedupKeyBuilder<STATE>& setDedupKey(const String& value)
        {
            m_result->setDedupKey(value);
            return *this;
        }

        AttributionReportingAggregatableDedupKeyBuilder<STATE | FiltersSet>& setFilters(
            std::unique_ptr<protocol::Storage::AttributionReportingFilterPair> value)
        {
            static_assert(!(STATE & FiltersSet), "property filters should not be set yet");
            m_result->setFilters(std::move(value));
            return castState<FiltersSet>();
        }

        std::unique_ptr<AttributionReportingAggregatableDedupKey> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class AttributionReportingAggregatableDedupKey;
        AttributionReportingAggregatableDedupKeyBuilder()
            : m_result(new AttributionReportingAggregatableDedupKey())
        {
        }

        template <int STEP> AttributionReportingAggregatableDedupKeyBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<AttributionReportingAggregatableDedupKeyBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Storage::AttributionReportingAggregatableDedupKey> m_result;
    };

    static AttributionReportingAggregatableDedupKeyBuilder<0> create()
    {
        return AttributionReportingAggregatableDedupKeyBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    AttributionReportingAggregatableDedupKey()
    {
    }

    Maybe<String> m_dedupKey;
    std::unique_ptr<protocol::Storage::AttributionReportingFilterPair> m_filters;
};

class CORE_EXPORT AttributionReportingTriggerRegistration : public ::crdtp::ProtocolObject<AttributionReportingTriggerRegistration> {
public:
    ~AttributionReportingTriggerRegistration() override
    {
    }

    protocol::Storage::AttributionReportingFilterPair* getFilters()
    {
        return m_filters.get();
    }
    void setFilters(std::unique_ptr<protocol::Storage::AttributionReportingFilterPair> value)
    {
        m_filters = std::move(value);
    }

    bool hasDebugKey()
    {
        return m_debugKey.has_value();
    }
    String getDebugKey(const String& defaultValue) const
    {
        return m_debugKey.value_or(defaultValue);
    }
    void setDebugKey(const String& value)
    {
        m_debugKey = value;
    }

    protocol::Array<protocol::Storage::AttributionReportingAggregatableDedupKey>* getAggregatableDedupKeys()
    {
        return m_aggregatableDedupKeys.get();
    }
    void setAggregatableDedupKeys(std::unique_ptr<protocol::Array<protocol::Storage::AttributionReportingAggregatableDedupKey>> value)
    {
        m_aggregatableDedupKeys = std::move(value);
    }

    protocol::Array<protocol::Storage::AttributionReportingEventTriggerData>* getEventTriggerData()
    {
        return m_eventTriggerData.get();
    }
    void setEventTriggerData(std::unique_ptr<protocol::Array<protocol::Storage::AttributionReportingEventTriggerData>> value)
    {
        m_eventTriggerData = std::move(value);
    }

    protocol::Array<protocol::Storage::AttributionReportingAggregatableTriggerData>* getAggregatableTriggerData()
    {
        return m_aggregatableTriggerData.get();
    }
    void setAggregatableTriggerData(std::unique_ptr<protocol::Array<protocol::Storage::AttributionReportingAggregatableTriggerData>> value)
    {
        m_aggregatableTriggerData = std::move(value);
    }

    protocol::Array<protocol::Storage::AttributionReportingAggregatableValueEntry>* getAggregatableValues()
    {
        return m_aggregatableValues.get();
    }
    void setAggregatableValues(std::unique_ptr<protocol::Array<protocol::Storage::AttributionReportingAggregatableValueEntry>> value)
    {
        m_aggregatableValues = std::move(value);
    }

    int getAggregatableFilteringIdMaxBytes()
    {
        return m_aggregatableFilteringIdMaxBytes;
    }
    void setAggregatableFilteringIdMaxBytes(int value)
    {
        m_aggregatableFilteringIdMaxBytes = value;
    }

    bool getDebugReporting()
    {
        return m_debugReporting;
    }
    void setDebugReporting(bool value)
    {
        m_debugReporting = value;
    }

    bool hasAggregationCoordinatorOrigin()
    {
        return m_aggregationCoordinatorOrigin.has_value();
    }
    String getAggregationCoordinatorOrigin(const String& defaultValue) const
    {
        return m_aggregationCoordinatorOrigin.value_or(defaultValue);
    }
    void setAggregationCoordinatorOrigin(const String& value)
    {
        m_aggregationCoordinatorOrigin = value;
    }

    String getSourceRegistrationTimeConfig()
    {
        return m_sourceRegistrationTimeConfig;
    }
    void setSourceRegistrationTimeConfig(const String& value)
    {
        m_sourceRegistrationTimeConfig = value;
    }

    bool hasTriggerContextId()
    {
        return m_triggerContextId.has_value();
    }
    String getTriggerContextId(const String& defaultValue) const
    {
        return m_triggerContextId.value_or(defaultValue);
    }
    void setTriggerContextId(const String& value)
    {
        m_triggerContextId = value;
    }

    protocol::Storage::AttributionReportingAggregatableDebugReportingConfig* getAggregatableDebugReportingConfig()
    {
        return m_aggregatableDebugReportingConfig.get();
    }
    void setAggregatableDebugReportingConfig(std::unique_ptr<protocol::Storage::AttributionReportingAggregatableDebugReportingConfig> value)
    {
        m_aggregatableDebugReportingConfig = std::move(value);
    }

    protocol::Array<String>* getScopes()
    {
        return m_scopes.get();
    }
    void setScopes(std::unique_ptr<protocol::Array<String>> value)
    {
        m_scopes = std::move(value);
    }

    template <int STATE> class AttributionReportingTriggerRegistrationBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            FiltersSet = 1 << 1,
            AggregatableDedupKeysSet = 1 << 2,
            EventTriggerDataSet = 1 << 3,
            AggregatableTriggerDataSet = 1 << 4,
            AggregatableValuesSet = 1 << 5,
            AggregatableFilteringIdMaxBytesSet = 1 << 6,
            DebugReportingSet = 1 << 7,
            SourceRegistrationTimeConfigSet = 1 << 8,
            AggregatableDebugReportingConfigSet = 1 << 9,
            ScopesSet = 1 << 10,
            AllFieldsSet = (FiltersSet | AggregatableDedupKeysSet | EventTriggerDataSet | AggregatableTriggerDataSet | AggregatableValuesSet
                | AggregatableFilteringIdMaxBytesSet | DebugReportingSet | SourceRegistrationTimeConfigSet | AggregatableDebugReportingConfigSet | ScopesSet
                | 0)
        };

        AttributionReportingTriggerRegistrationBuilder<STATE | FiltersSet>& setFilters(std::unique_ptr<protocol::Storage::AttributionReportingFilterPair> value)
        {
            static_assert(!(STATE & FiltersSet), "property filters should not be set yet");
            m_result->setFilters(std::move(value));
            return castState<FiltersSet>();
        }

        AttributionReportingTriggerRegistrationBuilder<STATE>& setDebugKey(const String& value)
        {
            m_result->setDebugKey(value);
            return *this;
        }

        AttributionReportingTriggerRegistrationBuilder<STATE | AggregatableDedupKeysSet>& setAggregatableDedupKeys(
            std::unique_ptr<protocol::Array<protocol::Storage::AttributionReportingAggregatableDedupKey>> value)
        {
            static_assert(!(STATE & AggregatableDedupKeysSet), "property aggregatableDedupKeys should not be set yet");
            m_result->setAggregatableDedupKeys(std::move(value));
            return castState<AggregatableDedupKeysSet>();
        }

        AttributionReportingTriggerRegistrationBuilder<STATE | EventTriggerDataSet>& setEventTriggerData(
            std::unique_ptr<protocol::Array<protocol::Storage::AttributionReportingEventTriggerData>> value)
        {
            static_assert(!(STATE & EventTriggerDataSet), "property eventTriggerData should not be set yet");
            m_result->setEventTriggerData(std::move(value));
            return castState<EventTriggerDataSet>();
        }

        AttributionReportingTriggerRegistrationBuilder<STATE | AggregatableTriggerDataSet>& setAggregatableTriggerData(
            std::unique_ptr<protocol::Array<protocol::Storage::AttributionReportingAggregatableTriggerData>> value)
        {
            static_assert(!(STATE & AggregatableTriggerDataSet), "property aggregatableTriggerData should not be set yet");
            m_result->setAggregatableTriggerData(std::move(value));
            return castState<AggregatableTriggerDataSet>();
        }

        AttributionReportingTriggerRegistrationBuilder<STATE | AggregatableValuesSet>& setAggregatableValues(
            std::unique_ptr<protocol::Array<protocol::Storage::AttributionReportingAggregatableValueEntry>> value)
        {
            static_assert(!(STATE & AggregatableValuesSet), "property aggregatableValues should not be set yet");
            m_result->setAggregatableValues(std::move(value));
            return castState<AggregatableValuesSet>();
        }

        AttributionReportingTriggerRegistrationBuilder<STATE | AggregatableFilteringIdMaxBytesSet>& setAggregatableFilteringIdMaxBytes(int value)
        {
            static_assert(!(STATE & AggregatableFilteringIdMaxBytesSet), "property aggregatableFilteringIdMaxBytes should not be set yet");
            m_result->setAggregatableFilteringIdMaxBytes(value);
            return castState<AggregatableFilteringIdMaxBytesSet>();
        }

        AttributionReportingTriggerRegistrationBuilder<STATE | DebugReportingSet>& setDebugReporting(bool value)
        {
            static_assert(!(STATE & DebugReportingSet), "property debugReporting should not be set yet");
            m_result->setDebugReporting(value);
            return castState<DebugReportingSet>();
        }

        AttributionReportingTriggerRegistrationBuilder<STATE>& setAggregationCoordinatorOrigin(const String& value)
        {
            m_result->setAggregationCoordinatorOrigin(value);
            return *this;
        }

        AttributionReportingTriggerRegistrationBuilder<STATE | SourceRegistrationTimeConfigSet>& setSourceRegistrationTimeConfig(const String& value)
        {
            static_assert(!(STATE & SourceRegistrationTimeConfigSet), "property sourceRegistrationTimeConfig should not be set yet");
            m_result->setSourceRegistrationTimeConfig(value);
            return castState<SourceRegistrationTimeConfigSet>();
        }

        AttributionReportingTriggerRegistrationBuilder<STATE>& setTriggerContextId(const String& value)
        {
            m_result->setTriggerContextId(value);
            return *this;
        }

        AttributionReportingTriggerRegistrationBuilder<STATE | AggregatableDebugReportingConfigSet>& setAggregatableDebugReportingConfig(
            std::unique_ptr<protocol::Storage::AttributionReportingAggregatableDebugReportingConfig> value)
        {
            static_assert(!(STATE & AggregatableDebugReportingConfigSet), "property aggregatableDebugReportingConfig should not be set yet");
            m_result->setAggregatableDebugReportingConfig(std::move(value));
            return castState<AggregatableDebugReportingConfigSet>();
        }

        AttributionReportingTriggerRegistrationBuilder<STATE | ScopesSet>& setScopes(std::unique_ptr<protocol::Array<String>> value)
        {
            static_assert(!(STATE & ScopesSet), "property scopes should not be set yet");
            m_result->setScopes(std::move(value));
            return castState<ScopesSet>();
        }

        std::unique_ptr<AttributionReportingTriggerRegistration> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class AttributionReportingTriggerRegistration;
        AttributionReportingTriggerRegistrationBuilder()
            : m_result(new AttributionReportingTriggerRegistration())
        {
        }

        template <int STEP> AttributionReportingTriggerRegistrationBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<AttributionReportingTriggerRegistrationBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Storage::AttributionReportingTriggerRegistration> m_result;
    };

    static AttributionReportingTriggerRegistrationBuilder<0> create()
    {
        return AttributionReportingTriggerRegistrationBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    AttributionReportingTriggerRegistration()
    {
        m_aggregatableFilteringIdMaxBytes = 0;
        m_debugReporting = false;
    }

    std::unique_ptr<protocol::Storage::AttributionReportingFilterPair> m_filters;
    Maybe<String> m_debugKey;
    std::unique_ptr<protocol::Array<protocol::Storage::AttributionReportingAggregatableDedupKey>> m_aggregatableDedupKeys;
    std::unique_ptr<protocol::Array<protocol::Storage::AttributionReportingEventTriggerData>> m_eventTriggerData;
    std::unique_ptr<protocol::Array<protocol::Storage::AttributionReportingAggregatableTriggerData>> m_aggregatableTriggerData;
    std::unique_ptr<protocol::Array<protocol::Storage::AttributionReportingAggregatableValueEntry>> m_aggregatableValues;
    int m_aggregatableFilteringIdMaxBytes;
    bool m_debugReporting;
    Maybe<String> m_aggregationCoordinatorOrigin;
    String m_sourceRegistrationTimeConfig;
    Maybe<String> m_triggerContextId;
    std::unique_ptr<protocol::Storage::AttributionReportingAggregatableDebugReportingConfig> m_aggregatableDebugReportingConfig;
    std::unique_ptr<protocol::Array<String>> m_scopes;
};

class CORE_EXPORT RelatedWebsiteSet : public ::crdtp::ProtocolObject<RelatedWebsiteSet> {
public:
    ~RelatedWebsiteSet() override
    {
    }

    protocol::Array<String>* getPrimarySites()
    {
        return m_primarySites.get();
    }
    void setPrimarySites(std::unique_ptr<protocol::Array<String>> value)
    {
        m_primarySites = std::move(value);
    }

    protocol::Array<String>* getAssociatedSites()
    {
        return m_associatedSites.get();
    }
    void setAssociatedSites(std::unique_ptr<protocol::Array<String>> value)
    {
        m_associatedSites = std::move(value);
    }

    protocol::Array<String>* getServiceSites()
    {
        return m_serviceSites.get();
    }
    void setServiceSites(std::unique_ptr<protocol::Array<String>> value)
    {
        m_serviceSites = std::move(value);
    }

    template <int STATE> class RelatedWebsiteSetBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            PrimarySitesSet = 1 << 1,
            AssociatedSitesSet = 1 << 2,
            ServiceSitesSet = 1 << 3,
            AllFieldsSet = (PrimarySitesSet | AssociatedSitesSet | ServiceSitesSet | 0)
        };

        RelatedWebsiteSetBuilder<STATE | PrimarySitesSet>& setPrimarySites(std::unique_ptr<protocol::Array<String>> value)
        {
            static_assert(!(STATE & PrimarySitesSet), "property primarySites should not be set yet");
            m_result->setPrimarySites(std::move(value));
            return castState<PrimarySitesSet>();
        }

        RelatedWebsiteSetBuilder<STATE | AssociatedSitesSet>& setAssociatedSites(std::unique_ptr<protocol::Array<String>> value)
        {
            static_assert(!(STATE & AssociatedSitesSet), "property associatedSites should not be set yet");
            m_result->setAssociatedSites(std::move(value));
            return castState<AssociatedSitesSet>();
        }

        RelatedWebsiteSetBuilder<STATE | ServiceSitesSet>& setServiceSites(std::unique_ptr<protocol::Array<String>> value)
        {
            static_assert(!(STATE & ServiceSitesSet), "property serviceSites should not be set yet");
            m_result->setServiceSites(std::move(value));
            return castState<ServiceSitesSet>();
        }

        std::unique_ptr<RelatedWebsiteSet> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class RelatedWebsiteSet;
        RelatedWebsiteSetBuilder()
            : m_result(new RelatedWebsiteSet())
        {
        }

        template <int STEP> RelatedWebsiteSetBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<RelatedWebsiteSetBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Storage::RelatedWebsiteSet> m_result;
    };

    static RelatedWebsiteSetBuilder<0> create()
    {
        return RelatedWebsiteSetBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    RelatedWebsiteSet()
    {
    }

    std::unique_ptr<protocol::Array<String>> m_primarySites;
    std::unique_ptr<protocol::Array<String>> m_associatedSites;
    std::unique_ptr<protocol::Array<String>> m_serviceSites;
};

// ------------- Backend interface.

class CORE_EXPORT Backend {
public:
    virtual ~Backend()
    {
    }

    virtual DispatchResponse getStorageKeyForFrame(const String& in_frameId, String* out_storageKey) = 0;
    virtual DispatchResponse clearDataForOrigin(const String& in_origin, const String& in_storageTypes) = 0;
    virtual DispatchResponse clearDataForStorageKey(const String& in_storageKey, const String& in_storageTypes) = 0;
    virtual DispatchResponse getCookies(Maybe<String> in_browserContextId, std::unique_ptr<protocol::Array<protocol::Network::Cookie>>* out_cookies) = 0;
    virtual DispatchResponse setCookies(std::unique_ptr<protocol::Array<protocol::Network::CookieParam>> in_cookies, Maybe<String> in_browserContextId) = 0;
    virtual DispatchResponse clearCookies(Maybe<String> in_browserContextId) = 0;
    virtual DispatchResponse getUsageAndQuota(const String& in_origin, double* out_usage, double* out_quota, bool* out_overrideActive,
        std::unique_ptr<protocol::Array<protocol::Storage::UsageForType>>* out_usageBreakdown)
        = 0;
    virtual DispatchResponse overrideQuotaForOrigin(const String& in_origin, Maybe<double> in_quotaSize) = 0;
    virtual DispatchResponse trackCacheStorageForOrigin(const String& in_origin) = 0;
    virtual DispatchResponse trackCacheStorageForStorageKey(const String& in_storageKey) = 0;
    virtual DispatchResponse trackIndexedDBForOrigin(const String& in_origin) = 0;
    virtual DispatchResponse trackIndexedDBForStorageKey(const String& in_storageKey) = 0;
    virtual DispatchResponse untrackCacheStorageForOrigin(const String& in_origin) = 0;
    virtual DispatchResponse untrackCacheStorageForStorageKey(const String& in_storageKey) = 0;
    virtual DispatchResponse untrackIndexedDBForOrigin(const String& in_origin) = 0;
    virtual DispatchResponse untrackIndexedDBForStorageKey(const String& in_storageKey) = 0;
    virtual DispatchResponse getTrustTokens(std::unique_ptr<protocol::Array<protocol::Storage::TrustTokens>>* out_tokens) = 0;
    virtual DispatchResponse clearTrustTokens(const String& in_issuerOrigin, bool* out_didDeleteTokens) = 0;
    virtual DispatchResponse getInterestGroupDetails(
        const String& in_ownerOrigin, const String& in_name, std::unique_ptr<protocol::DictionaryValue>* out_details)
        = 0;
    virtual DispatchResponse setInterestGroupTracking(bool in_enable) = 0;
    virtual DispatchResponse setInterestGroupAuctionTracking(bool in_enable) = 0;
    virtual DispatchResponse getSharedStorageMetadata(const String& in_ownerOrigin, std::unique_ptr<protocol::Storage::SharedStorageMetadata>* out_metadata)
        = 0;
    virtual DispatchResponse getSharedStorageEntries(
        const String& in_ownerOrigin, std::unique_ptr<protocol::Array<protocol::Storage::SharedStorageEntry>>* out_entries)
        = 0;
    virtual DispatchResponse setSharedStorageEntry(const String& in_ownerOrigin, const String& in_key, const String& in_value, Maybe<bool> in_ignoreIfPresent)
        = 0;
    virtual DispatchResponse deleteSharedStorageEntry(const String& in_ownerOrigin, const String& in_key) = 0;
    virtual DispatchResponse clearSharedStorageEntries(const String& in_ownerOrigin) = 0;
    virtual DispatchResponse resetSharedStorageBudget(const String& in_ownerOrigin) = 0;
    virtual DispatchResponse setSharedStorageTracking(bool in_enable) = 0;
    virtual DispatchResponse setStorageBucketTracking(const String& in_storageKey, bool in_enable) = 0;
    virtual DispatchResponse deleteStorageBucket(std::unique_ptr<protocol::Storage::StorageBucket> in_bucket) = 0;
    virtual DispatchResponse runBounceTrackingMitigations(std::unique_ptr<protocol::Array<String>>* out_deletedSites) = 0;
    virtual DispatchResponse setAttributionReportingLocalTestingMode(bool in_enabled) = 0;
    virtual DispatchResponse setAttributionReportingTracking(bool in_enable) = 0;
    virtual DispatchResponse sendPendingAttributionReports(int* out_numSent) = 0;
    virtual DispatchResponse getRelatedWebsiteSets(std::unique_ptr<protocol::Array<protocol::Storage::RelatedWebsiteSet>>* out_sets) = 0;

    virtual DispatchResponse disable()
    {
        return DispatchResponse::Success();
    }
};

// ------------- Frontend interface.

class CORE_EXPORT Frontend {
public:
    explicit Frontend(FrontendChannel* frontend_channel)
        : frontend_channel_(frontend_channel)
    {
    }
    void cacheStorageContentUpdated(const String& origin, const String& storageKey, const String& bucketId, const String& cacheName);
    void cacheStorageListUpdated(const String& origin, const String& storageKey, const String& bucketId);
    void indexedDBContentUpdated(
        const String& origin, const String& storageKey, const String& bucketId, const String& databaseName, const String& objectStoreName);
    void indexedDBListUpdated(const String& origin, const String& storageKey, const String& bucketId);
    void interestGroupAccessed(double accessTime, const String& type, const String& ownerOrigin, const String& name,
        Maybe<String> componentSellerOrigin = Maybe<String>(), Maybe<double> bid = Maybe<double>(), Maybe<String> bidCurrency = Maybe<String>(),
        Maybe<String> uniqueAuctionId = Maybe<String>());
    void interestGroupAuctionEventOccurred(double eventTime, const String& type, const String& uniqueAuctionId, Maybe<String> parentAuctionId = Maybe<String>(),
        Maybe<protocol::DictionaryValue> auctionConfig = Maybe<protocol::DictionaryValue>());
    void interestGroupAuctionNetworkRequestCreated(const String& type, const String& requestId, std::unique_ptr<protocol::Array<String>> auctions);
    void sharedStorageAccessed(double accessTime, const String& type, const String& mainFrameId, const String& ownerOrigin,
        std::unique_ptr<protocol::Storage::SharedStorageAccessParams> params);
    void storageBucketCreatedOrUpdated(std::unique_ptr<protocol::Storage::StorageBucketInfo> bucketInfo);
    void storageBucketDeleted(const String& bucketId);
    void attributionReportingSourceRegistered(std::unique_ptr<protocol::Storage::AttributionReportingSourceRegistration> registration, const String& result);
    void attributionReportingTriggerRegistered(
        std::unique_ptr<protocol::Storage::AttributionReportingTriggerRegistration> registration, const String& eventLevel, const String& aggregatable);

    void flush();
    void sendRawNotification(std::unique_ptr<Serializable>);

private:
    FrontendChannel* frontend_channel_;
};

// ------------- Dispatcher.

class CORE_EXPORT Dispatcher {
public:
    static void wire(UberDispatcher*, Backend*);

private:
    Dispatcher()
    {
    }
};

// ------------- Metainfo.

class CORE_EXPORT Metainfo {
public:
    using BackendClass = Backend;
    using FrontendClass = Frontend;
    using DispatcherClass = Dispatcher;
    static const char domainName[];
    static const char commandPrefix[];
    static const char version[];
};

} // namespace Storage
} // namespace blink
} // namespace protocol

#endif // !defined(blink_protocol_Storage_h)
