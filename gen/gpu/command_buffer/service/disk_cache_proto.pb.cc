// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: disk_cache_proto.proto

#include "disk_cache_proto.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

PROTOBUF_CONSTEXPR ShaderVariableProto::ShaderVariableProto(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.fields_)*/ {},
        /*decltype(_impl_.name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.mapped_name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.struct_name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.type_)*/ 0u,
        /*decltype(_impl_.precision_)*/ 0u, /*decltype(_impl_.array_size_)*/ 0u, /*decltype(_impl_.static_use_)*/ false }
{
}
struct ShaderVariableProtoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ShaderVariableProtoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ShaderVariableProtoDefaultTypeInternal()
    {
    }
    union {
        ShaderVariableProto _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShaderVariableProtoDefaultTypeInternal
    _ShaderVariableProto_default_instance_;
PROTOBUF_CONSTEXPR ShaderAttributeProto::ShaderAttributeProto(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.basic_)*/ nullptr,
        /*decltype(_impl_.location_)*/ 0 }
{
}
struct ShaderAttributeProtoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ShaderAttributeProtoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ShaderAttributeProtoDefaultTypeInternal()
    {
    }
    union {
        ShaderAttributeProto _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShaderAttributeProtoDefaultTypeInternal
    _ShaderAttributeProto_default_instance_;
PROTOBUF_CONSTEXPR ShaderUniformProto::ShaderUniformProto(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.basic_)*/ nullptr }
{
}
struct ShaderUniformProtoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ShaderUniformProtoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ShaderUniformProtoDefaultTypeInternal()
    {
    }
    union {
        ShaderUniformProto _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShaderUniformProtoDefaultTypeInternal _ShaderUniformProto_default_instance_;
PROTOBUF_CONSTEXPR ShaderVaryingProto::ShaderVaryingProto(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.basic_)*/ nullptr,
        /*decltype(_impl_.interpolation_)*/ 0, /*decltype(_impl_.is_invariant_)*/ false }
{
}
struct ShaderVaryingProtoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ShaderVaryingProtoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ShaderVaryingProtoDefaultTypeInternal()
    {
    }
    union {
        ShaderVaryingProto _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShaderVaryingProtoDefaultTypeInternal _ShaderVaryingProto_default_instance_;
PROTOBUF_CONSTEXPR ShaderOutputVariableProto::ShaderOutputVariableProto(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.basic_)*/ nullptr,
        /*decltype(_impl_.location_)*/ 0 }
{
}
struct ShaderOutputVariableProtoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ShaderOutputVariableProtoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ShaderOutputVariableProtoDefaultTypeInternal()
    {
    }
    union {
        ShaderOutputVariableProto _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShaderOutputVariableProtoDefaultTypeInternal
    _ShaderOutputVariableProto_default_instance_;
PROTOBUF_CONSTEXPR ShaderInterfaceBlockFieldProto::ShaderInterfaceBlockFieldProto(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.basic_)*/ nullptr,
        /*decltype(_impl_.is_row_major_layout_)*/ false }
{
}
struct ShaderInterfaceBlockFieldProtoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ShaderInterfaceBlockFieldProtoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ShaderInterfaceBlockFieldProtoDefaultTypeInternal()
    {
    }
    union {
        ShaderInterfaceBlockFieldProto _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShaderInterfaceBlockFieldProtoDefaultTypeInternal
    _ShaderInterfaceBlockFieldProto_default_instance_;
PROTOBUF_CONSTEXPR ShaderInterfaceBlockProto::ShaderInterfaceBlockProto(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.fields_)*/ {},
        /*decltype(_impl_.name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.mapped_name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.instance_name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.array_size_)*/ 0u,
        /*decltype(_impl_.layout_)*/ 0, /*decltype(_impl_.is_row_major_layout_)*/ false, /*decltype(_impl_.static_use_)*/ false }
{
}
struct ShaderInterfaceBlockProtoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ShaderInterfaceBlockProtoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ShaderInterfaceBlockProtoDefaultTypeInternal()
    {
    }
    union {
        ShaderInterfaceBlockProto _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShaderInterfaceBlockProtoDefaultTypeInternal
    _ShaderInterfaceBlockProto_default_instance_;
PROTOBUF_CONSTEXPR ShaderProto::ShaderProto(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.attribs_)*/ {}, /*decltype(_impl_.uniforms_)*/ {},
        /*decltype(_impl_.varyings_)*/ {}, /*decltype(_impl_.output_variables_)*/ {}, /*decltype(_impl_.interface_blocks_)*/ {},
        /*decltype(_impl_.sha_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct ShaderProtoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ShaderProtoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ShaderProtoDefaultTypeInternal()
    {
    }
    union {
        ShaderProto _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShaderProtoDefaultTypeInternal _ShaderProto_default_instance_;
PROTOBUF_CONSTEXPR GpuProgramProto::GpuProgramProto(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.sha_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.program_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.vertex_shader_)*/ nullptr,
        /*decltype(_impl_.fragment_shader_)*/ nullptr, /*decltype(_impl_.format_)*/ 0u, /*decltype(_impl_.program_is_compressed_)*/ false,
        /*decltype(_impl_.program_decompressed_length_)*/ 0u }
{
}
struct GpuProgramProtoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR GpuProgramProtoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~GpuProgramProtoDefaultTypeInternal()
    {
    }
    union {
        GpuProgramProto _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GpuProgramProtoDefaultTypeInternal _GpuProgramProto_default_instance_;

// ===================================================================

class ShaderVariableProto::_Internal {
public:
    using HasBits = decltype(std::declval<ShaderVariableProto>()._impl_._has_bits_);
    static void set_has_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_precision(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static void set_has_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_mapped_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_array_size(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
    static void set_has_static_use(HasBits* has_bits)
    {
        (*has_bits)[0] |= 64u;
    }
    static void set_has_struct_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
};

ShaderVariableProto::ShaderVariableProto(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:ShaderVariableProto)
}
ShaderVariableProto::ShaderVariableProto(const ShaderVariableProto& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ShaderVariableProto* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.fields_) { from._impl_.fields_ }, decltype(_impl_.name_) {}, decltype(_impl_.mapped_name_) {}, decltype(_impl_.struct_name_) {},
        decltype(_impl_.type_) {}, decltype(_impl_.precision_) {}, decltype(_impl_.array_size_) {}, decltype(_impl_.static_use_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_name()) {
        _this->_impl_.name_.Set(from._internal_name(), _this->GetArenaForAllocation());
    }
    _impl_.mapped_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mapped_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_mapped_name()) {
        _this->_impl_.mapped_name_.Set(from._internal_mapped_name(), _this->GetArenaForAllocation());
    }
    _impl_.struct_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.struct_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_struct_name()) {
        _this->_impl_.struct_name_.Set(from._internal_struct_name(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.type_, &from._impl_.type_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.static_use_) - reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.static_use_));
    // @@protoc_insertion_point(copy_constructor:ShaderVariableProto)
}

inline void ShaderVariableProto::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.fields_) { arena }, decltype(_impl_.name_) {},
        decltype(_impl_.mapped_name_) {}, decltype(_impl_.struct_name_) {}, decltype(_impl_.type_) { 0u }, decltype(_impl_.precision_) { 0u },
        decltype(_impl_.array_size_) { 0u }, decltype(_impl_.static_use_) { false } };
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mapped_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mapped_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.struct_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.struct_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ShaderVariableProto::~ShaderVariableProto()
{
    // @@protoc_insertion_point(destructor:ShaderVariableProto)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ShaderVariableProto::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.fields_.~RepeatedPtrField();
    _impl_.name_.Destroy();
    _impl_.mapped_name_.Destroy();
    _impl_.struct_name_.Destroy();
}

void ShaderVariableProto::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ShaderVariableProto::Clear()
{
    // @@protoc_insertion_point(message_clear_start:ShaderVariableProto)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.fields_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.name_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.mapped_name_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            _impl_.struct_name_.ClearNonDefaultToEmpty();
        }
    }
    if (cached_has_bits & 0x00000078u) {
        ::memset(&_impl_.type_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.static_use_) - reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.static_use_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ShaderVariableProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional uint32 type = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_type(&has_bits);
                _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional uint32 precision = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_precision(&has_bits);
                _impl_.precision_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string name = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string mapped_name = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                auto str = _internal_mutable_mapped_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional uint32 array_size = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
                _Internal::set_has_array_size(&has_bits);
                _impl_.array_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool static_use = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
                _Internal::set_has_static_use(&has_bits);
                _impl_.static_use_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .ShaderVariableProto fields = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_fields(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional string struct_name = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
                auto str = _internal_mutable_struct_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ShaderVariableProto::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:ShaderVariableProto)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional uint32 type = 1;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_type(), target);
    }

    // optional uint32 precision = 2;
    if (cached_has_bits & 0x00000010u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_precision(), target);
    }

    // optional string name = 3;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(3, this->_internal_name(), target);
    }

    // optional string mapped_name = 4;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(4, this->_internal_mapped_name(), target);
    }

    // optional uint32 array_size = 5;
    if (cached_has_bits & 0x00000020u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_array_size(), target);
    }

    // optional bool static_use = 6;
    if (cached_has_bits & 0x00000040u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_static_use(), target);
    }

    // repeated .ShaderVariableProto fields = 7;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_fields_size()); i < n; i++) {
        const auto& repfield = this->_internal_fields(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
    }

    // optional string struct_name = 8;
    if (cached_has_bits & 0x00000004u) {
        target = stream->WriteStringMaybeAliased(8, this->_internal_struct_name(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:ShaderVariableProto)
    return target;
}

size_t ShaderVariableProto::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:ShaderVariableProto)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .ShaderVariableProto fields = 7;
    total_size += 1UL * this->_internal_fields_size();
    for (const auto& msg : this->_impl_.fields_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000007fu) {
        // optional string name = 3;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_name());
        }

        // optional string mapped_name = 4;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_mapped_name());
        }

        // optional string struct_name = 8;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_struct_name());
        }

        // optional uint32 type = 1;
        if (cached_has_bits & 0x00000008u) {
            total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_type());
        }

        // optional uint32 precision = 2;
        if (cached_has_bits & 0x00000010u) {
            total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_precision());
        }

        // optional uint32 array_size = 5;
        if (cached_has_bits & 0x00000020u) {
            total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_array_size());
        }

        // optional bool static_use = 6;
        if (cached_has_bits & 0x00000040u) {
            total_size += 1 + 1;
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ShaderVariableProto::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ShaderVariableProto*>(&from));
}

void ShaderVariableProto::MergeFrom(const ShaderVariableProto& from)
{
    ShaderVariableProto* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:ShaderVariableProto)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.fields_.MergeFrom(from._impl_.fields_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000007fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_name(from._internal_name());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_mapped_name(from._internal_mapped_name());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_set_struct_name(from._internal_struct_name());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.type_ = from._impl_.type_;
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_impl_.precision_ = from._impl_.precision_;
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_impl_.array_size_ = from._impl_.array_size_;
        }
        if (cached_has_bits & 0x00000040u) {
            _this->_impl_.static_use_ = from._impl_.static_use_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ShaderVariableProto::CopyFrom(const ShaderVariableProto& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:ShaderVariableProto)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ShaderVariableProto::IsInitialized() const
{
    return true;
}

void ShaderVariableProto::InternalSwap(ShaderVariableProto* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.fields_.InternalSwap(&other->_impl_.fields_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.name_, lhs_arena, &other->_impl_.name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.mapped_name_, lhs_arena, &other->_impl_.mapped_name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.struct_name_, lhs_arena, &other->_impl_.struct_name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(ShaderVariableProto, _impl_.static_use_) + sizeof(ShaderVariableProto::_impl_.static_use_)
        - PROTOBUF_FIELD_OFFSET(ShaderVariableProto, _impl_.type_)>(reinterpret_cast<char*>(&_impl_.type_), reinterpret_cast<char*>(&other->_impl_.type_));
}

std::string ShaderVariableProto::GetTypeName() const
{
    return "ShaderVariableProto";
}

// ===================================================================

class ShaderAttributeProto::_Internal {
public:
    using HasBits = decltype(std::declval<ShaderAttributeProto>()._impl_._has_bits_);
    static const ::ShaderVariableProto& basic(const ShaderAttributeProto* msg);
    static void set_has_basic(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_location(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

const ::ShaderVariableProto& ShaderAttributeProto::_Internal::basic(const ShaderAttributeProto* msg)
{
    return *msg->_impl_.basic_;
}
ShaderAttributeProto::ShaderAttributeProto(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:ShaderAttributeProto)
}
ShaderAttributeProto::ShaderAttributeProto(const ShaderAttributeProto& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ShaderAttributeProto* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.basic_) { nullptr },
        decltype(_impl_.location_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_basic()) {
        _this->_impl_.basic_ = new ::ShaderVariableProto(*from._impl_.basic_);
    }
    _this->_impl_.location_ = from._impl_.location_;
    // @@protoc_insertion_point(copy_constructor:ShaderAttributeProto)
}

inline void ShaderAttributeProto::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_)
        Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.basic_) { nullptr }, decltype(_impl_.location_) { 0 } };
}

ShaderAttributeProto::~ShaderAttributeProto()
{
    // @@protoc_insertion_point(destructor:ShaderAttributeProto)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ShaderAttributeProto::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (this != internal_default_instance())
        delete _impl_.basic_;
}

void ShaderAttributeProto::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ShaderAttributeProto::Clear()
{
    // @@protoc_insertion_point(message_clear_start:ShaderAttributeProto)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        GOOGLE_DCHECK(_impl_.basic_ != nullptr);
        _impl_.basic_->Clear();
    }
    _impl_.location_ = 0;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ShaderAttributeProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .ShaderVariableProto basic = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_basic(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 location = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_location(&has_bits);
                _impl_.location_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ShaderAttributeProto::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:ShaderAttributeProto)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .ShaderVariableProto basic = 1;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::basic(this), _Internal::basic(this).GetCachedSize(), target, stream);
    }

    // optional int32 location = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_location(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:ShaderAttributeProto)
    return target;
}

size_t ShaderAttributeProto::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:ShaderAttributeProto)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional .ShaderVariableProto basic = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.basic_);
        }

        // optional int32 location = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_location());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ShaderAttributeProto::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ShaderAttributeProto*>(&from));
}

void ShaderAttributeProto::MergeFrom(const ShaderAttributeProto& from)
{
    ShaderAttributeProto* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:ShaderAttributeProto)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_mutable_basic()->::ShaderVariableProto::MergeFrom(from._internal_basic());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.location_ = from._impl_.location_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ShaderAttributeProto::CopyFrom(const ShaderAttributeProto& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:ShaderAttributeProto)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ShaderAttributeProto::IsInitialized() const
{
    return true;
}

void ShaderAttributeProto::InternalSwap(ShaderAttributeProto* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(ShaderAttributeProto, _impl_.location_) + sizeof(ShaderAttributeProto::_impl_.location_)
        - PROTOBUF_FIELD_OFFSET(ShaderAttributeProto, _impl_.basic_)>(reinterpret_cast<char*>(&_impl_.basic_), reinterpret_cast<char*>(&other->_impl_.basic_));
}

std::string ShaderAttributeProto::GetTypeName() const
{
    return "ShaderAttributeProto";
}

// ===================================================================

class ShaderUniformProto::_Internal {
public:
    using HasBits = decltype(std::declval<ShaderUniformProto>()._impl_._has_bits_);
    static const ::ShaderVariableProto& basic(const ShaderUniformProto* msg);
    static void set_has_basic(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

const ::ShaderVariableProto& ShaderUniformProto::_Internal::basic(const ShaderUniformProto* msg)
{
    return *msg->_impl_.basic_;
}
ShaderUniformProto::ShaderUniformProto(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:ShaderUniformProto)
}
ShaderUniformProto::ShaderUniformProto(const ShaderUniformProto& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ShaderUniformProto* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.basic_) { nullptr } };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_basic()) {
        _this->_impl_.basic_ = new ::ShaderVariableProto(*from._impl_.basic_);
    }
    // @@protoc_insertion_point(copy_constructor:ShaderUniformProto)
}

inline void ShaderUniformProto::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.basic_) { nullptr } };
}

ShaderUniformProto::~ShaderUniformProto()
{
    // @@protoc_insertion_point(destructor:ShaderUniformProto)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ShaderUniformProto::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (this != internal_default_instance())
        delete _impl_.basic_;
}

void ShaderUniformProto::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ShaderUniformProto::Clear()
{
    // @@protoc_insertion_point(message_clear_start:ShaderUniformProto)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        GOOGLE_DCHECK(_impl_.basic_ != nullptr);
        _impl_.basic_->Clear();
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ShaderUniformProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .ShaderVariableProto basic = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_basic(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ShaderUniformProto::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:ShaderUniformProto)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .ShaderVariableProto basic = 1;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::basic(this), _Internal::basic(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:ShaderUniformProto)
    return target;
}

size_t ShaderUniformProto::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:ShaderUniformProto)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional .ShaderVariableProto basic = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.basic_);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ShaderUniformProto::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ShaderUniformProto*>(&from));
}

void ShaderUniformProto::MergeFrom(const ShaderUniformProto& from)
{
    ShaderUniformProto* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:ShaderUniformProto)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_basic()) {
        _this->_internal_mutable_basic()->::ShaderVariableProto::MergeFrom(from._internal_basic());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ShaderUniformProto::CopyFrom(const ShaderUniformProto& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:ShaderUniformProto)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ShaderUniformProto::IsInitialized() const
{
    return true;
}

void ShaderUniformProto::InternalSwap(ShaderUniformProto* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    swap(_impl_.basic_, other->_impl_.basic_);
}

std::string ShaderUniformProto::GetTypeName() const
{
    return "ShaderUniformProto";
}

// ===================================================================

class ShaderVaryingProto::_Internal {
public:
    using HasBits = decltype(std::declval<ShaderVaryingProto>()._impl_._has_bits_);
    static const ::ShaderVariableProto& basic(const ShaderVaryingProto* msg);
    static void set_has_basic(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_interpolation(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_is_invariant(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
};

const ::ShaderVariableProto& ShaderVaryingProto::_Internal::basic(const ShaderVaryingProto* msg)
{
    return *msg->_impl_.basic_;
}
ShaderVaryingProto::ShaderVaryingProto(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:ShaderVaryingProto)
}
ShaderVaryingProto::ShaderVaryingProto(const ShaderVaryingProto& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ShaderVaryingProto* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.basic_) { nullptr },
        decltype(_impl_.interpolation_) {}, decltype(_impl_.is_invariant_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_basic()) {
        _this->_impl_.basic_ = new ::ShaderVariableProto(*from._impl_.basic_);
    }
    ::memcpy(&_impl_.interpolation_, &from._impl_.interpolation_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_invariant_) - reinterpret_cast<char*>(&_impl_.interpolation_)) + sizeof(_impl_.is_invariant_));
    // @@protoc_insertion_point(copy_constructor:ShaderVaryingProto)
}

inline void ShaderVaryingProto::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.basic_) { nullptr },
        decltype(_impl_.interpolation_) { 0 }, decltype(_impl_.is_invariant_) { false } };
}

ShaderVaryingProto::~ShaderVaryingProto()
{
    // @@protoc_insertion_point(destructor:ShaderVaryingProto)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ShaderVaryingProto::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (this != internal_default_instance())
        delete _impl_.basic_;
}

void ShaderVaryingProto::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ShaderVaryingProto::Clear()
{
    // @@protoc_insertion_point(message_clear_start:ShaderVaryingProto)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        GOOGLE_DCHECK(_impl_.basic_ != nullptr);
        _impl_.basic_->Clear();
    }
    if (cached_has_bits & 0x00000006u) {
        ::memset(&_impl_.interpolation_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_invariant_) - reinterpret_cast<char*>(&_impl_.interpolation_))
                + sizeof(_impl_.is_invariant_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ShaderVaryingProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .ShaderVariableProto basic = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_basic(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 interpolation = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_interpolation(&has_bits);
                _impl_.interpolation_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool is_invariant = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_is_invariant(&has_bits);
                _impl_.is_invariant_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ShaderVaryingProto::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:ShaderVaryingProto)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .ShaderVariableProto basic = 1;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::basic(this), _Internal::basic(this).GetCachedSize(), target, stream);
    }

    // optional int32 interpolation = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_interpolation(), target);
    }

    // optional bool is_invariant = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_is_invariant(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:ShaderVaryingProto)
    return target;
}

size_t ShaderVaryingProto::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:ShaderVaryingProto)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional .ShaderVariableProto basic = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.basic_);
        }

        // optional int32 interpolation = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_interpolation());
        }

        // optional bool is_invariant = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + 1;
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ShaderVaryingProto::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ShaderVaryingProto*>(&from));
}

void ShaderVaryingProto::MergeFrom(const ShaderVaryingProto& from)
{
    ShaderVaryingProto* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:ShaderVaryingProto)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_mutable_basic()->::ShaderVariableProto::MergeFrom(from._internal_basic());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.interpolation_ = from._impl_.interpolation_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.is_invariant_ = from._impl_.is_invariant_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ShaderVaryingProto::CopyFrom(const ShaderVaryingProto& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:ShaderVaryingProto)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ShaderVaryingProto::IsInitialized() const
{
    return true;
}

void ShaderVaryingProto::InternalSwap(ShaderVaryingProto* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(ShaderVaryingProto, _impl_.is_invariant_)
        + sizeof(ShaderVaryingProto::_impl_.is_invariant_) - PROTOBUF_FIELD_OFFSET(ShaderVaryingProto, _impl_.basic_)>(
        reinterpret_cast<char*>(&_impl_.basic_), reinterpret_cast<char*>(&other->_impl_.basic_));
}

std::string ShaderVaryingProto::GetTypeName() const
{
    return "ShaderVaryingProto";
}

// ===================================================================

class ShaderOutputVariableProto::_Internal {
public:
    using HasBits = decltype(std::declval<ShaderOutputVariableProto>()._impl_._has_bits_);
    static const ::ShaderVariableProto& basic(const ShaderOutputVariableProto* msg);
    static void set_has_basic(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_location(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

const ::ShaderVariableProto& ShaderOutputVariableProto::_Internal::basic(const ShaderOutputVariableProto* msg)
{
    return *msg->_impl_.basic_;
}
ShaderOutputVariableProto::ShaderOutputVariableProto(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:ShaderOutputVariableProto)
}
ShaderOutputVariableProto::ShaderOutputVariableProto(const ShaderOutputVariableProto& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ShaderOutputVariableProto* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.basic_) { nullptr },
        decltype(_impl_.location_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_basic()) {
        _this->_impl_.basic_ = new ::ShaderVariableProto(*from._impl_.basic_);
    }
    _this->_impl_.location_ = from._impl_.location_;
    // @@protoc_insertion_point(copy_constructor:ShaderOutputVariableProto)
}

inline void ShaderOutputVariableProto::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_)
        Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.basic_) { nullptr }, decltype(_impl_.location_) { 0 } };
}

ShaderOutputVariableProto::~ShaderOutputVariableProto()
{
    // @@protoc_insertion_point(destructor:ShaderOutputVariableProto)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ShaderOutputVariableProto::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (this != internal_default_instance())
        delete _impl_.basic_;
}

void ShaderOutputVariableProto::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ShaderOutputVariableProto::Clear()
{
    // @@protoc_insertion_point(message_clear_start:ShaderOutputVariableProto)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        GOOGLE_DCHECK(_impl_.basic_ != nullptr);
        _impl_.basic_->Clear();
    }
    _impl_.location_ = 0;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ShaderOutputVariableProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .ShaderVariableProto basic = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_basic(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 location = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_location(&has_bits);
                _impl_.location_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ShaderOutputVariableProto::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:ShaderOutputVariableProto)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .ShaderVariableProto basic = 1;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::basic(this), _Internal::basic(this).GetCachedSize(), target, stream);
    }

    // optional int32 location = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_location(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:ShaderOutputVariableProto)
    return target;
}

size_t ShaderOutputVariableProto::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:ShaderOutputVariableProto)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional .ShaderVariableProto basic = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.basic_);
        }

        // optional int32 location = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_location());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ShaderOutputVariableProto::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ShaderOutputVariableProto*>(&from));
}

void ShaderOutputVariableProto::MergeFrom(const ShaderOutputVariableProto& from)
{
    ShaderOutputVariableProto* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:ShaderOutputVariableProto)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_mutable_basic()->::ShaderVariableProto::MergeFrom(from._internal_basic());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.location_ = from._impl_.location_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ShaderOutputVariableProto::CopyFrom(const ShaderOutputVariableProto& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:ShaderOutputVariableProto)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ShaderOutputVariableProto::IsInitialized() const
{
    return true;
}

void ShaderOutputVariableProto::InternalSwap(ShaderOutputVariableProto* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(ShaderOutputVariableProto, _impl_.location_)
        + sizeof(ShaderOutputVariableProto::_impl_.location_) - PROTOBUF_FIELD_OFFSET(ShaderOutputVariableProto, _impl_.basic_)>(
        reinterpret_cast<char*>(&_impl_.basic_), reinterpret_cast<char*>(&other->_impl_.basic_));
}

std::string ShaderOutputVariableProto::GetTypeName() const
{
    return "ShaderOutputVariableProto";
}

// ===================================================================

class ShaderInterfaceBlockFieldProto::_Internal {
public:
    using HasBits = decltype(std::declval<ShaderInterfaceBlockFieldProto>()._impl_._has_bits_);
    static const ::ShaderVariableProto& basic(const ShaderInterfaceBlockFieldProto* msg);
    static void set_has_basic(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_is_row_major_layout(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

const ::ShaderVariableProto& ShaderInterfaceBlockFieldProto::_Internal::basic(const ShaderInterfaceBlockFieldProto* msg)
{
    return *msg->_impl_.basic_;
}
ShaderInterfaceBlockFieldProto::ShaderInterfaceBlockFieldProto(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:ShaderInterfaceBlockFieldProto)
}
ShaderInterfaceBlockFieldProto::ShaderInterfaceBlockFieldProto(const ShaderInterfaceBlockFieldProto& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ShaderInterfaceBlockFieldProto* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.basic_) { nullptr },
        decltype(_impl_.is_row_major_layout_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_basic()) {
        _this->_impl_.basic_ = new ::ShaderVariableProto(*from._impl_.basic_);
    }
    _this->_impl_.is_row_major_layout_ = from._impl_.is_row_major_layout_;
    // @@protoc_insertion_point(copy_constructor:ShaderInterfaceBlockFieldProto)
}

inline void ShaderInterfaceBlockFieldProto::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.basic_) { nullptr },
        decltype(_impl_.is_row_major_layout_) { false } };
}

ShaderInterfaceBlockFieldProto::~ShaderInterfaceBlockFieldProto()
{
    // @@protoc_insertion_point(destructor:ShaderInterfaceBlockFieldProto)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ShaderInterfaceBlockFieldProto::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (this != internal_default_instance())
        delete _impl_.basic_;
}

void ShaderInterfaceBlockFieldProto::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ShaderInterfaceBlockFieldProto::Clear()
{
    // @@protoc_insertion_point(message_clear_start:ShaderInterfaceBlockFieldProto)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        GOOGLE_DCHECK(_impl_.basic_ != nullptr);
        _impl_.basic_->Clear();
    }
    _impl_.is_row_major_layout_ = false;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ShaderInterfaceBlockFieldProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .ShaderVariableProto basic = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_basic(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool is_row_major_layout = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_is_row_major_layout(&has_bits);
                _impl_.is_row_major_layout_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ShaderInterfaceBlockFieldProto::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:ShaderInterfaceBlockFieldProto)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .ShaderVariableProto basic = 1;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::basic(this), _Internal::basic(this).GetCachedSize(), target, stream);
    }

    // optional bool is_row_major_layout = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_is_row_major_layout(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:ShaderInterfaceBlockFieldProto)
    return target;
}

size_t ShaderInterfaceBlockFieldProto::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:ShaderInterfaceBlockFieldProto)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional .ShaderVariableProto basic = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.basic_);
        }

        // optional bool is_row_major_layout = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + 1;
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ShaderInterfaceBlockFieldProto::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ShaderInterfaceBlockFieldProto*>(&from));
}

void ShaderInterfaceBlockFieldProto::MergeFrom(const ShaderInterfaceBlockFieldProto& from)
{
    ShaderInterfaceBlockFieldProto* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:ShaderInterfaceBlockFieldProto)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_mutable_basic()->::ShaderVariableProto::MergeFrom(from._internal_basic());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.is_row_major_layout_ = from._impl_.is_row_major_layout_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ShaderInterfaceBlockFieldProto::CopyFrom(const ShaderInterfaceBlockFieldProto& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:ShaderInterfaceBlockFieldProto)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ShaderInterfaceBlockFieldProto::IsInitialized() const
{
    return true;
}

void ShaderInterfaceBlockFieldProto::InternalSwap(ShaderInterfaceBlockFieldProto* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(ShaderInterfaceBlockFieldProto, _impl_.is_row_major_layout_)
        + sizeof(ShaderInterfaceBlockFieldProto::_impl_.is_row_major_layout_) - PROTOBUF_FIELD_OFFSET(ShaderInterfaceBlockFieldProto, _impl_.basic_)>(
        reinterpret_cast<char*>(&_impl_.basic_), reinterpret_cast<char*>(&other->_impl_.basic_));
}

std::string ShaderInterfaceBlockFieldProto::GetTypeName() const
{
    return "ShaderInterfaceBlockFieldProto";
}

// ===================================================================

class ShaderInterfaceBlockProto::_Internal {
public:
    using HasBits = decltype(std::declval<ShaderInterfaceBlockProto>()._impl_._has_bits_);
    static void set_has_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_mapped_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_instance_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_array_size(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_layout(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static void set_has_is_row_major_layout(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
    static void set_has_static_use(HasBits* has_bits)
    {
        (*has_bits)[0] |= 64u;
    }
};

ShaderInterfaceBlockProto::ShaderInterfaceBlockProto(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:ShaderInterfaceBlockProto)
}
ShaderInterfaceBlockProto::ShaderInterfaceBlockProto(const ShaderInterfaceBlockProto& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ShaderInterfaceBlockProto* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.fields_) { from._impl_.fields_ }, decltype(_impl_.name_) {}, decltype(_impl_.mapped_name_) {}, decltype(_impl_.instance_name_) {},
        decltype(_impl_.array_size_) {}, decltype(_impl_.layout_) {}, decltype(_impl_.is_row_major_layout_) {}, decltype(_impl_.static_use_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_name()) {
        _this->_impl_.name_.Set(from._internal_name(), _this->GetArenaForAllocation());
    }
    _impl_.mapped_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mapped_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_mapped_name()) {
        _this->_impl_.mapped_name_.Set(from._internal_mapped_name(), _this->GetArenaForAllocation());
    }
    _impl_.instance_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.instance_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_instance_name()) {
        _this->_impl_.instance_name_.Set(from._internal_instance_name(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.array_size_, &from._impl_.array_size_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.static_use_) - reinterpret_cast<char*>(&_impl_.array_size_)) + sizeof(_impl_.static_use_));
    // @@protoc_insertion_point(copy_constructor:ShaderInterfaceBlockProto)
}

inline void ShaderInterfaceBlockProto::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.fields_) { arena }, decltype(_impl_.name_) {},
        decltype(_impl_.mapped_name_) {}, decltype(_impl_.instance_name_) {}, decltype(_impl_.array_size_) { 0u }, decltype(_impl_.layout_) { 0 },
        decltype(_impl_.is_row_major_layout_) { false }, decltype(_impl_.static_use_) { false } };
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mapped_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mapped_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.instance_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.instance_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ShaderInterfaceBlockProto::~ShaderInterfaceBlockProto()
{
    // @@protoc_insertion_point(destructor:ShaderInterfaceBlockProto)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ShaderInterfaceBlockProto::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.fields_.~RepeatedPtrField();
    _impl_.name_.Destroy();
    _impl_.mapped_name_.Destroy();
    _impl_.instance_name_.Destroy();
}

void ShaderInterfaceBlockProto::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ShaderInterfaceBlockProto::Clear()
{
    // @@protoc_insertion_point(message_clear_start:ShaderInterfaceBlockProto)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.fields_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.name_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.mapped_name_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            _impl_.instance_name_.ClearNonDefaultToEmpty();
        }
    }
    if (cached_has_bits & 0x00000078u) {
        ::memset(&_impl_.array_size_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.static_use_) - reinterpret_cast<char*>(&_impl_.array_size_)) + sizeof(_impl_.static_use_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ShaderInterfaceBlockProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string name = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string mapped_name = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_mapped_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string instance_name = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_instance_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional uint32 array_size = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _Internal::set_has_array_size(&has_bits);
                _impl_.array_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 layout = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
                _Internal::set_has_layout(&has_bits);
                _impl_.layout_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool is_row_major_layout = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
                _Internal::set_has_is_row_major_layout(&has_bits);
                _impl_.is_row_major_layout_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool static_use = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
                _Internal::set_has_static_use(&has_bits);
                _impl_.static_use_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .ShaderInterfaceBlockFieldProto fields = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_fields(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ShaderInterfaceBlockProto::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:ShaderInterfaceBlockProto)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_name(), target);
    }

    // optional string mapped_name = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_mapped_name(), target);
    }

    // optional string instance_name = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->WriteStringMaybeAliased(3, this->_internal_instance_name(), target);
    }

    // optional uint32 array_size = 4;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_array_size(), target);
    }

    // optional int32 layout = 5;
    if (cached_has_bits & 0x00000010u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_layout(), target);
    }

    // optional bool is_row_major_layout = 6;
    if (cached_has_bits & 0x00000020u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_is_row_major_layout(), target);
    }

    // optional bool static_use = 7;
    if (cached_has_bits & 0x00000040u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_static_use(), target);
    }

    // repeated .ShaderInterfaceBlockFieldProto fields = 8;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_fields_size()); i < n; i++) {
        const auto& repfield = this->_internal_fields(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(8, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:ShaderInterfaceBlockProto)
    return target;
}

size_t ShaderInterfaceBlockProto::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:ShaderInterfaceBlockProto)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .ShaderInterfaceBlockFieldProto fields = 8;
    total_size += 1UL * this->_internal_fields_size();
    for (const auto& msg : this->_impl_.fields_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000007fu) {
        // optional string name = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_name());
        }

        // optional string mapped_name = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_mapped_name());
        }

        // optional string instance_name = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_instance_name());
        }

        // optional uint32 array_size = 4;
        if (cached_has_bits & 0x00000008u) {
            total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_array_size());
        }

        // optional int32 layout = 5;
        if (cached_has_bits & 0x00000010u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_layout());
        }

        // optional bool is_row_major_layout = 6;
        if (cached_has_bits & 0x00000020u) {
            total_size += 1 + 1;
        }

        // optional bool static_use = 7;
        if (cached_has_bits & 0x00000040u) {
            total_size += 1 + 1;
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ShaderInterfaceBlockProto::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ShaderInterfaceBlockProto*>(&from));
}

void ShaderInterfaceBlockProto::MergeFrom(const ShaderInterfaceBlockProto& from)
{
    ShaderInterfaceBlockProto* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:ShaderInterfaceBlockProto)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.fields_.MergeFrom(from._impl_.fields_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000007fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_name(from._internal_name());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_mapped_name(from._internal_mapped_name());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_set_instance_name(from._internal_instance_name());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.array_size_ = from._impl_.array_size_;
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_impl_.layout_ = from._impl_.layout_;
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_impl_.is_row_major_layout_ = from._impl_.is_row_major_layout_;
        }
        if (cached_has_bits & 0x00000040u) {
            _this->_impl_.static_use_ = from._impl_.static_use_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ShaderInterfaceBlockProto::CopyFrom(const ShaderInterfaceBlockProto& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:ShaderInterfaceBlockProto)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ShaderInterfaceBlockProto::IsInitialized() const
{
    return true;
}

void ShaderInterfaceBlockProto::InternalSwap(ShaderInterfaceBlockProto* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.fields_.InternalSwap(&other->_impl_.fields_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.name_, lhs_arena, &other->_impl_.name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.mapped_name_, lhs_arena, &other->_impl_.mapped_name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.instance_name_, lhs_arena, &other->_impl_.instance_name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(ShaderInterfaceBlockProto, _impl_.static_use_)
        + sizeof(ShaderInterfaceBlockProto::_impl_.static_use_) - PROTOBUF_FIELD_OFFSET(ShaderInterfaceBlockProto, _impl_.array_size_)>(
        reinterpret_cast<char*>(&_impl_.array_size_), reinterpret_cast<char*>(&other->_impl_.array_size_));
}

std::string ShaderInterfaceBlockProto::GetTypeName() const
{
    return "ShaderInterfaceBlockProto";
}

// ===================================================================

class ShaderProto::_Internal {
public:
    using HasBits = decltype(std::declval<ShaderProto>()._impl_._has_bits_);
    static void set_has_sha(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

ShaderProto::ShaderProto(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:ShaderProto)
}
ShaderProto::ShaderProto(const ShaderProto& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ShaderProto* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.attribs_) { from._impl_.attribs_ }, decltype(_impl_.uniforms_) { from._impl_.uniforms_ },
        decltype(_impl_.varyings_) { from._impl_.varyings_ }, decltype(_impl_.output_variables_) { from._impl_.output_variables_ },
        decltype(_impl_.interface_blocks_) { from._impl_.interface_blocks_ }, decltype(_impl_.sha_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.sha_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sha_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_sha()) {
        _this->_impl_.sha_.Set(from._internal_sha(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:ShaderProto)
}

inline void ShaderProto::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.attribs_) { arena },
        decltype(_impl_.uniforms_) { arena }, decltype(_impl_.varyings_) { arena }, decltype(_impl_.output_variables_) { arena },
        decltype(_impl_.interface_blocks_) { arena }, decltype(_impl_.sha_) {} };
    _impl_.sha_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sha_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ShaderProto::~ShaderProto()
{
    // @@protoc_insertion_point(destructor:ShaderProto)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ShaderProto::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.attribs_.~RepeatedPtrField();
    _impl_.uniforms_.~RepeatedPtrField();
    _impl_.varyings_.~RepeatedPtrField();
    _impl_.output_variables_.~RepeatedPtrField();
    _impl_.interface_blocks_.~RepeatedPtrField();
    _impl_.sha_.Destroy();
}

void ShaderProto::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ShaderProto::Clear()
{
    // @@protoc_insertion_point(message_clear_start:ShaderProto)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.attribs_.Clear();
    _impl_.uniforms_.Clear();
    _impl_.varyings_.Clear();
    _impl_.output_variables_.Clear();
    _impl_.interface_blocks_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.sha_.ClearNonDefaultToEmpty();
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ShaderProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional bytes sha = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_sha();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .ShaderAttributeProto attribs = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_attribs(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
            } else
                goto handle_unusual;
            continue;
        // repeated .ShaderUniformProto uniforms = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_uniforms(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
            } else
                goto handle_unusual;
            continue;
        // repeated .ShaderVaryingProto varyings = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_varyings(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
            } else
                goto handle_unusual;
            continue;
        // repeated .ShaderOutputVariableProto output_variables = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_output_variables(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
            } else
                goto handle_unusual;
            continue;
        // repeated .ShaderInterfaceBlockProto interface_blocks = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_interface_blocks(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ShaderProto::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:ShaderProto)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional bytes sha = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteBytesMaybeAliased(1, this->_internal_sha(), target);
    }

    // repeated .ShaderAttributeProto attribs = 2;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_attribs_size()); i < n; i++) {
        const auto& repfield = this->_internal_attribs(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
    }

    // repeated .ShaderUniformProto uniforms = 3;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_uniforms_size()); i < n; i++) {
        const auto& repfield = this->_internal_uniforms(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
    }

    // repeated .ShaderVaryingProto varyings = 4;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_varyings_size()); i < n; i++) {
        const auto& repfield = this->_internal_varyings(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
    }

    // repeated .ShaderOutputVariableProto output_variables = 5;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_output_variables_size()); i < n; i++) {
        const auto& repfield = this->_internal_output_variables(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
    }

    // repeated .ShaderInterfaceBlockProto interface_blocks = 6;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_interface_blocks_size()); i < n; i++) {
        const auto& repfield = this->_internal_interface_blocks(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:ShaderProto)
    return target;
}

size_t ShaderProto::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:ShaderProto)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .ShaderAttributeProto attribs = 2;
    total_size += 1UL * this->_internal_attribs_size();
    for (const auto& msg : this->_impl_.attribs_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // repeated .ShaderUniformProto uniforms = 3;
    total_size += 1UL * this->_internal_uniforms_size();
    for (const auto& msg : this->_impl_.uniforms_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // repeated .ShaderVaryingProto varyings = 4;
    total_size += 1UL * this->_internal_varyings_size();
    for (const auto& msg : this->_impl_.varyings_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // repeated .ShaderOutputVariableProto output_variables = 5;
    total_size += 1UL * this->_internal_output_variables_size();
    for (const auto& msg : this->_impl_.output_variables_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // repeated .ShaderInterfaceBlockProto interface_blocks = 6;
    total_size += 1UL * this->_internal_interface_blocks_size();
    for (const auto& msg : this->_impl_.interface_blocks_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // optional bytes sha = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_sha());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ShaderProto::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ShaderProto*>(&from));
}

void ShaderProto::MergeFrom(const ShaderProto& from)
{
    ShaderProto* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:ShaderProto)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.attribs_.MergeFrom(from._impl_.attribs_);
    _this->_impl_.uniforms_.MergeFrom(from._impl_.uniforms_);
    _this->_impl_.varyings_.MergeFrom(from._impl_.varyings_);
    _this->_impl_.output_variables_.MergeFrom(from._impl_.output_variables_);
    _this->_impl_.interface_blocks_.MergeFrom(from._impl_.interface_blocks_);
    if (from._internal_has_sha()) {
        _this->_internal_set_sha(from._internal_sha());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ShaderProto::CopyFrom(const ShaderProto& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:ShaderProto)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ShaderProto::IsInitialized() const
{
    return true;
}

void ShaderProto::InternalSwap(ShaderProto* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.attribs_.InternalSwap(&other->_impl_.attribs_);
    _impl_.uniforms_.InternalSwap(&other->_impl_.uniforms_);
    _impl_.varyings_.InternalSwap(&other->_impl_.varyings_);
    _impl_.output_variables_.InternalSwap(&other->_impl_.output_variables_);
    _impl_.interface_blocks_.InternalSwap(&other->_impl_.interface_blocks_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.sha_, lhs_arena, &other->_impl_.sha_, rhs_arena);
}

std::string ShaderProto::GetTypeName() const
{
    return "ShaderProto";
}

// ===================================================================

class GpuProgramProto::_Internal {
public:
    using HasBits = decltype(std::declval<GpuProgramProto>()._impl_._has_bits_);
    static void set_has_sha(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_format(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static void set_has_program(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_program_is_compressed(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
    static void set_has_program_decompressed_length(HasBits* has_bits)
    {
        (*has_bits)[0] |= 64u;
    }
    static const ::ShaderProto& vertex_shader(const GpuProgramProto* msg);
    static void set_has_vertex_shader(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static const ::ShaderProto& fragment_shader(const GpuProgramProto* msg);
    static void set_has_fragment_shader(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
};

const ::ShaderProto& GpuProgramProto::_Internal::vertex_shader(const GpuProgramProto* msg)
{
    return *msg->_impl_.vertex_shader_;
}
const ::ShaderProto& GpuProgramProto::_Internal::fragment_shader(const GpuProgramProto* msg)
{
    return *msg->_impl_.fragment_shader_;
}
GpuProgramProto::GpuProgramProto(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:GpuProgramProto)
}
GpuProgramProto::GpuProgramProto(const GpuProgramProto& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    GpuProgramProto* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.sha_) {},
        decltype(_impl_.program_) {}, decltype(_impl_.vertex_shader_) { nullptr }, decltype(_impl_.fragment_shader_) { nullptr }, decltype(_impl_.format_) {},
        decltype(_impl_.program_is_compressed_) {}, decltype(_impl_.program_decompressed_length_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.sha_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sha_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_sha()) {
        _this->_impl_.sha_.Set(from._internal_sha(), _this->GetArenaForAllocation());
    }
    _impl_.program_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.program_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_program()) {
        _this->_impl_.program_.Set(from._internal_program(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_vertex_shader()) {
        _this->_impl_.vertex_shader_ = new ::ShaderProto(*from._impl_.vertex_shader_);
    }
    if (from._internal_has_fragment_shader()) {
        _this->_impl_.fragment_shader_ = new ::ShaderProto(*from._impl_.fragment_shader_);
    }
    ::memcpy(&_impl_.format_, &from._impl_.format_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.program_decompressed_length_) - reinterpret_cast<char*>(&_impl_.format_))
            + sizeof(_impl_.program_decompressed_length_));
    // @@protoc_insertion_point(copy_constructor:GpuProgramProto)
}

inline void GpuProgramProto::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.sha_) {}, decltype(_impl_.program_) {},
        decltype(_impl_.vertex_shader_) { nullptr }, decltype(_impl_.fragment_shader_) { nullptr }, decltype(_impl_.format_) { 0u },
        decltype(_impl_.program_is_compressed_) { false }, decltype(_impl_.program_decompressed_length_) { 0u } };
    _impl_.sha_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sha_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.program_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.program_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GpuProgramProto::~GpuProgramProto()
{
    // @@protoc_insertion_point(destructor:GpuProgramProto)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void GpuProgramProto::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.sha_.Destroy();
    _impl_.program_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.vertex_shader_;
    if (this != internal_default_instance())
        delete _impl_.fragment_shader_;
}

void GpuProgramProto::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void GpuProgramProto::Clear()
{
    // @@protoc_insertion_point(message_clear_start:GpuProgramProto)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.sha_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.program_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            GOOGLE_DCHECK(_impl_.vertex_shader_ != nullptr);
            _impl_.vertex_shader_->Clear();
        }
        if (cached_has_bits & 0x00000008u) {
            GOOGLE_DCHECK(_impl_.fragment_shader_ != nullptr);
            _impl_.fragment_shader_->Clear();
        }
    }
    if (cached_has_bits & 0x00000070u) {
        ::memset(&_impl_.format_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.program_decompressed_length_) - reinterpret_cast<char*>(&_impl_.format_))
                + sizeof(_impl_.program_decompressed_length_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* GpuProgramProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional bytes sha = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_sha();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional uint32 format = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_format(&has_bits);
                _impl_.format_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bytes program = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_program();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .ShaderProto vertex_shader = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr = ctx->ParseMessage(_internal_mutable_vertex_shader(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .ShaderProto fragment_shader = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                ptr = ctx->ParseMessage(_internal_mutable_fragment_shader(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool program_is_compressed = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
                _Internal::set_has_program_is_compressed(&has_bits);
                _impl_.program_is_compressed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional uint32 program_decompressed_length = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
                _Internal::set_has_program_decompressed_length(&has_bits);
                _impl_.program_decompressed_length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* GpuProgramProto::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:GpuProgramProto)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional bytes sha = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteBytesMaybeAliased(1, this->_internal_sha(), target);
    }

    // optional uint32 format = 2;
    if (cached_has_bits & 0x00000010u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_format(), target);
    }

    // optional bytes program = 3;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteBytesMaybeAliased(3, this->_internal_program(), target);
    }

    // optional .ShaderProto vertex_shader = 4;
    if (cached_has_bits & 0x00000004u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            4, _Internal::vertex_shader(this), _Internal::vertex_shader(this).GetCachedSize(), target, stream);
    }

    // optional .ShaderProto fragment_shader = 5;
    if (cached_has_bits & 0x00000008u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            5, _Internal::fragment_shader(this), _Internal::fragment_shader(this).GetCachedSize(), target, stream);
    }

    // optional bool program_is_compressed = 6;
    if (cached_has_bits & 0x00000020u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_program_is_compressed(), target);
    }

    // optional uint32 program_decompressed_length = 7;
    if (cached_has_bits & 0x00000040u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_program_decompressed_length(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:GpuProgramProto)
    return target;
}

size_t GpuProgramProto::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:GpuProgramProto)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000007fu) {
        // optional bytes sha = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_sha());
        }

        // optional bytes program = 3;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_program());
        }

        // optional .ShaderProto vertex_shader = 4;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.vertex_shader_);
        }

        // optional .ShaderProto fragment_shader = 5;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.fragment_shader_);
        }

        // optional uint32 format = 2;
        if (cached_has_bits & 0x00000010u) {
            total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_format());
        }

        // optional bool program_is_compressed = 6;
        if (cached_has_bits & 0x00000020u) {
            total_size += 1 + 1;
        }

        // optional uint32 program_decompressed_length = 7;
        if (cached_has_bits & 0x00000040u) {
            total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_program_decompressed_length());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void GpuProgramProto::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const GpuProgramProto*>(&from));
}

void GpuProgramProto::MergeFrom(const GpuProgramProto& from)
{
    GpuProgramProto* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:GpuProgramProto)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000007fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_sha(from._internal_sha());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_program(from._internal_program());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_mutable_vertex_shader()->::ShaderProto::MergeFrom(from._internal_vertex_shader());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_mutable_fragment_shader()->::ShaderProto::MergeFrom(from._internal_fragment_shader());
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_impl_.format_ = from._impl_.format_;
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_impl_.program_is_compressed_ = from._impl_.program_is_compressed_;
        }
        if (cached_has_bits & 0x00000040u) {
            _this->_impl_.program_decompressed_length_ = from._impl_.program_decompressed_length_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GpuProgramProto::CopyFrom(const GpuProgramProto& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:GpuProgramProto)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool GpuProgramProto::IsInitialized() const
{
    return true;
}

void GpuProgramProto::InternalSwap(GpuProgramProto* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.sha_, lhs_arena, &other->_impl_.sha_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.program_, lhs_arena, &other->_impl_.program_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(GpuProgramProto, _impl_.program_decompressed_length_)
        + sizeof(GpuProgramProto::_impl_.program_decompressed_length_) - PROTOBUF_FIELD_OFFSET(GpuProgramProto, _impl_.vertex_shader_)>(
        reinterpret_cast<char*>(&_impl_.vertex_shader_), reinterpret_cast<char*>(&other->_impl_.vertex_shader_));
}

std::string GpuProgramProto::GetTypeName() const
{
    return "GpuProgramProto";
}

// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template <> PROTOBUF_NOINLINE ::ShaderVariableProto* Arena::CreateMaybeMessage<::ShaderVariableProto>(Arena* arena)
{
    return Arena::CreateMessageInternal<::ShaderVariableProto>(arena);
}
template <> PROTOBUF_NOINLINE ::ShaderAttributeProto* Arena::CreateMaybeMessage<::ShaderAttributeProto>(Arena* arena)
{
    return Arena::CreateMessageInternal<::ShaderAttributeProto>(arena);
}
template <> PROTOBUF_NOINLINE ::ShaderUniformProto* Arena::CreateMaybeMessage<::ShaderUniformProto>(Arena* arena)
{
    return Arena::CreateMessageInternal<::ShaderUniformProto>(arena);
}
template <> PROTOBUF_NOINLINE ::ShaderVaryingProto* Arena::CreateMaybeMessage<::ShaderVaryingProto>(Arena* arena)
{
    return Arena::CreateMessageInternal<::ShaderVaryingProto>(arena);
}
template <> PROTOBUF_NOINLINE ::ShaderOutputVariableProto* Arena::CreateMaybeMessage<::ShaderOutputVariableProto>(Arena* arena)
{
    return Arena::CreateMessageInternal<::ShaderOutputVariableProto>(arena);
}
template <> PROTOBUF_NOINLINE ::ShaderInterfaceBlockFieldProto* Arena::CreateMaybeMessage<::ShaderInterfaceBlockFieldProto>(Arena* arena)
{
    return Arena::CreateMessageInternal<::ShaderInterfaceBlockFieldProto>(arena);
}
template <> PROTOBUF_NOINLINE ::ShaderInterfaceBlockProto* Arena::CreateMaybeMessage<::ShaderInterfaceBlockProto>(Arena* arena)
{
    return Arena::CreateMessageInternal<::ShaderInterfaceBlockProto>(arena);
}
template <> PROTOBUF_NOINLINE ::ShaderProto* Arena::CreateMaybeMessage<::ShaderProto>(Arena* arena)
{
    return Arena::CreateMessageInternal<::ShaderProto>(arena);
}
template <> PROTOBUF_NOINLINE ::GpuProgramProto* Arena::CreateMaybeMessage<::GpuProgramProto>(Arena* arena)
{
    return Arena::CreateMessageInternal<::GpuProgramProto>(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
