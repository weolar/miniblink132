// gpu/ipc/common/gpu_info.mojom-blink.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef GPU_IPC_COMMON_GPU_INFO_MOJOM_BLINK_H_
#define GPU_IPC_COMMON_GPU_INFO_MOJOM_BLINK_H_

#include <stdint.h>

#include <limits>
#include <optional>
#include <type_traits>
#include <utility>

#include "base/types/cxx23_to_underlying.h"
#include "mojo/public/cpp/bindings/clone_traits.h"
#include "mojo/public/cpp/bindings/equals_traits.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/struct_ptr.h"
#include "mojo/public/cpp/bindings/struct_traits.h"
#include "mojo/public/cpp/bindings/union_traits.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "gpu/ipc/common/gpu_info.mojom-features.h" // IWYU pragma: export
#include "gpu/ipc/common/gpu_info.mojom-shared.h" // IWYU pragma: export
#include "gpu/ipc/common/gpu_info.mojom-blink-forward.h" // IWYU pragma: export
#include "gpu/ipc/common/luid.mojom-blink.h"
#include "mojo/public/mojom/base/time.mojom-blink.h"
#include "ui/gfx/geometry/mojom/geometry.mojom-blink.h"
#include "ui/gl/mojom/gl_implementation.mojom-blink.h"
#include "ui/gl/mojom/gpu_preference.mojom-blink-forward.h"
#include "gpu/ipc/common/vulkan_info.mojom-blink.h"

#include "mojo/public/cpp/bindings/lib/wtf_clone_equals_util.h"
#include "mojo/public/cpp/bindings/lib/wtf_hash_util.h"
#include "third_party/blink/renderer/platform/wtf/hash_functions.h"
#include "third_party/blink/renderer/platform/wtf/text/wtf_string.h"

#include "third_party/blink/public/platform/web_common.h"
#if !BLINK_MOJO_IMPL && !INSIDE_BLINK
#error "File must only be imported inside blink"
#endif

namespace gpu::mojom::blink {

class BLINK_PLATFORM_EXPORT GpuDevice {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<GpuDevice, T>::value>;
    using DataView = GpuDeviceDataView;
    using Data_ = internal::GpuDevice_Data;

    template <typename... Args> static GpuDevicePtr New(Args&&... args)
    {
        return GpuDevicePtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static GpuDevicePtr From(const U& u)
    {
        return mojo::TypeConverter<GpuDevicePtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, GpuDevice>::Convert(*this);
    }

    GpuDevice()
    : vendor_id()
    , device_id()
    , sub_sys_id()
    , revision()
    , active()
    , vendor_string()
    , device_string()
    , driver_vendor()
    , driver_version()
    , luid()
    , gpu_preference()
{
}

    GpuDevice(uint32_t vendor_id_in, uint32_t device_id_in, uint32_t sub_sys_id_in, uint32_t revision_in, bool active_in,
    const WTF::String& vendor_string_in, const WTF::String& device_string_in, const WTF::String& driver_vendor_in, const WTF::String& driver_version_in,
    const ::CHROME_LUID& luid_in, ::gl::mojom::blink::GpuPreference gpu_preference_in)
    : vendor_id(std::move(vendor_id_in))
    , device_id(std::move(device_id_in))
    , sub_sys_id(std::move(sub_sys_id_in))
    , revision(std::move(revision_in))
    , active(std::move(active_in))
    , vendor_string(std::move(vendor_string_in))
    , device_string(std::move(device_string_in))
    , driver_vendor(std::move(driver_vendor_in))
    , driver_version(std::move(driver_version_in))
    , luid(std::move(luid_in))
    , gpu_preference(std::move(gpu_preference_in)){
}

    ~GpuDevice() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = GpuDevicePtr> GpuDevicePtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, GpuDevice::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, GpuDevice::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, GpuDevice::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<GpuDevice::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<GpuDevice::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(std::make_unique<internal::GpuDevice_UnserializedMessageContext<UserType, GpuDevice::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<GpuDevice::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return GpuDevice::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::GpuDevice_UnserializedMessageContext<UserType, GpuDevice::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<GpuDevice::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    uint32_t vendor_id;

    uint32_t device_id;

    uint32_t sub_sys_id;

    uint32_t revision;

    bool active;

    WTF::String vendor_string;

    WTF::String device_string;

    WTF::String driver_vendor;

    WTF::String driver_version;

    ::CHROME_LUID luid;

    ::gl::mojom::blink::GpuPreference gpu_preference;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, GpuDevice::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, GpuDevice::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, GpuDevice::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, GpuDevice::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class BLINK_PLATFORM_EXPORT VideoDecodeAcceleratorSupportedProfile {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<VideoDecodeAcceleratorSupportedProfile, T>::value>;
    using DataView = VideoDecodeAcceleratorSupportedProfileDataView;
    using Data_ = internal::VideoDecodeAcceleratorSupportedProfile_Data;

    template <typename... Args> static VideoDecodeAcceleratorSupportedProfilePtr New(Args&&... args)
    {
        return VideoDecodeAcceleratorSupportedProfilePtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static VideoDecodeAcceleratorSupportedProfilePtr From(const U& u)
    {
        return mojo::TypeConverter<VideoDecodeAcceleratorSupportedProfilePtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, VideoDecodeAcceleratorSupportedProfile>::Convert(*this);
    }

    VideoDecodeAcceleratorSupportedProfile()
    : profile()
    , max_resolution()
    , min_resolution()
    , encrypted_only()
{
}

    VideoDecodeAcceleratorSupportedProfile(
    VideoCodecProfile profile_in, const ::gfx::Size& max_resolution_in, const ::gfx::Size& min_resolution_in, bool encrypted_only_in)
    : profile(std::move(profile_in))
    , max_resolution(std::move(max_resolution_in))
    , min_resolution(std::move(min_resolution_in))
    , encrypted_only(std::move(encrypted_only_in)){
}

    ~VideoDecodeAcceleratorSupportedProfile() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = VideoDecodeAcceleratorSupportedProfilePtr> VideoDecodeAcceleratorSupportedProfilePtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, VideoDecodeAcceleratorSupportedProfile::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, VideoDecodeAcceleratorSupportedProfile::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, VideoDecodeAcceleratorSupportedProfile::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<VideoDecodeAcceleratorSupportedProfile::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<VideoDecodeAcceleratorSupportedProfile::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<
                internal::VideoDecodeAcceleratorSupportedProfile_UnserializedMessageContext<UserType, VideoDecodeAcceleratorSupportedProfile::DataView>>(
                0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<VideoDecodeAcceleratorSupportedProfile::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return VideoDecodeAcceleratorSupportedProfile::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<
            internal::VideoDecodeAcceleratorSupportedProfile_UnserializedMessageContext<UserType, VideoDecodeAcceleratorSupportedProfile::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<VideoDecodeAcceleratorSupportedProfile::DataView>(
            input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    VideoCodecProfile profile;

    ::gfx::Size max_resolution;

    ::gfx::Size min_resolution;

    bool encrypted_only;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, VideoDecodeAcceleratorSupportedProfile::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, VideoDecodeAcceleratorSupportedProfile::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, VideoDecodeAcceleratorSupportedProfile::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, VideoDecodeAcceleratorSupportedProfile::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class BLINK_PLATFORM_EXPORT VideoDecodeAcceleratorCapabilities {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<VideoDecodeAcceleratorCapabilities, T>::value>;
    using DataView = VideoDecodeAcceleratorCapabilitiesDataView;
    using Data_ = internal::VideoDecodeAcceleratorCapabilities_Data;

    template <typename... Args> static VideoDecodeAcceleratorCapabilitiesPtr New(Args&&... args)
    {
        return VideoDecodeAcceleratorCapabilitiesPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static VideoDecodeAcceleratorCapabilitiesPtr From(const U& u)
    {
        return mojo::TypeConverter<VideoDecodeAcceleratorCapabilitiesPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, VideoDecodeAcceleratorCapabilities>::Convert(*this);
    }

    VideoDecodeAcceleratorCapabilities()
    : supported_profiles()
    , flags()
{
}

    VideoDecodeAcceleratorCapabilities(
    WTF::Vector<VideoDecodeAcceleratorSupportedProfilePtr> supported_profiles_in, uint32_t flags_in)
    : supported_profiles(std::move(supported_profiles_in))
    , flags(std::move(flags_in)){
}

    VideoDecodeAcceleratorCapabilities(const VideoDecodeAcceleratorCapabilities&) = delete;
    VideoDecodeAcceleratorCapabilities& operator=(const VideoDecodeAcceleratorCapabilities&) = delete;

    ~VideoDecodeAcceleratorCapabilities() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = VideoDecodeAcceleratorCapabilitiesPtr> VideoDecodeAcceleratorCapabilitiesPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, VideoDecodeAcceleratorCapabilities::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, VideoDecodeAcceleratorCapabilities::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, VideoDecodeAcceleratorCapabilities::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<VideoDecodeAcceleratorCapabilities::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<VideoDecodeAcceleratorCapabilities::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::VideoDecodeAcceleratorCapabilities_UnserializedMessageContext<UserType, VideoDecodeAcceleratorCapabilities::DataView>>(
                0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<VideoDecodeAcceleratorCapabilities::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return VideoDecodeAcceleratorCapabilities::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<
            internal::VideoDecodeAcceleratorCapabilities_UnserializedMessageContext<UserType, VideoDecodeAcceleratorCapabilities::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<VideoDecodeAcceleratorCapabilities::DataView>(
            input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    WTF::Vector<VideoDecodeAcceleratorSupportedProfilePtr> supported_profiles;

    uint32_t flags;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, VideoDecodeAcceleratorCapabilities::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, VideoDecodeAcceleratorCapabilities::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, VideoDecodeAcceleratorCapabilities::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, VideoDecodeAcceleratorCapabilities::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class BLINK_PLATFORM_EXPORT VideoEncodeAcceleratorSupportedProfile {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<VideoEncodeAcceleratorSupportedProfile, T>::value>;
    using DataView = VideoEncodeAcceleratorSupportedProfileDataView;
    using Data_ = internal::VideoEncodeAcceleratorSupportedProfile_Data;

    template <typename... Args> static VideoEncodeAcceleratorSupportedProfilePtr New(Args&&... args)
    {
        return VideoEncodeAcceleratorSupportedProfilePtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static VideoEncodeAcceleratorSupportedProfilePtr From(const U& u)
    {
        return mojo::TypeConverter<VideoEncodeAcceleratorSupportedProfilePtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, VideoEncodeAcceleratorSupportedProfile>::Convert(*this);
    }

    VideoEncodeAcceleratorSupportedProfile()
    : profile()
    , min_resolution()
    , max_resolution()
    , max_framerate_numerator()
    , max_framerate_denominator()
{
}

    VideoEncodeAcceleratorSupportedProfile(VideoCodecProfile profile_in, const ::gfx::Size& min_resolution_in,
    const ::gfx::Size& max_resolution_in, uint32_t max_framerate_numerator_in, uint32_t max_framerate_denominator_in)
    : profile(std::move(profile_in))
    , min_resolution(std::move(min_resolution_in))
    , max_resolution(std::move(max_resolution_in))
    , max_framerate_numerator(std::move(max_framerate_numerator_in))
    , max_framerate_denominator(std::move(max_framerate_denominator_in)){
}

    ~VideoEncodeAcceleratorSupportedProfile() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = VideoEncodeAcceleratorSupportedProfilePtr> VideoEncodeAcceleratorSupportedProfilePtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, VideoEncodeAcceleratorSupportedProfile::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, VideoEncodeAcceleratorSupportedProfile::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, VideoEncodeAcceleratorSupportedProfile::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<VideoEncodeAcceleratorSupportedProfile::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<VideoEncodeAcceleratorSupportedProfile::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<
                internal::VideoEncodeAcceleratorSupportedProfile_UnserializedMessageContext<UserType, VideoEncodeAcceleratorSupportedProfile::DataView>>(
                0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<VideoEncodeAcceleratorSupportedProfile::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return VideoEncodeAcceleratorSupportedProfile::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<
            internal::VideoEncodeAcceleratorSupportedProfile_UnserializedMessageContext<UserType, VideoEncodeAcceleratorSupportedProfile::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<VideoEncodeAcceleratorSupportedProfile::DataView>(
            input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    VideoCodecProfile profile;

    ::gfx::Size min_resolution;

    ::gfx::Size max_resolution;

    uint32_t max_framerate_numerator;

    uint32_t max_framerate_denominator;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, VideoEncodeAcceleratorSupportedProfile::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, VideoEncodeAcceleratorSupportedProfile::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, VideoEncodeAcceleratorSupportedProfile::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, VideoEncodeAcceleratorSupportedProfile::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class BLINK_PLATFORM_EXPORT ImageDecodeAcceleratorSupportedProfile {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<ImageDecodeAcceleratorSupportedProfile, T>::value>;
    using DataView = ImageDecodeAcceleratorSupportedProfileDataView;
    using Data_ = internal::ImageDecodeAcceleratorSupportedProfile_Data;

    template <typename... Args> static ImageDecodeAcceleratorSupportedProfilePtr New(Args&&... args)
    {
        return ImageDecodeAcceleratorSupportedProfilePtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static ImageDecodeAcceleratorSupportedProfilePtr From(const U& u)
    {
        return mojo::TypeConverter<ImageDecodeAcceleratorSupportedProfilePtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, ImageDecodeAcceleratorSupportedProfile>::Convert(*this);
    }

    ImageDecodeAcceleratorSupportedProfile()
    : image_type()
    , min_encoded_dimensions()
    , max_encoded_dimensions()
    , subsamplings()
{
}

    ImageDecodeAcceleratorSupportedProfile(ImageDecodeAcceleratorType image_type_in,
    const ::gfx::Size& min_encoded_dimensions_in, const ::gfx::Size& max_encoded_dimensions_in, WTF::Vector<ImageDecodeAcceleratorSubsampling> subsamplings_in)
    : image_type(std::move(image_type_in))
    , min_encoded_dimensions(std::move(min_encoded_dimensions_in))
    , max_encoded_dimensions(std::move(max_encoded_dimensions_in))
    , subsamplings(std::move(subsamplings_in)){
}

    ~ImageDecodeAcceleratorSupportedProfile() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = ImageDecodeAcceleratorSupportedProfilePtr> ImageDecodeAcceleratorSupportedProfilePtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, ImageDecodeAcceleratorSupportedProfile::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, ImageDecodeAcceleratorSupportedProfile::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, ImageDecodeAcceleratorSupportedProfile::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<ImageDecodeAcceleratorSupportedProfile::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<ImageDecodeAcceleratorSupportedProfile::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<
                internal::ImageDecodeAcceleratorSupportedProfile_UnserializedMessageContext<UserType, ImageDecodeAcceleratorSupportedProfile::DataView>>(
                0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<ImageDecodeAcceleratorSupportedProfile::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return ImageDecodeAcceleratorSupportedProfile::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<
            internal::ImageDecodeAcceleratorSupportedProfile_UnserializedMessageContext<UserType, ImageDecodeAcceleratorSupportedProfile::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<ImageDecodeAcceleratorSupportedProfile::DataView>(
            input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    ImageDecodeAcceleratorType image_type;

    ::gfx::Size min_encoded_dimensions;

    ::gfx::Size max_encoded_dimensions;

    WTF::Vector<ImageDecodeAcceleratorSubsampling> subsamplings;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, ImageDecodeAcceleratorSupportedProfile::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, ImageDecodeAcceleratorSupportedProfile::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, ImageDecodeAcceleratorSupportedProfile::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, ImageDecodeAcceleratorSupportedProfile::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class BLINK_PLATFORM_EXPORT OverlayInfo {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<OverlayInfo, T>::value>;
    using DataView = OverlayInfoDataView;
    using Data_ = internal::OverlayInfo_Data;

    template <typename... Args> static OverlayInfoPtr New(Args&&... args)
    {
        return OverlayInfoPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static OverlayInfoPtr From(const U& u)
    {
        return mojo::TypeConverter<OverlayInfoPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, OverlayInfo>::Convert(*this);
    }

    OverlayInfo()
    : direct_composition()
    , supports_overlays()
    , yuy2_overlay_support()
    , nv12_overlay_support()
    , bgra8_overlay_support()
    , rgb10a2_overlay_support()
    , p010_overlay_support()
{
}

    OverlayInfo(bool direct_composition_in, bool supports_overlays_in, OverlaySupport yuy2_overlay_support_in, OverlaySupport nv12_overlay_support_in,
    OverlaySupport bgra8_overlay_support_in, OverlaySupport rgb10a2_overlay_support_in, OverlaySupport p010_overlay_support_in)
    : direct_composition(std::move(direct_composition_in))
    , supports_overlays(std::move(supports_overlays_in))
    , yuy2_overlay_support(std::move(yuy2_overlay_support_in))
    , nv12_overlay_support(std::move(nv12_overlay_support_in))
    , bgra8_overlay_support(std::move(bgra8_overlay_support_in))
    , rgb10a2_overlay_support(std::move(rgb10a2_overlay_support_in))
    , p010_overlay_support(std::move(p010_overlay_support_in)){
}

    ~OverlayInfo() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = OverlayInfoPtr> OverlayInfoPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, OverlayInfo::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, OverlayInfo::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, OverlayInfo::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<OverlayInfo::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<OverlayInfo::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(std::make_unique<internal::OverlayInfo_UnserializedMessageContext<UserType, OverlayInfo::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<OverlayInfo::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return OverlayInfo::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::OverlayInfo_UnserializedMessageContext<UserType, OverlayInfo::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<OverlayInfo::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    bool direct_composition;

    bool supports_overlays;

    OverlaySupport yuy2_overlay_support;

    OverlaySupport nv12_overlay_support;

    OverlaySupport bgra8_overlay_support;

    OverlaySupport rgb10a2_overlay_support;

    OverlaySupport p010_overlay_support;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, OverlayInfo::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, OverlayInfo::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, OverlayInfo::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, OverlayInfo::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class BLINK_PLATFORM_EXPORT GpuInfo {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<GpuInfo, T>::value>;
    using DataView = GpuInfoDataView;
    using Data_ = internal::GpuInfo_Data;

    template <typename... Args> static GpuInfoPtr New(Args&&... args)
    {
        return GpuInfoPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static GpuInfoPtr From(const U& u)
    {
        return mojo::TypeConverter<GpuInfoPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, GpuInfo>::Convert(*this);
    }

    GpuInfo()
    : initialization_time()
    , optimus()
    , amd_switchable()
    , gpu()
    , secondary_gpus()
    , npus()
    , pixel_shader_version()
    , vertex_shader_version()
    , max_msaa_samples()
    , machine_model_name()
    , machine_model_version()
    , display_type()
    , gl_version()
    , gl_vendor()
    , gl_renderer()
    , gl_extensions()
    , gl_ws_vendor()
    , gl_ws_version()
    , gl_ws_extensions()
    , gl_reset_notification_strategy()
    , gl_implementation_parts()
    , direct_rendering_version()
    , sandboxed()
    , in_process_gpu()
    , passthrough_cmd_decoder()
    , can_support_threaded_texture_mailbox()
    , directml_feature_level()
    , d3d12_feature_level()
    , vulkan_version()
    , overlay_info()
    , shared_image_d3d()
    , video_decode_accelerator_supported_profiles()
    , video_encode_accelerator_supported_profiles()
    , jpeg_decode_accelerator_supported()
    , image_decode_accelerator_supported_profiles()
    , subpixel_font_rendering()
    , visibility_callback_call_count()
    , hardware_supports_vulkan()
    , vulkan_info()
{
}

    GpuInfo(::base::TimeDelta initialization_time_in, bool optimus_in, bool amd_switchable_in, GpuDevicePtr gpu_in,
    WTF::Vector<GpuDevicePtr> secondary_gpus_in, WTF::Vector<GpuDevicePtr> npus_in, const WTF::String& pixel_shader_version_in,
    const WTF::String& vertex_shader_version_in, const WTF::String& max_msaa_samples_in, const WTF::String& machine_model_name_in,
    const WTF::String& machine_model_version_in, const WTF::String& display_type_in, const WTF::String& gl_version_in, const WTF::String& gl_vendor_in,
    const WTF::String& gl_renderer_in, const WTF::String& gl_extensions_in, const WTF::String& gl_ws_vendor_in, const WTF::String& gl_ws_version_in,
    const WTF::String& gl_ws_extensions_in, uint32_t gl_reset_notification_strategy_in, ::gl::mojom::blink::GLImplementationPartsPtr gl_implementation_parts_in,
    const WTF::String& direct_rendering_version_in, bool sandboxed_in, bool in_process_gpu_in, bool passthrough_cmd_decoder_in,
    bool can_support_threaded_texture_mailbox_in, uint32_t directml_feature_level_in, uint32_t d3d12_feature_level_in, uint32_t vulkan_version_in,
    OverlayInfoPtr overlay_info_in, bool shared_image_d3d_in,
    WTF::Vector<VideoDecodeAcceleratorSupportedProfilePtr> video_decode_accelerator_supported_profiles_in,
    WTF::Vector<VideoEncodeAcceleratorSupportedProfilePtr> video_encode_accelerator_supported_profiles_in, bool jpeg_decode_accelerator_supported_in,
    WTF::Vector<ImageDecodeAcceleratorSupportedProfilePtr> image_decode_accelerator_supported_profiles_in, bool subpixel_font_rendering_in,
    uint32_t visibility_callback_call_count_in, bool hardware_supports_vulkan_in, ::gpu::mojom::blink::VulkanInfoPtr vulkan_info_in)
    : initialization_time(std::move(initialization_time_in))
    , optimus(std::move(optimus_in))
    , amd_switchable(std::move(amd_switchable_in))
    , gpu(std::move(gpu_in))
    , secondary_gpus(std::move(secondary_gpus_in))
    , npus(std::move(npus_in))
    , pixel_shader_version(std::move(pixel_shader_version_in))
    , vertex_shader_version(std::move(vertex_shader_version_in))
    , max_msaa_samples(std::move(max_msaa_samples_in))
    , machine_model_name(std::move(machine_model_name_in))
    , machine_model_version(std::move(machine_model_version_in))
    , display_type(std::move(display_type_in))
    , gl_version(std::move(gl_version_in))
    , gl_vendor(std::move(gl_vendor_in))
    , gl_renderer(std::move(gl_renderer_in))
    , gl_extensions(std::move(gl_extensions_in))
    , gl_ws_vendor(std::move(gl_ws_vendor_in))
    , gl_ws_version(std::move(gl_ws_version_in))
    , gl_ws_extensions(std::move(gl_ws_extensions_in))
    , gl_reset_notification_strategy(std::move(gl_reset_notification_strategy_in))
    , gl_implementation_parts(std::move(gl_implementation_parts_in))
    , direct_rendering_version(std::move(direct_rendering_version_in))
    , sandboxed(std::move(sandboxed_in))
    , in_process_gpu(std::move(in_process_gpu_in))
    , passthrough_cmd_decoder(std::move(passthrough_cmd_decoder_in))
    , can_support_threaded_texture_mailbox(std::move(can_support_threaded_texture_mailbox_in))
    , directml_feature_level(std::move(directml_feature_level_in))
    , d3d12_feature_level(std::move(d3d12_feature_level_in))
    , vulkan_version(std::move(vulkan_version_in))
    , overlay_info(std::move(overlay_info_in))
    , shared_image_d3d(std::move(shared_image_d3d_in))
    , video_decode_accelerator_supported_profiles(std::move(video_decode_accelerator_supported_profiles_in))
    , video_encode_accelerator_supported_profiles(std::move(video_encode_accelerator_supported_profiles_in))
    , jpeg_decode_accelerator_supported(std::move(jpeg_decode_accelerator_supported_in))
    , image_decode_accelerator_supported_profiles(std::move(image_decode_accelerator_supported_profiles_in))
    , subpixel_font_rendering(std::move(subpixel_font_rendering_in))
    , visibility_callback_call_count(std::move(visibility_callback_call_count_in))
    , hardware_supports_vulkan(std::move(hardware_supports_vulkan_in))
    , vulkan_info(std::move(vulkan_info_in)){
}

    GpuInfo(const GpuInfo&) = delete;
    GpuInfo& operator=(const GpuInfo&) = delete;

    ~GpuInfo() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = GpuInfoPtr> GpuInfoPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, GpuInfo::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, GpuInfo::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, GpuInfo::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<GpuInfo::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<GpuInfo::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::GpuInfo_UnserializedMessageContext<UserType, GpuInfo::DataView>>(0, 0, std::move(input)), MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<GpuInfo::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return GpuInfo::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::GpuInfo_UnserializedMessageContext<UserType, GpuInfo::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<GpuInfo::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    ::base::TimeDelta initialization_time;

    bool optimus;

    bool amd_switchable;

    GpuDevicePtr gpu;

    WTF::Vector<GpuDevicePtr> secondary_gpus;

    WTF::Vector<GpuDevicePtr> npus;

    WTF::String pixel_shader_version;

    WTF::String vertex_shader_version;

    WTF::String max_msaa_samples;

    WTF::String machine_model_name;

    WTF::String machine_model_version;

    WTF::String display_type;

    WTF::String gl_version;

    WTF::String gl_vendor;

    WTF::String gl_renderer;

    WTF::String gl_extensions;

    WTF::String gl_ws_vendor;

    WTF::String gl_ws_version;

    WTF::String gl_ws_extensions;

    uint32_t gl_reset_notification_strategy;

    ::gl::mojom::blink::GLImplementationPartsPtr gl_implementation_parts;

    WTF::String direct_rendering_version;

    bool sandboxed;

    bool in_process_gpu;

    bool passthrough_cmd_decoder;

    bool can_support_threaded_texture_mailbox;

    uint32_t directml_feature_level;

    uint32_t d3d12_feature_level;

    uint32_t vulkan_version;

    OverlayInfoPtr overlay_info;

    bool shared_image_d3d;

    WTF::Vector<VideoDecodeAcceleratorSupportedProfilePtr> video_decode_accelerator_supported_profiles;

    WTF::Vector<VideoEncodeAcceleratorSupportedProfilePtr> video_encode_accelerator_supported_profiles;

    bool jpeg_decode_accelerator_supported;

    WTF::Vector<ImageDecodeAcceleratorSupportedProfilePtr> image_decode_accelerator_supported_profiles;

    bool subpixel_font_rendering;

    uint32_t visibility_callback_call_count;

    bool hardware_supports_vulkan;

    ::gpu::mojom::blink::VulkanInfoPtr vulkan_info;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, GpuInfo::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, GpuInfo::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, GpuInfo::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, GpuInfo::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

template <typename StructPtrType> GpuDevicePtr GpuDevice::Clone() const
{
    return New(mojo::Clone(vendor_id), mojo::Clone(device_id), mojo::Clone(sub_sys_id), mojo::Clone(revision), mojo::Clone(active), mojo::Clone(vendor_string),
        mojo::Clone(device_string), mojo::Clone(driver_vendor), mojo::Clone(driver_version), mojo::Clone(luid), mojo::Clone(gpu_preference));
}

template <typename T, GpuDevice::EnableIfSame<T>*> bool GpuDevice::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->vendor_id, other_struct.vendor_id))
        return false;
    if (!mojo::Equals(this->device_id, other_struct.device_id))
        return false;
    if (!mojo::Equals(this->sub_sys_id, other_struct.sub_sys_id))
        return false;
    if (!mojo::Equals(this->revision, other_struct.revision))
        return false;
    if (!mojo::Equals(this->active, other_struct.active))
        return false;
    if (!mojo::Equals(this->vendor_string, other_struct.vendor_string))
        return false;
    if (!mojo::Equals(this->device_string, other_struct.device_string))
        return false;
    if (!mojo::Equals(this->driver_vendor, other_struct.driver_vendor))
        return false;
    if (!mojo::Equals(this->driver_version, other_struct.driver_version))
        return false;
    if (!mojo::Equals(this->luid, other_struct.luid))
        return false;
    if (!mojo::Equals(this->gpu_preference, other_struct.gpu_preference))
        return false;
    return true;
}

template <typename T, GpuDevice::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.vendor_id < rhs.vendor_id)
        return true;
    if (rhs.vendor_id < lhs.vendor_id)
        return false;
    if (lhs.device_id < rhs.device_id)
        return true;
    if (rhs.device_id < lhs.device_id)
        return false;
    if (lhs.sub_sys_id < rhs.sub_sys_id)
        return true;
    if (rhs.sub_sys_id < lhs.sub_sys_id)
        return false;
    if (lhs.revision < rhs.revision)
        return true;
    if (rhs.revision < lhs.revision)
        return false;
    if (lhs.active < rhs.active)
        return true;
    if (rhs.active < lhs.active)
        return false;
    if (lhs.vendor_string < rhs.vendor_string)
        return true;
    if (rhs.vendor_string < lhs.vendor_string)
        return false;
    if (lhs.device_string < rhs.device_string)
        return true;
    if (rhs.device_string < lhs.device_string)
        return false;
    if (lhs.driver_vendor < rhs.driver_vendor)
        return true;
    if (rhs.driver_vendor < lhs.driver_vendor)
        return false;
    if (lhs.driver_version < rhs.driver_version)
        return true;
    if (rhs.driver_version < lhs.driver_version)
        return false;
    if (lhs.luid < rhs.luid)
        return true;
    if (rhs.luid < lhs.luid)
        return false;
    if (lhs.gpu_preference < rhs.gpu_preference)
        return true;
    if (rhs.gpu_preference < lhs.gpu_preference)
        return false;
    return false;
}
template <typename StructPtrType> VideoDecodeAcceleratorSupportedProfilePtr VideoDecodeAcceleratorSupportedProfile::Clone() const
{
    return New(mojo::Clone(profile), mojo::Clone(max_resolution), mojo::Clone(min_resolution), mojo::Clone(encrypted_only));
}

template <typename T, VideoDecodeAcceleratorSupportedProfile::EnableIfSame<T>*> bool VideoDecodeAcceleratorSupportedProfile::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->profile, other_struct.profile))
        return false;
    if (!mojo::Equals(this->max_resolution, other_struct.max_resolution))
        return false;
    if (!mojo::Equals(this->min_resolution, other_struct.min_resolution))
        return false;
    if (!mojo::Equals(this->encrypted_only, other_struct.encrypted_only))
        return false;
    return true;
}

template <typename T, VideoDecodeAcceleratorSupportedProfile::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.profile < rhs.profile)
        return true;
    if (rhs.profile < lhs.profile)
        return false;
    if (lhs.max_resolution < rhs.max_resolution)
        return true;
    if (rhs.max_resolution < lhs.max_resolution)
        return false;
    if (lhs.min_resolution < rhs.min_resolution)
        return true;
    if (rhs.min_resolution < lhs.min_resolution)
        return false;
    if (lhs.encrypted_only < rhs.encrypted_only)
        return true;
    if (rhs.encrypted_only < lhs.encrypted_only)
        return false;
    return false;
}
template <typename StructPtrType> VideoDecodeAcceleratorCapabilitiesPtr VideoDecodeAcceleratorCapabilities::Clone() const
{
    return New(mojo::Clone(supported_profiles), mojo::Clone(flags));
}

template <typename T, VideoDecodeAcceleratorCapabilities::EnableIfSame<T>*> bool VideoDecodeAcceleratorCapabilities::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->supported_profiles, other_struct.supported_profiles))
        return false;
    if (!mojo::Equals(this->flags, other_struct.flags))
        return false;
    return true;
}

template <typename T, VideoDecodeAcceleratorCapabilities::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.supported_profiles < rhs.supported_profiles)
        return true;
    if (rhs.supported_profiles < lhs.supported_profiles)
        return false;
    if (lhs.flags < rhs.flags)
        return true;
    if (rhs.flags < lhs.flags)
        return false;
    return false;
}
template <typename StructPtrType> VideoEncodeAcceleratorSupportedProfilePtr VideoEncodeAcceleratorSupportedProfile::Clone() const
{
    return New(mojo::Clone(profile), mojo::Clone(min_resolution), mojo::Clone(max_resolution), mojo::Clone(max_framerate_numerator),
        mojo::Clone(max_framerate_denominator));
}

template <typename T, VideoEncodeAcceleratorSupportedProfile::EnableIfSame<T>*> bool VideoEncodeAcceleratorSupportedProfile::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->profile, other_struct.profile))
        return false;
    if (!mojo::Equals(this->min_resolution, other_struct.min_resolution))
        return false;
    if (!mojo::Equals(this->max_resolution, other_struct.max_resolution))
        return false;
    if (!mojo::Equals(this->max_framerate_numerator, other_struct.max_framerate_numerator))
        return false;
    if (!mojo::Equals(this->max_framerate_denominator, other_struct.max_framerate_denominator))
        return false;
    return true;
}

template <typename T, VideoEncodeAcceleratorSupportedProfile::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.profile < rhs.profile)
        return true;
    if (rhs.profile < lhs.profile)
        return false;
    if (lhs.min_resolution < rhs.min_resolution)
        return true;
    if (rhs.min_resolution < lhs.min_resolution)
        return false;
    if (lhs.max_resolution < rhs.max_resolution)
        return true;
    if (rhs.max_resolution < lhs.max_resolution)
        return false;
    if (lhs.max_framerate_numerator < rhs.max_framerate_numerator)
        return true;
    if (rhs.max_framerate_numerator < lhs.max_framerate_numerator)
        return false;
    if (lhs.max_framerate_denominator < rhs.max_framerate_denominator)
        return true;
    if (rhs.max_framerate_denominator < lhs.max_framerate_denominator)
        return false;
    return false;
}
template <typename StructPtrType> ImageDecodeAcceleratorSupportedProfilePtr ImageDecodeAcceleratorSupportedProfile::Clone() const
{
    return New(mojo::Clone(image_type), mojo::Clone(min_encoded_dimensions), mojo::Clone(max_encoded_dimensions), mojo::Clone(subsamplings));
}

template <typename T, ImageDecodeAcceleratorSupportedProfile::EnableIfSame<T>*> bool ImageDecodeAcceleratorSupportedProfile::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->image_type, other_struct.image_type))
        return false;
    if (!mojo::Equals(this->min_encoded_dimensions, other_struct.min_encoded_dimensions))
        return false;
    if (!mojo::Equals(this->max_encoded_dimensions, other_struct.max_encoded_dimensions))
        return false;
    if (!mojo::Equals(this->subsamplings, other_struct.subsamplings))
        return false;
    return true;
}

template <typename T, ImageDecodeAcceleratorSupportedProfile::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.image_type < rhs.image_type)
        return true;
    if (rhs.image_type < lhs.image_type)
        return false;
    if (lhs.min_encoded_dimensions < rhs.min_encoded_dimensions)
        return true;
    if (rhs.min_encoded_dimensions < lhs.min_encoded_dimensions)
        return false;
    if (lhs.max_encoded_dimensions < rhs.max_encoded_dimensions)
        return true;
    if (rhs.max_encoded_dimensions < lhs.max_encoded_dimensions)
        return false;
    if (lhs.subsamplings < rhs.subsamplings)
        return true;
    if (rhs.subsamplings < lhs.subsamplings)
        return false;
    return false;
}
template <typename StructPtrType> OverlayInfoPtr OverlayInfo::Clone() const
{
    return New(mojo::Clone(direct_composition), mojo::Clone(supports_overlays), mojo::Clone(yuy2_overlay_support), mojo::Clone(nv12_overlay_support),
        mojo::Clone(bgra8_overlay_support), mojo::Clone(rgb10a2_overlay_support), mojo::Clone(p010_overlay_support));
}

template <typename T, OverlayInfo::EnableIfSame<T>*> bool OverlayInfo::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->direct_composition, other_struct.direct_composition))
        return false;
    if (!mojo::Equals(this->supports_overlays, other_struct.supports_overlays))
        return false;
    if (!mojo::Equals(this->yuy2_overlay_support, other_struct.yuy2_overlay_support))
        return false;
    if (!mojo::Equals(this->nv12_overlay_support, other_struct.nv12_overlay_support))
        return false;
    if (!mojo::Equals(this->bgra8_overlay_support, other_struct.bgra8_overlay_support))
        return false;
    if (!mojo::Equals(this->rgb10a2_overlay_support, other_struct.rgb10a2_overlay_support))
        return false;
    if (!mojo::Equals(this->p010_overlay_support, other_struct.p010_overlay_support))
        return false;
    return true;
}

template <typename T, OverlayInfo::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.direct_composition < rhs.direct_composition)
        return true;
    if (rhs.direct_composition < lhs.direct_composition)
        return false;
    if (lhs.supports_overlays < rhs.supports_overlays)
        return true;
    if (rhs.supports_overlays < lhs.supports_overlays)
        return false;
    if (lhs.yuy2_overlay_support < rhs.yuy2_overlay_support)
        return true;
    if (rhs.yuy2_overlay_support < lhs.yuy2_overlay_support)
        return false;
    if (lhs.nv12_overlay_support < rhs.nv12_overlay_support)
        return true;
    if (rhs.nv12_overlay_support < lhs.nv12_overlay_support)
        return false;
    if (lhs.bgra8_overlay_support < rhs.bgra8_overlay_support)
        return true;
    if (rhs.bgra8_overlay_support < lhs.bgra8_overlay_support)
        return false;
    if (lhs.rgb10a2_overlay_support < rhs.rgb10a2_overlay_support)
        return true;
    if (rhs.rgb10a2_overlay_support < lhs.rgb10a2_overlay_support)
        return false;
    if (lhs.p010_overlay_support < rhs.p010_overlay_support)
        return true;
    if (rhs.p010_overlay_support < lhs.p010_overlay_support)
        return false;
    return false;
}
template <typename StructPtrType> GpuInfoPtr GpuInfo::Clone() const
{
    return New(mojo::Clone(initialization_time), mojo::Clone(optimus), mojo::Clone(amd_switchable), mojo::Clone(gpu), mojo::Clone(secondary_gpus),
        mojo::Clone(npus), mojo::Clone(pixel_shader_version), mojo::Clone(vertex_shader_version), mojo::Clone(max_msaa_samples),
        mojo::Clone(machine_model_name), mojo::Clone(machine_model_version), mojo::Clone(display_type), mojo::Clone(gl_version), mojo::Clone(gl_vendor),
        mojo::Clone(gl_renderer), mojo::Clone(gl_extensions), mojo::Clone(gl_ws_vendor), mojo::Clone(gl_ws_version), mojo::Clone(gl_ws_extensions),
        mojo::Clone(gl_reset_notification_strategy), mojo::Clone(gl_implementation_parts), mojo::Clone(direct_rendering_version), mojo::Clone(sandboxed),
        mojo::Clone(in_process_gpu), mojo::Clone(passthrough_cmd_decoder), mojo::Clone(can_support_threaded_texture_mailbox),
        mojo::Clone(directml_feature_level), mojo::Clone(d3d12_feature_level), mojo::Clone(vulkan_version), mojo::Clone(overlay_info),
        mojo::Clone(shared_image_d3d), mojo::Clone(video_decode_accelerator_supported_profiles), mojo::Clone(video_encode_accelerator_supported_profiles),
        mojo::Clone(jpeg_decode_accelerator_supported), mojo::Clone(image_decode_accelerator_supported_profiles), mojo::Clone(subpixel_font_rendering),
        mojo::Clone(visibility_callback_call_count), mojo::Clone(hardware_supports_vulkan), mojo::Clone(vulkan_info));
}

template <typename T, GpuInfo::EnableIfSame<T>*> bool GpuInfo::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->initialization_time, other_struct.initialization_time))
        return false;
    if (!mojo::Equals(this->optimus, other_struct.optimus))
        return false;
    if (!mojo::Equals(this->amd_switchable, other_struct.amd_switchable))
        return false;
    if (!mojo::Equals(this->gpu, other_struct.gpu))
        return false;
    if (!mojo::Equals(this->secondary_gpus, other_struct.secondary_gpus))
        return false;
    if (!mojo::Equals(this->npus, other_struct.npus))
        return false;
    if (!mojo::Equals(this->pixel_shader_version, other_struct.pixel_shader_version))
        return false;
    if (!mojo::Equals(this->vertex_shader_version, other_struct.vertex_shader_version))
        return false;
    if (!mojo::Equals(this->max_msaa_samples, other_struct.max_msaa_samples))
        return false;
    if (!mojo::Equals(this->machine_model_name, other_struct.machine_model_name))
        return false;
    if (!mojo::Equals(this->machine_model_version, other_struct.machine_model_version))
        return false;
    if (!mojo::Equals(this->display_type, other_struct.display_type))
        return false;
    if (!mojo::Equals(this->gl_version, other_struct.gl_version))
        return false;
    if (!mojo::Equals(this->gl_vendor, other_struct.gl_vendor))
        return false;
    if (!mojo::Equals(this->gl_renderer, other_struct.gl_renderer))
        return false;
    if (!mojo::Equals(this->gl_extensions, other_struct.gl_extensions))
        return false;
    if (!mojo::Equals(this->gl_ws_vendor, other_struct.gl_ws_vendor))
        return false;
    if (!mojo::Equals(this->gl_ws_version, other_struct.gl_ws_version))
        return false;
    if (!mojo::Equals(this->gl_ws_extensions, other_struct.gl_ws_extensions))
        return false;
    if (!mojo::Equals(this->gl_reset_notification_strategy, other_struct.gl_reset_notification_strategy))
        return false;
    if (!mojo::Equals(this->gl_implementation_parts, other_struct.gl_implementation_parts))
        return false;
    if (!mojo::Equals(this->direct_rendering_version, other_struct.direct_rendering_version))
        return false;
    if (!mojo::Equals(this->sandboxed, other_struct.sandboxed))
        return false;
    if (!mojo::Equals(this->in_process_gpu, other_struct.in_process_gpu))
        return false;
    if (!mojo::Equals(this->passthrough_cmd_decoder, other_struct.passthrough_cmd_decoder))
        return false;
    if (!mojo::Equals(this->can_support_threaded_texture_mailbox, other_struct.can_support_threaded_texture_mailbox))
        return false;
    if (!mojo::Equals(this->directml_feature_level, other_struct.directml_feature_level))
        return false;
    if (!mojo::Equals(this->d3d12_feature_level, other_struct.d3d12_feature_level))
        return false;
    if (!mojo::Equals(this->vulkan_version, other_struct.vulkan_version))
        return false;
    if (!mojo::Equals(this->overlay_info, other_struct.overlay_info))
        return false;
    if (!mojo::Equals(this->shared_image_d3d, other_struct.shared_image_d3d))
        return false;
    if (!mojo::Equals(this->video_decode_accelerator_supported_profiles, other_struct.video_decode_accelerator_supported_profiles))
        return false;
    if (!mojo::Equals(this->video_encode_accelerator_supported_profiles, other_struct.video_encode_accelerator_supported_profiles))
        return false;
    if (!mojo::Equals(this->jpeg_decode_accelerator_supported, other_struct.jpeg_decode_accelerator_supported))
        return false;
    if (!mojo::Equals(this->image_decode_accelerator_supported_profiles, other_struct.image_decode_accelerator_supported_profiles))
        return false;
    if (!mojo::Equals(this->subpixel_font_rendering, other_struct.subpixel_font_rendering))
        return false;
    if (!mojo::Equals(this->visibility_callback_call_count, other_struct.visibility_callback_call_count))
        return false;
    if (!mojo::Equals(this->hardware_supports_vulkan, other_struct.hardware_supports_vulkan))
        return false;
    if (!mojo::Equals(this->vulkan_info, other_struct.vulkan_info))
        return false;
    return true;
}

template <typename T, GpuInfo::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.initialization_time < rhs.initialization_time)
        return true;
    if (rhs.initialization_time < lhs.initialization_time)
        return false;
    if (lhs.optimus < rhs.optimus)
        return true;
    if (rhs.optimus < lhs.optimus)
        return false;
    if (lhs.amd_switchable < rhs.amd_switchable)
        return true;
    if (rhs.amd_switchable < lhs.amd_switchable)
        return false;
    if (lhs.gpu < rhs.gpu)
        return true;
    if (rhs.gpu < lhs.gpu)
        return false;
    if (lhs.secondary_gpus < rhs.secondary_gpus)
        return true;
    if (rhs.secondary_gpus < lhs.secondary_gpus)
        return false;
    if (lhs.npus < rhs.npus)
        return true;
    if (rhs.npus < lhs.npus)
        return false;
    if (lhs.pixel_shader_version < rhs.pixel_shader_version)
        return true;
    if (rhs.pixel_shader_version < lhs.pixel_shader_version)
        return false;
    if (lhs.vertex_shader_version < rhs.vertex_shader_version)
        return true;
    if (rhs.vertex_shader_version < lhs.vertex_shader_version)
        return false;
    if (lhs.max_msaa_samples < rhs.max_msaa_samples)
        return true;
    if (rhs.max_msaa_samples < lhs.max_msaa_samples)
        return false;
    if (lhs.machine_model_name < rhs.machine_model_name)
        return true;
    if (rhs.machine_model_name < lhs.machine_model_name)
        return false;
    if (lhs.machine_model_version < rhs.machine_model_version)
        return true;
    if (rhs.machine_model_version < lhs.machine_model_version)
        return false;
    if (lhs.display_type < rhs.display_type)
        return true;
    if (rhs.display_type < lhs.display_type)
        return false;
    if (lhs.gl_version < rhs.gl_version)
        return true;
    if (rhs.gl_version < lhs.gl_version)
        return false;
    if (lhs.gl_vendor < rhs.gl_vendor)
        return true;
    if (rhs.gl_vendor < lhs.gl_vendor)
        return false;
    if (lhs.gl_renderer < rhs.gl_renderer)
        return true;
    if (rhs.gl_renderer < lhs.gl_renderer)
        return false;
    if (lhs.gl_extensions < rhs.gl_extensions)
        return true;
    if (rhs.gl_extensions < lhs.gl_extensions)
        return false;
    if (lhs.gl_ws_vendor < rhs.gl_ws_vendor)
        return true;
    if (rhs.gl_ws_vendor < lhs.gl_ws_vendor)
        return false;
    if (lhs.gl_ws_version < rhs.gl_ws_version)
        return true;
    if (rhs.gl_ws_version < lhs.gl_ws_version)
        return false;
    if (lhs.gl_ws_extensions < rhs.gl_ws_extensions)
        return true;
    if (rhs.gl_ws_extensions < lhs.gl_ws_extensions)
        return false;
    if (lhs.gl_reset_notification_strategy < rhs.gl_reset_notification_strategy)
        return true;
    if (rhs.gl_reset_notification_strategy < lhs.gl_reset_notification_strategy)
        return false;
    if (lhs.gl_implementation_parts < rhs.gl_implementation_parts)
        return true;
    if (rhs.gl_implementation_parts < lhs.gl_implementation_parts)
        return false;
    if (lhs.direct_rendering_version < rhs.direct_rendering_version)
        return true;
    if (rhs.direct_rendering_version < lhs.direct_rendering_version)
        return false;
    if (lhs.sandboxed < rhs.sandboxed)
        return true;
    if (rhs.sandboxed < lhs.sandboxed)
        return false;
    if (lhs.in_process_gpu < rhs.in_process_gpu)
        return true;
    if (rhs.in_process_gpu < lhs.in_process_gpu)
        return false;
    if (lhs.passthrough_cmd_decoder < rhs.passthrough_cmd_decoder)
        return true;
    if (rhs.passthrough_cmd_decoder < lhs.passthrough_cmd_decoder)
        return false;
    if (lhs.can_support_threaded_texture_mailbox < rhs.can_support_threaded_texture_mailbox)
        return true;
    if (rhs.can_support_threaded_texture_mailbox < lhs.can_support_threaded_texture_mailbox)
        return false;
    if (lhs.directml_feature_level < rhs.directml_feature_level)
        return true;
    if (rhs.directml_feature_level < lhs.directml_feature_level)
        return false;
    if (lhs.d3d12_feature_level < rhs.d3d12_feature_level)
        return true;
    if (rhs.d3d12_feature_level < lhs.d3d12_feature_level)
        return false;
    if (lhs.vulkan_version < rhs.vulkan_version)
        return true;
    if (rhs.vulkan_version < lhs.vulkan_version)
        return false;
    if (lhs.overlay_info < rhs.overlay_info)
        return true;
    if (rhs.overlay_info < lhs.overlay_info)
        return false;
    if (lhs.shared_image_d3d < rhs.shared_image_d3d)
        return true;
    if (rhs.shared_image_d3d < lhs.shared_image_d3d)
        return false;
    if (lhs.video_decode_accelerator_supported_profiles < rhs.video_decode_accelerator_supported_profiles)
        return true;
    if (rhs.video_decode_accelerator_supported_profiles < lhs.video_decode_accelerator_supported_profiles)
        return false;
    if (lhs.video_encode_accelerator_supported_profiles < rhs.video_encode_accelerator_supported_profiles)
        return true;
    if (rhs.video_encode_accelerator_supported_profiles < lhs.video_encode_accelerator_supported_profiles)
        return false;
    if (lhs.jpeg_decode_accelerator_supported < rhs.jpeg_decode_accelerator_supported)
        return true;
    if (rhs.jpeg_decode_accelerator_supported < lhs.jpeg_decode_accelerator_supported)
        return false;
    if (lhs.image_decode_accelerator_supported_profiles < rhs.image_decode_accelerator_supported_profiles)
        return true;
    if (rhs.image_decode_accelerator_supported_profiles < lhs.image_decode_accelerator_supported_profiles)
        return false;
    if (lhs.subpixel_font_rendering < rhs.subpixel_font_rendering)
        return true;
    if (rhs.subpixel_font_rendering < lhs.subpixel_font_rendering)
        return false;
    if (lhs.visibility_callback_call_count < rhs.visibility_callback_call_count)
        return true;
    if (rhs.visibility_callback_call_count < lhs.visibility_callback_call_count)
        return false;
    if (lhs.hardware_supports_vulkan < rhs.hardware_supports_vulkan)
        return true;
    if (rhs.hardware_supports_vulkan < lhs.hardware_supports_vulkan)
        return false;
    if (lhs.vulkan_info < rhs.vulkan_info)
        return true;
    if (rhs.vulkan_info < lhs.vulkan_info)
        return false;
    return false;
}

} // gpu::mojom::blink

namespace mojo {

template <> struct BLINK_PLATFORM_EXPORT StructTraits<::gpu::mojom::blink::GpuDevice::DataView, ::gpu::mojom::blink::GpuDevicePtr> {
    static bool IsNull(const ::gpu::mojom::blink::GpuDevicePtr& input)
    {
        return !input;
    }
    static void SetToNull(::gpu::mojom::blink::GpuDevicePtr* output)
    {
        output->reset();
    }

    static decltype(::gpu::mojom::blink::GpuDevice::vendor_id) vendor_id(const ::gpu::mojom::blink::GpuDevicePtr& input)
    {
        return input->vendor_id;
    }

    static decltype(::gpu::mojom::blink::GpuDevice::device_id) device_id(const ::gpu::mojom::blink::GpuDevicePtr& input)
    {
        return input->device_id;
    }

    static decltype(::gpu::mojom::blink::GpuDevice::sub_sys_id) sub_sys_id(const ::gpu::mojom::blink::GpuDevicePtr& input)
    {
        return input->sub_sys_id;
    }

    static decltype(::gpu::mojom::blink::GpuDevice::revision) revision(const ::gpu::mojom::blink::GpuDevicePtr& input)
    {
        return input->revision;
    }

    static decltype(::gpu::mojom::blink::GpuDevice::active) active(const ::gpu::mojom::blink::GpuDevicePtr& input)
    {
        return input->active;
    }

    static const decltype(::gpu::mojom::blink::GpuDevice::vendor_string)& vendor_string(const ::gpu::mojom::blink::GpuDevicePtr& input)
    {
        return input->vendor_string;
    }

    static const decltype(::gpu::mojom::blink::GpuDevice::device_string)& device_string(const ::gpu::mojom::blink::GpuDevicePtr& input)
    {
        return input->device_string;
    }

    static const decltype(::gpu::mojom::blink::GpuDevice::driver_vendor)& driver_vendor(const ::gpu::mojom::blink::GpuDevicePtr& input)
    {
        return input->driver_vendor;
    }

    static const decltype(::gpu::mojom::blink::GpuDevice::driver_version)& driver_version(const ::gpu::mojom::blink::GpuDevicePtr& input)
    {
        return input->driver_version;
    }

    static const decltype(::gpu::mojom::blink::GpuDevice::luid)& luid(const ::gpu::mojom::blink::GpuDevicePtr& input)
    {
        return input->luid;
    }

    static decltype(::gpu::mojom::blink::GpuDevice::gpu_preference) gpu_preference(const ::gpu::mojom::blink::GpuDevicePtr& input)
    {
        return input->gpu_preference;
    }

    static bool Read(::gpu::mojom::blink::GpuDevice::DataView input, ::gpu::mojom::blink::GpuDevicePtr* output);
};

template <>
struct BLINK_PLATFORM_EXPORT
    StructTraits<::gpu::mojom::blink::VideoDecodeAcceleratorSupportedProfile::DataView, ::gpu::mojom::blink::VideoDecodeAcceleratorSupportedProfilePtr> {
    static bool IsNull(const ::gpu::mojom::blink::VideoDecodeAcceleratorSupportedProfilePtr& input)
    {
        return !input;
    }
    static void SetToNull(::gpu::mojom::blink::VideoDecodeAcceleratorSupportedProfilePtr* output)
    {
        output->reset();
    }

    static decltype(::gpu::mojom::blink::VideoDecodeAcceleratorSupportedProfile::profile) profile(
        const ::gpu::mojom::blink::VideoDecodeAcceleratorSupportedProfilePtr& input)
    {
        return input->profile;
    }

    static const decltype(::gpu::mojom::blink::VideoDecodeAcceleratorSupportedProfile::max_resolution)& max_resolution(
        const ::gpu::mojom::blink::VideoDecodeAcceleratorSupportedProfilePtr& input)
    {
        return input->max_resolution;
    }

    static const decltype(::gpu::mojom::blink::VideoDecodeAcceleratorSupportedProfile::min_resolution)& min_resolution(
        const ::gpu::mojom::blink::VideoDecodeAcceleratorSupportedProfilePtr& input)
    {
        return input->min_resolution;
    }

    static decltype(::gpu::mojom::blink::VideoDecodeAcceleratorSupportedProfile::encrypted_only) encrypted_only(
        const ::gpu::mojom::blink::VideoDecodeAcceleratorSupportedProfilePtr& input)
    {
        return input->encrypted_only;
    }

    static bool Read(
        ::gpu::mojom::blink::VideoDecodeAcceleratorSupportedProfile::DataView input, ::gpu::mojom::blink::VideoDecodeAcceleratorSupportedProfilePtr* output);
};

template <>
struct BLINK_PLATFORM_EXPORT
    StructTraits<::gpu::mojom::blink::VideoDecodeAcceleratorCapabilities::DataView, ::gpu::mojom::blink::VideoDecodeAcceleratorCapabilitiesPtr> {
    static bool IsNull(const ::gpu::mojom::blink::VideoDecodeAcceleratorCapabilitiesPtr& input)
    {
        return !input;
    }
    static void SetToNull(::gpu::mojom::blink::VideoDecodeAcceleratorCapabilitiesPtr* output)
    {
        output->reset();
    }

    static const decltype(::gpu::mojom::blink::VideoDecodeAcceleratorCapabilities::supported_profiles)& supported_profiles(
        const ::gpu::mojom::blink::VideoDecodeAcceleratorCapabilitiesPtr& input)
    {
        return input->supported_profiles;
    }

    static decltype(::gpu::mojom::blink::VideoDecodeAcceleratorCapabilities::flags) flags(
        const ::gpu::mojom::blink::VideoDecodeAcceleratorCapabilitiesPtr& input)
    {
        return input->flags;
    }

    static bool Read(
        ::gpu::mojom::blink::VideoDecodeAcceleratorCapabilities::DataView input, ::gpu::mojom::blink::VideoDecodeAcceleratorCapabilitiesPtr* output);
};

template <>
struct BLINK_PLATFORM_EXPORT
    StructTraits<::gpu::mojom::blink::VideoEncodeAcceleratorSupportedProfile::DataView, ::gpu::mojom::blink::VideoEncodeAcceleratorSupportedProfilePtr> {
    static bool IsNull(const ::gpu::mojom::blink::VideoEncodeAcceleratorSupportedProfilePtr& input)
    {
        return !input;
    }
    static void SetToNull(::gpu::mojom::blink::VideoEncodeAcceleratorSupportedProfilePtr* output)
    {
        output->reset();
    }

    static decltype(::gpu::mojom::blink::VideoEncodeAcceleratorSupportedProfile::profile) profile(
        const ::gpu::mojom::blink::VideoEncodeAcceleratorSupportedProfilePtr& input)
    {
        return input->profile;
    }

    static const decltype(::gpu::mojom::blink::VideoEncodeAcceleratorSupportedProfile::min_resolution)& min_resolution(
        const ::gpu::mojom::blink::VideoEncodeAcceleratorSupportedProfilePtr& input)
    {
        return input->min_resolution;
    }

    static const decltype(::gpu::mojom::blink::VideoEncodeAcceleratorSupportedProfile::max_resolution)& max_resolution(
        const ::gpu::mojom::blink::VideoEncodeAcceleratorSupportedProfilePtr& input)
    {
        return input->max_resolution;
    }

    static decltype(::gpu::mojom::blink::VideoEncodeAcceleratorSupportedProfile::max_framerate_numerator) max_framerate_numerator(
        const ::gpu::mojom::blink::VideoEncodeAcceleratorSupportedProfilePtr& input)
    {
        return input->max_framerate_numerator;
    }

    static decltype(::gpu::mojom::blink::VideoEncodeAcceleratorSupportedProfile::max_framerate_denominator) max_framerate_denominator(
        const ::gpu::mojom::blink::VideoEncodeAcceleratorSupportedProfilePtr& input)
    {
        return input->max_framerate_denominator;
    }

    static bool Read(
        ::gpu::mojom::blink::VideoEncodeAcceleratorSupportedProfile::DataView input, ::gpu::mojom::blink::VideoEncodeAcceleratorSupportedProfilePtr* output);
};

template <>
struct BLINK_PLATFORM_EXPORT
    StructTraits<::gpu::mojom::blink::ImageDecodeAcceleratorSupportedProfile::DataView, ::gpu::mojom::blink::ImageDecodeAcceleratorSupportedProfilePtr> {
    static bool IsNull(const ::gpu::mojom::blink::ImageDecodeAcceleratorSupportedProfilePtr& input)
    {
        return !input;
    }
    static void SetToNull(::gpu::mojom::blink::ImageDecodeAcceleratorSupportedProfilePtr* output)
    {
        output->reset();
    }

    static decltype(::gpu::mojom::blink::ImageDecodeAcceleratorSupportedProfile::image_type) image_type(
        const ::gpu::mojom::blink::ImageDecodeAcceleratorSupportedProfilePtr& input)
    {
        return input->image_type;
    }

    static const decltype(::gpu::mojom::blink::ImageDecodeAcceleratorSupportedProfile::min_encoded_dimensions)& min_encoded_dimensions(
        const ::gpu::mojom::blink::ImageDecodeAcceleratorSupportedProfilePtr& input)
    {
        return input->min_encoded_dimensions;
    }

    static const decltype(::gpu::mojom::blink::ImageDecodeAcceleratorSupportedProfile::max_encoded_dimensions)& max_encoded_dimensions(
        const ::gpu::mojom::blink::ImageDecodeAcceleratorSupportedProfilePtr& input)
    {
        return input->max_encoded_dimensions;
    }

    static const decltype(::gpu::mojom::blink::ImageDecodeAcceleratorSupportedProfile::subsamplings)& subsamplings(
        const ::gpu::mojom::blink::ImageDecodeAcceleratorSupportedProfilePtr& input)
    {
        return input->subsamplings;
    }

    static bool Read(
        ::gpu::mojom::blink::ImageDecodeAcceleratorSupportedProfile::DataView input, ::gpu::mojom::blink::ImageDecodeAcceleratorSupportedProfilePtr* output);
};

template <> struct BLINK_PLATFORM_EXPORT StructTraits<::gpu::mojom::blink::OverlayInfo::DataView, ::gpu::mojom::blink::OverlayInfoPtr> {
    static bool IsNull(const ::gpu::mojom::blink::OverlayInfoPtr& input)
    {
        return !input;
    }
    static void SetToNull(::gpu::mojom::blink::OverlayInfoPtr* output)
    {
        output->reset();
    }

    static decltype(::gpu::mojom::blink::OverlayInfo::direct_composition) direct_composition(const ::gpu::mojom::blink::OverlayInfoPtr& input)
    {
        return input->direct_composition;
    }

    static decltype(::gpu::mojom::blink::OverlayInfo::supports_overlays) supports_overlays(const ::gpu::mojom::blink::OverlayInfoPtr& input)
    {
        return input->supports_overlays;
    }

    static decltype(::gpu::mojom::blink::OverlayInfo::yuy2_overlay_support) yuy2_overlay_support(const ::gpu::mojom::blink::OverlayInfoPtr& input)
    {
        return input->yuy2_overlay_support;
    }

    static decltype(::gpu::mojom::blink::OverlayInfo::nv12_overlay_support) nv12_overlay_support(const ::gpu::mojom::blink::OverlayInfoPtr& input)
    {
        return input->nv12_overlay_support;
    }

    static decltype(::gpu::mojom::blink::OverlayInfo::bgra8_overlay_support) bgra8_overlay_support(const ::gpu::mojom::blink::OverlayInfoPtr& input)
    {
        return input->bgra8_overlay_support;
    }

    static decltype(::gpu::mojom::blink::OverlayInfo::rgb10a2_overlay_support) rgb10a2_overlay_support(const ::gpu::mojom::blink::OverlayInfoPtr& input)
    {
        return input->rgb10a2_overlay_support;
    }

    static decltype(::gpu::mojom::blink::OverlayInfo::p010_overlay_support) p010_overlay_support(const ::gpu::mojom::blink::OverlayInfoPtr& input)
    {
        return input->p010_overlay_support;
    }

    static bool Read(::gpu::mojom::blink::OverlayInfo::DataView input, ::gpu::mojom::blink::OverlayInfoPtr* output);
};

template <> struct BLINK_PLATFORM_EXPORT StructTraits<::gpu::mojom::blink::GpuInfo::DataView, ::gpu::mojom::blink::GpuInfoPtr> {
    static bool IsNull(const ::gpu::mojom::blink::GpuInfoPtr& input)
    {
        return !input;
    }
    static void SetToNull(::gpu::mojom::blink::GpuInfoPtr* output)
    {
        output->reset();
    }

    static const decltype(::gpu::mojom::blink::GpuInfo::initialization_time)& initialization_time(const ::gpu::mojom::blink::GpuInfoPtr& input)
    {
        return input->initialization_time;
    }

    static decltype(::gpu::mojom::blink::GpuInfo::optimus) optimus(const ::gpu::mojom::blink::GpuInfoPtr& input)
    {
        return input->optimus;
    }

    static decltype(::gpu::mojom::blink::GpuInfo::amd_switchable) amd_switchable(const ::gpu::mojom::blink::GpuInfoPtr& input)
    {
        return input->amd_switchable;
    }

    static const decltype(::gpu::mojom::blink::GpuInfo::gpu)& gpu(const ::gpu::mojom::blink::GpuInfoPtr& input)
    {
        return input->gpu;
    }

    static const decltype(::gpu::mojom::blink::GpuInfo::secondary_gpus)& secondary_gpus(const ::gpu::mojom::blink::GpuInfoPtr& input)
    {
        return input->secondary_gpus;
    }

    static const decltype(::gpu::mojom::blink::GpuInfo::npus)& npus(const ::gpu::mojom::blink::GpuInfoPtr& input)
    {
        return input->npus;
    }

    static const decltype(::gpu::mojom::blink::GpuInfo::pixel_shader_version)& pixel_shader_version(const ::gpu::mojom::blink::GpuInfoPtr& input)
    {
        return input->pixel_shader_version;
    }

    static const decltype(::gpu::mojom::blink::GpuInfo::vertex_shader_version)& vertex_shader_version(const ::gpu::mojom::blink::GpuInfoPtr& input)
    {
        return input->vertex_shader_version;
    }

    static const decltype(::gpu::mojom::blink::GpuInfo::max_msaa_samples)& max_msaa_samples(const ::gpu::mojom::blink::GpuInfoPtr& input)
    {
        return input->max_msaa_samples;
    }

    static const decltype(::gpu::mojom::blink::GpuInfo::machine_model_name)& machine_model_name(const ::gpu::mojom::blink::GpuInfoPtr& input)
    {
        return input->machine_model_name;
    }

    static const decltype(::gpu::mojom::blink::GpuInfo::machine_model_version)& machine_model_version(const ::gpu::mojom::blink::GpuInfoPtr& input)
    {
        return input->machine_model_version;
    }

    static const decltype(::gpu::mojom::blink::GpuInfo::display_type)& display_type(const ::gpu::mojom::blink::GpuInfoPtr& input)
    {
        return input->display_type;
    }

    static const decltype(::gpu::mojom::blink::GpuInfo::gl_version)& gl_version(const ::gpu::mojom::blink::GpuInfoPtr& input)
    {
        return input->gl_version;
    }

    static const decltype(::gpu::mojom::blink::GpuInfo::gl_vendor)& gl_vendor(const ::gpu::mojom::blink::GpuInfoPtr& input)
    {
        return input->gl_vendor;
    }

    static const decltype(::gpu::mojom::blink::GpuInfo::gl_renderer)& gl_renderer(const ::gpu::mojom::blink::GpuInfoPtr& input)
    {
        return input->gl_renderer;
    }

    static const decltype(::gpu::mojom::blink::GpuInfo::gl_extensions)& gl_extensions(const ::gpu::mojom::blink::GpuInfoPtr& input)
    {
        return input->gl_extensions;
    }

    static const decltype(::gpu::mojom::blink::GpuInfo::gl_ws_vendor)& gl_ws_vendor(const ::gpu::mojom::blink::GpuInfoPtr& input)
    {
        return input->gl_ws_vendor;
    }

    static const decltype(::gpu::mojom::blink::GpuInfo::gl_ws_version)& gl_ws_version(const ::gpu::mojom::blink::GpuInfoPtr& input)
    {
        return input->gl_ws_version;
    }

    static const decltype(::gpu::mojom::blink::GpuInfo::gl_ws_extensions)& gl_ws_extensions(const ::gpu::mojom::blink::GpuInfoPtr& input)
    {
        return input->gl_ws_extensions;
    }

    static decltype(::gpu::mojom::blink::GpuInfo::gl_reset_notification_strategy) gl_reset_notification_strategy(const ::gpu::mojom::blink::GpuInfoPtr& input)
    {
        return input->gl_reset_notification_strategy;
    }

    static const decltype(::gpu::mojom::blink::GpuInfo::gl_implementation_parts)& gl_implementation_parts(const ::gpu::mojom::blink::GpuInfoPtr& input)
    {
        return input->gl_implementation_parts;
    }

    static const decltype(::gpu::mojom::blink::GpuInfo::direct_rendering_version)& direct_rendering_version(const ::gpu::mojom::blink::GpuInfoPtr& input)
    {
        return input->direct_rendering_version;
    }

    static decltype(::gpu::mojom::blink::GpuInfo::sandboxed) sandboxed(const ::gpu::mojom::blink::GpuInfoPtr& input)
    {
        return input->sandboxed;
    }

    static decltype(::gpu::mojom::blink::GpuInfo::in_process_gpu) in_process_gpu(const ::gpu::mojom::blink::GpuInfoPtr& input)
    {
        return input->in_process_gpu;
    }

    static decltype(::gpu::mojom::blink::GpuInfo::passthrough_cmd_decoder) passthrough_cmd_decoder(const ::gpu::mojom::blink::GpuInfoPtr& input)
    {
        return input->passthrough_cmd_decoder;
    }

    static decltype(::gpu::mojom::blink::GpuInfo::can_support_threaded_texture_mailbox) can_support_threaded_texture_mailbox(
        const ::gpu::mojom::blink::GpuInfoPtr& input)
    {
        return input->can_support_threaded_texture_mailbox;
    }

    static decltype(::gpu::mojom::blink::GpuInfo::directml_feature_level) directml_feature_level(const ::gpu::mojom::blink::GpuInfoPtr& input)
    {
        return input->directml_feature_level;
    }

    static decltype(::gpu::mojom::blink::GpuInfo::d3d12_feature_level) d3d12_feature_level(const ::gpu::mojom::blink::GpuInfoPtr& input)
    {
        return input->d3d12_feature_level;
    }

    static decltype(::gpu::mojom::blink::GpuInfo::vulkan_version) vulkan_version(const ::gpu::mojom::blink::GpuInfoPtr& input)
    {
        return input->vulkan_version;
    }

    static const decltype(::gpu::mojom::blink::GpuInfo::overlay_info)& overlay_info(const ::gpu::mojom::blink::GpuInfoPtr& input)
    {
        return input->overlay_info;
    }

    static decltype(::gpu::mojom::blink::GpuInfo::shared_image_d3d) shared_image_d3d(const ::gpu::mojom::blink::GpuInfoPtr& input)
    {
        return input->shared_image_d3d;
    }

    static const decltype(::gpu::mojom::blink::GpuInfo::video_decode_accelerator_supported_profiles)& video_decode_accelerator_supported_profiles(
        const ::gpu::mojom::blink::GpuInfoPtr& input)
    {
        return input->video_decode_accelerator_supported_profiles;
    }

    static const decltype(::gpu::mojom::blink::GpuInfo::video_encode_accelerator_supported_profiles)& video_encode_accelerator_supported_profiles(
        const ::gpu::mojom::blink::GpuInfoPtr& input)
    {
        return input->video_encode_accelerator_supported_profiles;
    }

    static decltype(::gpu::mojom::blink::GpuInfo::jpeg_decode_accelerator_supported) jpeg_decode_accelerator_supported(
        const ::gpu::mojom::blink::GpuInfoPtr& input)
    {
        return input->jpeg_decode_accelerator_supported;
    }

    static const decltype(::gpu::mojom::blink::GpuInfo::image_decode_accelerator_supported_profiles)& image_decode_accelerator_supported_profiles(
        const ::gpu::mojom::blink::GpuInfoPtr& input)
    {
        return input->image_decode_accelerator_supported_profiles;
    }

    static decltype(::gpu::mojom::blink::GpuInfo::subpixel_font_rendering) subpixel_font_rendering(const ::gpu::mojom::blink::GpuInfoPtr& input)
    {
        return input->subpixel_font_rendering;
    }

    static decltype(::gpu::mojom::blink::GpuInfo::visibility_callback_call_count) visibility_callback_call_count(const ::gpu::mojom::blink::GpuInfoPtr& input)
    {
        return input->visibility_callback_call_count;
    }

    static decltype(::gpu::mojom::blink::GpuInfo::hardware_supports_vulkan) hardware_supports_vulkan(const ::gpu::mojom::blink::GpuInfoPtr& input)
    {
        return input->hardware_supports_vulkan;
    }

    static const decltype(::gpu::mojom::blink::GpuInfo::vulkan_info)& vulkan_info(const ::gpu::mojom::blink::GpuInfoPtr& input)
    {
        return input->vulkan_info;
    }

    static bool Read(::gpu::mojom::blink::GpuInfo::DataView input, ::gpu::mojom::blink::GpuInfoPtr* output);
};

} // namespace mojo

#endif // GPU_IPC_COMMON_GPU_INFO_MOJOM_BLINK_H_
