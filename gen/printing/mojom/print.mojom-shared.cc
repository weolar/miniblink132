// printing/mojom/print.mojom-shared.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "printing/mojom/print.mojom-shared.h"

// Used to support stream output operator for enums.
// TODO(dcheng): Consider omitting this somehow if not needed.
#include <ostream>
#include <utility>

#include "base/strings/stringprintf.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/lib/validation_util.h"
#include "third_party/perfetto/include/perfetto/tracing/traced_value.h"

#include "printing/mojom/print.mojom-params-data.h"
namespace printing {
namespace mojom {

NOINLINE static const char* ColorModelToStringHelper(ColorModel value)
{
    // Defined in a helper function to ensure that Clang generates a lookup table.
    switch (value) {
    case ColorModel::kUnknownColorModel:
        return "kUnknownColorModel";
    case ColorModel::kGray:
        return "kGray";
    case ColorModel::kColor:
        return "kColor";
    case ColorModel::kCMYK:
        return "kCMYK";
    case ColorModel::kCMY:
        return "kCMY";
    case ColorModel::kKCMY:
        return "kKCMY";
    case ColorModel::kCMYPlusK:
        return "kCMYPlusK";
    case ColorModel::kBlack:
        return "kBlack";
    case ColorModel::kGrayscale:
        return "kGrayscale";
    case ColorModel::kRGB:
        return "kRGB";
    case ColorModel::kRGB16:
        return "kRGB16";
    case ColorModel::kRGBA:
        return "kRGBA";
    case ColorModel::kColorModeColor:
        return "kColorModeColor";
    case ColorModel::kColorModeMonochrome:
        return "kColorModeMonochrome";
    case ColorModel::kHPColorColor:
        return "kHPColorColor";
    case ColorModel::kHPColorBlack:
        return "kHPColorBlack";
    case ColorModel::kPrintoutModeNormal:
        return "kPrintoutModeNormal";
    case ColorModel::kPrintoutModeNormalGray:
        return "kPrintoutModeNormalGray";
    case ColorModel::kProcessColorModelCMYK:
        return "kProcessColorModelCMYK";
    case ColorModel::kProcessColorModelGreyscale:
        return "kProcessColorModelGreyscale";
    case ColorModel::kProcessColorModelRGB:
        return "kProcessColorModelRGB";
    case ColorModel::kBrotherCUPSColor:
        return "kBrotherCUPSColor";
    case ColorModel::kBrotherCUPSMono:
        return "kBrotherCUPSMono";
    case ColorModel::kBrotherBRScript3Color:
        return "kBrotherBRScript3Color";
    case ColorModel::kBrotherBRScript3Black:
        return "kBrotherBRScript3Black";
    case ColorModel::kEpsonInkColor:
        return "kEpsonInkColor";
    case ColorModel::kEpsonInkMono:
        return "kEpsonInkMono";
    case ColorModel::kSharpARCModeCMColor:
        return "kSharpARCModeCMColor";
    case ColorModel::kSharpARCModeCMBW:
        return "kSharpARCModeCMBW";
    case ColorModel::kXeroxXRXColorAutomatic:
        return "kXeroxXRXColorAutomatic";
    case ColorModel::kXeroxXRXColorBW:
        return "{kXeroxXRXColorBW, kColorModelLast}";
    case ColorModel::kCanonCNColorModeColor:
        return "kCanonCNColorModeColor";
    case ColorModel::kCanonCNColorModeMono:
        return "kCanonCNColorModeMono";
    case ColorModel::kCanonCNIJGrayScaleOne:
        return "kCanonCNIJGrayScaleOne";
    case ColorModel::kCanonCNIJGrayScaleZero:
        return "kCanonCNIJGrayScaleZero";
    case ColorModel::kKonicaMinoltaSelectColorColor:
        return "kKonicaMinoltaSelectColorColor";
    case ColorModel::kKonicaMinoltaSelectColorGrayscale:
        return "kKonicaMinoltaSelectColorGrayscale";
    case ColorModel::kOkiOKControlColor:
        return "kOkiOKControlColor";
    case ColorModel::kOkiOKControlGray:
        return "kOkiOKControlGray";
    case ColorModel::kXeroxXROutputColorPrintAsColor:
        return "kXeroxXROutputColorPrintAsColor";
    case ColorModel::kXeroxXROutputColorPrintAsGrayscale:
        return "kXeroxXROutputColorPrintAsGrayscale";
    case ColorModel::kHpPjlColorAsGrayNo:
        return "kHpPjlColorAsGrayNo";
    case ColorModel::kHpPjlColorAsGrayYes:
        return "kHpPjlColorAsGrayYes";
    default:
        return nullptr;
    }
}

std::string ColorModelToString(ColorModel value)
{
    const char* str = ColorModelToStringHelper(value);
    if (!str) {
        return base::StringPrintf("Unknown ColorModel value: %i", static_cast<int32_t>(value));
    }
    return str;
}

std::ostream& operator<<(std::ostream& os, ColorModel value)
{
    return os << ColorModelToString(value);
}

NOINLINE static const char* DuplexModeToStringHelper(DuplexMode value)
{
    // Defined in a helper function to ensure that Clang generates a lookup table.
    switch (value) {
    case DuplexMode::kUnknownDuplexMode:
        return "kUnknownDuplexMode";
    case DuplexMode::kSimplex:
        return "kSimplex";
    case DuplexMode::kLongEdge:
        return "kLongEdge";
    case DuplexMode::kShortEdge:
        return "kShortEdge";
    default:
        return nullptr;
    }
}

std::string DuplexModeToString(DuplexMode value)
{
    const char* str = DuplexModeToStringHelper(value);
    if (!str) {
        return base::StringPrintf("Unknown DuplexMode value: %i", static_cast<int32_t>(value));
    }
    return str;
}

std::ostream& operator<<(std::ostream& os, DuplexMode value)
{
    return os << DuplexModeToString(value);
}

NOINLINE static const char* PageOrientationToStringHelper(PageOrientation value)
{
    // Defined in a helper function to ensure that Clang generates a lookup table.
    switch (value) {
    case PageOrientation::kUpright:
        return "kUpright";
    case PageOrientation::kRotateLeft:
        return "kRotateLeft";
    case PageOrientation::kRotateRight:
        return "kRotateRight";
    default:
        return nullptr;
    }
}

std::string PageOrientationToString(PageOrientation value)
{
    const char* str = PageOrientationToStringHelper(value);
    if (!str) {
        return base::StringPrintf("Unknown PageOrientation value: %i", static_cast<int32_t>(value));
    }
    return str;
}

std::ostream& operator<<(std::ostream& os, PageOrientation value)
{
    return os << PageOrientationToString(value);
}

NOINLINE static const char* PrintScalingOptionToStringHelper(PrintScalingOption value)
{
    // Defined in a helper function to ensure that Clang generates a lookup table.
    switch (value) {
    case PrintScalingOption::kNone:
        return "kNone";
    case PrintScalingOption::kFitToPrintableArea:
        return "kFitToPrintableArea";
    case PrintScalingOption::kSourceSize:
        return "kSourceSize";
    case PrintScalingOption::kFitToPaper:
        return "kFitToPaper";
    case PrintScalingOption::kCenterShrinkToFitPaper:
        return "kCenterShrinkToFitPaper";
    default:
        return nullptr;
    }
}

std::string PrintScalingOptionToString(PrintScalingOption value)
{
    const char* str = PrintScalingOptionToStringHelper(value);
    if (!str) {
        return base::StringPrintf("Unknown PrintScalingOption value: %i", static_cast<int32_t>(value));
    }
    return str;
}

std::ostream& operator<<(std::ostream& os, PrintScalingOption value)
{
    return os << PrintScalingOptionToString(value);
}

NOINLINE static const char* SkiaDocumentTypeToStringHelper(SkiaDocumentType value)
{
    // Defined in a helper function to ensure that Clang generates a lookup table.
    switch (value) {
    case SkiaDocumentType::kPDF:
        return "kPDF";
    case SkiaDocumentType::kMSKP:
        return "kMSKP";
    case SkiaDocumentType::kXPS:
        return "kXPS";
    default:
        return nullptr;
    }
}

std::string SkiaDocumentTypeToString(SkiaDocumentType value)
{
    const char* str = SkiaDocumentTypeToStringHelper(value);
    if (!str) {
        return base::StringPrintf("Unknown SkiaDocumentType value: %i", static_cast<int32_t>(value));
    }
    return str;
}

std::ostream& operator<<(std::ostream& os, SkiaDocumentType value)
{
    return os << SkiaDocumentTypeToString(value);
}

NOINLINE static const char* MetafileDataTypeToStringHelper(MetafileDataType value)
{
    // Defined in a helper function to ensure that Clang generates a lookup table.
    switch (value) {
    case MetafileDataType::kPDF:
        return "kPDF";
    case MetafileDataType::kEMF:
        return "kEMF";
    case MetafileDataType::kPostScriptEmf:
        return "kPostScriptEmf";
    default:
        return nullptr;
    }
}

std::string MetafileDataTypeToString(MetafileDataType value)
{
    const char* str = MetafileDataTypeToStringHelper(value);
    if (!str) {
        return base::StringPrintf("Unknown MetafileDataType value: %i", static_cast<int32_t>(value));
    }
    return str;
}

std::ostream& operator<<(std::ostream& os, MetafileDataType value)
{
    return os << MetafileDataTypeToString(value);
}

NOINLINE static const char* GenerateDocumentOutlineToStringHelper(GenerateDocumentOutline value)
{
    // Defined in a helper function to ensure that Clang generates a lookup table.
    switch (value) {
    case GenerateDocumentOutline::kNone:
        return "kNone";
    case GenerateDocumentOutline::kFromAccessibilityTreeHeaders:
        return "kFromAccessibilityTreeHeaders";
    default:
        return nullptr;
    }
}

std::string GenerateDocumentOutlineToString(GenerateDocumentOutline value)
{
    const char* str = GenerateDocumentOutlineToStringHelper(value);
    if (!str) {
        return base::StringPrintf("Unknown GenerateDocumentOutline value: %i", static_cast<int32_t>(value));
    }
    return str;
}

std::ostream& operator<<(std::ostream& os, GenerateDocumentOutline value)
{
    return os << GenerateDocumentOutlineToString(value);
}

NOINLINE static const char* MarginTypeToStringHelper(MarginType value)
{
    // Defined in a helper function to ensure that Clang generates a lookup table.
    switch (value) {
    case MarginType::kDefaultMargins:
        return "kDefaultMargins";
    case MarginType::kNoMargins:
        return "kNoMargins";
    case MarginType::kPrintableAreaMargins:
        return "kPrintableAreaMargins";
    case MarginType::kCustomMargins:
        return "kCustomMargins";
    default:
        return nullptr;
    }
}

std::string MarginTypeToString(MarginType value)
{
    const char* str = MarginTypeToStringHelper(value);
    if (!str) {
        return base::StringPrintf("Unknown MarginType value: %i", static_cast<int32_t>(value));
    }
    return str;
}

std::ostream& operator<<(std::ostream& os, MarginType value)
{
    return os << MarginTypeToString(value);
}

NOINLINE static const char* ResultCodeToStringHelper(ResultCode value)
{
    // Defined in a helper function to ensure that Clang generates a lookup table.
    switch (value) {
    case ResultCode::kSuccess:
        return "kSuccess";
    case ResultCode::kFailed:
        return "kFailed";
    case ResultCode::kAccessDenied:
        return "kAccessDenied";
    case ResultCode::kCanceled:
        return "kCanceled";
    default:
        return nullptr;
    }
}

std::string ResultCodeToString(ResultCode value)
{
    const char* str = ResultCodeToStringHelper(value);
    if (!str) {
        return base::StringPrintf("Unknown ResultCode value: %i", static_cast<int32_t>(value));
    }
    return str;
}

std::ostream& operator<<(std::ostream& os, ResultCode value)
{
    return os << ResultCodeToString(value);
}

NOINLINE static const char* PrinterTypeToStringHelper(PrinterType value)
{
    // Defined in a helper function to ensure that Clang generates a lookup table.
    switch (value) {
    case PrinterType::kPrivetDeprecated:
        return "kPrivetDeprecated";
    case PrinterType::kExtension:
        return "kExtension";
    case PrinterType::kPdf:
        return "kPdf";
    case PrinterType::kLocal:
        return "kLocal";
    case PrinterType::kCloudDeprecated:
        return "kCloudDeprecated";
    default:
        return nullptr;
    }
}

std::string PrinterTypeToString(PrinterType value)
{
    const char* str = PrinterTypeToStringHelper(value);
    if (!str) {
        return base::StringPrintf("Unknown PrinterType value: %i", static_cast<int32_t>(value));
    }
    return str;
}

std::ostream& operator<<(std::ostream& os, PrinterType value)
{
    return os << PrinterTypeToString(value);
}

NOINLINE static const char* PrinterLanguageTypeToStringHelper(PrinterLanguageType value)
{
    // Defined in a helper function to ensure that Clang generates a lookup table.
    switch (value) {
    case PrinterLanguageType::kNone:
        return "kNone";
    case PrinterLanguageType::kTextOnly:
        return "kTextOnly";
    case PrinterLanguageType::kXps:
        return "kXps";
    case PrinterLanguageType::kPostscriptLevel2:
        return "kPostscriptLevel2";
    case PrinterLanguageType::kPostscriptLevel3:
        return "kPostscriptLevel3";
    default:
        return nullptr;
    }
}

std::string PrinterLanguageTypeToString(PrinterLanguageType value)
{
    const char* str = PrinterLanguageTypeToStringHelper(value);
    if (!str) {
        return base::StringPrintf("Unknown PrinterLanguageType value: %i", static_cast<int32_t>(value));
    }
    return str;
}

std::ostream& operator<<(std::ostream& os, PrinterLanguageType value)
{
    return os << PrinterLanguageTypeToString(value);
}

namespace internal {

// static
bool PageSizeMargins_Data::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    if (!data)
        return true;
    if (!ValidateUnversionedStructHeaderAndSizeAndClaimMemory(data, 56, validation_context)) {
        return false;
    }

    // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
    // the message comes from an older version.
    [[maybe_unused]] const PageSizeMargins_Data* object = static_cast<const PageSizeMargins_Data*>(data);

    return true;
}

PageSizeMargins_Data::PageSizeMargins_Data()
    : header_({ sizeof(*this), 0 })
{
}

// static
bool PageRange_Data::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    if (!data)
        return true;
    if (!ValidateUnversionedStructHeaderAndSizeAndClaimMemory(data, 16, validation_context)) {
        return false;
    }

    // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
    // the message comes from an older version.
    [[maybe_unused]] const PageRange_Data* object = static_cast<const PageRange_Data*>(data);

    return true;
}

PageRange_Data::PageRange_Data()
    : header_({ sizeof(*this), 0 })
{
}

} // namespace internal
} // namespace mojom
} // namespace printing

namespace perfetto {

// static
void TraceFormatTraits<::printing::mojom::ColorModel>::WriteIntoTrace(perfetto::TracedValue context, ::printing::mojom::ColorModel value)
{
    return std::move(context).WriteString(::printing::mojom::ColorModelToString(value));
}

} // namespace perfetto

namespace perfetto {

// static
void TraceFormatTraits<::printing::mojom::DuplexMode>::WriteIntoTrace(perfetto::TracedValue context, ::printing::mojom::DuplexMode value)
{
    return std::move(context).WriteString(::printing::mojom::DuplexModeToString(value));
}

} // namespace perfetto

namespace perfetto {

// static
void TraceFormatTraits<::printing::mojom::PageOrientation>::WriteIntoTrace(perfetto::TracedValue context, ::printing::mojom::PageOrientation value)
{
    return std::move(context).WriteString(::printing::mojom::PageOrientationToString(value));
}

} // namespace perfetto

namespace perfetto {

// static
void TraceFormatTraits<::printing::mojom::PrintScalingOption>::WriteIntoTrace(perfetto::TracedValue context, ::printing::mojom::PrintScalingOption value)
{
    return std::move(context).WriteString(::printing::mojom::PrintScalingOptionToString(value));
}

} // namespace perfetto

namespace perfetto {

// static
void TraceFormatTraits<::printing::mojom::SkiaDocumentType>::WriteIntoTrace(perfetto::TracedValue context, ::printing::mojom::SkiaDocumentType value)
{
    return std::move(context).WriteString(::printing::mojom::SkiaDocumentTypeToString(value));
}

} // namespace perfetto

namespace perfetto {

// static
void TraceFormatTraits<::printing::mojom::MetafileDataType>::WriteIntoTrace(perfetto::TracedValue context, ::printing::mojom::MetafileDataType value)
{
    return std::move(context).WriteString(::printing::mojom::MetafileDataTypeToString(value));
}

} // namespace perfetto

namespace perfetto {

// static
void TraceFormatTraits<::printing::mojom::GenerateDocumentOutline>::WriteIntoTrace(
    perfetto::TracedValue context, ::printing::mojom::GenerateDocumentOutline value)
{
    return std::move(context).WriteString(::printing::mojom::GenerateDocumentOutlineToString(value));
}

} // namespace perfetto

namespace perfetto {

// static
void TraceFormatTraits<::printing::mojom::MarginType>::WriteIntoTrace(perfetto::TracedValue context, ::printing::mojom::MarginType value)
{
    return std::move(context).WriteString(::printing::mojom::MarginTypeToString(value));
}

} // namespace perfetto

namespace perfetto {

// static
void TraceFormatTraits<::printing::mojom::ResultCode>::WriteIntoTrace(perfetto::TracedValue context, ::printing::mojom::ResultCode value)
{
    return std::move(context).WriteString(::printing::mojom::ResultCodeToString(value));
}

} // namespace perfetto

namespace perfetto {

// static
void TraceFormatTraits<::printing::mojom::PrinterType>::WriteIntoTrace(perfetto::TracedValue context, ::printing::mojom::PrinterType value)
{
    return std::move(context).WriteString(::printing::mojom::PrinterTypeToString(value));
}

} // namespace perfetto

namespace perfetto {

// static
void TraceFormatTraits<::printing::mojom::PrinterLanguageType>::WriteIntoTrace(perfetto::TracedValue context, ::printing::mojom::PrinterLanguageType value)
{
    return std::move(context).WriteString(::printing::mojom::PrinterLanguageTypeToString(value));
}

} // namespace perfetto