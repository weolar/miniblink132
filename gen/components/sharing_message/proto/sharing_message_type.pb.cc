// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sharing_message_type.proto

#include "sharing_message_type.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace sharing_message {
} // namespace sharing_message
namespace sharing_message {
bool MessageType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> MessageType_strings[13] = {};

static const char MessageType_names[] = "ACK_MESSAGE"
                                        "CLICK_TO_CALL_MESSAGE"
                                        "DISCOVERY_REQUEST"
                                        "OPTIMIZATION_GUIDE_PUSH_NOTIFICATION"
                                        "PEER_CONNECTION_ICE_CANDIDATES_MESSAGE"
                                        "PEER_CONNECTION_OFFER_MESSAGE"
                                        "PING_MESSAGE"
                                        "REMOTE_COPY_MESSAGE"
                                        "SEND_TAB_TO_SELF_PUSH_NOTIFICATION"
                                        "SHARED_CLIPBOARD_MESSAGE"
                                        "SMS_FETCH_REQUEST"
                                        "UNKNOWN_MESSAGE"
                                        "WEB_RTC_SIGNALING_FRAME";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry MessageType_entries[] = {
    { { MessageType_names + 0, 11 }, 2 },
    { { MessageType_names + 11, 21 }, 3 },
    { { MessageType_names + 32, 17 }, 9 },
    { { MessageType_names + 49, 36 }, 11 },
    { { MessageType_names + 85, 38 }, 8 },
    { { MessageType_names + 123, 29 }, 7 },
    { { MessageType_names + 152, 12 }, 1 },
    { { MessageType_names + 164, 19 }, 6 },
    { { MessageType_names + 183, 34 }, 12 },
    { { MessageType_names + 217, 24 }, 4 },
    { { MessageType_names + 241, 17 }, 5 },
    { { MessageType_names + 258, 15 }, 0 },
    { { MessageType_names + 273, 23 }, 10 },
};

static const int MessageType_entries_by_number[] = {
    11, // 0 -> UNKNOWN_MESSAGE
    6, // 1 -> PING_MESSAGE
    0, // 2 -> ACK_MESSAGE
    1, // 3 -> CLICK_TO_CALL_MESSAGE
    9, // 4 -> SHARED_CLIPBOARD_MESSAGE
    10, // 5 -> SMS_FETCH_REQUEST
    7, // 6 -> REMOTE_COPY_MESSAGE
    5, // 7 -> PEER_CONNECTION_OFFER_MESSAGE
    4, // 8 -> PEER_CONNECTION_ICE_CANDIDATES_MESSAGE
    2, // 9 -> DISCOVERY_REQUEST
    12, // 10 -> WEB_RTC_SIGNALING_FRAME
    3, // 11 -> OPTIMIZATION_GUIDE_PUSH_NOTIFICATION
    8, // 12 -> SEND_TAB_TO_SELF_PUSH_NOTIFICATION
};

const std::string& MessageType_Name(MessageType value)
{
    static const bool dummy
        = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(MessageType_entries, MessageType_entries_by_number, 13, MessageType_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(MessageType_entries, MessageType_entries_by_number, 13, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : MessageType_strings[idx].get();
}
bool MessageType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MessageType* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(MessageType_entries, 13, name, &int_value);
    if (success) {
        *value = static_cast<MessageType>(int_value);
    }
    return success;
}

// @@protoc_insertion_point(namespace_scope)
} // namespace sharing_message
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
