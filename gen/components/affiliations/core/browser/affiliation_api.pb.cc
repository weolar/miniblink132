// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: affiliation_api.proto

#include "affiliation_api.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace affiliation_pb {
PROTOBUF_CONSTEXPR Affiliation::Affiliation(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.facet_)*/ {}, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct AffiliationDefaultTypeInternal {
    PROTOBUF_CONSTEXPR AffiliationDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~AffiliationDefaultTypeInternal()
    {
    }
    union {
        Affiliation _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AffiliationDefaultTypeInternal _Affiliation_default_instance_;
PROTOBUF_CONSTEXPR Facet::Facet(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.main_domain_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.branding_info_)*/ nullptr,
        /*decltype(_impl_.change_password_info_)*/ nullptr, /*decltype(_impl_.is_on_internal_network_)*/ false }
{
}
struct FacetDefaultTypeInternal {
    PROTOBUF_CONSTEXPR FacetDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~FacetDefaultTypeInternal()
    {
    }
    union {
        Facet _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FacetDefaultTypeInternal _Facet_default_instance_;
PROTOBUF_CONSTEXPR FacetGroup::FacetGroup(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.facet_)*/ {},
        /*decltype(_impl_.group_branding_info_)*/ nullptr }
{
}
struct FacetGroupDefaultTypeInternal {
    PROTOBUF_CONSTEXPR FacetGroupDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~FacetGroupDefaultTypeInternal()
    {
    }
    union {
        FacetGroup _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FacetGroupDefaultTypeInternal _FacetGroup_default_instance_;
PROTOBUF_CONSTEXPR GroupBrandingInfo::GroupBrandingInfo(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.icon_url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.icon_url_not_hosted_by_google_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.icon_width_)*/ 0, /*decltype(_impl_.icon_height_)*/ 0, /*decltype(_impl_.elide_info_)*/ 0 }
{
}
struct GroupBrandingInfoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR GroupBrandingInfoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~GroupBrandingInfoDefaultTypeInternal()
    {
    }
    union {
        GroupBrandingInfo _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GroupBrandingInfoDefaultTypeInternal _GroupBrandingInfo_default_instance_;
PROTOBUF_CONSTEXPR BrandingInfo::BrandingInfo(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.icon_url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.icon_url_not_hosted_by_google_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.icon_width_)*/ 0, /*decltype(_impl_.icon_height_)*/ 0, /*decltype(_impl_.elide_info_)*/ 0 }
{
}
struct BrandingInfoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR BrandingInfoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~BrandingInfoDefaultTypeInternal()
    {
    }
    union {
        BrandingInfo _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BrandingInfoDefaultTypeInternal _BrandingInfo_default_instance_;
PROTOBUF_CONSTEXPR ChangePasswordInfo::ChangePasswordInfo(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.change_password_url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct ChangePasswordInfoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ChangePasswordInfoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ChangePasswordInfoDefaultTypeInternal()
    {
    }
    union {
        ChangePasswordInfo _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChangePasswordInfoDefaultTypeInternal _ChangePasswordInfo_default_instance_;
PROTOBUF_CONSTEXPR LookupAffiliationMask::LookupAffiliationMask(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.locale_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.preferred_icon_size_)*/ 0,
        /*decltype(_impl_.branding_info_)*/ false, /*decltype(_impl_.icon_not_hosted_by_google_)*/ false, /*decltype(_impl_.grouping_info_)*/ false,
        /*decltype(_impl_.group_branding_info_)*/ false, /*decltype(_impl_.change_password_info_)*/ false, /*decltype(_impl_.psl_extension_list_)*/ false,
        /*decltype(_impl_.is_on_internal_network_)*/ false, /*decltype(_impl_.dataset_)*/ 0 }
{
}
struct LookupAffiliationMaskDefaultTypeInternal {
    PROTOBUF_CONSTEXPR LookupAffiliationMaskDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~LookupAffiliationMaskDefaultTypeInternal()
    {
    }
    union {
        LookupAffiliationMask _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LookupAffiliationMaskDefaultTypeInternal
    _LookupAffiliationMask_default_instance_;
PROTOBUF_CONSTEXPR LookupAffiliationRequest::LookupAffiliationRequest(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.facet_)*/ {}, /*decltype(_impl_.mask_)*/ nullptr }
{
}
struct LookupAffiliationRequestDefaultTypeInternal {
    PROTOBUF_CONSTEXPR LookupAffiliationRequestDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~LookupAffiliationRequestDefaultTypeInternal()
    {
    }
    union {
        LookupAffiliationRequest _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LookupAffiliationRequestDefaultTypeInternal
    _LookupAffiliationRequest_default_instance_;
PROTOBUF_CONSTEXPR LookupAffiliationResponse::LookupAffiliationResponse(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.affiliation_)*/ {}, /*decltype(_impl_.group_)*/ {}, /*decltype(_impl_.psl_extensions_)*/ {},
        /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct LookupAffiliationResponseDefaultTypeInternal {
    PROTOBUF_CONSTEXPR LookupAffiliationResponseDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~LookupAffiliationResponseDefaultTypeInternal()
    {
    }
    union {
        LookupAffiliationResponse _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LookupAffiliationResponseDefaultTypeInternal
    _LookupAffiliationResponse_default_instance_;
PROTOBUF_CONSTEXPR LookupAffiliationByHashPrefixRequest::LookupAffiliationByHashPrefixRequest(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.hash_prefixes_)*/ {},
        /*decltype(_impl_.mask_)*/ nullptr, /*decltype(_impl_.hash_prefix_length_)*/ 0u }
{
}
struct LookupAffiliationByHashPrefixRequestDefaultTypeInternal {
    PROTOBUF_CONSTEXPR LookupAffiliationByHashPrefixRequestDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~LookupAffiliationByHashPrefixRequestDefaultTypeInternal()
    {
    }
    union {
        LookupAffiliationByHashPrefixRequest _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LookupAffiliationByHashPrefixRequestDefaultTypeInternal
    _LookupAffiliationByHashPrefixRequest_default_instance_;
PROTOBUF_CONSTEXPR LookupAffiliationByHashPrefixResponse::LookupAffiliationByHashPrefixResponse(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.affiliations_)*/ {}, /*decltype(_impl_.groups_)*/ {}, /*decltype(_impl_.psl_extensions_)*/ {},
        /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct LookupAffiliationByHashPrefixResponseDefaultTypeInternal {
    PROTOBUF_CONSTEXPR LookupAffiliationByHashPrefixResponseDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~LookupAffiliationByHashPrefixResponseDefaultTypeInternal()
    {
    }
    union {
        LookupAffiliationByHashPrefixResponse _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LookupAffiliationByHashPrefixResponseDefaultTypeInternal
    _LookupAffiliationByHashPrefixResponse_default_instance_;
} // namespace affiliation_pb
namespace affiliation_pb {
bool BrandingInfo_ElideInfo_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> BrandingInfo_ElideInfo_strings[3] = {};

static const char BrandingInfo_ElideInfo_names[] = "ELIDE_FROM_BACK"
                                                   "ELIDE_FROM_FRONT"
                                                   "UNKNOWN_ELIDE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry BrandingInfo_ElideInfo_entries[] = {
    { { BrandingInfo_ElideInfo_names + 0, 15 }, 2 },
    { { BrandingInfo_ElideInfo_names + 15, 16 }, 1 },
    { { BrandingInfo_ElideInfo_names + 31, 13 }, 0 },
};

static const int BrandingInfo_ElideInfo_entries_by_number[] = {
    2, // 0 -> UNKNOWN_ELIDE
    1, // 1 -> ELIDE_FROM_FRONT
    0, // 2 -> ELIDE_FROM_BACK
};

const std::string& BrandingInfo_ElideInfo_Name(BrandingInfo_ElideInfo value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        BrandingInfo_ElideInfo_entries, BrandingInfo_ElideInfo_entries_by_number, 3, BrandingInfo_ElideInfo_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(BrandingInfo_ElideInfo_entries, BrandingInfo_ElideInfo_entries_by_number, 3, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : BrandingInfo_ElideInfo_strings[idx].get();
}
bool BrandingInfo_ElideInfo_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BrandingInfo_ElideInfo* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(BrandingInfo_ElideInfo_entries, 3, name, &int_value);
    if (success) {
        *value = static_cast<BrandingInfo_ElideInfo>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr BrandingInfo_ElideInfo BrandingInfo::UNKNOWN_ELIDE;
constexpr BrandingInfo_ElideInfo BrandingInfo::ELIDE_FROM_FRONT;
constexpr BrandingInfo_ElideInfo BrandingInfo::ELIDE_FROM_BACK;
constexpr BrandingInfo_ElideInfo BrandingInfo::ElideInfo_MIN;
constexpr BrandingInfo_ElideInfo BrandingInfo::ElideInfo_MAX;
constexpr int BrandingInfo::ElideInfo_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool LookupAffiliationMask_RequestedDataset_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> LookupAffiliationMask_RequestedDataset_strings[3] = {};

static const char LookupAffiliationMask_RequestedDataset_names[] = "DEFAULT_DATASET"
                                                                   "EXPERIMENTAL_DATASET"
                                                                   "REQUESTED_DATASET_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry LookupAffiliationMask_RequestedDataset_entries[] = {
    { { LookupAffiliationMask_RequestedDataset_names + 0, 15 }, 1 },
    { { LookupAffiliationMask_RequestedDataset_names + 15, 20 }, 2 },
    { { LookupAffiliationMask_RequestedDataset_names + 35, 29 }, 0 },
};

static const int LookupAffiliationMask_RequestedDataset_entries_by_number[] = {
    2, // 0 -> REQUESTED_DATASET_UNSPECIFIED
    0, // 1 -> DEFAULT_DATASET
    1, // 2 -> EXPERIMENTAL_DATASET
};

const std::string& LookupAffiliationMask_RequestedDataset_Name(LookupAffiliationMask_RequestedDataset value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(LookupAffiliationMask_RequestedDataset_entries,
        LookupAffiliationMask_RequestedDataset_entries_by_number, 3, LookupAffiliationMask_RequestedDataset_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        LookupAffiliationMask_RequestedDataset_entries, LookupAffiliationMask_RequestedDataset_entries_by_number, 3, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : LookupAffiliationMask_RequestedDataset_strings[idx].get();
}
bool LookupAffiliationMask_RequestedDataset_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LookupAffiliationMask_RequestedDataset* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(LookupAffiliationMask_RequestedDataset_entries, 3, name, &int_value);
    if (success) {
        *value = static_cast<LookupAffiliationMask_RequestedDataset>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr LookupAffiliationMask_RequestedDataset LookupAffiliationMask::REQUESTED_DATASET_UNSPECIFIED;
constexpr LookupAffiliationMask_RequestedDataset LookupAffiliationMask::DEFAULT_DATASET;
constexpr LookupAffiliationMask_RequestedDataset LookupAffiliationMask::EXPERIMENTAL_DATASET;
constexpr LookupAffiliationMask_RequestedDataset LookupAffiliationMask::RequestedDataset_MIN;
constexpr LookupAffiliationMask_RequestedDataset LookupAffiliationMask::RequestedDataset_MAX;
constexpr int LookupAffiliationMask::RequestedDataset_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class Affiliation::_Internal {
public:
};

Affiliation::Affiliation(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:affiliation_pb.Affiliation)
}
Affiliation::Affiliation(const Affiliation& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    Affiliation* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.facet_) { from._impl_.facet_ }, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:affiliation_pb.Affiliation)
}

inline void Affiliation::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.facet_) { arena }, /*decltype(_impl_._cached_size_)*/ {} };
}

Affiliation::~Affiliation()
{
    // @@protoc_insertion_point(destructor:affiliation_pb.Affiliation)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void Affiliation::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.facet_.~RepeatedPtrField();
}

void Affiliation::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void Affiliation::Clear()
{
    // @@protoc_insertion_point(message_clear_start:affiliation_pb.Affiliation)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.facet_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* Affiliation::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .affiliation_pb.Facet facet = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_facet(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* Affiliation::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:affiliation_pb.Affiliation)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .affiliation_pb.Facet facet = 1;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_facet_size()); i < n; i++) {
        const auto& repfield = this->_internal_facet(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:affiliation_pb.Affiliation)
    return target;
}

size_t Affiliation::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:affiliation_pb.Affiliation)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .affiliation_pb.Facet facet = 1;
    total_size += 1UL * this->_internal_facet_size();
    for (const auto& msg : this->_impl_.facet_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void Affiliation::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const Affiliation*>(&from));
}

void Affiliation::MergeFrom(const Affiliation& from)
{
    Affiliation* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:affiliation_pb.Affiliation)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.facet_.MergeFrom(from._impl_.facet_);
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Affiliation::CopyFrom(const Affiliation& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:affiliation_pb.Affiliation)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool Affiliation::IsInitialized() const
{
    return true;
}

void Affiliation::InternalSwap(Affiliation* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.facet_.InternalSwap(&other->_impl_.facet_);
}

std::string Affiliation::GetTypeName() const
{
    return "affiliation_pb.Affiliation";
}

// ===================================================================

class Facet::_Internal {
public:
    using HasBits = decltype(std::declval<Facet>()._impl_._has_bits_);
    static void set_has_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static const ::affiliation_pb::BrandingInfo& branding_info(const Facet* msg);
    static void set_has_branding_info(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_main_domain(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static const ::affiliation_pb::ChangePasswordInfo& change_password_info(const Facet* msg);
    static void set_has_change_password_info(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_is_on_internal_network(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
};

const ::affiliation_pb::BrandingInfo& Facet::_Internal::branding_info(const Facet* msg)
{
    return *msg->_impl_.branding_info_;
}
const ::affiliation_pb::ChangePasswordInfo& Facet::_Internal::change_password_info(const Facet* msg)
{
    return *msg->_impl_.change_password_info_;
}
Facet::Facet(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:affiliation_pb.Facet)
}
Facet::Facet(const Facet& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    Facet* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.id_) {},
        decltype(_impl_.main_domain_) {}, decltype(_impl_.branding_info_) { nullptr }, decltype(_impl_.change_password_info_) { nullptr },
        decltype(_impl_.is_on_internal_network_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_id()) {
        _this->_impl_.id_.Set(from._internal_id(), _this->GetArenaForAllocation());
    }
    _impl_.main_domain_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.main_domain_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_main_domain()) {
        _this->_impl_.main_domain_.Set(from._internal_main_domain(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_branding_info()) {
        _this->_impl_.branding_info_ = new ::affiliation_pb::BrandingInfo(*from._impl_.branding_info_);
    }
    if (from._internal_has_change_password_info()) {
        _this->_impl_.change_password_info_ = new ::affiliation_pb::ChangePasswordInfo(*from._impl_.change_password_info_);
    }
    _this->_impl_.is_on_internal_network_ = from._impl_.is_on_internal_network_;
    // @@protoc_insertion_point(copy_constructor:affiliation_pb.Facet)
}

inline void Facet::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.id_) {}, decltype(_impl_.main_domain_) {},
        decltype(_impl_.branding_info_) { nullptr }, decltype(_impl_.change_password_info_) { nullptr }, decltype(_impl_.is_on_internal_network_) { false } };
    _impl_.id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.main_domain_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.main_domain_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Facet::~Facet()
{
    // @@protoc_insertion_point(destructor:affiliation_pb.Facet)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void Facet::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.id_.Destroy();
    _impl_.main_domain_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.branding_info_;
    if (this != internal_default_instance())
        delete _impl_.change_password_info_;
}

void Facet::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void Facet::Clear()
{
    // @@protoc_insertion_point(message_clear_start:affiliation_pb.Facet)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.id_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.main_domain_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            GOOGLE_DCHECK(_impl_.branding_info_ != nullptr);
            _impl_.branding_info_->Clear();
        }
        if (cached_has_bits & 0x00000008u) {
            GOOGLE_DCHECK(_impl_.change_password_info_ != nullptr);
            _impl_.change_password_info_->Clear();
        }
    }
    _impl_.is_on_internal_network_ = false;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* Facet::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string id = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .affiliation_pb.BrandingInfo branding_info = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_branding_info(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string main_domain = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_main_domain();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .affiliation_pb.ChangePasswordInfo change_password_info = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr = ctx->ParseMessage(_internal_mutable_change_password_info(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool is_on_internal_network = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
                _Internal::set_has_is_on_internal_network(&has_bits);
                _impl_.is_on_internal_network_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* Facet::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:affiliation_pb.Facet)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string id = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_id(), target);
    }

    // optional .affiliation_pb.BrandingInfo branding_info = 2;
    if (cached_has_bits & 0x00000004u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::branding_info(this), _Internal::branding_info(this).GetCachedSize(), target, stream);
    }

    // optional string main_domain = 3;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(3, this->_internal_main_domain(), target);
    }

    // optional .affiliation_pb.ChangePasswordInfo change_password_info = 4;
    if (cached_has_bits & 0x00000008u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            4, _Internal::change_password_info(this), _Internal::change_password_info(this).GetCachedSize(), target, stream);
    }

    // optional bool is_on_internal_network = 5;
    if (cached_has_bits & 0x00000010u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_is_on_internal_network(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:affiliation_pb.Facet)
    return target;
}

size_t Facet::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:affiliation_pb.Facet)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        // optional string id = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_id());
        }

        // optional string main_domain = 3;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_main_domain());
        }

        // optional .affiliation_pb.BrandingInfo branding_info = 2;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.branding_info_);
        }

        // optional .affiliation_pb.ChangePasswordInfo change_password_info = 4;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.change_password_info_);
        }

        // optional bool is_on_internal_network = 5;
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + 1;
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void Facet::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const Facet*>(&from));
}

void Facet::MergeFrom(const Facet& from)
{
    Facet* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:affiliation_pb.Facet)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_id(from._internal_id());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_main_domain(from._internal_main_domain());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_mutable_branding_info()->::affiliation_pb::BrandingInfo::MergeFrom(from._internal_branding_info());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_mutable_change_password_info()->::affiliation_pb::ChangePasswordInfo::MergeFrom(from._internal_change_password_info());
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_impl_.is_on_internal_network_ = from._impl_.is_on_internal_network_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Facet::CopyFrom(const Facet& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:affiliation_pb.Facet)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool Facet::IsInitialized() const
{
    return true;
}

void Facet::InternalSwap(Facet* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.id_, lhs_arena, &other->_impl_.id_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.main_domain_, lhs_arena, &other->_impl_.main_domain_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(Facet, _impl_.is_on_internal_network_) + sizeof(Facet::_impl_.is_on_internal_network_)
        - PROTOBUF_FIELD_OFFSET(Facet, _impl_.branding_info_)>(
        reinterpret_cast<char*>(&_impl_.branding_info_), reinterpret_cast<char*>(&other->_impl_.branding_info_));
}

std::string Facet::GetTypeName() const
{
    return "affiliation_pb.Facet";
}

// ===================================================================

class FacetGroup::_Internal {
public:
    using HasBits = decltype(std::declval<FacetGroup>()._impl_._has_bits_);
    static const ::affiliation_pb::GroupBrandingInfo& group_branding_info(const FacetGroup* msg);
    static void set_has_group_branding_info(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

const ::affiliation_pb::GroupBrandingInfo& FacetGroup::_Internal::group_branding_info(const FacetGroup* msg)
{
    return *msg->_impl_.group_branding_info_;
}
FacetGroup::FacetGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:affiliation_pb.FacetGroup)
}
FacetGroup::FacetGroup(const FacetGroup& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    FacetGroup* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.facet_) { from._impl_.facet_ }, decltype(_impl_.group_branding_info_) { nullptr } };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_group_branding_info()) {
        _this->_impl_.group_branding_info_ = new ::affiliation_pb::GroupBrandingInfo(*from._impl_.group_branding_info_);
    }
    // @@protoc_insertion_point(copy_constructor:affiliation_pb.FacetGroup)
}

inline void FacetGroup::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.facet_) { arena },
        decltype(_impl_.group_branding_info_) { nullptr } };
}

FacetGroup::~FacetGroup()
{
    // @@protoc_insertion_point(destructor:affiliation_pb.FacetGroup)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void FacetGroup::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.facet_.~RepeatedPtrField();
    if (this != internal_default_instance())
        delete _impl_.group_branding_info_;
}

void FacetGroup::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void FacetGroup::Clear()
{
    // @@protoc_insertion_point(message_clear_start:affiliation_pb.FacetGroup)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.facet_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        GOOGLE_DCHECK(_impl_.group_branding_info_ != nullptr);
        _impl_.group_branding_info_->Clear();
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* FacetGroup::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .affiliation_pb.Facet facet = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_facet(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional .affiliation_pb.GroupBrandingInfo group_branding_info = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_group_branding_info(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* FacetGroup::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:affiliation_pb.FacetGroup)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .affiliation_pb.Facet facet = 1;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_facet_size()); i < n; i++) {
        const auto& repfield = this->_internal_facet(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
    }

    cached_has_bits = _impl_._has_bits_[0];
    // optional .affiliation_pb.GroupBrandingInfo group_branding_info = 2;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::group_branding_info(this), _Internal::group_branding_info(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:affiliation_pb.FacetGroup)
    return target;
}

size_t FacetGroup::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:affiliation_pb.FacetGroup)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .affiliation_pb.Facet facet = 1;
    total_size += 1UL * this->_internal_facet_size();
    for (const auto& msg : this->_impl_.facet_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // optional .affiliation_pb.GroupBrandingInfo group_branding_info = 2;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.group_branding_info_);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void FacetGroup::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const FacetGroup*>(&from));
}

void FacetGroup::MergeFrom(const FacetGroup& from)
{
    FacetGroup* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:affiliation_pb.FacetGroup)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.facet_.MergeFrom(from._impl_.facet_);
    if (from._internal_has_group_branding_info()) {
        _this->_internal_mutable_group_branding_info()->::affiliation_pb::GroupBrandingInfo::MergeFrom(from._internal_group_branding_info());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FacetGroup::CopyFrom(const FacetGroup& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:affiliation_pb.FacetGroup)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool FacetGroup::IsInitialized() const
{
    return true;
}

void FacetGroup::InternalSwap(FacetGroup* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.facet_.InternalSwap(&other->_impl_.facet_);
    swap(_impl_.group_branding_info_, other->_impl_.group_branding_info_);
}

std::string FacetGroup::GetTypeName() const
{
    return "affiliation_pb.FacetGroup";
}

// ===================================================================

class GroupBrandingInfo::_Internal {
public:
    using HasBits = decltype(std::declval<GroupBrandingInfo>()._impl_._has_bits_);
    static void set_has_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_elide_info(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
    static void set_has_icon_url(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_icon_width(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_icon_height(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static void set_has_icon_url_not_hosted_by_google(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
};

GroupBrandingInfo::GroupBrandingInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:affiliation_pb.GroupBrandingInfo)
}
GroupBrandingInfo::GroupBrandingInfo(const GroupBrandingInfo& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    GroupBrandingInfo* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.name_) {},
        decltype(_impl_.icon_url_) {}, decltype(_impl_.icon_url_not_hosted_by_google_) {}, decltype(_impl_.icon_width_) {}, decltype(_impl_.icon_height_) {},
        decltype(_impl_.elide_info_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_name()) {
        _this->_impl_.name_.Set(from._internal_name(), _this->GetArenaForAllocation());
    }
    _impl_.icon_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.icon_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_icon_url()) {
        _this->_impl_.icon_url_.Set(from._internal_icon_url(), _this->GetArenaForAllocation());
    }
    _impl_.icon_url_not_hosted_by_google_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.icon_url_not_hosted_by_google_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_icon_url_not_hosted_by_google()) {
        _this->_impl_.icon_url_not_hosted_by_google_.Set(from._internal_icon_url_not_hosted_by_google(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.icon_width_, &from._impl_.icon_width_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.elide_info_) - reinterpret_cast<char*>(&_impl_.icon_width_)) + sizeof(_impl_.elide_info_));
    // @@protoc_insertion_point(copy_constructor:affiliation_pb.GroupBrandingInfo)
}

inline void GroupBrandingInfo::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.name_) {}, decltype(_impl_.icon_url_) {},
        decltype(_impl_.icon_url_not_hosted_by_google_) {}, decltype(_impl_.icon_width_) { 0 }, decltype(_impl_.icon_height_) { 0 },
        decltype(_impl_.elide_info_) { 0 } };
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.icon_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.icon_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.icon_url_not_hosted_by_google_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.icon_url_not_hosted_by_google_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GroupBrandingInfo::~GroupBrandingInfo()
{
    // @@protoc_insertion_point(destructor:affiliation_pb.GroupBrandingInfo)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void GroupBrandingInfo::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.name_.Destroy();
    _impl_.icon_url_.Destroy();
    _impl_.icon_url_not_hosted_by_google_.Destroy();
}

void GroupBrandingInfo::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void GroupBrandingInfo::Clear()
{
    // @@protoc_insertion_point(message_clear_start:affiliation_pb.GroupBrandingInfo)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.name_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.icon_url_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            _impl_.icon_url_not_hosted_by_google_.ClearNonDefaultToEmpty();
        }
    }
    if (cached_has_bits & 0x00000038u) {
        ::memset(&_impl_.icon_width_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.elide_info_) - reinterpret_cast<char*>(&_impl_.icon_width_)) + sizeof(_impl_.elide_info_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* GroupBrandingInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string name = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string icon_url = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_icon_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 icon_width = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_icon_width(&has_bits);
                _impl_.icon_width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 icon_height = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _Internal::set_has_icon_height(&has_bits);
                _impl_.icon_height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .affiliation_pb.BrandingInfo.ElideInfo elide_info = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::affiliation_pb::BrandingInfo_ElideInfo_IsValid(val))) {
                    _internal_set_elide_info(static_cast<::affiliation_pb::BrandingInfo_ElideInfo>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional string icon_url_not_hosted_by_google = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
                auto str = _internal_mutable_icon_url_not_hosted_by_google();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* GroupBrandingInfo::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:affiliation_pb.GroupBrandingInfo)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_name(), target);
    }

    // optional string icon_url = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_icon_url(), target);
    }

    // optional int32 icon_width = 3;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_icon_width(), target);
    }

    // optional int32 icon_height = 4;
    if (cached_has_bits & 0x00000010u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_icon_height(), target);
    }

    // optional .affiliation_pb.BrandingInfo.ElideInfo elide_info = 5;
    if (cached_has_bits & 0x00000020u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(5, this->_internal_elide_info(), target);
    }

    // optional string icon_url_not_hosted_by_google = 7;
    if (cached_has_bits & 0x00000004u) {
        target = stream->WriteStringMaybeAliased(7, this->_internal_icon_url_not_hosted_by_google(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:affiliation_pb.GroupBrandingInfo)
    return target;
}

size_t GroupBrandingInfo::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:affiliation_pb.GroupBrandingInfo)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000003fu) {
        // optional string name = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_name());
        }

        // optional string icon_url = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_icon_url());
        }

        // optional string icon_url_not_hosted_by_google = 7;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_icon_url_not_hosted_by_google());
        }

        // optional int32 icon_width = 3;
        if (cached_has_bits & 0x00000008u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_icon_width());
        }

        // optional int32 icon_height = 4;
        if (cached_has_bits & 0x00000010u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_icon_height());
        }

        // optional .affiliation_pb.BrandingInfo.ElideInfo elide_info = 5;
        if (cached_has_bits & 0x00000020u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_elide_info());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void GroupBrandingInfo::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const GroupBrandingInfo*>(&from));
}

void GroupBrandingInfo::MergeFrom(const GroupBrandingInfo& from)
{
    GroupBrandingInfo* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:affiliation_pb.GroupBrandingInfo)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000003fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_name(from._internal_name());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_icon_url(from._internal_icon_url());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_set_icon_url_not_hosted_by_google(from._internal_icon_url_not_hosted_by_google());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.icon_width_ = from._impl_.icon_width_;
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_impl_.icon_height_ = from._impl_.icon_height_;
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_impl_.elide_info_ = from._impl_.elide_info_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GroupBrandingInfo::CopyFrom(const GroupBrandingInfo& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:affiliation_pb.GroupBrandingInfo)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool GroupBrandingInfo::IsInitialized() const
{
    return true;
}

void GroupBrandingInfo::InternalSwap(GroupBrandingInfo* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.name_, lhs_arena, &other->_impl_.name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.icon_url_, lhs_arena, &other->_impl_.icon_url_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
        &_impl_.icon_url_not_hosted_by_google_, lhs_arena, &other->_impl_.icon_url_not_hosted_by_google_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(GroupBrandingInfo, _impl_.elide_info_) + sizeof(GroupBrandingInfo::_impl_.elide_info_)
        - PROTOBUF_FIELD_OFFSET(GroupBrandingInfo, _impl_.icon_width_)>(
        reinterpret_cast<char*>(&_impl_.icon_width_), reinterpret_cast<char*>(&other->_impl_.icon_width_));
}

std::string GroupBrandingInfo::GetTypeName() const
{
    return "affiliation_pb.GroupBrandingInfo";
}

// ===================================================================

class BrandingInfo::_Internal {
public:
    using HasBits = decltype(std::declval<BrandingInfo>()._impl_._has_bits_);
    static void set_has_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_elide_info(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
    static void set_has_icon_url(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_icon_width(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_icon_height(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static void set_has_icon_url_not_hosted_by_google(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
};

BrandingInfo::BrandingInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:affiliation_pb.BrandingInfo)
}
BrandingInfo::BrandingInfo(const BrandingInfo& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    BrandingInfo* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.name_) {},
        decltype(_impl_.icon_url_) {}, decltype(_impl_.icon_url_not_hosted_by_google_) {}, decltype(_impl_.icon_width_) {}, decltype(_impl_.icon_height_) {},
        decltype(_impl_.elide_info_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_name()) {
        _this->_impl_.name_.Set(from._internal_name(), _this->GetArenaForAllocation());
    }
    _impl_.icon_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.icon_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_icon_url()) {
        _this->_impl_.icon_url_.Set(from._internal_icon_url(), _this->GetArenaForAllocation());
    }
    _impl_.icon_url_not_hosted_by_google_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.icon_url_not_hosted_by_google_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_icon_url_not_hosted_by_google()) {
        _this->_impl_.icon_url_not_hosted_by_google_.Set(from._internal_icon_url_not_hosted_by_google(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.icon_width_, &from._impl_.icon_width_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.elide_info_) - reinterpret_cast<char*>(&_impl_.icon_width_)) + sizeof(_impl_.elide_info_));
    // @@protoc_insertion_point(copy_constructor:affiliation_pb.BrandingInfo)
}

inline void BrandingInfo::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.name_) {}, decltype(_impl_.icon_url_) {},
        decltype(_impl_.icon_url_not_hosted_by_google_) {}, decltype(_impl_.icon_width_) { 0 }, decltype(_impl_.icon_height_) { 0 },
        decltype(_impl_.elide_info_) { 0 } };
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.icon_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.icon_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.icon_url_not_hosted_by_google_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.icon_url_not_hosted_by_google_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

BrandingInfo::~BrandingInfo()
{
    // @@protoc_insertion_point(destructor:affiliation_pb.BrandingInfo)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void BrandingInfo::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.name_.Destroy();
    _impl_.icon_url_.Destroy();
    _impl_.icon_url_not_hosted_by_google_.Destroy();
}

void BrandingInfo::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void BrandingInfo::Clear()
{
    // @@protoc_insertion_point(message_clear_start:affiliation_pb.BrandingInfo)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.name_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.icon_url_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            _impl_.icon_url_not_hosted_by_google_.ClearNonDefaultToEmpty();
        }
    }
    if (cached_has_bits & 0x00000038u) {
        ::memset(&_impl_.icon_width_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.elide_info_) - reinterpret_cast<char*>(&_impl_.icon_width_)) + sizeof(_impl_.elide_info_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* BrandingInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string name = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string icon_url = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_icon_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 icon_width = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _Internal::set_has_icon_width(&has_bits);
                _impl_.icon_width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 icon_height = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
                _Internal::set_has_icon_height(&has_bits);
                _impl_.icon_height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .affiliation_pb.BrandingInfo.ElideInfo elide_info = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::affiliation_pb::BrandingInfo_ElideInfo_IsValid(val))) {
                    _internal_set_elide_info(static_cast<::affiliation_pb::BrandingInfo_ElideInfo>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional string icon_url_not_hosted_by_google = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
                auto str = _internal_mutable_icon_url_not_hosted_by_google();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* BrandingInfo::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:affiliation_pb.BrandingInfo)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_name(), target);
    }

    // optional string icon_url = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_icon_url(), target);
    }

    // optional int32 icon_width = 4;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_icon_width(), target);
    }

    // optional int32 icon_height = 5;
    if (cached_has_bits & 0x00000010u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_icon_height(), target);
    }

    // optional .affiliation_pb.BrandingInfo.ElideInfo elide_info = 6;
    if (cached_has_bits & 0x00000020u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(6, this->_internal_elide_info(), target);
    }

    // optional string icon_url_not_hosted_by_google = 8;
    if (cached_has_bits & 0x00000004u) {
        target = stream->WriteStringMaybeAliased(8, this->_internal_icon_url_not_hosted_by_google(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:affiliation_pb.BrandingInfo)
    return target;
}

size_t BrandingInfo::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:affiliation_pb.BrandingInfo)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000003fu) {
        // optional string name = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_name());
        }

        // optional string icon_url = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_icon_url());
        }

        // optional string icon_url_not_hosted_by_google = 8;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_icon_url_not_hosted_by_google());
        }

        // optional int32 icon_width = 4;
        if (cached_has_bits & 0x00000008u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_icon_width());
        }

        // optional int32 icon_height = 5;
        if (cached_has_bits & 0x00000010u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_icon_height());
        }

        // optional .affiliation_pb.BrandingInfo.ElideInfo elide_info = 6;
        if (cached_has_bits & 0x00000020u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_elide_info());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void BrandingInfo::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const BrandingInfo*>(&from));
}

void BrandingInfo::MergeFrom(const BrandingInfo& from)
{
    BrandingInfo* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:affiliation_pb.BrandingInfo)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000003fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_name(from._internal_name());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_icon_url(from._internal_icon_url());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_set_icon_url_not_hosted_by_google(from._internal_icon_url_not_hosted_by_google());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.icon_width_ = from._impl_.icon_width_;
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_impl_.icon_height_ = from._impl_.icon_height_;
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_impl_.elide_info_ = from._impl_.elide_info_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BrandingInfo::CopyFrom(const BrandingInfo& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:affiliation_pb.BrandingInfo)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool BrandingInfo::IsInitialized() const
{
    return true;
}

void BrandingInfo::InternalSwap(BrandingInfo* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.name_, lhs_arena, &other->_impl_.name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.icon_url_, lhs_arena, &other->_impl_.icon_url_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
        &_impl_.icon_url_not_hosted_by_google_, lhs_arena, &other->_impl_.icon_url_not_hosted_by_google_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(BrandingInfo, _impl_.elide_info_) + sizeof(BrandingInfo::_impl_.elide_info_)
        - PROTOBUF_FIELD_OFFSET(BrandingInfo, _impl_.icon_width_)>(
        reinterpret_cast<char*>(&_impl_.icon_width_), reinterpret_cast<char*>(&other->_impl_.icon_width_));
}

std::string BrandingInfo::GetTypeName() const
{
    return "affiliation_pb.BrandingInfo";
}

// ===================================================================

class ChangePasswordInfo::_Internal {
public:
    using HasBits = decltype(std::declval<ChangePasswordInfo>()._impl_._has_bits_);
    static void set_has_change_password_url(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

ChangePasswordInfo::ChangePasswordInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:affiliation_pb.ChangePasswordInfo)
}
ChangePasswordInfo::ChangePasswordInfo(const ChangePasswordInfo& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ChangePasswordInfo* const _this = this;
    (void)_this;
    new (&_impl_)
        Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.change_password_url_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.change_password_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.change_password_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_change_password_url()) {
        _this->_impl_.change_password_url_.Set(from._internal_change_password_url(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:affiliation_pb.ChangePasswordInfo)
}

inline void ChangePasswordInfo::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.change_password_url_) {} };
    _impl_.change_password_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.change_password_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ChangePasswordInfo::~ChangePasswordInfo()
{
    // @@protoc_insertion_point(destructor:affiliation_pb.ChangePasswordInfo)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ChangePasswordInfo::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.change_password_url_.Destroy();
}

void ChangePasswordInfo::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ChangePasswordInfo::Clear()
{
    // @@protoc_insertion_point(message_clear_start:affiliation_pb.ChangePasswordInfo)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.change_password_url_.ClearNonDefaultToEmpty();
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ChangePasswordInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string change_password_url = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_change_password_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ChangePasswordInfo::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:affiliation_pb.ChangePasswordInfo)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string change_password_url = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_change_password_url(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:affiliation_pb.ChangePasswordInfo)
    return target;
}

size_t ChangePasswordInfo::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:affiliation_pb.ChangePasswordInfo)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional string change_password_url = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_change_password_url());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ChangePasswordInfo::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ChangePasswordInfo*>(&from));
}

void ChangePasswordInfo::MergeFrom(const ChangePasswordInfo& from)
{
    ChangePasswordInfo* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:affiliation_pb.ChangePasswordInfo)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_change_password_url()) {
        _this->_internal_set_change_password_url(from._internal_change_password_url());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ChangePasswordInfo::CopyFrom(const ChangePasswordInfo& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:affiliation_pb.ChangePasswordInfo)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ChangePasswordInfo::IsInitialized() const
{
    return true;
}

void ChangePasswordInfo::InternalSwap(ChangePasswordInfo* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.change_password_url_, lhs_arena, &other->_impl_.change_password_url_, rhs_arena);
}

std::string ChangePasswordInfo::GetTypeName() const
{
    return "affiliation_pb.ChangePasswordInfo";
}

// ===================================================================

class LookupAffiliationMask::_Internal {
public:
    using HasBits = decltype(std::declval<LookupAffiliationMask>()._impl_._has_bits_);
    static void set_has_branding_info(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_preferred_icon_size(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_icon_not_hosted_by_google(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_locale(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_grouping_info(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static void set_has_group_branding_info(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
    static void set_has_change_password_info(HasBits* has_bits)
    {
        (*has_bits)[0] |= 64u;
    }
    static void set_has_psl_extension_list(HasBits* has_bits)
    {
        (*has_bits)[0] |= 128u;
    }
    static void set_has_is_on_internal_network(HasBits* has_bits)
    {
        (*has_bits)[0] |= 256u;
    }
    static void set_has_dataset(HasBits* has_bits)
    {
        (*has_bits)[0] |= 512u;
    }
};

LookupAffiliationMask::LookupAffiliationMask(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:affiliation_pb.LookupAffiliationMask)
}
LookupAffiliationMask::LookupAffiliationMask(const LookupAffiliationMask& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    LookupAffiliationMask* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.locale_) {},
        decltype(_impl_.preferred_icon_size_) {}, decltype(_impl_.branding_info_) {}, decltype(_impl_.icon_not_hosted_by_google_) {},
        decltype(_impl_.grouping_info_) {}, decltype(_impl_.group_branding_info_) {}, decltype(_impl_.change_password_info_) {},
        decltype(_impl_.psl_extension_list_) {}, decltype(_impl_.is_on_internal_network_) {}, decltype(_impl_.dataset_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.locale_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.locale_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_locale()) {
        _this->_impl_.locale_.Set(from._internal_locale(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.preferred_icon_size_, &from._impl_.preferred_icon_size_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.dataset_) - reinterpret_cast<char*>(&_impl_.preferred_icon_size_)) + sizeof(_impl_.dataset_));
    // @@protoc_insertion_point(copy_constructor:affiliation_pb.LookupAffiliationMask)
}

inline void LookupAffiliationMask::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.locale_) {},
        decltype(_impl_.preferred_icon_size_) { 0 }, decltype(_impl_.branding_info_) { false }, decltype(_impl_.icon_not_hosted_by_google_) { false },
        decltype(_impl_.grouping_info_) { false }, decltype(_impl_.group_branding_info_) { false }, decltype(_impl_.change_password_info_) { false },
        decltype(_impl_.psl_extension_list_) { false }, decltype(_impl_.is_on_internal_network_) { false }, decltype(_impl_.dataset_) { 0 } };
    _impl_.locale_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.locale_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LookupAffiliationMask::~LookupAffiliationMask()
{
    // @@protoc_insertion_point(destructor:affiliation_pb.LookupAffiliationMask)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void LookupAffiliationMask::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.locale_.Destroy();
}

void LookupAffiliationMask::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void LookupAffiliationMask::Clear()
{
    // @@protoc_insertion_point(message_clear_start:affiliation_pb.LookupAffiliationMask)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.locale_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x000000feu) {
        ::memset(&_impl_.preferred_icon_size_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.psl_extension_list_) - reinterpret_cast<char*>(&_impl_.preferred_icon_size_))
                + sizeof(_impl_.psl_extension_list_));
    }
    if (cached_has_bits & 0x00000300u) {
        ::memset(&_impl_.is_on_internal_network_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.dataset_) - reinterpret_cast<char*>(&_impl_.is_on_internal_network_))
                + sizeof(_impl_.dataset_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* LookupAffiliationMask::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional bool branding_info = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_branding_info(&has_bits);
                _impl_.branding_info_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string locale = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_locale();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 preferred_icon_size = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _Internal::set_has_preferred_icon_size(&has_bits);
                _impl_.preferred_icon_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool group_branding_info = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
                _Internal::set_has_group_branding_info(&has_bits);
                _impl_.group_branding_info_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool grouping_info = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
                _Internal::set_has_grouping_info(&has_bits);
                _impl_.grouping_info_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool change_password_info = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
                _Internal::set_has_change_password_info(&has_bits);
                _impl_.change_password_info_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool psl_extension_list = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
                _Internal::set_has_psl_extension_list(&has_bits);
                _impl_.psl_extension_list_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool is_on_internal_network = 9;
        case 9:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
                _Internal::set_has_is_on_internal_network(&has_bits);
                _impl_.is_on_internal_network_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool icon_not_hosted_by_google = 10;
        case 10:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
                _Internal::set_has_icon_not_hosted_by_google(&has_bits);
                _impl_.icon_not_hosted_by_google_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .affiliation_pb.LookupAffiliationMask.RequestedDataset dataset = 11;
        case 11:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::affiliation_pb::LookupAffiliationMask_RequestedDataset_IsValid(val))) {
                    _internal_set_dataset(static_cast<::affiliation_pb::LookupAffiliationMask_RequestedDataset>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(11, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* LookupAffiliationMask::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:affiliation_pb.LookupAffiliationMask)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional bool branding_info = 1;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_branding_info(), target);
    }

    // optional string locale = 2;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_locale(), target);
    }

    // optional int32 preferred_icon_size = 4;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_preferred_icon_size(), target);
    }

    // optional bool group_branding_info = 5;
    if (cached_has_bits & 0x00000020u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_group_branding_info(), target);
    }

    // optional bool grouping_info = 6;
    if (cached_has_bits & 0x00000010u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_grouping_info(), target);
    }

    // optional bool change_password_info = 7;
    if (cached_has_bits & 0x00000040u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_change_password_info(), target);
    }

    // optional bool psl_extension_list = 8;
    if (cached_has_bits & 0x00000080u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_psl_extension_list(), target);
    }

    // optional bool is_on_internal_network = 9;
    if (cached_has_bits & 0x00000100u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_is_on_internal_network(), target);
    }

    // optional bool icon_not_hosted_by_google = 10;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_icon_not_hosted_by_google(), target);
    }

    // optional .affiliation_pb.LookupAffiliationMask.RequestedDataset dataset = 11;
    if (cached_has_bits & 0x00000200u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(11, this->_internal_dataset(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:affiliation_pb.LookupAffiliationMask)
    return target;
}

size_t LookupAffiliationMask::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:affiliation_pb.LookupAffiliationMask)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        // optional string locale = 2;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_locale());
        }

        // optional int32 preferred_icon_size = 4;
        if (cached_has_bits & 0x00000002u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_preferred_icon_size());
        }

        // optional bool branding_info = 1;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + 1;
        }

        // optional bool icon_not_hosted_by_google = 10;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + 1;
        }

        // optional bool grouping_info = 6;
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + 1;
        }

        // optional bool group_branding_info = 5;
        if (cached_has_bits & 0x00000020u) {
            total_size += 1 + 1;
        }

        // optional bool change_password_info = 7;
        if (cached_has_bits & 0x00000040u) {
            total_size += 1 + 1;
        }

        // optional bool psl_extension_list = 8;
        if (cached_has_bits & 0x00000080u) {
            total_size += 1 + 1;
        }
    }
    if (cached_has_bits & 0x00000300u) {
        // optional bool is_on_internal_network = 9;
        if (cached_has_bits & 0x00000100u) {
            total_size += 1 + 1;
        }

        // optional .affiliation_pb.LookupAffiliationMask.RequestedDataset dataset = 11;
        if (cached_has_bits & 0x00000200u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_dataset());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void LookupAffiliationMask::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const LookupAffiliationMask*>(&from));
}

void LookupAffiliationMask::MergeFrom(const LookupAffiliationMask& from)
{
    LookupAffiliationMask* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:affiliation_pb.LookupAffiliationMask)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_locale(from._internal_locale());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.preferred_icon_size_ = from._impl_.preferred_icon_size_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.branding_info_ = from._impl_.branding_info_;
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.icon_not_hosted_by_google_ = from._impl_.icon_not_hosted_by_google_;
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_impl_.grouping_info_ = from._impl_.grouping_info_;
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_impl_.group_branding_info_ = from._impl_.group_branding_info_;
        }
        if (cached_has_bits & 0x00000040u) {
            _this->_impl_.change_password_info_ = from._impl_.change_password_info_;
        }
        if (cached_has_bits & 0x00000080u) {
            _this->_impl_.psl_extension_list_ = from._impl_.psl_extension_list_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    if (cached_has_bits & 0x00000300u) {
        if (cached_has_bits & 0x00000100u) {
            _this->_impl_.is_on_internal_network_ = from._impl_.is_on_internal_network_;
        }
        if (cached_has_bits & 0x00000200u) {
            _this->_impl_.dataset_ = from._impl_.dataset_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LookupAffiliationMask::CopyFrom(const LookupAffiliationMask& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:affiliation_pb.LookupAffiliationMask)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool LookupAffiliationMask::IsInitialized() const
{
    return true;
}

void LookupAffiliationMask::InternalSwap(LookupAffiliationMask* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.locale_, lhs_arena, &other->_impl_.locale_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(LookupAffiliationMask, _impl_.dataset_) + sizeof(LookupAffiliationMask::_impl_.dataset_)
        - PROTOBUF_FIELD_OFFSET(LookupAffiliationMask, _impl_.preferred_icon_size_)>(
        reinterpret_cast<char*>(&_impl_.preferred_icon_size_), reinterpret_cast<char*>(&other->_impl_.preferred_icon_size_));
}

std::string LookupAffiliationMask::GetTypeName() const
{
    return "affiliation_pb.LookupAffiliationMask";
}

// ===================================================================

class LookupAffiliationRequest::_Internal {
public:
    using HasBits = decltype(std::declval<LookupAffiliationRequest>()._impl_._has_bits_);
    static const ::affiliation_pb::LookupAffiliationMask& mask(const LookupAffiliationRequest* msg);
    static void set_has_mask(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

const ::affiliation_pb::LookupAffiliationMask& LookupAffiliationRequest::_Internal::mask(const LookupAffiliationRequest* msg)
{
    return *msg->_impl_.mask_;
}
LookupAffiliationRequest::LookupAffiliationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:affiliation_pb.LookupAffiliationRequest)
}
LookupAffiliationRequest::LookupAffiliationRequest(const LookupAffiliationRequest& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    LookupAffiliationRequest* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.facet_) { from._impl_.facet_ }, decltype(_impl_.mask_) { nullptr } };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_mask()) {
        _this->_impl_.mask_ = new ::affiliation_pb::LookupAffiliationMask(*from._impl_.mask_);
    }
    // @@protoc_insertion_point(copy_constructor:affiliation_pb.LookupAffiliationRequest)
}

inline void LookupAffiliationRequest::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_)
        Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.facet_) { arena }, decltype(_impl_.mask_) { nullptr } };
}

LookupAffiliationRequest::~LookupAffiliationRequest()
{
    // @@protoc_insertion_point(destructor:affiliation_pb.LookupAffiliationRequest)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void LookupAffiliationRequest::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.facet_.~RepeatedPtrField();
    if (this != internal_default_instance())
        delete _impl_.mask_;
}

void LookupAffiliationRequest::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void LookupAffiliationRequest::Clear()
{
    // @@protoc_insertion_point(message_clear_start:affiliation_pb.LookupAffiliationRequest)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.facet_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        GOOGLE_DCHECK(_impl_.mask_ != nullptr);
        _impl_.mask_->Clear();
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* LookupAffiliationRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated string facet = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    auto str = _internal_add_facet();
                    ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional .affiliation_pb.LookupAffiliationMask mask = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_mask(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* LookupAffiliationRequest::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:affiliation_pb.LookupAffiliationRequest)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated string facet = 1;
    for (int i = 0, n = this->_internal_facet_size(); i < n; i++) {
        const auto& s = this->_internal_facet(i);
        target = stream->WriteString(1, s, target);
    }

    cached_has_bits = _impl_._has_bits_[0];
    // optional .affiliation_pb.LookupAffiliationMask mask = 2;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::mask(this), _Internal::mask(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:affiliation_pb.LookupAffiliationRequest)
    return target;
}

size_t LookupAffiliationRequest::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:affiliation_pb.LookupAffiliationRequest)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated string facet = 1;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.facet_.size());
    for (int i = 0, n = _impl_.facet_.size(); i < n; i++) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(_impl_.facet_.Get(i));
    }

    // optional .affiliation_pb.LookupAffiliationMask mask = 2;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.mask_);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void LookupAffiliationRequest::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const LookupAffiliationRequest*>(&from));
}

void LookupAffiliationRequest::MergeFrom(const LookupAffiliationRequest& from)
{
    LookupAffiliationRequest* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:affiliation_pb.LookupAffiliationRequest)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.facet_.MergeFrom(from._impl_.facet_);
    if (from._internal_has_mask()) {
        _this->_internal_mutable_mask()->::affiliation_pb::LookupAffiliationMask::MergeFrom(from._internal_mask());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LookupAffiliationRequest::CopyFrom(const LookupAffiliationRequest& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:affiliation_pb.LookupAffiliationRequest)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool LookupAffiliationRequest::IsInitialized() const
{
    return true;
}

void LookupAffiliationRequest::InternalSwap(LookupAffiliationRequest* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.facet_.InternalSwap(&other->_impl_.facet_);
    swap(_impl_.mask_, other->_impl_.mask_);
}

std::string LookupAffiliationRequest::GetTypeName() const
{
    return "affiliation_pb.LookupAffiliationRequest";
}

// ===================================================================

class LookupAffiliationResponse::_Internal {
public:
};

LookupAffiliationResponse::LookupAffiliationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:affiliation_pb.LookupAffiliationResponse)
}
LookupAffiliationResponse::LookupAffiliationResponse(const LookupAffiliationResponse& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    LookupAffiliationResponse* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.affiliation_) { from._impl_.affiliation_ }, decltype(_impl_.group_) { from._impl_.group_ },
        decltype(_impl_.psl_extensions_) { from._impl_.psl_extensions_ }, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:affiliation_pb.LookupAffiliationResponse)
}

inline void LookupAffiliationResponse::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.affiliation_) { arena }, decltype(_impl_.group_) { arena }, decltype(_impl_.psl_extensions_) { arena },
        /*decltype(_impl_._cached_size_)*/ {} };
}

LookupAffiliationResponse::~LookupAffiliationResponse()
{
    // @@protoc_insertion_point(destructor:affiliation_pb.LookupAffiliationResponse)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void LookupAffiliationResponse::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.affiliation_.~RepeatedPtrField();
    _impl_.group_.~RepeatedPtrField();
    _impl_.psl_extensions_.~RepeatedPtrField();
}

void LookupAffiliationResponse::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void LookupAffiliationResponse::Clear()
{
    // @@protoc_insertion_point(message_clear_start:affiliation_pb.LookupAffiliationResponse)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.affiliation_.Clear();
    _impl_.group_.Clear();
    _impl_.psl_extensions_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* LookupAffiliationResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .affiliation_pb.Affiliation affiliation = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_affiliation(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        // repeated .affiliation_pb.FacetGroup group = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_group(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
            } else
                goto handle_unusual;
            continue;
        // repeated string psl_extensions = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    auto str = _internal_add_psl_extensions();
                    ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* LookupAffiliationResponse::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:affiliation_pb.LookupAffiliationResponse)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .affiliation_pb.Affiliation affiliation = 1;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_affiliation_size()); i < n; i++) {
        const auto& repfield = this->_internal_affiliation(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
    }

    // repeated .affiliation_pb.FacetGroup group = 2;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_group_size()); i < n; i++) {
        const auto& repfield = this->_internal_group(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
    }

    // repeated string psl_extensions = 3;
    for (int i = 0, n = this->_internal_psl_extensions_size(); i < n; i++) {
        const auto& s = this->_internal_psl_extensions(i);
        target = stream->WriteString(3, s, target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:affiliation_pb.LookupAffiliationResponse)
    return target;
}

size_t LookupAffiliationResponse::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:affiliation_pb.LookupAffiliationResponse)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .affiliation_pb.Affiliation affiliation = 1;
    total_size += 1UL * this->_internal_affiliation_size();
    for (const auto& msg : this->_impl_.affiliation_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // repeated .affiliation_pb.FacetGroup group = 2;
    total_size += 1UL * this->_internal_group_size();
    for (const auto& msg : this->_impl_.group_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // repeated string psl_extensions = 3;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.psl_extensions_.size());
    for (int i = 0, n = _impl_.psl_extensions_.size(); i < n; i++) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(_impl_.psl_extensions_.Get(i));
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void LookupAffiliationResponse::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const LookupAffiliationResponse*>(&from));
}

void LookupAffiliationResponse::MergeFrom(const LookupAffiliationResponse& from)
{
    LookupAffiliationResponse* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:affiliation_pb.LookupAffiliationResponse)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.affiliation_.MergeFrom(from._impl_.affiliation_);
    _this->_impl_.group_.MergeFrom(from._impl_.group_);
    _this->_impl_.psl_extensions_.MergeFrom(from._impl_.psl_extensions_);
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LookupAffiliationResponse::CopyFrom(const LookupAffiliationResponse& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:affiliation_pb.LookupAffiliationResponse)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool LookupAffiliationResponse::IsInitialized() const
{
    return true;
}

void LookupAffiliationResponse::InternalSwap(LookupAffiliationResponse* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.affiliation_.InternalSwap(&other->_impl_.affiliation_);
    _impl_.group_.InternalSwap(&other->_impl_.group_);
    _impl_.psl_extensions_.InternalSwap(&other->_impl_.psl_extensions_);
}

std::string LookupAffiliationResponse::GetTypeName() const
{
    return "affiliation_pb.LookupAffiliationResponse";
}

// ===================================================================

class LookupAffiliationByHashPrefixRequest::_Internal {
public:
    using HasBits = decltype(std::declval<LookupAffiliationByHashPrefixRequest>()._impl_._has_bits_);
    static const ::affiliation_pb::LookupAffiliationMask& mask(const LookupAffiliationByHashPrefixRequest* msg);
    static void set_has_mask(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_hash_prefix_length(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

const ::affiliation_pb::LookupAffiliationMask& LookupAffiliationByHashPrefixRequest::_Internal::mask(const LookupAffiliationByHashPrefixRequest* msg)
{
    return *msg->_impl_.mask_;
}
LookupAffiliationByHashPrefixRequest::LookupAffiliationByHashPrefixRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:affiliation_pb.LookupAffiliationByHashPrefixRequest)
}
LookupAffiliationByHashPrefixRequest::LookupAffiliationByHashPrefixRequest(const LookupAffiliationByHashPrefixRequest& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    LookupAffiliationByHashPrefixRequest* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.hash_prefixes_) { from._impl_.hash_prefixes_ }, decltype(_impl_.mask_) { nullptr }, decltype(_impl_.hash_prefix_length_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_mask()) {
        _this->_impl_.mask_ = new ::affiliation_pb::LookupAffiliationMask(*from._impl_.mask_);
    }
    _this->_impl_.hash_prefix_length_ = from._impl_.hash_prefix_length_;
    // @@protoc_insertion_point(copy_constructor:affiliation_pb.LookupAffiliationByHashPrefixRequest)
}

inline void LookupAffiliationByHashPrefixRequest::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.hash_prefixes_) { arena },
        decltype(_impl_.mask_) { nullptr }, decltype(_impl_.hash_prefix_length_) { 0u } };
}

LookupAffiliationByHashPrefixRequest::~LookupAffiliationByHashPrefixRequest()
{
    // @@protoc_insertion_point(destructor:affiliation_pb.LookupAffiliationByHashPrefixRequest)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void LookupAffiliationByHashPrefixRequest::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.hash_prefixes_.~RepeatedField();
    if (this != internal_default_instance())
        delete _impl_.mask_;
}

void LookupAffiliationByHashPrefixRequest::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void LookupAffiliationByHashPrefixRequest::Clear()
{
    // @@protoc_insertion_point(message_clear_start:affiliation_pb.LookupAffiliationByHashPrefixRequest)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.hash_prefixes_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        GOOGLE_DCHECK(_impl_.mask_ != nullptr);
        _impl_.mask_->Clear();
    }
    _impl_.hash_prefix_length_ = 0u;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* LookupAffiliationByHashPrefixRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .affiliation_pb.LookupAffiliationMask mask = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_mask(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional uint32 hash_prefix_length = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_hash_prefix_length(&has_bits);
                _impl_.hash_prefix_length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated uint64 hash_prefixes = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    _internal_add_hash_prefixes(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
            } else if (static_cast<uint8_t>(tag) == 26) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_hash_prefixes(), ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* LookupAffiliationByHashPrefixRequest::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:affiliation_pb.LookupAffiliationByHashPrefixRequest)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .affiliation_pb.LookupAffiliationMask mask = 1;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::mask(this), _Internal::mask(this).GetCachedSize(), target, stream);
    }

    // optional uint32 hash_prefix_length = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_hash_prefix_length(), target);
    }

    // repeated uint64 hash_prefixes = 3;
    for (int i = 0, n = this->_internal_hash_prefixes_size(); i < n; i++) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_hash_prefixes(i), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:affiliation_pb.LookupAffiliationByHashPrefixRequest)
    return target;
}

size_t LookupAffiliationByHashPrefixRequest::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:affiliation_pb.LookupAffiliationByHashPrefixRequest)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated uint64 hash_prefixes = 3;
    {
        size_t data_size = ::_pbi::WireFormatLite::UInt64Size(this->_impl_.hash_prefixes_);
        total_size += 1 * ::_pbi::FromIntSize(this->_internal_hash_prefixes_size());
        total_size += data_size;
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional .affiliation_pb.LookupAffiliationMask mask = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.mask_);
        }

        // optional uint32 hash_prefix_length = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_hash_prefix_length());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void LookupAffiliationByHashPrefixRequest::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const LookupAffiliationByHashPrefixRequest*>(&from));
}

void LookupAffiliationByHashPrefixRequest::MergeFrom(const LookupAffiliationByHashPrefixRequest& from)
{
    LookupAffiliationByHashPrefixRequest* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:affiliation_pb.LookupAffiliationByHashPrefixRequest)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.hash_prefixes_.MergeFrom(from._impl_.hash_prefixes_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_mutable_mask()->::affiliation_pb::LookupAffiliationMask::MergeFrom(from._internal_mask());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.hash_prefix_length_ = from._impl_.hash_prefix_length_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LookupAffiliationByHashPrefixRequest::CopyFrom(const LookupAffiliationByHashPrefixRequest& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:affiliation_pb.LookupAffiliationByHashPrefixRequest)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool LookupAffiliationByHashPrefixRequest::IsInitialized() const
{
    return true;
}

void LookupAffiliationByHashPrefixRequest::InternalSwap(LookupAffiliationByHashPrefixRequest* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.hash_prefixes_.InternalSwap(&other->_impl_.hash_prefixes_);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(LookupAffiliationByHashPrefixRequest, _impl_.hash_prefix_length_)
        + sizeof(LookupAffiliationByHashPrefixRequest::_impl_.hash_prefix_length_) - PROTOBUF_FIELD_OFFSET(LookupAffiliationByHashPrefixRequest, _impl_.mask_)>(
        reinterpret_cast<char*>(&_impl_.mask_), reinterpret_cast<char*>(&other->_impl_.mask_));
}

std::string LookupAffiliationByHashPrefixRequest::GetTypeName() const
{
    return "affiliation_pb.LookupAffiliationByHashPrefixRequest";
}

// ===================================================================

class LookupAffiliationByHashPrefixResponse::_Internal {
public:
};

LookupAffiliationByHashPrefixResponse::LookupAffiliationByHashPrefixResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:affiliation_pb.LookupAffiliationByHashPrefixResponse)
}
LookupAffiliationByHashPrefixResponse::LookupAffiliationByHashPrefixResponse(const LookupAffiliationByHashPrefixResponse& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    LookupAffiliationByHashPrefixResponse* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.affiliations_) { from._impl_.affiliations_ }, decltype(_impl_.groups_) { from._impl_.groups_ },
        decltype(_impl_.psl_extensions_) { from._impl_.psl_extensions_ }, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:affiliation_pb.LookupAffiliationByHashPrefixResponse)
}

inline void LookupAffiliationByHashPrefixResponse::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.affiliations_) { arena }, decltype(_impl_.groups_) { arena }, decltype(_impl_.psl_extensions_) { arena },
        /*decltype(_impl_._cached_size_)*/ {} };
}

LookupAffiliationByHashPrefixResponse::~LookupAffiliationByHashPrefixResponse()
{
    // @@protoc_insertion_point(destructor:affiliation_pb.LookupAffiliationByHashPrefixResponse)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void LookupAffiliationByHashPrefixResponse::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.affiliations_.~RepeatedPtrField();
    _impl_.groups_.~RepeatedPtrField();
    _impl_.psl_extensions_.~RepeatedPtrField();
}

void LookupAffiliationByHashPrefixResponse::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void LookupAffiliationByHashPrefixResponse::Clear()
{
    // @@protoc_insertion_point(message_clear_start:affiliation_pb.LookupAffiliationByHashPrefixResponse)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.affiliations_.Clear();
    _impl_.groups_.Clear();
    _impl_.psl_extensions_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* LookupAffiliationByHashPrefixResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .affiliation_pb.Affiliation affiliations = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_affiliations(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        // repeated .affiliation_pb.FacetGroup groups = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_groups(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
            } else
                goto handle_unusual;
            continue;
        // repeated string psl_extensions = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    auto str = _internal_add_psl_extensions();
                    ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* LookupAffiliationByHashPrefixResponse::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:affiliation_pb.LookupAffiliationByHashPrefixResponse)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .affiliation_pb.Affiliation affiliations = 1;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_affiliations_size()); i < n; i++) {
        const auto& repfield = this->_internal_affiliations(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
    }

    // repeated .affiliation_pb.FacetGroup groups = 2;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_groups_size()); i < n; i++) {
        const auto& repfield = this->_internal_groups(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
    }

    // repeated string psl_extensions = 3;
    for (int i = 0, n = this->_internal_psl_extensions_size(); i < n; i++) {
        const auto& s = this->_internal_psl_extensions(i);
        target = stream->WriteString(3, s, target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:affiliation_pb.LookupAffiliationByHashPrefixResponse)
    return target;
}

size_t LookupAffiliationByHashPrefixResponse::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:affiliation_pb.LookupAffiliationByHashPrefixResponse)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .affiliation_pb.Affiliation affiliations = 1;
    total_size += 1UL * this->_internal_affiliations_size();
    for (const auto& msg : this->_impl_.affiliations_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // repeated .affiliation_pb.FacetGroup groups = 2;
    total_size += 1UL * this->_internal_groups_size();
    for (const auto& msg : this->_impl_.groups_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // repeated string psl_extensions = 3;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.psl_extensions_.size());
    for (int i = 0, n = _impl_.psl_extensions_.size(); i < n; i++) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(_impl_.psl_extensions_.Get(i));
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void LookupAffiliationByHashPrefixResponse::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const LookupAffiliationByHashPrefixResponse*>(&from));
}

void LookupAffiliationByHashPrefixResponse::MergeFrom(const LookupAffiliationByHashPrefixResponse& from)
{
    LookupAffiliationByHashPrefixResponse* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:affiliation_pb.LookupAffiliationByHashPrefixResponse)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.affiliations_.MergeFrom(from._impl_.affiliations_);
    _this->_impl_.groups_.MergeFrom(from._impl_.groups_);
    _this->_impl_.psl_extensions_.MergeFrom(from._impl_.psl_extensions_);
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LookupAffiliationByHashPrefixResponse::CopyFrom(const LookupAffiliationByHashPrefixResponse& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:affiliation_pb.LookupAffiliationByHashPrefixResponse)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool LookupAffiliationByHashPrefixResponse::IsInitialized() const
{
    return true;
}

void LookupAffiliationByHashPrefixResponse::InternalSwap(LookupAffiliationByHashPrefixResponse* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.affiliations_.InternalSwap(&other->_impl_.affiliations_);
    _impl_.groups_.InternalSwap(&other->_impl_.groups_);
    _impl_.psl_extensions_.InternalSwap(&other->_impl_.psl_extensions_);
}

std::string LookupAffiliationByHashPrefixResponse::GetTypeName() const
{
    return "affiliation_pb.LookupAffiliationByHashPrefixResponse";
}

// @@protoc_insertion_point(namespace_scope)
} // namespace affiliation_pb
PROTOBUF_NAMESPACE_OPEN
template <> PROTOBUF_NOINLINE ::affiliation_pb::Affiliation* Arena::CreateMaybeMessage<::affiliation_pb::Affiliation>(Arena* arena)
{
    return Arena::CreateMessageInternal<::affiliation_pb::Affiliation>(arena);
}
template <> PROTOBUF_NOINLINE ::affiliation_pb::Facet* Arena::CreateMaybeMessage<::affiliation_pb::Facet>(Arena* arena)
{
    return Arena::CreateMessageInternal<::affiliation_pb::Facet>(arena);
}
template <> PROTOBUF_NOINLINE ::affiliation_pb::FacetGroup* Arena::CreateMaybeMessage<::affiliation_pb::FacetGroup>(Arena* arena)
{
    return Arena::CreateMessageInternal<::affiliation_pb::FacetGroup>(arena);
}
template <> PROTOBUF_NOINLINE ::affiliation_pb::GroupBrandingInfo* Arena::CreateMaybeMessage<::affiliation_pb::GroupBrandingInfo>(Arena* arena)
{
    return Arena::CreateMessageInternal<::affiliation_pb::GroupBrandingInfo>(arena);
}
template <> PROTOBUF_NOINLINE ::affiliation_pb::BrandingInfo* Arena::CreateMaybeMessage<::affiliation_pb::BrandingInfo>(Arena* arena)
{
    return Arena::CreateMessageInternal<::affiliation_pb::BrandingInfo>(arena);
}
template <> PROTOBUF_NOINLINE ::affiliation_pb::ChangePasswordInfo* Arena::CreateMaybeMessage<::affiliation_pb::ChangePasswordInfo>(Arena* arena)
{
    return Arena::CreateMessageInternal<::affiliation_pb::ChangePasswordInfo>(arena);
}
template <> PROTOBUF_NOINLINE ::affiliation_pb::LookupAffiliationMask* Arena::CreateMaybeMessage<::affiliation_pb::LookupAffiliationMask>(Arena* arena)
{
    return Arena::CreateMessageInternal<::affiliation_pb::LookupAffiliationMask>(arena);
}
template <> PROTOBUF_NOINLINE ::affiliation_pb::LookupAffiliationRequest* Arena::CreateMaybeMessage<::affiliation_pb::LookupAffiliationRequest>(Arena* arena)
{
    return Arena::CreateMessageInternal<::affiliation_pb::LookupAffiliationRequest>(arena);
}
template <> PROTOBUF_NOINLINE ::affiliation_pb::LookupAffiliationResponse* Arena::CreateMaybeMessage<::affiliation_pb::LookupAffiliationResponse>(Arena* arena)
{
    return Arena::CreateMessageInternal<::affiliation_pb::LookupAffiliationResponse>(arena);
}
template <>
PROTOBUF_NOINLINE ::affiliation_pb::LookupAffiliationByHashPrefixRequest* Arena::CreateMaybeMessage<::affiliation_pb::LookupAffiliationByHashPrefixRequest>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<::affiliation_pb::LookupAffiliationByHashPrefixRequest>(arena);
}
template <>
PROTOBUF_NOINLINE ::affiliation_pb::LookupAffiliationByHashPrefixResponse* Arena::CreateMaybeMessage<::affiliation_pb::LookupAffiliationByHashPrefixResponse>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<::affiliation_pb::LookupAffiliationByHashPrefixResponse>(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
