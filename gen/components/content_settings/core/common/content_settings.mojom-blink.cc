// components/content_settings/core/common/content_settings.mojom-blink.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif

#include "components/content_settings/core/common/content_settings.mojom-blink.h"

#include <math.h>
#include <stdint.h>
#include <utility>

#include "base/debug/alias.h"
#include "base/hash/md5_constexpr.h"
#include "base/run_loop.h"
#include "base/strings/string_number_conversions.h"
#include "base/task/thread_pool/thread_pool_instance.h"
#include "base/trace_event/trace_event.h"
#include "base/trace_event/typed_macros.h"
#include "mojo/public/cpp/bindings/features.h"
#include "mojo/public/cpp/bindings/lib/default_construct_tag_internal.h"
#include "mojo/public/cpp/bindings/lib/generated_code_util.h"
#include "mojo/public/cpp/bindings/lib/message_internal.h"
#include "mojo/public/cpp/bindings/lib/proxy_to_responder.h"
#include "mojo/public/cpp/bindings/lib/send_message_helper.h"
#include "mojo/public/cpp/bindings/lib/serialization_util.h"
#include "mojo/public/cpp/bindings/lib/unserialized_message_context.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/mojo_buildflags.h"
#include "mojo/public/cpp/bindings/urgent_message_scope.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"
#include "third_party/perfetto/include/perfetto/tracing/traced_value.h"

#include "components/content_settings/core/common/content_settings.mojom-params-data.h"
#include "components/content_settings/core/common/content_settings.mojom-shared-message-ids.h"

#include "components/content_settings/core/common/content_settings.mojom-blink-import-headers.h"
#include "components/content_settings/core/common/content_settings.mojom-blink-test-utils.h"
#include "mojo/public/cpp/bindings/lib/wtf_serialization.h"

namespace content_settings::mojom::blink {
PatternParts::PatternParts()
    : scheme()
    , is_scheme_wildcard()
    , host()
    , has_domain_wildcard()
    , port()
    , is_port_wildcard()
    , path()
    , is_path_wildcard()
{
}

PatternParts::PatternParts(const WTF::String& scheme_in, bool is_scheme_wildcard_in, const WTF::String& host_in, bool has_domain_wildcard_in,
    const WTF::String& port_in, bool is_port_wildcard_in, const WTF::String& path_in, bool is_path_wildcard_in)
    : scheme(std::move(scheme_in))
    , is_scheme_wildcard(std::move(is_scheme_wildcard_in))
    , host(std::move(host_in))
    , has_domain_wildcard(std::move(has_domain_wildcard_in))
    , port(std::move(port_in))
    , is_port_wildcard(std::move(is_port_wildcard_in))
    , path(std::move(path_in))
    , is_path_wildcard(std::move(is_path_wildcard_in))
{
}

PatternParts::~PatternParts() = default;
size_t PatternParts::Hash(size_t seed) const
{
    seed = mojo::internal::WTFHash(seed, this->scheme);
    seed = mojo::internal::WTFHash(seed, this->is_scheme_wildcard);
    seed = mojo::internal::WTFHash(seed, this->host);
    seed = mojo::internal::WTFHash(seed, this->has_domain_wildcard);
    seed = mojo::internal::WTFHash(seed, this->port);
    seed = mojo::internal::WTFHash(seed, this->is_port_wildcard);
    seed = mojo::internal::WTFHash(seed, this->path);
    seed = mojo::internal::WTFHash(seed, this->is_path_wildcard);
    return seed;
}

void PatternParts::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("scheme"), this->scheme,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const WTF::String&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("is_scheme_wildcard"), this->is_scheme_wildcard,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type bool>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("host"), this->host,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const WTF::String&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("has_domain_wildcard"), this->has_domain_wildcard,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type bool>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("port"), this->port,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const WTF::String&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("is_port_wildcard"), this->is_port_wildcard,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type bool>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("path"), this->path,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const WTF::String&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("is_path_wildcard"), this->is_path_wildcard,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type bool>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool PatternParts::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
ContentSettingsPattern::ContentSettingsPattern()
    : parts()
    , is_valid()
{
}

ContentSettingsPattern::ContentSettingsPattern(PatternPartsPtr parts_in, bool is_valid_in)
    : parts(std::move(parts_in))
    , is_valid(std::move(is_valid_in))
{
}

ContentSettingsPattern::~ContentSettingsPattern() = default;
size_t ContentSettingsPattern::Hash(size_t seed) const
{
    seed = mojo::internal::WTFHash(seed, this->parts);
    seed = mojo::internal::WTFHash(seed, this->is_valid);
    return seed;
}

void ContentSettingsPattern::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("parts"), this->parts,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type PatternPartsPtr>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("is_valid"), this->is_valid,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type bool>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool ContentSettingsPattern::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
RuleMetaData::RuleMetaData()
    : last_modified()
    , last_used()
    , last_visited()
    , expiration()
    , session_model()
    , lifetime()
    , tpcd_metadata_rule_source()
    , tpcd_metadata_cohort()
    , decided_by_related_website_sets()
{
}

RuleMetaData::RuleMetaData(::base::Time last_modified_in, ::base::Time last_used_in, ::base::Time last_visited_in, ::base::Time expiration_in,
    ::content_settings::mojom::blink::SessionModel session_model_in, ::base::TimeDelta lifetime_in,
    ::content_settings::mojom::blink::TpcdMetadataRuleSource tpcd_metadata_rule_source_in,
    ::content_settings::mojom::blink::TpcdMetadataCohort tpcd_metadata_cohort_in, bool decided_by_related_website_sets_in)
    : last_modified(std::move(last_modified_in))
    , last_used(std::move(last_used_in))
    , last_visited(std::move(last_visited_in))
    , expiration(std::move(expiration_in))
    , session_model(std::move(session_model_in))
    , lifetime(std::move(lifetime_in))
    , tpcd_metadata_rule_source(std::move(tpcd_metadata_rule_source_in))
    , tpcd_metadata_cohort(std::move(tpcd_metadata_cohort_in))
    , decided_by_related_website_sets(std::move(decided_by_related_website_sets_in))
{
}

RuleMetaData::~RuleMetaData() = default;

void RuleMetaData::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("last_modified"), this->last_modified,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type ::base::Time>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("last_used"), this->last_used,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type ::base::Time>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("last_visited"), this->last_visited,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type ::base::Time>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("expiration"), this->expiration,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type ::base::Time>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("session_model"), this->session_model,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type ::content_settings::mojom::blink::SessionModel>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("lifetime"), this->lifetime,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type ::base::TimeDelta>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("tpcd_metadata_rule_source"), this->tpcd_metadata_rule_source,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type ::content_settings::mojom::blink::TpcdMetadataRuleSource>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("tpcd_metadata_cohort"), this->tpcd_metadata_cohort,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type ::content_settings::mojom::blink::TpcdMetadataCohort>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("decided_by_related_website_sets"), this->decided_by_related_website_sets,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type bool>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool RuleMetaData::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
ContentSettingPatternSource::ContentSettingPatternSource()
    : primary_pattern()
    , secondary_pattern()
    , setting_value()
    , metadata()
    , source()
    , incognito()
{
}

ContentSettingPatternSource::ContentSettingPatternSource(ContentSettingsPatternPtr primary_pattern_in, ContentSettingsPatternPtr secondary_pattern_in,
    ::base::Value setting_value_in, RuleMetaDataPtr metadata_in, ::content_settings::mojom::blink::ProviderType source_in, bool incognito_in)
    : primary_pattern(std::move(primary_pattern_in))
    , secondary_pattern(std::move(secondary_pattern_in))
    , setting_value(std::move(setting_value_in))
    , metadata(std::move(metadata_in))
    , source(std::move(source_in))
    , incognito(std::move(incognito_in))
{
}

ContentSettingPatternSource::~ContentSettingPatternSource() = default;

void ContentSettingPatternSource::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("primary_pattern"), this->primary_pattern,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type ContentSettingsPatternPtr>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("secondary_pattern"), this->secondary_pattern,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type ContentSettingsPatternPtr>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("setting_value"), this->setting_value,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type ::base::Value>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("metadata"), this->metadata,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type RuleMetaDataPtr>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("source"), this->source,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type ::content_settings::mojom::blink::ProviderType>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("incognito"), this->incognito,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type bool>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool ContentSettingPatternSource::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
RendererContentSettingRules::RendererContentSettingRules()
    : mixed_content_rules()
{
}

RendererContentSettingRules::RendererContentSettingRules(WTF::Vector<ContentSettingPatternSourcePtr> mixed_content_rules_in)
    : mixed_content_rules(std::move(mixed_content_rules_in))
{
}

RendererContentSettingRules::~RendererContentSettingRules() = default;

void RendererContentSettingRules::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("mixed_content_rules"), this->mixed_content_rules,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type WTF::Vector<ContentSettingPatternSourcePtr>>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool RendererContentSettingRules::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}

} // content_settings::mojom::blink

namespace mojo {

// static
bool StructTraits<::content_settings::mojom::blink::PatternParts::DataView, ::content_settings::mojom::blink::PatternPartsPtr>::Read(
    ::content_settings::mojom::blink::PatternParts::DataView input, ::content_settings::mojom::blink::PatternPartsPtr* output)
{
    bool success = true;
    ::content_settings::mojom::blink::PatternPartsPtr result(::content_settings::mojom::blink::PatternParts::New());

    if (success && !input.ReadScheme(&result->scheme))
        success = false;
    if (success)
        result->is_scheme_wildcard = input.is_scheme_wildcard();
    if (success && !input.ReadHost(&result->host))
        success = false;
    if (success)
        result->has_domain_wildcard = input.has_domain_wildcard();
    if (success && !input.ReadPort(&result->port))
        success = false;
    if (success)
        result->is_port_wildcard = input.is_port_wildcard();
    if (success && !input.ReadPath(&result->path))
        success = false;
    if (success)
        result->is_path_wildcard = input.is_path_wildcard();
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::content_settings::mojom::blink::ContentSettingsPattern::DataView, ::content_settings::mojom::blink::ContentSettingsPatternPtr>::Read(
    ::content_settings::mojom::blink::ContentSettingsPattern::DataView input, ::content_settings::mojom::blink::ContentSettingsPatternPtr* output)
{
    bool success = true;
    ::content_settings::mojom::blink::ContentSettingsPatternPtr result(::content_settings::mojom::blink::ContentSettingsPattern::New());

    if (success && !input.ReadParts(&result->parts))
        success = false;
    if (success)
        result->is_valid = input.is_valid();
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::content_settings::mojom::blink::RuleMetaData::DataView, ::content_settings::mojom::blink::RuleMetaDataPtr>::Read(
    ::content_settings::mojom::blink::RuleMetaData::DataView input, ::content_settings::mojom::blink::RuleMetaDataPtr* output)
{
    bool success = true;
    ::content_settings::mojom::blink::RuleMetaDataPtr result(::content_settings::mojom::blink::RuleMetaData::New());

    if (success && !input.ReadLastModified(&result->last_modified))
        success = false;
    if (success && !input.ReadLastUsed(&result->last_used))
        success = false;
    if (success && !input.ReadLastVisited(&result->last_visited))
        success = false;
    if (success && !input.ReadExpiration(&result->expiration))
        success = false;
    if (success && !input.ReadSessionModel(&result->session_model))
        success = false;
    if (success && !input.ReadLifetime(&result->lifetime))
        success = false;
    if (success && !input.ReadTpcdMetadataRuleSource(&result->tpcd_metadata_rule_source))
        success = false;
    if (success && !input.ReadTpcdMetadataCohort(&result->tpcd_metadata_cohort))
        success = false;
    if (success)
        result->decided_by_related_website_sets = input.decided_by_related_website_sets();
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::content_settings::mojom::blink::ContentSettingPatternSource::DataView,
    ::content_settings::mojom::blink::ContentSettingPatternSourcePtr>::Read(::content_settings::mojom::blink::ContentSettingPatternSource::DataView input,
    ::content_settings::mojom::blink::ContentSettingPatternSourcePtr* output)
{
    bool success = true;
    ::content_settings::mojom::blink::ContentSettingPatternSourcePtr result(::content_settings::mojom::blink::ContentSettingPatternSource::New());

    if (success && !input.ReadPrimaryPattern(&result->primary_pattern))
        success = false;
    if (success && !input.ReadSecondaryPattern(&result->secondary_pattern))
        success = false;
    if (success && !input.ReadSettingValue(&result->setting_value))
        success = false;
    if (success && !input.ReadMetadata(&result->metadata))
        success = false;
    if (success && !input.ReadSource(&result->source))
        success = false;
    if (success)
        result->incognito = input.incognito();
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::content_settings::mojom::blink::RendererContentSettingRules::DataView,
    ::content_settings::mojom::blink::RendererContentSettingRulesPtr>::Read(::content_settings::mojom::blink::RendererContentSettingRules::DataView input,
    ::content_settings::mojom::blink::RendererContentSettingRulesPtr* output)
{
    bool success = true;
    ::content_settings::mojom::blink::RendererContentSettingRulesPtr result(::content_settings::mojom::blink::RendererContentSettingRules::New());

    if (success && !input.ReadMixedContentRules(&result->mixed_content_rules))
        success = false;
    *output = std::move(result);
    return success;
}

} // namespace mojo

// Symbols declared in the -test-utils.h header are defined here instead of a
// separate .cc file to save compile time.

namespace content_settings::mojom::blink {

} // content_settings::mojom::blink

#if defined(__clang__)
#pragma clang diagnostic pop
#endif