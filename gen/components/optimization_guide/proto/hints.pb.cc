// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/optimization_guide/proto/hints.proto

#include "components/optimization_guide/proto/hints.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace optimization_guide {
namespace proto {
PROTOBUF_CONSTEXPR MatchedHintInfo::MatchedHintInfo(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.key_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.version_)*/ int64_t { 0 },
        /*decltype(_impl_.key_representation_)*/ 0 }
{
}
struct MatchedHintInfoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR MatchedHintInfoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~MatchedHintInfoDefaultTypeInternal()
    {
    }
    union {
        MatchedHintInfo _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MatchedHintInfoDefaultTypeInternal _MatchedHintInfo_default_instance_;
PROTOBUF_CONSTEXPR HostInfo::HostInfo(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.host_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.matched_hint_)*/ nullptr }
{
}
struct HostInfoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR HostInfoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~HostInfoDefaultTypeInternal()
    {
    }
    union {
        HostInfo _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HostInfoDefaultTypeInternal _HostInfo_default_instance_;
PROTOBUF_CONSTEXPR UrlInfo::UrlInfo(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct UrlInfoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR UrlInfoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~UrlInfoDefaultTypeInternal()
    {
    }
    union {
        UrlInfo _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UrlInfoDefaultTypeInternal _UrlInfo_default_instance_;
PROTOBUF_CONSTEXPR HashedHostInfos::HashedHostInfos(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.partial_host_hashes_)*/ {},
        /*decltype(_impl_.num_hash_bits_)*/ 0u }
{
}
struct HashedHostInfosDefaultTypeInternal {
    PROTOBUF_CONSTEXPR HashedHostInfosDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~HashedHostInfosDefaultTypeInternal()
    {
    }
    union {
        HashedHostInfos _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HashedHostInfosDefaultTypeInternal _HashedHostInfos_default_instance_;
PROTOBUF_CONSTEXPR GetHintsRequest::GetHintsRequest(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.hosts_)*/ {},
        /*decltype(_impl_.supported_optimizations_)*/ {}, /*decltype(_impl_.urls_)*/ {}, /*decltype(_impl_.supported_key_representations_)*/ {},
        /*decltype(_impl_.locale_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.hashed_hosts_)*/ nullptr,
        /*decltype(_impl_.origin_info_)*/ nullptr, /*decltype(_impl_.context_metadata_)*/ nullptr, /*decltype(_impl_.context_)*/ 0 }
{
}
struct GetHintsRequestDefaultTypeInternal {
    PROTOBUF_CONSTEXPR GetHintsRequestDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~GetHintsRequestDefaultTypeInternal()
    {
    }
    union {
        GetHintsRequest _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetHintsRequestDefaultTypeInternal _GetHintsRequest_default_instance_;
PROTOBUF_CONSTEXPR RequestContextMetadata::RequestContextMetadata(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.metadata_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_._oneof_case_)*/ {} }
{
}
struct RequestContextMetadataDefaultTypeInternal {
    PROTOBUF_CONSTEXPR RequestContextMetadataDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~RequestContextMetadataDefaultTypeInternal()
    {
    }
    union {
        RequestContextMetadata _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RequestContextMetadataDefaultTypeInternal
    _RequestContextMetadata_default_instance_;
PROTOBUF_CONSTEXPR PageInsightsHubRequestContextMetadata::PageInsightsHubRequestContextMetadata(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.navigation_timestamp_ms_)*/ int64_t { 0 },
        /*decltype(_impl_.is_user_initiated_)*/ false, /*decltype(_impl_.is_initial_page_)*/ false, /*decltype(_impl_.should_not_log_or_personalize_)*/ false }
{
}
struct PageInsightsHubRequestContextMetadataDefaultTypeInternal {
    PROTOBUF_CONSTEXPR PageInsightsHubRequestContextMetadataDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~PageInsightsHubRequestContextMetadataDefaultTypeInternal()
    {
    }
    union {
        PageInsightsHubRequestContextMetadata _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PageInsightsHubRequestContextMetadataDefaultTypeInternal
    _PageInsightsHubRequestContextMetadata_default_instance_;
PROTOBUF_CONSTEXPR GetHintsResponse::GetHintsResponse(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.hints_)*/ {},
        /*decltype(_impl_.hints_to_remove_)*/ {}, /*decltype(_impl_.max_cache_duration_)*/ nullptr }
{
}
struct GetHintsResponseDefaultTypeInternal {
    PROTOBUF_CONSTEXPR GetHintsResponseDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~GetHintsResponseDefaultTypeInternal()
    {
    }
    union {
        GetHintsResponse _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetHintsResponseDefaultTypeInternal _GetHintsResponse_default_instance_;
PROTOBUF_CONSTEXPR Optimization::Optimization(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.tuning_version_)*/ uint64_t { 0u },
        /*decltype(_impl_.optimization_type_)*/ 0, /*decltype(_impl_.metadata_)*/ {}, /*decltype(_impl_._oneof_case_)*/ {} }
{
}
struct OptimizationDefaultTypeInternal {
    PROTOBUF_CONSTEXPR OptimizationDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~OptimizationDefaultTypeInternal()
    {
    }
    union {
        Optimization _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OptimizationDefaultTypeInternal _Optimization_default_instance_;
PROTOBUF_CONSTEXPR PageHint::PageHint(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.allowlisted_optimizations_)*/ {},
        /*decltype(_impl_.page_pattern_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct PageHintDefaultTypeInternal {
    PROTOBUF_CONSTEXPR PageHintDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~PageHintDefaultTypeInternal()
    {
    }
    union {
        PageHint _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PageHintDefaultTypeInternal _PageHint_default_instance_;
PROTOBUF_CONSTEXPR Hint::Hint(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.allowlisted_optimizations_)*/ {},
        /*decltype(_impl_.page_hints_)*/ {}, /*decltype(_impl_.key_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.version_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.max_cache_duration_)*/ nullptr,
        /*decltype(_impl_.key_representation_)*/ 0 }
{
}
struct HintDefaultTypeInternal {
    PROTOBUF_CONSTEXPR HintDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~HintDefaultTypeInternal()
    {
    }
    union {
        Hint _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HintDefaultTypeInternal _Hint_default_instance_;
PROTOBUF_CONSTEXPR BloomFilter::BloomFilter(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.data_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.num_hash_functions_)*/ 0u,
        /*decltype(_impl_.num_bits_)*/ 0u }
{
}
struct BloomFilterDefaultTypeInternal {
    PROTOBUF_CONSTEXPR BloomFilterDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~BloomFilterDefaultTypeInternal()
    {
    }
    union {
        BloomFilter _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BloomFilterDefaultTypeInternal _BloomFilter_default_instance_;
PROTOBUF_CONSTEXPR OptimizationFilter::OptimizationFilter(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.regexps_)*/ {},
        /*decltype(_impl_.exclusion_regexps_)*/ {}, /*decltype(_impl_.bloom_filter_)*/ nullptr, /*decltype(_impl_.optimization_type_)*/ 0,
        /*decltype(_impl_.skip_host_suffix_checking_)*/ false, /*decltype(_impl_.bloom_filter_format_)*/ 0 }
{
}
struct OptimizationFilterDefaultTypeInternal {
    PROTOBUF_CONSTEXPR OptimizationFilterDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~OptimizationFilterDefaultTypeInternal()
    {
    }
    union {
        OptimizationFilter _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OptimizationFilterDefaultTypeInternal _OptimizationFilter_default_instance_;
PROTOBUF_CONSTEXPR Configuration::Configuration(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.hints_)*/ {}, /*decltype(_impl_.optimization_blocklists_)*/ {}, /*decltype(_impl_.optimization_allowlists_)*/ {},
        /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct ConfigurationDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ConfigurationDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ConfigurationDefaultTypeInternal()
    {
    }
    union {
        Configuration _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConfigurationDefaultTypeInternal _Configuration_default_instance_;
PROTOBUF_CONSTEXPR Version::Version(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.generation_timestamp_)*/ nullptr,
        /*decltype(_impl_.hint_source_)*/ 0 }
{
}
struct VersionDefaultTypeInternal {
    PROTOBUF_CONSTEXPR VersionDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~VersionDefaultTypeInternal()
    {
    }
    union {
        Version _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VersionDefaultTypeInternal _Version_default_instance_;
} // namespace proto
} // namespace optimization_guide
namespace optimization_guide {
namespace proto {
bool OptimizationType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 13:
    case 14:
    case 15:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 30:
    case 31:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 48:
    case 55:
    case 56:
    case 57:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 65:
    case 67:
    case 68:
    case 69:
    case 70:
    case 71:
    case 73:
    case 74:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> OptimizationType_strings[62] = {};

static const char OptimizationType_names[] = "ABOUT_THIS_SITE"
                                             "AMERICAN_EXPRESS_CREDIT_CARD_FLIGHT_BENEFITS"
                                             "AMERICAN_EXPRESS_CREDIT_CARD_SUBSCRIPTION_BENEFITS"
                                             "AMOUNT_EXTRACTION_ALLOWLIST"
                                             "AUTOFILL_ABLATION_SITES_LIST1"
                                             "AUTOFILL_ABLATION_SITES_LIST2"
                                             "AUTOFILL_ABLATION_SITES_LIST3"
                                             "AUTOFILL_ABLATION_SITES_LIST4"
                                             "AUTOFILL_ABLATION_SITES_LIST5"
                                             "AUTOFILL_ABLATION_SITES_LIST6"
                                             "AUTOFILL_PREDICTION_IMPROVEMENTS_ALLOWLIST"
                                             "AUTOFILL_SAMPLING_RATE"
                                             "BLOOM_FILTER_VALIDATION"
                                             "BUY_NOW_PAY_LATER_ALLOWLIST_AFFIRM"
                                             "BUY_NOW_PAY_LATER_ALLOWLIST_ZIP"
                                             "CAPITAL_ONE_CREDIT_CARD_BENEFITS_BLOCKED"
                                             "CAPITAL_ONE_CREDIT_CARD_DINING_BENEFITS"
                                             "CAPITAL_ONE_CREDIT_CARD_ENTERTAINMENT_BENEFITS"
                                             "CAPITAL_ONE_CREDIT_CARD_GROCERY_BENEFITS"
                                             "CAPITAL_ONE_CREDIT_CARD_STREAMING_BENEFITS"
                                             "COMPOSE"
                                             "COMPRESS_PUBLIC_IMAGES"
                                             "DEFER_ALL_SCRIPT"
                                             "FAST_HOST_HINTS"
                                             "FORMS_ANNOTATIONS"
                                             "HISTORY_CLUSTERS"
                                             "HISTORY_EMBEDDINGS"
                                             "IBAN_AUTOFILL_BLOCKED"
                                             "LINK_PERFORMANCE"
                                             "LITE_PAGE"
                                             "LITE_PAGE_REDIRECT"
                                             "LITE_VIDEO"
                                             "LOADING_PREDICTOR"
                                             "MERCHANT_TRUST_SIGNALS"
                                             "MERCHANT_TRUST_SIGNALS_V2"
                                             "METADATA_FETCH_VALIDATION"
                                             "NOSCRIPT"
                                             "PAGE_ENTITIES"
                                             "PERFORMANCE_HINTS"
                                             "PIX_MERCHANT_ORIGINS_ALLOWLIST"
                                             "PIX_PAYMENT_MERCHANT_ALLOWLIST"
                                             "PRICE_INSIGHTS"
                                             "PRICE_TRACKING"
                                             "RESOURCE_LOADING"
                                             "SALIENT_IMAGE"
                                             "SAVED_TAB_GROUP"
                                             "SHARED_CREDIT_CARD_DINING_BENEFITS"
                                             "SHARED_CREDIT_CARD_ENTERTAINMENT_BENEFITS"
                                             "SHARED_CREDIT_CARD_FLIGHT_BENEFITS"
                                             "SHARED_CREDIT_CARD_GROCERY_BENEFITS"
                                             "SHARED_CREDIT_CARD_STREAMING_BENEFITS"
                                             "SHARED_CREDIT_CARD_SUBSCRIPTION_BENEFITS"
                                             "SHOPPING_DISCOUNTS"
                                             "SHOPPING_PAGE_PREDICTOR"
                                             "SHOPPING_PAGE_TYPES"
                                             "TEXT_CLASSIFIER_ENTITY_DETECTION"
                                             "THANK_CREATOR_ELIGIBLE"
                                             "TYPE_UNSPECIFIED"
                                             "V8_COMPILE_HINTS"
                                             "VCN_MERCHANT_OPT_OUT_DISCOVER"
                                             "VCN_MERCHANT_OPT_OUT_MASTERCARD"
                                             "VCN_MERCHANT_OPT_OUT_VISA";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry OptimizationType_entries[] = {
    { { OptimizationType_names + 0, 15 }, 20 },
    { { OptimizationType_names + 15, 44 }, 47 },
    { { OptimizationType_names + 59, 50 }, 48 },
    { { OptimizationType_names + 109, 27 }, 67 },
    { { OptimizationType_names + 136, 29 }, 60 },
    { { OptimizationType_names + 165, 29 }, 61 },
    { { OptimizationType_names + 194, 29 }, 62 },
    { { OptimizationType_names + 223, 29 }, 63 },
    { { OptimizationType_names + 252, 29 }, 64 },
    { { OptimizationType_names + 281, 29 }, 65 },
    { { OptimizationType_names + 310, 42 }, 68 },
    { { OptimizationType_names + 352, 22 }, 27 },
    { { OptimizationType_names + 374, 23 }, 19 },
    { { OptimizationType_names + 397, 34 }, 69 },
    { { OptimizationType_names + 431, 31 }, 70 },
    { { OptimizationType_names + 462, 40 }, 55 },
    { { OptimizationType_names + 502, 39 }, 43 },
    { { OptimizationType_names + 541, 46 }, 45 },
    { { OptimizationType_names + 587, 40 }, 44 },
    { { OptimizationType_names + 627, 42 }, 46 },
    { { OptimizationType_names + 669, 7 }, 35 },
    { { OptimizationType_names + 676, 22 }, 8 },
    { { OptimizationType_names + 698, 16 }, 5 },
    { { OptimizationType_names + 714, 15 }, 10 },
    { { OptimizationType_names + 729, 17 }, 73 },
    { { OptimizationType_names + 746, 16 }, 23 },
    { { OptimizationType_names + 762, 18 }, 59 },
    { { OptimizationType_names + 780, 21 }, 25 },
    { { OptimizationType_names + 801, 16 }, 14 },
    { { OptimizationType_names + 817, 9 }, 7 },
    { { OptimizationType_names + 826, 18 }, 3 },
    { { OptimizationType_names + 844, 10 }, 13 },
    { { OptimizationType_names + 854, 17 }, 9 },
    { { OptimizationType_names + 871, 22 }, 17 },
    { { OptimizationType_names + 893, 25 }, 21 },
    { { OptimizationType_names + 918, 25 }, 4 },
    { { OptimizationType_names + 943, 8 }, 1 },
    { { OptimizationType_names + 951, 13 }, 22 },
    { { OptimizationType_names + 964, 17 }, 6 },
    { { OptimizationType_names + 981, 30 }, 58 },
    { { OptimizationType_names + 1011, 30 }, 36 },
    { { OptimizationType_names + 1041, 14 }, 30 },
    { { OptimizationType_names + 1055, 14 }, 18 },
    { { OptimizationType_names + 1069, 16 }, 2 },
    { { OptimizationType_names + 1085, 13 }, 26 },
    { { OptimizationType_names + 1098, 15 }, 71 },
    { { OptimizationType_names + 1113, 34 }, 38 },
    { { OptimizationType_names + 1147, 41 }, 40 },
    { { OptimizationType_names + 1188, 34 }, 37 },
    { { OptimizationType_names + 1222, 35 }, 39 },
    { { OptimizationType_names + 1257, 37 }, 41 },
    { { OptimizationType_names + 1294, 40 }, 42 },
    { { OptimizationType_names + 1334, 18 }, 34 },
    { { OptimizationType_names + 1352, 23 }, 15 },
    { { OptimizationType_names + 1375, 19 }, 33 },
    { { OptimizationType_names + 1394, 32 }, 74 },
    { { OptimizationType_names + 1426, 22 }, 24 },
    { { OptimizationType_names + 1448, 16 }, 0 },
    { { OptimizationType_names + 1464, 16 }, 31 },
    { { OptimizationType_names + 1480, 29 }, 56 },
    { { OptimizationType_names + 1509, 31 }, 57 },
    { { OptimizationType_names + 1540, 25 }, 28 },
};

static const int OptimizationType_entries_by_number[] = {
    57, // 0 -> TYPE_UNSPECIFIED
    36, // 1 -> NOSCRIPT
    43, // 2 -> RESOURCE_LOADING
    30, // 3 -> LITE_PAGE_REDIRECT
    35, // 4 -> METADATA_FETCH_VALIDATION
    22, // 5 -> DEFER_ALL_SCRIPT
    38, // 6 -> PERFORMANCE_HINTS
    29, // 7 -> LITE_PAGE
    21, // 8 -> COMPRESS_PUBLIC_IMAGES
    32, // 9 -> LOADING_PREDICTOR
    23, // 10 -> FAST_HOST_HINTS
    31, // 13 -> LITE_VIDEO
    28, // 14 -> LINK_PERFORMANCE
    53, // 15 -> SHOPPING_PAGE_PREDICTOR
    33, // 17 -> MERCHANT_TRUST_SIGNALS
    42, // 18 -> PRICE_TRACKING
    12, // 19 -> BLOOM_FILTER_VALIDATION
    0, // 20 -> ABOUT_THIS_SITE
    34, // 21 -> MERCHANT_TRUST_SIGNALS_V2
    37, // 22 -> PAGE_ENTITIES
    25, // 23 -> HISTORY_CLUSTERS
    56, // 24 -> THANK_CREATOR_ELIGIBLE
    27, // 25 -> IBAN_AUTOFILL_BLOCKED
    44, // 26 -> SALIENT_IMAGE
    11, // 27 -> AUTOFILL_SAMPLING_RATE
    61, // 28 -> VCN_MERCHANT_OPT_OUT_VISA
    41, // 30 -> PRICE_INSIGHTS
    58, // 31 -> V8_COMPILE_HINTS
    54, // 33 -> SHOPPING_PAGE_TYPES
    52, // 34 -> SHOPPING_DISCOUNTS
    20, // 35 -> COMPOSE
    40, // 36 -> PIX_PAYMENT_MERCHANT_ALLOWLIST
    48, // 37 -> SHARED_CREDIT_CARD_FLIGHT_BENEFITS
    46, // 38 -> SHARED_CREDIT_CARD_DINING_BENEFITS
    49, // 39 -> SHARED_CREDIT_CARD_GROCERY_BENEFITS
    47, // 40 -> SHARED_CREDIT_CARD_ENTERTAINMENT_BENEFITS
    50, // 41 -> SHARED_CREDIT_CARD_STREAMING_BENEFITS
    51, // 42 -> SHARED_CREDIT_CARD_SUBSCRIPTION_BENEFITS
    16, // 43 -> CAPITAL_ONE_CREDIT_CARD_DINING_BENEFITS
    18, // 44 -> CAPITAL_ONE_CREDIT_CARD_GROCERY_BENEFITS
    17, // 45 -> CAPITAL_ONE_CREDIT_CARD_ENTERTAINMENT_BENEFITS
    19, // 46 -> CAPITAL_ONE_CREDIT_CARD_STREAMING_BENEFITS
    1, // 47 -> AMERICAN_EXPRESS_CREDIT_CARD_FLIGHT_BENEFITS
    2, // 48 -> AMERICAN_EXPRESS_CREDIT_CARD_SUBSCRIPTION_BENEFITS
    15, // 55 -> CAPITAL_ONE_CREDIT_CARD_BENEFITS_BLOCKED
    59, // 56 -> VCN_MERCHANT_OPT_OUT_DISCOVER
    60, // 57 -> VCN_MERCHANT_OPT_OUT_MASTERCARD
    39, // 58 -> PIX_MERCHANT_ORIGINS_ALLOWLIST
    26, // 59 -> HISTORY_EMBEDDINGS
    4, // 60 -> AUTOFILL_ABLATION_SITES_LIST1
    5, // 61 -> AUTOFILL_ABLATION_SITES_LIST2
    6, // 62 -> AUTOFILL_ABLATION_SITES_LIST3
    7, // 63 -> AUTOFILL_ABLATION_SITES_LIST4
    8, // 64 -> AUTOFILL_ABLATION_SITES_LIST5
    9, // 65 -> AUTOFILL_ABLATION_SITES_LIST6
    3, // 67 -> AMOUNT_EXTRACTION_ALLOWLIST
    10, // 68 -> AUTOFILL_PREDICTION_IMPROVEMENTS_ALLOWLIST
    13, // 69 -> BUY_NOW_PAY_LATER_ALLOWLIST_AFFIRM
    14, // 70 -> BUY_NOW_PAY_LATER_ALLOWLIST_ZIP
    45, // 71 -> SAVED_TAB_GROUP
    24, // 73 -> FORMS_ANNOTATIONS
    55, // 74 -> TEXT_CLASSIFIER_ENTITY_DETECTION
};

const std::string& OptimizationType_Name(OptimizationType value)
{
    static const bool dummy
        = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(OptimizationType_entries, OptimizationType_entries_by_number, 62, OptimizationType_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(OptimizationType_entries, OptimizationType_entries_by_number, 62, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : OptimizationType_strings[idx].get();
}
bool OptimizationType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OptimizationType* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(OptimizationType_entries, 62, name, &int_value);
    if (success) {
        *value = static_cast<OptimizationType>(int_value);
    }
    return success;
}
bool KeyRepresentation_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> KeyRepresentation_strings[5] = {};

static const char KeyRepresentation_names[] = "FULL_URL"
                                              "HASHED_HOST"
                                              "HOST"
                                              "HOST_SUFFIX"
                                              "REPRESENTATION_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry KeyRepresentation_entries[] = {
    { { KeyRepresentation_names + 0, 8 }, 2 },
    { { KeyRepresentation_names + 8, 11 }, 4 },
    { { KeyRepresentation_names + 19, 4 }, 3 },
    { { KeyRepresentation_names + 23, 11 }, 1 },
    { { KeyRepresentation_names + 34, 26 }, 0 },
};

static const int KeyRepresentation_entries_by_number[] = {
    4, // 0 -> REPRESENTATION_UNSPECIFIED
    3, // 1 -> HOST_SUFFIX
    0, // 2 -> FULL_URL
    2, // 3 -> HOST
    1, // 4 -> HASHED_HOST
};

const std::string& KeyRepresentation_Name(KeyRepresentation value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        KeyRepresentation_entries, KeyRepresentation_entries_by_number, 5, KeyRepresentation_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(KeyRepresentation_entries, KeyRepresentation_entries_by_number, 5, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : KeyRepresentation_strings[idx].get();
}
bool KeyRepresentation_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, KeyRepresentation* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(KeyRepresentation_entries, 5, name, &int_value);
    if (success) {
        *value = static_cast<KeyRepresentation>(int_value);
    }
    return success;
}
bool BloomFilterFormat_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> BloomFilterFormat_strings[3] = {};

static const char BloomFilterFormat_names[] = "BLOOM_FILTER_FORMAT_PLAINTEXT"
                                              "BLOOM_FILTER_FORMAT_SHA256"
                                              "BLOOM_FILTER_FORMAT_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry BloomFilterFormat_entries[] = {
    { { BloomFilterFormat_names + 0, 29 }, 1 },
    { { BloomFilterFormat_names + 29, 26 }, 2 },
    { { BloomFilterFormat_names + 55, 27 }, 0 },
};

static const int BloomFilterFormat_entries_by_number[] = {
    2, // 0 -> BLOOM_FILTER_FORMAT_UNKNOWN
    0, // 1 -> BLOOM_FILTER_FORMAT_PLAINTEXT
    1, // 2 -> BLOOM_FILTER_FORMAT_SHA256
};

const std::string& BloomFilterFormat_Name(BloomFilterFormat value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        BloomFilterFormat_entries, BloomFilterFormat_entries_by_number, 3, BloomFilterFormat_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(BloomFilterFormat_entries, BloomFilterFormat_entries_by_number, 3, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : BloomFilterFormat_strings[idx].get();
}
bool BloomFilterFormat_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BloomFilterFormat* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(BloomFilterFormat_entries, 3, name, &int_value);
    if (success) {
        *value = static_cast<BloomFilterFormat>(int_value);
    }
    return success;
}
bool HintSource_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> HintSource_strings[3] = {};

static const char HintSource_names[] = "HINT_SOURCE_OPTIMIZATION_GUIDE_SERVICE"
                                       "HINT_SOURCE_OPTIMIZATION_HINTS_COMPONENT"
                                       "HINT_SOURCE_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry HintSource_entries[] = {
    { { HintSource_names + 0, 38 }, 2 },
    { { HintSource_names + 38, 40 }, 1 },
    { { HintSource_names + 78, 19 }, 0 },
};

static const int HintSource_entries_by_number[] = {
    2, // 0 -> HINT_SOURCE_UNKNOWN
    1, // 1 -> HINT_SOURCE_OPTIMIZATION_HINTS_COMPONENT
    0, // 2 -> HINT_SOURCE_OPTIMIZATION_GUIDE_SERVICE
};

const std::string& HintSource_Name(HintSource value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(HintSource_entries, HintSource_entries_by_number, 3, HintSource_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(HintSource_entries, HintSource_entries_by_number, 3, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : HintSource_strings[idx].get();
}
bool HintSource_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HintSource* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(HintSource_entries, 3, name, &int_value);
    if (success) {
        *value = static_cast<HintSource>(int_value);
    }
    return success;
}
bool ThemeKey_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ThemeKey_strings[3] = {};

static const char ThemeKey_names[] = "THEME_KEY_DARK"
                                     "THEME_KEY_LIGHT"
                                     "THEME_KEY_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ThemeKey_entries[] = {
    { { ThemeKey_names + 0, 14 }, 2 },
    { { ThemeKey_names + 14, 15 }, 1 },
    { { ThemeKey_names + 29, 17 }, 0 },
};

static const int ThemeKey_entries_by_number[] = {
    2, // 0 -> THEME_KEY_UNKNOWN
    1, // 1 -> THEME_KEY_LIGHT
    0, // 2 -> THEME_KEY_DARK
};

const std::string& ThemeKey_Name(ThemeKey value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(ThemeKey_entries, ThemeKey_entries_by_number, 3, ThemeKey_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(ThemeKey_entries, ThemeKey_entries_by_number, 3, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : ThemeKey_strings[idx].get();
}
bool ThemeKey_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ThemeKey* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(ThemeKey_entries, 3, name, &int_value);
    if (success) {
        *value = static_cast<ThemeKey>(int_value);
    }
    return success;
}

// ===================================================================

class MatchedHintInfo::_Internal {
public:
    using HasBits = decltype(std::declval<MatchedHintInfo>()._impl_._has_bits_);
    static void set_has_key_representation(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_key(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_version(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

MatchedHintInfo::MatchedHintInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:optimization_guide.proto.MatchedHintInfo)
}
MatchedHintInfo::MatchedHintInfo(const MatchedHintInfo& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    MatchedHintInfo* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.key_) {},
        decltype(_impl_.version_) {}, decltype(_impl_.key_representation_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.key_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_key()) {
        _this->_impl_.key_.Set(from._internal_key(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.version_, &from._impl_.version_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.key_representation_) - reinterpret_cast<char*>(&_impl_.version_))
            + sizeof(_impl_.key_representation_));
    // @@protoc_insertion_point(copy_constructor:optimization_guide.proto.MatchedHintInfo)
}

inline void MatchedHintInfo::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.key_) {},
        decltype(_impl_.version_) { int64_t { 0 } }, decltype(_impl_.key_representation_) { 0 } };
    _impl_.key_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MatchedHintInfo::~MatchedHintInfo()
{
    // @@protoc_insertion_point(destructor:optimization_guide.proto.MatchedHintInfo)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void MatchedHintInfo::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.key_.Destroy();
}

void MatchedHintInfo::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void MatchedHintInfo::Clear()
{
    // @@protoc_insertion_point(message_clear_start:optimization_guide.proto.MatchedHintInfo)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000006u) {
        ::memset(&_impl_.version_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.key_representation_) - reinterpret_cast<char*>(&_impl_.version_))
                + sizeof(_impl_.key_representation_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* MatchedHintInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .optimization_guide.proto.KeyRepresentation key_representation = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::optimization_guide::proto::KeyRepresentation_IsValid(val))) {
                    _internal_set_key_representation(static_cast<::optimization_guide::proto::KeyRepresentation>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional string key = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_key();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 version = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_version(&has_bits);
                _impl_.version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* MatchedHintInfo::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:optimization_guide.proto.MatchedHintInfo)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .optimization_guide.proto.KeyRepresentation key_representation = 1;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(1, this->_internal_key_representation(), target);
    }

    // optional string key = 2;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_key(), target);
    }

    // optional int64 version = 3;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_version(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:optimization_guide.proto.MatchedHintInfo)
    return target;
}

size_t MatchedHintInfo::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:optimization_guide.proto.MatchedHintInfo)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional string key = 2;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_key());
        }

        // optional int64 version = 3;
        if (cached_has_bits & 0x00000002u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_version());
        }

        // optional .optimization_guide.proto.KeyRepresentation key_representation = 1;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_key_representation());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void MatchedHintInfo::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const MatchedHintInfo*>(&from));
}

void MatchedHintInfo::MergeFrom(const MatchedHintInfo& from)
{
    MatchedHintInfo* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:optimization_guide.proto.MatchedHintInfo)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_key(from._internal_key());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.version_ = from._impl_.version_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.key_representation_ = from._impl_.key_representation_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MatchedHintInfo::CopyFrom(const MatchedHintInfo& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:optimization_guide.proto.MatchedHintInfo)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool MatchedHintInfo::IsInitialized() const
{
    return true;
}

void MatchedHintInfo::InternalSwap(MatchedHintInfo* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.key_, lhs_arena, &other->_impl_.key_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(MatchedHintInfo, _impl_.key_representation_)
        + sizeof(MatchedHintInfo::_impl_.key_representation_) - PROTOBUF_FIELD_OFFSET(MatchedHintInfo, _impl_.version_)>(
        reinterpret_cast<char*>(&_impl_.version_), reinterpret_cast<char*>(&other->_impl_.version_));
}

std::string MatchedHintInfo::GetTypeName() const
{
    return "optimization_guide.proto.MatchedHintInfo";
}

// ===================================================================

class HostInfo::_Internal {
public:
    using HasBits = decltype(std::declval<HostInfo>()._impl_._has_bits_);
    static void set_has_host(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static const ::optimization_guide::proto::MatchedHintInfo& matched_hint(const HostInfo* msg);
    static void set_has_matched_hint(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

const ::optimization_guide::proto::MatchedHintInfo& HostInfo::_Internal::matched_hint(const HostInfo* msg)
{
    return *msg->_impl_.matched_hint_;
}
HostInfo::HostInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:optimization_guide.proto.HostInfo)
}
HostInfo::HostInfo(const HostInfo& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    HostInfo* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.host_) {},
        decltype(_impl_.matched_hint_) { nullptr } };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.host_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.host_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_host()) {
        _this->_impl_.host_.Set(from._internal_host(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_matched_hint()) {
        _this->_impl_.matched_hint_ = new ::optimization_guide::proto::MatchedHintInfo(*from._impl_.matched_hint_);
    }
    // @@protoc_insertion_point(copy_constructor:optimization_guide.proto.HostInfo)
}

inline void HostInfo::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_)
        Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.host_) {}, decltype(_impl_.matched_hint_) { nullptr } };
    _impl_.host_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.host_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

HostInfo::~HostInfo()
{
    // @@protoc_insertion_point(destructor:optimization_guide.proto.HostInfo)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void HostInfo::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.host_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.matched_hint_;
}

void HostInfo::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void HostInfo::Clear()
{
    // @@protoc_insertion_point(message_clear_start:optimization_guide.proto.HostInfo)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.host_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            GOOGLE_DCHECK(_impl_.matched_hint_ != nullptr);
            _impl_.matched_hint_->Clear();
        }
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* HostInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string host = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_host();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .optimization_guide.proto.MatchedHintInfo matched_hint = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_matched_hint(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* HostInfo::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:optimization_guide.proto.HostInfo)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string host = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_host(), target);
    }

    // optional .optimization_guide.proto.MatchedHintInfo matched_hint = 2;
    if (cached_has_bits & 0x00000002u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::matched_hint(this), _Internal::matched_hint(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:optimization_guide.proto.HostInfo)
    return target;
}

size_t HostInfo::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:optimization_guide.proto.HostInfo)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional string host = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_host());
        }

        // optional .optimization_guide.proto.MatchedHintInfo matched_hint = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.matched_hint_);
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void HostInfo::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const HostInfo*>(&from));
}

void HostInfo::MergeFrom(const HostInfo& from)
{
    HostInfo* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:optimization_guide.proto.HostInfo)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_host(from._internal_host());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_mutable_matched_hint()->::optimization_guide::proto::MatchedHintInfo::MergeFrom(from._internal_matched_hint());
        }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void HostInfo::CopyFrom(const HostInfo& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:optimization_guide.proto.HostInfo)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool HostInfo::IsInitialized() const
{
    return true;
}

void HostInfo::InternalSwap(HostInfo* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.host_, lhs_arena, &other->_impl_.host_, rhs_arena);
    swap(_impl_.matched_hint_, other->_impl_.matched_hint_);
}

std::string HostInfo::GetTypeName() const
{
    return "optimization_guide.proto.HostInfo";
}

// ===================================================================

class UrlInfo::_Internal {
public:
    using HasBits = decltype(std::declval<UrlInfo>()._impl_._has_bits_);
    static void set_has_url(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

UrlInfo::UrlInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:optimization_guide.proto.UrlInfo)
}
UrlInfo::UrlInfo(const UrlInfo& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    UrlInfo* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.url_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_url()) {
        _this->_impl_.url_.Set(from._internal_url(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:optimization_guide.proto.UrlInfo)
}

inline void UrlInfo::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.url_) {} };
    _impl_.url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

UrlInfo::~UrlInfo()
{
    // @@protoc_insertion_point(destructor:optimization_guide.proto.UrlInfo)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void UrlInfo::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.url_.Destroy();
}

void UrlInfo::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void UrlInfo::Clear()
{
    // @@protoc_insertion_point(message_clear_start:optimization_guide.proto.UrlInfo)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.url_.ClearNonDefaultToEmpty();
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* UrlInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string url = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* UrlInfo::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:optimization_guide.proto.UrlInfo)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string url = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_url(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:optimization_guide.proto.UrlInfo)
    return target;
}

size_t UrlInfo::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:optimization_guide.proto.UrlInfo)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional string url = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_url());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void UrlInfo::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const UrlInfo*>(&from));
}

void UrlInfo::MergeFrom(const UrlInfo& from)
{
    UrlInfo* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:optimization_guide.proto.UrlInfo)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_url()) {
        _this->_internal_set_url(from._internal_url());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UrlInfo::CopyFrom(const UrlInfo& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:optimization_guide.proto.UrlInfo)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool UrlInfo::IsInitialized() const
{
    return true;
}

void UrlInfo::InternalSwap(UrlInfo* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.url_, lhs_arena, &other->_impl_.url_, rhs_arena);
}

std::string UrlInfo::GetTypeName() const
{
    return "optimization_guide.proto.UrlInfo";
}

// ===================================================================

class HashedHostInfos::_Internal {
public:
    using HasBits = decltype(std::declval<HashedHostInfos>()._impl_._has_bits_);
    static void set_has_num_hash_bits(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

HashedHostInfos::HashedHostInfos(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:optimization_guide.proto.HashedHostInfos)
}
HashedHostInfos::HashedHostInfos(const HashedHostInfos& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    HashedHostInfos* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.partial_host_hashes_) { from._impl_.partial_host_hashes_ }, decltype(_impl_.num_hash_bits_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _this->_impl_.num_hash_bits_ = from._impl_.num_hash_bits_;
    // @@protoc_insertion_point(copy_constructor:optimization_guide.proto.HashedHostInfos)
}

inline void HashedHostInfos::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.partial_host_hashes_) { arena },
        decltype(_impl_.num_hash_bits_) { 0u } };
}

HashedHostInfos::~HashedHostInfos()
{
    // @@protoc_insertion_point(destructor:optimization_guide.proto.HashedHostInfos)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void HashedHostInfos::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.partial_host_hashes_.~RepeatedField();
}

void HashedHostInfos::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void HashedHostInfos::Clear()
{
    // @@protoc_insertion_point(message_clear_start:optimization_guide.proto.HashedHostInfos)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.partial_host_hashes_.Clear();
    _impl_.num_hash_bits_ = 0u;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* HashedHostInfos::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated uint32 partial_host_hashes = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    _internal_add_partial_host_hashes(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
            } else if (static_cast<uint8_t>(tag) == 10) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_partial_host_hashes(), ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional uint32 num_hash_bits = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_num_hash_bits(&has_bits);
                _impl_.num_hash_bits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* HashedHostInfos::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:optimization_guide.proto.HashedHostInfos)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated uint32 partial_host_hashes = 1;
    for (int i = 0, n = this->_internal_partial_host_hashes_size(); i < n; i++) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_partial_host_hashes(i), target);
    }

    cached_has_bits = _impl_._has_bits_[0];
    // optional uint32 num_hash_bits = 2;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_num_hash_bits(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:optimization_guide.proto.HashedHostInfos)
    return target;
}

size_t HashedHostInfos::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:optimization_guide.proto.HashedHostInfos)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated uint32 partial_host_hashes = 1;
    {
        size_t data_size = ::_pbi::WireFormatLite::UInt32Size(this->_impl_.partial_host_hashes_);
        total_size += 1 * ::_pbi::FromIntSize(this->_internal_partial_host_hashes_size());
        total_size += data_size;
    }

    // optional uint32 num_hash_bits = 2;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_num_hash_bits());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void HashedHostInfos::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const HashedHostInfos*>(&from));
}

void HashedHostInfos::MergeFrom(const HashedHostInfos& from)
{
    HashedHostInfos* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:optimization_guide.proto.HashedHostInfos)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.partial_host_hashes_.MergeFrom(from._impl_.partial_host_hashes_);
    if (from._internal_has_num_hash_bits()) {
        _this->_internal_set_num_hash_bits(from._internal_num_hash_bits());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void HashedHostInfos::CopyFrom(const HashedHostInfos& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:optimization_guide.proto.HashedHostInfos)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool HashedHostInfos::IsInitialized() const
{
    return true;
}

void HashedHostInfos::InternalSwap(HashedHostInfos* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.partial_host_hashes_.InternalSwap(&other->_impl_.partial_host_hashes_);
    swap(_impl_.num_hash_bits_, other->_impl_.num_hash_bits_);
}

std::string HashedHostInfos::GetTypeName() const
{
    return "optimization_guide.proto.HashedHostInfos";
}

// ===================================================================

class GetHintsRequest::_Internal {
public:
    using HasBits = decltype(std::declval<GetHintsRequest>()._impl_._has_bits_);
    static const ::optimization_guide::proto::HashedHostInfos& hashed_hosts(const GetHintsRequest* msg);
    static void set_has_hashed_hosts(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_context(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static const ::optimization_guide::proto::RequestContextMetadata& context_metadata(const GetHintsRequest* msg);
    static void set_has_context_metadata(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_locale(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static const ::optimization_guide::proto::OriginInfo& origin_info(const GetHintsRequest* msg);
    static void set_has_origin_info(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
};

const ::optimization_guide::proto::HashedHostInfos& GetHintsRequest::_Internal::hashed_hosts(const GetHintsRequest* msg)
{
    return *msg->_impl_.hashed_hosts_;
}
const ::optimization_guide::proto::RequestContextMetadata& GetHintsRequest::_Internal::context_metadata(const GetHintsRequest* msg)
{
    return *msg->_impl_.context_metadata_;
}
const ::optimization_guide::proto::OriginInfo& GetHintsRequest::_Internal::origin_info(const GetHintsRequest* msg)
{
    return *msg->_impl_.origin_info_;
}
void GetHintsRequest::clear_origin_info()
{
    if (_impl_.origin_info_ != nullptr)
        _impl_.origin_info_->Clear();
    _impl_._has_bits_[0] &= ~0x00000004u;
}
GetHintsRequest::GetHintsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:optimization_guide.proto.GetHintsRequest)
}
GetHintsRequest::GetHintsRequest(const GetHintsRequest& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    GetHintsRequest* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.hosts_) { from._impl_.hosts_ }, decltype(_impl_.supported_optimizations_) { from._impl_.supported_optimizations_ },
        decltype(_impl_.urls_) { from._impl_.urls_ }, decltype(_impl_.supported_key_representations_) { from._impl_.supported_key_representations_ },
        decltype(_impl_.locale_) {}, decltype(_impl_.hashed_hosts_) { nullptr }, decltype(_impl_.origin_info_) { nullptr },
        decltype(_impl_.context_metadata_) { nullptr }, decltype(_impl_.context_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.locale_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.locale_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_locale()) {
        _this->_impl_.locale_.Set(from._internal_locale(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_hashed_hosts()) {
        _this->_impl_.hashed_hosts_ = new ::optimization_guide::proto::HashedHostInfos(*from._impl_.hashed_hosts_);
    }
    if (from._internal_has_origin_info()) {
        _this->_impl_.origin_info_ = new ::optimization_guide::proto::OriginInfo(*from._impl_.origin_info_);
    }
    if (from._internal_has_context_metadata()) {
        _this->_impl_.context_metadata_ = new ::optimization_guide::proto::RequestContextMetadata(*from._impl_.context_metadata_);
    }
    _this->_impl_.context_ = from._impl_.context_;
    // @@protoc_insertion_point(copy_constructor:optimization_guide.proto.GetHintsRequest)
}

inline void GetHintsRequest::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.hosts_) { arena },
        decltype(_impl_.supported_optimizations_) { arena }, decltype(_impl_.urls_) { arena }, decltype(_impl_.supported_key_representations_) { arena },
        decltype(_impl_.locale_) {}, decltype(_impl_.hashed_hosts_) { nullptr }, decltype(_impl_.origin_info_) { nullptr },
        decltype(_impl_.context_metadata_) { nullptr }, decltype(_impl_.context_) { 0 } };
    _impl_.locale_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.locale_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GetHintsRequest::~GetHintsRequest()
{
    // @@protoc_insertion_point(destructor:optimization_guide.proto.GetHintsRequest)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void GetHintsRequest::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.hosts_.~RepeatedPtrField();
    _impl_.supported_optimizations_.~RepeatedField();
    _impl_.urls_.~RepeatedPtrField();
    _impl_.supported_key_representations_.~RepeatedField();
    _impl_.locale_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.hashed_hosts_;
    if (this != internal_default_instance())
        delete _impl_.origin_info_;
    if (this != internal_default_instance())
        delete _impl_.context_metadata_;
}

void GetHintsRequest::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void GetHintsRequest::Clear()
{
    // @@protoc_insertion_point(message_clear_start:optimization_guide.proto.GetHintsRequest)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.hosts_.Clear();
    _impl_.supported_optimizations_.Clear();
    _impl_.urls_.Clear();
    _impl_.supported_key_representations_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.locale_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            GOOGLE_DCHECK(_impl_.hashed_hosts_ != nullptr);
            _impl_.hashed_hosts_->Clear();
        }
        if (cached_has_bits & 0x00000004u) {
            GOOGLE_DCHECK(_impl_.origin_info_ != nullptr);
            _impl_.origin_info_->Clear();
        }
        if (cached_has_bits & 0x00000008u) {
            GOOGLE_DCHECK(_impl_.context_metadata_ != nullptr);
            _impl_.context_metadata_->Clear();
        }
    }
    _impl_.context_ = 0;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* GetHintsRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .optimization_guide.proto.HostInfo hosts = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_hosts(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        // repeated .optimization_guide.proto.OptimizationType supported_optimizations = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                    CHK_(ptr);
                    if (PROTOBUF_PREDICT_TRUE(::optimization_guide::proto::OptimizationType_IsValid(val))) {
                        _internal_add_supported_optimizations(static_cast<::optimization_guide::proto::OptimizationType>(val));
                    } else {
                        ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
                    }
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
            } else if (static_cast<uint8_t>(tag) == 18) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(
                    _internal_mutable_supported_optimizations(), ptr, ctx, ::optimization_guide::proto::OptimizationType_IsValid, &_internal_metadata_, 2);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .optimization_guide.proto.RequestContext context = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::optimization_guide::proto::RequestContext_IsValid(val))) {
                    _internal_set_context(static_cast<::optimization_guide::proto::RequestContext>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // repeated .optimization_guide.proto.UrlInfo urls = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_urls(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
            } else
                goto handle_unusual;
            continue;
        // repeated .optimization_guide.proto.KeyRepresentation supported_key_representations = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                    CHK_(ptr);
                    if (PROTOBUF_PREDICT_TRUE(::optimization_guide::proto::KeyRepresentation_IsValid(val))) {
                        _internal_add_supported_key_representations(static_cast<::optimization_guide::proto::KeyRepresentation>(val));
                    } else {
                        ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
                    }
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<40>(ptr));
            } else if (static_cast<uint8_t>(tag) == 42) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(_internal_mutable_supported_key_representations(), ptr, ctx,
                    ::optimization_guide::proto::KeyRepresentation_IsValid, &_internal_metadata_, 5);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string locale = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
                auto str = _internal_mutable_locale();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .optimization_guide.proto.HashedHostInfos hashed_hosts = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
                ptr = ctx->ParseMessage(_internal_mutable_hashed_hosts(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .optimization_guide.proto.OriginInfo origin_info = 9;
        case 9:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
                ptr = ctx->ParseMessage(_internal_mutable_origin_info(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .optimization_guide.proto.RequestContextMetadata context_metadata = 11;
        case 11:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
                ptr = ctx->ParseMessage(_internal_mutable_context_metadata(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* GetHintsRequest::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:optimization_guide.proto.GetHintsRequest)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .optimization_guide.proto.HostInfo hosts = 1;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_hosts_size()); i < n; i++) {
        const auto& repfield = this->_internal_hosts(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
    }

    // repeated .optimization_guide.proto.OptimizationType supported_optimizations = 2;
    for (int i = 0, n = this->_internal_supported_optimizations_size(); i < n; i++) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(2, this->_internal_supported_optimizations(i), target);
    }

    cached_has_bits = _impl_._has_bits_[0];
    // optional .optimization_guide.proto.RequestContext context = 3;
    if (cached_has_bits & 0x00000010u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(3, this->_internal_context(), target);
    }

    // repeated .optimization_guide.proto.UrlInfo urls = 4;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_urls_size()); i < n; i++) {
        const auto& repfield = this->_internal_urls(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
    }

    // repeated .optimization_guide.proto.KeyRepresentation supported_key_representations = 5;
    for (int i = 0, n = this->_internal_supported_key_representations_size(); i < n; i++) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(5, this->_internal_supported_key_representations(i), target);
    }

    // optional string locale = 7;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(7, this->_internal_locale(), target);
    }

    // optional .optimization_guide.proto.HashedHostInfos hashed_hosts = 8;
    if (cached_has_bits & 0x00000002u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            8, _Internal::hashed_hosts(this), _Internal::hashed_hosts(this).GetCachedSize(), target, stream);
    }

    // optional .optimization_guide.proto.OriginInfo origin_info = 9;
    if (cached_has_bits & 0x00000004u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            9, _Internal::origin_info(this), _Internal::origin_info(this).GetCachedSize(), target, stream);
    }

    // optional .optimization_guide.proto.RequestContextMetadata context_metadata = 11;
    if (cached_has_bits & 0x00000008u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            11, _Internal::context_metadata(this), _Internal::context_metadata(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:optimization_guide.proto.GetHintsRequest)
    return target;
}

size_t GetHintsRequest::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:optimization_guide.proto.GetHintsRequest)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .optimization_guide.proto.HostInfo hosts = 1;
    total_size += 1UL * this->_internal_hosts_size();
    for (const auto& msg : this->_impl_.hosts_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // repeated .optimization_guide.proto.OptimizationType supported_optimizations = 2;
    {
        size_t data_size = 0;
        unsigned int count = static_cast<unsigned int>(this->_internal_supported_optimizations_size());
        for (unsigned int i = 0; i < count; i++) {
            data_size += ::_pbi::WireFormatLite::EnumSize(this->_internal_supported_optimizations(static_cast<int>(i)));
        }
        total_size += (1UL * count) + data_size;
    }

    // repeated .optimization_guide.proto.UrlInfo urls = 4;
    total_size += 1UL * this->_internal_urls_size();
    for (const auto& msg : this->_impl_.urls_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // repeated .optimization_guide.proto.KeyRepresentation supported_key_representations = 5;
    {
        size_t data_size = 0;
        unsigned int count = static_cast<unsigned int>(this->_internal_supported_key_representations_size());
        for (unsigned int i = 0; i < count; i++) {
            data_size += ::_pbi::WireFormatLite::EnumSize(this->_internal_supported_key_representations(static_cast<int>(i)));
        }
        total_size += (1UL * count) + data_size;
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        // optional string locale = 7;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_locale());
        }

        // optional .optimization_guide.proto.HashedHostInfos hashed_hosts = 8;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.hashed_hosts_);
        }

        // optional .optimization_guide.proto.OriginInfo origin_info = 9;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.origin_info_);
        }

        // optional .optimization_guide.proto.RequestContextMetadata context_metadata = 11;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.context_metadata_);
        }

        // optional .optimization_guide.proto.RequestContext context = 3;
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_context());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void GetHintsRequest::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const GetHintsRequest*>(&from));
}

void GetHintsRequest::MergeFrom(const GetHintsRequest& from)
{
    GetHintsRequest* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:optimization_guide.proto.GetHintsRequest)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.hosts_.MergeFrom(from._impl_.hosts_);
    _this->_impl_.supported_optimizations_.MergeFrom(from._impl_.supported_optimizations_);
    _this->_impl_.urls_.MergeFrom(from._impl_.urls_);
    _this->_impl_.supported_key_representations_.MergeFrom(from._impl_.supported_key_representations_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_locale(from._internal_locale());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_mutable_hashed_hosts()->::optimization_guide::proto::HashedHostInfos::MergeFrom(from._internal_hashed_hosts());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_mutable_origin_info()->::optimization_guide::proto::OriginInfo::MergeFrom(from._internal_origin_info());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_mutable_context_metadata()->::optimization_guide::proto::RequestContextMetadata::MergeFrom(from._internal_context_metadata());
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_impl_.context_ = from._impl_.context_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GetHintsRequest::CopyFrom(const GetHintsRequest& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:optimization_guide.proto.GetHintsRequest)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool GetHintsRequest::IsInitialized() const
{
    return true;
}

void GetHintsRequest::InternalSwap(GetHintsRequest* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.hosts_.InternalSwap(&other->_impl_.hosts_);
    _impl_.supported_optimizations_.InternalSwap(&other->_impl_.supported_optimizations_);
    _impl_.urls_.InternalSwap(&other->_impl_.urls_);
    _impl_.supported_key_representations_.InternalSwap(&other->_impl_.supported_key_representations_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.locale_, lhs_arena, &other->_impl_.locale_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(GetHintsRequest, _impl_.context_) + sizeof(GetHintsRequest::_impl_.context_)
        - PROTOBUF_FIELD_OFFSET(GetHintsRequest, _impl_.hashed_hosts_)>(
        reinterpret_cast<char*>(&_impl_.hashed_hosts_), reinterpret_cast<char*>(&other->_impl_.hashed_hosts_));
}

std::string GetHintsRequest::GetTypeName() const
{
    return "optimization_guide.proto.GetHintsRequest";
}

// ===================================================================

class RequestContextMetadata::_Internal {
public:
    static const ::optimization_guide::proto::PageInsightsHubRequestContextMetadata& page_insights_hub_metadata(const RequestContextMetadata* msg);
};

const ::optimization_guide::proto::PageInsightsHubRequestContextMetadata& RequestContextMetadata::_Internal::page_insights_hub_metadata(
    const RequestContextMetadata* msg)
{
    return *msg->_impl_.metadata_.page_insights_hub_metadata_;
}
void RequestContextMetadata::set_allocated_page_insights_hub_metadata(
    ::optimization_guide::proto::PageInsightsHubRequestContextMetadata* page_insights_hub_metadata)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_metadata();
    if (page_insights_hub_metadata) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(page_insights_hub_metadata);
        if (message_arena != submessage_arena) {
            page_insights_hub_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, page_insights_hub_metadata, submessage_arena);
        }
        set_has_page_insights_hub_metadata();
        _impl_.metadata_.page_insights_hub_metadata_ = page_insights_hub_metadata;
    }
    // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.RequestContextMetadata.page_insights_hub_metadata)
}
RequestContextMetadata::RequestContextMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:optimization_guide.proto.RequestContextMetadata)
}
RequestContextMetadata::RequestContextMetadata(const RequestContextMetadata& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    RequestContextMetadata* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.metadata_) {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_._oneof_case_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    clear_has_metadata();
    switch (from.metadata_case()) {
    case kPageInsightsHubMetadata: {
        _this->_internal_mutable_page_insights_hub_metadata()->::optimization_guide::proto::PageInsightsHubRequestContextMetadata::MergeFrom(
            from._internal_page_insights_hub_metadata());
        break;
    }
    case METADATA_NOT_SET: {
        break;
    }
    }
    // @@protoc_insertion_point(copy_constructor:optimization_guide.proto.RequestContextMetadata)
}

inline void RequestContextMetadata::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.metadata_) {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_._oneof_case_)*/ {} };
    clear_has_metadata();
}

RequestContextMetadata::~RequestContextMetadata()
{
    // @@protoc_insertion_point(destructor:optimization_guide.proto.RequestContextMetadata)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void RequestContextMetadata::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (has_metadata()) {
        clear_metadata();
    }
}

void RequestContextMetadata::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void RequestContextMetadata::clear_metadata()
{
    // @@protoc_insertion_point(one_of_clear_start:optimization_guide.proto.RequestContextMetadata)
    switch (metadata_case()) {
    case kPageInsightsHubMetadata: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.metadata_.page_insights_hub_metadata_;
        }
        break;
    }
    case METADATA_NOT_SET: {
        break;
    }
    }
    _impl_._oneof_case_[0] = METADATA_NOT_SET;
}

void RequestContextMetadata::Clear()
{
    // @@protoc_insertion_point(message_clear_start:optimization_guide.proto.RequestContextMetadata)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    clear_metadata();
    _internal_metadata_.Clear<std::string>();
}

const char* RequestContextMetadata::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // .optimization_guide.proto.PageInsightsHubRequestContextMetadata page_insights_hub_metadata = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_page_insights_hub_metadata(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* RequestContextMetadata::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:optimization_guide.proto.RequestContextMetadata)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // .optimization_guide.proto.PageInsightsHubRequestContextMetadata page_insights_hub_metadata = 1;
    if (_internal_has_page_insights_hub_metadata()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::page_insights_hub_metadata(this), _Internal::page_insights_hub_metadata(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:optimization_guide.proto.RequestContextMetadata)
    return target;
}

size_t RequestContextMetadata::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:optimization_guide.proto.RequestContextMetadata)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    switch (metadata_case()) {
    // .optimization_guide.proto.PageInsightsHubRequestContextMetadata page_insights_hub_metadata = 1;
    case kPageInsightsHubMetadata: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.metadata_.page_insights_hub_metadata_);
        break;
    }
    case METADATA_NOT_SET: {
        break;
    }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void RequestContextMetadata::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const RequestContextMetadata*>(&from));
}

void RequestContextMetadata::MergeFrom(const RequestContextMetadata& from)
{
    RequestContextMetadata* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:optimization_guide.proto.RequestContextMetadata)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    switch (from.metadata_case()) {
    case kPageInsightsHubMetadata: {
        _this->_internal_mutable_page_insights_hub_metadata()->::optimization_guide::proto::PageInsightsHubRequestContextMetadata::MergeFrom(
            from._internal_page_insights_hub_metadata());
        break;
    }
    case METADATA_NOT_SET: {
        break;
    }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RequestContextMetadata::CopyFrom(const RequestContextMetadata& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:optimization_guide.proto.RequestContextMetadata)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool RequestContextMetadata::IsInitialized() const
{
    return true;
}

void RequestContextMetadata::InternalSwap(RequestContextMetadata* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_.metadata_, other->_impl_.metadata_);
    swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

std::string RequestContextMetadata::GetTypeName() const
{
    return "optimization_guide.proto.RequestContextMetadata";
}

// ===================================================================

class PageInsightsHubRequestContextMetadata::_Internal {
public:
    using HasBits = decltype(std::declval<PageInsightsHubRequestContextMetadata>()._impl_._has_bits_);
    static void set_has_is_user_initiated(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_is_initial_page(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_should_not_log_or_personalize(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_navigation_timestamp_ms(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

PageInsightsHubRequestContextMetadata::PageInsightsHubRequestContextMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:optimization_guide.proto.PageInsightsHubRequestContextMetadata)
}
PageInsightsHubRequestContextMetadata::PageInsightsHubRequestContextMetadata(const PageInsightsHubRequestContextMetadata& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    PageInsightsHubRequestContextMetadata* const _this = this;
    (void)_this;
    new (&_impl_)
        Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.navigation_timestamp_ms_) {},
            decltype(_impl_.is_user_initiated_) {}, decltype(_impl_.is_initial_page_) {}, decltype(_impl_.should_not_log_or_personalize_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.navigation_timestamp_ms_, &from._impl_.navigation_timestamp_ms_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.should_not_log_or_personalize_) - reinterpret_cast<char*>(&_impl_.navigation_timestamp_ms_))
            + sizeof(_impl_.should_not_log_or_personalize_));
    // @@protoc_insertion_point(copy_constructor:optimization_guide.proto.PageInsightsHubRequestContextMetadata)
}

inline void PageInsightsHubRequestContextMetadata::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.navigation_timestamp_ms_) { int64_t { 0 } },
        decltype(_impl_.is_user_initiated_) { false }, decltype(_impl_.is_initial_page_) { false }, decltype(_impl_.should_not_log_or_personalize_) { false } };
}

PageInsightsHubRequestContextMetadata::~PageInsightsHubRequestContextMetadata()
{
    // @@protoc_insertion_point(destructor:optimization_guide.proto.PageInsightsHubRequestContextMetadata)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void PageInsightsHubRequestContextMetadata::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PageInsightsHubRequestContextMetadata::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void PageInsightsHubRequestContextMetadata::Clear()
{
    // @@protoc_insertion_point(message_clear_start:optimization_guide.proto.PageInsightsHubRequestContextMetadata)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        ::memset(&_impl_.navigation_timestamp_ms_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.should_not_log_or_personalize_) - reinterpret_cast<char*>(&_impl_.navigation_timestamp_ms_))
                + sizeof(_impl_.should_not_log_or_personalize_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* PageInsightsHubRequestContextMetadata::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional bool is_user_initiated = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_is_user_initiated(&has_bits);
                _impl_.is_user_initiated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool is_initial_page = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_is_initial_page(&has_bits);
                _impl_.is_initial_page_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool should_not_log_or_personalize = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_should_not_log_or_personalize(&has_bits);
                _impl_.should_not_log_or_personalize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 navigation_timestamp_ms = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _Internal::set_has_navigation_timestamp_ms(&has_bits);
                _impl_.navigation_timestamp_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* PageInsightsHubRequestContextMetadata::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:optimization_guide.proto.PageInsightsHubRequestContextMetadata)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional bool is_user_initiated = 1;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_is_user_initiated(), target);
    }

    // optional bool is_initial_page = 2;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_is_initial_page(), target);
    }

    // optional bool should_not_log_or_personalize = 3;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_should_not_log_or_personalize(), target);
    }

    // optional int64 navigation_timestamp_ms = 4;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_navigation_timestamp_ms(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:optimization_guide.proto.PageInsightsHubRequestContextMetadata)
    return target;
}

size_t PageInsightsHubRequestContextMetadata::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:optimization_guide.proto.PageInsightsHubRequestContextMetadata)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        // optional int64 navigation_timestamp_ms = 4;
        if (cached_has_bits & 0x00000001u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_navigation_timestamp_ms());
        }

        // optional bool is_user_initiated = 1;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + 1;
        }

        // optional bool is_initial_page = 2;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + 1;
        }

        // optional bool should_not_log_or_personalize = 3;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + 1;
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void PageInsightsHubRequestContextMetadata::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const PageInsightsHubRequestContextMetadata*>(&from));
}

void PageInsightsHubRequestContextMetadata::MergeFrom(const PageInsightsHubRequestContextMetadata& from)
{
    PageInsightsHubRequestContextMetadata* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:optimization_guide.proto.PageInsightsHubRequestContextMetadata)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_impl_.navigation_timestamp_ms_ = from._impl_.navigation_timestamp_ms_;
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.is_user_initiated_ = from._impl_.is_user_initiated_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.is_initial_page_ = from._impl_.is_initial_page_;
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.should_not_log_or_personalize_ = from._impl_.should_not_log_or_personalize_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PageInsightsHubRequestContextMetadata::CopyFrom(const PageInsightsHubRequestContextMetadata& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:optimization_guide.proto.PageInsightsHubRequestContextMetadata)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool PageInsightsHubRequestContextMetadata::IsInitialized() const
{
    return true;
}

void PageInsightsHubRequestContextMetadata::InternalSwap(PageInsightsHubRequestContextMetadata* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(PageInsightsHubRequestContextMetadata, _impl_.should_not_log_or_personalize_)
        + sizeof(PageInsightsHubRequestContextMetadata::_impl_.should_not_log_or_personalize_)
        - PROTOBUF_FIELD_OFFSET(PageInsightsHubRequestContextMetadata, _impl_.navigation_timestamp_ms_)>(
        reinterpret_cast<char*>(&_impl_.navigation_timestamp_ms_), reinterpret_cast<char*>(&other->_impl_.navigation_timestamp_ms_));
}

std::string PageInsightsHubRequestContextMetadata::GetTypeName() const
{
    return "optimization_guide.proto.PageInsightsHubRequestContextMetadata";
}

// ===================================================================

class GetHintsResponse::_Internal {
public:
    using HasBits = decltype(std::declval<GetHintsResponse>()._impl_._has_bits_);
    static const ::optimization_guide::proto::Duration& max_cache_duration(const GetHintsResponse* msg);
    static void set_has_max_cache_duration(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

const ::optimization_guide::proto::Duration& GetHintsResponse::_Internal::max_cache_duration(const GetHintsResponse* msg)
{
    return *msg->_impl_.max_cache_duration_;
}
void GetHintsResponse::clear_max_cache_duration()
{
    if (_impl_.max_cache_duration_ != nullptr)
        _impl_.max_cache_duration_->Clear();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
GetHintsResponse::GetHintsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:optimization_guide.proto.GetHintsResponse)
}
GetHintsResponse::GetHintsResponse(const GetHintsResponse& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    GetHintsResponse* const _this = this;
    (void)_this;
    new (&_impl_)
        Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.hints_) { from._impl_.hints_ },
            decltype(_impl_.hints_to_remove_) { from._impl_.hints_to_remove_ }, decltype(_impl_.max_cache_duration_) { nullptr } };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_max_cache_duration()) {
        _this->_impl_.max_cache_duration_ = new ::optimization_guide::proto::Duration(*from._impl_.max_cache_duration_);
    }
    // @@protoc_insertion_point(copy_constructor:optimization_guide.proto.GetHintsResponse)
}

inline void GetHintsResponse::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.hints_) { arena },
        decltype(_impl_.hints_to_remove_) { arena }, decltype(_impl_.max_cache_duration_) { nullptr } };
}

GetHintsResponse::~GetHintsResponse()
{
    // @@protoc_insertion_point(destructor:optimization_guide.proto.GetHintsResponse)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void GetHintsResponse::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.hints_.~RepeatedPtrField();
    _impl_.hints_to_remove_.~RepeatedPtrField();
    if (this != internal_default_instance())
        delete _impl_.max_cache_duration_;
}

void GetHintsResponse::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void GetHintsResponse::Clear()
{
    // @@protoc_insertion_point(message_clear_start:optimization_guide.proto.GetHintsResponse)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.hints_.Clear();
    _impl_.hints_to_remove_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        GOOGLE_DCHECK(_impl_.max_cache_duration_ != nullptr);
        _impl_.max_cache_duration_->Clear();
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* GetHintsResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .optimization_guide.proto.Hint hints = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_hints(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional .optimization_guide.proto.Duration max_cache_duration = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_max_cache_duration(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .optimization_guide.proto.MatchedHintInfo hints_to_remove = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_hints_to_remove(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* GetHintsResponse::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:optimization_guide.proto.GetHintsResponse)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .optimization_guide.proto.Hint hints = 1;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_hints_size()); i < n; i++) {
        const auto& repfield = this->_internal_hints(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
    }

    cached_has_bits = _impl_._has_bits_[0];
    // optional .optimization_guide.proto.Duration max_cache_duration = 2;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::max_cache_duration(this), _Internal::max_cache_duration(this).GetCachedSize(), target, stream);
    }

    // repeated .optimization_guide.proto.MatchedHintInfo hints_to_remove = 3;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_hints_to_remove_size()); i < n; i++) {
        const auto& repfield = this->_internal_hints_to_remove(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:optimization_guide.proto.GetHintsResponse)
    return target;
}

size_t GetHintsResponse::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:optimization_guide.proto.GetHintsResponse)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .optimization_guide.proto.Hint hints = 1;
    total_size += 1UL * this->_internal_hints_size();
    for (const auto& msg : this->_impl_.hints_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // repeated .optimization_guide.proto.MatchedHintInfo hints_to_remove = 3;
    total_size += 1UL * this->_internal_hints_to_remove_size();
    for (const auto& msg : this->_impl_.hints_to_remove_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // optional .optimization_guide.proto.Duration max_cache_duration = 2;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.max_cache_duration_);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void GetHintsResponse::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const GetHintsResponse*>(&from));
}

void GetHintsResponse::MergeFrom(const GetHintsResponse& from)
{
    GetHintsResponse* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:optimization_guide.proto.GetHintsResponse)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.hints_.MergeFrom(from._impl_.hints_);
    _this->_impl_.hints_to_remove_.MergeFrom(from._impl_.hints_to_remove_);
    if (from._internal_has_max_cache_duration()) {
        _this->_internal_mutable_max_cache_duration()->::optimization_guide::proto::Duration::MergeFrom(from._internal_max_cache_duration());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GetHintsResponse::CopyFrom(const GetHintsResponse& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:optimization_guide.proto.GetHintsResponse)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool GetHintsResponse::IsInitialized() const
{
    return true;
}

void GetHintsResponse::InternalSwap(GetHintsResponse* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.hints_.InternalSwap(&other->_impl_.hints_);
    _impl_.hints_to_remove_.InternalSwap(&other->_impl_.hints_to_remove_);
    swap(_impl_.max_cache_duration_, other->_impl_.max_cache_duration_);
}

std::string GetHintsResponse::GetTypeName() const
{
    return "optimization_guide.proto.GetHintsResponse";
}

// ===================================================================

class Optimization::_Internal {
public:
    using HasBits = decltype(std::declval<Optimization>()._impl_._has_bits_);
    static void set_has_optimization_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_tuning_version(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static const ::optimization_guide::proto::LoadingPredictorMetadata& loading_predictor_metadata(const Optimization* msg);
    static const ::optimization_guide::proto::Any& any_metadata(const Optimization* msg);
};

const ::optimization_guide::proto::LoadingPredictorMetadata& Optimization::_Internal::loading_predictor_metadata(const Optimization* msg)
{
    return *msg->_impl_.metadata_.loading_predictor_metadata_;
}
const ::optimization_guide::proto::Any& Optimization::_Internal::any_metadata(const Optimization* msg)
{
    return *msg->_impl_.metadata_.any_metadata_;
}
void Optimization::set_allocated_loading_predictor_metadata(::optimization_guide::proto::LoadingPredictorMetadata* loading_predictor_metadata)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_metadata();
    if (loading_predictor_metadata) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena
            = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(loading_predictor_metadata));
        if (message_arena != submessage_arena) {
            loading_predictor_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, loading_predictor_metadata, submessage_arena);
        }
        set_has_loading_predictor_metadata();
        _impl_.metadata_.loading_predictor_metadata_ = loading_predictor_metadata;
    }
    // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.Optimization.loading_predictor_metadata)
}
void Optimization::clear_loading_predictor_metadata()
{
    if (_internal_has_loading_predictor_metadata()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.metadata_.loading_predictor_metadata_;
        }
        clear_has_metadata();
    }
}
void Optimization::set_allocated_any_metadata(::optimization_guide::proto::Any* any_metadata)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_metadata();
    if (any_metadata) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena
            = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(any_metadata));
        if (message_arena != submessage_arena) {
            any_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, any_metadata, submessage_arena);
        }
        set_has_any_metadata();
        _impl_.metadata_.any_metadata_ = any_metadata;
    }
    // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.Optimization.any_metadata)
}
void Optimization::clear_any_metadata()
{
    if (_internal_has_any_metadata()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.metadata_.any_metadata_;
        }
        clear_has_metadata();
    }
}
Optimization::Optimization(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:optimization_guide.proto.Optimization)
}
Optimization::Optimization(const Optimization& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    Optimization* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.tuning_version_) {},
        decltype(_impl_.optimization_type_) {}, decltype(_impl_.metadata_) {}, /*decltype(_impl_._oneof_case_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.tuning_version_, &from._impl_.tuning_version_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.optimization_type_) - reinterpret_cast<char*>(&_impl_.tuning_version_))
            + sizeof(_impl_.optimization_type_));
    clear_has_metadata();
    switch (from.metadata_case()) {
    case kLoadingPredictorMetadata: {
        _this->_internal_mutable_loading_predictor_metadata()->::optimization_guide::proto::LoadingPredictorMetadata::MergeFrom(
            from._internal_loading_predictor_metadata());
        break;
    }
    case kAnyMetadata: {
        _this->_internal_mutable_any_metadata()->::optimization_guide::proto::Any::MergeFrom(from._internal_any_metadata());
        break;
    }
    case METADATA_NOT_SET: {
        break;
    }
    }
    // @@protoc_insertion_point(copy_constructor:optimization_guide.proto.Optimization)
}

inline void Optimization::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.tuning_version_) { uint64_t { 0u } },
        decltype(_impl_.optimization_type_) { 0 }, decltype(_impl_.metadata_) {}, /*decltype(_impl_._oneof_case_)*/ {} };
    clear_has_metadata();
}

Optimization::~Optimization()
{
    // @@protoc_insertion_point(destructor:optimization_guide.proto.Optimization)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void Optimization::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (has_metadata()) {
        clear_metadata();
    }
}

void Optimization::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void Optimization::clear_metadata()
{
    // @@protoc_insertion_point(one_of_clear_start:optimization_guide.proto.Optimization)
    switch (metadata_case()) {
    case kLoadingPredictorMetadata: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.metadata_.loading_predictor_metadata_;
        }
        break;
    }
    case kAnyMetadata: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.metadata_.any_metadata_;
        }
        break;
    }
    case METADATA_NOT_SET: {
        break;
    }
    }
    _impl_._oneof_case_[0] = METADATA_NOT_SET;
}

void Optimization::Clear()
{
    // @@protoc_insertion_point(message_clear_start:optimization_guide.proto.Optimization)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        ::memset(&_impl_.tuning_version_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.optimization_type_) - reinterpret_cast<char*>(&_impl_.tuning_version_))
                + sizeof(_impl_.optimization_type_));
    }
    clear_metadata();
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* Optimization::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .optimization_guide.proto.OptimizationType optimization_type = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::optimization_guide::proto::OptimizationType_IsValid(val))) {
                    _internal_set_optimization_type(static_cast<::optimization_guide::proto::OptimizationType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional uint64 tuning_version = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
                _Internal::set_has_tuning_version(&has_bits);
                _impl_.tuning_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .optimization_guide.proto.LoadingPredictorMetadata loading_predictor_metadata = 13;
        case 13:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
                ptr = ctx->ParseMessage(_internal_mutable_loading_predictor_metadata(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .optimization_guide.proto.Any any_metadata = 15;
        case 15:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
                ptr = ctx->ParseMessage(_internal_mutable_any_metadata(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* Optimization::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:optimization_guide.proto.Optimization)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .optimization_guide.proto.OptimizationType optimization_type = 1;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(1, this->_internal_optimization_type(), target);
    }

    // optional uint64 tuning_version = 6;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt64ToArray(6, this->_internal_tuning_version(), target);
    }

    switch (metadata_case()) {
    case kLoadingPredictorMetadata: {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            13, _Internal::loading_predictor_metadata(this), _Internal::loading_predictor_metadata(this).GetCachedSize(), target, stream);
        break;
    }
    case kAnyMetadata: {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            15, _Internal::any_metadata(this), _Internal::any_metadata(this).GetCachedSize(), target, stream);
        break;
    }
    default:;
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:optimization_guide.proto.Optimization)
    return target;
}

size_t Optimization::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:optimization_guide.proto.Optimization)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional uint64 tuning_version = 6;
        if (cached_has_bits & 0x00000001u) {
            total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_tuning_version());
        }

        // optional .optimization_guide.proto.OptimizationType optimization_type = 1;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_optimization_type());
        }
    }
    switch (metadata_case()) {
    // .optimization_guide.proto.LoadingPredictorMetadata loading_predictor_metadata = 13;
    case kLoadingPredictorMetadata: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.metadata_.loading_predictor_metadata_);
        break;
    }
    // .optimization_guide.proto.Any any_metadata = 15;
    case kAnyMetadata: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.metadata_.any_metadata_);
        break;
    }
    case METADATA_NOT_SET: {
        break;
    }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void Optimization::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const Optimization*>(&from));
}

void Optimization::MergeFrom(const Optimization& from)
{
    Optimization* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:optimization_guide.proto.Optimization)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_impl_.tuning_version_ = from._impl_.tuning_version_;
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.optimization_type_ = from._impl_.optimization_type_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    switch (from.metadata_case()) {
    case kLoadingPredictorMetadata: {
        _this->_internal_mutable_loading_predictor_metadata()->::optimization_guide::proto::LoadingPredictorMetadata::MergeFrom(
            from._internal_loading_predictor_metadata());
        break;
    }
    case kAnyMetadata: {
        _this->_internal_mutable_any_metadata()->::optimization_guide::proto::Any::MergeFrom(from._internal_any_metadata());
        break;
    }
    case METADATA_NOT_SET: {
        break;
    }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Optimization::CopyFrom(const Optimization& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:optimization_guide.proto.Optimization)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool Optimization::IsInitialized() const
{
    return true;
}

void Optimization::InternalSwap(Optimization* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(Optimization, _impl_.optimization_type_) + sizeof(Optimization::_impl_.optimization_type_)
        - PROTOBUF_FIELD_OFFSET(Optimization, _impl_.tuning_version_)>(
        reinterpret_cast<char*>(&_impl_.tuning_version_), reinterpret_cast<char*>(&other->_impl_.tuning_version_));
    swap(_impl_.metadata_, other->_impl_.metadata_);
    swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

std::string Optimization::GetTypeName() const
{
    return "optimization_guide.proto.Optimization";
}

// ===================================================================

class PageHint::_Internal {
public:
    using HasBits = decltype(std::declval<PageHint>()._impl_._has_bits_);
    static void set_has_page_pattern(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

PageHint::PageHint(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:optimization_guide.proto.PageHint)
}
PageHint::PageHint(const PageHint& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    PageHint* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.allowlisted_optimizations_) { from._impl_.allowlisted_optimizations_ }, decltype(_impl_.page_pattern_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.page_pattern_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.page_pattern_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_page_pattern()) {
        _this->_impl_.page_pattern_.Set(from._internal_page_pattern(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:optimization_guide.proto.PageHint)
}

inline void PageHint::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.allowlisted_optimizations_) { arena },
        decltype(_impl_.page_pattern_) {} };
    _impl_.page_pattern_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.page_pattern_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PageHint::~PageHint()
{
    // @@protoc_insertion_point(destructor:optimization_guide.proto.PageHint)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void PageHint::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.allowlisted_optimizations_.~RepeatedPtrField();
    _impl_.page_pattern_.Destroy();
}

void PageHint::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void PageHint::Clear()
{
    // @@protoc_insertion_point(message_clear_start:optimization_guide.proto.PageHint)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.allowlisted_optimizations_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.page_pattern_.ClearNonDefaultToEmpty();
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* PageHint::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string page_pattern = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_page_pattern();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .optimization_guide.proto.Optimization allowlisted_optimizations = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_allowlisted_optimizations(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* PageHint::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:optimization_guide.proto.PageHint)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string page_pattern = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_page_pattern(), target);
    }

    // repeated .optimization_guide.proto.Optimization allowlisted_optimizations = 3;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_allowlisted_optimizations_size()); i < n; i++) {
        const auto& repfield = this->_internal_allowlisted_optimizations(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:optimization_guide.proto.PageHint)
    return target;
}

size_t PageHint::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:optimization_guide.proto.PageHint)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .optimization_guide.proto.Optimization allowlisted_optimizations = 3;
    total_size += 1UL * this->_internal_allowlisted_optimizations_size();
    for (const auto& msg : this->_impl_.allowlisted_optimizations_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // optional string page_pattern = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_page_pattern());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void PageHint::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const PageHint*>(&from));
}

void PageHint::MergeFrom(const PageHint& from)
{
    PageHint* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:optimization_guide.proto.PageHint)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.allowlisted_optimizations_.MergeFrom(from._impl_.allowlisted_optimizations_);
    if (from._internal_has_page_pattern()) {
        _this->_internal_set_page_pattern(from._internal_page_pattern());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PageHint::CopyFrom(const PageHint& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:optimization_guide.proto.PageHint)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool PageHint::IsInitialized() const
{
    return true;
}

void PageHint::InternalSwap(PageHint* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.allowlisted_optimizations_.InternalSwap(&other->_impl_.allowlisted_optimizations_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.page_pattern_, lhs_arena, &other->_impl_.page_pattern_, rhs_arena);
}

std::string PageHint::GetTypeName() const
{
    return "optimization_guide.proto.PageHint";
}

// ===================================================================

class Hint::_Internal {
public:
    using HasBits = decltype(std::declval<Hint>()._impl_._has_bits_);
    static void set_has_key_representation(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_key(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_version(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static const ::optimization_guide::proto::Duration& max_cache_duration(const Hint* msg);
    static void set_has_max_cache_duration(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
};

const ::optimization_guide::proto::Duration& Hint::_Internal::max_cache_duration(const Hint* msg)
{
    return *msg->_impl_.max_cache_duration_;
}
void Hint::clear_max_cache_duration()
{
    if (_impl_.max_cache_duration_ != nullptr)
        _impl_.max_cache_duration_->Clear();
    _impl_._has_bits_[0] &= ~0x00000004u;
}
Hint::Hint(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:optimization_guide.proto.Hint)
}
Hint::Hint(const Hint& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    Hint* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.allowlisted_optimizations_) { from._impl_.allowlisted_optimizations_ }, decltype(_impl_.page_hints_) { from._impl_.page_hints_ },
        decltype(_impl_.key_) {}, decltype(_impl_.version_) {}, decltype(_impl_.max_cache_duration_) { nullptr }, decltype(_impl_.key_representation_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.key_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_key()) {
        _this->_impl_.key_.Set(from._internal_key(), _this->GetArenaForAllocation());
    }
    _impl_.version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_version()) {
        _this->_impl_.version_.Set(from._internal_version(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_max_cache_duration()) {
        _this->_impl_.max_cache_duration_ = new ::optimization_guide::proto::Duration(*from._impl_.max_cache_duration_);
    }
    _this->_impl_.key_representation_ = from._impl_.key_representation_;
    // @@protoc_insertion_point(copy_constructor:optimization_guide.proto.Hint)
}

inline void Hint::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.allowlisted_optimizations_) { arena },
        decltype(_impl_.page_hints_) { arena }, decltype(_impl_.key_) {}, decltype(_impl_.version_) {}, decltype(_impl_.max_cache_duration_) { nullptr },
        decltype(_impl_.key_representation_) { 0 } };
    _impl_.key_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Hint::~Hint()
{
    // @@protoc_insertion_point(destructor:optimization_guide.proto.Hint)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void Hint::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.allowlisted_optimizations_.~RepeatedPtrField();
    _impl_.page_hints_.~RepeatedPtrField();
    _impl_.key_.Destroy();
    _impl_.version_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.max_cache_duration_;
}

void Hint::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void Hint::Clear()
{
    // @@protoc_insertion_point(message_clear_start:optimization_guide.proto.Hint)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.allowlisted_optimizations_.Clear();
    _impl_.page_hints_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.key_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.version_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            GOOGLE_DCHECK(_impl_.max_cache_duration_ != nullptr);
            _impl_.max_cache_duration_->Clear();
        }
    }
    _impl_.key_representation_ = 0;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* Hint::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .optimization_guide.proto.KeyRepresentation key_representation = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::optimization_guide::proto::KeyRepresentation_IsValid(val))) {
                    _internal_set_key_representation(static_cast<::optimization_guide::proto::KeyRepresentation>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional string key = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_key();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .optimization_guide.proto.Optimization allowlisted_optimizations = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_allowlisted_optimizations(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
            } else
                goto handle_unusual;
            continue;
        // repeated .optimization_guide.proto.PageHint page_hints = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_page_hints(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional string version = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                auto str = _internal_mutable_version();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .optimization_guide.proto.Duration max_cache_duration = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
                ptr = ctx->ParseMessage(_internal_mutable_max_cache_duration(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* Hint::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:optimization_guide.proto.Hint)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .optimization_guide.proto.KeyRepresentation key_representation = 1;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(1, this->_internal_key_representation(), target);
    }

    // optional string key = 2;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_key(), target);
    }

    // repeated .optimization_guide.proto.Optimization allowlisted_optimizations = 3;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_allowlisted_optimizations_size()); i < n; i++) {
        const auto& repfield = this->_internal_allowlisted_optimizations(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
    }

    // repeated .optimization_guide.proto.PageHint page_hints = 4;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_page_hints_size()); i < n; i++) {
        const auto& repfield = this->_internal_page_hints(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
    }

    // optional string version = 5;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(5, this->_internal_version(), target);
    }

    // optional .optimization_guide.proto.Duration max_cache_duration = 6;
    if (cached_has_bits & 0x00000004u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            6, _Internal::max_cache_duration(this), _Internal::max_cache_duration(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:optimization_guide.proto.Hint)
    return target;
}

size_t Hint::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:optimization_guide.proto.Hint)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .optimization_guide.proto.Optimization allowlisted_optimizations = 3;
    total_size += 1UL * this->_internal_allowlisted_optimizations_size();
    for (const auto& msg : this->_impl_.allowlisted_optimizations_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // repeated .optimization_guide.proto.PageHint page_hints = 4;
    total_size += 1UL * this->_internal_page_hints_size();
    for (const auto& msg : this->_impl_.page_hints_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        // optional string key = 2;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_key());
        }

        // optional string version = 5;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_version());
        }

        // optional .optimization_guide.proto.Duration max_cache_duration = 6;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.max_cache_duration_);
        }

        // optional .optimization_guide.proto.KeyRepresentation key_representation = 1;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_key_representation());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void Hint::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const Hint*>(&from));
}

void Hint::MergeFrom(const Hint& from)
{
    Hint* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:optimization_guide.proto.Hint)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.allowlisted_optimizations_.MergeFrom(from._impl_.allowlisted_optimizations_);
    _this->_impl_.page_hints_.MergeFrom(from._impl_.page_hints_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_key(from._internal_key());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_version(from._internal_version());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_mutable_max_cache_duration()->::optimization_guide::proto::Duration::MergeFrom(from._internal_max_cache_duration());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.key_representation_ = from._impl_.key_representation_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Hint::CopyFrom(const Hint& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:optimization_guide.proto.Hint)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool Hint::IsInitialized() const
{
    return true;
}

void Hint::InternalSwap(Hint* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.allowlisted_optimizations_.InternalSwap(&other->_impl_.allowlisted_optimizations_);
    _impl_.page_hints_.InternalSwap(&other->_impl_.page_hints_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.key_, lhs_arena, &other->_impl_.key_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.version_, lhs_arena, &other->_impl_.version_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(Hint, _impl_.key_representation_) + sizeof(Hint::_impl_.key_representation_)
        - PROTOBUF_FIELD_OFFSET(Hint, _impl_.max_cache_duration_)>(
        reinterpret_cast<char*>(&_impl_.max_cache_duration_), reinterpret_cast<char*>(&other->_impl_.max_cache_duration_));
}

std::string Hint::GetTypeName() const
{
    return "optimization_guide.proto.Hint";
}

// ===================================================================

class BloomFilter::_Internal {
public:
    using HasBits = decltype(std::declval<BloomFilter>()._impl_._has_bits_);
    static void set_has_num_hash_functions(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_num_bits(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_data(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

BloomFilter::BloomFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:optimization_guide.proto.BloomFilter)
}
BloomFilter::BloomFilter(const BloomFilter& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    BloomFilter* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.data_) {},
        decltype(_impl_.num_hash_functions_) {}, decltype(_impl_.num_bits_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.data_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_data()) {
        _this->_impl_.data_.Set(from._internal_data(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.num_hash_functions_, &from._impl_.num_hash_functions_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.num_bits_) - reinterpret_cast<char*>(&_impl_.num_hash_functions_)) + sizeof(_impl_.num_bits_));
    // @@protoc_insertion_point(copy_constructor:optimization_guide.proto.BloomFilter)
}

inline void BloomFilter::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.data_) {},
        decltype(_impl_.num_hash_functions_) { 0u }, decltype(_impl_.num_bits_) { 0u } };
    _impl_.data_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

BloomFilter::~BloomFilter()
{
    // @@protoc_insertion_point(destructor:optimization_guide.proto.BloomFilter)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void BloomFilter::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.data_.Destroy();
}

void BloomFilter::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void BloomFilter::Clear()
{
    // @@protoc_insertion_point(message_clear_start:optimization_guide.proto.BloomFilter)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.data_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000006u) {
        ::memset(&_impl_.num_hash_functions_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.num_bits_) - reinterpret_cast<char*>(&_impl_.num_hash_functions_)) + sizeof(_impl_.num_bits_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* BloomFilter::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional uint32 num_hash_functions = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_num_hash_functions(&has_bits);
                _impl_.num_hash_functions_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional uint32 num_bits = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_num_bits(&has_bits);
                _impl_.num_bits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bytes data = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_data();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* BloomFilter::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:optimization_guide.proto.BloomFilter)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional uint32 num_hash_functions = 1;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_num_hash_functions(), target);
    }

    // optional uint32 num_bits = 2;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_num_bits(), target);
    }

    // optional bytes data = 3;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteBytesMaybeAliased(3, this->_internal_data(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:optimization_guide.proto.BloomFilter)
    return target;
}

size_t BloomFilter::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:optimization_guide.proto.BloomFilter)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional bytes data = 3;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_data());
        }

        // optional uint32 num_hash_functions = 1;
        if (cached_has_bits & 0x00000002u) {
            total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_num_hash_functions());
        }

        // optional uint32 num_bits = 2;
        if (cached_has_bits & 0x00000004u) {
            total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_num_bits());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void BloomFilter::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const BloomFilter*>(&from));
}

void BloomFilter::MergeFrom(const BloomFilter& from)
{
    BloomFilter* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:optimization_guide.proto.BloomFilter)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_data(from._internal_data());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.num_hash_functions_ = from._impl_.num_hash_functions_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.num_bits_ = from._impl_.num_bits_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BloomFilter::CopyFrom(const BloomFilter& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:optimization_guide.proto.BloomFilter)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool BloomFilter::IsInitialized() const
{
    return true;
}

void BloomFilter::InternalSwap(BloomFilter* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.data_, lhs_arena, &other->_impl_.data_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(BloomFilter, _impl_.num_bits_) + sizeof(BloomFilter::_impl_.num_bits_)
        - PROTOBUF_FIELD_OFFSET(BloomFilter, _impl_.num_hash_functions_)>(
        reinterpret_cast<char*>(&_impl_.num_hash_functions_), reinterpret_cast<char*>(&other->_impl_.num_hash_functions_));
}

std::string BloomFilter::GetTypeName() const
{
    return "optimization_guide.proto.BloomFilter";
}

// ===================================================================

class OptimizationFilter::_Internal {
public:
    using HasBits = decltype(std::declval<OptimizationFilter>()._impl_._has_bits_);
    static void set_has_optimization_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static const ::optimization_guide::proto::BloomFilter& bloom_filter(const OptimizationFilter* msg);
    static void set_has_bloom_filter(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_skip_host_suffix_checking(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_bloom_filter_format(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
};

const ::optimization_guide::proto::BloomFilter& OptimizationFilter::_Internal::bloom_filter(const OptimizationFilter* msg)
{
    return *msg->_impl_.bloom_filter_;
}
OptimizationFilter::OptimizationFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:optimization_guide.proto.OptimizationFilter)
}
OptimizationFilter::OptimizationFilter(const OptimizationFilter& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    OptimizationFilter* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.regexps_) { from._impl_.regexps_ }, decltype(_impl_.exclusion_regexps_) { from._impl_.exclusion_regexps_ },
        decltype(_impl_.bloom_filter_) { nullptr }, decltype(_impl_.optimization_type_) {}, decltype(_impl_.skip_host_suffix_checking_) {},
        decltype(_impl_.bloom_filter_format_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_bloom_filter()) {
        _this->_impl_.bloom_filter_ = new ::optimization_guide::proto::BloomFilter(*from._impl_.bloom_filter_);
    }
    ::memcpy(&_impl_.optimization_type_, &from._impl_.optimization_type_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.bloom_filter_format_) - reinterpret_cast<char*>(&_impl_.optimization_type_))
            + sizeof(_impl_.bloom_filter_format_));
    // @@protoc_insertion_point(copy_constructor:optimization_guide.proto.OptimizationFilter)
}

inline void OptimizationFilter::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.regexps_) { arena },
        decltype(_impl_.exclusion_regexps_) { arena }, decltype(_impl_.bloom_filter_) { nullptr }, decltype(_impl_.optimization_type_) { 0 },
        decltype(_impl_.skip_host_suffix_checking_) { false }, decltype(_impl_.bloom_filter_format_) { 0 } };
}

OptimizationFilter::~OptimizationFilter()
{
    // @@protoc_insertion_point(destructor:optimization_guide.proto.OptimizationFilter)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void OptimizationFilter::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.regexps_.~RepeatedPtrField();
    _impl_.exclusion_regexps_.~RepeatedPtrField();
    if (this != internal_default_instance())
        delete _impl_.bloom_filter_;
}

void OptimizationFilter::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void OptimizationFilter::Clear()
{
    // @@protoc_insertion_point(message_clear_start:optimization_guide.proto.OptimizationFilter)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.regexps_.Clear();
    _impl_.exclusion_regexps_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        GOOGLE_DCHECK(_impl_.bloom_filter_ != nullptr);
        _impl_.bloom_filter_->Clear();
    }
    if (cached_has_bits & 0x0000000eu) {
        ::memset(&_impl_.optimization_type_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.bloom_filter_format_) - reinterpret_cast<char*>(&_impl_.optimization_type_))
                + sizeof(_impl_.bloom_filter_format_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* OptimizationFilter::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .optimization_guide.proto.OptimizationType optimization_type = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::optimization_guide::proto::OptimizationType_IsValid(val))) {
                    _internal_set_optimization_type(static_cast<::optimization_guide::proto::OptimizationType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional .optimization_guide.proto.BloomFilter bloom_filter = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_bloom_filter(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated string regexps = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    auto str = _internal_add_regexps();
                    ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional bool skip_host_suffix_checking = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _Internal::set_has_skip_host_suffix_checking(&has_bits);
                _impl_.skip_host_suffix_checking_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated string exclusion_regexps = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    auto str = _internal_add_exclusion_regexps();
                    ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional .optimization_guide.proto.BloomFilterFormat bloom_filter_format = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::optimization_guide::proto::BloomFilterFormat_IsValid(val))) {
                    _internal_set_bloom_filter_format(static_cast<::optimization_guide::proto::BloomFilterFormat>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* OptimizationFilter::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:optimization_guide.proto.OptimizationFilter)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .optimization_guide.proto.OptimizationType optimization_type = 1;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(1, this->_internal_optimization_type(), target);
    }

    // optional .optimization_guide.proto.BloomFilter bloom_filter = 2;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::bloom_filter(this), _Internal::bloom_filter(this).GetCachedSize(), target, stream);
    }

    // repeated string regexps = 3;
    for (int i = 0, n = this->_internal_regexps_size(); i < n; i++) {
        const auto& s = this->_internal_regexps(i);
        target = stream->WriteString(3, s, target);
    }

    // optional bool skip_host_suffix_checking = 4;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_skip_host_suffix_checking(), target);
    }

    // repeated string exclusion_regexps = 5;
    for (int i = 0, n = this->_internal_exclusion_regexps_size(); i < n; i++) {
        const auto& s = this->_internal_exclusion_regexps(i);
        target = stream->WriteString(5, s, target);
    }

    // optional .optimization_guide.proto.BloomFilterFormat bloom_filter_format = 6;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(6, this->_internal_bloom_filter_format(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:optimization_guide.proto.OptimizationFilter)
    return target;
}

size_t OptimizationFilter::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:optimization_guide.proto.OptimizationFilter)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated string regexps = 3;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.regexps_.size());
    for (int i = 0, n = _impl_.regexps_.size(); i < n; i++) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(_impl_.regexps_.Get(i));
    }

    // repeated string exclusion_regexps = 5;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.exclusion_regexps_.size());
    for (int i = 0, n = _impl_.exclusion_regexps_.size(); i < n; i++) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(_impl_.exclusion_regexps_.Get(i));
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        // optional .optimization_guide.proto.BloomFilter bloom_filter = 2;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.bloom_filter_);
        }

        // optional .optimization_guide.proto.OptimizationType optimization_type = 1;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_optimization_type());
        }

        // optional bool skip_host_suffix_checking = 4;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + 1;
        }

        // optional .optimization_guide.proto.BloomFilterFormat bloom_filter_format = 6;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_bloom_filter_format());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void OptimizationFilter::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const OptimizationFilter*>(&from));
}

void OptimizationFilter::MergeFrom(const OptimizationFilter& from)
{
    OptimizationFilter* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:optimization_guide.proto.OptimizationFilter)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.regexps_.MergeFrom(from._impl_.regexps_);
    _this->_impl_.exclusion_regexps_.MergeFrom(from._impl_.exclusion_regexps_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_mutable_bloom_filter()->::optimization_guide::proto::BloomFilter::MergeFrom(from._internal_bloom_filter());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.optimization_type_ = from._impl_.optimization_type_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.skip_host_suffix_checking_ = from._impl_.skip_host_suffix_checking_;
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.bloom_filter_format_ = from._impl_.bloom_filter_format_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void OptimizationFilter::CopyFrom(const OptimizationFilter& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:optimization_guide.proto.OptimizationFilter)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool OptimizationFilter::IsInitialized() const
{
    return true;
}

void OptimizationFilter::InternalSwap(OptimizationFilter* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.regexps_.InternalSwap(&other->_impl_.regexps_);
    _impl_.exclusion_regexps_.InternalSwap(&other->_impl_.exclusion_regexps_);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(OptimizationFilter, _impl_.bloom_filter_format_)
        + sizeof(OptimizationFilter::_impl_.bloom_filter_format_) - PROTOBUF_FIELD_OFFSET(OptimizationFilter, _impl_.bloom_filter_)>(
        reinterpret_cast<char*>(&_impl_.bloom_filter_), reinterpret_cast<char*>(&other->_impl_.bloom_filter_));
}

std::string OptimizationFilter::GetTypeName() const
{
    return "optimization_guide.proto.OptimizationFilter";
}

// ===================================================================

class Configuration::_Internal {
public:
};

Configuration::Configuration(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:optimization_guide.proto.Configuration)
}
Configuration::Configuration(const Configuration& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    Configuration* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.hints_) { from._impl_.hints_ }, decltype(_impl_.optimization_blocklists_) { from._impl_.optimization_blocklists_ },
        decltype(_impl_.optimization_allowlists_) { from._impl_.optimization_allowlists_ }, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:optimization_guide.proto.Configuration)
}

inline void Configuration::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.hints_) { arena }, decltype(_impl_.optimization_blocklists_) { arena },
        decltype(_impl_.optimization_allowlists_) { arena }, /*decltype(_impl_._cached_size_)*/ {} };
}

Configuration::~Configuration()
{
    // @@protoc_insertion_point(destructor:optimization_guide.proto.Configuration)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void Configuration::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.hints_.~RepeatedPtrField();
    _impl_.optimization_blocklists_.~RepeatedPtrField();
    _impl_.optimization_allowlists_.~RepeatedPtrField();
}

void Configuration::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void Configuration::Clear()
{
    // @@protoc_insertion_point(message_clear_start:optimization_guide.proto.Configuration)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.hints_.Clear();
    _impl_.optimization_blocklists_.Clear();
    _impl_.optimization_allowlists_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* Configuration::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .optimization_guide.proto.Hint hints = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_hints(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        // repeated .optimization_guide.proto.OptimizationFilter optimization_blocklists = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_optimization_blocklists(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
            } else
                goto handle_unusual;
            continue;
        // repeated .optimization_guide.proto.OptimizationFilter optimization_allowlists = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_optimization_allowlists(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* Configuration::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:optimization_guide.proto.Configuration)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .optimization_guide.proto.Hint hints = 1;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_hints_size()); i < n; i++) {
        const auto& repfield = this->_internal_hints(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
    }

    // repeated .optimization_guide.proto.OptimizationFilter optimization_blocklists = 2;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_optimization_blocklists_size()); i < n; i++) {
        const auto& repfield = this->_internal_optimization_blocklists(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
    }

    // repeated .optimization_guide.proto.OptimizationFilter optimization_allowlists = 3;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_optimization_allowlists_size()); i < n; i++) {
        const auto& repfield = this->_internal_optimization_allowlists(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:optimization_guide.proto.Configuration)
    return target;
}

size_t Configuration::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:optimization_guide.proto.Configuration)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .optimization_guide.proto.Hint hints = 1;
    total_size += 1UL * this->_internal_hints_size();
    for (const auto& msg : this->_impl_.hints_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // repeated .optimization_guide.proto.OptimizationFilter optimization_blocklists = 2;
    total_size += 1UL * this->_internal_optimization_blocklists_size();
    for (const auto& msg : this->_impl_.optimization_blocklists_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // repeated .optimization_guide.proto.OptimizationFilter optimization_allowlists = 3;
    total_size += 1UL * this->_internal_optimization_allowlists_size();
    for (const auto& msg : this->_impl_.optimization_allowlists_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void Configuration::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const Configuration*>(&from));
}

void Configuration::MergeFrom(const Configuration& from)
{
    Configuration* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:optimization_guide.proto.Configuration)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.hints_.MergeFrom(from._impl_.hints_);
    _this->_impl_.optimization_blocklists_.MergeFrom(from._impl_.optimization_blocklists_);
    _this->_impl_.optimization_allowlists_.MergeFrom(from._impl_.optimization_allowlists_);
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Configuration::CopyFrom(const Configuration& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:optimization_guide.proto.Configuration)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool Configuration::IsInitialized() const
{
    return true;
}

void Configuration::InternalSwap(Configuration* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.hints_.InternalSwap(&other->_impl_.hints_);
    _impl_.optimization_blocklists_.InternalSwap(&other->_impl_.optimization_blocklists_);
    _impl_.optimization_allowlists_.InternalSwap(&other->_impl_.optimization_allowlists_);
}

std::string Configuration::GetTypeName() const
{
    return "optimization_guide.proto.Configuration";
}

// ===================================================================

class Version::_Internal {
public:
    using HasBits = decltype(std::declval<Version>()._impl_._has_bits_);
    static const ::optimization_guide::proto::Timestamp& generation_timestamp(const Version* msg);
    static void set_has_generation_timestamp(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_hint_source(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

const ::optimization_guide::proto::Timestamp& Version::_Internal::generation_timestamp(const Version* msg)
{
    return *msg->_impl_.generation_timestamp_;
}
void Version::clear_generation_timestamp()
{
    if (_impl_.generation_timestamp_ != nullptr)
        _impl_.generation_timestamp_->Clear();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
Version::Version(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:optimization_guide.proto.Version)
}
Version::Version(const Version& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    Version* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.generation_timestamp_) { nullptr }, decltype(_impl_.hint_source_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_generation_timestamp()) {
        _this->_impl_.generation_timestamp_ = new ::optimization_guide::proto::Timestamp(*from._impl_.generation_timestamp_);
    }
    _this->_impl_.hint_source_ = from._impl_.hint_source_;
    // @@protoc_insertion_point(copy_constructor:optimization_guide.proto.Version)
}

inline void Version::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.generation_timestamp_) { nullptr },
        decltype(_impl_.hint_source_) { 0 } };
}

Version::~Version()
{
    // @@protoc_insertion_point(destructor:optimization_guide.proto.Version)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void Version::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (this != internal_default_instance())
        delete _impl_.generation_timestamp_;
}

void Version::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void Version::Clear()
{
    // @@protoc_insertion_point(message_clear_start:optimization_guide.proto.Version)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        GOOGLE_DCHECK(_impl_.generation_timestamp_ != nullptr);
        _impl_.generation_timestamp_->Clear();
    }
    _impl_.hint_source_ = 0;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* Version::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .optimization_guide.proto.Timestamp generation_timestamp = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_generation_timestamp(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .optimization_guide.proto.HintSource hint_source = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::optimization_guide::proto::HintSource_IsValid(val))) {
                    _internal_set_hint_source(static_cast<::optimization_guide::proto::HintSource>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* Version::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:optimization_guide.proto.Version)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .optimization_guide.proto.Timestamp generation_timestamp = 1;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::generation_timestamp(this), _Internal::generation_timestamp(this).GetCachedSize(), target, stream);
    }

    // optional .optimization_guide.proto.HintSource hint_source = 3;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(3, this->_internal_hint_source(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:optimization_guide.proto.Version)
    return target;
}

size_t Version::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:optimization_guide.proto.Version)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional .optimization_guide.proto.Timestamp generation_timestamp = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.generation_timestamp_);
        }

        // optional .optimization_guide.proto.HintSource hint_source = 3;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_hint_source());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void Version::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const Version*>(&from));
}

void Version::MergeFrom(const Version& from)
{
    Version* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:optimization_guide.proto.Version)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_mutable_generation_timestamp()->::optimization_guide::proto::Timestamp::MergeFrom(from._internal_generation_timestamp());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.hint_source_ = from._impl_.hint_source_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Version::CopyFrom(const Version& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:optimization_guide.proto.Version)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool Version::IsInitialized() const
{
    return true;
}

void Version::InternalSwap(Version* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(Version, _impl_.hint_source_) + sizeof(Version::_impl_.hint_source_)
        - PROTOBUF_FIELD_OFFSET(Version, _impl_.generation_timestamp_)>(
        reinterpret_cast<char*>(&_impl_.generation_timestamp_), reinterpret_cast<char*>(&other->_impl_.generation_timestamp_));
}

std::string Version::GetTypeName() const
{
    return "optimization_guide.proto.Version";
}

// @@protoc_insertion_point(namespace_scope)
} // namespace proto
} // namespace optimization_guide
PROTOBUF_NAMESPACE_OPEN
template <>
PROTOBUF_NOINLINE ::optimization_guide::proto::MatchedHintInfo* Arena::CreateMaybeMessage<::optimization_guide::proto::MatchedHintInfo>(Arena* arena)
{
    return Arena::CreateMessageInternal<::optimization_guide::proto::MatchedHintInfo>(arena);
}
template <> PROTOBUF_NOINLINE ::optimization_guide::proto::HostInfo* Arena::CreateMaybeMessage<::optimization_guide::proto::HostInfo>(Arena* arena)
{
    return Arena::CreateMessageInternal<::optimization_guide::proto::HostInfo>(arena);
}
template <> PROTOBUF_NOINLINE ::optimization_guide::proto::UrlInfo* Arena::CreateMaybeMessage<::optimization_guide::proto::UrlInfo>(Arena* arena)
{
    return Arena::CreateMessageInternal<::optimization_guide::proto::UrlInfo>(arena);
}
template <>
PROTOBUF_NOINLINE ::optimization_guide::proto::HashedHostInfos* Arena::CreateMaybeMessage<::optimization_guide::proto::HashedHostInfos>(Arena* arena)
{
    return Arena::CreateMessageInternal<::optimization_guide::proto::HashedHostInfos>(arena);
}
template <>
PROTOBUF_NOINLINE ::optimization_guide::proto::GetHintsRequest* Arena::CreateMaybeMessage<::optimization_guide::proto::GetHintsRequest>(Arena* arena)
{
    return Arena::CreateMessageInternal<::optimization_guide::proto::GetHintsRequest>(arena);
}
template <>
PROTOBUF_NOINLINE ::optimization_guide::proto::RequestContextMetadata* Arena::CreateMaybeMessage<::optimization_guide::proto::RequestContextMetadata>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<::optimization_guide::proto::RequestContextMetadata>(arena);
}
template <>
PROTOBUF_NOINLINE ::optimization_guide::proto::PageInsightsHubRequestContextMetadata*
Arena::CreateMaybeMessage<::optimization_guide::proto::PageInsightsHubRequestContextMetadata>(Arena* arena)
{
    return Arena::CreateMessageInternal<::optimization_guide::proto::PageInsightsHubRequestContextMetadata>(arena);
}
template <>
PROTOBUF_NOINLINE ::optimization_guide::proto::GetHintsResponse* Arena::CreateMaybeMessage<::optimization_guide::proto::GetHintsResponse>(Arena* arena)
{
    return Arena::CreateMessageInternal<::optimization_guide::proto::GetHintsResponse>(arena);
}
template <> PROTOBUF_NOINLINE ::optimization_guide::proto::Optimization* Arena::CreateMaybeMessage<::optimization_guide::proto::Optimization>(Arena* arena)
{
    return Arena::CreateMessageInternal<::optimization_guide::proto::Optimization>(arena);
}
template <> PROTOBUF_NOINLINE ::optimization_guide::proto::PageHint* Arena::CreateMaybeMessage<::optimization_guide::proto::PageHint>(Arena* arena)
{
    return Arena::CreateMessageInternal<::optimization_guide::proto::PageHint>(arena);
}
template <> PROTOBUF_NOINLINE ::optimization_guide::proto::Hint* Arena::CreateMaybeMessage<::optimization_guide::proto::Hint>(Arena* arena)
{
    return Arena::CreateMessageInternal<::optimization_guide::proto::Hint>(arena);
}
template <> PROTOBUF_NOINLINE ::optimization_guide::proto::BloomFilter* Arena::CreateMaybeMessage<::optimization_guide::proto::BloomFilter>(Arena* arena)
{
    return Arena::CreateMessageInternal<::optimization_guide::proto::BloomFilter>(arena);
}
template <>
PROTOBUF_NOINLINE ::optimization_guide::proto::OptimizationFilter* Arena::CreateMaybeMessage<::optimization_guide::proto::OptimizationFilter>(Arena* arena)
{
    return Arena::CreateMessageInternal<::optimization_guide::proto::OptimizationFilter>(arena);
}
template <> PROTOBUF_NOINLINE ::optimization_guide::proto::Configuration* Arena::CreateMaybeMessage<::optimization_guide::proto::Configuration>(Arena* arena)
{
    return Arena::CreateMessageInternal<::optimization_guide::proto::Configuration>(arena);
}
template <> PROTOBUF_NOINLINE ::optimization_guide::proto::Version* Arena::CreateMaybeMessage<::optimization_guide::proto::Version>(Arena* arena)
{
    return Arena::CreateMessageInternal<::optimization_guide::proto::Version>(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
