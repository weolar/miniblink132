// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/optimization_guide/proto/models.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_components_2foptimization_5fguide_2fproto_2fmodels_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_components_2foptimization_5fguide_2fproto_2fmodels_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h> // IWYU pragma: export
#include <google/protobuf/extension_set.h> // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
#include "components/optimization_guide/proto/common_types.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_components_2foptimization_5fguide_2fproto_2fmodels_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
} // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_components_2foptimization_5fguide_2fproto_2fmodels_2eproto {
    static const uint32_t offsets[];
};
namespace optimization_guide {
namespace proto {
class AdditionalModelFile;
struct AdditionalModelFileDefaultTypeInternal;
extern AdditionalModelFileDefaultTypeInternal _AdditionalModelFile_default_instance_;
class GetModelsRequest;
struct GetModelsRequestDefaultTypeInternal;
extern GetModelsRequestDefaultTypeInternal _GetModelsRequest_default_instance_;
class GetModelsResponse;
struct GetModelsResponseDefaultTypeInternal;
extern GetModelsResponseDefaultTypeInternal _GetModelsResponse_default_instance_;
class Model;
struct ModelDefaultTypeInternal;
extern ModelDefaultTypeInternal _Model_default_instance_;
class ModelCacheKey;
struct ModelCacheKeyDefaultTypeInternal;
extern ModelCacheKeyDefaultTypeInternal _ModelCacheKey_default_instance_;
class ModelInfo;
struct ModelInfoDefaultTypeInternal;
extern ModelInfoDefaultTypeInternal _ModelInfo_default_instance_;
class PredictionModel;
struct PredictionModelDefaultTypeInternal;
extern PredictionModelDefaultTypeInternal _PredictionModel_default_instance_;
} // namespace proto
} // namespace optimization_guide
PROTOBUF_NAMESPACE_OPEN
template <>::optimization_guide::proto::AdditionalModelFile* Arena::CreateMaybeMessage<::optimization_guide::proto::AdditionalModelFile>(Arena*);
template <>::optimization_guide::proto::GetModelsRequest* Arena::CreateMaybeMessage<::optimization_guide::proto::GetModelsRequest>(Arena*);
template <>::optimization_guide::proto::GetModelsResponse* Arena::CreateMaybeMessage<::optimization_guide::proto::GetModelsResponse>(Arena*);
template <>::optimization_guide::proto::Model* Arena::CreateMaybeMessage<::optimization_guide::proto::Model>(Arena*);
template <>::optimization_guide::proto::ModelCacheKey* Arena::CreateMaybeMessage<::optimization_guide::proto::ModelCacheKey>(Arena*);
template <>::optimization_guide::proto::ModelInfo* Arena::CreateMaybeMessage<::optimization_guide::proto::ModelInfo>(Arena*);
template <>::optimization_guide::proto::PredictionModel* Arena::CreateMaybeMessage<::optimization_guide::proto::PredictionModel>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace optimization_guide {
namespace proto {

enum OptimizationTarget : int {
    OPTIMIZATION_TARGET_UNKNOWN = 0,
    OPTIMIZATION_TARGET_PAINFUL_PAGE_LOAD = 1,
    OPTIMIZATION_TARGET_LANGUAGE_DETECTION = 2,
    OPTIMIZATION_TARGET_PAGE_TOPICS = 3,
    OPTIMIZATION_TARGET_SEGMENTATION_NEW_TAB = 4,
    OPTIMIZATION_TARGET_SEGMENTATION_SHARE = 5,
    OPTIMIZATION_TARGET_SEGMENTATION_VOICE = 6,
    OPTIMIZATION_TARGET_MODEL_VALIDATION = 7,
    OPTIMIZATION_TARGET_PAGE_ENTITIES = 8,
    OPTIMIZATION_TARGET_NOTIFICATION_PERMISSION_PREDICTIONS = 9,
    OPTIMIZATION_TARGET_SEGMENTATION_DUMMY = 10,
    OPTIMIZATION_TARGET_SEGMENTATION_CHROME_START_ANDROID = 11,
    OPTIMIZATION_TARGET_SEGMENTATION_QUERY_TILES = 12,
    OPTIMIZATION_TARGET_PAGE_VISIBILITY = 13,
    OPTIMIZATION_TARGET_PAGE_TOPICS_V2 = 15,
    OPTIMIZATION_TARGET_SEGMENTATION_CHROME_LOW_USER_ENGAGEMENT = 16,
    OPTIMIZATION_TARGET_SEGMENTATION_FEED_USER = 17,
    OPTIMIZATION_TARGET_CONTEXTUAL_PAGE_ACTION_PRICE_TRACKING = 18,
    OPTIMIZATION_TARGET_TEXT_CLASSIFIER = 19,
    OPTIMIZATION_TARGET_GEOLOCATION_PERMISSION_PREDICTIONS = 20,
    OPTIMIZATION_TARGET_SEGMENTATION_SHOPPING_USER = 21,
    OPTIMIZATION_TARGET_SEGMENTATION_CHROME_START_ANDROID_V2 = 22,
    OPTIMIZATION_TARGET_SEGMENTATION_SEARCH_USER = 23,
    OPTIMIZATION_TARGET_OMNIBOX_ON_DEVICE_TAIL_SUGGEST = 24,
    OPTIMIZATION_TARGET_CLIENT_SIDE_PHISHING = 25,
    OPTIMIZATION_TARGET_OMNIBOX_URL_SCORING = 26,
    OPTIMIZATION_TARGET_SEGMENTATION_DEVICE_SWITCHER = 27,
    OPTIMIZATION_TARGET_SEGMENTATION_ADAPTIVE_TOOLBAR = 28,
    OPTIMIZATION_TARGET_SEGMENTATION_TABLET_PRODUCTIVITY_USER = 29,
    OPTIMIZATION_TARGET_CLIENT_SIDE_PHISHING_IMAGE_EMBEDDER = 30,
    OPTIMIZATION_TARGET_NEW_TAB_PAGE_HISTORY_CLUSTERS_MODULE_RANKING = 31,
    OPTIMIZATION_TARGET_WEB_APP_INSTALLATION_PROMO = 32,
    OPTIMIZATION_TARGET_TEXT_EMBEDDER = 33,
    OPTIMIZATION_TARGET_VISUAL_SEARCH_CLASSIFICATION = 34,
    OPTIMIZATION_TARGET_SEGMENTATION_BOTTOM_TOOLBAR = 35,
    OPTIMIZATION_TARGET_AUTOFILL_FIELD_CLASSIFICATION = 36,
    OPTIMIZATION_TARGET_SEGMENTATION_IOS_MODULE_RANKER = 37,
    OPTIMIZATION_TARGET_SEGMENTATION_DESKTOP_NTP_MODULE = 38,
    OPTIMIZATION_TARGET_PRELOADING_HEURISTICS = 39,
    OPTIMIZATION_TARGET_TEXT_SAFETY = 40,
    OPTIMIZATION_TARGET_SEGMENTATION_ANDROID_HOME_MODULE_RANKER = 41,
    OPTIMIZATION_TARGET_COMPOSE = 42,
    OPTIMIZATION_TARGET_PASSAGE_EMBEDDER = 43,
    OPTIMIZATION_TARGET_PHRASE_SEGMENTATION = 44,
    OPTIMIZATION_TARGET_SEGMENTATION_COMPOSE_PROMOTION = 45,
    OPTIMIZATION_TARGET_URL_VISIT_RESUMPTION_RANKER = 46,
    OPTIMIZATION_TARGET_CAMERA_BACKGROUND_SEGMENTATION = 47,
    OPTIMIZATION_TARGET_MODEL_EXECUTION_FEATURE_HISTORY_SEARCH = 48,
    OPTIMIZATION_TARGET_MODEL_EXECUTION_FEATURE_PROMPT_API = 49,
    OPTIMIZATION_TARGET_SEGMENTATION_METRICS_CLUSTERING = 50,
    OPTIMIZATION_TARGET_MODEL_EXECUTION_FEATURE_SUMMARIZE = 51,
    OPTIMIZATION_TARGET_PASSWORD_MANAGER_FORM_CLASSIFICATION = 52,
    OPTIMIZATION_TARGET_NOTIFICATION_CONTENT_DETECTION = 53,
    OPTIMIZATION_TARGET_MODEL_EXECUTION_FEATURE_HISTORY_QUERY_INTENT = 54
};
bool OptimizationTarget_IsValid(int value);
constexpr OptimizationTarget OptimizationTarget_MIN = OPTIMIZATION_TARGET_UNKNOWN;
constexpr OptimizationTarget OptimizationTarget_MAX = OPTIMIZATION_TARGET_MODEL_EXECUTION_FEATURE_HISTORY_QUERY_INTENT;
constexpr int OptimizationTarget_ARRAYSIZE = OptimizationTarget_MAX + 1;

const std::string& OptimizationTarget_Name(OptimizationTarget value);
template <typename T> inline const std::string& OptimizationTarget_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, OptimizationTarget>::value || ::std::is_integral<T>::value, "Incorrect type passed to function OptimizationTarget_Name.");
    return OptimizationTarget_Name(static_cast<OptimizationTarget>(enum_t_value));
}
bool OptimizationTarget_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OptimizationTarget* value);
enum ModelEngineVersion : int {
    MODEL_ENGINE_VERSION_UNKNOWN = 0,
    MODEL_ENGINE_VERSION_TFLITE_2_3_0 = 2,
    MODEL_ENGINE_VERSION_TFLITE_2_3_0_1 = 3,
    MODEL_ENGINE_VERSION_TFLITE_2_4 = 4,
    MODEL_ENGINE_VERSION_TFLITE_2_7 = 5,
    MODEL_ENGINE_VERSION_TFLITE_2_8 = 6,
    MODEL_ENGINE_VERSION_TFLITE_2_9 = 7,
    MODEL_ENGINE_VERSION_TFLITE_2_9_0_1 = 8,
    MODEL_ENGINE_VERSION_TFLITE_2_10 = 9,
    MODEL_ENGINE_VERSION_TFLITE_2_11 = 10,
    MODEL_ENGINE_VERSION_TFLITE_2_12 = 11,
    MODEL_ENGINE_VERSION_TFLITE_2_13 = 12,
    MODEL_ENGINE_VERSION_TFLITE_2_14 = 13,
    MODEL_ENGINE_VERSION_TFLITE_2_14_1 = 14,
    MODEL_ENGINE_VERSION_TFLITE_2_16 = 15,
    MODEL_ENGINE_VERSION_TFLITE_2_16_1 = 16,
    MODEL_ENGINE_VERSION_TFLITE_2_17 = 17,
    MODEL_ENGINE_VERSION_TFLITE_2_18 = 18
};
bool ModelEngineVersion_IsValid(int value);
constexpr ModelEngineVersion ModelEngineVersion_MIN = MODEL_ENGINE_VERSION_UNKNOWN;
constexpr ModelEngineVersion ModelEngineVersion_MAX = MODEL_ENGINE_VERSION_TFLITE_2_18;
constexpr int ModelEngineVersion_ARRAYSIZE = ModelEngineVersion_MAX + 1;

const std::string& ModelEngineVersion_Name(ModelEngineVersion value);
template <typename T> inline const std::string& ModelEngineVersion_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, ModelEngineVersion>::value || ::std::is_integral<T>::value, "Incorrect type passed to function ModelEngineVersion_Name.");
    return ModelEngineVersion_Name(static_cast<ModelEngineVersion>(enum_t_value));
}
bool ModelEngineVersion_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ModelEngineVersion* value);
// ===================================================================

class Model final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.Model) */ {
public:
    inline Model()
        : Model(nullptr)
    {
    }
    ~Model() override;
    explicit PROTOBUF_CONSTEXPR Model(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    Model(const Model& from);
    Model(Model&& from) noexcept
        : Model()
    {
        *this = ::std::move(from);
    }

    inline Model& operator=(const Model& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline Model& operator=(Model&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const Model& default_instance()
    {
        return *internal_default_instance();
    }
    enum ModelCase {
        kDownloadUrl = 5,
        MODEL_NOT_SET = 0,
    };

    static inline const Model* internal_default_instance()
    {
        return reinterpret_cast<const Model*>(&_Model_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 0;

    friend void swap(Model& a, Model& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(Model* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(Model* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    Model* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<Model>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const Model& from);
    void MergeFrom(const Model& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(Model* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "optimization_guide.proto.Model";
    }

protected:
    explicit Model(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kDownloadUrlFieldNumber = 5,
    };
    // string download_url = 5;
    bool has_download_url() const;

private:
    bool _internal_has_download_url() const;

public:
    void clear_download_url();
    const std::string& download_url() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_download_url(ArgT0&& arg0, ArgT... args);
    std::string* mutable_download_url();
    PROTOBUF_NODISCARD std::string* release_download_url();
    void set_allocated_download_url(std::string* download_url);

private:
    const std::string& _internal_download_url() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_download_url(const std::string& value);
    std::string* _internal_mutable_download_url();

public:
    void clear_model();
    ModelCase model_case() const;
    // @@protoc_insertion_point(class_scope:optimization_guide.proto.Model)
private:
    class _Internal;
    void set_has_download_url();

    inline bool has_model() const;
    inline void clear_has_model();

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        union ModelUnion {
            constexpr ModelUnion()
                : _constinit_ {}
            {
            }
            ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
            ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr download_url_;
        } model_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        uint32_t _oneof_case_[1];
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2foptimization_5fguide_2fproto_2fmodels_2eproto;
};
// -------------------------------------------------------------------

class GetModelsRequest final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.GetModelsRequest) */ {
public:
    inline GetModelsRequest()
        : GetModelsRequest(nullptr)
    {
    }
    ~GetModelsRequest() override;
    explicit PROTOBUF_CONSTEXPR GetModelsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    GetModelsRequest(const GetModelsRequest& from);
    GetModelsRequest(GetModelsRequest&& from) noexcept
        : GetModelsRequest()
    {
        *this = ::std::move(from);
    }

    inline GetModelsRequest& operator=(const GetModelsRequest& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline GetModelsRequest& operator=(GetModelsRequest&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const GetModelsRequest& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const GetModelsRequest* internal_default_instance()
    {
        return reinterpret_cast<const GetModelsRequest*>(&_GetModelsRequest_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 1;

    friend void swap(GetModelsRequest& a, GetModelsRequest& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(GetModelsRequest* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(GetModelsRequest* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    GetModelsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<GetModelsRequest>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const GetModelsRequest& from);
    void MergeFrom(const GetModelsRequest& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(GetModelsRequest* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "optimization_guide.proto.GetModelsRequest";
    }

protected:
    explicit GetModelsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kRequestedModelsFieldNumber = 1,
        kLocaleFieldNumber = 5,
        kOriginInfoFieldNumber = 6,
        kRequestContextFieldNumber = 3,
    };
    // repeated .optimization_guide.proto.ModelInfo requested_models = 1;
    int requested_models_size() const;

private:
    int _internal_requested_models_size() const;

public:
    void clear_requested_models();
    ::optimization_guide::proto::ModelInfo* mutable_requested_models(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::ModelInfo>* mutable_requested_models();

private:
    const ::optimization_guide::proto::ModelInfo& _internal_requested_models(int index) const;
    ::optimization_guide::proto::ModelInfo* _internal_add_requested_models();

public:
    const ::optimization_guide::proto::ModelInfo& requested_models(int index) const;
    ::optimization_guide::proto::ModelInfo* add_requested_models();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::ModelInfo>& requested_models() const;

    // optional string locale = 5;
    bool has_locale() const;

private:
    bool _internal_has_locale() const;

public:
    void clear_locale();
    const std::string& locale() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_locale(ArgT0&& arg0, ArgT... args);
    std::string* mutable_locale();
    PROTOBUF_NODISCARD std::string* release_locale();
    void set_allocated_locale(std::string* locale);

private:
    const std::string& _internal_locale() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_locale(const std::string& value);
    std::string* _internal_mutable_locale();

public:
    // optional .optimization_guide.proto.OriginInfo origin_info = 6;
    bool has_origin_info() const;

private:
    bool _internal_has_origin_info() const;

public:
    void clear_origin_info();
    const ::optimization_guide::proto::OriginInfo& origin_info() const;
    PROTOBUF_NODISCARD ::optimization_guide::proto::OriginInfo* release_origin_info();
    ::optimization_guide::proto::OriginInfo* mutable_origin_info();
    void set_allocated_origin_info(::optimization_guide::proto::OriginInfo* origin_info);

private:
    const ::optimization_guide::proto::OriginInfo& _internal_origin_info() const;
    ::optimization_guide::proto::OriginInfo* _internal_mutable_origin_info();

public:
    void unsafe_arena_set_allocated_origin_info(::optimization_guide::proto::OriginInfo* origin_info);
    ::optimization_guide::proto::OriginInfo* unsafe_arena_release_origin_info();

    // optional .optimization_guide.proto.RequestContext request_context = 3;
    bool has_request_context() const;

private:
    bool _internal_has_request_context() const;

public:
    void clear_request_context();
    ::optimization_guide::proto::RequestContext request_context() const;
    void set_request_context(::optimization_guide::proto::RequestContext value);

private:
    ::optimization_guide::proto::RequestContext _internal_request_context() const;
    void _internal_set_request_context(::optimization_guide::proto::RequestContext value);

public:
    // @@protoc_insertion_point(class_scope:optimization_guide.proto.GetModelsRequest)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::ModelInfo> requested_models_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr locale_;
        ::optimization_guide::proto::OriginInfo* origin_info_;
        int request_context_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2foptimization_5fguide_2fproto_2fmodels_2eproto;
};
// -------------------------------------------------------------------

class GetModelsResponse final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.GetModelsResponse) */ {
public:
    inline GetModelsResponse()
        : GetModelsResponse(nullptr)
    {
    }
    ~GetModelsResponse() override;
    explicit PROTOBUF_CONSTEXPR GetModelsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    GetModelsResponse(const GetModelsResponse& from);
    GetModelsResponse(GetModelsResponse&& from) noexcept
        : GetModelsResponse()
    {
        *this = ::std::move(from);
    }

    inline GetModelsResponse& operator=(const GetModelsResponse& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline GetModelsResponse& operator=(GetModelsResponse&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const GetModelsResponse& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const GetModelsResponse* internal_default_instance()
    {
        return reinterpret_cast<const GetModelsResponse*>(&_GetModelsResponse_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 2;

    friend void swap(GetModelsResponse& a, GetModelsResponse& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(GetModelsResponse* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(GetModelsResponse* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    GetModelsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<GetModelsResponse>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const GetModelsResponse& from);
    void MergeFrom(const GetModelsResponse& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(GetModelsResponse* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "optimization_guide.proto.GetModelsResponse";
    }

protected:
    explicit GetModelsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kModelsFieldNumber = 1,
    };
    // repeated .optimization_guide.proto.PredictionModel models = 1;
    int models_size() const;

private:
    int _internal_models_size() const;

public:
    void clear_models();
    ::optimization_guide::proto::PredictionModel* mutable_models(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::PredictionModel>* mutable_models();

private:
    const ::optimization_guide::proto::PredictionModel& _internal_models(int index) const;
    ::optimization_guide::proto::PredictionModel* _internal_add_models();

public:
    const ::optimization_guide::proto::PredictionModel& models(int index) const;
    ::optimization_guide::proto::PredictionModel* add_models();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::PredictionModel>& models() const;

    // @@protoc_insertion_point(class_scope:optimization_guide.proto.GetModelsResponse)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::PredictionModel> models_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2foptimization_5fguide_2fproto_2fmodels_2eproto;
};
// -------------------------------------------------------------------

class PredictionModel final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.PredictionModel) */ {
public:
    inline PredictionModel()
        : PredictionModel(nullptr)
    {
    }
    ~PredictionModel() override;
    explicit PROTOBUF_CONSTEXPR PredictionModel(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    PredictionModel(const PredictionModel& from);
    PredictionModel(PredictionModel&& from) noexcept
        : PredictionModel()
    {
        *this = ::std::move(from);
    }

    inline PredictionModel& operator=(const PredictionModel& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline PredictionModel& operator=(PredictionModel&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const PredictionModel& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const PredictionModel* internal_default_instance()
    {
        return reinterpret_cast<const PredictionModel*>(&_PredictionModel_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 3;

    friend void swap(PredictionModel& a, PredictionModel& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(PredictionModel* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(PredictionModel* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    PredictionModel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<PredictionModel>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const PredictionModel& from);
    void MergeFrom(const PredictionModel& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(PredictionModel* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "optimization_guide.proto.PredictionModel";
    }

protected:
    explicit PredictionModel(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kModelInfoFieldNumber = 1,
        kModelFieldNumber = 2,
    };
    // optional .optimization_guide.proto.ModelInfo model_info = 1;
    bool has_model_info() const;

private:
    bool _internal_has_model_info() const;

public:
    void clear_model_info();
    const ::optimization_guide::proto::ModelInfo& model_info() const;
    PROTOBUF_NODISCARD ::optimization_guide::proto::ModelInfo* release_model_info();
    ::optimization_guide::proto::ModelInfo* mutable_model_info();
    void set_allocated_model_info(::optimization_guide::proto::ModelInfo* model_info);

private:
    const ::optimization_guide::proto::ModelInfo& _internal_model_info() const;
    ::optimization_guide::proto::ModelInfo* _internal_mutable_model_info();

public:
    void unsafe_arena_set_allocated_model_info(::optimization_guide::proto::ModelInfo* model_info);
    ::optimization_guide::proto::ModelInfo* unsafe_arena_release_model_info();

    // optional .optimization_guide.proto.Model model = 2;
    bool has_model() const;

private:
    bool _internal_has_model() const;

public:
    void clear_model();
    const ::optimization_guide::proto::Model& model() const;
    PROTOBUF_NODISCARD ::optimization_guide::proto::Model* release_model();
    ::optimization_guide::proto::Model* mutable_model();
    void set_allocated_model(::optimization_guide::proto::Model* model);

private:
    const ::optimization_guide::proto::Model& _internal_model() const;
    ::optimization_guide::proto::Model* _internal_mutable_model();

public:
    void unsafe_arena_set_allocated_model(::optimization_guide::proto::Model* model);
    ::optimization_guide::proto::Model* unsafe_arena_release_model();

    // @@protoc_insertion_point(class_scope:optimization_guide.proto.PredictionModel)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::optimization_guide::proto::ModelInfo* model_info_;
        ::optimization_guide::proto::Model* model_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2foptimization_5fguide_2fproto_2fmodels_2eproto;
};
// -------------------------------------------------------------------

class AdditionalModelFile final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.AdditionalModelFile) */ {
public:
    inline AdditionalModelFile()
        : AdditionalModelFile(nullptr)
    {
    }
    ~AdditionalModelFile() override;
    explicit PROTOBUF_CONSTEXPR AdditionalModelFile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    AdditionalModelFile(const AdditionalModelFile& from);
    AdditionalModelFile(AdditionalModelFile&& from) noexcept
        : AdditionalModelFile()
    {
        *this = ::std::move(from);
    }

    inline AdditionalModelFile& operator=(const AdditionalModelFile& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline AdditionalModelFile& operator=(AdditionalModelFile&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const AdditionalModelFile& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const AdditionalModelFile* internal_default_instance()
    {
        return reinterpret_cast<const AdditionalModelFile*>(&_AdditionalModelFile_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 4;

    friend void swap(AdditionalModelFile& a, AdditionalModelFile& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(AdditionalModelFile* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(AdditionalModelFile* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    AdditionalModelFile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<AdditionalModelFile>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const AdditionalModelFile& from);
    void MergeFrom(const AdditionalModelFile& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(AdditionalModelFile* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "optimization_guide.proto.AdditionalModelFile";
    }

protected:
    explicit AdditionalModelFile(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kFilePathFieldNumber = 1,
    };
    // optional string file_path = 1;
    bool has_file_path() const;

private:
    bool _internal_has_file_path() const;

public:
    void clear_file_path();
    const std::string& file_path() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_file_path(ArgT0&& arg0, ArgT... args);
    std::string* mutable_file_path();
    PROTOBUF_NODISCARD std::string* release_file_path();
    void set_allocated_file_path(std::string* file_path);

private:
    const std::string& _internal_file_path() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_path(const std::string& value);
    std::string* _internal_mutable_file_path();

public:
    // @@protoc_insertion_point(class_scope:optimization_guide.proto.AdditionalModelFile)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_path_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2foptimization_5fguide_2fproto_2fmodels_2eproto;
};
// -------------------------------------------------------------------

class ModelInfo final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.ModelInfo) */ {
public:
    inline ModelInfo()
        : ModelInfo(nullptr)
    {
    }
    ~ModelInfo() override;
    explicit PROTOBUF_CONSTEXPR ModelInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ModelInfo(const ModelInfo& from);
    ModelInfo(ModelInfo&& from) noexcept
        : ModelInfo()
    {
        *this = ::std::move(from);
    }

    inline ModelInfo& operator=(const ModelInfo& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ModelInfo& operator=(ModelInfo&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ModelInfo& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ModelInfo* internal_default_instance()
    {
        return reinterpret_cast<const ModelInfo*>(&_ModelInfo_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 5;

    friend void swap(ModelInfo& a, ModelInfo& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ModelInfo* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ModelInfo* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ModelInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ModelInfo>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ModelInfo& from);
    void MergeFrom(const ModelInfo& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ModelInfo* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "optimization_guide.proto.ModelInfo";
    }

protected:
    explicit ModelInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kSupportedModelEngineVersionsFieldNumber = 4,
        kSupportedHostModelFeaturesFieldNumber = 5,
        kAdditionalFilesFieldNumber = 7,
        kModelMetadataFieldNumber = 6,
        kValidDurationFieldNumber = 8,
        kModelCacheKeyFieldNumber = 10,
        kVersionFieldNumber = 2,
        kOptimizationTargetFieldNumber = 1,
        kKeepBeyondValidDurationFieldNumber = 9,
    };
    // repeated .optimization_guide.proto.ModelEngineVersion supported_model_engine_versions = 4;
    int supported_model_engine_versions_size() const;

private:
    int _internal_supported_model_engine_versions_size() const;

public:
    void clear_supported_model_engine_versions();

private:
    ::optimization_guide::proto::ModelEngineVersion _internal_supported_model_engine_versions(int index) const;
    void _internal_add_supported_model_engine_versions(::optimization_guide::proto::ModelEngineVersion value);
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_supported_model_engine_versions();

public:
    ::optimization_guide::proto::ModelEngineVersion supported_model_engine_versions(int index) const;
    void set_supported_model_engine_versions(int index, ::optimization_guide::proto::ModelEngineVersion value);
    void add_supported_model_engine_versions(::optimization_guide::proto::ModelEngineVersion value);
    const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& supported_model_engine_versions() const;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_supported_model_engine_versions();

    // repeated string supported_host_model_features = 5;
    int supported_host_model_features_size() const;

private:
    int _internal_supported_host_model_features_size() const;

public:
    void clear_supported_host_model_features();
    const std::string& supported_host_model_features(int index) const;
    std::string* mutable_supported_host_model_features(int index);
    void set_supported_host_model_features(int index, const std::string& value);
    void set_supported_host_model_features(int index, std::string&& value);
    void set_supported_host_model_features(int index, const char* value);
    void set_supported_host_model_features(int index, const char* value, size_t size);
    std::string* add_supported_host_model_features();
    void add_supported_host_model_features(const std::string& value);
    void add_supported_host_model_features(std::string&& value);
    void add_supported_host_model_features(const char* value);
    void add_supported_host_model_features(const char* value, size_t size);
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& supported_host_model_features() const;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_supported_host_model_features();

private:
    const std::string& _internal_supported_host_model_features(int index) const;
    std::string* _internal_add_supported_host_model_features();

public:
    // repeated .optimization_guide.proto.AdditionalModelFile additional_files = 7;
    int additional_files_size() const;

private:
    int _internal_additional_files_size() const;

public:
    void clear_additional_files();
    ::optimization_guide::proto::AdditionalModelFile* mutable_additional_files(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::AdditionalModelFile>* mutable_additional_files();

private:
    const ::optimization_guide::proto::AdditionalModelFile& _internal_additional_files(int index) const;
    ::optimization_guide::proto::AdditionalModelFile* _internal_add_additional_files();

public:
    const ::optimization_guide::proto::AdditionalModelFile& additional_files(int index) const;
    ::optimization_guide::proto::AdditionalModelFile* add_additional_files();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::AdditionalModelFile>& additional_files() const;

    // optional .optimization_guide.proto.Any model_metadata = 6;
    bool has_model_metadata() const;

private:
    bool _internal_has_model_metadata() const;

public:
    void clear_model_metadata();
    const ::optimization_guide::proto::Any& model_metadata() const;
    PROTOBUF_NODISCARD ::optimization_guide::proto::Any* release_model_metadata();
    ::optimization_guide::proto::Any* mutable_model_metadata();
    void set_allocated_model_metadata(::optimization_guide::proto::Any* model_metadata);

private:
    const ::optimization_guide::proto::Any& _internal_model_metadata() const;
    ::optimization_guide::proto::Any* _internal_mutable_model_metadata();

public:
    void unsafe_arena_set_allocated_model_metadata(::optimization_guide::proto::Any* model_metadata);
    ::optimization_guide::proto::Any* unsafe_arena_release_model_metadata();

    // optional .optimization_guide.proto.Duration valid_duration = 8;
    bool has_valid_duration() const;

private:
    bool _internal_has_valid_duration() const;

public:
    void clear_valid_duration();
    const ::optimization_guide::proto::Duration& valid_duration() const;
    PROTOBUF_NODISCARD ::optimization_guide::proto::Duration* release_valid_duration();
    ::optimization_guide::proto::Duration* mutable_valid_duration();
    void set_allocated_valid_duration(::optimization_guide::proto::Duration* valid_duration);

private:
    const ::optimization_guide::proto::Duration& _internal_valid_duration() const;
    ::optimization_guide::proto::Duration* _internal_mutable_valid_duration();

public:
    void unsafe_arena_set_allocated_valid_duration(::optimization_guide::proto::Duration* valid_duration);
    ::optimization_guide::proto::Duration* unsafe_arena_release_valid_duration();

    // optional .optimization_guide.proto.ModelCacheKey model_cache_key = 10;
    bool has_model_cache_key() const;

private:
    bool _internal_has_model_cache_key() const;

public:
    void clear_model_cache_key();
    const ::optimization_guide::proto::ModelCacheKey& model_cache_key() const;
    PROTOBUF_NODISCARD ::optimization_guide::proto::ModelCacheKey* release_model_cache_key();
    ::optimization_guide::proto::ModelCacheKey* mutable_model_cache_key();
    void set_allocated_model_cache_key(::optimization_guide::proto::ModelCacheKey* model_cache_key);

private:
    const ::optimization_guide::proto::ModelCacheKey& _internal_model_cache_key() const;
    ::optimization_guide::proto::ModelCacheKey* _internal_mutable_model_cache_key();

public:
    void unsafe_arena_set_allocated_model_cache_key(::optimization_guide::proto::ModelCacheKey* model_cache_key);
    ::optimization_guide::proto::ModelCacheKey* unsafe_arena_release_model_cache_key();

    // optional int64 version = 2;
    bool has_version() const;

private:
    bool _internal_has_version() const;

public:
    void clear_version();
    int64_t version() const;
    void set_version(int64_t value);

private:
    int64_t _internal_version() const;
    void _internal_set_version(int64_t value);

public:
    // optional .optimization_guide.proto.OptimizationTarget optimization_target = 1;
    bool has_optimization_target() const;

private:
    bool _internal_has_optimization_target() const;

public:
    void clear_optimization_target();
    ::optimization_guide::proto::OptimizationTarget optimization_target() const;
    void set_optimization_target(::optimization_guide::proto::OptimizationTarget value);

private:
    ::optimization_guide::proto::OptimizationTarget _internal_optimization_target() const;
    void _internal_set_optimization_target(::optimization_guide::proto::OptimizationTarget value);

public:
    // optional bool keep_beyond_valid_duration = 9;
    bool has_keep_beyond_valid_duration() const;

private:
    bool _internal_has_keep_beyond_valid_duration() const;

public:
    void clear_keep_beyond_valid_duration();
    bool keep_beyond_valid_duration() const;
    void set_keep_beyond_valid_duration(bool value);

private:
    bool _internal_keep_beyond_valid_duration() const;
    void _internal_set_keep_beyond_valid_duration(bool value);

public:
    // @@protoc_insertion_point(class_scope:optimization_guide.proto.ModelInfo)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> supported_model_engine_versions_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> supported_host_model_features_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::AdditionalModelFile> additional_files_;
        ::optimization_guide::proto::Any* model_metadata_;
        ::optimization_guide::proto::Duration* valid_duration_;
        ::optimization_guide::proto::ModelCacheKey* model_cache_key_;
        int64_t version_;
        int optimization_target_;
        bool keep_beyond_valid_duration_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2foptimization_5fguide_2fproto_2fmodels_2eproto;
};
// -------------------------------------------------------------------

class ModelCacheKey final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.ModelCacheKey) */ {
public:
    inline ModelCacheKey()
        : ModelCacheKey(nullptr)
    {
    }
    ~ModelCacheKey() override;
    explicit PROTOBUF_CONSTEXPR ModelCacheKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ModelCacheKey(const ModelCacheKey& from);
    ModelCacheKey(ModelCacheKey&& from) noexcept
        : ModelCacheKey()
    {
        *this = ::std::move(from);
    }

    inline ModelCacheKey& operator=(const ModelCacheKey& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ModelCacheKey& operator=(ModelCacheKey&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ModelCacheKey& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ModelCacheKey* internal_default_instance()
    {
        return reinterpret_cast<const ModelCacheKey*>(&_ModelCacheKey_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 6;

    friend void swap(ModelCacheKey& a, ModelCacheKey& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ModelCacheKey* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ModelCacheKey* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ModelCacheKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ModelCacheKey>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ModelCacheKey& from);
    void MergeFrom(const ModelCacheKey& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ModelCacheKey* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "optimization_guide.proto.ModelCacheKey";
    }

protected:
    explicit ModelCacheKey(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kLocaleFieldNumber = 1,
    };
    // optional string locale = 1;
    bool has_locale() const;

private:
    bool _internal_has_locale() const;

public:
    void clear_locale();
    const std::string& locale() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_locale(ArgT0&& arg0, ArgT... args);
    std::string* mutable_locale();
    PROTOBUF_NODISCARD std::string* release_locale();
    void set_allocated_locale(std::string* locale);

private:
    const std::string& _internal_locale() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_locale(const std::string& value);
    std::string* _internal_mutable_locale();

public:
    // @@protoc_insertion_point(class_scope:optimization_guide.proto.ModelCacheKey)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr locale_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2foptimization_5fguide_2fproto_2fmodels_2eproto;
};
// ===================================================================

// ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif // __GNUC__
// Model

// string download_url = 5;
inline bool Model::_internal_has_download_url() const
{
    return model_case() == kDownloadUrl;
}
inline bool Model::has_download_url() const
{
    return _internal_has_download_url();
}
inline void Model::set_has_download_url()
{
    _impl_._oneof_case_[0] = kDownloadUrl;
}
inline void Model::clear_download_url()
{
    if (_internal_has_download_url()) {
        _impl_.model_.download_url_.Destroy();
        clear_has_model();
    }
}
inline const std::string& Model::download_url() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.Model.download_url)
    return _internal_download_url();
}
template <typename ArgT0, typename... ArgT> inline void Model::set_download_url(ArgT0&& arg0, ArgT... args)
{
    if (!_internal_has_download_url()) {
        clear_model();
        set_has_download_url();
        _impl_.model_.download_url_.InitDefault();
    }
    _impl_.model_.download_url_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:optimization_guide.proto.Model.download_url)
}
inline std::string* Model::mutable_download_url()
{
    std::string* _s = _internal_mutable_download_url();
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.Model.download_url)
    return _s;
}
inline const std::string& Model::_internal_download_url() const
{
    if (_internal_has_download_url()) {
        return _impl_.model_.download_url_.Get();
    }
    return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Model::_internal_set_download_url(const std::string& value)
{
    if (!_internal_has_download_url()) {
        clear_model();
        set_has_download_url();
        _impl_.model_.download_url_.InitDefault();
    }
    _impl_.model_.download_url_.Set(value, GetArenaForAllocation());
}
inline std::string* Model::_internal_mutable_download_url()
{
    if (!_internal_has_download_url()) {
        clear_model();
        set_has_download_url();
        _impl_.model_.download_url_.InitDefault();
    }
    return _impl_.model_.download_url_.Mutable(GetArenaForAllocation());
}
inline std::string* Model::release_download_url()
{
    // @@protoc_insertion_point(field_release:optimization_guide.proto.Model.download_url)
    if (_internal_has_download_url()) {
        clear_has_model();
        return _impl_.model_.download_url_.Release();
    } else {
        return nullptr;
    }
}
inline void Model::set_allocated_download_url(std::string* download_url)
{
    if (has_model()) {
        clear_model();
    }
    if (download_url != nullptr) {
        set_has_download_url();
        _impl_.model_.download_url_.InitAllocated(download_url, GetArenaForAllocation());
    }
    // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.Model.download_url)
}

inline bool Model::has_model() const
{
    return model_case() != MODEL_NOT_SET;
}
inline void Model::clear_has_model()
{
    _impl_._oneof_case_[0] = MODEL_NOT_SET;
}
inline Model::ModelCase Model::model_case() const
{
    return Model::ModelCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// GetModelsRequest

// repeated .optimization_guide.proto.ModelInfo requested_models = 1;
inline int GetModelsRequest::_internal_requested_models_size() const
{
    return _impl_.requested_models_.size();
}
inline int GetModelsRequest::requested_models_size() const
{
    return _internal_requested_models_size();
}
inline void GetModelsRequest::clear_requested_models()
{
    _impl_.requested_models_.Clear();
}
inline ::optimization_guide::proto::ModelInfo* GetModelsRequest::mutable_requested_models(int index)
{
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.GetModelsRequest.requested_models)
    return _impl_.requested_models_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::ModelInfo>* GetModelsRequest::mutable_requested_models()
{
    // @@protoc_insertion_point(field_mutable_list:optimization_guide.proto.GetModelsRequest.requested_models)
    return &_impl_.requested_models_;
}
inline const ::optimization_guide::proto::ModelInfo& GetModelsRequest::_internal_requested_models(int index) const
{
    return _impl_.requested_models_.Get(index);
}
inline const ::optimization_guide::proto::ModelInfo& GetModelsRequest::requested_models(int index) const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.GetModelsRequest.requested_models)
    return _internal_requested_models(index);
}
inline ::optimization_guide::proto::ModelInfo* GetModelsRequest::_internal_add_requested_models()
{
    return _impl_.requested_models_.Add();
}
inline ::optimization_guide::proto::ModelInfo* GetModelsRequest::add_requested_models()
{
    ::optimization_guide::proto::ModelInfo* _add = _internal_add_requested_models();
    // @@protoc_insertion_point(field_add:optimization_guide.proto.GetModelsRequest.requested_models)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::ModelInfo>& GetModelsRequest::requested_models() const
{
    // @@protoc_insertion_point(field_list:optimization_guide.proto.GetModelsRequest.requested_models)
    return _impl_.requested_models_;
}

// optional .optimization_guide.proto.RequestContext request_context = 3;
inline bool GetModelsRequest::_internal_has_request_context() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool GetModelsRequest::has_request_context() const
{
    return _internal_has_request_context();
}
inline void GetModelsRequest::clear_request_context()
{
    _impl_.request_context_ = 0;
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::optimization_guide::proto::RequestContext GetModelsRequest::_internal_request_context() const
{
    return static_cast<::optimization_guide::proto::RequestContext>(_impl_.request_context_);
}
inline ::optimization_guide::proto::RequestContext GetModelsRequest::request_context() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.GetModelsRequest.request_context)
    return _internal_request_context();
}
inline void GetModelsRequest::_internal_set_request_context(::optimization_guide::proto::RequestContext value)
{
    assert(::optimization_guide::proto::RequestContext_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.request_context_ = value;
}
inline void GetModelsRequest::set_request_context(::optimization_guide::proto::RequestContext value)
{
    _internal_set_request_context(value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.GetModelsRequest.request_context)
}

// optional string locale = 5;
inline bool GetModelsRequest::_internal_has_locale() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool GetModelsRequest::has_locale() const
{
    return _internal_has_locale();
}
inline void GetModelsRequest::clear_locale()
{
    _impl_.locale_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetModelsRequest::locale() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.GetModelsRequest.locale)
    return _internal_locale();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void GetModelsRequest::set_locale(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.locale_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:optimization_guide.proto.GetModelsRequest.locale)
}
inline std::string* GetModelsRequest::mutable_locale()
{
    std::string* _s = _internal_mutable_locale();
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.GetModelsRequest.locale)
    return _s;
}
inline const std::string& GetModelsRequest::_internal_locale() const
{
    return _impl_.locale_.Get();
}
inline void GetModelsRequest::_internal_set_locale(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.locale_.Set(value, GetArenaForAllocation());
}
inline std::string* GetModelsRequest::_internal_mutable_locale()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.locale_.Mutable(GetArenaForAllocation());
}
inline std::string* GetModelsRequest::release_locale()
{
    // @@protoc_insertion_point(field_release:optimization_guide.proto.GetModelsRequest.locale)
    if (!_internal_has_locale()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.locale_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.locale_.IsDefault()) {
        _impl_.locale_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void GetModelsRequest::set_allocated_locale(std::string* locale)
{
    if (locale != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.locale_.SetAllocated(locale, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.locale_.IsDefault()) {
        _impl_.locale_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.GetModelsRequest.locale)
}

// optional .optimization_guide.proto.OriginInfo origin_info = 6;
inline bool GetModelsRequest::_internal_has_origin_info() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.origin_info_ != nullptr);
    return value;
}
inline bool GetModelsRequest::has_origin_info() const
{
    return _internal_has_origin_info();
}
inline const ::optimization_guide::proto::OriginInfo& GetModelsRequest::_internal_origin_info() const
{
    const ::optimization_guide::proto::OriginInfo* p = _impl_.origin_info_;
    return p != nullptr ? *p : reinterpret_cast<const ::optimization_guide::proto::OriginInfo&>(::optimization_guide::proto::_OriginInfo_default_instance_);
}
inline const ::optimization_guide::proto::OriginInfo& GetModelsRequest::origin_info() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.GetModelsRequest.origin_info)
    return _internal_origin_info();
}
inline void GetModelsRequest::unsafe_arena_set_allocated_origin_info(::optimization_guide::proto::OriginInfo* origin_info)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.origin_info_);
    }
    _impl_.origin_info_ = origin_info;
    if (origin_info) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:optimization_guide.proto.GetModelsRequest.origin_info)
}
inline ::optimization_guide::proto::OriginInfo* GetModelsRequest::release_origin_info()
{
    _impl_._has_bits_[0] &= ~0x00000002u;
    ::optimization_guide::proto::OriginInfo* temp = _impl_.origin_info_;
    _impl_.origin_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::optimization_guide::proto::OriginInfo* GetModelsRequest::unsafe_arena_release_origin_info()
{
    // @@protoc_insertion_point(field_release:optimization_guide.proto.GetModelsRequest.origin_info)
    _impl_._has_bits_[0] &= ~0x00000002u;
    ::optimization_guide::proto::OriginInfo* temp = _impl_.origin_info_;
    _impl_.origin_info_ = nullptr;
    return temp;
}
inline ::optimization_guide::proto::OriginInfo* GetModelsRequest::_internal_mutable_origin_info()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    if (_impl_.origin_info_ == nullptr) {
        auto* p = CreateMaybeMessage<::optimization_guide::proto::OriginInfo>(GetArenaForAllocation());
        _impl_.origin_info_ = p;
    }
    return _impl_.origin_info_;
}
inline ::optimization_guide::proto::OriginInfo* GetModelsRequest::mutable_origin_info()
{
    ::optimization_guide::proto::OriginInfo* _msg = _internal_mutable_origin_info();
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.GetModelsRequest.origin_info)
    return _msg;
}
inline void GetModelsRequest::set_allocated_origin_info(::optimization_guide::proto::OriginInfo* origin_info)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.origin_info_);
    }
    if (origin_info) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena
            = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(origin_info));
        if (message_arena != submessage_arena) {
            origin_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, origin_info, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.origin_info_ = origin_info;
    // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.GetModelsRequest.origin_info)
}

// -------------------------------------------------------------------

// GetModelsResponse

// repeated .optimization_guide.proto.PredictionModel models = 1;
inline int GetModelsResponse::_internal_models_size() const
{
    return _impl_.models_.size();
}
inline int GetModelsResponse::models_size() const
{
    return _internal_models_size();
}
inline void GetModelsResponse::clear_models()
{
    _impl_.models_.Clear();
}
inline ::optimization_guide::proto::PredictionModel* GetModelsResponse::mutable_models(int index)
{
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.GetModelsResponse.models)
    return _impl_.models_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::PredictionModel>* GetModelsResponse::mutable_models()
{
    // @@protoc_insertion_point(field_mutable_list:optimization_guide.proto.GetModelsResponse.models)
    return &_impl_.models_;
}
inline const ::optimization_guide::proto::PredictionModel& GetModelsResponse::_internal_models(int index) const
{
    return _impl_.models_.Get(index);
}
inline const ::optimization_guide::proto::PredictionModel& GetModelsResponse::models(int index) const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.GetModelsResponse.models)
    return _internal_models(index);
}
inline ::optimization_guide::proto::PredictionModel* GetModelsResponse::_internal_add_models()
{
    return _impl_.models_.Add();
}
inline ::optimization_guide::proto::PredictionModel* GetModelsResponse::add_models()
{
    ::optimization_guide::proto::PredictionModel* _add = _internal_add_models();
    // @@protoc_insertion_point(field_add:optimization_guide.proto.GetModelsResponse.models)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::PredictionModel>& GetModelsResponse::models() const
{
    // @@protoc_insertion_point(field_list:optimization_guide.proto.GetModelsResponse.models)
    return _impl_.models_;
}

// -------------------------------------------------------------------

// PredictionModel

// optional .optimization_guide.proto.ModelInfo model_info = 1;
inline bool PredictionModel::_internal_has_model_info() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.model_info_ != nullptr);
    return value;
}
inline bool PredictionModel::has_model_info() const
{
    return _internal_has_model_info();
}
inline void PredictionModel::clear_model_info()
{
    if (_impl_.model_info_ != nullptr)
        _impl_.model_info_->Clear();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::optimization_guide::proto::ModelInfo& PredictionModel::_internal_model_info() const
{
    const ::optimization_guide::proto::ModelInfo* p = _impl_.model_info_;
    return p != nullptr ? *p : reinterpret_cast<const ::optimization_guide::proto::ModelInfo&>(::optimization_guide::proto::_ModelInfo_default_instance_);
}
inline const ::optimization_guide::proto::ModelInfo& PredictionModel::model_info() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.PredictionModel.model_info)
    return _internal_model_info();
}
inline void PredictionModel::unsafe_arena_set_allocated_model_info(::optimization_guide::proto::ModelInfo* model_info)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.model_info_);
    }
    _impl_.model_info_ = model_info;
    if (model_info) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:optimization_guide.proto.PredictionModel.model_info)
}
inline ::optimization_guide::proto::ModelInfo* PredictionModel::release_model_info()
{
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::optimization_guide::proto::ModelInfo* temp = _impl_.model_info_;
    _impl_.model_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::optimization_guide::proto::ModelInfo* PredictionModel::unsafe_arena_release_model_info()
{
    // @@protoc_insertion_point(field_release:optimization_guide.proto.PredictionModel.model_info)
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::optimization_guide::proto::ModelInfo* temp = _impl_.model_info_;
    _impl_.model_info_ = nullptr;
    return temp;
}
inline ::optimization_guide::proto::ModelInfo* PredictionModel::_internal_mutable_model_info()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    if (_impl_.model_info_ == nullptr) {
        auto* p = CreateMaybeMessage<::optimization_guide::proto::ModelInfo>(GetArenaForAllocation());
        _impl_.model_info_ = p;
    }
    return _impl_.model_info_;
}
inline ::optimization_guide::proto::ModelInfo* PredictionModel::mutable_model_info()
{
    ::optimization_guide::proto::ModelInfo* _msg = _internal_mutable_model_info();
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.PredictionModel.model_info)
    return _msg;
}
inline void PredictionModel::set_allocated_model_info(::optimization_guide::proto::ModelInfo* model_info)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.model_info_;
    }
    if (model_info) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(model_info);
        if (message_arena != submessage_arena) {
            model_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, model_info, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.model_info_ = model_info;
    // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.PredictionModel.model_info)
}

// optional .optimization_guide.proto.Model model = 2;
inline bool PredictionModel::_internal_has_model() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.model_ != nullptr);
    return value;
}
inline bool PredictionModel::has_model() const
{
    return _internal_has_model();
}
inline void PredictionModel::clear_model()
{
    if (_impl_.model_ != nullptr)
        _impl_.model_->Clear();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::optimization_guide::proto::Model& PredictionModel::_internal_model() const
{
    const ::optimization_guide::proto::Model* p = _impl_.model_;
    return p != nullptr ? *p : reinterpret_cast<const ::optimization_guide::proto::Model&>(::optimization_guide::proto::_Model_default_instance_);
}
inline const ::optimization_guide::proto::Model& PredictionModel::model() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.PredictionModel.model)
    return _internal_model();
}
inline void PredictionModel::unsafe_arena_set_allocated_model(::optimization_guide::proto::Model* model)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.model_);
    }
    _impl_.model_ = model;
    if (model) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:optimization_guide.proto.PredictionModel.model)
}
inline ::optimization_guide::proto::Model* PredictionModel::release_model()
{
    _impl_._has_bits_[0] &= ~0x00000002u;
    ::optimization_guide::proto::Model* temp = _impl_.model_;
    _impl_.model_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::optimization_guide::proto::Model* PredictionModel::unsafe_arena_release_model()
{
    // @@protoc_insertion_point(field_release:optimization_guide.proto.PredictionModel.model)
    _impl_._has_bits_[0] &= ~0x00000002u;
    ::optimization_guide::proto::Model* temp = _impl_.model_;
    _impl_.model_ = nullptr;
    return temp;
}
inline ::optimization_guide::proto::Model* PredictionModel::_internal_mutable_model()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    if (_impl_.model_ == nullptr) {
        auto* p = CreateMaybeMessage<::optimization_guide::proto::Model>(GetArenaForAllocation());
        _impl_.model_ = p;
    }
    return _impl_.model_;
}
inline ::optimization_guide::proto::Model* PredictionModel::mutable_model()
{
    ::optimization_guide::proto::Model* _msg = _internal_mutable_model();
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.PredictionModel.model)
    return _msg;
}
inline void PredictionModel::set_allocated_model(::optimization_guide::proto::Model* model)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.model_;
    }
    if (model) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(model);
        if (message_arena != submessage_arena) {
            model = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, model, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.model_ = model;
    // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.PredictionModel.model)
}

// -------------------------------------------------------------------

// AdditionalModelFile

// optional string file_path = 1;
inline bool AdditionalModelFile::_internal_has_file_path() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool AdditionalModelFile::has_file_path() const
{
    return _internal_has_file_path();
}
inline void AdditionalModelFile::clear_file_path()
{
    _impl_.file_path_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AdditionalModelFile::file_path() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.AdditionalModelFile.file_path)
    return _internal_file_path();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void AdditionalModelFile::set_file_path(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.file_path_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:optimization_guide.proto.AdditionalModelFile.file_path)
}
inline std::string* AdditionalModelFile::mutable_file_path()
{
    std::string* _s = _internal_mutable_file_path();
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.AdditionalModelFile.file_path)
    return _s;
}
inline const std::string& AdditionalModelFile::_internal_file_path() const
{
    return _impl_.file_path_.Get();
}
inline void AdditionalModelFile::_internal_set_file_path(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.file_path_.Set(value, GetArenaForAllocation());
}
inline std::string* AdditionalModelFile::_internal_mutable_file_path()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.file_path_.Mutable(GetArenaForAllocation());
}
inline std::string* AdditionalModelFile::release_file_path()
{
    // @@protoc_insertion_point(field_release:optimization_guide.proto.AdditionalModelFile.file_path)
    if (!_internal_has_file_path()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.file_path_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.file_path_.IsDefault()) {
        _impl_.file_path_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void AdditionalModelFile::set_allocated_file_path(std::string* file_path)
{
    if (file_path != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.file_path_.SetAllocated(file_path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.file_path_.IsDefault()) {
        _impl_.file_path_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.AdditionalModelFile.file_path)
}

// -------------------------------------------------------------------

// ModelInfo

// optional .optimization_guide.proto.OptimizationTarget optimization_target = 1;
inline bool ModelInfo::_internal_has_optimization_target() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
    return value;
}
inline bool ModelInfo::has_optimization_target() const
{
    return _internal_has_optimization_target();
}
inline void ModelInfo::clear_optimization_target()
{
    _impl_.optimization_target_ = 0;
    _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::optimization_guide::proto::OptimizationTarget ModelInfo::_internal_optimization_target() const
{
    return static_cast<::optimization_guide::proto::OptimizationTarget>(_impl_.optimization_target_);
}
inline ::optimization_guide::proto::OptimizationTarget ModelInfo::optimization_target() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.ModelInfo.optimization_target)
    return _internal_optimization_target();
}
inline void ModelInfo::_internal_set_optimization_target(::optimization_guide::proto::OptimizationTarget value)
{
    assert(::optimization_guide::proto::OptimizationTarget_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000010u;
    _impl_.optimization_target_ = value;
}
inline void ModelInfo::set_optimization_target(::optimization_guide::proto::OptimizationTarget value)
{
    _internal_set_optimization_target(value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.ModelInfo.optimization_target)
}

// optional int64 version = 2;
inline bool ModelInfo::_internal_has_version() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    return value;
}
inline bool ModelInfo::has_version() const
{
    return _internal_has_version();
}
inline void ModelInfo::clear_version()
{
    _impl_.version_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int64_t ModelInfo::_internal_version() const
{
    return _impl_.version_;
}
inline int64_t ModelInfo::version() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.ModelInfo.version)
    return _internal_version();
}
inline void ModelInfo::_internal_set_version(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.version_ = value;
}
inline void ModelInfo::set_version(int64_t value)
{
    _internal_set_version(value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.ModelInfo.version)
}

// repeated .optimization_guide.proto.ModelEngineVersion supported_model_engine_versions = 4;
inline int ModelInfo::_internal_supported_model_engine_versions_size() const
{
    return _impl_.supported_model_engine_versions_.size();
}
inline int ModelInfo::supported_model_engine_versions_size() const
{
    return _internal_supported_model_engine_versions_size();
}
inline void ModelInfo::clear_supported_model_engine_versions()
{
    _impl_.supported_model_engine_versions_.Clear();
}
inline ::optimization_guide::proto::ModelEngineVersion ModelInfo::_internal_supported_model_engine_versions(int index) const
{
    return static_cast<::optimization_guide::proto::ModelEngineVersion>(_impl_.supported_model_engine_versions_.Get(index));
}
inline ::optimization_guide::proto::ModelEngineVersion ModelInfo::supported_model_engine_versions(int index) const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.ModelInfo.supported_model_engine_versions)
    return _internal_supported_model_engine_versions(index);
}
inline void ModelInfo::set_supported_model_engine_versions(int index, ::optimization_guide::proto::ModelEngineVersion value)
{
    assert(::optimization_guide::proto::ModelEngineVersion_IsValid(value));
    _impl_.supported_model_engine_versions_.Set(index, value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.ModelInfo.supported_model_engine_versions)
}
inline void ModelInfo::_internal_add_supported_model_engine_versions(::optimization_guide::proto::ModelEngineVersion value)
{
    assert(::optimization_guide::proto::ModelEngineVersion_IsValid(value));
    _impl_.supported_model_engine_versions_.Add(value);
}
inline void ModelInfo::add_supported_model_engine_versions(::optimization_guide::proto::ModelEngineVersion value)
{
    _internal_add_supported_model_engine_versions(value);
    // @@protoc_insertion_point(field_add:optimization_guide.proto.ModelInfo.supported_model_engine_versions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& ModelInfo::supported_model_engine_versions() const
{
    // @@protoc_insertion_point(field_list:optimization_guide.proto.ModelInfo.supported_model_engine_versions)
    return _impl_.supported_model_engine_versions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* ModelInfo::_internal_mutable_supported_model_engine_versions()
{
    return &_impl_.supported_model_engine_versions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* ModelInfo::mutable_supported_model_engine_versions()
{
    // @@protoc_insertion_point(field_mutable_list:optimization_guide.proto.ModelInfo.supported_model_engine_versions)
    return _internal_mutable_supported_model_engine_versions();
}

// repeated string supported_host_model_features = 5;
inline int ModelInfo::_internal_supported_host_model_features_size() const
{
    return _impl_.supported_host_model_features_.size();
}
inline int ModelInfo::supported_host_model_features_size() const
{
    return _internal_supported_host_model_features_size();
}
inline void ModelInfo::clear_supported_host_model_features()
{
    _impl_.supported_host_model_features_.Clear();
}
inline std::string* ModelInfo::add_supported_host_model_features()
{
    std::string* _s = _internal_add_supported_host_model_features();
    // @@protoc_insertion_point(field_add_mutable:optimization_guide.proto.ModelInfo.supported_host_model_features)
    return _s;
}
inline const std::string& ModelInfo::_internal_supported_host_model_features(int index) const
{
    return _impl_.supported_host_model_features_.Get(index);
}
inline const std::string& ModelInfo::supported_host_model_features(int index) const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.ModelInfo.supported_host_model_features)
    return _internal_supported_host_model_features(index);
}
inline std::string* ModelInfo::mutable_supported_host_model_features(int index)
{
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.ModelInfo.supported_host_model_features)
    return _impl_.supported_host_model_features_.Mutable(index);
}
inline void ModelInfo::set_supported_host_model_features(int index, const std::string& value)
{
    _impl_.supported_host_model_features_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.ModelInfo.supported_host_model_features)
}
inline void ModelInfo::set_supported_host_model_features(int index, std::string&& value)
{
    _impl_.supported_host_model_features_.Mutable(index)->assign(std::move(value));
    // @@protoc_insertion_point(field_set:optimization_guide.proto.ModelInfo.supported_host_model_features)
}
inline void ModelInfo::set_supported_host_model_features(int index, const char* value)
{
    GOOGLE_DCHECK(value != nullptr);
    _impl_.supported_host_model_features_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set_char:optimization_guide.proto.ModelInfo.supported_host_model_features)
}
inline void ModelInfo::set_supported_host_model_features(int index, const char* value, size_t size)
{
    _impl_.supported_host_model_features_.Mutable(index)->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:optimization_guide.proto.ModelInfo.supported_host_model_features)
}
inline std::string* ModelInfo::_internal_add_supported_host_model_features()
{
    return _impl_.supported_host_model_features_.Add();
}
inline void ModelInfo::add_supported_host_model_features(const std::string& value)
{
    _impl_.supported_host_model_features_.Add()->assign(value);
    // @@protoc_insertion_point(field_add:optimization_guide.proto.ModelInfo.supported_host_model_features)
}
inline void ModelInfo::add_supported_host_model_features(std::string&& value)
{
    _impl_.supported_host_model_features_.Add(std::move(value));
    // @@protoc_insertion_point(field_add:optimization_guide.proto.ModelInfo.supported_host_model_features)
}
inline void ModelInfo::add_supported_host_model_features(const char* value)
{
    GOOGLE_DCHECK(value != nullptr);
    _impl_.supported_host_model_features_.Add()->assign(value);
    // @@protoc_insertion_point(field_add_char:optimization_guide.proto.ModelInfo.supported_host_model_features)
}
inline void ModelInfo::add_supported_host_model_features(const char* value, size_t size)
{
    _impl_.supported_host_model_features_.Add()->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_add_pointer:optimization_guide.proto.ModelInfo.supported_host_model_features)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& ModelInfo::supported_host_model_features() const
{
    // @@protoc_insertion_point(field_list:optimization_guide.proto.ModelInfo.supported_host_model_features)
    return _impl_.supported_host_model_features_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* ModelInfo::mutable_supported_host_model_features()
{
    // @@protoc_insertion_point(field_mutable_list:optimization_guide.proto.ModelInfo.supported_host_model_features)
    return &_impl_.supported_host_model_features_;
}

// repeated .optimization_guide.proto.AdditionalModelFile additional_files = 7;
inline int ModelInfo::_internal_additional_files_size() const
{
    return _impl_.additional_files_.size();
}
inline int ModelInfo::additional_files_size() const
{
    return _internal_additional_files_size();
}
inline void ModelInfo::clear_additional_files()
{
    _impl_.additional_files_.Clear();
}
inline ::optimization_guide::proto::AdditionalModelFile* ModelInfo::mutable_additional_files(int index)
{
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.ModelInfo.additional_files)
    return _impl_.additional_files_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::AdditionalModelFile>* ModelInfo::mutable_additional_files()
{
    // @@protoc_insertion_point(field_mutable_list:optimization_guide.proto.ModelInfo.additional_files)
    return &_impl_.additional_files_;
}
inline const ::optimization_guide::proto::AdditionalModelFile& ModelInfo::_internal_additional_files(int index) const
{
    return _impl_.additional_files_.Get(index);
}
inline const ::optimization_guide::proto::AdditionalModelFile& ModelInfo::additional_files(int index) const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.ModelInfo.additional_files)
    return _internal_additional_files(index);
}
inline ::optimization_guide::proto::AdditionalModelFile* ModelInfo::_internal_add_additional_files()
{
    return _impl_.additional_files_.Add();
}
inline ::optimization_guide::proto::AdditionalModelFile* ModelInfo::add_additional_files()
{
    ::optimization_guide::proto::AdditionalModelFile* _add = _internal_add_additional_files();
    // @@protoc_insertion_point(field_add:optimization_guide.proto.ModelInfo.additional_files)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::AdditionalModelFile>& ModelInfo::additional_files() const
{
    // @@protoc_insertion_point(field_list:optimization_guide.proto.ModelInfo.additional_files)
    return _impl_.additional_files_;
}

// optional .optimization_guide.proto.Duration valid_duration = 8;
inline bool ModelInfo::_internal_has_valid_duration() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.valid_duration_ != nullptr);
    return value;
}
inline bool ModelInfo::has_valid_duration() const
{
    return _internal_has_valid_duration();
}
inline const ::optimization_guide::proto::Duration& ModelInfo::_internal_valid_duration() const
{
    const ::optimization_guide::proto::Duration* p = _impl_.valid_duration_;
    return p != nullptr ? *p : reinterpret_cast<const ::optimization_guide::proto::Duration&>(::optimization_guide::proto::_Duration_default_instance_);
}
inline const ::optimization_guide::proto::Duration& ModelInfo::valid_duration() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.ModelInfo.valid_duration)
    return _internal_valid_duration();
}
inline void ModelInfo::unsafe_arena_set_allocated_valid_duration(::optimization_guide::proto::Duration* valid_duration)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.valid_duration_);
    }
    _impl_.valid_duration_ = valid_duration;
    if (valid_duration) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:optimization_guide.proto.ModelInfo.valid_duration)
}
inline ::optimization_guide::proto::Duration* ModelInfo::release_valid_duration()
{
    _impl_._has_bits_[0] &= ~0x00000002u;
    ::optimization_guide::proto::Duration* temp = _impl_.valid_duration_;
    _impl_.valid_duration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::optimization_guide::proto::Duration* ModelInfo::unsafe_arena_release_valid_duration()
{
    // @@protoc_insertion_point(field_release:optimization_guide.proto.ModelInfo.valid_duration)
    _impl_._has_bits_[0] &= ~0x00000002u;
    ::optimization_guide::proto::Duration* temp = _impl_.valid_duration_;
    _impl_.valid_duration_ = nullptr;
    return temp;
}
inline ::optimization_guide::proto::Duration* ModelInfo::_internal_mutable_valid_duration()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    if (_impl_.valid_duration_ == nullptr) {
        auto* p = CreateMaybeMessage<::optimization_guide::proto::Duration>(GetArenaForAllocation());
        _impl_.valid_duration_ = p;
    }
    return _impl_.valid_duration_;
}
inline ::optimization_guide::proto::Duration* ModelInfo::mutable_valid_duration()
{
    ::optimization_guide::proto::Duration* _msg = _internal_mutable_valid_duration();
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.ModelInfo.valid_duration)
    return _msg;
}
inline void ModelInfo::set_allocated_valid_duration(::optimization_guide::proto::Duration* valid_duration)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.valid_duration_);
    }
    if (valid_duration) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena
            = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(valid_duration));
        if (message_arena != submessage_arena) {
            valid_duration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, valid_duration, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.valid_duration_ = valid_duration;
    // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.ModelInfo.valid_duration)
}

// optional bool keep_beyond_valid_duration = 9;
inline bool ModelInfo::_internal_has_keep_beyond_valid_duration() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
    return value;
}
inline bool ModelInfo::has_keep_beyond_valid_duration() const
{
    return _internal_has_keep_beyond_valid_duration();
}
inline void ModelInfo::clear_keep_beyond_valid_duration()
{
    _impl_.keep_beyond_valid_duration_ = false;
    _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool ModelInfo::_internal_keep_beyond_valid_duration() const
{
    return _impl_.keep_beyond_valid_duration_;
}
inline bool ModelInfo::keep_beyond_valid_duration() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.ModelInfo.keep_beyond_valid_duration)
    return _internal_keep_beyond_valid_duration();
}
inline void ModelInfo::_internal_set_keep_beyond_valid_duration(bool value)
{
    _impl_._has_bits_[0] |= 0x00000020u;
    _impl_.keep_beyond_valid_duration_ = value;
}
inline void ModelInfo::set_keep_beyond_valid_duration(bool value)
{
    _internal_set_keep_beyond_valid_duration(value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.ModelInfo.keep_beyond_valid_duration)
}

// optional .optimization_guide.proto.Any model_metadata = 6;
inline bool ModelInfo::_internal_has_model_metadata() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.model_metadata_ != nullptr);
    return value;
}
inline bool ModelInfo::has_model_metadata() const
{
    return _internal_has_model_metadata();
}
inline const ::optimization_guide::proto::Any& ModelInfo::_internal_model_metadata() const
{
    const ::optimization_guide::proto::Any* p = _impl_.model_metadata_;
    return p != nullptr ? *p : reinterpret_cast<const ::optimization_guide::proto::Any&>(::optimization_guide::proto::_Any_default_instance_);
}
inline const ::optimization_guide::proto::Any& ModelInfo::model_metadata() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.ModelInfo.model_metadata)
    return _internal_model_metadata();
}
inline void ModelInfo::unsafe_arena_set_allocated_model_metadata(::optimization_guide::proto::Any* model_metadata)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.model_metadata_);
    }
    _impl_.model_metadata_ = model_metadata;
    if (model_metadata) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:optimization_guide.proto.ModelInfo.model_metadata)
}
inline ::optimization_guide::proto::Any* ModelInfo::release_model_metadata()
{
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::optimization_guide::proto::Any* temp = _impl_.model_metadata_;
    _impl_.model_metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::optimization_guide::proto::Any* ModelInfo::unsafe_arena_release_model_metadata()
{
    // @@protoc_insertion_point(field_release:optimization_guide.proto.ModelInfo.model_metadata)
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::optimization_guide::proto::Any* temp = _impl_.model_metadata_;
    _impl_.model_metadata_ = nullptr;
    return temp;
}
inline ::optimization_guide::proto::Any* ModelInfo::_internal_mutable_model_metadata()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    if (_impl_.model_metadata_ == nullptr) {
        auto* p = CreateMaybeMessage<::optimization_guide::proto::Any>(GetArenaForAllocation());
        _impl_.model_metadata_ = p;
    }
    return _impl_.model_metadata_;
}
inline ::optimization_guide::proto::Any* ModelInfo::mutable_model_metadata()
{
    ::optimization_guide::proto::Any* _msg = _internal_mutable_model_metadata();
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.ModelInfo.model_metadata)
    return _msg;
}
inline void ModelInfo::set_allocated_model_metadata(::optimization_guide::proto::Any* model_metadata)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.model_metadata_);
    }
    if (model_metadata) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena
            = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(model_metadata));
        if (message_arena != submessage_arena) {
            model_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, model_metadata, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.model_metadata_ = model_metadata;
    // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.ModelInfo.model_metadata)
}

// optional .optimization_guide.proto.ModelCacheKey model_cache_key = 10;
inline bool ModelInfo::_internal_has_model_cache_key() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.model_cache_key_ != nullptr);
    return value;
}
inline bool ModelInfo::has_model_cache_key() const
{
    return _internal_has_model_cache_key();
}
inline void ModelInfo::clear_model_cache_key()
{
    if (_impl_.model_cache_key_ != nullptr)
        _impl_.model_cache_key_->Clear();
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::optimization_guide::proto::ModelCacheKey& ModelInfo::_internal_model_cache_key() const
{
    const ::optimization_guide::proto::ModelCacheKey* p = _impl_.model_cache_key_;
    return p != nullptr ? *p
                        : reinterpret_cast<const ::optimization_guide::proto::ModelCacheKey&>(::optimization_guide::proto::_ModelCacheKey_default_instance_);
}
inline const ::optimization_guide::proto::ModelCacheKey& ModelInfo::model_cache_key() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.ModelInfo.model_cache_key)
    return _internal_model_cache_key();
}
inline void ModelInfo::unsafe_arena_set_allocated_model_cache_key(::optimization_guide::proto::ModelCacheKey* model_cache_key)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.model_cache_key_);
    }
    _impl_.model_cache_key_ = model_cache_key;
    if (model_cache_key) {
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:optimization_guide.proto.ModelInfo.model_cache_key)
}
inline ::optimization_guide::proto::ModelCacheKey* ModelInfo::release_model_cache_key()
{
    _impl_._has_bits_[0] &= ~0x00000004u;
    ::optimization_guide::proto::ModelCacheKey* temp = _impl_.model_cache_key_;
    _impl_.model_cache_key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::optimization_guide::proto::ModelCacheKey* ModelInfo::unsafe_arena_release_model_cache_key()
{
    // @@protoc_insertion_point(field_release:optimization_guide.proto.ModelInfo.model_cache_key)
    _impl_._has_bits_[0] &= ~0x00000004u;
    ::optimization_guide::proto::ModelCacheKey* temp = _impl_.model_cache_key_;
    _impl_.model_cache_key_ = nullptr;
    return temp;
}
inline ::optimization_guide::proto::ModelCacheKey* ModelInfo::_internal_mutable_model_cache_key()
{
    _impl_._has_bits_[0] |= 0x00000004u;
    if (_impl_.model_cache_key_ == nullptr) {
        auto* p = CreateMaybeMessage<::optimization_guide::proto::ModelCacheKey>(GetArenaForAllocation());
        _impl_.model_cache_key_ = p;
    }
    return _impl_.model_cache_key_;
}
inline ::optimization_guide::proto::ModelCacheKey* ModelInfo::mutable_model_cache_key()
{
    ::optimization_guide::proto::ModelCacheKey* _msg = _internal_mutable_model_cache_key();
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.ModelInfo.model_cache_key)
    return _msg;
}
inline void ModelInfo::set_allocated_model_cache_key(::optimization_guide::proto::ModelCacheKey* model_cache_key)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.model_cache_key_;
    }
    if (model_cache_key) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(model_cache_key);
        if (message_arena != submessage_arena) {
            model_cache_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, model_cache_key, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    _impl_.model_cache_key_ = model_cache_key;
    // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.ModelInfo.model_cache_key)
}

// -------------------------------------------------------------------

// ModelCacheKey

// optional string locale = 1;
inline bool ModelCacheKey::_internal_has_locale() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool ModelCacheKey::has_locale() const
{
    return _internal_has_locale();
}
inline void ModelCacheKey::clear_locale()
{
    _impl_.locale_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ModelCacheKey::locale() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.ModelCacheKey.locale)
    return _internal_locale();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ModelCacheKey::set_locale(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.locale_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:optimization_guide.proto.ModelCacheKey.locale)
}
inline std::string* ModelCacheKey::mutable_locale()
{
    std::string* _s = _internal_mutable_locale();
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.ModelCacheKey.locale)
    return _s;
}
inline const std::string& ModelCacheKey::_internal_locale() const
{
    return _impl_.locale_.Get();
}
inline void ModelCacheKey::_internal_set_locale(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.locale_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelCacheKey::_internal_mutable_locale()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.locale_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelCacheKey::release_locale()
{
    // @@protoc_insertion_point(field_release:optimization_guide.proto.ModelCacheKey.locale)
    if (!_internal_has_locale()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.locale_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.locale_.IsDefault()) {
        _impl_.locale_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ModelCacheKey::set_allocated_locale(std::string* locale)
{
    if (locale != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.locale_.SetAllocated(locale, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.locale_.IsDefault()) {
        _impl_.locale_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.ModelCacheKey.locale)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// @@protoc_insertion_point(namespace_scope)

} // namespace proto
} // namespace optimization_guide

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum<::optimization_guide::proto::OptimizationTarget> : ::std::true_type { };
template <> struct is_proto_enum<::optimization_guide::proto::ModelEngineVersion> : ::std::true_type { };

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_components_2foptimization_5fguide_2fproto_2fmodels_2eproto
