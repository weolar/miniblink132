// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/optimization_guide/proto/models.proto

#include "components/optimization_guide/proto/models.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace optimization_guide {
namespace proto {
PROTOBUF_CONSTEXPR Model::Model(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.model_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_._oneof_case_)*/ {} }
{
}
struct ModelDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ModelDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ModelDefaultTypeInternal()
    {
    }
    union {
        Model _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModelDefaultTypeInternal _Model_default_instance_;
PROTOBUF_CONSTEXPR GetModelsRequest::GetModelsRequest(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.requested_models_)*/ {},
        /*decltype(_impl_.locale_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.origin_info_)*/ nullptr,
        /*decltype(_impl_.request_context_)*/ 0 }
{
}
struct GetModelsRequestDefaultTypeInternal {
    PROTOBUF_CONSTEXPR GetModelsRequestDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~GetModelsRequestDefaultTypeInternal()
    {
    }
    union {
        GetModelsRequest _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetModelsRequestDefaultTypeInternal _GetModelsRequest_default_instance_;
PROTOBUF_CONSTEXPR GetModelsResponse::GetModelsResponse(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.models_)*/ {}, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct GetModelsResponseDefaultTypeInternal {
    PROTOBUF_CONSTEXPR GetModelsResponseDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~GetModelsResponseDefaultTypeInternal()
    {
    }
    union {
        GetModelsResponse _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetModelsResponseDefaultTypeInternal _GetModelsResponse_default_instance_;
PROTOBUF_CONSTEXPR PredictionModel::PredictionModel(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.model_info_)*/ nullptr,
        /*decltype(_impl_.model_)*/ nullptr }
{
}
struct PredictionModelDefaultTypeInternal {
    PROTOBUF_CONSTEXPR PredictionModelDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~PredictionModelDefaultTypeInternal()
    {
    }
    union {
        PredictionModel _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PredictionModelDefaultTypeInternal _PredictionModel_default_instance_;
PROTOBUF_CONSTEXPR AdditionalModelFile::AdditionalModelFile(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.file_path_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct AdditionalModelFileDefaultTypeInternal {
    PROTOBUF_CONSTEXPR AdditionalModelFileDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~AdditionalModelFileDefaultTypeInternal()
    {
    }
    union {
        AdditionalModelFile _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AdditionalModelFileDefaultTypeInternal
    _AdditionalModelFile_default_instance_;
PROTOBUF_CONSTEXPR ModelInfo::ModelInfo(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.supported_model_engine_versions_)*/ {},
        /*decltype(_impl_.supported_host_model_features_)*/ {}, /*decltype(_impl_.additional_files_)*/ {}, /*decltype(_impl_.model_metadata_)*/ nullptr,
        /*decltype(_impl_.valid_duration_)*/ nullptr, /*decltype(_impl_.model_cache_key_)*/ nullptr, /*decltype(_impl_.version_)*/ int64_t { 0 },
        /*decltype(_impl_.optimization_target_)*/ 0, /*decltype(_impl_.keep_beyond_valid_duration_)*/ false }
{
}
struct ModelInfoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ModelInfoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ModelInfoDefaultTypeInternal()
    {
    }
    union {
        ModelInfo _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModelInfoDefaultTypeInternal _ModelInfo_default_instance_;
PROTOBUF_CONSTEXPR ModelCacheKey::ModelCacheKey(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.locale_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct ModelCacheKeyDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ModelCacheKeyDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ModelCacheKeyDefaultTypeInternal()
    {
    }
    union {
        ModelCacheKey _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModelCacheKeyDefaultTypeInternal _ModelCacheKey_default_instance_;
} // namespace proto
} // namespace optimization_guide
namespace optimization_guide {
namespace proto {
bool OptimizationTarget_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> OptimizationTarget_strings[54] = {};

static const char OptimizationTarget_names[] = "OPTIMIZATION_TARGET_AUTOFILL_FIELD_CLASSIFICATION"
                                               "OPTIMIZATION_TARGET_CAMERA_BACKGROUND_SEGMENTATION"
                                               "OPTIMIZATION_TARGET_CLIENT_SIDE_PHISHING"
                                               "OPTIMIZATION_TARGET_CLIENT_SIDE_PHISHING_IMAGE_EMBEDDER"
                                               "OPTIMIZATION_TARGET_COMPOSE"
                                               "OPTIMIZATION_TARGET_CONTEXTUAL_PAGE_ACTION_PRICE_TRACKING"
                                               "OPTIMIZATION_TARGET_GEOLOCATION_PERMISSION_PREDICTIONS"
                                               "OPTIMIZATION_TARGET_LANGUAGE_DETECTION"
                                               "OPTIMIZATION_TARGET_MODEL_EXECUTION_FEATURE_HISTORY_QUERY_INTENT"
                                               "OPTIMIZATION_TARGET_MODEL_EXECUTION_FEATURE_HISTORY_SEARCH"
                                               "OPTIMIZATION_TARGET_MODEL_EXECUTION_FEATURE_PROMPT_API"
                                               "OPTIMIZATION_TARGET_MODEL_EXECUTION_FEATURE_SUMMARIZE"
                                               "OPTIMIZATION_TARGET_MODEL_VALIDATION"
                                               "OPTIMIZATION_TARGET_NEW_TAB_PAGE_HISTORY_CLUSTERS_MODULE_RANKING"
                                               "OPTIMIZATION_TARGET_NOTIFICATION_CONTENT_DETECTION"
                                               "OPTIMIZATION_TARGET_NOTIFICATION_PERMISSION_PREDICTIONS"
                                               "OPTIMIZATION_TARGET_OMNIBOX_ON_DEVICE_TAIL_SUGGEST"
                                               "OPTIMIZATION_TARGET_OMNIBOX_URL_SCORING"
                                               "OPTIMIZATION_TARGET_PAGE_ENTITIES"
                                               "OPTIMIZATION_TARGET_PAGE_TOPICS"
                                               "OPTIMIZATION_TARGET_PAGE_TOPICS_V2"
                                               "OPTIMIZATION_TARGET_PAGE_VISIBILITY"
                                               "OPTIMIZATION_TARGET_PAINFUL_PAGE_LOAD"
                                               "OPTIMIZATION_TARGET_PASSAGE_EMBEDDER"
                                               "OPTIMIZATION_TARGET_PASSWORD_MANAGER_FORM_CLASSIFICATION"
                                               "OPTIMIZATION_TARGET_PHRASE_SEGMENTATION"
                                               "OPTIMIZATION_TARGET_PRELOADING_HEURISTICS"
                                               "OPTIMIZATION_TARGET_SEGMENTATION_ADAPTIVE_TOOLBAR"
                                               "OPTIMIZATION_TARGET_SEGMENTATION_ANDROID_HOME_MODULE_RANKER"
                                               "OPTIMIZATION_TARGET_SEGMENTATION_BOTTOM_TOOLBAR"
                                               "OPTIMIZATION_TARGET_SEGMENTATION_CHROME_LOW_USER_ENGAGEMENT"
                                               "OPTIMIZATION_TARGET_SEGMENTATION_CHROME_START_ANDROID"
                                               "OPTIMIZATION_TARGET_SEGMENTATION_CHROME_START_ANDROID_V2"
                                               "OPTIMIZATION_TARGET_SEGMENTATION_COMPOSE_PROMOTION"
                                               "OPTIMIZATION_TARGET_SEGMENTATION_DESKTOP_NTP_MODULE"
                                               "OPTIMIZATION_TARGET_SEGMENTATION_DEVICE_SWITCHER"
                                               "OPTIMIZATION_TARGET_SEGMENTATION_DUMMY"
                                               "OPTIMIZATION_TARGET_SEGMENTATION_FEED_USER"
                                               "OPTIMIZATION_TARGET_SEGMENTATION_IOS_MODULE_RANKER"
                                               "OPTIMIZATION_TARGET_SEGMENTATION_METRICS_CLUSTERING"
                                               "OPTIMIZATION_TARGET_SEGMENTATION_NEW_TAB"
                                               "OPTIMIZATION_TARGET_SEGMENTATION_QUERY_TILES"
                                               "OPTIMIZATION_TARGET_SEGMENTATION_SEARCH_USER"
                                               "OPTIMIZATION_TARGET_SEGMENTATION_SHARE"
                                               "OPTIMIZATION_TARGET_SEGMENTATION_SHOPPING_USER"
                                               "OPTIMIZATION_TARGET_SEGMENTATION_TABLET_PRODUCTIVITY_USER"
                                               "OPTIMIZATION_TARGET_SEGMENTATION_VOICE"
                                               "OPTIMIZATION_TARGET_TEXT_CLASSIFIER"
                                               "OPTIMIZATION_TARGET_TEXT_EMBEDDER"
                                               "OPTIMIZATION_TARGET_TEXT_SAFETY"
                                               "OPTIMIZATION_TARGET_UNKNOWN"
                                               "OPTIMIZATION_TARGET_URL_VISIT_RESUMPTION_RANKER"
                                               "OPTIMIZATION_TARGET_VISUAL_SEARCH_CLASSIFICATION"
                                               "OPTIMIZATION_TARGET_WEB_APP_INSTALLATION_PROMO";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry OptimizationTarget_entries[] = {
    { { OptimizationTarget_names + 0, 49 }, 36 },
    { { OptimizationTarget_names + 49, 50 }, 47 },
    { { OptimizationTarget_names + 99, 40 }, 25 },
    { { OptimizationTarget_names + 139, 55 }, 30 },
    { { OptimizationTarget_names + 194, 27 }, 42 },
    { { OptimizationTarget_names + 221, 57 }, 18 },
    { { OptimizationTarget_names + 278, 54 }, 20 },
    { { OptimizationTarget_names + 332, 38 }, 2 },
    { { OptimizationTarget_names + 370, 64 }, 54 },
    { { OptimizationTarget_names + 434, 58 }, 48 },
    { { OptimizationTarget_names + 492, 54 }, 49 },
    { { OptimizationTarget_names + 546, 53 }, 51 },
    { { OptimizationTarget_names + 599, 36 }, 7 },
    { { OptimizationTarget_names + 635, 64 }, 31 },
    { { OptimizationTarget_names + 699, 50 }, 53 },
    { { OptimizationTarget_names + 749, 55 }, 9 },
    { { OptimizationTarget_names + 804, 50 }, 24 },
    { { OptimizationTarget_names + 854, 39 }, 26 },
    { { OptimizationTarget_names + 893, 33 }, 8 },
    { { OptimizationTarget_names + 926, 31 }, 3 },
    { { OptimizationTarget_names + 957, 34 }, 15 },
    { { OptimizationTarget_names + 991, 35 }, 13 },
    { { OptimizationTarget_names + 1026, 37 }, 1 },
    { { OptimizationTarget_names + 1063, 36 }, 43 },
    { { OptimizationTarget_names + 1099, 56 }, 52 },
    { { OptimizationTarget_names + 1155, 39 }, 44 },
    { { OptimizationTarget_names + 1194, 41 }, 39 },
    { { OptimizationTarget_names + 1235, 49 }, 28 },
    { { OptimizationTarget_names + 1284, 59 }, 41 },
    { { OptimizationTarget_names + 1343, 47 }, 35 },
    { { OptimizationTarget_names + 1390, 59 }, 16 },
    { { OptimizationTarget_names + 1449, 53 }, 11 },
    { { OptimizationTarget_names + 1502, 56 }, 22 },
    { { OptimizationTarget_names + 1558, 50 }, 45 },
    { { OptimizationTarget_names + 1608, 51 }, 38 },
    { { OptimizationTarget_names + 1659, 48 }, 27 },
    { { OptimizationTarget_names + 1707, 38 }, 10 },
    { { OptimizationTarget_names + 1745, 42 }, 17 },
    { { OptimizationTarget_names + 1787, 50 }, 37 },
    { { OptimizationTarget_names + 1837, 51 }, 50 },
    { { OptimizationTarget_names + 1888, 40 }, 4 },
    { { OptimizationTarget_names + 1928, 44 }, 12 },
    { { OptimizationTarget_names + 1972, 44 }, 23 },
    { { OptimizationTarget_names + 2016, 38 }, 5 },
    { { OptimizationTarget_names + 2054, 46 }, 21 },
    { { OptimizationTarget_names + 2100, 57 }, 29 },
    { { OptimizationTarget_names + 2157, 38 }, 6 },
    { { OptimizationTarget_names + 2195, 35 }, 19 },
    { { OptimizationTarget_names + 2230, 33 }, 33 },
    { { OptimizationTarget_names + 2263, 31 }, 40 },
    { { OptimizationTarget_names + 2294, 27 }, 0 },
    { { OptimizationTarget_names + 2321, 47 }, 46 },
    { { OptimizationTarget_names + 2368, 48 }, 34 },
    { { OptimizationTarget_names + 2416, 46 }, 32 },
};

static const int OptimizationTarget_entries_by_number[] = {
    50, // 0 -> OPTIMIZATION_TARGET_UNKNOWN
    22, // 1 -> OPTIMIZATION_TARGET_PAINFUL_PAGE_LOAD
    7, // 2 -> OPTIMIZATION_TARGET_LANGUAGE_DETECTION
    19, // 3 -> OPTIMIZATION_TARGET_PAGE_TOPICS
    40, // 4 -> OPTIMIZATION_TARGET_SEGMENTATION_NEW_TAB
    43, // 5 -> OPTIMIZATION_TARGET_SEGMENTATION_SHARE
    46, // 6 -> OPTIMIZATION_TARGET_SEGMENTATION_VOICE
    12, // 7 -> OPTIMIZATION_TARGET_MODEL_VALIDATION
    18, // 8 -> OPTIMIZATION_TARGET_PAGE_ENTITIES
    15, // 9 -> OPTIMIZATION_TARGET_NOTIFICATION_PERMISSION_PREDICTIONS
    36, // 10 -> OPTIMIZATION_TARGET_SEGMENTATION_DUMMY
    31, // 11 -> OPTIMIZATION_TARGET_SEGMENTATION_CHROME_START_ANDROID
    41, // 12 -> OPTIMIZATION_TARGET_SEGMENTATION_QUERY_TILES
    21, // 13 -> OPTIMIZATION_TARGET_PAGE_VISIBILITY
    20, // 15 -> OPTIMIZATION_TARGET_PAGE_TOPICS_V2
    30, // 16 -> OPTIMIZATION_TARGET_SEGMENTATION_CHROME_LOW_USER_ENGAGEMENT
    37, // 17 -> OPTIMIZATION_TARGET_SEGMENTATION_FEED_USER
    5, // 18 -> OPTIMIZATION_TARGET_CONTEXTUAL_PAGE_ACTION_PRICE_TRACKING
    47, // 19 -> OPTIMIZATION_TARGET_TEXT_CLASSIFIER
    6, // 20 -> OPTIMIZATION_TARGET_GEOLOCATION_PERMISSION_PREDICTIONS
    44, // 21 -> OPTIMIZATION_TARGET_SEGMENTATION_SHOPPING_USER
    32, // 22 -> OPTIMIZATION_TARGET_SEGMENTATION_CHROME_START_ANDROID_V2
    42, // 23 -> OPTIMIZATION_TARGET_SEGMENTATION_SEARCH_USER
    16, // 24 -> OPTIMIZATION_TARGET_OMNIBOX_ON_DEVICE_TAIL_SUGGEST
    2, // 25 -> OPTIMIZATION_TARGET_CLIENT_SIDE_PHISHING
    17, // 26 -> OPTIMIZATION_TARGET_OMNIBOX_URL_SCORING
    35, // 27 -> OPTIMIZATION_TARGET_SEGMENTATION_DEVICE_SWITCHER
    27, // 28 -> OPTIMIZATION_TARGET_SEGMENTATION_ADAPTIVE_TOOLBAR
    45, // 29 -> OPTIMIZATION_TARGET_SEGMENTATION_TABLET_PRODUCTIVITY_USER
    3, // 30 -> OPTIMIZATION_TARGET_CLIENT_SIDE_PHISHING_IMAGE_EMBEDDER
    13, // 31 -> OPTIMIZATION_TARGET_NEW_TAB_PAGE_HISTORY_CLUSTERS_MODULE_RANKING
    53, // 32 -> OPTIMIZATION_TARGET_WEB_APP_INSTALLATION_PROMO
    48, // 33 -> OPTIMIZATION_TARGET_TEXT_EMBEDDER
    52, // 34 -> OPTIMIZATION_TARGET_VISUAL_SEARCH_CLASSIFICATION
    29, // 35 -> OPTIMIZATION_TARGET_SEGMENTATION_BOTTOM_TOOLBAR
    0, // 36 -> OPTIMIZATION_TARGET_AUTOFILL_FIELD_CLASSIFICATION
    38, // 37 -> OPTIMIZATION_TARGET_SEGMENTATION_IOS_MODULE_RANKER
    34, // 38 -> OPTIMIZATION_TARGET_SEGMENTATION_DESKTOP_NTP_MODULE
    26, // 39 -> OPTIMIZATION_TARGET_PRELOADING_HEURISTICS
    49, // 40 -> OPTIMIZATION_TARGET_TEXT_SAFETY
    28, // 41 -> OPTIMIZATION_TARGET_SEGMENTATION_ANDROID_HOME_MODULE_RANKER
    4, // 42 -> OPTIMIZATION_TARGET_COMPOSE
    23, // 43 -> OPTIMIZATION_TARGET_PASSAGE_EMBEDDER
    25, // 44 -> OPTIMIZATION_TARGET_PHRASE_SEGMENTATION
    33, // 45 -> OPTIMIZATION_TARGET_SEGMENTATION_COMPOSE_PROMOTION
    51, // 46 -> OPTIMIZATION_TARGET_URL_VISIT_RESUMPTION_RANKER
    1, // 47 -> OPTIMIZATION_TARGET_CAMERA_BACKGROUND_SEGMENTATION
    9, // 48 -> OPTIMIZATION_TARGET_MODEL_EXECUTION_FEATURE_HISTORY_SEARCH
    10, // 49 -> OPTIMIZATION_TARGET_MODEL_EXECUTION_FEATURE_PROMPT_API
    39, // 50 -> OPTIMIZATION_TARGET_SEGMENTATION_METRICS_CLUSTERING
    11, // 51 -> OPTIMIZATION_TARGET_MODEL_EXECUTION_FEATURE_SUMMARIZE
    24, // 52 -> OPTIMIZATION_TARGET_PASSWORD_MANAGER_FORM_CLASSIFICATION
    14, // 53 -> OPTIMIZATION_TARGET_NOTIFICATION_CONTENT_DETECTION
    8, // 54 -> OPTIMIZATION_TARGET_MODEL_EXECUTION_FEATURE_HISTORY_QUERY_INTENT
};

const std::string& OptimizationTarget_Name(OptimizationTarget value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        OptimizationTarget_entries, OptimizationTarget_entries_by_number, 54, OptimizationTarget_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(OptimizationTarget_entries, OptimizationTarget_entries_by_number, 54, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : OptimizationTarget_strings[idx].get();
}
bool OptimizationTarget_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OptimizationTarget* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(OptimizationTarget_entries, 54, name, &int_value);
    if (success) {
        *value = static_cast<OptimizationTarget>(int_value);
    }
    return success;
}
bool ModelEngineVersion_IsValid(int value)
{
    switch (value) {
    case 0:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ModelEngineVersion_strings[18] = {};

static const char ModelEngineVersion_names[] = "MODEL_ENGINE_VERSION_TFLITE_2_10"
                                               "MODEL_ENGINE_VERSION_TFLITE_2_11"
                                               "MODEL_ENGINE_VERSION_TFLITE_2_12"
                                               "MODEL_ENGINE_VERSION_TFLITE_2_13"
                                               "MODEL_ENGINE_VERSION_TFLITE_2_14"
                                               "MODEL_ENGINE_VERSION_TFLITE_2_14_1"
                                               "MODEL_ENGINE_VERSION_TFLITE_2_16"
                                               "MODEL_ENGINE_VERSION_TFLITE_2_16_1"
                                               "MODEL_ENGINE_VERSION_TFLITE_2_17"
                                               "MODEL_ENGINE_VERSION_TFLITE_2_18"
                                               "MODEL_ENGINE_VERSION_TFLITE_2_3_0"
                                               "MODEL_ENGINE_VERSION_TFLITE_2_3_0_1"
                                               "MODEL_ENGINE_VERSION_TFLITE_2_4"
                                               "MODEL_ENGINE_VERSION_TFLITE_2_7"
                                               "MODEL_ENGINE_VERSION_TFLITE_2_8"
                                               "MODEL_ENGINE_VERSION_TFLITE_2_9"
                                               "MODEL_ENGINE_VERSION_TFLITE_2_9_0_1"
                                               "MODEL_ENGINE_VERSION_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ModelEngineVersion_entries[] = {
    { { ModelEngineVersion_names + 0, 32 }, 9 },
    { { ModelEngineVersion_names + 32, 32 }, 10 },
    { { ModelEngineVersion_names + 64, 32 }, 11 },
    { { ModelEngineVersion_names + 96, 32 }, 12 },
    { { ModelEngineVersion_names + 128, 32 }, 13 },
    { { ModelEngineVersion_names + 160, 34 }, 14 },
    { { ModelEngineVersion_names + 194, 32 }, 15 },
    { { ModelEngineVersion_names + 226, 34 }, 16 },
    { { ModelEngineVersion_names + 260, 32 }, 17 },
    { { ModelEngineVersion_names + 292, 32 }, 18 },
    { { ModelEngineVersion_names + 324, 33 }, 2 },
    { { ModelEngineVersion_names + 357, 35 }, 3 },
    { { ModelEngineVersion_names + 392, 31 }, 4 },
    { { ModelEngineVersion_names + 423, 31 }, 5 },
    { { ModelEngineVersion_names + 454, 31 }, 6 },
    { { ModelEngineVersion_names + 485, 31 }, 7 },
    { { ModelEngineVersion_names + 516, 35 }, 8 },
    { { ModelEngineVersion_names + 551, 28 }, 0 },
};

static const int ModelEngineVersion_entries_by_number[] = {
    17, // 0 -> MODEL_ENGINE_VERSION_UNKNOWN
    10, // 2 -> MODEL_ENGINE_VERSION_TFLITE_2_3_0
    11, // 3 -> MODEL_ENGINE_VERSION_TFLITE_2_3_0_1
    12, // 4 -> MODEL_ENGINE_VERSION_TFLITE_2_4
    13, // 5 -> MODEL_ENGINE_VERSION_TFLITE_2_7
    14, // 6 -> MODEL_ENGINE_VERSION_TFLITE_2_8
    15, // 7 -> MODEL_ENGINE_VERSION_TFLITE_2_9
    16, // 8 -> MODEL_ENGINE_VERSION_TFLITE_2_9_0_1
    0, // 9 -> MODEL_ENGINE_VERSION_TFLITE_2_10
    1, // 10 -> MODEL_ENGINE_VERSION_TFLITE_2_11
    2, // 11 -> MODEL_ENGINE_VERSION_TFLITE_2_12
    3, // 12 -> MODEL_ENGINE_VERSION_TFLITE_2_13
    4, // 13 -> MODEL_ENGINE_VERSION_TFLITE_2_14
    5, // 14 -> MODEL_ENGINE_VERSION_TFLITE_2_14_1
    6, // 15 -> MODEL_ENGINE_VERSION_TFLITE_2_16
    7, // 16 -> MODEL_ENGINE_VERSION_TFLITE_2_16_1
    8, // 17 -> MODEL_ENGINE_VERSION_TFLITE_2_17
    9, // 18 -> MODEL_ENGINE_VERSION_TFLITE_2_18
};

const std::string& ModelEngineVersion_Name(ModelEngineVersion value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        ModelEngineVersion_entries, ModelEngineVersion_entries_by_number, 18, ModelEngineVersion_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(ModelEngineVersion_entries, ModelEngineVersion_entries_by_number, 18, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : ModelEngineVersion_strings[idx].get();
}
bool ModelEngineVersion_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ModelEngineVersion* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(ModelEngineVersion_entries, 18, name, &int_value);
    if (success) {
        *value = static_cast<ModelEngineVersion>(int_value);
    }
    return success;
}

// ===================================================================

class Model::_Internal {
public:
};

Model::Model(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:optimization_guide.proto.Model)
}
Model::Model(const Model& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    Model* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.model_) {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_._oneof_case_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    clear_has_model();
    switch (from.model_case()) {
    case kDownloadUrl: {
        _this->_internal_set_download_url(from._internal_download_url());
        break;
    }
    case MODEL_NOT_SET: {
        break;
    }
    }
    // @@protoc_insertion_point(copy_constructor:optimization_guide.proto.Model)
}

inline void Model::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.model_) {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_._oneof_case_)*/ {} };
    clear_has_model();
}

Model::~Model()
{
    // @@protoc_insertion_point(destructor:optimization_guide.proto.Model)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void Model::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (has_model()) {
        clear_model();
    }
}

void Model::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void Model::clear_model()
{
    // @@protoc_insertion_point(one_of_clear_start:optimization_guide.proto.Model)
    switch (model_case()) {
    case kDownloadUrl: {
        _impl_.model_.download_url_.Destroy();
        break;
    }
    case MODEL_NOT_SET: {
        break;
    }
    }
    _impl_._oneof_case_[0] = MODEL_NOT_SET;
}

void Model::Clear()
{
    // @@protoc_insertion_point(message_clear_start:optimization_guide.proto.Model)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    clear_model();
    _internal_metadata_.Clear<std::string>();
}

const char* Model::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // string download_url = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                auto str = _internal_mutable_download_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* Model::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:optimization_guide.proto.Model)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // string download_url = 5;
    if (_internal_has_download_url()) {
        target = stream->WriteStringMaybeAliased(5, this->_internal_download_url(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:optimization_guide.proto.Model)
    return target;
}

size_t Model::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:optimization_guide.proto.Model)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    switch (model_case()) {
    // string download_url = 5;
    case kDownloadUrl: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_download_url());
        break;
    }
    case MODEL_NOT_SET: {
        break;
    }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void Model::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const Model*>(&from));
}

void Model::MergeFrom(const Model& from)
{
    Model* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:optimization_guide.proto.Model)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    switch (from.model_case()) {
    case kDownloadUrl: {
        _this->_internal_set_download_url(from._internal_download_url());
        break;
    }
    case MODEL_NOT_SET: {
        break;
    }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Model::CopyFrom(const Model& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:optimization_guide.proto.Model)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool Model::IsInitialized() const
{
    return true;
}

void Model::InternalSwap(Model* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_.model_, other->_impl_.model_);
    swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

std::string Model::GetTypeName() const
{
    return "optimization_guide.proto.Model";
}

// ===================================================================

class GetModelsRequest::_Internal {
public:
    using HasBits = decltype(std::declval<GetModelsRequest>()._impl_._has_bits_);
    static void set_has_request_context(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_locale(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static const ::optimization_guide::proto::OriginInfo& origin_info(const GetModelsRequest* msg);
    static void set_has_origin_info(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

const ::optimization_guide::proto::OriginInfo& GetModelsRequest::_Internal::origin_info(const GetModelsRequest* msg)
{
    return *msg->_impl_.origin_info_;
}
void GetModelsRequest::clear_origin_info()
{
    if (_impl_.origin_info_ != nullptr)
        _impl_.origin_info_->Clear();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
GetModelsRequest::GetModelsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:optimization_guide.proto.GetModelsRequest)
}
GetModelsRequest::GetModelsRequest(const GetModelsRequest& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    GetModelsRequest* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.requested_models_) { from._impl_.requested_models_ }, decltype(_impl_.locale_) {}, decltype(_impl_.origin_info_) { nullptr },
        decltype(_impl_.request_context_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.locale_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.locale_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_locale()) {
        _this->_impl_.locale_.Set(from._internal_locale(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_origin_info()) {
        _this->_impl_.origin_info_ = new ::optimization_guide::proto::OriginInfo(*from._impl_.origin_info_);
    }
    _this->_impl_.request_context_ = from._impl_.request_context_;
    // @@protoc_insertion_point(copy_constructor:optimization_guide.proto.GetModelsRequest)
}

inline void GetModelsRequest::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.requested_models_) { arena },
        decltype(_impl_.locale_) {}, decltype(_impl_.origin_info_) { nullptr }, decltype(_impl_.request_context_) { 0 } };
    _impl_.locale_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.locale_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GetModelsRequest::~GetModelsRequest()
{
    // @@protoc_insertion_point(destructor:optimization_guide.proto.GetModelsRequest)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void GetModelsRequest::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.requested_models_.~RepeatedPtrField();
    _impl_.locale_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.origin_info_;
}

void GetModelsRequest::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void GetModelsRequest::Clear()
{
    // @@protoc_insertion_point(message_clear_start:optimization_guide.proto.GetModelsRequest)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.requested_models_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.locale_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            GOOGLE_DCHECK(_impl_.origin_info_ != nullptr);
            _impl_.origin_info_->Clear();
        }
    }
    _impl_.request_context_ = 0;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* GetModelsRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .optimization_guide.proto.ModelInfo requested_models = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_requested_models(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional .optimization_guide.proto.RequestContext request_context = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::optimization_guide::proto::RequestContext_IsValid(val))) {
                    _internal_set_request_context(static_cast<::optimization_guide::proto::RequestContext>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional string locale = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                auto str = _internal_mutable_locale();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .optimization_guide.proto.OriginInfo origin_info = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
                ptr = ctx->ParseMessage(_internal_mutable_origin_info(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* GetModelsRequest::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:optimization_guide.proto.GetModelsRequest)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .optimization_guide.proto.ModelInfo requested_models = 1;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_requested_models_size()); i < n; i++) {
        const auto& repfield = this->_internal_requested_models(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
    }

    cached_has_bits = _impl_._has_bits_[0];
    // optional .optimization_guide.proto.RequestContext request_context = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(3, this->_internal_request_context(), target);
    }

    // optional string locale = 5;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(5, this->_internal_locale(), target);
    }

    // optional .optimization_guide.proto.OriginInfo origin_info = 6;
    if (cached_has_bits & 0x00000002u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            6, _Internal::origin_info(this), _Internal::origin_info(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:optimization_guide.proto.GetModelsRequest)
    return target;
}

size_t GetModelsRequest::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:optimization_guide.proto.GetModelsRequest)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .optimization_guide.proto.ModelInfo requested_models = 1;
    total_size += 1UL * this->_internal_requested_models_size();
    for (const auto& msg : this->_impl_.requested_models_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional string locale = 5;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_locale());
        }

        // optional .optimization_guide.proto.OriginInfo origin_info = 6;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.origin_info_);
        }

        // optional .optimization_guide.proto.RequestContext request_context = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_request_context());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void GetModelsRequest::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const GetModelsRequest*>(&from));
}

void GetModelsRequest::MergeFrom(const GetModelsRequest& from)
{
    GetModelsRequest* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:optimization_guide.proto.GetModelsRequest)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.requested_models_.MergeFrom(from._impl_.requested_models_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_locale(from._internal_locale());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_mutable_origin_info()->::optimization_guide::proto::OriginInfo::MergeFrom(from._internal_origin_info());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.request_context_ = from._impl_.request_context_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GetModelsRequest::CopyFrom(const GetModelsRequest& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:optimization_guide.proto.GetModelsRequest)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool GetModelsRequest::IsInitialized() const
{
    return true;
}

void GetModelsRequest::InternalSwap(GetModelsRequest* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.requested_models_.InternalSwap(&other->_impl_.requested_models_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.locale_, lhs_arena, &other->_impl_.locale_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(GetModelsRequest, _impl_.request_context_)
        + sizeof(GetModelsRequest::_impl_.request_context_) - PROTOBUF_FIELD_OFFSET(GetModelsRequest, _impl_.origin_info_)>(
        reinterpret_cast<char*>(&_impl_.origin_info_), reinterpret_cast<char*>(&other->_impl_.origin_info_));
}

std::string GetModelsRequest::GetTypeName() const
{
    return "optimization_guide.proto.GetModelsRequest";
}

// ===================================================================

class GetModelsResponse::_Internal {
public:
};

GetModelsResponse::GetModelsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:optimization_guide.proto.GetModelsResponse)
}
GetModelsResponse::GetModelsResponse(const GetModelsResponse& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    GetModelsResponse* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.models_) { from._impl_.models_ }, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:optimization_guide.proto.GetModelsResponse)
}

inline void GetModelsResponse::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.models_) { arena }, /*decltype(_impl_._cached_size_)*/ {} };
}

GetModelsResponse::~GetModelsResponse()
{
    // @@protoc_insertion_point(destructor:optimization_guide.proto.GetModelsResponse)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void GetModelsResponse::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.models_.~RepeatedPtrField();
}

void GetModelsResponse::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void GetModelsResponse::Clear()
{
    // @@protoc_insertion_point(message_clear_start:optimization_guide.proto.GetModelsResponse)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.models_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* GetModelsResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .optimization_guide.proto.PredictionModel models = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_models(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* GetModelsResponse::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:optimization_guide.proto.GetModelsResponse)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .optimization_guide.proto.PredictionModel models = 1;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_models_size()); i < n; i++) {
        const auto& repfield = this->_internal_models(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:optimization_guide.proto.GetModelsResponse)
    return target;
}

size_t GetModelsResponse::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:optimization_guide.proto.GetModelsResponse)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .optimization_guide.proto.PredictionModel models = 1;
    total_size += 1UL * this->_internal_models_size();
    for (const auto& msg : this->_impl_.models_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void GetModelsResponse::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const GetModelsResponse*>(&from));
}

void GetModelsResponse::MergeFrom(const GetModelsResponse& from)
{
    GetModelsResponse* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:optimization_guide.proto.GetModelsResponse)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.models_.MergeFrom(from._impl_.models_);
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GetModelsResponse::CopyFrom(const GetModelsResponse& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:optimization_guide.proto.GetModelsResponse)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool GetModelsResponse::IsInitialized() const
{
    return true;
}

void GetModelsResponse::InternalSwap(GetModelsResponse* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.models_.InternalSwap(&other->_impl_.models_);
}

std::string GetModelsResponse::GetTypeName() const
{
    return "optimization_guide.proto.GetModelsResponse";
}

// ===================================================================

class PredictionModel::_Internal {
public:
    using HasBits = decltype(std::declval<PredictionModel>()._impl_._has_bits_);
    static const ::optimization_guide::proto::ModelInfo& model_info(const PredictionModel* msg);
    static void set_has_model_info(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static const ::optimization_guide::proto::Model& model(const PredictionModel* msg);
    static void set_has_model(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

const ::optimization_guide::proto::ModelInfo& PredictionModel::_Internal::model_info(const PredictionModel* msg)
{
    return *msg->_impl_.model_info_;
}
const ::optimization_guide::proto::Model& PredictionModel::_Internal::model(const PredictionModel* msg)
{
    return *msg->_impl_.model_;
}
PredictionModel::PredictionModel(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:optimization_guide.proto.PredictionModel)
}
PredictionModel::PredictionModel(const PredictionModel& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    PredictionModel* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.model_info_) { nullptr }, decltype(_impl_.model_) { nullptr } };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_model_info()) {
        _this->_impl_.model_info_ = new ::optimization_guide::proto::ModelInfo(*from._impl_.model_info_);
    }
    if (from._internal_has_model()) {
        _this->_impl_.model_ = new ::optimization_guide::proto::Model(*from._impl_.model_);
    }
    // @@protoc_insertion_point(copy_constructor:optimization_guide.proto.PredictionModel)
}

inline void PredictionModel::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.model_info_) { nullptr },
        decltype(_impl_.model_) { nullptr } };
}

PredictionModel::~PredictionModel()
{
    // @@protoc_insertion_point(destructor:optimization_guide.proto.PredictionModel)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void PredictionModel::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (this != internal_default_instance())
        delete _impl_.model_info_;
    if (this != internal_default_instance())
        delete _impl_.model_;
}

void PredictionModel::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void PredictionModel::Clear()
{
    // @@protoc_insertion_point(message_clear_start:optimization_guide.proto.PredictionModel)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            GOOGLE_DCHECK(_impl_.model_info_ != nullptr);
            _impl_.model_info_->Clear();
        }
        if (cached_has_bits & 0x00000002u) {
            GOOGLE_DCHECK(_impl_.model_ != nullptr);
            _impl_.model_->Clear();
        }
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* PredictionModel::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .optimization_guide.proto.ModelInfo model_info = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_model_info(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .optimization_guide.proto.Model model = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_model(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* PredictionModel::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:optimization_guide.proto.PredictionModel)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .optimization_guide.proto.ModelInfo model_info = 1;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::model_info(this), _Internal::model_info(this).GetCachedSize(), target, stream);
    }

    // optional .optimization_guide.proto.Model model = 2;
    if (cached_has_bits & 0x00000002u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::model(this), _Internal::model(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:optimization_guide.proto.PredictionModel)
    return target;
}

size_t PredictionModel::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:optimization_guide.proto.PredictionModel)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional .optimization_guide.proto.ModelInfo model_info = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.model_info_);
        }

        // optional .optimization_guide.proto.Model model = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.model_);
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void PredictionModel::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const PredictionModel*>(&from));
}

void PredictionModel::MergeFrom(const PredictionModel& from)
{
    PredictionModel* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:optimization_guide.proto.PredictionModel)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_mutable_model_info()->::optimization_guide::proto::ModelInfo::MergeFrom(from._internal_model_info());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_mutable_model()->::optimization_guide::proto::Model::MergeFrom(from._internal_model());
        }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PredictionModel::CopyFrom(const PredictionModel& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:optimization_guide.proto.PredictionModel)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool PredictionModel::IsInitialized() const
{
    return true;
}

void PredictionModel::InternalSwap(PredictionModel* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(PredictionModel, _impl_.model_) + sizeof(PredictionModel::_impl_.model_)
        - PROTOBUF_FIELD_OFFSET(PredictionModel, _impl_.model_info_)>(
        reinterpret_cast<char*>(&_impl_.model_info_), reinterpret_cast<char*>(&other->_impl_.model_info_));
}

std::string PredictionModel::GetTypeName() const
{
    return "optimization_guide.proto.PredictionModel";
}

// ===================================================================

class AdditionalModelFile::_Internal {
public:
    using HasBits = decltype(std::declval<AdditionalModelFile>()._impl_._has_bits_);
    static void set_has_file_path(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

AdditionalModelFile::AdditionalModelFile(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:optimization_guide.proto.AdditionalModelFile)
}
AdditionalModelFile::AdditionalModelFile(const AdditionalModelFile& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    AdditionalModelFile* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.file_path_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.file_path_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.file_path_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_file_path()) {
        _this->_impl_.file_path_.Set(from._internal_file_path(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:optimization_guide.proto.AdditionalModelFile)
}

inline void AdditionalModelFile::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.file_path_) {} };
    _impl_.file_path_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.file_path_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AdditionalModelFile::~AdditionalModelFile()
{
    // @@protoc_insertion_point(destructor:optimization_guide.proto.AdditionalModelFile)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void AdditionalModelFile::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.file_path_.Destroy();
}

void AdditionalModelFile::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void AdditionalModelFile::Clear()
{
    // @@protoc_insertion_point(message_clear_start:optimization_guide.proto.AdditionalModelFile)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.file_path_.ClearNonDefaultToEmpty();
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* AdditionalModelFile::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string file_path = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_file_path();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* AdditionalModelFile::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:optimization_guide.proto.AdditionalModelFile)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string file_path = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_file_path(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:optimization_guide.proto.AdditionalModelFile)
    return target;
}

size_t AdditionalModelFile::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:optimization_guide.proto.AdditionalModelFile)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional string file_path = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_file_path());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void AdditionalModelFile::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const AdditionalModelFile*>(&from));
}

void AdditionalModelFile::MergeFrom(const AdditionalModelFile& from)
{
    AdditionalModelFile* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:optimization_guide.proto.AdditionalModelFile)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_file_path()) {
        _this->_internal_set_file_path(from._internal_file_path());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AdditionalModelFile::CopyFrom(const AdditionalModelFile& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:optimization_guide.proto.AdditionalModelFile)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool AdditionalModelFile::IsInitialized() const
{
    return true;
}

void AdditionalModelFile::InternalSwap(AdditionalModelFile* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.file_path_, lhs_arena, &other->_impl_.file_path_, rhs_arena);
}

std::string AdditionalModelFile::GetTypeName() const
{
    return "optimization_guide.proto.AdditionalModelFile";
}

// ===================================================================

class ModelInfo::_Internal {
public:
    using HasBits = decltype(std::declval<ModelInfo>()._impl_._has_bits_);
    static void set_has_optimization_target(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static void set_has_version(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static const ::optimization_guide::proto::Duration& valid_duration(const ModelInfo* msg);
    static void set_has_valid_duration(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_keep_beyond_valid_duration(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
    static const ::optimization_guide::proto::Any& model_metadata(const ModelInfo* msg);
    static void set_has_model_metadata(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static const ::optimization_guide::proto::ModelCacheKey& model_cache_key(const ModelInfo* msg);
    static void set_has_model_cache_key(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
};

const ::optimization_guide::proto::Duration& ModelInfo::_Internal::valid_duration(const ModelInfo* msg)
{
    return *msg->_impl_.valid_duration_;
}
const ::optimization_guide::proto::Any& ModelInfo::_Internal::model_metadata(const ModelInfo* msg)
{
    return *msg->_impl_.model_metadata_;
}
const ::optimization_guide::proto::ModelCacheKey& ModelInfo::_Internal::model_cache_key(const ModelInfo* msg)
{
    return *msg->_impl_.model_cache_key_;
}
void ModelInfo::clear_valid_duration()
{
    if (_impl_.valid_duration_ != nullptr)
        _impl_.valid_duration_->Clear();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
void ModelInfo::clear_model_metadata()
{
    if (_impl_.model_metadata_ != nullptr)
        _impl_.model_metadata_->Clear();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
ModelInfo::ModelInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:optimization_guide.proto.ModelInfo)
}
ModelInfo::ModelInfo(const ModelInfo& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ModelInfo* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.supported_model_engine_versions_) { from._impl_.supported_model_engine_versions_ },
        decltype(_impl_.supported_host_model_features_) { from._impl_.supported_host_model_features_ },
        decltype(_impl_.additional_files_) { from._impl_.additional_files_ }, decltype(_impl_.model_metadata_) { nullptr },
        decltype(_impl_.valid_duration_) { nullptr }, decltype(_impl_.model_cache_key_) { nullptr }, decltype(_impl_.version_) {},
        decltype(_impl_.optimization_target_) {}, decltype(_impl_.keep_beyond_valid_duration_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_model_metadata()) {
        _this->_impl_.model_metadata_ = new ::optimization_guide::proto::Any(*from._impl_.model_metadata_);
    }
    if (from._internal_has_valid_duration()) {
        _this->_impl_.valid_duration_ = new ::optimization_guide::proto::Duration(*from._impl_.valid_duration_);
    }
    if (from._internal_has_model_cache_key()) {
        _this->_impl_.model_cache_key_ = new ::optimization_guide::proto::ModelCacheKey(*from._impl_.model_cache_key_);
    }
    ::memcpy(&_impl_.version_, &from._impl_.version_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.keep_beyond_valid_duration_) - reinterpret_cast<char*>(&_impl_.version_))
            + sizeof(_impl_.keep_beyond_valid_duration_));
    // @@protoc_insertion_point(copy_constructor:optimization_guide.proto.ModelInfo)
}

inline void ModelInfo::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.supported_model_engine_versions_) { arena },
        decltype(_impl_.supported_host_model_features_) { arena }, decltype(_impl_.additional_files_) { arena }, decltype(_impl_.model_metadata_) { nullptr },
        decltype(_impl_.valid_duration_) { nullptr }, decltype(_impl_.model_cache_key_) { nullptr }, decltype(_impl_.version_) { int64_t { 0 } },
        decltype(_impl_.optimization_target_) { 0 }, decltype(_impl_.keep_beyond_valid_duration_) { false } };
}

ModelInfo::~ModelInfo()
{
    // @@protoc_insertion_point(destructor:optimization_guide.proto.ModelInfo)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ModelInfo::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.supported_model_engine_versions_.~RepeatedField();
    _impl_.supported_host_model_features_.~RepeatedPtrField();
    _impl_.additional_files_.~RepeatedPtrField();
    if (this != internal_default_instance())
        delete _impl_.model_metadata_;
    if (this != internal_default_instance())
        delete _impl_.valid_duration_;
    if (this != internal_default_instance())
        delete _impl_.model_cache_key_;
}

void ModelInfo::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ModelInfo::Clear()
{
    // @@protoc_insertion_point(message_clear_start:optimization_guide.proto.ModelInfo)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.supported_model_engine_versions_.Clear();
    _impl_.supported_host_model_features_.Clear();
    _impl_.additional_files_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            GOOGLE_DCHECK(_impl_.model_metadata_ != nullptr);
            _impl_.model_metadata_->Clear();
        }
        if (cached_has_bits & 0x00000002u) {
            GOOGLE_DCHECK(_impl_.valid_duration_ != nullptr);
            _impl_.valid_duration_->Clear();
        }
        if (cached_has_bits & 0x00000004u) {
            GOOGLE_DCHECK(_impl_.model_cache_key_ != nullptr);
            _impl_.model_cache_key_->Clear();
        }
    }
    if (cached_has_bits & 0x00000038u) {
        ::memset(&_impl_.version_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.keep_beyond_valid_duration_) - reinterpret_cast<char*>(&_impl_.version_))
                + sizeof(_impl_.keep_beyond_valid_duration_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ModelInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .optimization_guide.proto.OptimizationTarget optimization_target = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::optimization_guide::proto::OptimizationTarget_IsValid(val))) {
                    _internal_set_optimization_target(static_cast<::optimization_guide::proto::OptimizationTarget>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional int64 version = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_version(&has_bits);
                _impl_.version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .optimization_guide.proto.ModelEngineVersion supported_model_engine_versions = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                    CHK_(ptr);
                    if (PROTOBUF_PREDICT_TRUE(::optimization_guide::proto::ModelEngineVersion_IsValid(val))) {
                        _internal_add_supported_model_engine_versions(static_cast<::optimization_guide::proto::ModelEngineVersion>(val));
                    } else {
                        ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
                    }
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<32>(ptr));
            } else if (static_cast<uint8_t>(tag) == 34) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(_internal_mutable_supported_model_engine_versions(), ptr, ctx,
                    ::optimization_guide::proto::ModelEngineVersion_IsValid, &_internal_metadata_, 4);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated string supported_host_model_features = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    auto str = _internal_add_supported_host_model_features();
                    ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional .optimization_guide.proto.Any model_metadata = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
                ptr = ctx->ParseMessage(_internal_mutable_model_metadata(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .optimization_guide.proto.AdditionalModelFile additional_files = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_additional_files(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional .optimization_guide.proto.Duration valid_duration = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
                ptr = ctx->ParseMessage(_internal_mutable_valid_duration(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool keep_beyond_valid_duration = 9;
        case 9:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
                _Internal::set_has_keep_beyond_valid_duration(&has_bits);
                _impl_.keep_beyond_valid_duration_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .optimization_guide.proto.ModelCacheKey model_cache_key = 10;
        case 10:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
                ptr = ctx->ParseMessage(_internal_mutable_model_cache_key(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ModelInfo::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:optimization_guide.proto.ModelInfo)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .optimization_guide.proto.OptimizationTarget optimization_target = 1;
    if (cached_has_bits & 0x00000010u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(1, this->_internal_optimization_target(), target);
    }

    // optional int64 version = 2;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_version(), target);
    }

    // repeated .optimization_guide.proto.ModelEngineVersion supported_model_engine_versions = 4;
    for (int i = 0, n = this->_internal_supported_model_engine_versions_size(); i < n; i++) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(4, this->_internal_supported_model_engine_versions(i), target);
    }

    // repeated string supported_host_model_features = 5;
    for (int i = 0, n = this->_internal_supported_host_model_features_size(); i < n; i++) {
        const auto& s = this->_internal_supported_host_model_features(i);
        target = stream->WriteString(5, s, target);
    }

    // optional .optimization_guide.proto.Any model_metadata = 6;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            6, _Internal::model_metadata(this), _Internal::model_metadata(this).GetCachedSize(), target, stream);
    }

    // repeated .optimization_guide.proto.AdditionalModelFile additional_files = 7;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_additional_files_size()); i < n; i++) {
        const auto& repfield = this->_internal_additional_files(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
    }

    // optional .optimization_guide.proto.Duration valid_duration = 8;
    if (cached_has_bits & 0x00000002u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            8, _Internal::valid_duration(this), _Internal::valid_duration(this).GetCachedSize(), target, stream);
    }

    // optional bool keep_beyond_valid_duration = 9;
    if (cached_has_bits & 0x00000020u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_keep_beyond_valid_duration(), target);
    }

    // optional .optimization_guide.proto.ModelCacheKey model_cache_key = 10;
    if (cached_has_bits & 0x00000004u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            10, _Internal::model_cache_key(this), _Internal::model_cache_key(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:optimization_guide.proto.ModelInfo)
    return target;
}

size_t ModelInfo::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:optimization_guide.proto.ModelInfo)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .optimization_guide.proto.ModelEngineVersion supported_model_engine_versions = 4;
    {
        size_t data_size = 0;
        unsigned int count = static_cast<unsigned int>(this->_internal_supported_model_engine_versions_size());
        for (unsigned int i = 0; i < count; i++) {
            data_size += ::_pbi::WireFormatLite::EnumSize(this->_internal_supported_model_engine_versions(static_cast<int>(i)));
        }
        total_size += (1UL * count) + data_size;
    }

    // repeated string supported_host_model_features = 5;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.supported_host_model_features_.size());
    for (int i = 0, n = _impl_.supported_host_model_features_.size(); i < n; i++) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(_impl_.supported_host_model_features_.Get(i));
    }

    // repeated .optimization_guide.proto.AdditionalModelFile additional_files = 7;
    total_size += 1UL * this->_internal_additional_files_size();
    for (const auto& msg : this->_impl_.additional_files_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000003fu) {
        // optional .optimization_guide.proto.Any model_metadata = 6;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.model_metadata_);
        }

        // optional .optimization_guide.proto.Duration valid_duration = 8;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.valid_duration_);
        }

        // optional .optimization_guide.proto.ModelCacheKey model_cache_key = 10;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.model_cache_key_);
        }

        // optional int64 version = 2;
        if (cached_has_bits & 0x00000008u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_version());
        }

        // optional .optimization_guide.proto.OptimizationTarget optimization_target = 1;
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_optimization_target());
        }

        // optional bool keep_beyond_valid_duration = 9;
        if (cached_has_bits & 0x00000020u) {
            total_size += 1 + 1;
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ModelInfo::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ModelInfo*>(&from));
}

void ModelInfo::MergeFrom(const ModelInfo& from)
{
    ModelInfo* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:optimization_guide.proto.ModelInfo)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.supported_model_engine_versions_.MergeFrom(from._impl_.supported_model_engine_versions_);
    _this->_impl_.supported_host_model_features_.MergeFrom(from._impl_.supported_host_model_features_);
    _this->_impl_.additional_files_.MergeFrom(from._impl_.additional_files_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000003fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_mutable_model_metadata()->::optimization_guide::proto::Any::MergeFrom(from._internal_model_metadata());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_mutable_valid_duration()->::optimization_guide::proto::Duration::MergeFrom(from._internal_valid_duration());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_mutable_model_cache_key()->::optimization_guide::proto::ModelCacheKey::MergeFrom(from._internal_model_cache_key());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.version_ = from._impl_.version_;
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_impl_.optimization_target_ = from._impl_.optimization_target_;
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_impl_.keep_beyond_valid_duration_ = from._impl_.keep_beyond_valid_duration_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ModelInfo::CopyFrom(const ModelInfo& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:optimization_guide.proto.ModelInfo)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ModelInfo::IsInitialized() const
{
    return true;
}

void ModelInfo::InternalSwap(ModelInfo* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.supported_model_engine_versions_.InternalSwap(&other->_impl_.supported_model_engine_versions_);
    _impl_.supported_host_model_features_.InternalSwap(&other->_impl_.supported_host_model_features_);
    _impl_.additional_files_.InternalSwap(&other->_impl_.additional_files_);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(ModelInfo, _impl_.keep_beyond_valid_duration_)
        + sizeof(ModelInfo::_impl_.keep_beyond_valid_duration_) - PROTOBUF_FIELD_OFFSET(ModelInfo, _impl_.model_metadata_)>(
        reinterpret_cast<char*>(&_impl_.model_metadata_), reinterpret_cast<char*>(&other->_impl_.model_metadata_));
}

std::string ModelInfo::GetTypeName() const
{
    return "optimization_guide.proto.ModelInfo";
}

// ===================================================================

class ModelCacheKey::_Internal {
public:
    using HasBits = decltype(std::declval<ModelCacheKey>()._impl_._has_bits_);
    static void set_has_locale(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

ModelCacheKey::ModelCacheKey(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:optimization_guide.proto.ModelCacheKey)
}
ModelCacheKey::ModelCacheKey(const ModelCacheKey& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ModelCacheKey* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.locale_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.locale_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.locale_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_locale()) {
        _this->_impl_.locale_.Set(from._internal_locale(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:optimization_guide.proto.ModelCacheKey)
}

inline void ModelCacheKey::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.locale_) {} };
    _impl_.locale_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.locale_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ModelCacheKey::~ModelCacheKey()
{
    // @@protoc_insertion_point(destructor:optimization_guide.proto.ModelCacheKey)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ModelCacheKey::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.locale_.Destroy();
}

void ModelCacheKey::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ModelCacheKey::Clear()
{
    // @@protoc_insertion_point(message_clear_start:optimization_guide.proto.ModelCacheKey)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.locale_.ClearNonDefaultToEmpty();
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ModelCacheKey::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string locale = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_locale();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ModelCacheKey::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:optimization_guide.proto.ModelCacheKey)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string locale = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_locale(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:optimization_guide.proto.ModelCacheKey)
    return target;
}

size_t ModelCacheKey::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:optimization_guide.proto.ModelCacheKey)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional string locale = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_locale());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ModelCacheKey::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ModelCacheKey*>(&from));
}

void ModelCacheKey::MergeFrom(const ModelCacheKey& from)
{
    ModelCacheKey* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:optimization_guide.proto.ModelCacheKey)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_locale()) {
        _this->_internal_set_locale(from._internal_locale());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ModelCacheKey::CopyFrom(const ModelCacheKey& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:optimization_guide.proto.ModelCacheKey)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ModelCacheKey::IsInitialized() const
{
    return true;
}

void ModelCacheKey::InternalSwap(ModelCacheKey* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.locale_, lhs_arena, &other->_impl_.locale_, rhs_arena);
}

std::string ModelCacheKey::GetTypeName() const
{
    return "optimization_guide.proto.ModelCacheKey";
}

// @@protoc_insertion_point(namespace_scope)
} // namespace proto
} // namespace optimization_guide
PROTOBUF_NAMESPACE_OPEN
template <> PROTOBUF_NOINLINE ::optimization_guide::proto::Model* Arena::CreateMaybeMessage<::optimization_guide::proto::Model>(Arena* arena)
{
    return Arena::CreateMessageInternal<::optimization_guide::proto::Model>(arena);
}
template <>
PROTOBUF_NOINLINE ::optimization_guide::proto::GetModelsRequest* Arena::CreateMaybeMessage<::optimization_guide::proto::GetModelsRequest>(Arena* arena)
{
    return Arena::CreateMessageInternal<::optimization_guide::proto::GetModelsRequest>(arena);
}
template <>
PROTOBUF_NOINLINE ::optimization_guide::proto::GetModelsResponse* Arena::CreateMaybeMessage<::optimization_guide::proto::GetModelsResponse>(Arena* arena)
{
    return Arena::CreateMessageInternal<::optimization_guide::proto::GetModelsResponse>(arena);
}
template <>
PROTOBUF_NOINLINE ::optimization_guide::proto::PredictionModel* Arena::CreateMaybeMessage<::optimization_guide::proto::PredictionModel>(Arena* arena)
{
    return Arena::CreateMessageInternal<::optimization_guide::proto::PredictionModel>(arena);
}
template <>
PROTOBUF_NOINLINE ::optimization_guide::proto::AdditionalModelFile* Arena::CreateMaybeMessage<::optimization_guide::proto::AdditionalModelFile>(Arena* arena)
{
    return Arena::CreateMessageInternal<::optimization_guide::proto::AdditionalModelFile>(arena);
}
template <> PROTOBUF_NOINLINE ::optimization_guide::proto::ModelInfo* Arena::CreateMaybeMessage<::optimization_guide::proto::ModelInfo>(Arena* arena)
{
    return Arena::CreateMessageInternal<::optimization_guide::proto::ModelInfo>(arena);
}
template <> PROTOBUF_NOINLINE ::optimization_guide::proto::ModelCacheKey* Arena::CreateMaybeMessage<::optimization_guide::proto::ModelCacheKey>(Arena* arena)
{
    return Arena::CreateMessageInternal<::optimization_guide::proto::ModelCacheKey>(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
