// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/optimization_guide/proto/features/common_quality_data.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_components_2foptimization_5fguide_2fproto_2ffeatures_2fcommon_5fquality_5fdata_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_components_2foptimization_5fguide_2fproto_2ffeatures_2fcommon_5fquality_5fdata_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h> // IWYU pragma: export
#include <google/protobuf/extension_set.h> // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_components_2foptimization_5fguide_2fproto_2ffeatures_2fcommon_5fquality_5fdata_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
} // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_components_2foptimization_5fguide_2fproto_2ffeatures_2fcommon_5fquality_5fdata_2eproto {
    static const uint32_t offsets[];
};
namespace optimization_guide {
namespace proto {
class AXAttribute;
struct AXAttributeDefaultTypeInternal;
extern AXAttributeDefaultTypeInternal _AXAttribute_default_instance_;
class AXIntList;
struct AXIntListDefaultTypeInternal;
extern AXIntListDefaultTypeInternal _AXIntList_default_instance_;
class AXNodeData;
struct AXNodeDataDefaultTypeInternal;
extern AXNodeDataDefaultTypeInternal _AXNodeData_default_instance_;
class AXRelativeBounds;
struct AXRelativeBoundsDefaultTypeInternal;
extern AXRelativeBoundsDefaultTypeInternal _AXRelativeBounds_default_instance_;
class AXStringList;
struct AXStringListDefaultTypeInternal;
extern AXStringListDefaultTypeInternal _AXStringList_default_instance_;
class AXTreeData;
struct AXTreeDataDefaultTypeInternal;
extern AXTreeDataDefaultTypeInternal _AXTreeData_default_instance_;
class AXTreeUpdate;
struct AXTreeUpdateDefaultTypeInternal;
extern AXTreeUpdateDefaultTypeInternal _AXTreeUpdate_default_instance_;
class BrowserCollectedInformation;
struct BrowserCollectedInformationDefaultTypeInternal;
extern BrowserCollectedInformationDefaultTypeInternal _BrowserCollectedInformation_default_instance_;
class Embedding;
struct EmbeddingDefaultTypeInternal;
extern EmbeddingDefaultTypeInternal _Embedding_default_instance_;
class FloatArray;
struct FloatArrayDefaultTypeInternal;
extern FloatArrayDefaultTypeInternal _FloatArray_default_instance_;
class FormData;
struct FormDataDefaultTypeInternal;
extern FormDataDefaultTypeInternal _FormData_default_instance_;
class FormFieldData;
struct FormFieldDataDefaultTypeInternal;
extern FormFieldDataDefaultTypeInternal _FormFieldData_default_instance_;
class PageContext;
struct PageContextDefaultTypeInternal;
extern PageContextDefaultTypeInternal _PageContext_default_instance_;
class SelectOption;
struct SelectOptionDefaultTypeInternal;
extern SelectOptionDefaultTypeInternal _SelectOption_default_instance_;
class SiteEngagement;
struct SiteEngagementDefaultTypeInternal;
extern SiteEngagementDefaultTypeInternal _SiteEngagement_default_instance_;
class SiteEngagementEntry;
struct SiteEngagementEntryDefaultTypeInternal;
extern SiteEngagementEntryDefaultTypeInternal _SiteEngagementEntry_default_instance_;
class Tab;
struct TabDefaultTypeInternal;
extern TabDefaultTypeInternal _Tab_default_instance_;
class TabGroup;
struct TabGroupDefaultTypeInternal;
extern TabGroupDefaultTypeInternal _TabGroup_default_instance_;
class UserAnnotationsEntry;
struct UserAnnotationsEntryDefaultTypeInternal;
extern UserAnnotationsEntryDefaultTypeInternal _UserAnnotationsEntry_default_instance_;
} // namespace proto
} // namespace optimization_guide
PROTOBUF_NAMESPACE_OPEN
template <>::optimization_guide::proto::AXAttribute* Arena::CreateMaybeMessage<::optimization_guide::proto::AXAttribute>(Arena*);
template <>::optimization_guide::proto::AXIntList* Arena::CreateMaybeMessage<::optimization_guide::proto::AXIntList>(Arena*);
template <>::optimization_guide::proto::AXNodeData* Arena::CreateMaybeMessage<::optimization_guide::proto::AXNodeData>(Arena*);
template <>::optimization_guide::proto::AXRelativeBounds* Arena::CreateMaybeMessage<::optimization_guide::proto::AXRelativeBounds>(Arena*);
template <>::optimization_guide::proto::AXStringList* Arena::CreateMaybeMessage<::optimization_guide::proto::AXStringList>(Arena*);
template <>::optimization_guide::proto::AXTreeData* Arena::CreateMaybeMessage<::optimization_guide::proto::AXTreeData>(Arena*);
template <>::optimization_guide::proto::AXTreeUpdate* Arena::CreateMaybeMessage<::optimization_guide::proto::AXTreeUpdate>(Arena*);
template <>
::optimization_guide::proto::BrowserCollectedInformation* Arena::CreateMaybeMessage<::optimization_guide::proto::BrowserCollectedInformation>(Arena*);
template <>::optimization_guide::proto::Embedding* Arena::CreateMaybeMessage<::optimization_guide::proto::Embedding>(Arena*);
template <>::optimization_guide::proto::FloatArray* Arena::CreateMaybeMessage<::optimization_guide::proto::FloatArray>(Arena*);
template <>::optimization_guide::proto::FormData* Arena::CreateMaybeMessage<::optimization_guide::proto::FormData>(Arena*);
template <>::optimization_guide::proto::FormFieldData* Arena::CreateMaybeMessage<::optimization_guide::proto::FormFieldData>(Arena*);
template <>::optimization_guide::proto::PageContext* Arena::CreateMaybeMessage<::optimization_guide::proto::PageContext>(Arena*);
template <>::optimization_guide::proto::SelectOption* Arena::CreateMaybeMessage<::optimization_guide::proto::SelectOption>(Arena*);
template <>::optimization_guide::proto::SiteEngagement* Arena::CreateMaybeMessage<::optimization_guide::proto::SiteEngagement>(Arena*);
template <>::optimization_guide::proto::SiteEngagementEntry* Arena::CreateMaybeMessage<::optimization_guide::proto::SiteEngagementEntry>(Arena*);
template <>::optimization_guide::proto::Tab* Arena::CreateMaybeMessage<::optimization_guide::proto::Tab>(Arena*);
template <>::optimization_guide::proto::TabGroup* Arena::CreateMaybeMessage<::optimization_guide::proto::TabGroup>(Arena*);
template <>::optimization_guide::proto::UserAnnotationsEntry* Arena::CreateMaybeMessage<::optimization_guide::proto::UserAnnotationsEntry>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace optimization_guide {
namespace proto {

enum AXTextAffinity : int {
    AX_TEXT_AFFINITY_NONE = 0,
    AX_TEXT_AFFINITY_DOWNSTREAM = 1,
    AX_TEXT_AFFINITY_UPSTREAM = 2,
    AXTextAffinity_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
    AXTextAffinity_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AXTextAffinity_IsValid(int value);
constexpr AXTextAffinity AXTextAffinity_MIN = AX_TEXT_AFFINITY_NONE;
constexpr AXTextAffinity AXTextAffinity_MAX = AX_TEXT_AFFINITY_UPSTREAM;
constexpr int AXTextAffinity_ARRAYSIZE = AXTextAffinity_MAX + 1;

const std::string& AXTextAffinity_Name(AXTextAffinity value);
template <typename T> inline const std::string& AXTextAffinity_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, AXTextAffinity>::value || ::std::is_integral<T>::value, "Incorrect type passed to function AXTextAffinity_Name.");
    return AXTextAffinity_Name(static_cast<AXTextAffinity>(enum_t_value));
}
bool AXTextAffinity_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AXTextAffinity* value);
enum AXRole : int {
    AX_ROLE_NONE = 0,
    AX_ROLE_ABBR = 1,
    AX_ROLE_ALERT = 2,
    AX_ROLE_ALERTDIALOG = 3,
    AX_ROLE_APPLICATION = 4,
    AX_ROLE_ARTICLE = 5,
    AX_ROLE_AUDIO = 6,
    AX_ROLE_BANNER = 7,
    AX_ROLE_BLOCKQUOTE = 8,
    AX_ROLE_BUTTON = 9,
    AX_ROLE_CANVAS = 10,
    AX_ROLE_CAPTION = 11,
    AX_ROLE_CARET = 12,
    AX_ROLE_CELL = 13,
    AX_ROLE_CHECKBOX = 14,
    AX_ROLE_CLIENT = 15,
    AX_ROLE_CODE = 16,
    AX_ROLE_COLORWELL = 17,
    AX_ROLE_COLUMN = 18,
    AX_ROLE_COLUMNHEADER = 19,
    AX_ROLE_COMBOBOXGROUPING = 20,
    AX_ROLE_COMBOBOXMENUBUTTON = 21,
    AX_ROLE_COMPLEMENTARY = 22,
    AX_ROLE_COMMENT = 23,
    AX_ROLE_CONTENTDELETION = 24,
    AX_ROLE_CONTENTINSERTION = 25,
    AX_ROLE_CONTENTINFO = 26,
    AX_ROLE_DATE = 27,
    AX_ROLE_DATETIME = 28,
    AX_ROLE_DEFINITION = 29,
    AX_ROLE_DESCRIPTIONLIST = 30,
    AX_ROLE_DESCRIPTIONLISTDETAILDEPRECATED = 31,
    AX_ROLE_DESCRIPTIONLISTTERMDEPRECATED = 32,
    AX_ROLE_DESKTOP = 33,
    AX_ROLE_DETAILS = 34,
    AX_ROLE_DIALOG = 35,
    AX_ROLE_DIRECTORYDEPRECATED = 36,
    AX_ROLE_DISCLOSURETRIANGLE = 37,
    AX_ROLE_DOCABSTRACT = 38,
    AX_ROLE_DOCACKNOWLEDGMENTS = 39,
    AX_ROLE_DOCAFTERWORD = 40,
    AX_ROLE_DOCAPPENDIX = 41,
    AX_ROLE_DOCBACKLINK = 42,
    AX_ROLE_DOCBIBLIOENTRY = 43,
    AX_ROLE_DOCBIBLIOGRAPHY = 44,
    AX_ROLE_DOCBIBLIOREF = 45,
    AX_ROLE_DOCCHAPTER = 46,
    AX_ROLE_DOCCOLOPHON = 47,
    AX_ROLE_DOCCONCLUSION = 48,
    AX_ROLE_DOCCOVER = 49,
    AX_ROLE_DOCCREDIT = 50,
    AX_ROLE_DOCCREDITS = 51,
    AX_ROLE_DOCDEDICATION = 52,
    AX_ROLE_DOCENDNOTE = 53,
    AX_ROLE_DOCENDNOTES = 54,
    AX_ROLE_DOCEPIGRAPH = 55,
    AX_ROLE_DOCEPILOGUE = 56,
    AX_ROLE_DOCERRATA = 57,
    AX_ROLE_DOCEXAMPLE = 58,
    AX_ROLE_DOCFOOTNOTE = 59,
    AX_ROLE_DOCFOREWORD = 60,
    AX_ROLE_DOCGLOSSARY = 61,
    AX_ROLE_DOCGLOSSREF = 62,
    AX_ROLE_DOCINDEX = 63,
    AX_ROLE_DOCINTRODUCTION = 64,
    AX_ROLE_DOCNOTEREF = 65,
    AX_ROLE_DOCNOTICE = 66,
    AX_ROLE_DOCPAGEBREAK = 67,
    AX_ROLE_DOCPAGEFOOTER = 68,
    AX_ROLE_DOCPAGEHEADER = 69,
    AX_ROLE_DOCPAGELIST = 70,
    AX_ROLE_DOCPART = 71,
    AX_ROLE_DOCPREFACE = 72,
    AX_ROLE_DOCPROLOGUE = 73,
    AX_ROLE_DOCPULLQUOTE = 74,
    AX_ROLE_DOCQNA = 75,
    AX_ROLE_DOCSUBTITLE = 76,
    AX_ROLE_DOCTIP = 77,
    AX_ROLE_DOCTOC = 78,
    AX_ROLE_DOCUMENT = 79,
    AX_ROLE_EMBEDDEDOBJECT = 80,
    AX_ROLE_EMPHASIS = 81,
    AX_ROLE_FEED = 82,
    AX_ROLE_FIGCAPTION = 83,
    AX_ROLE_FIGURE = 84,
    AX_ROLE_FOOTER = 85,
    AX_ROLE_SECTIONFOOTER = 86,
    AX_ROLE_FORM = 87,
    AX_ROLE_GENERICCONTAINER = 88,
    AX_ROLE_GRAPHICSDOCUMENT = 89,
    AX_ROLE_GRAPHICSOBJECT = 90,
    AX_ROLE_GRAPHICSSYMBOL = 91,
    AX_ROLE_GRID = 92,
    AX_ROLE_GROUP = 93,
    AX_ROLE_HEADER = 94,
    AX_ROLE_SECTIONHEADER = 95,
    AX_ROLE_HEADING = 96,
    AX_ROLE_IFRAME = 97,
    AX_ROLE_IFRAMEPRESENTATIONAL = 98,
    AX_ROLE_IMAGE = 99,
    AX_ROLE_IMECANDIDATE = 100,
    AX_ROLE_INLINETEXTBOX = 101,
    AX_ROLE_INPUTTIME = 102,
    AX_ROLE_KEYBOARD = 103,
    AX_ROLE_LABELTEXT = 104,
    AX_ROLE_LAYOUTTABLE = 105,
    AX_ROLE_LAYOUTTABLECELL = 106,
    AX_ROLE_LAYOUTTABLEROW = 107,
    AX_ROLE_LEGEND = 108,
    AX_ROLE_LINEBREAK = 109,
    AX_ROLE_LINK = 110,
    AX_ROLE_LIST = 111,
    AX_ROLE_LISTBOX = 112,
    AX_ROLE_LISTBOXOPTION = 113,
    AX_ROLE_LISTGRID = 114,
    AX_ROLE_LISTITEM = 115,
    AX_ROLE_LISTMARKER = 116,
    AX_ROLE_LOG = 117,
    AX_ROLE_MAIN = 118,
    AX_ROLE_MARK = 119,
    AX_ROLE_MARQUEE = 120,
    AX_ROLE_MATH = 121,
    AX_ROLE_MENU = 122,
    AX_ROLE_MENUBAR = 123,
    AX_ROLE_MENUITEM = 124,
    AX_ROLE_MENUITEMCHECKBOX = 125,
    AX_ROLE_MENUITEMRADIO = 126,
    AX_ROLE_MENULISTOPTION = 127,
    AX_ROLE_MENULISTPOPUP = 128,
    AX_ROLE_METER = 129,
    AX_ROLE_NAVIGATION = 130,
    AX_ROLE_NOTE = 131,
    AX_ROLE_PANE = 132,
    AX_ROLE_PARAGRAPH = 133,
    AX_ROLE_PDFACTIONABLEHIGHLIGHT = 134,
    AX_ROLE_PDFROOT = 135,
    AX_ROLE_PLUGINOBJECT = 136,
    AX_ROLE_POPUPBUTTON = 137,
    AX_ROLE_PORTALDEPRECATED = 138,
    AX_ROLE_PREDEPRECATED = 139,
    AX_ROLE_PROGRESSINDICATOR = 140,
    AX_ROLE_RADIOBUTTON = 141,
    AX_ROLE_RADIOGROUP = 142,
    AX_ROLE_REGION = 143,
    AX_ROLE_ROOTWEBAREA = 144,
    AX_ROLE_ROW = 145,
    AX_ROLE_ROWGROUP = 146,
    AX_ROLE_ROWHEADER = 147,
    AX_ROLE_RUBY = 148,
    AX_ROLE_RUBYANNOTATION = 149,
    AX_ROLE_SCROLLBAR = 150,
    AX_ROLE_SCROLLVIEW = 151,
    AX_ROLE_SEARCH = 152,
    AX_ROLE_SEARCHBOX = 153,
    AX_ROLE_SECTION = 154,
    AX_ROLE_SLIDER = 155,
    AX_ROLE_SPINBUTTON = 156,
    AX_ROLE_SPLITTER = 157,
    AX_ROLE_STATICTEXT = 158,
    AX_ROLE_STATUS = 159,
    AX_ROLE_STRONG = 160,
    AX_ROLE_SUGGESTION = 161,
    AX_ROLE_SVGROOT = 162,
    AX_ROLE_SWITCH = 163,
    AX_ROLE_TAB = 164,
    AX_ROLE_TABLIST = 165,
    AX_ROLE_TABPANEL = 166,
    AX_ROLE_TABLE = 167,
    AX_ROLE_TABLEHEADERCONTAINER = 168,
    AX_ROLE_TERM = 169,
    AX_ROLE_TEXTFIELD = 170,
    AX_ROLE_TEXTFIELDWITHCOMBOBOX = 171,
    AX_ROLE_TIME = 172,
    AX_ROLE_TIMER = 173,
    AX_ROLE_TITLEBAR = 174,
    AX_ROLE_TOGGLEBUTTON = 175,
    AX_ROLE_TOOLBAR = 176,
    AX_ROLE_TOOLTIP = 177,
    AX_ROLE_TREE = 178,
    AX_ROLE_TREEGRID = 179,
    AX_ROLE_TREEITEM = 180,
    AX_ROLE_UNKNOWN = 181,
    AX_ROLE_VIDEO = 182,
    AX_ROLE_WEBVIEW = 183,
    AX_ROLE_WINDOW = 184,
    AX_ROLE_SUBSCRIPT = 185,
    AX_ROLE_SUPERSCRIPT = 186,
    AX_ROLE_MATHMLMATH = 187,
    AX_ROLE_MATHMLFRACTION = 188,
    AX_ROLE_MATHMLIDENTIFIER = 189,
    AX_ROLE_MATHMLMULTISCRIPTS = 190,
    AX_ROLE_MATHMLNONESCRIPT = 191,
    AX_ROLE_MATHMLNUMBER = 192,
    AX_ROLE_MATHMLOPERATOR = 193,
    AX_ROLE_MATHMLOVER = 194,
    AX_ROLE_MATHMLPRESCRIPTDELIMITER = 195,
    AX_ROLE_MATHMLROOT = 196,
    AX_ROLE_MATHMLROW = 197,
    AX_ROLE_MATHMLSQUAREROOT = 198,
    AX_ROLE_MATHMLSTRINGLITERAL = 199,
    AX_ROLE_MATHMLSUB = 200,
    AX_ROLE_MATHMLSUBSUP = 201,
    AX_ROLE_MATHMLSUP = 202,
    AX_ROLE_MATHMLTABLE = 203,
    AX_ROLE_MATHMLTABLECELL = 204,
    AX_ROLE_MATHMLTABLEROW = 205,
    AX_ROLE_MATHMLTEXT = 206,
    AX_ROLE_MATHMLUNDER = 207,
    AX_ROLE_MATHMLUNDEROVER = 208,
    AX_ROLE_COMBOBOXSELECT = 209,
    AX_ROLE_DISCLOSURETRIANGLEGROUPED = 210,
    AX_ROLE_SECTIONWITHOUTNAME = 211,
    AX_ROLE_GRIDCELL = 212,
    AXRole_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
    AXRole_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AXRole_IsValid(int value);
constexpr AXRole AXRole_MIN = AX_ROLE_NONE;
constexpr AXRole AXRole_MAX = AX_ROLE_GRIDCELL;
constexpr int AXRole_ARRAYSIZE = AXRole_MAX + 1;

const std::string& AXRole_Name(AXRole value);
template <typename T> inline const std::string& AXRole_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, AXRole>::value || ::std::is_integral<T>::value, "Incorrect type passed to function AXRole_Name.");
    return AXRole_Name(static_cast<AXRole>(enum_t_value));
}
bool AXRole_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AXRole* value);
enum AXStringAttribute : int {
    AX_SA_NONE = 0,
    AX_SA_ACCESSKEY = 1,
    AX_SA_APPID = 2,
    AX_SA_ARIAINVALIDVALUEDEPRECATED = 3,
    AX_SA_AUTOCOMPLETE = 4,
    AX_SA_CHECKEDSTATEDESCRIPTION = 5,
    AX_SA_CHILDTREEID = 6,
    AX_SA_CHILDTREENODEAPPID = 7,
    AX_SA_CLASSNAME = 8,
    AX_SA_CONTAINERLIVERELEVANT = 9,
    AX_SA_CONTAINERLIVESTATUS = 10,
    AX_SA_DESCRIPTION = 11,
    AX_SA_DISPLAY = 12,
    AX_SA_FONTFAMILY = 13,
    AX_SA_HTMLTAG = 14,
    AX_SA_IMAGEANNOTATION = 15,
    AX_SA_IMAGEDATAURL = 16,
    AX_SA_MATHCONTENT = 17,
    AX_SA_INPUTTYPE = 18,
    AX_SA_KEYSHORTCUTS = 19,
    AX_SA_LANGUAGE = 20,
    AX_SA_NAME = 21,
    AX_SA_LIVERELEVANT = 22,
    AX_SA_LIVESTATUS = 23,
    AX_SA_PLACEHOLDER = 24,
    AX_SA_ROLE = 25,
    AX_SA_ROLEDESCRIPTION = 26,
    AX_SA_TOOLTIP = 27,
    AX_SA_URL = 28,
    AX_SA_VALUE = 29,
    AX_SA_VIRTUALCONTENT = 30,
    AX_SA_DODEFAULTLABEL = 31,
    AX_SA_LONGCLICKLABEL = 32,
    AX_SA_ARIABRAILLELABEL = 33,
    AX_SA_ARIABRAILLEROLEDESCRIPTION = 34,
    AX_SA_LINKTARGET = 35,
    AX_SA_ARIANOTIFICATIONANNOUNCEMENTDEPRECATED = 36,
    AX_SA_ARIANOTIFICATIONIDDEPRECATED = 37,
    AX_SA_HTMLID = 38,
    AX_SA_ARIACELLCOLUMNINDEXTEXT = 39,
    AX_SA_ARIACELLROWINDEXTEXT = 40,
    AX_SA_DATETIME = 41,
    AX_SA_HTMLINPUTNAME = 42,
    AXStringAttribute_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
    AXStringAttribute_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AXStringAttribute_IsValid(int value);
constexpr AXStringAttribute AXStringAttribute_MIN = AX_SA_NONE;
constexpr AXStringAttribute AXStringAttribute_MAX = AX_SA_HTMLINPUTNAME;
constexpr int AXStringAttribute_ARRAYSIZE = AXStringAttribute_MAX + 1;

const std::string& AXStringAttribute_Name(AXStringAttribute value);
template <typename T> inline const std::string& AXStringAttribute_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, AXStringAttribute>::value || ::std::is_integral<T>::value, "Incorrect type passed to function AXStringAttribute_Name.");
    return AXStringAttribute_Name(static_cast<AXStringAttribute>(enum_t_value));
}
bool AXStringAttribute_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AXStringAttribute* value);
enum AXIntAttribute : int {
    AX_IA_NONE = 0,
    AX_IA_DEFAULTACTIONVERB = 1,
    AX_IA_SCROLLX = 2,
    AX_IA_SCROLLXMIN = 3,
    AX_IA_SCROLLXMAX = 4,
    AX_IA_SCROLLY = 5,
    AX_IA_SCROLLYMIN = 6,
    AX_IA_SCROLLYMAX = 7,
    AX_IA_TEXTSELSTART = 8,
    AX_IA_TEXTSELEND = 9,
    AX_IA_ARIACOLUMNCOUNT = 10,
    AX_IA_ARIACELLCOLUMNINDEX = 11,
    AX_IA_ARIACELLCOLUMNSPAN = 12,
    AX_IA_ARIAROWCOUNT = 13,
    AX_IA_ARIACELLROWINDEX = 14,
    AX_IA_ARIACELLROWSPAN = 15,
    AX_IA_TABLEROWCOUNT = 16,
    AX_IA_TABLECOLUMNCOUNT = 17,
    AX_IA_TABLEHEADERID = 18,
    AX_IA_TABLEROWINDEX = 19,
    AX_IA_TABLEROWHEADERID = 20,
    AX_IA_TABLECOLUMNINDEX = 21,
    AX_IA_TABLECOLUMNHEADERID = 22,
    AX_IA_TABLECELLCOLUMNINDEX = 23,
    AX_IA_TABLECELLCOLUMNSPAN = 24,
    AX_IA_TABLECELLROWINDEX = 25,
    AX_IA_TABLECELLROWSPAN = 26,
    AX_IA_SORTDIRECTION = 27,
    AX_IA_HIERARCHICALLEVEL = 28,
    AX_IA_NAMEFROM = 29,
    AX_IA_DESCRIPTIONFROM = 30,
    AX_IA_ACTIVEDESCENDANTID = 31,
    AX_IA_ERRORMESSAGEIDDEPRECATED = 32,
    AX_IA_INPAGELINKTARGETID = 33,
    AX_IA_MEMBEROFID = 34,
    AX_IA_NEXTONLINEID = 35,
    AX_IA_POPUPFORID = 36,
    AX_IA_PREVIOUSONLINEID = 37,
    AX_IA_RESTRICTION = 38,
    AX_IA_SETSIZE = 39,
    AX_IA_POSINSET = 40,
    AX_IA_COLORVALUE = 41,
    AX_IA_ARIACURRENTSTATE = 42,
    AX_IA_BACKGROUNDCOLOR = 43,
    AX_IA_COLOR = 44,
    AX_IA_HASPOPUP = 45,
    AX_IA_IMAGEANNOTATIONSTATUS = 46,
    AX_IA_INVALIDSTATE = 47,
    AX_IA_CHECKEDSTATE = 48,
    AX_IA_LISTSTYLE = 49,
    AX_IA_TEXTALIGN = 50,
    AX_IA_TEXTDIRECTION = 51,
    AX_IA_TEXTPOSITION = 52,
    AX_IA_TEXTSTYLE = 53,
    AX_IA_TEXTOVERLINESTYLE = 54,
    AX_IA_TEXTSTRIKETHROUGHSTYLE = 55,
    AX_IA_TEXTUNDERLINESTYLE = 56,
    AX_IA_PREVIOUSFOCUSID = 57,
    AX_IA_NEXTFOCUSID = 58,
    AX_IA_DROPEFFECTDEPRECATED = 59,
    AX_IA_DOMNODEIDDEPRECATED = 60,
    AX_IA_ISPOPUP = 61,
    AX_IA_NEXTWINDOWFOCUSID = 62,
    AX_IA_PREVIOUSWINDOWFOCUSID = 63,
    AX_IA_ARIANOTIFICATIONINTERRUPTDEPRECATED = 64,
    AX_IA_ARIANOTIFICATIONPRIORITYDEPRECATED = 65,
    AX_IA_DETAILSFROM = 66,
    AX_IA_MAXLENGTH = 67,
    AXIntAttribute_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
    AXIntAttribute_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AXIntAttribute_IsValid(int value);
constexpr AXIntAttribute AXIntAttribute_MIN = AX_IA_NONE;
constexpr AXIntAttribute AXIntAttribute_MAX = AX_IA_MAXLENGTH;
constexpr int AXIntAttribute_ARRAYSIZE = AXIntAttribute_MAX + 1;

const std::string& AXIntAttribute_Name(AXIntAttribute value);
template <typename T> inline const std::string& AXIntAttribute_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, AXIntAttribute>::value || ::std::is_integral<T>::value, "Incorrect type passed to function AXIntAttribute_Name.");
    return AXIntAttribute_Name(static_cast<AXIntAttribute>(enum_t_value));
}
bool AXIntAttribute_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AXIntAttribute* value);
enum AXFloatAttribute : int {
    AX_FA_NONE = 0,
    AX_FA_VALUEFORRANGE = 1,
    AX_FA_MINVALUEFORRANGE = 2,
    AX_FA_MAXVALUEFORRANGE = 3,
    AX_FA_STEPVALUEFORRANGE = 4,
    AX_FA_FONTSIZE = 5,
    AX_FA_FONTWEIGHT = 6,
    AX_FA_TEXTINDENT = 7,
    AX_FA_CHILDTREESCALE = 8,
    AXFloatAttribute_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
    AXFloatAttribute_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AXFloatAttribute_IsValid(int value);
constexpr AXFloatAttribute AXFloatAttribute_MIN = AX_FA_NONE;
constexpr AXFloatAttribute AXFloatAttribute_MAX = AX_FA_CHILDTREESCALE;
constexpr int AXFloatAttribute_ARRAYSIZE = AXFloatAttribute_MAX + 1;

const std::string& AXFloatAttribute_Name(AXFloatAttribute value);
template <typename T> inline const std::string& AXFloatAttribute_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, AXFloatAttribute>::value || ::std::is_integral<T>::value, "Incorrect type passed to function AXFloatAttribute_Name.");
    return AXFloatAttribute_Name(static_cast<AXFloatAttribute>(enum_t_value));
}
bool AXFloatAttribute_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AXFloatAttribute* value);
enum AXBoolAttribute : int {
    AX_BA_NONE = 0,
    AX_BA_BUSY = 1,
    AX_BA_NONATOMICTEXTFIELDROOT = 2,
    AX_BA_CONTAINERLIVEATOMIC = 3,
    AX_BA_CONTAINERLIVEBUSY = 4,
    AX_BA_LIVEATOMIC = 5,
    AX_BA_MODAL = 6,
    AX_BA_UPDATELOCATIONONLY = 7,
    AX_BA_CANVASHASFALLBACK = 8,
    AX_BA_SCROLLABLE = 9,
    AX_BA_CLICKABLE = 10,
    AX_BA_CLIPSCHILDREN = 11,
    AX_BA_NOTUSERSELECTABLESTYLE = 12,
    AX_BA_SELECTED = 13,
    AX_BA_SELECTEDFROMFOCUS = 14,
    AX_BA_SUPPORTSTEXTLOCATION = 15,
    AX_BA_GRABBEDDEPRECATED = 16,
    AX_BA_ISLINEBREAKINGOBJECT = 17,
    AX_BA_ISPAGEBREAKINGOBJECT = 18,
    AX_BA_HASARIAATTRIBUTE = 19,
    AX_BA_TOUCHPASSTHROUGHDEPRECATED = 20,
    AX_BA_LONGCLICKABLE = 21,
    AX_BA_HASHIDDENOFFSCREENNODES = 22,
    AXBoolAttribute_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
    AXBoolAttribute_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AXBoolAttribute_IsValid(int value);
constexpr AXBoolAttribute AXBoolAttribute_MIN = AX_BA_NONE;
constexpr AXBoolAttribute AXBoolAttribute_MAX = AX_BA_HASHIDDENOFFSCREENNODES;
constexpr int AXBoolAttribute_ARRAYSIZE = AXBoolAttribute_MAX + 1;

const std::string& AXBoolAttribute_Name(AXBoolAttribute value);
template <typename T> inline const std::string& AXBoolAttribute_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, AXBoolAttribute>::value || ::std::is_integral<T>::value, "Incorrect type passed to function AXBoolAttribute_Name.");
    return AXBoolAttribute_Name(static_cast<AXBoolAttribute>(enum_t_value));
}
bool AXBoolAttribute_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AXBoolAttribute* value);
enum AXIntListAttribute : int {
    AX_ILA_NONE = 0,
    AX_ILA_INDIRECTCHILDIDS = 1,
    AX_ILA_ACTIONSIDS = 29,
    AX_ILA_CONTROLSIDS = 2,
    AX_ILA_DETAILSIDS = 3,
    AX_ILA_DESCRIBEDBYIDS = 4,
    AX_ILA_FLOWTOIDS = 5,
    AX_ILA_LABELLEDBYIDS = 6,
    AX_ILA_RADIOGROUPIDS = 7,
    AX_ILA_MARKERTYPES = 8,
    AX_ILA_MARKERSTARTS = 9,
    AX_ILA_MARKERENDS = 10,
    AX_ILA_CHARACTEROFFSETS = 11,
    AX_ILA_LINESTARTS = 12,
    AX_ILA_WORDSTARTS = 13,
    AX_ILA_WORDENDS = 14,
    AX_ILA_CUSTOMACTIONIDS = 15,
    AX_ILA_CARETBOUNDS = 16,
    AX_ILA_LINEENDS = 17,
    AX_ILA_SENTENCESTARTS = 18,
    AX_ILA_SENTENCEENDS = 19,
    AX_ILA_HIGHLIGHTTYPES = 20,
    AX_ILA_TEXTOPERATIONSTARTANCHORIDS = 21,
    AX_ILA_TEXTOPERATIONSTARTOFFSETS = 22,
    AX_ILA_TEXTOPERATIONENDANCHORIDS = 23,
    AX_ILA_TEXTOPERATIONENDOFFSETS = 24,
    AX_ILA_TEXTOPERATIONS = 25,
    AX_ILA_ERRORMESSAGEIDS = 26,
    AX_ILA_ARIANOTIFICATIONINTERRUPTPROPERTIES = 27,
    AX_ILA_ARIANOTIFICATIONPRIORITYPROPERTIES = 28,
    AXIntListAttribute_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
    AXIntListAttribute_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AXIntListAttribute_IsValid(int value);
constexpr AXIntListAttribute AXIntListAttribute_MIN = AX_ILA_NONE;
constexpr AXIntListAttribute AXIntListAttribute_MAX = AX_ILA_ACTIONSIDS;
constexpr int AXIntListAttribute_ARRAYSIZE = AXIntListAttribute_MAX + 1;

const std::string& AXIntListAttribute_Name(AXIntListAttribute value);
template <typename T> inline const std::string& AXIntListAttribute_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, AXIntListAttribute>::value || ::std::is_integral<T>::value, "Incorrect type passed to function AXIntListAttribute_Name.");
    return AXIntListAttribute_Name(static_cast<AXIntListAttribute>(enum_t_value));
}
bool AXIntListAttribute_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AXIntListAttribute* value);
enum AXStringListAttribute : int {
    AX_SLA_NONE = 0,
    AX_SLA_CUSTOMACTIONDESCRIPTIONS = 1,
    AX_SLA_ARIANOTIFICATIONANNOUNCEMENTS = 2,
    AX_SLA_ARIANOTIFICATIONIDS = 3,
    AXStringListAttribute_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
    AXStringListAttribute_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AXStringListAttribute_IsValid(int value);
constexpr AXStringListAttribute AXStringListAttribute_MIN = AX_SLA_NONE;
constexpr AXStringListAttribute AXStringListAttribute_MAX = AX_SLA_ARIANOTIFICATIONIDS;
constexpr int AXStringListAttribute_ARRAYSIZE = AXStringListAttribute_MAX + 1;

const std::string& AXStringListAttribute_Name(AXStringListAttribute value);
template <typename T> inline const std::string& AXStringListAttribute_Name(T enum_t_value)
{
    static_assert(
        ::std::is_same<T, AXStringListAttribute>::value || ::std::is_integral<T>::value, "Incorrect type passed to function AXStringListAttribute_Name.");
    return AXStringListAttribute_Name(static_cast<AXStringListAttribute>(enum_t_value));
}
bool AXStringListAttribute_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AXStringListAttribute* value);
enum FormControlType : int {
    FORM_CONTROL_TYPE_UNSPECIFIED = 0,
    FORM_CONTROL_TYPE_CONTENT_EDITABLE = 1,
    FORM_CONTROL_TYPE_INPUT_CHECKBOX = 2,
    FORM_CONTROL_TYPE_INPUT_EMAIL = 3,
    FORM_CONTROL_TYPE_INPUT_MONTH = 4,
    FORM_CONTROL_TYPE_INPUT_NUMBER = 5,
    FORM_CONTROL_TYPE_INPUT_PASSWORD = 6,
    FORM_CONTROL_TYPE_INPUT_RADIO = 7,
    FORM_CONTROL_TYPE_INPUT_SEARCH = 8,
    FORM_CONTROL_TYPE_INPUT_TELEPHONE = 9,
    FORM_CONTROL_TYPE_INPUT_TEXT = 10,
    FORM_CONTROL_TYPE_INPUT_URL = 11,
    FORM_CONTROL_TYPE_SELECT_ONE = 12,
    FORM_CONTROL_TYPE_SELECT_MULTIPLE = 13,
    FORM_CONTROL_TYPE_TEXT_AREA = 15,
    FormControlType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
    FormControlType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool FormControlType_IsValid(int value);
constexpr FormControlType FormControlType_MIN = FORM_CONTROL_TYPE_UNSPECIFIED;
constexpr FormControlType FormControlType_MAX = FORM_CONTROL_TYPE_TEXT_AREA;
constexpr int FormControlType_ARRAYSIZE = FormControlType_MAX + 1;

const std::string& FormControlType_Name(FormControlType value);
template <typename T> inline const std::string& FormControlType_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, FormControlType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function FormControlType_Name.");
    return FormControlType_Name(static_cast<FormControlType>(enum_t_value));
}
bool FormControlType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FormControlType* value);
enum FinalModelStatus : int {
    FINAL_MODEL_STATUS_UNSPECIFIED = 0,
    FINAL_MODEL_STATUS_SUCCESS = 1,
    FINAL_MODEL_STATUS_FAILURE = 2,
    FinalModelStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
    FinalModelStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool FinalModelStatus_IsValid(int value);
constexpr FinalModelStatus FinalModelStatus_MIN = FINAL_MODEL_STATUS_UNSPECIFIED;
constexpr FinalModelStatus FinalModelStatus_MAX = FINAL_MODEL_STATUS_FAILURE;
constexpr int FinalModelStatus_ARRAYSIZE = FinalModelStatus_MAX + 1;

const std::string& FinalModelStatus_Name(FinalModelStatus value);
template <typename T> inline const std::string& FinalModelStatus_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, FinalModelStatus>::value || ::std::is_integral<T>::value, "Incorrect type passed to function FinalModelStatus_Name.");
    return FinalModelStatus_Name(static_cast<FinalModelStatus>(enum_t_value));
}
bool FinalModelStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FinalModelStatus* value);
enum UserFeedback : int {
    USER_FEEDBACK_UNSPECIFIED = 0,
    USER_FEEDBACK_THUMBS_DOWN = 1,
    USER_FEEDBACK_THUMBS_UP = 2,
    UserFeedback_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
    UserFeedback_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool UserFeedback_IsValid(int value);
constexpr UserFeedback UserFeedback_MIN = USER_FEEDBACK_UNSPECIFIED;
constexpr UserFeedback UserFeedback_MAX = USER_FEEDBACK_THUMBS_UP;
constexpr int UserFeedback_ARRAYSIZE = UserFeedback_MAX + 1;

const std::string& UserFeedback_Name(UserFeedback value);
template <typename T> inline const std::string& UserFeedback_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, UserFeedback>::value || ::std::is_integral<T>::value, "Incorrect type passed to function UserFeedback_Name.");
    return UserFeedback_Name(static_cast<UserFeedback>(enum_t_value));
}
bool UserFeedback_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UserFeedback* value);
// ===================================================================

class FloatArray final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.FloatArray) */ {
public:
    inline FloatArray()
        : FloatArray(nullptr)
    {
    }
    ~FloatArray() override;
    explicit PROTOBUF_CONSTEXPR FloatArray(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    FloatArray(const FloatArray& from);
    FloatArray(FloatArray&& from) noexcept
        : FloatArray()
    {
        *this = ::std::move(from);
    }

    inline FloatArray& operator=(const FloatArray& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline FloatArray& operator=(FloatArray&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const FloatArray& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const FloatArray* internal_default_instance()
    {
        return reinterpret_cast<const FloatArray*>(&_FloatArray_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 0;

    friend void swap(FloatArray& a, FloatArray& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(FloatArray* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(FloatArray* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    FloatArray* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<FloatArray>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const FloatArray& from);
    void MergeFrom(const FloatArray& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(FloatArray* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "optimization_guide.proto.FloatArray";
    }

protected:
    explicit FloatArray(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kValuesFieldNumber = 1,
    };
    // repeated float values = 1;
    int values_size() const;

private:
    int _internal_values_size() const;

public:
    void clear_values();

private:
    float _internal_values(int index) const;
    const ::PROTOBUF_NAMESPACE_ID::RepeatedField<float>& _internal_values() const;
    void _internal_add_values(float value);
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<float>* _internal_mutable_values();

public:
    float values(int index) const;
    void set_values(int index, float value);
    void add_values(float value);
    const ::PROTOBUF_NAMESPACE_ID::RepeatedField<float>& values() const;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<float>* mutable_values();

    // @@protoc_insertion_point(class_scope:optimization_guide.proto.FloatArray)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedField<float> values_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2foptimization_5fguide_2fproto_2ffeatures_2fcommon_5fquality_5fdata_2eproto;
};
// -------------------------------------------------------------------

class Embedding final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.Embedding) */ {
public:
    inline Embedding()
        : Embedding(nullptr)
    {
    }
    ~Embedding() override;
    explicit PROTOBUF_CONSTEXPR Embedding(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    Embedding(const Embedding& from);
    Embedding(Embedding&& from) noexcept
        : Embedding()
    {
        *this = ::std::move(from);
    }

    inline Embedding& operator=(const Embedding& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline Embedding& operator=(Embedding&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const Embedding& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const Embedding* internal_default_instance()
    {
        return reinterpret_cast<const Embedding*>(&_Embedding_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 1;

    friend void swap(Embedding& a, Embedding& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(Embedding* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(Embedding* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    Embedding* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<Embedding>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const Embedding& from);
    void MergeFrom(const Embedding& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(Embedding* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "optimization_guide.proto.Embedding";
    }

protected:
    explicit Embedding(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kFloatsFieldNumber = 1,
    };
    // .optimization_guide.proto.FloatArray floats = 1;
    bool has_floats() const;

private:
    bool _internal_has_floats() const;

public:
    void clear_floats();
    const ::optimization_guide::proto::FloatArray& floats() const;
    PROTOBUF_NODISCARD ::optimization_guide::proto::FloatArray* release_floats();
    ::optimization_guide::proto::FloatArray* mutable_floats();
    void set_allocated_floats(::optimization_guide::proto::FloatArray* floats);

private:
    const ::optimization_guide::proto::FloatArray& _internal_floats() const;
    ::optimization_guide::proto::FloatArray* _internal_mutable_floats();

public:
    void unsafe_arena_set_allocated_floats(::optimization_guide::proto::FloatArray* floats);
    ::optimization_guide::proto::FloatArray* unsafe_arena_release_floats();

    // @@protoc_insertion_point(class_scope:optimization_guide.proto.Embedding)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::optimization_guide::proto::FloatArray* floats_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2foptimization_5fguide_2fproto_2ffeatures_2fcommon_5fquality_5fdata_2eproto;
};
// -------------------------------------------------------------------

class AXTreeUpdate final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.AXTreeUpdate) */ {
public:
    inline AXTreeUpdate()
        : AXTreeUpdate(nullptr)
    {
    }
    ~AXTreeUpdate() override;
    explicit PROTOBUF_CONSTEXPR AXTreeUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    AXTreeUpdate(const AXTreeUpdate& from);
    AXTreeUpdate(AXTreeUpdate&& from) noexcept
        : AXTreeUpdate()
    {
        *this = ::std::move(from);
    }

    inline AXTreeUpdate& operator=(const AXTreeUpdate& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline AXTreeUpdate& operator=(AXTreeUpdate&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const AXTreeUpdate& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const AXTreeUpdate* internal_default_instance()
    {
        return reinterpret_cast<const AXTreeUpdate*>(&_AXTreeUpdate_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 2;

    friend void swap(AXTreeUpdate& a, AXTreeUpdate& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(AXTreeUpdate* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(AXTreeUpdate* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    AXTreeUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<AXTreeUpdate>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const AXTreeUpdate& from);
    void MergeFrom(const AXTreeUpdate& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(AXTreeUpdate* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "optimization_guide.proto.AXTreeUpdate";
    }

protected:
    explicit AXTreeUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kNodesFieldNumber = 3,
        kTreeDataFieldNumber = 1,
        kRootIdFieldNumber = 2,
    };
    // repeated .optimization_guide.proto.AXNodeData nodes = 3;
    int nodes_size() const;

private:
    int _internal_nodes_size() const;

public:
    void clear_nodes();
    ::optimization_guide::proto::AXNodeData* mutable_nodes(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::AXNodeData>* mutable_nodes();

private:
    const ::optimization_guide::proto::AXNodeData& _internal_nodes(int index) const;
    ::optimization_guide::proto::AXNodeData* _internal_add_nodes();

public:
    const ::optimization_guide::proto::AXNodeData& nodes(int index) const;
    ::optimization_guide::proto::AXNodeData* add_nodes();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::AXNodeData>& nodes() const;

    // optional .optimization_guide.proto.AXTreeData tree_data = 1;
    bool has_tree_data() const;

private:
    bool _internal_has_tree_data() const;

public:
    void clear_tree_data();
    const ::optimization_guide::proto::AXTreeData& tree_data() const;
    PROTOBUF_NODISCARD ::optimization_guide::proto::AXTreeData* release_tree_data();
    ::optimization_guide::proto::AXTreeData* mutable_tree_data();
    void set_allocated_tree_data(::optimization_guide::proto::AXTreeData* tree_data);

private:
    const ::optimization_guide::proto::AXTreeData& _internal_tree_data() const;
    ::optimization_guide::proto::AXTreeData* _internal_mutable_tree_data();

public:
    void unsafe_arena_set_allocated_tree_data(::optimization_guide::proto::AXTreeData* tree_data);
    ::optimization_guide::proto::AXTreeData* unsafe_arena_release_tree_data();

    // uint32 root_id = 2;
    void clear_root_id();
    uint32_t root_id() const;
    void set_root_id(uint32_t value);

private:
    uint32_t _internal_root_id() const;
    void _internal_set_root_id(uint32_t value);

public:
    // @@protoc_insertion_point(class_scope:optimization_guide.proto.AXTreeUpdate)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::AXNodeData> nodes_;
        ::optimization_guide::proto::AXTreeData* tree_data_;
        uint32_t root_id_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2foptimization_5fguide_2fproto_2ffeatures_2fcommon_5fquality_5fdata_2eproto;
};
// -------------------------------------------------------------------

class AXTreeData final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.AXTreeData) */ {
public:
    inline AXTreeData()
        : AXTreeData(nullptr)
    {
    }
    ~AXTreeData() override;
    explicit PROTOBUF_CONSTEXPR AXTreeData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    AXTreeData(const AXTreeData& from);
    AXTreeData(AXTreeData&& from) noexcept
        : AXTreeData()
    {
        *this = ::std::move(from);
    }

    inline AXTreeData& operator=(const AXTreeData& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline AXTreeData& operator=(AXTreeData&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const AXTreeData& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const AXTreeData* internal_default_instance()
    {
        return reinterpret_cast<const AXTreeData*>(&_AXTreeData_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 3;

    friend void swap(AXTreeData& a, AXTreeData& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(AXTreeData* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(AXTreeData* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    AXTreeData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<AXTreeData>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const AXTreeData& from);
    void MergeFrom(const AXTreeData& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(AXTreeData* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "optimization_guide.proto.AXTreeData";
    }

protected:
    explicit AXTreeData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kMetadataFieldNumber = 15,
        kDoctypeFieldNumber = 1,
        kMimetypeFieldNumber = 4,
        kTitleFieldNumber = 5,
        kLoadingProgressFieldNumber = 3,
        kLoadedFieldNumber = 2,
        kSelIsBackwardFieldNumber = 7,
        kFocusIdFieldNumber = 6,
        kSelAnchorObjectIdFieldNumber = 8,
        kSelAnchorOffsetFieldNumber = 9,
        kSelAnchorAffinityFieldNumber = 10,
        kSelFocusObjectIdFieldNumber = 11,
        kSelFocusOffsetFieldNumber = 12,
        kSelFocusAffinityFieldNumber = 13,
        kRootScrollerIdFieldNumber = 14,
    };
    // repeated string metadata = 15;
    int metadata_size() const;

private:
    int _internal_metadata_size() const;

public:
    void clear_metadata();
    const std::string& metadata(int index) const;
    std::string* mutable_metadata(int index);
    void set_metadata(int index, const std::string& value);
    void set_metadata(int index, std::string&& value);
    void set_metadata(int index, const char* value);
    void set_metadata(int index, const char* value, size_t size);
    std::string* add_metadata();
    void add_metadata(const std::string& value);
    void add_metadata(std::string&& value);
    void add_metadata(const char* value);
    void add_metadata(const char* value, size_t size);
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& metadata() const;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_metadata();

private:
    const std::string& _internal_metadata(int index) const;
    std::string* _internal_add_metadata();

public:
    // string doctype = 1;
    void clear_doctype();
    const std::string& doctype() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_doctype(ArgT0&& arg0, ArgT... args);
    std::string* mutable_doctype();
    PROTOBUF_NODISCARD std::string* release_doctype();
    void set_allocated_doctype(std::string* doctype);

private:
    const std::string& _internal_doctype() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_doctype(const std::string& value);
    std::string* _internal_mutable_doctype();

public:
    // string mimetype = 4;
    void clear_mimetype();
    const std::string& mimetype() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_mimetype(ArgT0&& arg0, ArgT... args);
    std::string* mutable_mimetype();
    PROTOBUF_NODISCARD std::string* release_mimetype();
    void set_allocated_mimetype(std::string* mimetype);

private:
    const std::string& _internal_mimetype() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_mimetype(const std::string& value);
    std::string* _internal_mutable_mimetype();

public:
    // string title = 5;
    void clear_title();
    const std::string& title() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_title(ArgT0&& arg0, ArgT... args);
    std::string* mutable_title();
    PROTOBUF_NODISCARD std::string* release_title();
    void set_allocated_title(std::string* title);

private:
    const std::string& _internal_title() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
    std::string* _internal_mutable_title();

public:
    // float loading_progress = 3;
    void clear_loading_progress();
    float loading_progress() const;
    void set_loading_progress(float value);

private:
    float _internal_loading_progress() const;
    void _internal_set_loading_progress(float value);

public:
    // bool loaded = 2;
    void clear_loaded();
    bool loaded() const;
    void set_loaded(bool value);

private:
    bool _internal_loaded() const;
    void _internal_set_loaded(bool value);

public:
    // bool sel_is_backward = 7;
    void clear_sel_is_backward();
    bool sel_is_backward() const;
    void set_sel_is_backward(bool value);

private:
    bool _internal_sel_is_backward() const;
    void _internal_set_sel_is_backward(bool value);

public:
    // uint32 focus_id = 6;
    void clear_focus_id();
    uint32_t focus_id() const;
    void set_focus_id(uint32_t value);

private:
    uint32_t _internal_focus_id() const;
    void _internal_set_focus_id(uint32_t value);

public:
    // uint32 sel_anchor_object_id = 8;
    void clear_sel_anchor_object_id();
    uint32_t sel_anchor_object_id() const;
    void set_sel_anchor_object_id(uint32_t value);

private:
    uint32_t _internal_sel_anchor_object_id() const;
    void _internal_set_sel_anchor_object_id(uint32_t value);

public:
    // uint32 sel_anchor_offset = 9;
    void clear_sel_anchor_offset();
    uint32_t sel_anchor_offset() const;
    void set_sel_anchor_offset(uint32_t value);

private:
    uint32_t _internal_sel_anchor_offset() const;
    void _internal_set_sel_anchor_offset(uint32_t value);

public:
    // .optimization_guide.proto.AXTextAffinity sel_anchor_affinity = 10;
    void clear_sel_anchor_affinity();
    ::optimization_guide::proto::AXTextAffinity sel_anchor_affinity() const;
    void set_sel_anchor_affinity(::optimization_guide::proto::AXTextAffinity value);

private:
    ::optimization_guide::proto::AXTextAffinity _internal_sel_anchor_affinity() const;
    void _internal_set_sel_anchor_affinity(::optimization_guide::proto::AXTextAffinity value);

public:
    // uint32 sel_focus_object_id = 11;
    void clear_sel_focus_object_id();
    uint32_t sel_focus_object_id() const;
    void set_sel_focus_object_id(uint32_t value);

private:
    uint32_t _internal_sel_focus_object_id() const;
    void _internal_set_sel_focus_object_id(uint32_t value);

public:
    // uint32 sel_focus_offset = 12;
    void clear_sel_focus_offset();
    uint32_t sel_focus_offset() const;
    void set_sel_focus_offset(uint32_t value);

private:
    uint32_t _internal_sel_focus_offset() const;
    void _internal_set_sel_focus_offset(uint32_t value);

public:
    // .optimization_guide.proto.AXTextAffinity sel_focus_affinity = 13;
    void clear_sel_focus_affinity();
    ::optimization_guide::proto::AXTextAffinity sel_focus_affinity() const;
    void set_sel_focus_affinity(::optimization_guide::proto::AXTextAffinity value);

private:
    ::optimization_guide::proto::AXTextAffinity _internal_sel_focus_affinity() const;
    void _internal_set_sel_focus_affinity(::optimization_guide::proto::AXTextAffinity value);

public:
    // uint32 root_scroller_id = 14;
    void clear_root_scroller_id();
    uint32_t root_scroller_id() const;
    void set_root_scroller_id(uint32_t value);

private:
    uint32_t _internal_root_scroller_id() const;
    void _internal_set_root_scroller_id(uint32_t value);

public:
    // @@protoc_insertion_point(class_scope:optimization_guide.proto.AXTreeData)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> metadata_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr doctype_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mimetype_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
        float loading_progress_;
        bool loaded_;
        bool sel_is_backward_;
        uint32_t focus_id_;
        uint32_t sel_anchor_object_id_;
        uint32_t sel_anchor_offset_;
        int sel_anchor_affinity_;
        uint32_t sel_focus_object_id_;
        uint32_t sel_focus_offset_;
        int sel_focus_affinity_;
        uint32_t root_scroller_id_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2foptimization_5fguide_2fproto_2ffeatures_2fcommon_5fquality_5fdata_2eproto;
};
// -------------------------------------------------------------------

class AXNodeData final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.AXNodeData) */ {
public:
    inline AXNodeData()
        : AXNodeData(nullptr)
    {
    }
    ~AXNodeData() override;
    explicit PROTOBUF_CONSTEXPR AXNodeData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    AXNodeData(const AXNodeData& from);
    AXNodeData(AXNodeData&& from) noexcept
        : AXNodeData()
    {
        *this = ::std::move(from);
    }

    inline AXNodeData& operator=(const AXNodeData& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline AXNodeData& operator=(AXNodeData&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const AXNodeData& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const AXNodeData* internal_default_instance()
    {
        return reinterpret_cast<const AXNodeData*>(&_AXNodeData_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 4;

    friend void swap(AXNodeData& a, AXNodeData& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(AXNodeData* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(AXNodeData* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    AXNodeData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<AXNodeData>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const AXNodeData& from);
    void MergeFrom(const AXNodeData& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(AXNodeData* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "optimization_guide.proto.AXNodeData";
    }

protected:
    explicit AXNodeData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kAttributesFieldNumber = 5,
        kChildIdsFieldNumber = 6,
        kRelativeBoundsFieldNumber = 7,
        kIdFieldNumber = 1,
        kRoleFieldNumber = 2,
        kActionsFieldNumber = 4,
        kStateFieldNumber = 3,
    };
    // repeated .optimization_guide.proto.AXAttribute attributes = 5;
    int attributes_size() const;

private:
    int _internal_attributes_size() const;

public:
    void clear_attributes();
    ::optimization_guide::proto::AXAttribute* mutable_attributes(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::AXAttribute>* mutable_attributes();

private:
    const ::optimization_guide::proto::AXAttribute& _internal_attributes(int index) const;
    ::optimization_guide::proto::AXAttribute* _internal_add_attributes();

public:
    const ::optimization_guide::proto::AXAttribute& attributes(int index) const;
    ::optimization_guide::proto::AXAttribute* add_attributes();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::AXAttribute>& attributes() const;

    // repeated int32 child_ids = 6;
    int child_ids_size() const;

private:
    int _internal_child_ids_size() const;

public:
    void clear_child_ids();

private:
    int32_t _internal_child_ids(int index) const;
    const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>& _internal_child_ids() const;
    void _internal_add_child_ids(int32_t value);
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>* _internal_mutable_child_ids();

public:
    int32_t child_ids(int index) const;
    void set_child_ids(int index, int32_t value);
    void add_child_ids(int32_t value);
    const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>& child_ids() const;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>* mutable_child_ids();

    // .optimization_guide.proto.AXRelativeBounds relative_bounds = 7;
    bool has_relative_bounds() const;

private:
    bool _internal_has_relative_bounds() const;

public:
    void clear_relative_bounds();
    const ::optimization_guide::proto::AXRelativeBounds& relative_bounds() const;
    PROTOBUF_NODISCARD ::optimization_guide::proto::AXRelativeBounds* release_relative_bounds();
    ::optimization_guide::proto::AXRelativeBounds* mutable_relative_bounds();
    void set_allocated_relative_bounds(::optimization_guide::proto::AXRelativeBounds* relative_bounds);

private:
    const ::optimization_guide::proto::AXRelativeBounds& _internal_relative_bounds() const;
    ::optimization_guide::proto::AXRelativeBounds* _internal_mutable_relative_bounds();

public:
    void unsafe_arena_set_allocated_relative_bounds(::optimization_guide::proto::AXRelativeBounds* relative_bounds);
    ::optimization_guide::proto::AXRelativeBounds* unsafe_arena_release_relative_bounds();

    // uint32 id = 1;
    void clear_id();
    uint32_t id() const;
    void set_id(uint32_t value);

private:
    uint32_t _internal_id() const;
    void _internal_set_id(uint32_t value);

public:
    // .optimization_guide.proto.AXRole role = 2;
    void clear_role();
    ::optimization_guide::proto::AXRole role() const;
    void set_role(::optimization_guide::proto::AXRole value);

private:
    ::optimization_guide::proto::AXRole _internal_role() const;
    void _internal_set_role(::optimization_guide::proto::AXRole value);

public:
    // uint64 actions = 4;
    void clear_actions();
    uint64_t actions() const;
    void set_actions(uint64_t value);

private:
    uint64_t _internal_actions() const;
    void _internal_set_actions(uint64_t value);

public:
    // uint32 state = 3;
    void clear_state();
    uint32_t state() const;
    void set_state(uint32_t value);

private:
    uint32_t _internal_state() const;
    void _internal_set_state(uint32_t value);

public:
    // @@protoc_insertion_point(class_scope:optimization_guide.proto.AXNodeData)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::AXAttribute> attributes_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t> child_ids_;
        mutable std::atomic<int> _child_ids_cached_byte_size_;
        ::optimization_guide::proto::AXRelativeBounds* relative_bounds_;
        uint32_t id_;
        int role_;
        uint64_t actions_;
        uint32_t state_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2foptimization_5fguide_2fproto_2ffeatures_2fcommon_5fquality_5fdata_2eproto;
};
// -------------------------------------------------------------------

class AXAttribute final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.AXAttribute) */ {
public:
    inline AXAttribute()
        : AXAttribute(nullptr)
    {
    }
    ~AXAttribute() override;
    explicit PROTOBUF_CONSTEXPR AXAttribute(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    AXAttribute(const AXAttribute& from);
    AXAttribute(AXAttribute&& from) noexcept
        : AXAttribute()
    {
        *this = ::std::move(from);
    }

    inline AXAttribute& operator=(const AXAttribute& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline AXAttribute& operator=(AXAttribute&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const AXAttribute& default_instance()
    {
        return *internal_default_instance();
    }
    enum AttributeKeyCase {
        kStringType = 1,
        kIntType = 2,
        kFloatType = 3,
        kBoolType = 4,
        kIntlistType = 5,
        kStringlistType = 6,
        kHtmlAttributeName = 7,
        ATTRIBUTE_KEY_NOT_SET = 0,
    };

    enum AttributeValueCase {
        kStringValue = 8,
        kIntValue = 9,
        kFloatValue = 10,
        kBoolValue = 11,
        kIntListValue = 12,
        kStringListValue = 13,
        kHtmlAttributeValue = 14,
        ATTRIBUTE_VALUE_NOT_SET = 0,
    };

    static inline const AXAttribute* internal_default_instance()
    {
        return reinterpret_cast<const AXAttribute*>(&_AXAttribute_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 5;

    friend void swap(AXAttribute& a, AXAttribute& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(AXAttribute* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(AXAttribute* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    AXAttribute* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<AXAttribute>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const AXAttribute& from);
    void MergeFrom(const AXAttribute& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(AXAttribute* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "optimization_guide.proto.AXAttribute";
    }

protected:
    explicit AXAttribute(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kStringTypeFieldNumber = 1,
        kIntTypeFieldNumber = 2,
        kFloatTypeFieldNumber = 3,
        kBoolTypeFieldNumber = 4,
        kIntlistTypeFieldNumber = 5,
        kStringlistTypeFieldNumber = 6,
        kHtmlAttributeNameFieldNumber = 7,
        kStringValueFieldNumber = 8,
        kIntValueFieldNumber = 9,
        kFloatValueFieldNumber = 10,
        kBoolValueFieldNumber = 11,
        kIntListValueFieldNumber = 12,
        kStringListValueFieldNumber = 13,
        kHtmlAttributeValueFieldNumber = 14,
    };
    // .optimization_guide.proto.AXStringAttribute string_type = 1;
    bool has_string_type() const;

private:
    bool _internal_has_string_type() const;

public:
    void clear_string_type();
    ::optimization_guide::proto::AXStringAttribute string_type() const;
    void set_string_type(::optimization_guide::proto::AXStringAttribute value);

private:
    ::optimization_guide::proto::AXStringAttribute _internal_string_type() const;
    void _internal_set_string_type(::optimization_guide::proto::AXStringAttribute value);

public:
    // .optimization_guide.proto.AXIntAttribute int_type = 2;
    bool has_int_type() const;

private:
    bool _internal_has_int_type() const;

public:
    void clear_int_type();
    ::optimization_guide::proto::AXIntAttribute int_type() const;
    void set_int_type(::optimization_guide::proto::AXIntAttribute value);

private:
    ::optimization_guide::proto::AXIntAttribute _internal_int_type() const;
    void _internal_set_int_type(::optimization_guide::proto::AXIntAttribute value);

public:
    // .optimization_guide.proto.AXFloatAttribute float_type = 3;
    bool has_float_type() const;

private:
    bool _internal_has_float_type() const;

public:
    void clear_float_type();
    ::optimization_guide::proto::AXFloatAttribute float_type() const;
    void set_float_type(::optimization_guide::proto::AXFloatAttribute value);

private:
    ::optimization_guide::proto::AXFloatAttribute _internal_float_type() const;
    void _internal_set_float_type(::optimization_guide::proto::AXFloatAttribute value);

public:
    // .optimization_guide.proto.AXBoolAttribute bool_type = 4;
    bool has_bool_type() const;

private:
    bool _internal_has_bool_type() const;

public:
    void clear_bool_type();
    ::optimization_guide::proto::AXBoolAttribute bool_type() const;
    void set_bool_type(::optimization_guide::proto::AXBoolAttribute value);

private:
    ::optimization_guide::proto::AXBoolAttribute _internal_bool_type() const;
    void _internal_set_bool_type(::optimization_guide::proto::AXBoolAttribute value);

public:
    // .optimization_guide.proto.AXIntListAttribute intlist_type = 5;
    bool has_intlist_type() const;

private:
    bool _internal_has_intlist_type() const;

public:
    void clear_intlist_type();
    ::optimization_guide::proto::AXIntListAttribute intlist_type() const;
    void set_intlist_type(::optimization_guide::proto::AXIntListAttribute value);

private:
    ::optimization_guide::proto::AXIntListAttribute _internal_intlist_type() const;
    void _internal_set_intlist_type(::optimization_guide::proto::AXIntListAttribute value);

public:
    // .optimization_guide.proto.AXStringListAttribute stringlist_type = 6;
    bool has_stringlist_type() const;

private:
    bool _internal_has_stringlist_type() const;

public:
    void clear_stringlist_type();
    ::optimization_guide::proto::AXStringListAttribute stringlist_type() const;
    void set_stringlist_type(::optimization_guide::proto::AXStringListAttribute value);

private:
    ::optimization_guide::proto::AXStringListAttribute _internal_stringlist_type() const;
    void _internal_set_stringlist_type(::optimization_guide::proto::AXStringListAttribute value);

public:
    // string html_attribute_name = 7;
    bool has_html_attribute_name() const;

private:
    bool _internal_has_html_attribute_name() const;

public:
    void clear_html_attribute_name();
    const std::string& html_attribute_name() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_html_attribute_name(ArgT0&& arg0, ArgT... args);
    std::string* mutable_html_attribute_name();
    PROTOBUF_NODISCARD std::string* release_html_attribute_name();
    void set_allocated_html_attribute_name(std::string* html_attribute_name);

private:
    const std::string& _internal_html_attribute_name() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_html_attribute_name(const std::string& value);
    std::string* _internal_mutable_html_attribute_name();

public:
    // string string_value = 8;
    bool has_string_value() const;

private:
    bool _internal_has_string_value() const;

public:
    void clear_string_value();
    const std::string& string_value() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_string_value(ArgT0&& arg0, ArgT... args);
    std::string* mutable_string_value();
    PROTOBUF_NODISCARD std::string* release_string_value();
    void set_allocated_string_value(std::string* string_value);

private:
    const std::string& _internal_string_value() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_string_value(const std::string& value);
    std::string* _internal_mutable_string_value();

public:
    // int32 int_value = 9;
    bool has_int_value() const;

private:
    bool _internal_has_int_value() const;

public:
    void clear_int_value();
    int32_t int_value() const;
    void set_int_value(int32_t value);

private:
    int32_t _internal_int_value() const;
    void _internal_set_int_value(int32_t value);

public:
    // float float_value = 10;
    bool has_float_value() const;

private:
    bool _internal_has_float_value() const;

public:
    void clear_float_value();
    float float_value() const;
    void set_float_value(float value);

private:
    float _internal_float_value() const;
    void _internal_set_float_value(float value);

public:
    // bool bool_value = 11;
    bool has_bool_value() const;

private:
    bool _internal_has_bool_value() const;

public:
    void clear_bool_value();
    bool bool_value() const;
    void set_bool_value(bool value);

private:
    bool _internal_bool_value() const;
    void _internal_set_bool_value(bool value);

public:
    // .optimization_guide.proto.AXIntList int_list_value = 12;
    bool has_int_list_value() const;

private:
    bool _internal_has_int_list_value() const;

public:
    void clear_int_list_value();
    const ::optimization_guide::proto::AXIntList& int_list_value() const;
    PROTOBUF_NODISCARD ::optimization_guide::proto::AXIntList* release_int_list_value();
    ::optimization_guide::proto::AXIntList* mutable_int_list_value();
    void set_allocated_int_list_value(::optimization_guide::proto::AXIntList* int_list_value);

private:
    const ::optimization_guide::proto::AXIntList& _internal_int_list_value() const;
    ::optimization_guide::proto::AXIntList* _internal_mutable_int_list_value();

public:
    void unsafe_arena_set_allocated_int_list_value(::optimization_guide::proto::AXIntList* int_list_value);
    ::optimization_guide::proto::AXIntList* unsafe_arena_release_int_list_value();

    // .optimization_guide.proto.AXStringList string_list_value = 13;
    bool has_string_list_value() const;

private:
    bool _internal_has_string_list_value() const;

public:
    void clear_string_list_value();
    const ::optimization_guide::proto::AXStringList& string_list_value() const;
    PROTOBUF_NODISCARD ::optimization_guide::proto::AXStringList* release_string_list_value();
    ::optimization_guide::proto::AXStringList* mutable_string_list_value();
    void set_allocated_string_list_value(::optimization_guide::proto::AXStringList* string_list_value);

private:
    const ::optimization_guide::proto::AXStringList& _internal_string_list_value() const;
    ::optimization_guide::proto::AXStringList* _internal_mutable_string_list_value();

public:
    void unsafe_arena_set_allocated_string_list_value(::optimization_guide::proto::AXStringList* string_list_value);
    ::optimization_guide::proto::AXStringList* unsafe_arena_release_string_list_value();

    // string html_attribute_value = 14;
    bool has_html_attribute_value() const;

private:
    bool _internal_has_html_attribute_value() const;

public:
    void clear_html_attribute_value();
    const std::string& html_attribute_value() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_html_attribute_value(ArgT0&& arg0, ArgT... args);
    std::string* mutable_html_attribute_value();
    PROTOBUF_NODISCARD std::string* release_html_attribute_value();
    void set_allocated_html_attribute_value(std::string* html_attribute_value);

private:
    const std::string& _internal_html_attribute_value() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_html_attribute_value(const std::string& value);
    std::string* _internal_mutable_html_attribute_value();

public:
    void clear_attribute_key();
    AttributeKeyCase attribute_key_case() const;
    void clear_attribute_value();
    AttributeValueCase attribute_value_case() const;
    // @@protoc_insertion_point(class_scope:optimization_guide.proto.AXAttribute)
private:
    class _Internal;
    void set_has_string_type();
    void set_has_int_type();
    void set_has_float_type();
    void set_has_bool_type();
    void set_has_intlist_type();
    void set_has_stringlist_type();
    void set_has_html_attribute_name();
    void set_has_string_value();
    void set_has_int_value();
    void set_has_float_value();
    void set_has_bool_value();
    void set_has_int_list_value();
    void set_has_string_list_value();
    void set_has_html_attribute_value();

    inline bool has_attribute_key() const;
    inline void clear_has_attribute_key();

    inline bool has_attribute_value() const;
    inline void clear_has_attribute_value();

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        union AttributeKeyUnion {
            constexpr AttributeKeyUnion()
                : _constinit_ {}
            {
            }
            ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
            int string_type_;
            int int_type_;
            int float_type_;
            int bool_type_;
            int intlist_type_;
            int stringlist_type_;
            ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr html_attribute_name_;
        } attribute_key_;
        union AttributeValueUnion {
            constexpr AttributeValueUnion()
                : _constinit_ {}
            {
            }
            ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
            ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr string_value_;
            int32_t int_value_;
            float float_value_;
            bool bool_value_;
            ::optimization_guide::proto::AXIntList* int_list_value_;
            ::optimization_guide::proto::AXStringList* string_list_value_;
            ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr html_attribute_value_;
        } attribute_value_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        uint32_t _oneof_case_[2];
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2foptimization_5fguide_2fproto_2ffeatures_2fcommon_5fquality_5fdata_2eproto;
};
// -------------------------------------------------------------------

class AXIntList final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.AXIntList) */ {
public:
    inline AXIntList()
        : AXIntList(nullptr)
    {
    }
    ~AXIntList() override;
    explicit PROTOBUF_CONSTEXPR AXIntList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    AXIntList(const AXIntList& from);
    AXIntList(AXIntList&& from) noexcept
        : AXIntList()
    {
        *this = ::std::move(from);
    }

    inline AXIntList& operator=(const AXIntList& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline AXIntList& operator=(AXIntList&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const AXIntList& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const AXIntList* internal_default_instance()
    {
        return reinterpret_cast<const AXIntList*>(&_AXIntList_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 6;

    friend void swap(AXIntList& a, AXIntList& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(AXIntList* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(AXIntList* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    AXIntList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<AXIntList>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const AXIntList& from);
    void MergeFrom(const AXIntList& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(AXIntList* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "optimization_guide.proto.AXIntList";
    }

protected:
    explicit AXIntList(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kValueFieldNumber = 1,
    };
    // repeated int32 value = 1;
    int value_size() const;

private:
    int _internal_value_size() const;

public:
    void clear_value();

private:
    int32_t _internal_value(int index) const;
    const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>& _internal_value() const;
    void _internal_add_value(int32_t value);
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>* _internal_mutable_value();

public:
    int32_t value(int index) const;
    void set_value(int index, int32_t value);
    void add_value(int32_t value);
    const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>& value() const;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>* mutable_value();

    // @@protoc_insertion_point(class_scope:optimization_guide.proto.AXIntList)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t> value_;
        mutable std::atomic<int> _value_cached_byte_size_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2foptimization_5fguide_2fproto_2ffeatures_2fcommon_5fquality_5fdata_2eproto;
};
// -------------------------------------------------------------------

class AXStringList final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.AXStringList) */ {
public:
    inline AXStringList()
        : AXStringList(nullptr)
    {
    }
    ~AXStringList() override;
    explicit PROTOBUF_CONSTEXPR AXStringList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    AXStringList(const AXStringList& from);
    AXStringList(AXStringList&& from) noexcept
        : AXStringList()
    {
        *this = ::std::move(from);
    }

    inline AXStringList& operator=(const AXStringList& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline AXStringList& operator=(AXStringList&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const AXStringList& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const AXStringList* internal_default_instance()
    {
        return reinterpret_cast<const AXStringList*>(&_AXStringList_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 7;

    friend void swap(AXStringList& a, AXStringList& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(AXStringList* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(AXStringList* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    AXStringList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<AXStringList>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const AXStringList& from);
    void MergeFrom(const AXStringList& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(AXStringList* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "optimization_guide.proto.AXStringList";
    }

protected:
    explicit AXStringList(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kValueFieldNumber = 1,
    };
    // repeated string value = 1;
    int value_size() const;

private:
    int _internal_value_size() const;

public:
    void clear_value();
    const std::string& value(int index) const;
    std::string* mutable_value(int index);
    void set_value(int index, const std::string& value);
    void set_value(int index, std::string&& value);
    void set_value(int index, const char* value);
    void set_value(int index, const char* value, size_t size);
    std::string* add_value();
    void add_value(const std::string& value);
    void add_value(std::string&& value);
    void add_value(const char* value);
    void add_value(const char* value, size_t size);
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& value() const;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_value();

private:
    const std::string& _internal_value(int index) const;
    std::string* _internal_add_value();

public:
    // @@protoc_insertion_point(class_scope:optimization_guide.proto.AXStringList)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> value_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2foptimization_5fguide_2fproto_2ffeatures_2fcommon_5fquality_5fdata_2eproto;
};
// -------------------------------------------------------------------

class AXRelativeBounds final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.AXRelativeBounds) */ {
public:
    inline AXRelativeBounds()
        : AXRelativeBounds(nullptr)
    {
    }
    ~AXRelativeBounds() override;
    explicit PROTOBUF_CONSTEXPR AXRelativeBounds(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    AXRelativeBounds(const AXRelativeBounds& from);
    AXRelativeBounds(AXRelativeBounds&& from) noexcept
        : AXRelativeBounds()
    {
        *this = ::std::move(from);
    }

    inline AXRelativeBounds& operator=(const AXRelativeBounds& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline AXRelativeBounds& operator=(AXRelativeBounds&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const AXRelativeBounds& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const AXRelativeBounds* internal_default_instance()
    {
        return reinterpret_cast<const AXRelativeBounds*>(&_AXRelativeBounds_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 8;

    friend void swap(AXRelativeBounds& a, AXRelativeBounds& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(AXRelativeBounds* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(AXRelativeBounds* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    AXRelativeBounds* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<AXRelativeBounds>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const AXRelativeBounds& from);
    void MergeFrom(const AXRelativeBounds& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(AXRelativeBounds* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "optimization_guide.proto.AXRelativeBounds";
    }

protected:
    explicit AXRelativeBounds(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kTransformFieldNumber = 6,
        kOffsetContainerIdFieldNumber = 1,
        kXFieldNumber = 2,
        kYFieldNumber = 3,
        kWidthFieldNumber = 4,
        kHeightFieldNumber = 5,
    };
    // repeated float transform = 6;
    int transform_size() const;

private:
    int _internal_transform_size() const;

public:
    void clear_transform();

private:
    float _internal_transform(int index) const;
    const ::PROTOBUF_NAMESPACE_ID::RepeatedField<float>& _internal_transform() const;
    void _internal_add_transform(float value);
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<float>* _internal_mutable_transform();

public:
    float transform(int index) const;
    void set_transform(int index, float value);
    void add_transform(float value);
    const ::PROTOBUF_NAMESPACE_ID::RepeatedField<float>& transform() const;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<float>* mutable_transform();

    // int32 offset_container_id = 1;
    void clear_offset_container_id();
    int32_t offset_container_id() const;
    void set_offset_container_id(int32_t value);

private:
    int32_t _internal_offset_container_id() const;
    void _internal_set_offset_container_id(int32_t value);

public:
    // float x = 2;
    void clear_x();
    float x() const;
    void set_x(float value);

private:
    float _internal_x() const;
    void _internal_set_x(float value);

public:
    // float y = 3;
    void clear_y();
    float y() const;
    void set_y(float value);

private:
    float _internal_y() const;
    void _internal_set_y(float value);

public:
    // float width = 4;
    void clear_width();
    float width() const;
    void set_width(float value);

private:
    float _internal_width() const;
    void _internal_set_width(float value);

public:
    // float height = 5;
    void clear_height();
    float height() const;
    void set_height(float value);

private:
    float _internal_height() const;
    void _internal_set_height(float value);

public:
    // @@protoc_insertion_point(class_scope:optimization_guide.proto.AXRelativeBounds)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedField<float> transform_;
        int32_t offset_container_id_;
        float x_;
        float y_;
        float width_;
        float height_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2foptimization_5fguide_2fproto_2ffeatures_2fcommon_5fquality_5fdata_2eproto;
};
// -------------------------------------------------------------------

class PageContext final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.PageContext) */ {
public:
    inline PageContext()
        : PageContext(nullptr)
    {
    }
    ~PageContext() override;
    explicit PROTOBUF_CONSTEXPR PageContext(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    PageContext(const PageContext& from);
    PageContext(PageContext&& from) noexcept
        : PageContext()
    {
        *this = ::std::move(from);
    }

    inline PageContext& operator=(const PageContext& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline PageContext& operator=(PageContext&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const PageContext& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const PageContext* internal_default_instance()
    {
        return reinterpret_cast<const PageContext*>(&_PageContext_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 9;

    friend void swap(PageContext& a, PageContext& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(PageContext* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(PageContext* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    PageContext* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<PageContext>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const PageContext& from);
    void MergeFrom(const PageContext& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(PageContext* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "optimization_guide.proto.PageContext";
    }

protected:
    explicit PageContext(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kUrlFieldNumber = 1,
        kTitleFieldNumber = 2,
        kInnerTextFieldNumber = 4,
        kTabScreenshotFieldNumber = 6,
        kPdfDataFieldNumber = 7,
        kAxTreeDataFieldNumber = 3,
        kInnerTextOffsetFieldNumber = 5,
    };
    // string url = 1;
    void clear_url();
    const std::string& url() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_url(ArgT0&& arg0, ArgT... args);
    std::string* mutable_url();
    PROTOBUF_NODISCARD std::string* release_url();
    void set_allocated_url(std::string* url);

private:
    const std::string& _internal_url() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
    std::string* _internal_mutable_url();

public:
    // string title = 2;
    void clear_title();
    const std::string& title() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_title(ArgT0&& arg0, ArgT... args);
    std::string* mutable_title();
    PROTOBUF_NODISCARD std::string* release_title();
    void set_allocated_title(std::string* title);

private:
    const std::string& _internal_title() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
    std::string* _internal_mutable_title();

public:
    // string inner_text = 4;
    void clear_inner_text();
    const std::string& inner_text() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_inner_text(ArgT0&& arg0, ArgT... args);
    std::string* mutable_inner_text();
    PROTOBUF_NODISCARD std::string* release_inner_text();
    void set_allocated_inner_text(std::string* inner_text);

private:
    const std::string& _internal_inner_text() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_inner_text(const std::string& value);
    std::string* _internal_mutable_inner_text();

public:
    // string tab_screenshot = 6;
    void clear_tab_screenshot();
    const std::string& tab_screenshot() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_tab_screenshot(ArgT0&& arg0, ArgT... args);
    std::string* mutable_tab_screenshot();
    PROTOBUF_NODISCARD std::string* release_tab_screenshot();
    void set_allocated_tab_screenshot(std::string* tab_screenshot);

private:
    const std::string& _internal_tab_screenshot() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_tab_screenshot(const std::string& value);
    std::string* _internal_mutable_tab_screenshot();

public:
    // string pdf_data = 7;
    void clear_pdf_data();
    const std::string& pdf_data() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_pdf_data(ArgT0&& arg0, ArgT... args);
    std::string* mutable_pdf_data();
    PROTOBUF_NODISCARD std::string* release_pdf_data();
    void set_allocated_pdf_data(std::string* pdf_data);

private:
    const std::string& _internal_pdf_data() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_pdf_data(const std::string& value);
    std::string* _internal_mutable_pdf_data();

public:
    // .optimization_guide.proto.AXTreeUpdate ax_tree_data = 3;
    bool has_ax_tree_data() const;

private:
    bool _internal_has_ax_tree_data() const;

public:
    void clear_ax_tree_data();
    const ::optimization_guide::proto::AXTreeUpdate& ax_tree_data() const;
    PROTOBUF_NODISCARD ::optimization_guide::proto::AXTreeUpdate* release_ax_tree_data();
    ::optimization_guide::proto::AXTreeUpdate* mutable_ax_tree_data();
    void set_allocated_ax_tree_data(::optimization_guide::proto::AXTreeUpdate* ax_tree_data);

private:
    const ::optimization_guide::proto::AXTreeUpdate& _internal_ax_tree_data() const;
    ::optimization_guide::proto::AXTreeUpdate* _internal_mutable_ax_tree_data();

public:
    void unsafe_arena_set_allocated_ax_tree_data(::optimization_guide::proto::AXTreeUpdate* ax_tree_data);
    ::optimization_guide::proto::AXTreeUpdate* unsafe_arena_release_ax_tree_data();

    // uint64 inner_text_offset = 5;
    void clear_inner_text_offset();
    uint64_t inner_text_offset() const;
    void set_inner_text_offset(uint64_t value);

private:
    uint64_t _internal_inner_text_offset() const;
    void _internal_set_inner_text_offset(uint64_t value);

public:
    // @@protoc_insertion_point(class_scope:optimization_guide.proto.PageContext)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr inner_text_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tab_screenshot_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pdf_data_;
        ::optimization_guide::proto::AXTreeUpdate* ax_tree_data_;
        uint64_t inner_text_offset_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2foptimization_5fguide_2fproto_2ffeatures_2fcommon_5fquality_5fdata_2eproto;
};
// -------------------------------------------------------------------

class FormData final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.FormData) */ {
public:
    inline FormData()
        : FormData(nullptr)
    {
    }
    ~FormData() override;
    explicit PROTOBUF_CONSTEXPR FormData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    FormData(const FormData& from);
    FormData(FormData&& from) noexcept
        : FormData()
    {
        *this = ::std::move(from);
    }

    inline FormData& operator=(const FormData& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline FormData& operator=(FormData&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const FormData& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const FormData* internal_default_instance()
    {
        return reinterpret_cast<const FormData*>(&_FormData_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 10;

    friend void swap(FormData& a, FormData& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(FormData* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(FormData* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    FormData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<FormData>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const FormData& from);
    void MergeFrom(const FormData& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(FormData* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "optimization_guide.proto.FormData";
    }

protected:
    explicit FormData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kFieldsFieldNumber = 2,
        kFormNameFieldNumber = 1,
    };
    // repeated .optimization_guide.proto.FormFieldData fields = 2;
    int fields_size() const;

private:
    int _internal_fields_size() const;

public:
    void clear_fields();
    ::optimization_guide::proto::FormFieldData* mutable_fields(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::FormFieldData>* mutable_fields();

private:
    const ::optimization_guide::proto::FormFieldData& _internal_fields(int index) const;
    ::optimization_guide::proto::FormFieldData* _internal_add_fields();

public:
    const ::optimization_guide::proto::FormFieldData& fields(int index) const;
    ::optimization_guide::proto::FormFieldData* add_fields();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::FormFieldData>& fields() const;

    // string form_name = 1;
    void clear_form_name();
    const std::string& form_name() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_form_name(ArgT0&& arg0, ArgT... args);
    std::string* mutable_form_name();
    PROTOBUF_NODISCARD std::string* release_form_name();
    void set_allocated_form_name(std::string* form_name);

private:
    const std::string& _internal_form_name() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_form_name(const std::string& value);
    std::string* _internal_mutable_form_name();

public:
    // @@protoc_insertion_point(class_scope:optimization_guide.proto.FormData)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::FormFieldData> fields_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr form_name_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2foptimization_5fguide_2fproto_2ffeatures_2fcommon_5fquality_5fdata_2eproto;
};
// -------------------------------------------------------------------

class FormFieldData final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.FormFieldData) */ {
public:
    inline FormFieldData()
        : FormFieldData(nullptr)
    {
    }
    ~FormFieldData() override;
    explicit PROTOBUF_CONSTEXPR FormFieldData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    FormFieldData(const FormFieldData& from);
    FormFieldData(FormFieldData&& from) noexcept
        : FormFieldData()
    {
        *this = ::std::move(from);
    }

    inline FormFieldData& operator=(const FormFieldData& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline FormFieldData& operator=(FormFieldData&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const FormFieldData& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const FormFieldData* internal_default_instance()
    {
        return reinterpret_cast<const FormFieldData*>(&_FormFieldData_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 11;

    friend void swap(FormFieldData& a, FormFieldData& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(FormFieldData* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(FormFieldData* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    FormFieldData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<FormFieldData>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const FormFieldData& from);
    void MergeFrom(const FormFieldData& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(FormFieldData* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "optimization_guide.proto.FormFieldData";
    }

protected:
    explicit FormFieldData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kSelectOptionsFieldNumber = 7,
        kFieldNameFieldNumber = 1,
        kFieldLabelFieldNumber = 2,
        kFieldValueFieldNumber = 3,
        kPlaceholderFieldNumber = 8,
        kGlobalIdFieldNumber = 11,
        kFormControlTypeFieldNumber = 6,
        kIsVisibleFieldNumber = 4,
        kIsFocusableFieldNumber = 5,
        kIsEligibleFieldNumber = 10,
        kFormControlAxNodeIdFieldNumber = 9,
    };
    // repeated .optimization_guide.proto.SelectOption select_options = 7;
    int select_options_size() const;

private:
    int _internal_select_options_size() const;

public:
    void clear_select_options();
    ::optimization_guide::proto::SelectOption* mutable_select_options(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::SelectOption>* mutable_select_options();

private:
    const ::optimization_guide::proto::SelectOption& _internal_select_options(int index) const;
    ::optimization_guide::proto::SelectOption* _internal_add_select_options();

public:
    const ::optimization_guide::proto::SelectOption& select_options(int index) const;
    ::optimization_guide::proto::SelectOption* add_select_options();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::SelectOption>& select_options() const;

    // string field_name = 1;
    void clear_field_name();
    const std::string& field_name() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_field_name(ArgT0&& arg0, ArgT... args);
    std::string* mutable_field_name();
    PROTOBUF_NODISCARD std::string* release_field_name();
    void set_allocated_field_name(std::string* field_name);

private:
    const std::string& _internal_field_name() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_field_name(const std::string& value);
    std::string* _internal_mutable_field_name();

public:
    // string field_label = 2;
    void clear_field_label();
    const std::string& field_label() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_field_label(ArgT0&& arg0, ArgT... args);
    std::string* mutable_field_label();
    PROTOBUF_NODISCARD std::string* release_field_label();
    void set_allocated_field_label(std::string* field_label);

private:
    const std::string& _internal_field_label() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_field_label(const std::string& value);
    std::string* _internal_mutable_field_label();

public:
    // string field_value = 3;
    void clear_field_value();
    const std::string& field_value() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_field_value(ArgT0&& arg0, ArgT... args);
    std::string* mutable_field_value();
    PROTOBUF_NODISCARD std::string* release_field_value();
    void set_allocated_field_value(std::string* field_value);

private:
    const std::string& _internal_field_value() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_field_value(const std::string& value);
    std::string* _internal_mutable_field_value();

public:
    // string placeholder = 8;
    void clear_placeholder();
    const std::string& placeholder() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_placeholder(ArgT0&& arg0, ArgT... args);
    std::string* mutable_placeholder();
    PROTOBUF_NODISCARD std::string* release_placeholder();
    void set_allocated_placeholder(std::string* placeholder);

private:
    const std::string& _internal_placeholder() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_placeholder(const std::string& value);
    std::string* _internal_mutable_placeholder();

public:
    // string global_id = 11;
    void clear_global_id();
    const std::string& global_id() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_global_id(ArgT0&& arg0, ArgT... args);
    std::string* mutable_global_id();
    PROTOBUF_NODISCARD std::string* release_global_id();
    void set_allocated_global_id(std::string* global_id);

private:
    const std::string& _internal_global_id() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_global_id(const std::string& value);
    std::string* _internal_mutable_global_id();

public:
    // .optimization_guide.proto.FormControlType form_control_type = 6;
    void clear_form_control_type();
    ::optimization_guide::proto::FormControlType form_control_type() const;
    void set_form_control_type(::optimization_guide::proto::FormControlType value);

private:
    ::optimization_guide::proto::FormControlType _internal_form_control_type() const;
    void _internal_set_form_control_type(::optimization_guide::proto::FormControlType value);

public:
    // bool is_visible = 4;
    void clear_is_visible();
    bool is_visible() const;
    void set_is_visible(bool value);

private:
    bool _internal_is_visible() const;
    void _internal_set_is_visible(bool value);

public:
    // bool is_focusable = 5;
    void clear_is_focusable();
    bool is_focusable() const;
    void set_is_focusable(bool value);

private:
    bool _internal_is_focusable() const;
    void _internal_set_is_focusable(bool value);

public:
    // bool is_eligible = 10;
    void clear_is_eligible();
    bool is_eligible() const;
    void set_is_eligible(bool value);

private:
    bool _internal_is_eligible() const;
    void _internal_set_is_eligible(bool value);

public:
    // int32 form_control_ax_node_id = 9;
    void clear_form_control_ax_node_id();
    int32_t form_control_ax_node_id() const;
    void set_form_control_ax_node_id(int32_t value);

private:
    int32_t _internal_form_control_ax_node_id() const;
    void _internal_set_form_control_ax_node_id(int32_t value);

public:
    // @@protoc_insertion_point(class_scope:optimization_guide.proto.FormFieldData)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::SelectOption> select_options_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field_name_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field_label_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field_value_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr placeholder_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr global_id_;
        int form_control_type_;
        bool is_visible_;
        bool is_focusable_;
        bool is_eligible_;
        int32_t form_control_ax_node_id_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2foptimization_5fguide_2fproto_2ffeatures_2fcommon_5fquality_5fdata_2eproto;
};
// -------------------------------------------------------------------

class SelectOption final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.SelectOption) */ {
public:
    inline SelectOption()
        : SelectOption(nullptr)
    {
    }
    ~SelectOption() override;
    explicit PROTOBUF_CONSTEXPR SelectOption(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    SelectOption(const SelectOption& from);
    SelectOption(SelectOption&& from) noexcept
        : SelectOption()
    {
        *this = ::std::move(from);
    }

    inline SelectOption& operator=(const SelectOption& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline SelectOption& operator=(SelectOption&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const SelectOption& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const SelectOption* internal_default_instance()
    {
        return reinterpret_cast<const SelectOption*>(&_SelectOption_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 12;

    friend void swap(SelectOption& a, SelectOption& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(SelectOption* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(SelectOption* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    SelectOption* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<SelectOption>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const SelectOption& from);
    void MergeFrom(const SelectOption& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(SelectOption* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "optimization_guide.proto.SelectOption";
    }

protected:
    explicit SelectOption(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kValueFieldNumber = 1,
        kTextFieldNumber = 2,
    };
    // string value = 1;
    void clear_value();
    const std::string& value() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_value(ArgT0&& arg0, ArgT... args);
    std::string* mutable_value();
    PROTOBUF_NODISCARD std::string* release_value();
    void set_allocated_value(std::string* value);

private:
    const std::string& _internal_value() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
    std::string* _internal_mutable_value();

public:
    // string text = 2;
    void clear_text();
    const std::string& text() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_text(ArgT0&& arg0, ArgT... args);
    std::string* mutable_text();
    PROTOBUF_NODISCARD std::string* release_text();
    void set_allocated_text(std::string* text);

private:
    const std::string& _internal_text() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
    std::string* _internal_mutable_text();

public:
    // @@protoc_insertion_point(class_scope:optimization_guide.proto.SelectOption)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2foptimization_5fguide_2fproto_2ffeatures_2fcommon_5fquality_5fdata_2eproto;
};
// -------------------------------------------------------------------

class UserAnnotationsEntry final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.UserAnnotationsEntry) */ {
public:
    inline UserAnnotationsEntry()
        : UserAnnotationsEntry(nullptr)
    {
    }
    ~UserAnnotationsEntry() override;
    explicit PROTOBUF_CONSTEXPR UserAnnotationsEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    UserAnnotationsEntry(const UserAnnotationsEntry& from);
    UserAnnotationsEntry(UserAnnotationsEntry&& from) noexcept
        : UserAnnotationsEntry()
    {
        *this = ::std::move(from);
    }

    inline UserAnnotationsEntry& operator=(const UserAnnotationsEntry& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline UserAnnotationsEntry& operator=(UserAnnotationsEntry&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const UserAnnotationsEntry& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const UserAnnotationsEntry* internal_default_instance()
    {
        return reinterpret_cast<const UserAnnotationsEntry*>(&_UserAnnotationsEntry_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 13;

    friend void swap(UserAnnotationsEntry& a, UserAnnotationsEntry& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(UserAnnotationsEntry* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(UserAnnotationsEntry* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    UserAnnotationsEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<UserAnnotationsEntry>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const UserAnnotationsEntry& from);
    void MergeFrom(const UserAnnotationsEntry& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(UserAnnotationsEntry* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "optimization_guide.proto.UserAnnotationsEntry";
    }

protected:
    explicit UserAnnotationsEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kKeyFieldNumber = 2,
        kValueFieldNumber = 3,
        kEntryIdFieldNumber = 1,
    };
    // string key = 2;
    void clear_key();
    const std::string& key() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_key(ArgT0&& arg0, ArgT... args);
    std::string* mutable_key();
    PROTOBUF_NODISCARD std::string* release_key();
    void set_allocated_key(std::string* key);

private:
    const std::string& _internal_key() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
    std::string* _internal_mutable_key();

public:
    // string value = 3;
    void clear_value();
    const std::string& value() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_value(ArgT0&& arg0, ArgT... args);
    std::string* mutable_value();
    PROTOBUF_NODISCARD std::string* release_value();
    void set_allocated_value(std::string* value);

private:
    const std::string& _internal_value() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
    std::string* _internal_mutable_value();

public:
    // int64 entry_id = 1;
    void clear_entry_id();
    int64_t entry_id() const;
    void set_entry_id(int64_t value);

private:
    int64_t _internal_entry_id() const;
    void _internal_set_entry_id(int64_t value);

public:
    // @@protoc_insertion_point(class_scope:optimization_guide.proto.UserAnnotationsEntry)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
        int64_t entry_id_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2foptimization_5fguide_2fproto_2ffeatures_2fcommon_5fquality_5fdata_2eproto;
};
// -------------------------------------------------------------------

class TabGroup final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.TabGroup) */ {
public:
    inline TabGroup()
        : TabGroup(nullptr)
    {
    }
    ~TabGroup() override;
    explicit PROTOBUF_CONSTEXPR TabGroup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    TabGroup(const TabGroup& from);
    TabGroup(TabGroup&& from) noexcept
        : TabGroup()
    {
        *this = ::std::move(from);
    }

    inline TabGroup& operator=(const TabGroup& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline TabGroup& operator=(TabGroup&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const TabGroup& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const TabGroup* internal_default_instance()
    {
        return reinterpret_cast<const TabGroup*>(&_TabGroup_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 14;

    friend void swap(TabGroup& a, TabGroup& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(TabGroup* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(TabGroup* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    TabGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<TabGroup>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const TabGroup& from);
    void MergeFrom(const TabGroup& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(TabGroup* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "optimization_guide.proto.TabGroup";
    }

protected:
    explicit TabGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kTabsFieldNumber = 2,
        kLabelFieldNumber = 1,
        kGroupIdFieldNumber = 3,
    };
    // repeated .optimization_guide.proto.Tab tabs = 2;
    int tabs_size() const;

private:
    int _internal_tabs_size() const;

public:
    void clear_tabs();
    ::optimization_guide::proto::Tab* mutable_tabs(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::Tab>* mutable_tabs();

private:
    const ::optimization_guide::proto::Tab& _internal_tabs(int index) const;
    ::optimization_guide::proto::Tab* _internal_add_tabs();

public:
    const ::optimization_guide::proto::Tab& tabs(int index) const;
    ::optimization_guide::proto::Tab* add_tabs();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::Tab>& tabs() const;

    // string label = 1;
    void clear_label();
    const std::string& label() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_label(ArgT0&& arg0, ArgT... args);
    std::string* mutable_label();
    PROTOBUF_NODISCARD std::string* release_label();
    void set_allocated_label(std::string* label);

private:
    const std::string& _internal_label() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_label(const std::string& value);
    std::string* _internal_mutable_label();

public:
    // optional string group_id = 3;
    bool has_group_id() const;

private:
    bool _internal_has_group_id() const;

public:
    void clear_group_id();
    const std::string& group_id() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_group_id(ArgT0&& arg0, ArgT... args);
    std::string* mutable_group_id();
    PROTOBUF_NODISCARD std::string* release_group_id();
    void set_allocated_group_id(std::string* group_id);

private:
    const std::string& _internal_group_id() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_group_id(const std::string& value);
    std::string* _internal_mutable_group_id();

public:
    // @@protoc_insertion_point(class_scope:optimization_guide.proto.TabGroup)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::Tab> tabs_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr label_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr group_id_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2foptimization_5fguide_2fproto_2ffeatures_2fcommon_5fquality_5fdata_2eproto;
};
// -------------------------------------------------------------------

class Tab final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.Tab) */ {
public:
    inline Tab()
        : Tab(nullptr)
    {
    }
    ~Tab() override;
    explicit PROTOBUF_CONSTEXPR Tab(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    Tab(const Tab& from);
    Tab(Tab&& from) noexcept
        : Tab()
    {
        *this = ::std::move(from);
    }

    inline Tab& operator=(const Tab& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline Tab& operator=(Tab&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const Tab& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const Tab* internal_default_instance()
    {
        return reinterpret_cast<const Tab*>(&_Tab_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 15;

    friend void swap(Tab& a, Tab& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(Tab* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(Tab* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    Tab* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<Tab>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const Tab& from);
    void MergeFrom(const Tab& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(Tab* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "optimization_guide.proto.Tab";
    }

protected:
    explicit Tab(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kTitleFieldNumber = 2,
        kUrlFieldNumber = 3,
        kPageContextFieldNumber = 4,
        kTabIdFieldNumber = 1,
    };
    // string title = 2;
    void clear_title();
    const std::string& title() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_title(ArgT0&& arg0, ArgT... args);
    std::string* mutable_title();
    PROTOBUF_NODISCARD std::string* release_title();
    void set_allocated_title(std::string* title);

private:
    const std::string& _internal_title() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
    std::string* _internal_mutable_title();

public:
    // string url = 3;
    void clear_url();
    const std::string& url() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_url(ArgT0&& arg0, ArgT... args);
    std::string* mutable_url();
    PROTOBUF_NODISCARD std::string* release_url();
    void set_allocated_url(std::string* url);

private:
    const std::string& _internal_url() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
    std::string* _internal_mutable_url();

public:
    // .optimization_guide.proto.PageContext page_context = 4;
    bool has_page_context() const;

private:
    bool _internal_has_page_context() const;

public:
    void clear_page_context();
    const ::optimization_guide::proto::PageContext& page_context() const;
    PROTOBUF_NODISCARD ::optimization_guide::proto::PageContext* release_page_context();
    ::optimization_guide::proto::PageContext* mutable_page_context();
    void set_allocated_page_context(::optimization_guide::proto::PageContext* page_context);

private:
    const ::optimization_guide::proto::PageContext& _internal_page_context() const;
    ::optimization_guide::proto::PageContext* _internal_mutable_page_context();

public:
    void unsafe_arena_set_allocated_page_context(::optimization_guide::proto::PageContext* page_context);
    ::optimization_guide::proto::PageContext* unsafe_arena_release_page_context();

    // int64 tab_id = 1;
    void clear_tab_id();
    int64_t tab_id() const;
    void set_tab_id(int64_t value);

private:
    int64_t _internal_tab_id() const;
    void _internal_set_tab_id(int64_t value);

public:
    // @@protoc_insertion_point(class_scope:optimization_guide.proto.Tab)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
        ::optimization_guide::proto::PageContext* page_context_;
        int64_t tab_id_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2foptimization_5fguide_2fproto_2ffeatures_2fcommon_5fquality_5fdata_2eproto;
};
// -------------------------------------------------------------------

class SiteEngagementEntry final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.SiteEngagementEntry) */ {
public:
    inline SiteEngagementEntry()
        : SiteEngagementEntry(nullptr)
    {
    }
    ~SiteEngagementEntry() override;
    explicit PROTOBUF_CONSTEXPR SiteEngagementEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    SiteEngagementEntry(const SiteEngagementEntry& from);
    SiteEngagementEntry(SiteEngagementEntry&& from) noexcept
        : SiteEngagementEntry()
    {
        *this = ::std::move(from);
    }

    inline SiteEngagementEntry& operator=(const SiteEngagementEntry& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline SiteEngagementEntry& operator=(SiteEngagementEntry&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const SiteEngagementEntry& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const SiteEngagementEntry* internal_default_instance()
    {
        return reinterpret_cast<const SiteEngagementEntry*>(&_SiteEngagementEntry_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 16;

    friend void swap(SiteEngagementEntry& a, SiteEngagementEntry& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(SiteEngagementEntry* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(SiteEngagementEntry* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    SiteEngagementEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<SiteEngagementEntry>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const SiteEngagementEntry& from);
    void MergeFrom(const SiteEngagementEntry& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(SiteEngagementEntry* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "optimization_guide.proto.SiteEngagementEntry";
    }

protected:
    explicit SiteEngagementEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kUrlFieldNumber = 1,
        kScoreFieldNumber = 2,
    };
    // string url = 1;
    void clear_url();
    const std::string& url() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_url(ArgT0&& arg0, ArgT... args);
    std::string* mutable_url();
    PROTOBUF_NODISCARD std::string* release_url();
    void set_allocated_url(std::string* url);

private:
    const std::string& _internal_url() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
    std::string* _internal_mutable_url();

public:
    // float score = 2;
    void clear_score();
    float score() const;
    void set_score(float value);

private:
    float _internal_score() const;
    void _internal_set_score(float value);

public:
    // @@protoc_insertion_point(class_scope:optimization_guide.proto.SiteEngagementEntry)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
        float score_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2foptimization_5fguide_2fproto_2ffeatures_2fcommon_5fquality_5fdata_2eproto;
};
// -------------------------------------------------------------------

class SiteEngagement final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.SiteEngagement) */ {
public:
    inline SiteEngagement()
        : SiteEngagement(nullptr)
    {
    }
    ~SiteEngagement() override;
    explicit PROTOBUF_CONSTEXPR SiteEngagement(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    SiteEngagement(const SiteEngagement& from);
    SiteEngagement(SiteEngagement&& from) noexcept
        : SiteEngagement()
    {
        *this = ::std::move(from);
    }

    inline SiteEngagement& operator=(const SiteEngagement& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline SiteEngagement& operator=(SiteEngagement&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const SiteEngagement& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const SiteEngagement* internal_default_instance()
    {
        return reinterpret_cast<const SiteEngagement*>(&_SiteEngagement_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 17;

    friend void swap(SiteEngagement& a, SiteEngagement& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(SiteEngagement* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(SiteEngagement* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    SiteEngagement* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<SiteEngagement>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const SiteEngagement& from);
    void MergeFrom(const SiteEngagement& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(SiteEngagement* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "optimization_guide.proto.SiteEngagement";
    }

protected:
    explicit SiteEngagement(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kEntriesFieldNumber = 1,
    };
    // repeated .optimization_guide.proto.SiteEngagementEntry entries = 1;
    int entries_size() const;

private:
    int _internal_entries_size() const;

public:
    void clear_entries();
    ::optimization_guide::proto::SiteEngagementEntry* mutable_entries(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::SiteEngagementEntry>* mutable_entries();

private:
    const ::optimization_guide::proto::SiteEngagementEntry& _internal_entries(int index) const;
    ::optimization_guide::proto::SiteEngagementEntry* _internal_add_entries();

public:
    const ::optimization_guide::proto::SiteEngagementEntry& entries(int index) const;
    ::optimization_guide::proto::SiteEngagementEntry* add_entries();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::SiteEngagementEntry>& entries() const;

    // @@protoc_insertion_point(class_scope:optimization_guide.proto.SiteEngagement)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::SiteEngagementEntry> entries_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2foptimization_5fguide_2fproto_2ffeatures_2fcommon_5fquality_5fdata_2eproto;
};
// -------------------------------------------------------------------

class BrowserCollectedInformation final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.BrowserCollectedInformation) */ {
public:
    inline BrowserCollectedInformation()
        : BrowserCollectedInformation(nullptr)
    {
    }
    ~BrowserCollectedInformation() override;
    explicit PROTOBUF_CONSTEXPR BrowserCollectedInformation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    BrowserCollectedInformation(const BrowserCollectedInformation& from);
    BrowserCollectedInformation(BrowserCollectedInformation&& from) noexcept
        : BrowserCollectedInformation()
    {
        *this = ::std::move(from);
    }

    inline BrowserCollectedInformation& operator=(const BrowserCollectedInformation& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline BrowserCollectedInformation& operator=(BrowserCollectedInformation&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const BrowserCollectedInformation& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const BrowserCollectedInformation* internal_default_instance()
    {
        return reinterpret_cast<const BrowserCollectedInformation*>(&_BrowserCollectedInformation_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 18;

    friend void swap(BrowserCollectedInformation& a, BrowserCollectedInformation& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(BrowserCollectedInformation* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(BrowserCollectedInformation* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    BrowserCollectedInformation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<BrowserCollectedInformation>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const BrowserCollectedInformation& from);
    void MergeFrom(const BrowserCollectedInformation& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(BrowserCollectedInformation* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "optimization_guide.proto.BrowserCollectedInformation";
    }

protected:
    explicit BrowserCollectedInformation(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kCustomDataFieldNumber = 4,
        kEntriesFieldNumber = 6,
        kTabsFieldNumber = 7,
        kPreExistingTabGroupsFieldNumber = 9,
        kInnerTextFieldNumber = 2,
        kPageContextFieldNumber = 1,
        kFormDataFieldNumber = 5,
        kSiteEngagementFieldNumber = 10,
        kInnerTextOffsetFieldNumber = 3,
        kActiveTabIdFieldNumber = 8,
    };
    // repeated string custom_data = 4;
    int custom_data_size() const;

private:
    int _internal_custom_data_size() const;

public:
    void clear_custom_data();
    const std::string& custom_data(int index) const;
    std::string* mutable_custom_data(int index);
    void set_custom_data(int index, const std::string& value);
    void set_custom_data(int index, std::string&& value);
    void set_custom_data(int index, const char* value);
    void set_custom_data(int index, const char* value, size_t size);
    std::string* add_custom_data();
    void add_custom_data(const std::string& value);
    void add_custom_data(std::string&& value);
    void add_custom_data(const char* value);
    void add_custom_data(const char* value, size_t size);
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& custom_data() const;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_custom_data();

private:
    const std::string& _internal_custom_data(int index) const;
    std::string* _internal_add_custom_data();

public:
    // repeated .optimization_guide.proto.UserAnnotationsEntry entries = 6;
    int entries_size() const;

private:
    int _internal_entries_size() const;

public:
    void clear_entries();
    ::optimization_guide::proto::UserAnnotationsEntry* mutable_entries(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::UserAnnotationsEntry>* mutable_entries();

private:
    const ::optimization_guide::proto::UserAnnotationsEntry& _internal_entries(int index) const;
    ::optimization_guide::proto::UserAnnotationsEntry* _internal_add_entries();

public:
    const ::optimization_guide::proto::UserAnnotationsEntry& entries(int index) const;
    ::optimization_guide::proto::UserAnnotationsEntry* add_entries();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::UserAnnotationsEntry>& entries() const;

    // repeated .optimization_guide.proto.Tab tabs = 7;
    int tabs_size() const;

private:
    int _internal_tabs_size() const;

public:
    void clear_tabs();
    ::optimization_guide::proto::Tab* mutable_tabs(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::Tab>* mutable_tabs();

private:
    const ::optimization_guide::proto::Tab& _internal_tabs(int index) const;
    ::optimization_guide::proto::Tab* _internal_add_tabs();

public:
    const ::optimization_guide::proto::Tab& tabs(int index) const;
    ::optimization_guide::proto::Tab* add_tabs();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::Tab>& tabs() const;

    // repeated .optimization_guide.proto.TabGroup pre_existing_tab_groups = 9;
    int pre_existing_tab_groups_size() const;

private:
    int _internal_pre_existing_tab_groups_size() const;

public:
    void clear_pre_existing_tab_groups();
    ::optimization_guide::proto::TabGroup* mutable_pre_existing_tab_groups(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::TabGroup>* mutable_pre_existing_tab_groups();

private:
    const ::optimization_guide::proto::TabGroup& _internal_pre_existing_tab_groups(int index) const;
    ::optimization_guide::proto::TabGroup* _internal_add_pre_existing_tab_groups();

public:
    const ::optimization_guide::proto::TabGroup& pre_existing_tab_groups(int index) const;
    ::optimization_guide::proto::TabGroup* add_pre_existing_tab_groups();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::TabGroup>& pre_existing_tab_groups() const;

    // string inner_text = 2;
    void clear_inner_text();
    const std::string& inner_text() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_inner_text(ArgT0&& arg0, ArgT... args);
    std::string* mutable_inner_text();
    PROTOBUF_NODISCARD std::string* release_inner_text();
    void set_allocated_inner_text(std::string* inner_text);

private:
    const std::string& _internal_inner_text() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_inner_text(const std::string& value);
    std::string* _internal_mutable_inner_text();

public:
    // .optimization_guide.proto.PageContext page_context = 1;
    bool has_page_context() const;

private:
    bool _internal_has_page_context() const;

public:
    void clear_page_context();
    const ::optimization_guide::proto::PageContext& page_context() const;
    PROTOBUF_NODISCARD ::optimization_guide::proto::PageContext* release_page_context();
    ::optimization_guide::proto::PageContext* mutable_page_context();
    void set_allocated_page_context(::optimization_guide::proto::PageContext* page_context);

private:
    const ::optimization_guide::proto::PageContext& _internal_page_context() const;
    ::optimization_guide::proto::PageContext* _internal_mutable_page_context();

public:
    void unsafe_arena_set_allocated_page_context(::optimization_guide::proto::PageContext* page_context);
    ::optimization_guide::proto::PageContext* unsafe_arena_release_page_context();

    // .optimization_guide.proto.FormData form_data = 5;
    bool has_form_data() const;

private:
    bool _internal_has_form_data() const;

public:
    void clear_form_data();
    const ::optimization_guide::proto::FormData& form_data() const;
    PROTOBUF_NODISCARD ::optimization_guide::proto::FormData* release_form_data();
    ::optimization_guide::proto::FormData* mutable_form_data();
    void set_allocated_form_data(::optimization_guide::proto::FormData* form_data);

private:
    const ::optimization_guide::proto::FormData& _internal_form_data() const;
    ::optimization_guide::proto::FormData* _internal_mutable_form_data();

public:
    void unsafe_arena_set_allocated_form_data(::optimization_guide::proto::FormData* form_data);
    ::optimization_guide::proto::FormData* unsafe_arena_release_form_data();

    // .optimization_guide.proto.SiteEngagement site_engagement = 10;
    bool has_site_engagement() const;

private:
    bool _internal_has_site_engagement() const;

public:
    void clear_site_engagement();
    const ::optimization_guide::proto::SiteEngagement& site_engagement() const;
    PROTOBUF_NODISCARD ::optimization_guide::proto::SiteEngagement* release_site_engagement();
    ::optimization_guide::proto::SiteEngagement* mutable_site_engagement();
    void set_allocated_site_engagement(::optimization_guide::proto::SiteEngagement* site_engagement);

private:
    const ::optimization_guide::proto::SiteEngagement& _internal_site_engagement() const;
    ::optimization_guide::proto::SiteEngagement* _internal_mutable_site_engagement();

public:
    void unsafe_arena_set_allocated_site_engagement(::optimization_guide::proto::SiteEngagement* site_engagement);
    ::optimization_guide::proto::SiteEngagement* unsafe_arena_release_site_engagement();

    // uint64 inner_text_offset = 3;
    void clear_inner_text_offset();
    uint64_t inner_text_offset() const;
    void set_inner_text_offset(uint64_t value);

private:
    uint64_t _internal_inner_text_offset() const;
    void _internal_set_inner_text_offset(uint64_t value);

public:
    // int64 active_tab_id = 8;
    void clear_active_tab_id();
    int64_t active_tab_id() const;
    void set_active_tab_id(int64_t value);

private:
    int64_t _internal_active_tab_id() const;
    void _internal_set_active_tab_id(int64_t value);

public:
    // @@protoc_insertion_point(class_scope:optimization_guide.proto.BrowserCollectedInformation)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> custom_data_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::UserAnnotationsEntry> entries_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::Tab> tabs_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::TabGroup> pre_existing_tab_groups_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr inner_text_;
        ::optimization_guide::proto::PageContext* page_context_;
        ::optimization_guide::proto::FormData* form_data_;
        ::optimization_guide::proto::SiteEngagement* site_engagement_;
        uint64_t inner_text_offset_;
        int64_t active_tab_id_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2foptimization_5fguide_2fproto_2ffeatures_2fcommon_5fquality_5fdata_2eproto;
};
// ===================================================================

// ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif // __GNUC__
// FloatArray

// repeated float values = 1;
inline int FloatArray::_internal_values_size() const
{
    return _impl_.values_.size();
}
inline int FloatArray::values_size() const
{
    return _internal_values_size();
}
inline void FloatArray::clear_values()
{
    _impl_.values_.Clear();
}
inline float FloatArray::_internal_values(int index) const
{
    return _impl_.values_.Get(index);
}
inline float FloatArray::values(int index) const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.FloatArray.values)
    return _internal_values(index);
}
inline void FloatArray::set_values(int index, float value)
{
    _impl_.values_.Set(index, value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.FloatArray.values)
}
inline void FloatArray::_internal_add_values(float value)
{
    _impl_.values_.Add(value);
}
inline void FloatArray::add_values(float value)
{
    _internal_add_values(value);
    // @@protoc_insertion_point(field_add:optimization_guide.proto.FloatArray.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<float>& FloatArray::_internal_values() const
{
    return _impl_.values_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<float>& FloatArray::values() const
{
    // @@protoc_insertion_point(field_list:optimization_guide.proto.FloatArray.values)
    return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<float>* FloatArray::_internal_mutable_values()
{
    return &_impl_.values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<float>* FloatArray::mutable_values()
{
    // @@protoc_insertion_point(field_mutable_list:optimization_guide.proto.FloatArray.values)
    return _internal_mutable_values();
}

// -------------------------------------------------------------------

// Embedding

// .optimization_guide.proto.FloatArray floats = 1;
inline bool Embedding::_internal_has_floats() const
{
    return this != internal_default_instance() && _impl_.floats_ != nullptr;
}
inline bool Embedding::has_floats() const
{
    return _internal_has_floats();
}
inline void Embedding::clear_floats()
{
    if (GetArenaForAllocation() == nullptr && _impl_.floats_ != nullptr) {
        delete _impl_.floats_;
    }
    _impl_.floats_ = nullptr;
}
inline const ::optimization_guide::proto::FloatArray& Embedding::_internal_floats() const
{
    const ::optimization_guide::proto::FloatArray* p = _impl_.floats_;
    return p != nullptr ? *p : reinterpret_cast<const ::optimization_guide::proto::FloatArray&>(::optimization_guide::proto::_FloatArray_default_instance_);
}
inline const ::optimization_guide::proto::FloatArray& Embedding::floats() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.Embedding.floats)
    return _internal_floats();
}
inline void Embedding::unsafe_arena_set_allocated_floats(::optimization_guide::proto::FloatArray* floats)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.floats_);
    }
    _impl_.floats_ = floats;
    if (floats) {

    } else {
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:optimization_guide.proto.Embedding.floats)
}
inline ::optimization_guide::proto::FloatArray* Embedding::release_floats()
{

    ::optimization_guide::proto::FloatArray* temp = _impl_.floats_;
    _impl_.floats_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::optimization_guide::proto::FloatArray* Embedding::unsafe_arena_release_floats()
{
    // @@protoc_insertion_point(field_release:optimization_guide.proto.Embedding.floats)

    ::optimization_guide::proto::FloatArray* temp = _impl_.floats_;
    _impl_.floats_ = nullptr;
    return temp;
}
inline ::optimization_guide::proto::FloatArray* Embedding::_internal_mutable_floats()
{

    if (_impl_.floats_ == nullptr) {
        auto* p = CreateMaybeMessage<::optimization_guide::proto::FloatArray>(GetArenaForAllocation());
        _impl_.floats_ = p;
    }
    return _impl_.floats_;
}
inline ::optimization_guide::proto::FloatArray* Embedding::mutable_floats()
{
    ::optimization_guide::proto::FloatArray* _msg = _internal_mutable_floats();
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.Embedding.floats)
    return _msg;
}
inline void Embedding::set_allocated_floats(::optimization_guide::proto::FloatArray* floats)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.floats_;
    }
    if (floats) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(floats);
        if (message_arena != submessage_arena) {
            floats = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, floats, submessage_arena);
        }

    } else {
    }
    _impl_.floats_ = floats;
    // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.Embedding.floats)
}

// -------------------------------------------------------------------

// AXTreeUpdate

// optional .optimization_guide.proto.AXTreeData tree_data = 1;
inline bool AXTreeUpdate::_internal_has_tree_data() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.tree_data_ != nullptr);
    return value;
}
inline bool AXTreeUpdate::has_tree_data() const
{
    return _internal_has_tree_data();
}
inline void AXTreeUpdate::clear_tree_data()
{
    if (_impl_.tree_data_ != nullptr)
        _impl_.tree_data_->Clear();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::optimization_guide::proto::AXTreeData& AXTreeUpdate::_internal_tree_data() const
{
    const ::optimization_guide::proto::AXTreeData* p = _impl_.tree_data_;
    return p != nullptr ? *p : reinterpret_cast<const ::optimization_guide::proto::AXTreeData&>(::optimization_guide::proto::_AXTreeData_default_instance_);
}
inline const ::optimization_guide::proto::AXTreeData& AXTreeUpdate::tree_data() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.AXTreeUpdate.tree_data)
    return _internal_tree_data();
}
inline void AXTreeUpdate::unsafe_arena_set_allocated_tree_data(::optimization_guide::proto::AXTreeData* tree_data)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tree_data_);
    }
    _impl_.tree_data_ = tree_data;
    if (tree_data) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:optimization_guide.proto.AXTreeUpdate.tree_data)
}
inline ::optimization_guide::proto::AXTreeData* AXTreeUpdate::release_tree_data()
{
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::optimization_guide::proto::AXTreeData* temp = _impl_.tree_data_;
    _impl_.tree_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::optimization_guide::proto::AXTreeData* AXTreeUpdate::unsafe_arena_release_tree_data()
{
    // @@protoc_insertion_point(field_release:optimization_guide.proto.AXTreeUpdate.tree_data)
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::optimization_guide::proto::AXTreeData* temp = _impl_.tree_data_;
    _impl_.tree_data_ = nullptr;
    return temp;
}
inline ::optimization_guide::proto::AXTreeData* AXTreeUpdate::_internal_mutable_tree_data()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    if (_impl_.tree_data_ == nullptr) {
        auto* p = CreateMaybeMessage<::optimization_guide::proto::AXTreeData>(GetArenaForAllocation());
        _impl_.tree_data_ = p;
    }
    return _impl_.tree_data_;
}
inline ::optimization_guide::proto::AXTreeData* AXTreeUpdate::mutable_tree_data()
{
    ::optimization_guide::proto::AXTreeData* _msg = _internal_mutable_tree_data();
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.AXTreeUpdate.tree_data)
    return _msg;
}
inline void AXTreeUpdate::set_allocated_tree_data(::optimization_guide::proto::AXTreeData* tree_data)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.tree_data_;
    }
    if (tree_data) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tree_data);
        if (message_arena != submessage_arena) {
            tree_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, tree_data, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.tree_data_ = tree_data;
    // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.AXTreeUpdate.tree_data)
}

// uint32 root_id = 2;
inline void AXTreeUpdate::clear_root_id()
{
    _impl_.root_id_ = 0u;
}
inline uint32_t AXTreeUpdate::_internal_root_id() const
{
    return _impl_.root_id_;
}
inline uint32_t AXTreeUpdate::root_id() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.AXTreeUpdate.root_id)
    return _internal_root_id();
}
inline void AXTreeUpdate::_internal_set_root_id(uint32_t value)
{

    _impl_.root_id_ = value;
}
inline void AXTreeUpdate::set_root_id(uint32_t value)
{
    _internal_set_root_id(value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.AXTreeUpdate.root_id)
}

// repeated .optimization_guide.proto.AXNodeData nodes = 3;
inline int AXTreeUpdate::_internal_nodes_size() const
{
    return _impl_.nodes_.size();
}
inline int AXTreeUpdate::nodes_size() const
{
    return _internal_nodes_size();
}
inline void AXTreeUpdate::clear_nodes()
{
    _impl_.nodes_.Clear();
}
inline ::optimization_guide::proto::AXNodeData* AXTreeUpdate::mutable_nodes(int index)
{
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.AXTreeUpdate.nodes)
    return _impl_.nodes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::AXNodeData>* AXTreeUpdate::mutable_nodes()
{
    // @@protoc_insertion_point(field_mutable_list:optimization_guide.proto.AXTreeUpdate.nodes)
    return &_impl_.nodes_;
}
inline const ::optimization_guide::proto::AXNodeData& AXTreeUpdate::_internal_nodes(int index) const
{
    return _impl_.nodes_.Get(index);
}
inline const ::optimization_guide::proto::AXNodeData& AXTreeUpdate::nodes(int index) const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.AXTreeUpdate.nodes)
    return _internal_nodes(index);
}
inline ::optimization_guide::proto::AXNodeData* AXTreeUpdate::_internal_add_nodes()
{
    return _impl_.nodes_.Add();
}
inline ::optimization_guide::proto::AXNodeData* AXTreeUpdate::add_nodes()
{
    ::optimization_guide::proto::AXNodeData* _add = _internal_add_nodes();
    // @@protoc_insertion_point(field_add:optimization_guide.proto.AXTreeUpdate.nodes)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::AXNodeData>& AXTreeUpdate::nodes() const
{
    // @@protoc_insertion_point(field_list:optimization_guide.proto.AXTreeUpdate.nodes)
    return _impl_.nodes_;
}

// -------------------------------------------------------------------

// AXTreeData

// string doctype = 1;
inline void AXTreeData::clear_doctype()
{
    _impl_.doctype_.ClearToEmpty();
}
inline const std::string& AXTreeData::doctype() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.AXTreeData.doctype)
    return _internal_doctype();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void AXTreeData::set_doctype(ArgT0&& arg0, ArgT... args)
{

    _impl_.doctype_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:optimization_guide.proto.AXTreeData.doctype)
}
inline std::string* AXTreeData::mutable_doctype()
{
    std::string* _s = _internal_mutable_doctype();
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.AXTreeData.doctype)
    return _s;
}
inline const std::string& AXTreeData::_internal_doctype() const
{
    return _impl_.doctype_.Get();
}
inline void AXTreeData::_internal_set_doctype(const std::string& value)
{

    _impl_.doctype_.Set(value, GetArenaForAllocation());
}
inline std::string* AXTreeData::_internal_mutable_doctype()
{

    return _impl_.doctype_.Mutable(GetArenaForAllocation());
}
inline std::string* AXTreeData::release_doctype()
{
    // @@protoc_insertion_point(field_release:optimization_guide.proto.AXTreeData.doctype)
    return _impl_.doctype_.Release();
}
inline void AXTreeData::set_allocated_doctype(std::string* doctype)
{
    if (doctype != nullptr) {

    } else {
    }
    _impl_.doctype_.SetAllocated(doctype, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.doctype_.IsDefault()) {
        _impl_.doctype_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.AXTreeData.doctype)
}

// bool loaded = 2;
inline void AXTreeData::clear_loaded()
{
    _impl_.loaded_ = false;
}
inline bool AXTreeData::_internal_loaded() const
{
    return _impl_.loaded_;
}
inline bool AXTreeData::loaded() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.AXTreeData.loaded)
    return _internal_loaded();
}
inline void AXTreeData::_internal_set_loaded(bool value)
{

    _impl_.loaded_ = value;
}
inline void AXTreeData::set_loaded(bool value)
{
    _internal_set_loaded(value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.AXTreeData.loaded)
}

// float loading_progress = 3;
inline void AXTreeData::clear_loading_progress()
{
    _impl_.loading_progress_ = 0;
}
inline float AXTreeData::_internal_loading_progress() const
{
    return _impl_.loading_progress_;
}
inline float AXTreeData::loading_progress() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.AXTreeData.loading_progress)
    return _internal_loading_progress();
}
inline void AXTreeData::_internal_set_loading_progress(float value)
{

    _impl_.loading_progress_ = value;
}
inline void AXTreeData::set_loading_progress(float value)
{
    _internal_set_loading_progress(value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.AXTreeData.loading_progress)
}

// string mimetype = 4;
inline void AXTreeData::clear_mimetype()
{
    _impl_.mimetype_.ClearToEmpty();
}
inline const std::string& AXTreeData::mimetype() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.AXTreeData.mimetype)
    return _internal_mimetype();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void AXTreeData::set_mimetype(ArgT0&& arg0, ArgT... args)
{

    _impl_.mimetype_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:optimization_guide.proto.AXTreeData.mimetype)
}
inline std::string* AXTreeData::mutable_mimetype()
{
    std::string* _s = _internal_mutable_mimetype();
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.AXTreeData.mimetype)
    return _s;
}
inline const std::string& AXTreeData::_internal_mimetype() const
{
    return _impl_.mimetype_.Get();
}
inline void AXTreeData::_internal_set_mimetype(const std::string& value)
{

    _impl_.mimetype_.Set(value, GetArenaForAllocation());
}
inline std::string* AXTreeData::_internal_mutable_mimetype()
{

    return _impl_.mimetype_.Mutable(GetArenaForAllocation());
}
inline std::string* AXTreeData::release_mimetype()
{
    // @@protoc_insertion_point(field_release:optimization_guide.proto.AXTreeData.mimetype)
    return _impl_.mimetype_.Release();
}
inline void AXTreeData::set_allocated_mimetype(std::string* mimetype)
{
    if (mimetype != nullptr) {

    } else {
    }
    _impl_.mimetype_.SetAllocated(mimetype, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.mimetype_.IsDefault()) {
        _impl_.mimetype_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.AXTreeData.mimetype)
}

// string title = 5;
inline void AXTreeData::clear_title()
{
    _impl_.title_.ClearToEmpty();
}
inline const std::string& AXTreeData::title() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.AXTreeData.title)
    return _internal_title();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void AXTreeData::set_title(ArgT0&& arg0, ArgT... args)
{

    _impl_.title_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:optimization_guide.proto.AXTreeData.title)
}
inline std::string* AXTreeData::mutable_title()
{
    std::string* _s = _internal_mutable_title();
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.AXTreeData.title)
    return _s;
}
inline const std::string& AXTreeData::_internal_title() const
{
    return _impl_.title_.Get();
}
inline void AXTreeData::_internal_set_title(const std::string& value)
{

    _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* AXTreeData::_internal_mutable_title()
{

    return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* AXTreeData::release_title()
{
    // @@protoc_insertion_point(field_release:optimization_guide.proto.AXTreeData.title)
    return _impl_.title_.Release();
}
inline void AXTreeData::set_allocated_title(std::string* title)
{
    if (title != nullptr) {

    } else {
    }
    _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.title_.IsDefault()) {
        _impl_.title_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.AXTreeData.title)
}

// uint32 focus_id = 6;
inline void AXTreeData::clear_focus_id()
{
    _impl_.focus_id_ = 0u;
}
inline uint32_t AXTreeData::_internal_focus_id() const
{
    return _impl_.focus_id_;
}
inline uint32_t AXTreeData::focus_id() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.AXTreeData.focus_id)
    return _internal_focus_id();
}
inline void AXTreeData::_internal_set_focus_id(uint32_t value)
{

    _impl_.focus_id_ = value;
}
inline void AXTreeData::set_focus_id(uint32_t value)
{
    _internal_set_focus_id(value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.AXTreeData.focus_id)
}

// bool sel_is_backward = 7;
inline void AXTreeData::clear_sel_is_backward()
{
    _impl_.sel_is_backward_ = false;
}
inline bool AXTreeData::_internal_sel_is_backward() const
{
    return _impl_.sel_is_backward_;
}
inline bool AXTreeData::sel_is_backward() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.AXTreeData.sel_is_backward)
    return _internal_sel_is_backward();
}
inline void AXTreeData::_internal_set_sel_is_backward(bool value)
{

    _impl_.sel_is_backward_ = value;
}
inline void AXTreeData::set_sel_is_backward(bool value)
{
    _internal_set_sel_is_backward(value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.AXTreeData.sel_is_backward)
}

// uint32 sel_anchor_object_id = 8;
inline void AXTreeData::clear_sel_anchor_object_id()
{
    _impl_.sel_anchor_object_id_ = 0u;
}
inline uint32_t AXTreeData::_internal_sel_anchor_object_id() const
{
    return _impl_.sel_anchor_object_id_;
}
inline uint32_t AXTreeData::sel_anchor_object_id() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.AXTreeData.sel_anchor_object_id)
    return _internal_sel_anchor_object_id();
}
inline void AXTreeData::_internal_set_sel_anchor_object_id(uint32_t value)
{

    _impl_.sel_anchor_object_id_ = value;
}
inline void AXTreeData::set_sel_anchor_object_id(uint32_t value)
{
    _internal_set_sel_anchor_object_id(value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.AXTreeData.sel_anchor_object_id)
}

// uint32 sel_anchor_offset = 9;
inline void AXTreeData::clear_sel_anchor_offset()
{
    _impl_.sel_anchor_offset_ = 0u;
}
inline uint32_t AXTreeData::_internal_sel_anchor_offset() const
{
    return _impl_.sel_anchor_offset_;
}
inline uint32_t AXTreeData::sel_anchor_offset() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.AXTreeData.sel_anchor_offset)
    return _internal_sel_anchor_offset();
}
inline void AXTreeData::_internal_set_sel_anchor_offset(uint32_t value)
{

    _impl_.sel_anchor_offset_ = value;
}
inline void AXTreeData::set_sel_anchor_offset(uint32_t value)
{
    _internal_set_sel_anchor_offset(value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.AXTreeData.sel_anchor_offset)
}

// .optimization_guide.proto.AXTextAffinity sel_anchor_affinity = 10;
inline void AXTreeData::clear_sel_anchor_affinity()
{
    _impl_.sel_anchor_affinity_ = 0;
}
inline ::optimization_guide::proto::AXTextAffinity AXTreeData::_internal_sel_anchor_affinity() const
{
    return static_cast<::optimization_guide::proto::AXTextAffinity>(_impl_.sel_anchor_affinity_);
}
inline ::optimization_guide::proto::AXTextAffinity AXTreeData::sel_anchor_affinity() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.AXTreeData.sel_anchor_affinity)
    return _internal_sel_anchor_affinity();
}
inline void AXTreeData::_internal_set_sel_anchor_affinity(::optimization_guide::proto::AXTextAffinity value)
{

    _impl_.sel_anchor_affinity_ = value;
}
inline void AXTreeData::set_sel_anchor_affinity(::optimization_guide::proto::AXTextAffinity value)
{
    _internal_set_sel_anchor_affinity(value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.AXTreeData.sel_anchor_affinity)
}

// uint32 sel_focus_object_id = 11;
inline void AXTreeData::clear_sel_focus_object_id()
{
    _impl_.sel_focus_object_id_ = 0u;
}
inline uint32_t AXTreeData::_internal_sel_focus_object_id() const
{
    return _impl_.sel_focus_object_id_;
}
inline uint32_t AXTreeData::sel_focus_object_id() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.AXTreeData.sel_focus_object_id)
    return _internal_sel_focus_object_id();
}
inline void AXTreeData::_internal_set_sel_focus_object_id(uint32_t value)
{

    _impl_.sel_focus_object_id_ = value;
}
inline void AXTreeData::set_sel_focus_object_id(uint32_t value)
{
    _internal_set_sel_focus_object_id(value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.AXTreeData.sel_focus_object_id)
}

// uint32 sel_focus_offset = 12;
inline void AXTreeData::clear_sel_focus_offset()
{
    _impl_.sel_focus_offset_ = 0u;
}
inline uint32_t AXTreeData::_internal_sel_focus_offset() const
{
    return _impl_.sel_focus_offset_;
}
inline uint32_t AXTreeData::sel_focus_offset() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.AXTreeData.sel_focus_offset)
    return _internal_sel_focus_offset();
}
inline void AXTreeData::_internal_set_sel_focus_offset(uint32_t value)
{

    _impl_.sel_focus_offset_ = value;
}
inline void AXTreeData::set_sel_focus_offset(uint32_t value)
{
    _internal_set_sel_focus_offset(value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.AXTreeData.sel_focus_offset)
}

// .optimization_guide.proto.AXTextAffinity sel_focus_affinity = 13;
inline void AXTreeData::clear_sel_focus_affinity()
{
    _impl_.sel_focus_affinity_ = 0;
}
inline ::optimization_guide::proto::AXTextAffinity AXTreeData::_internal_sel_focus_affinity() const
{
    return static_cast<::optimization_guide::proto::AXTextAffinity>(_impl_.sel_focus_affinity_);
}
inline ::optimization_guide::proto::AXTextAffinity AXTreeData::sel_focus_affinity() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.AXTreeData.sel_focus_affinity)
    return _internal_sel_focus_affinity();
}
inline void AXTreeData::_internal_set_sel_focus_affinity(::optimization_guide::proto::AXTextAffinity value)
{

    _impl_.sel_focus_affinity_ = value;
}
inline void AXTreeData::set_sel_focus_affinity(::optimization_guide::proto::AXTextAffinity value)
{
    _internal_set_sel_focus_affinity(value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.AXTreeData.sel_focus_affinity)
}

// uint32 root_scroller_id = 14;
inline void AXTreeData::clear_root_scroller_id()
{
    _impl_.root_scroller_id_ = 0u;
}
inline uint32_t AXTreeData::_internal_root_scroller_id() const
{
    return _impl_.root_scroller_id_;
}
inline uint32_t AXTreeData::root_scroller_id() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.AXTreeData.root_scroller_id)
    return _internal_root_scroller_id();
}
inline void AXTreeData::_internal_set_root_scroller_id(uint32_t value)
{

    _impl_.root_scroller_id_ = value;
}
inline void AXTreeData::set_root_scroller_id(uint32_t value)
{
    _internal_set_root_scroller_id(value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.AXTreeData.root_scroller_id)
}

// repeated string metadata = 15;
inline int AXTreeData::_internal_metadata_size() const
{
    return _impl_.metadata_.size();
}
inline int AXTreeData::metadata_size() const
{
    return _internal_metadata_size();
}
inline void AXTreeData::clear_metadata()
{
    _impl_.metadata_.Clear();
}
inline std::string* AXTreeData::add_metadata()
{
    std::string* _s = _internal_add_metadata();
    // @@protoc_insertion_point(field_add_mutable:optimization_guide.proto.AXTreeData.metadata)
    return _s;
}
inline const std::string& AXTreeData::_internal_metadata(int index) const
{
    return _impl_.metadata_.Get(index);
}
inline const std::string& AXTreeData::metadata(int index) const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.AXTreeData.metadata)
    return _internal_metadata(index);
}
inline std::string* AXTreeData::mutable_metadata(int index)
{
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.AXTreeData.metadata)
    return _impl_.metadata_.Mutable(index);
}
inline void AXTreeData::set_metadata(int index, const std::string& value)
{
    _impl_.metadata_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.AXTreeData.metadata)
}
inline void AXTreeData::set_metadata(int index, std::string&& value)
{
    _impl_.metadata_.Mutable(index)->assign(std::move(value));
    // @@protoc_insertion_point(field_set:optimization_guide.proto.AXTreeData.metadata)
}
inline void AXTreeData::set_metadata(int index, const char* value)
{
    GOOGLE_DCHECK(value != nullptr);
    _impl_.metadata_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set_char:optimization_guide.proto.AXTreeData.metadata)
}
inline void AXTreeData::set_metadata(int index, const char* value, size_t size)
{
    _impl_.metadata_.Mutable(index)->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:optimization_guide.proto.AXTreeData.metadata)
}
inline std::string* AXTreeData::_internal_add_metadata()
{
    return _impl_.metadata_.Add();
}
inline void AXTreeData::add_metadata(const std::string& value)
{
    _impl_.metadata_.Add()->assign(value);
    // @@protoc_insertion_point(field_add:optimization_guide.proto.AXTreeData.metadata)
}
inline void AXTreeData::add_metadata(std::string&& value)
{
    _impl_.metadata_.Add(std::move(value));
    // @@protoc_insertion_point(field_add:optimization_guide.proto.AXTreeData.metadata)
}
inline void AXTreeData::add_metadata(const char* value)
{
    GOOGLE_DCHECK(value != nullptr);
    _impl_.metadata_.Add()->assign(value);
    // @@protoc_insertion_point(field_add_char:optimization_guide.proto.AXTreeData.metadata)
}
inline void AXTreeData::add_metadata(const char* value, size_t size)
{
    _impl_.metadata_.Add()->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_add_pointer:optimization_guide.proto.AXTreeData.metadata)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& AXTreeData::metadata() const
{
    // @@protoc_insertion_point(field_list:optimization_guide.proto.AXTreeData.metadata)
    return _impl_.metadata_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* AXTreeData::mutable_metadata()
{
    // @@protoc_insertion_point(field_mutable_list:optimization_guide.proto.AXTreeData.metadata)
    return &_impl_.metadata_;
}

// -------------------------------------------------------------------

// AXNodeData

// uint32 id = 1;
inline void AXNodeData::clear_id()
{
    _impl_.id_ = 0u;
}
inline uint32_t AXNodeData::_internal_id() const
{
    return _impl_.id_;
}
inline uint32_t AXNodeData::id() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.AXNodeData.id)
    return _internal_id();
}
inline void AXNodeData::_internal_set_id(uint32_t value)
{

    _impl_.id_ = value;
}
inline void AXNodeData::set_id(uint32_t value)
{
    _internal_set_id(value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.AXNodeData.id)
}

// .optimization_guide.proto.AXRole role = 2;
inline void AXNodeData::clear_role()
{
    _impl_.role_ = 0;
}
inline ::optimization_guide::proto::AXRole AXNodeData::_internal_role() const
{
    return static_cast<::optimization_guide::proto::AXRole>(_impl_.role_);
}
inline ::optimization_guide::proto::AXRole AXNodeData::role() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.AXNodeData.role)
    return _internal_role();
}
inline void AXNodeData::_internal_set_role(::optimization_guide::proto::AXRole value)
{

    _impl_.role_ = value;
}
inline void AXNodeData::set_role(::optimization_guide::proto::AXRole value)
{
    _internal_set_role(value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.AXNodeData.role)
}

// uint32 state = 3;
inline void AXNodeData::clear_state()
{
    _impl_.state_ = 0u;
}
inline uint32_t AXNodeData::_internal_state() const
{
    return _impl_.state_;
}
inline uint32_t AXNodeData::state() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.AXNodeData.state)
    return _internal_state();
}
inline void AXNodeData::_internal_set_state(uint32_t value)
{

    _impl_.state_ = value;
}
inline void AXNodeData::set_state(uint32_t value)
{
    _internal_set_state(value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.AXNodeData.state)
}

// uint64 actions = 4;
inline void AXNodeData::clear_actions()
{
    _impl_.actions_ = uint64_t { 0u };
}
inline uint64_t AXNodeData::_internal_actions() const
{
    return _impl_.actions_;
}
inline uint64_t AXNodeData::actions() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.AXNodeData.actions)
    return _internal_actions();
}
inline void AXNodeData::_internal_set_actions(uint64_t value)
{

    _impl_.actions_ = value;
}
inline void AXNodeData::set_actions(uint64_t value)
{
    _internal_set_actions(value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.AXNodeData.actions)
}

// repeated .optimization_guide.proto.AXAttribute attributes = 5;
inline int AXNodeData::_internal_attributes_size() const
{
    return _impl_.attributes_.size();
}
inline int AXNodeData::attributes_size() const
{
    return _internal_attributes_size();
}
inline void AXNodeData::clear_attributes()
{
    _impl_.attributes_.Clear();
}
inline ::optimization_guide::proto::AXAttribute* AXNodeData::mutable_attributes(int index)
{
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.AXNodeData.attributes)
    return _impl_.attributes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::AXAttribute>* AXNodeData::mutable_attributes()
{
    // @@protoc_insertion_point(field_mutable_list:optimization_guide.proto.AXNodeData.attributes)
    return &_impl_.attributes_;
}
inline const ::optimization_guide::proto::AXAttribute& AXNodeData::_internal_attributes(int index) const
{
    return _impl_.attributes_.Get(index);
}
inline const ::optimization_guide::proto::AXAttribute& AXNodeData::attributes(int index) const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.AXNodeData.attributes)
    return _internal_attributes(index);
}
inline ::optimization_guide::proto::AXAttribute* AXNodeData::_internal_add_attributes()
{
    return _impl_.attributes_.Add();
}
inline ::optimization_guide::proto::AXAttribute* AXNodeData::add_attributes()
{
    ::optimization_guide::proto::AXAttribute* _add = _internal_add_attributes();
    // @@protoc_insertion_point(field_add:optimization_guide.proto.AXNodeData.attributes)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::AXAttribute>& AXNodeData::attributes() const
{
    // @@protoc_insertion_point(field_list:optimization_guide.proto.AXNodeData.attributes)
    return _impl_.attributes_;
}

// repeated int32 child_ids = 6;
inline int AXNodeData::_internal_child_ids_size() const
{
    return _impl_.child_ids_.size();
}
inline int AXNodeData::child_ids_size() const
{
    return _internal_child_ids_size();
}
inline void AXNodeData::clear_child_ids()
{
    _impl_.child_ids_.Clear();
}
inline int32_t AXNodeData::_internal_child_ids(int index) const
{
    return _impl_.child_ids_.Get(index);
}
inline int32_t AXNodeData::child_ids(int index) const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.AXNodeData.child_ids)
    return _internal_child_ids(index);
}
inline void AXNodeData::set_child_ids(int index, int32_t value)
{
    _impl_.child_ids_.Set(index, value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.AXNodeData.child_ids)
}
inline void AXNodeData::_internal_add_child_ids(int32_t value)
{
    _impl_.child_ids_.Add(value);
}
inline void AXNodeData::add_child_ids(int32_t value)
{
    _internal_add_child_ids(value);
    // @@protoc_insertion_point(field_add:optimization_guide.proto.AXNodeData.child_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>& AXNodeData::_internal_child_ids() const
{
    return _impl_.child_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>& AXNodeData::child_ids() const
{
    // @@protoc_insertion_point(field_list:optimization_guide.proto.AXNodeData.child_ids)
    return _internal_child_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>* AXNodeData::_internal_mutable_child_ids()
{
    return &_impl_.child_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>* AXNodeData::mutable_child_ids()
{
    // @@protoc_insertion_point(field_mutable_list:optimization_guide.proto.AXNodeData.child_ids)
    return _internal_mutable_child_ids();
}

// .optimization_guide.proto.AXRelativeBounds relative_bounds = 7;
inline bool AXNodeData::_internal_has_relative_bounds() const
{
    return this != internal_default_instance() && _impl_.relative_bounds_ != nullptr;
}
inline bool AXNodeData::has_relative_bounds() const
{
    return _internal_has_relative_bounds();
}
inline void AXNodeData::clear_relative_bounds()
{
    if (GetArenaForAllocation() == nullptr && _impl_.relative_bounds_ != nullptr) {
        delete _impl_.relative_bounds_;
    }
    _impl_.relative_bounds_ = nullptr;
}
inline const ::optimization_guide::proto::AXRelativeBounds& AXNodeData::_internal_relative_bounds() const
{
    const ::optimization_guide::proto::AXRelativeBounds* p = _impl_.relative_bounds_;
    return p != nullptr
        ? *p
        : reinterpret_cast<const ::optimization_guide::proto::AXRelativeBounds&>(::optimization_guide::proto::_AXRelativeBounds_default_instance_);
}
inline const ::optimization_guide::proto::AXRelativeBounds& AXNodeData::relative_bounds() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.AXNodeData.relative_bounds)
    return _internal_relative_bounds();
}
inline void AXNodeData::unsafe_arena_set_allocated_relative_bounds(::optimization_guide::proto::AXRelativeBounds* relative_bounds)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.relative_bounds_);
    }
    _impl_.relative_bounds_ = relative_bounds;
    if (relative_bounds) {

    } else {
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:optimization_guide.proto.AXNodeData.relative_bounds)
}
inline ::optimization_guide::proto::AXRelativeBounds* AXNodeData::release_relative_bounds()
{

    ::optimization_guide::proto::AXRelativeBounds* temp = _impl_.relative_bounds_;
    _impl_.relative_bounds_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::optimization_guide::proto::AXRelativeBounds* AXNodeData::unsafe_arena_release_relative_bounds()
{
    // @@protoc_insertion_point(field_release:optimization_guide.proto.AXNodeData.relative_bounds)

    ::optimization_guide::proto::AXRelativeBounds* temp = _impl_.relative_bounds_;
    _impl_.relative_bounds_ = nullptr;
    return temp;
}
inline ::optimization_guide::proto::AXRelativeBounds* AXNodeData::_internal_mutable_relative_bounds()
{

    if (_impl_.relative_bounds_ == nullptr) {
        auto* p = CreateMaybeMessage<::optimization_guide::proto::AXRelativeBounds>(GetArenaForAllocation());
        _impl_.relative_bounds_ = p;
    }
    return _impl_.relative_bounds_;
}
inline ::optimization_guide::proto::AXRelativeBounds* AXNodeData::mutable_relative_bounds()
{
    ::optimization_guide::proto::AXRelativeBounds* _msg = _internal_mutable_relative_bounds();
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.AXNodeData.relative_bounds)
    return _msg;
}
inline void AXNodeData::set_allocated_relative_bounds(::optimization_guide::proto::AXRelativeBounds* relative_bounds)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.relative_bounds_;
    }
    if (relative_bounds) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(relative_bounds);
        if (message_arena != submessage_arena) {
            relative_bounds = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, relative_bounds, submessage_arena);
        }

    } else {
    }
    _impl_.relative_bounds_ = relative_bounds;
    // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.AXNodeData.relative_bounds)
}

// -------------------------------------------------------------------

// AXAttribute

// .optimization_guide.proto.AXStringAttribute string_type = 1;
inline bool AXAttribute::_internal_has_string_type() const
{
    return attribute_key_case() == kStringType;
}
inline bool AXAttribute::has_string_type() const
{
    return _internal_has_string_type();
}
inline void AXAttribute::set_has_string_type()
{
    _impl_._oneof_case_[0] = kStringType;
}
inline void AXAttribute::clear_string_type()
{
    if (_internal_has_string_type()) {
        _impl_.attribute_key_.string_type_ = 0;
        clear_has_attribute_key();
    }
}
inline ::optimization_guide::proto::AXStringAttribute AXAttribute::_internal_string_type() const
{
    if (_internal_has_string_type()) {
        return static_cast<::optimization_guide::proto::AXStringAttribute>(_impl_.attribute_key_.string_type_);
    }
    return static_cast<::optimization_guide::proto::AXStringAttribute>(0);
}
inline ::optimization_guide::proto::AXStringAttribute AXAttribute::string_type() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.AXAttribute.string_type)
    return _internal_string_type();
}
inline void AXAttribute::_internal_set_string_type(::optimization_guide::proto::AXStringAttribute value)
{
    if (!_internal_has_string_type()) {
        clear_attribute_key();
        set_has_string_type();
    }
    _impl_.attribute_key_.string_type_ = value;
}
inline void AXAttribute::set_string_type(::optimization_guide::proto::AXStringAttribute value)
{
    _internal_set_string_type(value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.AXAttribute.string_type)
}

// .optimization_guide.proto.AXIntAttribute int_type = 2;
inline bool AXAttribute::_internal_has_int_type() const
{
    return attribute_key_case() == kIntType;
}
inline bool AXAttribute::has_int_type() const
{
    return _internal_has_int_type();
}
inline void AXAttribute::set_has_int_type()
{
    _impl_._oneof_case_[0] = kIntType;
}
inline void AXAttribute::clear_int_type()
{
    if (_internal_has_int_type()) {
        _impl_.attribute_key_.int_type_ = 0;
        clear_has_attribute_key();
    }
}
inline ::optimization_guide::proto::AXIntAttribute AXAttribute::_internal_int_type() const
{
    if (_internal_has_int_type()) {
        return static_cast<::optimization_guide::proto::AXIntAttribute>(_impl_.attribute_key_.int_type_);
    }
    return static_cast<::optimization_guide::proto::AXIntAttribute>(0);
}
inline ::optimization_guide::proto::AXIntAttribute AXAttribute::int_type() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.AXAttribute.int_type)
    return _internal_int_type();
}
inline void AXAttribute::_internal_set_int_type(::optimization_guide::proto::AXIntAttribute value)
{
    if (!_internal_has_int_type()) {
        clear_attribute_key();
        set_has_int_type();
    }
    _impl_.attribute_key_.int_type_ = value;
}
inline void AXAttribute::set_int_type(::optimization_guide::proto::AXIntAttribute value)
{
    _internal_set_int_type(value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.AXAttribute.int_type)
}

// .optimization_guide.proto.AXFloatAttribute float_type = 3;
inline bool AXAttribute::_internal_has_float_type() const
{
    return attribute_key_case() == kFloatType;
}
inline bool AXAttribute::has_float_type() const
{
    return _internal_has_float_type();
}
inline void AXAttribute::set_has_float_type()
{
    _impl_._oneof_case_[0] = kFloatType;
}
inline void AXAttribute::clear_float_type()
{
    if (_internal_has_float_type()) {
        _impl_.attribute_key_.float_type_ = 0;
        clear_has_attribute_key();
    }
}
inline ::optimization_guide::proto::AXFloatAttribute AXAttribute::_internal_float_type() const
{
    if (_internal_has_float_type()) {
        return static_cast<::optimization_guide::proto::AXFloatAttribute>(_impl_.attribute_key_.float_type_);
    }
    return static_cast<::optimization_guide::proto::AXFloatAttribute>(0);
}
inline ::optimization_guide::proto::AXFloatAttribute AXAttribute::float_type() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.AXAttribute.float_type)
    return _internal_float_type();
}
inline void AXAttribute::_internal_set_float_type(::optimization_guide::proto::AXFloatAttribute value)
{
    if (!_internal_has_float_type()) {
        clear_attribute_key();
        set_has_float_type();
    }
    _impl_.attribute_key_.float_type_ = value;
}
inline void AXAttribute::set_float_type(::optimization_guide::proto::AXFloatAttribute value)
{
    _internal_set_float_type(value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.AXAttribute.float_type)
}

// .optimization_guide.proto.AXBoolAttribute bool_type = 4;
inline bool AXAttribute::_internal_has_bool_type() const
{
    return attribute_key_case() == kBoolType;
}
inline bool AXAttribute::has_bool_type() const
{
    return _internal_has_bool_type();
}
inline void AXAttribute::set_has_bool_type()
{
    _impl_._oneof_case_[0] = kBoolType;
}
inline void AXAttribute::clear_bool_type()
{
    if (_internal_has_bool_type()) {
        _impl_.attribute_key_.bool_type_ = 0;
        clear_has_attribute_key();
    }
}
inline ::optimization_guide::proto::AXBoolAttribute AXAttribute::_internal_bool_type() const
{
    if (_internal_has_bool_type()) {
        return static_cast<::optimization_guide::proto::AXBoolAttribute>(_impl_.attribute_key_.bool_type_);
    }
    return static_cast<::optimization_guide::proto::AXBoolAttribute>(0);
}
inline ::optimization_guide::proto::AXBoolAttribute AXAttribute::bool_type() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.AXAttribute.bool_type)
    return _internal_bool_type();
}
inline void AXAttribute::_internal_set_bool_type(::optimization_guide::proto::AXBoolAttribute value)
{
    if (!_internal_has_bool_type()) {
        clear_attribute_key();
        set_has_bool_type();
    }
    _impl_.attribute_key_.bool_type_ = value;
}
inline void AXAttribute::set_bool_type(::optimization_guide::proto::AXBoolAttribute value)
{
    _internal_set_bool_type(value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.AXAttribute.bool_type)
}

// .optimization_guide.proto.AXIntListAttribute intlist_type = 5;
inline bool AXAttribute::_internal_has_intlist_type() const
{
    return attribute_key_case() == kIntlistType;
}
inline bool AXAttribute::has_intlist_type() const
{
    return _internal_has_intlist_type();
}
inline void AXAttribute::set_has_intlist_type()
{
    _impl_._oneof_case_[0] = kIntlistType;
}
inline void AXAttribute::clear_intlist_type()
{
    if (_internal_has_intlist_type()) {
        _impl_.attribute_key_.intlist_type_ = 0;
        clear_has_attribute_key();
    }
}
inline ::optimization_guide::proto::AXIntListAttribute AXAttribute::_internal_intlist_type() const
{
    if (_internal_has_intlist_type()) {
        return static_cast<::optimization_guide::proto::AXIntListAttribute>(_impl_.attribute_key_.intlist_type_);
    }
    return static_cast<::optimization_guide::proto::AXIntListAttribute>(0);
}
inline ::optimization_guide::proto::AXIntListAttribute AXAttribute::intlist_type() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.AXAttribute.intlist_type)
    return _internal_intlist_type();
}
inline void AXAttribute::_internal_set_intlist_type(::optimization_guide::proto::AXIntListAttribute value)
{
    if (!_internal_has_intlist_type()) {
        clear_attribute_key();
        set_has_intlist_type();
    }
    _impl_.attribute_key_.intlist_type_ = value;
}
inline void AXAttribute::set_intlist_type(::optimization_guide::proto::AXIntListAttribute value)
{
    _internal_set_intlist_type(value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.AXAttribute.intlist_type)
}

// .optimization_guide.proto.AXStringListAttribute stringlist_type = 6;
inline bool AXAttribute::_internal_has_stringlist_type() const
{
    return attribute_key_case() == kStringlistType;
}
inline bool AXAttribute::has_stringlist_type() const
{
    return _internal_has_stringlist_type();
}
inline void AXAttribute::set_has_stringlist_type()
{
    _impl_._oneof_case_[0] = kStringlistType;
}
inline void AXAttribute::clear_stringlist_type()
{
    if (_internal_has_stringlist_type()) {
        _impl_.attribute_key_.stringlist_type_ = 0;
        clear_has_attribute_key();
    }
}
inline ::optimization_guide::proto::AXStringListAttribute AXAttribute::_internal_stringlist_type() const
{
    if (_internal_has_stringlist_type()) {
        return static_cast<::optimization_guide::proto::AXStringListAttribute>(_impl_.attribute_key_.stringlist_type_);
    }
    return static_cast<::optimization_guide::proto::AXStringListAttribute>(0);
}
inline ::optimization_guide::proto::AXStringListAttribute AXAttribute::stringlist_type() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.AXAttribute.stringlist_type)
    return _internal_stringlist_type();
}
inline void AXAttribute::_internal_set_stringlist_type(::optimization_guide::proto::AXStringListAttribute value)
{
    if (!_internal_has_stringlist_type()) {
        clear_attribute_key();
        set_has_stringlist_type();
    }
    _impl_.attribute_key_.stringlist_type_ = value;
}
inline void AXAttribute::set_stringlist_type(::optimization_guide::proto::AXStringListAttribute value)
{
    _internal_set_stringlist_type(value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.AXAttribute.stringlist_type)
}

// string html_attribute_name = 7;
inline bool AXAttribute::_internal_has_html_attribute_name() const
{
    return attribute_key_case() == kHtmlAttributeName;
}
inline bool AXAttribute::has_html_attribute_name() const
{
    return _internal_has_html_attribute_name();
}
inline void AXAttribute::set_has_html_attribute_name()
{
    _impl_._oneof_case_[0] = kHtmlAttributeName;
}
inline void AXAttribute::clear_html_attribute_name()
{
    if (_internal_has_html_attribute_name()) {
        _impl_.attribute_key_.html_attribute_name_.Destroy();
        clear_has_attribute_key();
    }
}
inline const std::string& AXAttribute::html_attribute_name() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.AXAttribute.html_attribute_name)
    return _internal_html_attribute_name();
}
template <typename ArgT0, typename... ArgT> inline void AXAttribute::set_html_attribute_name(ArgT0&& arg0, ArgT... args)
{
    if (!_internal_has_html_attribute_name()) {
        clear_attribute_key();
        set_has_html_attribute_name();
        _impl_.attribute_key_.html_attribute_name_.InitDefault();
    }
    _impl_.attribute_key_.html_attribute_name_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:optimization_guide.proto.AXAttribute.html_attribute_name)
}
inline std::string* AXAttribute::mutable_html_attribute_name()
{
    std::string* _s = _internal_mutable_html_attribute_name();
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.AXAttribute.html_attribute_name)
    return _s;
}
inline const std::string& AXAttribute::_internal_html_attribute_name() const
{
    if (_internal_has_html_attribute_name()) {
        return _impl_.attribute_key_.html_attribute_name_.Get();
    }
    return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void AXAttribute::_internal_set_html_attribute_name(const std::string& value)
{
    if (!_internal_has_html_attribute_name()) {
        clear_attribute_key();
        set_has_html_attribute_name();
        _impl_.attribute_key_.html_attribute_name_.InitDefault();
    }
    _impl_.attribute_key_.html_attribute_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AXAttribute::_internal_mutable_html_attribute_name()
{
    if (!_internal_has_html_attribute_name()) {
        clear_attribute_key();
        set_has_html_attribute_name();
        _impl_.attribute_key_.html_attribute_name_.InitDefault();
    }
    return _impl_.attribute_key_.html_attribute_name_.Mutable(GetArenaForAllocation());
}
inline std::string* AXAttribute::release_html_attribute_name()
{
    // @@protoc_insertion_point(field_release:optimization_guide.proto.AXAttribute.html_attribute_name)
    if (_internal_has_html_attribute_name()) {
        clear_has_attribute_key();
        return _impl_.attribute_key_.html_attribute_name_.Release();
    } else {
        return nullptr;
    }
}
inline void AXAttribute::set_allocated_html_attribute_name(std::string* html_attribute_name)
{
    if (has_attribute_key()) {
        clear_attribute_key();
    }
    if (html_attribute_name != nullptr) {
        set_has_html_attribute_name();
        _impl_.attribute_key_.html_attribute_name_.InitAllocated(html_attribute_name, GetArenaForAllocation());
    }
    // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.AXAttribute.html_attribute_name)
}

// string string_value = 8;
inline bool AXAttribute::_internal_has_string_value() const
{
    return attribute_value_case() == kStringValue;
}
inline bool AXAttribute::has_string_value() const
{
    return _internal_has_string_value();
}
inline void AXAttribute::set_has_string_value()
{
    _impl_._oneof_case_[1] = kStringValue;
}
inline void AXAttribute::clear_string_value()
{
    if (_internal_has_string_value()) {
        _impl_.attribute_value_.string_value_.Destroy();
        clear_has_attribute_value();
    }
}
inline const std::string& AXAttribute::string_value() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.AXAttribute.string_value)
    return _internal_string_value();
}
template <typename ArgT0, typename... ArgT> inline void AXAttribute::set_string_value(ArgT0&& arg0, ArgT... args)
{
    if (!_internal_has_string_value()) {
        clear_attribute_value();
        set_has_string_value();
        _impl_.attribute_value_.string_value_.InitDefault();
    }
    _impl_.attribute_value_.string_value_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:optimization_guide.proto.AXAttribute.string_value)
}
inline std::string* AXAttribute::mutable_string_value()
{
    std::string* _s = _internal_mutable_string_value();
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.AXAttribute.string_value)
    return _s;
}
inline const std::string& AXAttribute::_internal_string_value() const
{
    if (_internal_has_string_value()) {
        return _impl_.attribute_value_.string_value_.Get();
    }
    return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void AXAttribute::_internal_set_string_value(const std::string& value)
{
    if (!_internal_has_string_value()) {
        clear_attribute_value();
        set_has_string_value();
        _impl_.attribute_value_.string_value_.InitDefault();
    }
    _impl_.attribute_value_.string_value_.Set(value, GetArenaForAllocation());
}
inline std::string* AXAttribute::_internal_mutable_string_value()
{
    if (!_internal_has_string_value()) {
        clear_attribute_value();
        set_has_string_value();
        _impl_.attribute_value_.string_value_.InitDefault();
    }
    return _impl_.attribute_value_.string_value_.Mutable(GetArenaForAllocation());
}
inline std::string* AXAttribute::release_string_value()
{
    // @@protoc_insertion_point(field_release:optimization_guide.proto.AXAttribute.string_value)
    if (_internal_has_string_value()) {
        clear_has_attribute_value();
        return _impl_.attribute_value_.string_value_.Release();
    } else {
        return nullptr;
    }
}
inline void AXAttribute::set_allocated_string_value(std::string* string_value)
{
    if (has_attribute_value()) {
        clear_attribute_value();
    }
    if (string_value != nullptr) {
        set_has_string_value();
        _impl_.attribute_value_.string_value_.InitAllocated(string_value, GetArenaForAllocation());
    }
    // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.AXAttribute.string_value)
}

// int32 int_value = 9;
inline bool AXAttribute::_internal_has_int_value() const
{
    return attribute_value_case() == kIntValue;
}
inline bool AXAttribute::has_int_value() const
{
    return _internal_has_int_value();
}
inline void AXAttribute::set_has_int_value()
{
    _impl_._oneof_case_[1] = kIntValue;
}
inline void AXAttribute::clear_int_value()
{
    if (_internal_has_int_value()) {
        _impl_.attribute_value_.int_value_ = 0;
        clear_has_attribute_value();
    }
}
inline int32_t AXAttribute::_internal_int_value() const
{
    if (_internal_has_int_value()) {
        return _impl_.attribute_value_.int_value_;
    }
    return 0;
}
inline void AXAttribute::_internal_set_int_value(int32_t value)
{
    if (!_internal_has_int_value()) {
        clear_attribute_value();
        set_has_int_value();
    }
    _impl_.attribute_value_.int_value_ = value;
}
inline int32_t AXAttribute::int_value() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.AXAttribute.int_value)
    return _internal_int_value();
}
inline void AXAttribute::set_int_value(int32_t value)
{
    _internal_set_int_value(value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.AXAttribute.int_value)
}

// float float_value = 10;
inline bool AXAttribute::_internal_has_float_value() const
{
    return attribute_value_case() == kFloatValue;
}
inline bool AXAttribute::has_float_value() const
{
    return _internal_has_float_value();
}
inline void AXAttribute::set_has_float_value()
{
    _impl_._oneof_case_[1] = kFloatValue;
}
inline void AXAttribute::clear_float_value()
{
    if (_internal_has_float_value()) {
        _impl_.attribute_value_.float_value_ = 0;
        clear_has_attribute_value();
    }
}
inline float AXAttribute::_internal_float_value() const
{
    if (_internal_has_float_value()) {
        return _impl_.attribute_value_.float_value_;
    }
    return 0;
}
inline void AXAttribute::_internal_set_float_value(float value)
{
    if (!_internal_has_float_value()) {
        clear_attribute_value();
        set_has_float_value();
    }
    _impl_.attribute_value_.float_value_ = value;
}
inline float AXAttribute::float_value() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.AXAttribute.float_value)
    return _internal_float_value();
}
inline void AXAttribute::set_float_value(float value)
{
    _internal_set_float_value(value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.AXAttribute.float_value)
}

// bool bool_value = 11;
inline bool AXAttribute::_internal_has_bool_value() const
{
    return attribute_value_case() == kBoolValue;
}
inline bool AXAttribute::has_bool_value() const
{
    return _internal_has_bool_value();
}
inline void AXAttribute::set_has_bool_value()
{
    _impl_._oneof_case_[1] = kBoolValue;
}
inline void AXAttribute::clear_bool_value()
{
    if (_internal_has_bool_value()) {
        _impl_.attribute_value_.bool_value_ = false;
        clear_has_attribute_value();
    }
}
inline bool AXAttribute::_internal_bool_value() const
{
    if (_internal_has_bool_value()) {
        return _impl_.attribute_value_.bool_value_;
    }
    return false;
}
inline void AXAttribute::_internal_set_bool_value(bool value)
{
    if (!_internal_has_bool_value()) {
        clear_attribute_value();
        set_has_bool_value();
    }
    _impl_.attribute_value_.bool_value_ = value;
}
inline bool AXAttribute::bool_value() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.AXAttribute.bool_value)
    return _internal_bool_value();
}
inline void AXAttribute::set_bool_value(bool value)
{
    _internal_set_bool_value(value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.AXAttribute.bool_value)
}

// .optimization_guide.proto.AXIntList int_list_value = 12;
inline bool AXAttribute::_internal_has_int_list_value() const
{
    return attribute_value_case() == kIntListValue;
}
inline bool AXAttribute::has_int_list_value() const
{
    return _internal_has_int_list_value();
}
inline void AXAttribute::set_has_int_list_value()
{
    _impl_._oneof_case_[1] = kIntListValue;
}
inline void AXAttribute::clear_int_list_value()
{
    if (_internal_has_int_list_value()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.attribute_value_.int_list_value_;
        }
        clear_has_attribute_value();
    }
}
inline ::optimization_guide::proto::AXIntList* AXAttribute::release_int_list_value()
{
    // @@protoc_insertion_point(field_release:optimization_guide.proto.AXAttribute.int_list_value)
    if (_internal_has_int_list_value()) {
        clear_has_attribute_value();
        ::optimization_guide::proto::AXIntList* temp = _impl_.attribute_value_.int_list_value_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.attribute_value_.int_list_value_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::optimization_guide::proto::AXIntList& AXAttribute::_internal_int_list_value() const
{
    return _internal_has_int_list_value()
        ? *_impl_.attribute_value_.int_list_value_
        : reinterpret_cast<::optimization_guide::proto::AXIntList&>(::optimization_guide::proto::_AXIntList_default_instance_);
}
inline const ::optimization_guide::proto::AXIntList& AXAttribute::int_list_value() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.AXAttribute.int_list_value)
    return _internal_int_list_value();
}
inline ::optimization_guide::proto::AXIntList* AXAttribute::unsafe_arena_release_int_list_value()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:optimization_guide.proto.AXAttribute.int_list_value)
    if (_internal_has_int_list_value()) {
        clear_has_attribute_value();
        ::optimization_guide::proto::AXIntList* temp = _impl_.attribute_value_.int_list_value_;
        _impl_.attribute_value_.int_list_value_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void AXAttribute::unsafe_arena_set_allocated_int_list_value(::optimization_guide::proto::AXIntList* int_list_value)
{
    clear_attribute_value();
    if (int_list_value) {
        set_has_int_list_value();
        _impl_.attribute_value_.int_list_value_ = int_list_value;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:optimization_guide.proto.AXAttribute.int_list_value)
}
inline ::optimization_guide::proto::AXIntList* AXAttribute::_internal_mutable_int_list_value()
{
    if (!_internal_has_int_list_value()) {
        clear_attribute_value();
        set_has_int_list_value();
        _impl_.attribute_value_.int_list_value_ = CreateMaybeMessage<::optimization_guide::proto::AXIntList>(GetArenaForAllocation());
    }
    return _impl_.attribute_value_.int_list_value_;
}
inline ::optimization_guide::proto::AXIntList* AXAttribute::mutable_int_list_value()
{
    ::optimization_guide::proto::AXIntList* _msg = _internal_mutable_int_list_value();
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.AXAttribute.int_list_value)
    return _msg;
}

// .optimization_guide.proto.AXStringList string_list_value = 13;
inline bool AXAttribute::_internal_has_string_list_value() const
{
    return attribute_value_case() == kStringListValue;
}
inline bool AXAttribute::has_string_list_value() const
{
    return _internal_has_string_list_value();
}
inline void AXAttribute::set_has_string_list_value()
{
    _impl_._oneof_case_[1] = kStringListValue;
}
inline void AXAttribute::clear_string_list_value()
{
    if (_internal_has_string_list_value()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.attribute_value_.string_list_value_;
        }
        clear_has_attribute_value();
    }
}
inline ::optimization_guide::proto::AXStringList* AXAttribute::release_string_list_value()
{
    // @@protoc_insertion_point(field_release:optimization_guide.proto.AXAttribute.string_list_value)
    if (_internal_has_string_list_value()) {
        clear_has_attribute_value();
        ::optimization_guide::proto::AXStringList* temp = _impl_.attribute_value_.string_list_value_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.attribute_value_.string_list_value_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::optimization_guide::proto::AXStringList& AXAttribute::_internal_string_list_value() const
{
    return _internal_has_string_list_value()
        ? *_impl_.attribute_value_.string_list_value_
        : reinterpret_cast<::optimization_guide::proto::AXStringList&>(::optimization_guide::proto::_AXStringList_default_instance_);
}
inline const ::optimization_guide::proto::AXStringList& AXAttribute::string_list_value() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.AXAttribute.string_list_value)
    return _internal_string_list_value();
}
inline ::optimization_guide::proto::AXStringList* AXAttribute::unsafe_arena_release_string_list_value()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:optimization_guide.proto.AXAttribute.string_list_value)
    if (_internal_has_string_list_value()) {
        clear_has_attribute_value();
        ::optimization_guide::proto::AXStringList* temp = _impl_.attribute_value_.string_list_value_;
        _impl_.attribute_value_.string_list_value_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void AXAttribute::unsafe_arena_set_allocated_string_list_value(::optimization_guide::proto::AXStringList* string_list_value)
{
    clear_attribute_value();
    if (string_list_value) {
        set_has_string_list_value();
        _impl_.attribute_value_.string_list_value_ = string_list_value;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:optimization_guide.proto.AXAttribute.string_list_value)
}
inline ::optimization_guide::proto::AXStringList* AXAttribute::_internal_mutable_string_list_value()
{
    if (!_internal_has_string_list_value()) {
        clear_attribute_value();
        set_has_string_list_value();
        _impl_.attribute_value_.string_list_value_ = CreateMaybeMessage<::optimization_guide::proto::AXStringList>(GetArenaForAllocation());
    }
    return _impl_.attribute_value_.string_list_value_;
}
inline ::optimization_guide::proto::AXStringList* AXAttribute::mutable_string_list_value()
{
    ::optimization_guide::proto::AXStringList* _msg = _internal_mutable_string_list_value();
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.AXAttribute.string_list_value)
    return _msg;
}

// string html_attribute_value = 14;
inline bool AXAttribute::_internal_has_html_attribute_value() const
{
    return attribute_value_case() == kHtmlAttributeValue;
}
inline bool AXAttribute::has_html_attribute_value() const
{
    return _internal_has_html_attribute_value();
}
inline void AXAttribute::set_has_html_attribute_value()
{
    _impl_._oneof_case_[1] = kHtmlAttributeValue;
}
inline void AXAttribute::clear_html_attribute_value()
{
    if (_internal_has_html_attribute_value()) {
        _impl_.attribute_value_.html_attribute_value_.Destroy();
        clear_has_attribute_value();
    }
}
inline const std::string& AXAttribute::html_attribute_value() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.AXAttribute.html_attribute_value)
    return _internal_html_attribute_value();
}
template <typename ArgT0, typename... ArgT> inline void AXAttribute::set_html_attribute_value(ArgT0&& arg0, ArgT... args)
{
    if (!_internal_has_html_attribute_value()) {
        clear_attribute_value();
        set_has_html_attribute_value();
        _impl_.attribute_value_.html_attribute_value_.InitDefault();
    }
    _impl_.attribute_value_.html_attribute_value_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:optimization_guide.proto.AXAttribute.html_attribute_value)
}
inline std::string* AXAttribute::mutable_html_attribute_value()
{
    std::string* _s = _internal_mutable_html_attribute_value();
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.AXAttribute.html_attribute_value)
    return _s;
}
inline const std::string& AXAttribute::_internal_html_attribute_value() const
{
    if (_internal_has_html_attribute_value()) {
        return _impl_.attribute_value_.html_attribute_value_.Get();
    }
    return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void AXAttribute::_internal_set_html_attribute_value(const std::string& value)
{
    if (!_internal_has_html_attribute_value()) {
        clear_attribute_value();
        set_has_html_attribute_value();
        _impl_.attribute_value_.html_attribute_value_.InitDefault();
    }
    _impl_.attribute_value_.html_attribute_value_.Set(value, GetArenaForAllocation());
}
inline std::string* AXAttribute::_internal_mutable_html_attribute_value()
{
    if (!_internal_has_html_attribute_value()) {
        clear_attribute_value();
        set_has_html_attribute_value();
        _impl_.attribute_value_.html_attribute_value_.InitDefault();
    }
    return _impl_.attribute_value_.html_attribute_value_.Mutable(GetArenaForAllocation());
}
inline std::string* AXAttribute::release_html_attribute_value()
{
    // @@protoc_insertion_point(field_release:optimization_guide.proto.AXAttribute.html_attribute_value)
    if (_internal_has_html_attribute_value()) {
        clear_has_attribute_value();
        return _impl_.attribute_value_.html_attribute_value_.Release();
    } else {
        return nullptr;
    }
}
inline void AXAttribute::set_allocated_html_attribute_value(std::string* html_attribute_value)
{
    if (has_attribute_value()) {
        clear_attribute_value();
    }
    if (html_attribute_value != nullptr) {
        set_has_html_attribute_value();
        _impl_.attribute_value_.html_attribute_value_.InitAllocated(html_attribute_value, GetArenaForAllocation());
    }
    // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.AXAttribute.html_attribute_value)
}

inline bool AXAttribute::has_attribute_key() const
{
    return attribute_key_case() != ATTRIBUTE_KEY_NOT_SET;
}
inline void AXAttribute::clear_has_attribute_key()
{
    _impl_._oneof_case_[0] = ATTRIBUTE_KEY_NOT_SET;
}
inline bool AXAttribute::has_attribute_value() const
{
    return attribute_value_case() != ATTRIBUTE_VALUE_NOT_SET;
}
inline void AXAttribute::clear_has_attribute_value()
{
    _impl_._oneof_case_[1] = ATTRIBUTE_VALUE_NOT_SET;
}
inline AXAttribute::AttributeKeyCase AXAttribute::attribute_key_case() const
{
    return AXAttribute::AttributeKeyCase(_impl_._oneof_case_[0]);
}
inline AXAttribute::AttributeValueCase AXAttribute::attribute_value_case() const
{
    return AXAttribute::AttributeValueCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// AXIntList

// repeated int32 value = 1;
inline int AXIntList::_internal_value_size() const
{
    return _impl_.value_.size();
}
inline int AXIntList::value_size() const
{
    return _internal_value_size();
}
inline void AXIntList::clear_value()
{
    _impl_.value_.Clear();
}
inline int32_t AXIntList::_internal_value(int index) const
{
    return _impl_.value_.Get(index);
}
inline int32_t AXIntList::value(int index) const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.AXIntList.value)
    return _internal_value(index);
}
inline void AXIntList::set_value(int index, int32_t value)
{
    _impl_.value_.Set(index, value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.AXIntList.value)
}
inline void AXIntList::_internal_add_value(int32_t value)
{
    _impl_.value_.Add(value);
}
inline void AXIntList::add_value(int32_t value)
{
    _internal_add_value(value);
    // @@protoc_insertion_point(field_add:optimization_guide.proto.AXIntList.value)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>& AXIntList::_internal_value() const
{
    return _impl_.value_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>& AXIntList::value() const
{
    // @@protoc_insertion_point(field_list:optimization_guide.proto.AXIntList.value)
    return _internal_value();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>* AXIntList::_internal_mutable_value()
{
    return &_impl_.value_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>* AXIntList::mutable_value()
{
    // @@protoc_insertion_point(field_mutable_list:optimization_guide.proto.AXIntList.value)
    return _internal_mutable_value();
}

// -------------------------------------------------------------------

// AXStringList

// repeated string value = 1;
inline int AXStringList::_internal_value_size() const
{
    return _impl_.value_.size();
}
inline int AXStringList::value_size() const
{
    return _internal_value_size();
}
inline void AXStringList::clear_value()
{
    _impl_.value_.Clear();
}
inline std::string* AXStringList::add_value()
{
    std::string* _s = _internal_add_value();
    // @@protoc_insertion_point(field_add_mutable:optimization_guide.proto.AXStringList.value)
    return _s;
}
inline const std::string& AXStringList::_internal_value(int index) const
{
    return _impl_.value_.Get(index);
}
inline const std::string& AXStringList::value(int index) const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.AXStringList.value)
    return _internal_value(index);
}
inline std::string* AXStringList::mutable_value(int index)
{
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.AXStringList.value)
    return _impl_.value_.Mutable(index);
}
inline void AXStringList::set_value(int index, const std::string& value)
{
    _impl_.value_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.AXStringList.value)
}
inline void AXStringList::set_value(int index, std::string&& value)
{
    _impl_.value_.Mutable(index)->assign(std::move(value));
    // @@protoc_insertion_point(field_set:optimization_guide.proto.AXStringList.value)
}
inline void AXStringList::set_value(int index, const char* value)
{
    GOOGLE_DCHECK(value != nullptr);
    _impl_.value_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set_char:optimization_guide.proto.AXStringList.value)
}
inline void AXStringList::set_value(int index, const char* value, size_t size)
{
    _impl_.value_.Mutable(index)->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:optimization_guide.proto.AXStringList.value)
}
inline std::string* AXStringList::_internal_add_value()
{
    return _impl_.value_.Add();
}
inline void AXStringList::add_value(const std::string& value)
{
    _impl_.value_.Add()->assign(value);
    // @@protoc_insertion_point(field_add:optimization_guide.proto.AXStringList.value)
}
inline void AXStringList::add_value(std::string&& value)
{
    _impl_.value_.Add(std::move(value));
    // @@protoc_insertion_point(field_add:optimization_guide.proto.AXStringList.value)
}
inline void AXStringList::add_value(const char* value)
{
    GOOGLE_DCHECK(value != nullptr);
    _impl_.value_.Add()->assign(value);
    // @@protoc_insertion_point(field_add_char:optimization_guide.proto.AXStringList.value)
}
inline void AXStringList::add_value(const char* value, size_t size)
{
    _impl_.value_.Add()->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_add_pointer:optimization_guide.proto.AXStringList.value)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& AXStringList::value() const
{
    // @@protoc_insertion_point(field_list:optimization_guide.proto.AXStringList.value)
    return _impl_.value_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* AXStringList::mutable_value()
{
    // @@protoc_insertion_point(field_mutable_list:optimization_guide.proto.AXStringList.value)
    return &_impl_.value_;
}

// -------------------------------------------------------------------

// AXRelativeBounds

// int32 offset_container_id = 1;
inline void AXRelativeBounds::clear_offset_container_id()
{
    _impl_.offset_container_id_ = 0;
}
inline int32_t AXRelativeBounds::_internal_offset_container_id() const
{
    return _impl_.offset_container_id_;
}
inline int32_t AXRelativeBounds::offset_container_id() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.AXRelativeBounds.offset_container_id)
    return _internal_offset_container_id();
}
inline void AXRelativeBounds::_internal_set_offset_container_id(int32_t value)
{

    _impl_.offset_container_id_ = value;
}
inline void AXRelativeBounds::set_offset_container_id(int32_t value)
{
    _internal_set_offset_container_id(value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.AXRelativeBounds.offset_container_id)
}

// float x = 2;
inline void AXRelativeBounds::clear_x()
{
    _impl_.x_ = 0;
}
inline float AXRelativeBounds::_internal_x() const
{
    return _impl_.x_;
}
inline float AXRelativeBounds::x() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.AXRelativeBounds.x)
    return _internal_x();
}
inline void AXRelativeBounds::_internal_set_x(float value)
{

    _impl_.x_ = value;
}
inline void AXRelativeBounds::set_x(float value)
{
    _internal_set_x(value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.AXRelativeBounds.x)
}

// float y = 3;
inline void AXRelativeBounds::clear_y()
{
    _impl_.y_ = 0;
}
inline float AXRelativeBounds::_internal_y() const
{
    return _impl_.y_;
}
inline float AXRelativeBounds::y() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.AXRelativeBounds.y)
    return _internal_y();
}
inline void AXRelativeBounds::_internal_set_y(float value)
{

    _impl_.y_ = value;
}
inline void AXRelativeBounds::set_y(float value)
{
    _internal_set_y(value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.AXRelativeBounds.y)
}

// float width = 4;
inline void AXRelativeBounds::clear_width()
{
    _impl_.width_ = 0;
}
inline float AXRelativeBounds::_internal_width() const
{
    return _impl_.width_;
}
inline float AXRelativeBounds::width() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.AXRelativeBounds.width)
    return _internal_width();
}
inline void AXRelativeBounds::_internal_set_width(float value)
{

    _impl_.width_ = value;
}
inline void AXRelativeBounds::set_width(float value)
{
    _internal_set_width(value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.AXRelativeBounds.width)
}

// float height = 5;
inline void AXRelativeBounds::clear_height()
{
    _impl_.height_ = 0;
}
inline float AXRelativeBounds::_internal_height() const
{
    return _impl_.height_;
}
inline float AXRelativeBounds::height() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.AXRelativeBounds.height)
    return _internal_height();
}
inline void AXRelativeBounds::_internal_set_height(float value)
{

    _impl_.height_ = value;
}
inline void AXRelativeBounds::set_height(float value)
{
    _internal_set_height(value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.AXRelativeBounds.height)
}

// repeated float transform = 6;
inline int AXRelativeBounds::_internal_transform_size() const
{
    return _impl_.transform_.size();
}
inline int AXRelativeBounds::transform_size() const
{
    return _internal_transform_size();
}
inline void AXRelativeBounds::clear_transform()
{
    _impl_.transform_.Clear();
}
inline float AXRelativeBounds::_internal_transform(int index) const
{
    return _impl_.transform_.Get(index);
}
inline float AXRelativeBounds::transform(int index) const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.AXRelativeBounds.transform)
    return _internal_transform(index);
}
inline void AXRelativeBounds::set_transform(int index, float value)
{
    _impl_.transform_.Set(index, value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.AXRelativeBounds.transform)
}
inline void AXRelativeBounds::_internal_add_transform(float value)
{
    _impl_.transform_.Add(value);
}
inline void AXRelativeBounds::add_transform(float value)
{
    _internal_add_transform(value);
    // @@protoc_insertion_point(field_add:optimization_guide.proto.AXRelativeBounds.transform)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<float>& AXRelativeBounds::_internal_transform() const
{
    return _impl_.transform_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<float>& AXRelativeBounds::transform() const
{
    // @@protoc_insertion_point(field_list:optimization_guide.proto.AXRelativeBounds.transform)
    return _internal_transform();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<float>* AXRelativeBounds::_internal_mutable_transform()
{
    return &_impl_.transform_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<float>* AXRelativeBounds::mutable_transform()
{
    // @@protoc_insertion_point(field_mutable_list:optimization_guide.proto.AXRelativeBounds.transform)
    return _internal_mutable_transform();
}

// -------------------------------------------------------------------

// PageContext

// string url = 1;
inline void PageContext::clear_url()
{
    _impl_.url_.ClearToEmpty();
}
inline const std::string& PageContext::url() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.PageContext.url)
    return _internal_url();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void PageContext::set_url(ArgT0&& arg0, ArgT... args)
{

    _impl_.url_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:optimization_guide.proto.PageContext.url)
}
inline std::string* PageContext::mutable_url()
{
    std::string* _s = _internal_mutable_url();
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.PageContext.url)
    return _s;
}
inline const std::string& PageContext::_internal_url() const
{
    return _impl_.url_.Get();
}
inline void PageContext::_internal_set_url(const std::string& value)
{

    _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* PageContext::_internal_mutable_url()
{

    return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* PageContext::release_url()
{
    // @@protoc_insertion_point(field_release:optimization_guide.proto.PageContext.url)
    return _impl_.url_.Release();
}
inline void PageContext::set_allocated_url(std::string* url)
{
    if (url != nullptr) {

    } else {
    }
    _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.url_.IsDefault()) {
        _impl_.url_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.PageContext.url)
}

// string title = 2;
inline void PageContext::clear_title()
{
    _impl_.title_.ClearToEmpty();
}
inline const std::string& PageContext::title() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.PageContext.title)
    return _internal_title();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void PageContext::set_title(ArgT0&& arg0, ArgT... args)
{

    _impl_.title_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:optimization_guide.proto.PageContext.title)
}
inline std::string* PageContext::mutable_title()
{
    std::string* _s = _internal_mutable_title();
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.PageContext.title)
    return _s;
}
inline const std::string& PageContext::_internal_title() const
{
    return _impl_.title_.Get();
}
inline void PageContext::_internal_set_title(const std::string& value)
{

    _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* PageContext::_internal_mutable_title()
{

    return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* PageContext::release_title()
{
    // @@protoc_insertion_point(field_release:optimization_guide.proto.PageContext.title)
    return _impl_.title_.Release();
}
inline void PageContext::set_allocated_title(std::string* title)
{
    if (title != nullptr) {

    } else {
    }
    _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.title_.IsDefault()) {
        _impl_.title_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.PageContext.title)
}

// .optimization_guide.proto.AXTreeUpdate ax_tree_data = 3;
inline bool PageContext::_internal_has_ax_tree_data() const
{
    return this != internal_default_instance() && _impl_.ax_tree_data_ != nullptr;
}
inline bool PageContext::has_ax_tree_data() const
{
    return _internal_has_ax_tree_data();
}
inline void PageContext::clear_ax_tree_data()
{
    if (GetArenaForAllocation() == nullptr && _impl_.ax_tree_data_ != nullptr) {
        delete _impl_.ax_tree_data_;
    }
    _impl_.ax_tree_data_ = nullptr;
}
inline const ::optimization_guide::proto::AXTreeUpdate& PageContext::_internal_ax_tree_data() const
{
    const ::optimization_guide::proto::AXTreeUpdate* p = _impl_.ax_tree_data_;
    return p != nullptr ? *p : reinterpret_cast<const ::optimization_guide::proto::AXTreeUpdate&>(::optimization_guide::proto::_AXTreeUpdate_default_instance_);
}
inline const ::optimization_guide::proto::AXTreeUpdate& PageContext::ax_tree_data() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.PageContext.ax_tree_data)
    return _internal_ax_tree_data();
}
inline void PageContext::unsafe_arena_set_allocated_ax_tree_data(::optimization_guide::proto::AXTreeUpdate* ax_tree_data)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ax_tree_data_);
    }
    _impl_.ax_tree_data_ = ax_tree_data;
    if (ax_tree_data) {

    } else {
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:optimization_guide.proto.PageContext.ax_tree_data)
}
inline ::optimization_guide::proto::AXTreeUpdate* PageContext::release_ax_tree_data()
{

    ::optimization_guide::proto::AXTreeUpdate* temp = _impl_.ax_tree_data_;
    _impl_.ax_tree_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::optimization_guide::proto::AXTreeUpdate* PageContext::unsafe_arena_release_ax_tree_data()
{
    // @@protoc_insertion_point(field_release:optimization_guide.proto.PageContext.ax_tree_data)

    ::optimization_guide::proto::AXTreeUpdate* temp = _impl_.ax_tree_data_;
    _impl_.ax_tree_data_ = nullptr;
    return temp;
}
inline ::optimization_guide::proto::AXTreeUpdate* PageContext::_internal_mutable_ax_tree_data()
{

    if (_impl_.ax_tree_data_ == nullptr) {
        auto* p = CreateMaybeMessage<::optimization_guide::proto::AXTreeUpdate>(GetArenaForAllocation());
        _impl_.ax_tree_data_ = p;
    }
    return _impl_.ax_tree_data_;
}
inline ::optimization_guide::proto::AXTreeUpdate* PageContext::mutable_ax_tree_data()
{
    ::optimization_guide::proto::AXTreeUpdate* _msg = _internal_mutable_ax_tree_data();
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.PageContext.ax_tree_data)
    return _msg;
}
inline void PageContext::set_allocated_ax_tree_data(::optimization_guide::proto::AXTreeUpdate* ax_tree_data)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.ax_tree_data_;
    }
    if (ax_tree_data) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ax_tree_data);
        if (message_arena != submessage_arena) {
            ax_tree_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, ax_tree_data, submessage_arena);
        }

    } else {
    }
    _impl_.ax_tree_data_ = ax_tree_data;
    // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.PageContext.ax_tree_data)
}

// string inner_text = 4;
inline void PageContext::clear_inner_text()
{
    _impl_.inner_text_.ClearToEmpty();
}
inline const std::string& PageContext::inner_text() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.PageContext.inner_text)
    return _internal_inner_text();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void PageContext::set_inner_text(ArgT0&& arg0, ArgT... args)
{

    _impl_.inner_text_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:optimization_guide.proto.PageContext.inner_text)
}
inline std::string* PageContext::mutable_inner_text()
{
    std::string* _s = _internal_mutable_inner_text();
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.PageContext.inner_text)
    return _s;
}
inline const std::string& PageContext::_internal_inner_text() const
{
    return _impl_.inner_text_.Get();
}
inline void PageContext::_internal_set_inner_text(const std::string& value)
{

    _impl_.inner_text_.Set(value, GetArenaForAllocation());
}
inline std::string* PageContext::_internal_mutable_inner_text()
{

    return _impl_.inner_text_.Mutable(GetArenaForAllocation());
}
inline std::string* PageContext::release_inner_text()
{
    // @@protoc_insertion_point(field_release:optimization_guide.proto.PageContext.inner_text)
    return _impl_.inner_text_.Release();
}
inline void PageContext::set_allocated_inner_text(std::string* inner_text)
{
    if (inner_text != nullptr) {

    } else {
    }
    _impl_.inner_text_.SetAllocated(inner_text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.inner_text_.IsDefault()) {
        _impl_.inner_text_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.PageContext.inner_text)
}

// uint64 inner_text_offset = 5;
inline void PageContext::clear_inner_text_offset()
{
    _impl_.inner_text_offset_ = uint64_t { 0u };
}
inline uint64_t PageContext::_internal_inner_text_offset() const
{
    return _impl_.inner_text_offset_;
}
inline uint64_t PageContext::inner_text_offset() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.PageContext.inner_text_offset)
    return _internal_inner_text_offset();
}
inline void PageContext::_internal_set_inner_text_offset(uint64_t value)
{

    _impl_.inner_text_offset_ = value;
}
inline void PageContext::set_inner_text_offset(uint64_t value)
{
    _internal_set_inner_text_offset(value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.PageContext.inner_text_offset)
}

// string tab_screenshot = 6;
inline void PageContext::clear_tab_screenshot()
{
    _impl_.tab_screenshot_.ClearToEmpty();
}
inline const std::string& PageContext::tab_screenshot() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.PageContext.tab_screenshot)
    return _internal_tab_screenshot();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void PageContext::set_tab_screenshot(ArgT0&& arg0, ArgT... args)
{

    _impl_.tab_screenshot_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:optimization_guide.proto.PageContext.tab_screenshot)
}
inline std::string* PageContext::mutable_tab_screenshot()
{
    std::string* _s = _internal_mutable_tab_screenshot();
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.PageContext.tab_screenshot)
    return _s;
}
inline const std::string& PageContext::_internal_tab_screenshot() const
{
    return _impl_.tab_screenshot_.Get();
}
inline void PageContext::_internal_set_tab_screenshot(const std::string& value)
{

    _impl_.tab_screenshot_.Set(value, GetArenaForAllocation());
}
inline std::string* PageContext::_internal_mutable_tab_screenshot()
{

    return _impl_.tab_screenshot_.Mutable(GetArenaForAllocation());
}
inline std::string* PageContext::release_tab_screenshot()
{
    // @@protoc_insertion_point(field_release:optimization_guide.proto.PageContext.tab_screenshot)
    return _impl_.tab_screenshot_.Release();
}
inline void PageContext::set_allocated_tab_screenshot(std::string* tab_screenshot)
{
    if (tab_screenshot != nullptr) {

    } else {
    }
    _impl_.tab_screenshot_.SetAllocated(tab_screenshot, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.tab_screenshot_.IsDefault()) {
        _impl_.tab_screenshot_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.PageContext.tab_screenshot)
}

// string pdf_data = 7;
inline void PageContext::clear_pdf_data()
{
    _impl_.pdf_data_.ClearToEmpty();
}
inline const std::string& PageContext::pdf_data() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.PageContext.pdf_data)
    return _internal_pdf_data();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void PageContext::set_pdf_data(ArgT0&& arg0, ArgT... args)
{

    _impl_.pdf_data_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:optimization_guide.proto.PageContext.pdf_data)
}
inline std::string* PageContext::mutable_pdf_data()
{
    std::string* _s = _internal_mutable_pdf_data();
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.PageContext.pdf_data)
    return _s;
}
inline const std::string& PageContext::_internal_pdf_data() const
{
    return _impl_.pdf_data_.Get();
}
inline void PageContext::_internal_set_pdf_data(const std::string& value)
{

    _impl_.pdf_data_.Set(value, GetArenaForAllocation());
}
inline std::string* PageContext::_internal_mutable_pdf_data()
{

    return _impl_.pdf_data_.Mutable(GetArenaForAllocation());
}
inline std::string* PageContext::release_pdf_data()
{
    // @@protoc_insertion_point(field_release:optimization_guide.proto.PageContext.pdf_data)
    return _impl_.pdf_data_.Release();
}
inline void PageContext::set_allocated_pdf_data(std::string* pdf_data)
{
    if (pdf_data != nullptr) {

    } else {
    }
    _impl_.pdf_data_.SetAllocated(pdf_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.pdf_data_.IsDefault()) {
        _impl_.pdf_data_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.PageContext.pdf_data)
}

// -------------------------------------------------------------------

// FormData

// string form_name = 1;
inline void FormData::clear_form_name()
{
    _impl_.form_name_.ClearToEmpty();
}
inline const std::string& FormData::form_name() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.FormData.form_name)
    return _internal_form_name();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void FormData::set_form_name(ArgT0&& arg0, ArgT... args)
{

    _impl_.form_name_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:optimization_guide.proto.FormData.form_name)
}
inline std::string* FormData::mutable_form_name()
{
    std::string* _s = _internal_mutable_form_name();
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.FormData.form_name)
    return _s;
}
inline const std::string& FormData::_internal_form_name() const
{
    return _impl_.form_name_.Get();
}
inline void FormData::_internal_set_form_name(const std::string& value)
{

    _impl_.form_name_.Set(value, GetArenaForAllocation());
}
inline std::string* FormData::_internal_mutable_form_name()
{

    return _impl_.form_name_.Mutable(GetArenaForAllocation());
}
inline std::string* FormData::release_form_name()
{
    // @@protoc_insertion_point(field_release:optimization_guide.proto.FormData.form_name)
    return _impl_.form_name_.Release();
}
inline void FormData::set_allocated_form_name(std::string* form_name)
{
    if (form_name != nullptr) {

    } else {
    }
    _impl_.form_name_.SetAllocated(form_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.form_name_.IsDefault()) {
        _impl_.form_name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.FormData.form_name)
}

// repeated .optimization_guide.proto.FormFieldData fields = 2;
inline int FormData::_internal_fields_size() const
{
    return _impl_.fields_.size();
}
inline int FormData::fields_size() const
{
    return _internal_fields_size();
}
inline void FormData::clear_fields()
{
    _impl_.fields_.Clear();
}
inline ::optimization_guide::proto::FormFieldData* FormData::mutable_fields(int index)
{
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.FormData.fields)
    return _impl_.fields_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::FormFieldData>* FormData::mutable_fields()
{
    // @@protoc_insertion_point(field_mutable_list:optimization_guide.proto.FormData.fields)
    return &_impl_.fields_;
}
inline const ::optimization_guide::proto::FormFieldData& FormData::_internal_fields(int index) const
{
    return _impl_.fields_.Get(index);
}
inline const ::optimization_guide::proto::FormFieldData& FormData::fields(int index) const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.FormData.fields)
    return _internal_fields(index);
}
inline ::optimization_guide::proto::FormFieldData* FormData::_internal_add_fields()
{
    return _impl_.fields_.Add();
}
inline ::optimization_guide::proto::FormFieldData* FormData::add_fields()
{
    ::optimization_guide::proto::FormFieldData* _add = _internal_add_fields();
    // @@protoc_insertion_point(field_add:optimization_guide.proto.FormData.fields)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::FormFieldData>& FormData::fields() const
{
    // @@protoc_insertion_point(field_list:optimization_guide.proto.FormData.fields)
    return _impl_.fields_;
}

// -------------------------------------------------------------------

// FormFieldData

// string field_name = 1;
inline void FormFieldData::clear_field_name()
{
    _impl_.field_name_.ClearToEmpty();
}
inline const std::string& FormFieldData::field_name() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.FormFieldData.field_name)
    return _internal_field_name();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void FormFieldData::set_field_name(ArgT0&& arg0, ArgT... args)
{

    _impl_.field_name_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:optimization_guide.proto.FormFieldData.field_name)
}
inline std::string* FormFieldData::mutable_field_name()
{
    std::string* _s = _internal_mutable_field_name();
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.FormFieldData.field_name)
    return _s;
}
inline const std::string& FormFieldData::_internal_field_name() const
{
    return _impl_.field_name_.Get();
}
inline void FormFieldData::_internal_set_field_name(const std::string& value)
{

    _impl_.field_name_.Set(value, GetArenaForAllocation());
}
inline std::string* FormFieldData::_internal_mutable_field_name()
{

    return _impl_.field_name_.Mutable(GetArenaForAllocation());
}
inline std::string* FormFieldData::release_field_name()
{
    // @@protoc_insertion_point(field_release:optimization_guide.proto.FormFieldData.field_name)
    return _impl_.field_name_.Release();
}
inline void FormFieldData::set_allocated_field_name(std::string* field_name)
{
    if (field_name != nullptr) {

    } else {
    }
    _impl_.field_name_.SetAllocated(field_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.field_name_.IsDefault()) {
        _impl_.field_name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.FormFieldData.field_name)
}

// string field_label = 2;
inline void FormFieldData::clear_field_label()
{
    _impl_.field_label_.ClearToEmpty();
}
inline const std::string& FormFieldData::field_label() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.FormFieldData.field_label)
    return _internal_field_label();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void FormFieldData::set_field_label(ArgT0&& arg0, ArgT... args)
{

    _impl_.field_label_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:optimization_guide.proto.FormFieldData.field_label)
}
inline std::string* FormFieldData::mutable_field_label()
{
    std::string* _s = _internal_mutable_field_label();
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.FormFieldData.field_label)
    return _s;
}
inline const std::string& FormFieldData::_internal_field_label() const
{
    return _impl_.field_label_.Get();
}
inline void FormFieldData::_internal_set_field_label(const std::string& value)
{

    _impl_.field_label_.Set(value, GetArenaForAllocation());
}
inline std::string* FormFieldData::_internal_mutable_field_label()
{

    return _impl_.field_label_.Mutable(GetArenaForAllocation());
}
inline std::string* FormFieldData::release_field_label()
{
    // @@protoc_insertion_point(field_release:optimization_guide.proto.FormFieldData.field_label)
    return _impl_.field_label_.Release();
}
inline void FormFieldData::set_allocated_field_label(std::string* field_label)
{
    if (field_label != nullptr) {

    } else {
    }
    _impl_.field_label_.SetAllocated(field_label, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.field_label_.IsDefault()) {
        _impl_.field_label_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.FormFieldData.field_label)
}

// string field_value = 3;
inline void FormFieldData::clear_field_value()
{
    _impl_.field_value_.ClearToEmpty();
}
inline const std::string& FormFieldData::field_value() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.FormFieldData.field_value)
    return _internal_field_value();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void FormFieldData::set_field_value(ArgT0&& arg0, ArgT... args)
{

    _impl_.field_value_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:optimization_guide.proto.FormFieldData.field_value)
}
inline std::string* FormFieldData::mutable_field_value()
{
    std::string* _s = _internal_mutable_field_value();
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.FormFieldData.field_value)
    return _s;
}
inline const std::string& FormFieldData::_internal_field_value() const
{
    return _impl_.field_value_.Get();
}
inline void FormFieldData::_internal_set_field_value(const std::string& value)
{

    _impl_.field_value_.Set(value, GetArenaForAllocation());
}
inline std::string* FormFieldData::_internal_mutable_field_value()
{

    return _impl_.field_value_.Mutable(GetArenaForAllocation());
}
inline std::string* FormFieldData::release_field_value()
{
    // @@protoc_insertion_point(field_release:optimization_guide.proto.FormFieldData.field_value)
    return _impl_.field_value_.Release();
}
inline void FormFieldData::set_allocated_field_value(std::string* field_value)
{
    if (field_value != nullptr) {

    } else {
    }
    _impl_.field_value_.SetAllocated(field_value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.field_value_.IsDefault()) {
        _impl_.field_value_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.FormFieldData.field_value)
}

// bool is_visible = 4;
inline void FormFieldData::clear_is_visible()
{
    _impl_.is_visible_ = false;
}
inline bool FormFieldData::_internal_is_visible() const
{
    return _impl_.is_visible_;
}
inline bool FormFieldData::is_visible() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.FormFieldData.is_visible)
    return _internal_is_visible();
}
inline void FormFieldData::_internal_set_is_visible(bool value)
{

    _impl_.is_visible_ = value;
}
inline void FormFieldData::set_is_visible(bool value)
{
    _internal_set_is_visible(value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.FormFieldData.is_visible)
}

// bool is_focusable = 5;
inline void FormFieldData::clear_is_focusable()
{
    _impl_.is_focusable_ = false;
}
inline bool FormFieldData::_internal_is_focusable() const
{
    return _impl_.is_focusable_;
}
inline bool FormFieldData::is_focusable() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.FormFieldData.is_focusable)
    return _internal_is_focusable();
}
inline void FormFieldData::_internal_set_is_focusable(bool value)
{

    _impl_.is_focusable_ = value;
}
inline void FormFieldData::set_is_focusable(bool value)
{
    _internal_set_is_focusable(value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.FormFieldData.is_focusable)
}

// .optimization_guide.proto.FormControlType form_control_type = 6;
inline void FormFieldData::clear_form_control_type()
{
    _impl_.form_control_type_ = 0;
}
inline ::optimization_guide::proto::FormControlType FormFieldData::_internal_form_control_type() const
{
    return static_cast<::optimization_guide::proto::FormControlType>(_impl_.form_control_type_);
}
inline ::optimization_guide::proto::FormControlType FormFieldData::form_control_type() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.FormFieldData.form_control_type)
    return _internal_form_control_type();
}
inline void FormFieldData::_internal_set_form_control_type(::optimization_guide::proto::FormControlType value)
{

    _impl_.form_control_type_ = value;
}
inline void FormFieldData::set_form_control_type(::optimization_guide::proto::FormControlType value)
{
    _internal_set_form_control_type(value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.FormFieldData.form_control_type)
}

// repeated .optimization_guide.proto.SelectOption select_options = 7;
inline int FormFieldData::_internal_select_options_size() const
{
    return _impl_.select_options_.size();
}
inline int FormFieldData::select_options_size() const
{
    return _internal_select_options_size();
}
inline void FormFieldData::clear_select_options()
{
    _impl_.select_options_.Clear();
}
inline ::optimization_guide::proto::SelectOption* FormFieldData::mutable_select_options(int index)
{
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.FormFieldData.select_options)
    return _impl_.select_options_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::SelectOption>* FormFieldData::mutable_select_options()
{
    // @@protoc_insertion_point(field_mutable_list:optimization_guide.proto.FormFieldData.select_options)
    return &_impl_.select_options_;
}
inline const ::optimization_guide::proto::SelectOption& FormFieldData::_internal_select_options(int index) const
{
    return _impl_.select_options_.Get(index);
}
inline const ::optimization_guide::proto::SelectOption& FormFieldData::select_options(int index) const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.FormFieldData.select_options)
    return _internal_select_options(index);
}
inline ::optimization_guide::proto::SelectOption* FormFieldData::_internal_add_select_options()
{
    return _impl_.select_options_.Add();
}
inline ::optimization_guide::proto::SelectOption* FormFieldData::add_select_options()
{
    ::optimization_guide::proto::SelectOption* _add = _internal_add_select_options();
    // @@protoc_insertion_point(field_add:optimization_guide.proto.FormFieldData.select_options)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::SelectOption>& FormFieldData::select_options() const
{
    // @@protoc_insertion_point(field_list:optimization_guide.proto.FormFieldData.select_options)
    return _impl_.select_options_;
}

// string placeholder = 8;
inline void FormFieldData::clear_placeholder()
{
    _impl_.placeholder_.ClearToEmpty();
}
inline const std::string& FormFieldData::placeholder() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.FormFieldData.placeholder)
    return _internal_placeholder();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void FormFieldData::set_placeholder(ArgT0&& arg0, ArgT... args)
{

    _impl_.placeholder_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:optimization_guide.proto.FormFieldData.placeholder)
}
inline std::string* FormFieldData::mutable_placeholder()
{
    std::string* _s = _internal_mutable_placeholder();
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.FormFieldData.placeholder)
    return _s;
}
inline const std::string& FormFieldData::_internal_placeholder() const
{
    return _impl_.placeholder_.Get();
}
inline void FormFieldData::_internal_set_placeholder(const std::string& value)
{

    _impl_.placeholder_.Set(value, GetArenaForAllocation());
}
inline std::string* FormFieldData::_internal_mutable_placeholder()
{

    return _impl_.placeholder_.Mutable(GetArenaForAllocation());
}
inline std::string* FormFieldData::release_placeholder()
{
    // @@protoc_insertion_point(field_release:optimization_guide.proto.FormFieldData.placeholder)
    return _impl_.placeholder_.Release();
}
inline void FormFieldData::set_allocated_placeholder(std::string* placeholder)
{
    if (placeholder != nullptr) {

    } else {
    }
    _impl_.placeholder_.SetAllocated(placeholder, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.placeholder_.IsDefault()) {
        _impl_.placeholder_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.FormFieldData.placeholder)
}

// int32 form_control_ax_node_id = 9;
inline void FormFieldData::clear_form_control_ax_node_id()
{
    _impl_.form_control_ax_node_id_ = 0;
}
inline int32_t FormFieldData::_internal_form_control_ax_node_id() const
{
    return _impl_.form_control_ax_node_id_;
}
inline int32_t FormFieldData::form_control_ax_node_id() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.FormFieldData.form_control_ax_node_id)
    return _internal_form_control_ax_node_id();
}
inline void FormFieldData::_internal_set_form_control_ax_node_id(int32_t value)
{

    _impl_.form_control_ax_node_id_ = value;
}
inline void FormFieldData::set_form_control_ax_node_id(int32_t value)
{
    _internal_set_form_control_ax_node_id(value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.FormFieldData.form_control_ax_node_id)
}

// bool is_eligible = 10;
inline void FormFieldData::clear_is_eligible()
{
    _impl_.is_eligible_ = false;
}
inline bool FormFieldData::_internal_is_eligible() const
{
    return _impl_.is_eligible_;
}
inline bool FormFieldData::is_eligible() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.FormFieldData.is_eligible)
    return _internal_is_eligible();
}
inline void FormFieldData::_internal_set_is_eligible(bool value)
{

    _impl_.is_eligible_ = value;
}
inline void FormFieldData::set_is_eligible(bool value)
{
    _internal_set_is_eligible(value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.FormFieldData.is_eligible)
}

// string global_id = 11;
inline void FormFieldData::clear_global_id()
{
    _impl_.global_id_.ClearToEmpty();
}
inline const std::string& FormFieldData::global_id() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.FormFieldData.global_id)
    return _internal_global_id();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void FormFieldData::set_global_id(ArgT0&& arg0, ArgT... args)
{

    _impl_.global_id_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:optimization_guide.proto.FormFieldData.global_id)
}
inline std::string* FormFieldData::mutable_global_id()
{
    std::string* _s = _internal_mutable_global_id();
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.FormFieldData.global_id)
    return _s;
}
inline const std::string& FormFieldData::_internal_global_id() const
{
    return _impl_.global_id_.Get();
}
inline void FormFieldData::_internal_set_global_id(const std::string& value)
{

    _impl_.global_id_.Set(value, GetArenaForAllocation());
}
inline std::string* FormFieldData::_internal_mutable_global_id()
{

    return _impl_.global_id_.Mutable(GetArenaForAllocation());
}
inline std::string* FormFieldData::release_global_id()
{
    // @@protoc_insertion_point(field_release:optimization_guide.proto.FormFieldData.global_id)
    return _impl_.global_id_.Release();
}
inline void FormFieldData::set_allocated_global_id(std::string* global_id)
{
    if (global_id != nullptr) {

    } else {
    }
    _impl_.global_id_.SetAllocated(global_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.global_id_.IsDefault()) {
        _impl_.global_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.FormFieldData.global_id)
}

// -------------------------------------------------------------------

// SelectOption

// string value = 1;
inline void SelectOption::clear_value()
{
    _impl_.value_.ClearToEmpty();
}
inline const std::string& SelectOption::value() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.SelectOption.value)
    return _internal_value();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void SelectOption::set_value(ArgT0&& arg0, ArgT... args)
{

    _impl_.value_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:optimization_guide.proto.SelectOption.value)
}
inline std::string* SelectOption::mutable_value()
{
    std::string* _s = _internal_mutable_value();
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.SelectOption.value)
    return _s;
}
inline const std::string& SelectOption::_internal_value() const
{
    return _impl_.value_.Get();
}
inline void SelectOption::_internal_set_value(const std::string& value)
{

    _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* SelectOption::_internal_mutable_value()
{

    return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* SelectOption::release_value()
{
    // @@protoc_insertion_point(field_release:optimization_guide.proto.SelectOption.value)
    return _impl_.value_.Release();
}
inline void SelectOption::set_allocated_value(std::string* value)
{
    if (value != nullptr) {

    } else {
    }
    _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.value_.IsDefault()) {
        _impl_.value_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.SelectOption.value)
}

// string text = 2;
inline void SelectOption::clear_text()
{
    _impl_.text_.ClearToEmpty();
}
inline const std::string& SelectOption::text() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.SelectOption.text)
    return _internal_text();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void SelectOption::set_text(ArgT0&& arg0, ArgT... args)
{

    _impl_.text_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:optimization_guide.proto.SelectOption.text)
}
inline std::string* SelectOption::mutable_text()
{
    std::string* _s = _internal_mutable_text();
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.SelectOption.text)
    return _s;
}
inline const std::string& SelectOption::_internal_text() const
{
    return _impl_.text_.Get();
}
inline void SelectOption::_internal_set_text(const std::string& value)
{

    _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* SelectOption::_internal_mutable_text()
{

    return _impl_.text_.Mutable(GetArenaForAllocation());
}
inline std::string* SelectOption::release_text()
{
    // @@protoc_insertion_point(field_release:optimization_guide.proto.SelectOption.text)
    return _impl_.text_.Release();
}
inline void SelectOption::set_allocated_text(std::string* text)
{
    if (text != nullptr) {

    } else {
    }
    _impl_.text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.text_.IsDefault()) {
        _impl_.text_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.SelectOption.text)
}

// -------------------------------------------------------------------

// UserAnnotationsEntry

// int64 entry_id = 1;
inline void UserAnnotationsEntry::clear_entry_id()
{
    _impl_.entry_id_ = int64_t { 0 };
}
inline int64_t UserAnnotationsEntry::_internal_entry_id() const
{
    return _impl_.entry_id_;
}
inline int64_t UserAnnotationsEntry::entry_id() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.UserAnnotationsEntry.entry_id)
    return _internal_entry_id();
}
inline void UserAnnotationsEntry::_internal_set_entry_id(int64_t value)
{

    _impl_.entry_id_ = value;
}
inline void UserAnnotationsEntry::set_entry_id(int64_t value)
{
    _internal_set_entry_id(value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.UserAnnotationsEntry.entry_id)
}

// string key = 2;
inline void UserAnnotationsEntry::clear_key()
{
    _impl_.key_.ClearToEmpty();
}
inline const std::string& UserAnnotationsEntry::key() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.UserAnnotationsEntry.key)
    return _internal_key();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void UserAnnotationsEntry::set_key(ArgT0&& arg0, ArgT... args)
{

    _impl_.key_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:optimization_guide.proto.UserAnnotationsEntry.key)
}
inline std::string* UserAnnotationsEntry::mutable_key()
{
    std::string* _s = _internal_mutable_key();
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.UserAnnotationsEntry.key)
    return _s;
}
inline const std::string& UserAnnotationsEntry::_internal_key() const
{
    return _impl_.key_.Get();
}
inline void UserAnnotationsEntry::_internal_set_key(const std::string& value)
{

    _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* UserAnnotationsEntry::_internal_mutable_key()
{

    return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* UserAnnotationsEntry::release_key()
{
    // @@protoc_insertion_point(field_release:optimization_guide.proto.UserAnnotationsEntry.key)
    return _impl_.key_.Release();
}
inline void UserAnnotationsEntry::set_allocated_key(std::string* key)
{
    if (key != nullptr) {

    } else {
    }
    _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.key_.IsDefault()) {
        _impl_.key_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.UserAnnotationsEntry.key)
}

// string value = 3;
inline void UserAnnotationsEntry::clear_value()
{
    _impl_.value_.ClearToEmpty();
}
inline const std::string& UserAnnotationsEntry::value() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.UserAnnotationsEntry.value)
    return _internal_value();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void UserAnnotationsEntry::set_value(ArgT0&& arg0, ArgT... args)
{

    _impl_.value_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:optimization_guide.proto.UserAnnotationsEntry.value)
}
inline std::string* UserAnnotationsEntry::mutable_value()
{
    std::string* _s = _internal_mutable_value();
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.UserAnnotationsEntry.value)
    return _s;
}
inline const std::string& UserAnnotationsEntry::_internal_value() const
{
    return _impl_.value_.Get();
}
inline void UserAnnotationsEntry::_internal_set_value(const std::string& value)
{

    _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* UserAnnotationsEntry::_internal_mutable_value()
{

    return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* UserAnnotationsEntry::release_value()
{
    // @@protoc_insertion_point(field_release:optimization_guide.proto.UserAnnotationsEntry.value)
    return _impl_.value_.Release();
}
inline void UserAnnotationsEntry::set_allocated_value(std::string* value)
{
    if (value != nullptr) {

    } else {
    }
    _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.value_.IsDefault()) {
        _impl_.value_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.UserAnnotationsEntry.value)
}

// -------------------------------------------------------------------

// TabGroup

// string label = 1;
inline void TabGroup::clear_label()
{
    _impl_.label_.ClearToEmpty();
}
inline const std::string& TabGroup::label() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.TabGroup.label)
    return _internal_label();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void TabGroup::set_label(ArgT0&& arg0, ArgT... args)
{

    _impl_.label_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:optimization_guide.proto.TabGroup.label)
}
inline std::string* TabGroup::mutable_label()
{
    std::string* _s = _internal_mutable_label();
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.TabGroup.label)
    return _s;
}
inline const std::string& TabGroup::_internal_label() const
{
    return _impl_.label_.Get();
}
inline void TabGroup::_internal_set_label(const std::string& value)
{

    _impl_.label_.Set(value, GetArenaForAllocation());
}
inline std::string* TabGroup::_internal_mutable_label()
{

    return _impl_.label_.Mutable(GetArenaForAllocation());
}
inline std::string* TabGroup::release_label()
{
    // @@protoc_insertion_point(field_release:optimization_guide.proto.TabGroup.label)
    return _impl_.label_.Release();
}
inline void TabGroup::set_allocated_label(std::string* label)
{
    if (label != nullptr) {

    } else {
    }
    _impl_.label_.SetAllocated(label, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.label_.IsDefault()) {
        _impl_.label_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.TabGroup.label)
}

// repeated .optimization_guide.proto.Tab tabs = 2;
inline int TabGroup::_internal_tabs_size() const
{
    return _impl_.tabs_.size();
}
inline int TabGroup::tabs_size() const
{
    return _internal_tabs_size();
}
inline void TabGroup::clear_tabs()
{
    _impl_.tabs_.Clear();
}
inline ::optimization_guide::proto::Tab* TabGroup::mutable_tabs(int index)
{
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.TabGroup.tabs)
    return _impl_.tabs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::Tab>* TabGroup::mutable_tabs()
{
    // @@protoc_insertion_point(field_mutable_list:optimization_guide.proto.TabGroup.tabs)
    return &_impl_.tabs_;
}
inline const ::optimization_guide::proto::Tab& TabGroup::_internal_tabs(int index) const
{
    return _impl_.tabs_.Get(index);
}
inline const ::optimization_guide::proto::Tab& TabGroup::tabs(int index) const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.TabGroup.tabs)
    return _internal_tabs(index);
}
inline ::optimization_guide::proto::Tab* TabGroup::_internal_add_tabs()
{
    return _impl_.tabs_.Add();
}
inline ::optimization_guide::proto::Tab* TabGroup::add_tabs()
{
    ::optimization_guide::proto::Tab* _add = _internal_add_tabs();
    // @@protoc_insertion_point(field_add:optimization_guide.proto.TabGroup.tabs)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::Tab>& TabGroup::tabs() const
{
    // @@protoc_insertion_point(field_list:optimization_guide.proto.TabGroup.tabs)
    return _impl_.tabs_;
}

// optional string group_id = 3;
inline bool TabGroup::_internal_has_group_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool TabGroup::has_group_id() const
{
    return _internal_has_group_id();
}
inline void TabGroup::clear_group_id()
{
    _impl_.group_id_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TabGroup::group_id() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.TabGroup.group_id)
    return _internal_group_id();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void TabGroup::set_group_id(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.group_id_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:optimization_guide.proto.TabGroup.group_id)
}
inline std::string* TabGroup::mutable_group_id()
{
    std::string* _s = _internal_mutable_group_id();
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.TabGroup.group_id)
    return _s;
}
inline const std::string& TabGroup::_internal_group_id() const
{
    return _impl_.group_id_.Get();
}
inline void TabGroup::_internal_set_group_id(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.group_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TabGroup::_internal_mutable_group_id()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.group_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TabGroup::release_group_id()
{
    // @@protoc_insertion_point(field_release:optimization_guide.proto.TabGroup.group_id)
    if (!_internal_has_group_id()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.group_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.group_id_.IsDefault()) {
        _impl_.group_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void TabGroup::set_allocated_group_id(std::string* group_id)
{
    if (group_id != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.group_id_.SetAllocated(group_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.group_id_.IsDefault()) {
        _impl_.group_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.TabGroup.group_id)
}

// -------------------------------------------------------------------

// Tab

// int64 tab_id = 1;
inline void Tab::clear_tab_id()
{
    _impl_.tab_id_ = int64_t { 0 };
}
inline int64_t Tab::_internal_tab_id() const
{
    return _impl_.tab_id_;
}
inline int64_t Tab::tab_id() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.Tab.tab_id)
    return _internal_tab_id();
}
inline void Tab::_internal_set_tab_id(int64_t value)
{

    _impl_.tab_id_ = value;
}
inline void Tab::set_tab_id(int64_t value)
{
    _internal_set_tab_id(value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.Tab.tab_id)
}

// string title = 2;
inline void Tab::clear_title()
{
    _impl_.title_.ClearToEmpty();
}
inline const std::string& Tab::title() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.Tab.title)
    return _internal_title();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void Tab::set_title(ArgT0&& arg0, ArgT... args)
{

    _impl_.title_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:optimization_guide.proto.Tab.title)
}
inline std::string* Tab::mutable_title()
{
    std::string* _s = _internal_mutable_title();
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.Tab.title)
    return _s;
}
inline const std::string& Tab::_internal_title() const
{
    return _impl_.title_.Get();
}
inline void Tab::_internal_set_title(const std::string& value)
{

    _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* Tab::_internal_mutable_title()
{

    return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* Tab::release_title()
{
    // @@protoc_insertion_point(field_release:optimization_guide.proto.Tab.title)
    return _impl_.title_.Release();
}
inline void Tab::set_allocated_title(std::string* title)
{
    if (title != nullptr) {

    } else {
    }
    _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.title_.IsDefault()) {
        _impl_.title_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.Tab.title)
}

// string url = 3;
inline void Tab::clear_url()
{
    _impl_.url_.ClearToEmpty();
}
inline const std::string& Tab::url() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.Tab.url)
    return _internal_url();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void Tab::set_url(ArgT0&& arg0, ArgT... args)
{

    _impl_.url_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:optimization_guide.proto.Tab.url)
}
inline std::string* Tab::mutable_url()
{
    std::string* _s = _internal_mutable_url();
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.Tab.url)
    return _s;
}
inline const std::string& Tab::_internal_url() const
{
    return _impl_.url_.Get();
}
inline void Tab::_internal_set_url(const std::string& value)
{

    _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* Tab::_internal_mutable_url()
{

    return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* Tab::release_url()
{
    // @@protoc_insertion_point(field_release:optimization_guide.proto.Tab.url)
    return _impl_.url_.Release();
}
inline void Tab::set_allocated_url(std::string* url)
{
    if (url != nullptr) {

    } else {
    }
    _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.url_.IsDefault()) {
        _impl_.url_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.Tab.url)
}

// .optimization_guide.proto.PageContext page_context = 4;
inline bool Tab::_internal_has_page_context() const
{
    return this != internal_default_instance() && _impl_.page_context_ != nullptr;
}
inline bool Tab::has_page_context() const
{
    return _internal_has_page_context();
}
inline void Tab::clear_page_context()
{
    if (GetArenaForAllocation() == nullptr && _impl_.page_context_ != nullptr) {
        delete _impl_.page_context_;
    }
    _impl_.page_context_ = nullptr;
}
inline const ::optimization_guide::proto::PageContext& Tab::_internal_page_context() const
{
    const ::optimization_guide::proto::PageContext* p = _impl_.page_context_;
    return p != nullptr ? *p : reinterpret_cast<const ::optimization_guide::proto::PageContext&>(::optimization_guide::proto::_PageContext_default_instance_);
}
inline const ::optimization_guide::proto::PageContext& Tab::page_context() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.Tab.page_context)
    return _internal_page_context();
}
inline void Tab::unsafe_arena_set_allocated_page_context(::optimization_guide::proto::PageContext* page_context)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.page_context_);
    }
    _impl_.page_context_ = page_context;
    if (page_context) {

    } else {
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:optimization_guide.proto.Tab.page_context)
}
inline ::optimization_guide::proto::PageContext* Tab::release_page_context()
{

    ::optimization_guide::proto::PageContext* temp = _impl_.page_context_;
    _impl_.page_context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::optimization_guide::proto::PageContext* Tab::unsafe_arena_release_page_context()
{
    // @@protoc_insertion_point(field_release:optimization_guide.proto.Tab.page_context)

    ::optimization_guide::proto::PageContext* temp = _impl_.page_context_;
    _impl_.page_context_ = nullptr;
    return temp;
}
inline ::optimization_guide::proto::PageContext* Tab::_internal_mutable_page_context()
{

    if (_impl_.page_context_ == nullptr) {
        auto* p = CreateMaybeMessage<::optimization_guide::proto::PageContext>(GetArenaForAllocation());
        _impl_.page_context_ = p;
    }
    return _impl_.page_context_;
}
inline ::optimization_guide::proto::PageContext* Tab::mutable_page_context()
{
    ::optimization_guide::proto::PageContext* _msg = _internal_mutable_page_context();
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.Tab.page_context)
    return _msg;
}
inline void Tab::set_allocated_page_context(::optimization_guide::proto::PageContext* page_context)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.page_context_;
    }
    if (page_context) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(page_context);
        if (message_arena != submessage_arena) {
            page_context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, page_context, submessage_arena);
        }

    } else {
    }
    _impl_.page_context_ = page_context;
    // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.Tab.page_context)
}

// -------------------------------------------------------------------

// SiteEngagementEntry

// string url = 1;
inline void SiteEngagementEntry::clear_url()
{
    _impl_.url_.ClearToEmpty();
}
inline const std::string& SiteEngagementEntry::url() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.SiteEngagementEntry.url)
    return _internal_url();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void SiteEngagementEntry::set_url(ArgT0&& arg0, ArgT... args)
{

    _impl_.url_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:optimization_guide.proto.SiteEngagementEntry.url)
}
inline std::string* SiteEngagementEntry::mutable_url()
{
    std::string* _s = _internal_mutable_url();
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.SiteEngagementEntry.url)
    return _s;
}
inline const std::string& SiteEngagementEntry::_internal_url() const
{
    return _impl_.url_.Get();
}
inline void SiteEngagementEntry::_internal_set_url(const std::string& value)
{

    _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* SiteEngagementEntry::_internal_mutable_url()
{

    return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* SiteEngagementEntry::release_url()
{
    // @@protoc_insertion_point(field_release:optimization_guide.proto.SiteEngagementEntry.url)
    return _impl_.url_.Release();
}
inline void SiteEngagementEntry::set_allocated_url(std::string* url)
{
    if (url != nullptr) {

    } else {
    }
    _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.url_.IsDefault()) {
        _impl_.url_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.SiteEngagementEntry.url)
}

// float score = 2;
inline void SiteEngagementEntry::clear_score()
{
    _impl_.score_ = 0;
}
inline float SiteEngagementEntry::_internal_score() const
{
    return _impl_.score_;
}
inline float SiteEngagementEntry::score() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.SiteEngagementEntry.score)
    return _internal_score();
}
inline void SiteEngagementEntry::_internal_set_score(float value)
{

    _impl_.score_ = value;
}
inline void SiteEngagementEntry::set_score(float value)
{
    _internal_set_score(value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.SiteEngagementEntry.score)
}

// -------------------------------------------------------------------

// SiteEngagement

// repeated .optimization_guide.proto.SiteEngagementEntry entries = 1;
inline int SiteEngagement::_internal_entries_size() const
{
    return _impl_.entries_.size();
}
inline int SiteEngagement::entries_size() const
{
    return _internal_entries_size();
}
inline void SiteEngagement::clear_entries()
{
    _impl_.entries_.Clear();
}
inline ::optimization_guide::proto::SiteEngagementEntry* SiteEngagement::mutable_entries(int index)
{
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.SiteEngagement.entries)
    return _impl_.entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::SiteEngagementEntry>* SiteEngagement::mutable_entries()
{
    // @@protoc_insertion_point(field_mutable_list:optimization_guide.proto.SiteEngagement.entries)
    return &_impl_.entries_;
}
inline const ::optimization_guide::proto::SiteEngagementEntry& SiteEngagement::_internal_entries(int index) const
{
    return _impl_.entries_.Get(index);
}
inline const ::optimization_guide::proto::SiteEngagementEntry& SiteEngagement::entries(int index) const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.SiteEngagement.entries)
    return _internal_entries(index);
}
inline ::optimization_guide::proto::SiteEngagementEntry* SiteEngagement::_internal_add_entries()
{
    return _impl_.entries_.Add();
}
inline ::optimization_guide::proto::SiteEngagementEntry* SiteEngagement::add_entries()
{
    ::optimization_guide::proto::SiteEngagementEntry* _add = _internal_add_entries();
    // @@protoc_insertion_point(field_add:optimization_guide.proto.SiteEngagement.entries)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::SiteEngagementEntry>& SiteEngagement::entries() const
{
    // @@protoc_insertion_point(field_list:optimization_guide.proto.SiteEngagement.entries)
    return _impl_.entries_;
}

// -------------------------------------------------------------------

// BrowserCollectedInformation

// .optimization_guide.proto.PageContext page_context = 1;
inline bool BrowserCollectedInformation::_internal_has_page_context() const
{
    return this != internal_default_instance() && _impl_.page_context_ != nullptr;
}
inline bool BrowserCollectedInformation::has_page_context() const
{
    return _internal_has_page_context();
}
inline void BrowserCollectedInformation::clear_page_context()
{
    if (GetArenaForAllocation() == nullptr && _impl_.page_context_ != nullptr) {
        delete _impl_.page_context_;
    }
    _impl_.page_context_ = nullptr;
}
inline const ::optimization_guide::proto::PageContext& BrowserCollectedInformation::_internal_page_context() const
{
    const ::optimization_guide::proto::PageContext* p = _impl_.page_context_;
    return p != nullptr ? *p : reinterpret_cast<const ::optimization_guide::proto::PageContext&>(::optimization_guide::proto::_PageContext_default_instance_);
}
inline const ::optimization_guide::proto::PageContext& BrowserCollectedInformation::page_context() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.BrowserCollectedInformation.page_context)
    return _internal_page_context();
}
inline void BrowserCollectedInformation::unsafe_arena_set_allocated_page_context(::optimization_guide::proto::PageContext* page_context)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.page_context_);
    }
    _impl_.page_context_ = page_context;
    if (page_context) {

    } else {
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:optimization_guide.proto.BrowserCollectedInformation.page_context)
}
inline ::optimization_guide::proto::PageContext* BrowserCollectedInformation::release_page_context()
{

    ::optimization_guide::proto::PageContext* temp = _impl_.page_context_;
    _impl_.page_context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::optimization_guide::proto::PageContext* BrowserCollectedInformation::unsafe_arena_release_page_context()
{
    // @@protoc_insertion_point(field_release:optimization_guide.proto.BrowserCollectedInformation.page_context)

    ::optimization_guide::proto::PageContext* temp = _impl_.page_context_;
    _impl_.page_context_ = nullptr;
    return temp;
}
inline ::optimization_guide::proto::PageContext* BrowserCollectedInformation::_internal_mutable_page_context()
{

    if (_impl_.page_context_ == nullptr) {
        auto* p = CreateMaybeMessage<::optimization_guide::proto::PageContext>(GetArenaForAllocation());
        _impl_.page_context_ = p;
    }
    return _impl_.page_context_;
}
inline ::optimization_guide::proto::PageContext* BrowserCollectedInformation::mutable_page_context()
{
    ::optimization_guide::proto::PageContext* _msg = _internal_mutable_page_context();
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.BrowserCollectedInformation.page_context)
    return _msg;
}
inline void BrowserCollectedInformation::set_allocated_page_context(::optimization_guide::proto::PageContext* page_context)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.page_context_;
    }
    if (page_context) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(page_context);
        if (message_arena != submessage_arena) {
            page_context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, page_context, submessage_arena);
        }

    } else {
    }
    _impl_.page_context_ = page_context;
    // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.BrowserCollectedInformation.page_context)
}

// string inner_text = 2;
inline void BrowserCollectedInformation::clear_inner_text()
{
    _impl_.inner_text_.ClearToEmpty();
}
inline const std::string& BrowserCollectedInformation::inner_text() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.BrowserCollectedInformation.inner_text)
    return _internal_inner_text();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void BrowserCollectedInformation::set_inner_text(ArgT0&& arg0, ArgT... args)
{

    _impl_.inner_text_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:optimization_guide.proto.BrowserCollectedInformation.inner_text)
}
inline std::string* BrowserCollectedInformation::mutable_inner_text()
{
    std::string* _s = _internal_mutable_inner_text();
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.BrowserCollectedInformation.inner_text)
    return _s;
}
inline const std::string& BrowserCollectedInformation::_internal_inner_text() const
{
    return _impl_.inner_text_.Get();
}
inline void BrowserCollectedInformation::_internal_set_inner_text(const std::string& value)
{

    _impl_.inner_text_.Set(value, GetArenaForAllocation());
}
inline std::string* BrowserCollectedInformation::_internal_mutable_inner_text()
{

    return _impl_.inner_text_.Mutable(GetArenaForAllocation());
}
inline std::string* BrowserCollectedInformation::release_inner_text()
{
    // @@protoc_insertion_point(field_release:optimization_guide.proto.BrowserCollectedInformation.inner_text)
    return _impl_.inner_text_.Release();
}
inline void BrowserCollectedInformation::set_allocated_inner_text(std::string* inner_text)
{
    if (inner_text != nullptr) {

    } else {
    }
    _impl_.inner_text_.SetAllocated(inner_text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.inner_text_.IsDefault()) {
        _impl_.inner_text_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.BrowserCollectedInformation.inner_text)
}

// uint64 inner_text_offset = 3;
inline void BrowserCollectedInformation::clear_inner_text_offset()
{
    _impl_.inner_text_offset_ = uint64_t { 0u };
}
inline uint64_t BrowserCollectedInformation::_internal_inner_text_offset() const
{
    return _impl_.inner_text_offset_;
}
inline uint64_t BrowserCollectedInformation::inner_text_offset() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.BrowserCollectedInformation.inner_text_offset)
    return _internal_inner_text_offset();
}
inline void BrowserCollectedInformation::_internal_set_inner_text_offset(uint64_t value)
{

    _impl_.inner_text_offset_ = value;
}
inline void BrowserCollectedInformation::set_inner_text_offset(uint64_t value)
{
    _internal_set_inner_text_offset(value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.BrowserCollectedInformation.inner_text_offset)
}

// repeated string custom_data = 4;
inline int BrowserCollectedInformation::_internal_custom_data_size() const
{
    return _impl_.custom_data_.size();
}
inline int BrowserCollectedInformation::custom_data_size() const
{
    return _internal_custom_data_size();
}
inline void BrowserCollectedInformation::clear_custom_data()
{
    _impl_.custom_data_.Clear();
}
inline std::string* BrowserCollectedInformation::add_custom_data()
{
    std::string* _s = _internal_add_custom_data();
    // @@protoc_insertion_point(field_add_mutable:optimization_guide.proto.BrowserCollectedInformation.custom_data)
    return _s;
}
inline const std::string& BrowserCollectedInformation::_internal_custom_data(int index) const
{
    return _impl_.custom_data_.Get(index);
}
inline const std::string& BrowserCollectedInformation::custom_data(int index) const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.BrowserCollectedInformation.custom_data)
    return _internal_custom_data(index);
}
inline std::string* BrowserCollectedInformation::mutable_custom_data(int index)
{
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.BrowserCollectedInformation.custom_data)
    return _impl_.custom_data_.Mutable(index);
}
inline void BrowserCollectedInformation::set_custom_data(int index, const std::string& value)
{
    _impl_.custom_data_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.BrowserCollectedInformation.custom_data)
}
inline void BrowserCollectedInformation::set_custom_data(int index, std::string&& value)
{
    _impl_.custom_data_.Mutable(index)->assign(std::move(value));
    // @@protoc_insertion_point(field_set:optimization_guide.proto.BrowserCollectedInformation.custom_data)
}
inline void BrowserCollectedInformation::set_custom_data(int index, const char* value)
{
    GOOGLE_DCHECK(value != nullptr);
    _impl_.custom_data_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set_char:optimization_guide.proto.BrowserCollectedInformation.custom_data)
}
inline void BrowserCollectedInformation::set_custom_data(int index, const char* value, size_t size)
{
    _impl_.custom_data_.Mutable(index)->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:optimization_guide.proto.BrowserCollectedInformation.custom_data)
}
inline std::string* BrowserCollectedInformation::_internal_add_custom_data()
{
    return _impl_.custom_data_.Add();
}
inline void BrowserCollectedInformation::add_custom_data(const std::string& value)
{
    _impl_.custom_data_.Add()->assign(value);
    // @@protoc_insertion_point(field_add:optimization_guide.proto.BrowserCollectedInformation.custom_data)
}
inline void BrowserCollectedInformation::add_custom_data(std::string&& value)
{
    _impl_.custom_data_.Add(std::move(value));
    // @@protoc_insertion_point(field_add:optimization_guide.proto.BrowserCollectedInformation.custom_data)
}
inline void BrowserCollectedInformation::add_custom_data(const char* value)
{
    GOOGLE_DCHECK(value != nullptr);
    _impl_.custom_data_.Add()->assign(value);
    // @@protoc_insertion_point(field_add_char:optimization_guide.proto.BrowserCollectedInformation.custom_data)
}
inline void BrowserCollectedInformation::add_custom_data(const char* value, size_t size)
{
    _impl_.custom_data_.Add()->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_add_pointer:optimization_guide.proto.BrowserCollectedInformation.custom_data)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& BrowserCollectedInformation::custom_data() const
{
    // @@protoc_insertion_point(field_list:optimization_guide.proto.BrowserCollectedInformation.custom_data)
    return _impl_.custom_data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* BrowserCollectedInformation::mutable_custom_data()
{
    // @@protoc_insertion_point(field_mutable_list:optimization_guide.proto.BrowserCollectedInformation.custom_data)
    return &_impl_.custom_data_;
}

// .optimization_guide.proto.FormData form_data = 5;
inline bool BrowserCollectedInformation::_internal_has_form_data() const
{
    return this != internal_default_instance() && _impl_.form_data_ != nullptr;
}
inline bool BrowserCollectedInformation::has_form_data() const
{
    return _internal_has_form_data();
}
inline void BrowserCollectedInformation::clear_form_data()
{
    if (GetArenaForAllocation() == nullptr && _impl_.form_data_ != nullptr) {
        delete _impl_.form_data_;
    }
    _impl_.form_data_ = nullptr;
}
inline const ::optimization_guide::proto::FormData& BrowserCollectedInformation::_internal_form_data() const
{
    const ::optimization_guide::proto::FormData* p = _impl_.form_data_;
    return p != nullptr ? *p : reinterpret_cast<const ::optimization_guide::proto::FormData&>(::optimization_guide::proto::_FormData_default_instance_);
}
inline const ::optimization_guide::proto::FormData& BrowserCollectedInformation::form_data() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.BrowserCollectedInformation.form_data)
    return _internal_form_data();
}
inline void BrowserCollectedInformation::unsafe_arena_set_allocated_form_data(::optimization_guide::proto::FormData* form_data)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.form_data_);
    }
    _impl_.form_data_ = form_data;
    if (form_data) {

    } else {
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:optimization_guide.proto.BrowserCollectedInformation.form_data)
}
inline ::optimization_guide::proto::FormData* BrowserCollectedInformation::release_form_data()
{

    ::optimization_guide::proto::FormData* temp = _impl_.form_data_;
    _impl_.form_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::optimization_guide::proto::FormData* BrowserCollectedInformation::unsafe_arena_release_form_data()
{
    // @@protoc_insertion_point(field_release:optimization_guide.proto.BrowserCollectedInformation.form_data)

    ::optimization_guide::proto::FormData* temp = _impl_.form_data_;
    _impl_.form_data_ = nullptr;
    return temp;
}
inline ::optimization_guide::proto::FormData* BrowserCollectedInformation::_internal_mutable_form_data()
{

    if (_impl_.form_data_ == nullptr) {
        auto* p = CreateMaybeMessage<::optimization_guide::proto::FormData>(GetArenaForAllocation());
        _impl_.form_data_ = p;
    }
    return _impl_.form_data_;
}
inline ::optimization_guide::proto::FormData* BrowserCollectedInformation::mutable_form_data()
{
    ::optimization_guide::proto::FormData* _msg = _internal_mutable_form_data();
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.BrowserCollectedInformation.form_data)
    return _msg;
}
inline void BrowserCollectedInformation::set_allocated_form_data(::optimization_guide::proto::FormData* form_data)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.form_data_;
    }
    if (form_data) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(form_data);
        if (message_arena != submessage_arena) {
            form_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, form_data, submessage_arena);
        }

    } else {
    }
    _impl_.form_data_ = form_data;
    // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.BrowserCollectedInformation.form_data)
}

// repeated .optimization_guide.proto.UserAnnotationsEntry entries = 6;
inline int BrowserCollectedInformation::_internal_entries_size() const
{
    return _impl_.entries_.size();
}
inline int BrowserCollectedInformation::entries_size() const
{
    return _internal_entries_size();
}
inline void BrowserCollectedInformation::clear_entries()
{
    _impl_.entries_.Clear();
}
inline ::optimization_guide::proto::UserAnnotationsEntry* BrowserCollectedInformation::mutable_entries(int index)
{
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.BrowserCollectedInformation.entries)
    return _impl_.entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::UserAnnotationsEntry>* BrowserCollectedInformation::mutable_entries()
{
    // @@protoc_insertion_point(field_mutable_list:optimization_guide.proto.BrowserCollectedInformation.entries)
    return &_impl_.entries_;
}
inline const ::optimization_guide::proto::UserAnnotationsEntry& BrowserCollectedInformation::_internal_entries(int index) const
{
    return _impl_.entries_.Get(index);
}
inline const ::optimization_guide::proto::UserAnnotationsEntry& BrowserCollectedInformation::entries(int index) const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.BrowserCollectedInformation.entries)
    return _internal_entries(index);
}
inline ::optimization_guide::proto::UserAnnotationsEntry* BrowserCollectedInformation::_internal_add_entries()
{
    return _impl_.entries_.Add();
}
inline ::optimization_guide::proto::UserAnnotationsEntry* BrowserCollectedInformation::add_entries()
{
    ::optimization_guide::proto::UserAnnotationsEntry* _add = _internal_add_entries();
    // @@protoc_insertion_point(field_add:optimization_guide.proto.BrowserCollectedInformation.entries)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::UserAnnotationsEntry>& BrowserCollectedInformation::entries() const
{
    // @@protoc_insertion_point(field_list:optimization_guide.proto.BrowserCollectedInformation.entries)
    return _impl_.entries_;
}

// repeated .optimization_guide.proto.Tab tabs = 7;
inline int BrowserCollectedInformation::_internal_tabs_size() const
{
    return _impl_.tabs_.size();
}
inline int BrowserCollectedInformation::tabs_size() const
{
    return _internal_tabs_size();
}
inline void BrowserCollectedInformation::clear_tabs()
{
    _impl_.tabs_.Clear();
}
inline ::optimization_guide::proto::Tab* BrowserCollectedInformation::mutable_tabs(int index)
{
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.BrowserCollectedInformation.tabs)
    return _impl_.tabs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::Tab>* BrowserCollectedInformation::mutable_tabs()
{
    // @@protoc_insertion_point(field_mutable_list:optimization_guide.proto.BrowserCollectedInformation.tabs)
    return &_impl_.tabs_;
}
inline const ::optimization_guide::proto::Tab& BrowserCollectedInformation::_internal_tabs(int index) const
{
    return _impl_.tabs_.Get(index);
}
inline const ::optimization_guide::proto::Tab& BrowserCollectedInformation::tabs(int index) const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.BrowserCollectedInformation.tabs)
    return _internal_tabs(index);
}
inline ::optimization_guide::proto::Tab* BrowserCollectedInformation::_internal_add_tabs()
{
    return _impl_.tabs_.Add();
}
inline ::optimization_guide::proto::Tab* BrowserCollectedInformation::add_tabs()
{
    ::optimization_guide::proto::Tab* _add = _internal_add_tabs();
    // @@protoc_insertion_point(field_add:optimization_guide.proto.BrowserCollectedInformation.tabs)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::Tab>& BrowserCollectedInformation::tabs() const
{
    // @@protoc_insertion_point(field_list:optimization_guide.proto.BrowserCollectedInformation.tabs)
    return _impl_.tabs_;
}

// int64 active_tab_id = 8;
inline void BrowserCollectedInformation::clear_active_tab_id()
{
    _impl_.active_tab_id_ = int64_t { 0 };
}
inline int64_t BrowserCollectedInformation::_internal_active_tab_id() const
{
    return _impl_.active_tab_id_;
}
inline int64_t BrowserCollectedInformation::active_tab_id() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.BrowserCollectedInformation.active_tab_id)
    return _internal_active_tab_id();
}
inline void BrowserCollectedInformation::_internal_set_active_tab_id(int64_t value)
{

    _impl_.active_tab_id_ = value;
}
inline void BrowserCollectedInformation::set_active_tab_id(int64_t value)
{
    _internal_set_active_tab_id(value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.BrowserCollectedInformation.active_tab_id)
}

// repeated .optimization_guide.proto.TabGroup pre_existing_tab_groups = 9;
inline int BrowserCollectedInformation::_internal_pre_existing_tab_groups_size() const
{
    return _impl_.pre_existing_tab_groups_.size();
}
inline int BrowserCollectedInformation::pre_existing_tab_groups_size() const
{
    return _internal_pre_existing_tab_groups_size();
}
inline void BrowserCollectedInformation::clear_pre_existing_tab_groups()
{
    _impl_.pre_existing_tab_groups_.Clear();
}
inline ::optimization_guide::proto::TabGroup* BrowserCollectedInformation::mutable_pre_existing_tab_groups(int index)
{
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.BrowserCollectedInformation.pre_existing_tab_groups)
    return _impl_.pre_existing_tab_groups_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::TabGroup>* BrowserCollectedInformation::mutable_pre_existing_tab_groups()
{
    // @@protoc_insertion_point(field_mutable_list:optimization_guide.proto.BrowserCollectedInformation.pre_existing_tab_groups)
    return &_impl_.pre_existing_tab_groups_;
}
inline const ::optimization_guide::proto::TabGroup& BrowserCollectedInformation::_internal_pre_existing_tab_groups(int index) const
{
    return _impl_.pre_existing_tab_groups_.Get(index);
}
inline const ::optimization_guide::proto::TabGroup& BrowserCollectedInformation::pre_existing_tab_groups(int index) const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.BrowserCollectedInformation.pre_existing_tab_groups)
    return _internal_pre_existing_tab_groups(index);
}
inline ::optimization_guide::proto::TabGroup* BrowserCollectedInformation::_internal_add_pre_existing_tab_groups()
{
    return _impl_.pre_existing_tab_groups_.Add();
}
inline ::optimization_guide::proto::TabGroup* BrowserCollectedInformation::add_pre_existing_tab_groups()
{
    ::optimization_guide::proto::TabGroup* _add = _internal_add_pre_existing_tab_groups();
    // @@protoc_insertion_point(field_add:optimization_guide.proto.BrowserCollectedInformation.pre_existing_tab_groups)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::TabGroup>& BrowserCollectedInformation::pre_existing_tab_groups() const
{
    // @@protoc_insertion_point(field_list:optimization_guide.proto.BrowserCollectedInformation.pre_existing_tab_groups)
    return _impl_.pre_existing_tab_groups_;
}

// .optimization_guide.proto.SiteEngagement site_engagement = 10;
inline bool BrowserCollectedInformation::_internal_has_site_engagement() const
{
    return this != internal_default_instance() && _impl_.site_engagement_ != nullptr;
}
inline bool BrowserCollectedInformation::has_site_engagement() const
{
    return _internal_has_site_engagement();
}
inline void BrowserCollectedInformation::clear_site_engagement()
{
    if (GetArenaForAllocation() == nullptr && _impl_.site_engagement_ != nullptr) {
        delete _impl_.site_engagement_;
    }
    _impl_.site_engagement_ = nullptr;
}
inline const ::optimization_guide::proto::SiteEngagement& BrowserCollectedInformation::_internal_site_engagement() const
{
    const ::optimization_guide::proto::SiteEngagement* p = _impl_.site_engagement_;
    return p != nullptr ? *p
                        : reinterpret_cast<const ::optimization_guide::proto::SiteEngagement&>(::optimization_guide::proto::_SiteEngagement_default_instance_);
}
inline const ::optimization_guide::proto::SiteEngagement& BrowserCollectedInformation::site_engagement() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.BrowserCollectedInformation.site_engagement)
    return _internal_site_engagement();
}
inline void BrowserCollectedInformation::unsafe_arena_set_allocated_site_engagement(::optimization_guide::proto::SiteEngagement* site_engagement)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.site_engagement_);
    }
    _impl_.site_engagement_ = site_engagement;
    if (site_engagement) {

    } else {
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:optimization_guide.proto.BrowserCollectedInformation.site_engagement)
}
inline ::optimization_guide::proto::SiteEngagement* BrowserCollectedInformation::release_site_engagement()
{

    ::optimization_guide::proto::SiteEngagement* temp = _impl_.site_engagement_;
    _impl_.site_engagement_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::optimization_guide::proto::SiteEngagement* BrowserCollectedInformation::unsafe_arena_release_site_engagement()
{
    // @@protoc_insertion_point(field_release:optimization_guide.proto.BrowserCollectedInformation.site_engagement)

    ::optimization_guide::proto::SiteEngagement* temp = _impl_.site_engagement_;
    _impl_.site_engagement_ = nullptr;
    return temp;
}
inline ::optimization_guide::proto::SiteEngagement* BrowserCollectedInformation::_internal_mutable_site_engagement()
{

    if (_impl_.site_engagement_ == nullptr) {
        auto* p = CreateMaybeMessage<::optimization_guide::proto::SiteEngagement>(GetArenaForAllocation());
        _impl_.site_engagement_ = p;
    }
    return _impl_.site_engagement_;
}
inline ::optimization_guide::proto::SiteEngagement* BrowserCollectedInformation::mutable_site_engagement()
{
    ::optimization_guide::proto::SiteEngagement* _msg = _internal_mutable_site_engagement();
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.BrowserCollectedInformation.site_engagement)
    return _msg;
}
inline void BrowserCollectedInformation::set_allocated_site_engagement(::optimization_guide::proto::SiteEngagement* site_engagement)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.site_engagement_;
    }
    if (site_engagement) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(site_engagement);
        if (message_arena != submessage_arena) {
            site_engagement = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, site_engagement, submessage_arena);
        }

    } else {
    }
    _impl_.site_engagement_ = site_engagement;
    // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.BrowserCollectedInformation.site_engagement)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// @@protoc_insertion_point(namespace_scope)

} // namespace proto
} // namespace optimization_guide

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum<::optimization_guide::proto::AXTextAffinity> : ::std::true_type { };
template <> struct is_proto_enum<::optimization_guide::proto::AXRole> : ::std::true_type { };
template <> struct is_proto_enum<::optimization_guide::proto::AXStringAttribute> : ::std::true_type { };
template <> struct is_proto_enum<::optimization_guide::proto::AXIntAttribute> : ::std::true_type { };
template <> struct is_proto_enum<::optimization_guide::proto::AXFloatAttribute> : ::std::true_type { };
template <> struct is_proto_enum<::optimization_guide::proto::AXBoolAttribute> : ::std::true_type { };
template <> struct is_proto_enum<::optimization_guide::proto::AXIntListAttribute> : ::std::true_type { };
template <> struct is_proto_enum<::optimization_guide::proto::AXStringListAttribute> : ::std::true_type { };
template <> struct is_proto_enum<::optimization_guide::proto::FormControlType> : ::std::true_type { };
template <> struct is_proto_enum<::optimization_guide::proto::FinalModelStatus> : ::std::true_type { };
template <> struct is_proto_enum<::optimization_guide::proto::UserFeedback> : ::std::true_type { };

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_components_2foptimization_5fguide_2fproto_2ffeatures_2fcommon_5fquality_5fdata_2eproto
