// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/optimization_guide/proto/features/common_quality_data.proto

#include "components/optimization_guide/proto/features/common_quality_data.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace optimization_guide {
namespace proto {
PROTOBUF_CONSTEXPR FloatArray::FloatArray(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.values_)*/ {}, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct FloatArrayDefaultTypeInternal {
    PROTOBUF_CONSTEXPR FloatArrayDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~FloatArrayDefaultTypeInternal()
    {
    }
    union {
        FloatArray _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FloatArrayDefaultTypeInternal _FloatArray_default_instance_;
PROTOBUF_CONSTEXPR Embedding::Embedding(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.floats_)*/ nullptr, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct EmbeddingDefaultTypeInternal {
    PROTOBUF_CONSTEXPR EmbeddingDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~EmbeddingDefaultTypeInternal()
    {
    }
    union {
        Embedding _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EmbeddingDefaultTypeInternal _Embedding_default_instance_;
PROTOBUF_CONSTEXPR AXTreeUpdate::AXTreeUpdate(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.nodes_)*/ {},
        /*decltype(_impl_.tree_data_)*/ nullptr, /*decltype(_impl_.root_id_)*/ 0u }
{
}
struct AXTreeUpdateDefaultTypeInternal {
    PROTOBUF_CONSTEXPR AXTreeUpdateDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~AXTreeUpdateDefaultTypeInternal()
    {
    }
    union {
        AXTreeUpdate _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AXTreeUpdateDefaultTypeInternal _AXTreeUpdate_default_instance_;
PROTOBUF_CONSTEXPR AXTreeData::AXTreeData(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.metadata_)*/ {}, /*decltype(_impl_.doctype_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.mimetype_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.title_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.loading_progress_)*/ 0,
        /*decltype(_impl_.loaded_)*/ false, /*decltype(_impl_.sel_is_backward_)*/ false, /*decltype(_impl_.focus_id_)*/ 0u,
        /*decltype(_impl_.sel_anchor_object_id_)*/ 0u, /*decltype(_impl_.sel_anchor_offset_)*/ 0u, /*decltype(_impl_.sel_anchor_affinity_)*/ 0,
        /*decltype(_impl_.sel_focus_object_id_)*/ 0u, /*decltype(_impl_.sel_focus_offset_)*/ 0u, /*decltype(_impl_.sel_focus_affinity_)*/ 0,
        /*decltype(_impl_.root_scroller_id_)*/ 0u, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct AXTreeDataDefaultTypeInternal {
    PROTOBUF_CONSTEXPR AXTreeDataDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~AXTreeDataDefaultTypeInternal()
    {
    }
    union {
        AXTreeData _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AXTreeDataDefaultTypeInternal _AXTreeData_default_instance_;
PROTOBUF_CONSTEXPR AXNodeData::AXNodeData(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.attributes_)*/ {}, /*decltype(_impl_.child_ids_)*/ {}, /*decltype(_impl_._child_ids_cached_byte_size_)*/ { 0 },
        /*decltype(_impl_.relative_bounds_)*/ nullptr, /*decltype(_impl_.id_)*/ 0u, /*decltype(_impl_.role_)*/ 0, /*decltype(_impl_.actions_)*/ uint64_t { 0u },
        /*decltype(_impl_.state_)*/ 0u, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct AXNodeDataDefaultTypeInternal {
    PROTOBUF_CONSTEXPR AXNodeDataDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~AXNodeDataDefaultTypeInternal()
    {
    }
    union {
        AXNodeData _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AXNodeDataDefaultTypeInternal _AXNodeData_default_instance_;
PROTOBUF_CONSTEXPR AXAttribute::AXAttribute(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.attribute_key_)*/ {}, /*decltype(_impl_.attribute_value_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_._oneof_case_)*/ {} }
{
}
struct AXAttributeDefaultTypeInternal {
    PROTOBUF_CONSTEXPR AXAttributeDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~AXAttributeDefaultTypeInternal()
    {
    }
    union {
        AXAttribute _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AXAttributeDefaultTypeInternal _AXAttribute_default_instance_;
PROTOBUF_CONSTEXPR AXIntList::AXIntList(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.value_)*/ {}, /*decltype(_impl_._value_cached_byte_size_)*/ { 0 }, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct AXIntListDefaultTypeInternal {
    PROTOBUF_CONSTEXPR AXIntListDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~AXIntListDefaultTypeInternal()
    {
    }
    union {
        AXIntList _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AXIntListDefaultTypeInternal _AXIntList_default_instance_;
PROTOBUF_CONSTEXPR AXStringList::AXStringList(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.value_)*/ {}, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct AXStringListDefaultTypeInternal {
    PROTOBUF_CONSTEXPR AXStringListDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~AXStringListDefaultTypeInternal()
    {
    }
    union {
        AXStringList _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AXStringListDefaultTypeInternal _AXStringList_default_instance_;
PROTOBUF_CONSTEXPR AXRelativeBounds::AXRelativeBounds(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.transform_)*/ {}, /*decltype(_impl_.offset_container_id_)*/ 0, /*decltype(_impl_.x_)*/ 0, /*decltype(_impl_.y_)*/ 0,
        /*decltype(_impl_.width_)*/ 0, /*decltype(_impl_.height_)*/ 0, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct AXRelativeBoundsDefaultTypeInternal {
    PROTOBUF_CONSTEXPR AXRelativeBoundsDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~AXRelativeBoundsDefaultTypeInternal()
    {
    }
    union {
        AXRelativeBounds _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AXRelativeBoundsDefaultTypeInternal _AXRelativeBounds_default_instance_;
PROTOBUF_CONSTEXPR PageContext::PageContext(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.title_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.inner_text_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.tab_screenshot_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.pdf_data_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.ax_tree_data_)*/ nullptr,
        /*decltype(_impl_.inner_text_offset_)*/ uint64_t { 0u }, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct PageContextDefaultTypeInternal {
    PROTOBUF_CONSTEXPR PageContextDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~PageContextDefaultTypeInternal()
    {
    }
    union {
        PageContext _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PageContextDefaultTypeInternal _PageContext_default_instance_;
PROTOBUF_CONSTEXPR FormData::FormData(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.fields_)*/ {}, /*decltype(_impl_.form_name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct FormDataDefaultTypeInternal {
    PROTOBUF_CONSTEXPR FormDataDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~FormDataDefaultTypeInternal()
    {
    }
    union {
        FormData _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FormDataDefaultTypeInternal _FormData_default_instance_;
PROTOBUF_CONSTEXPR FormFieldData::FormFieldData(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.select_options_)*/ {},
        /*decltype(_impl_.field_name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.field_label_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.field_value_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.placeholder_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.global_id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.form_control_type_)*/ 0,
        /*decltype(_impl_.is_visible_)*/ false, /*decltype(_impl_.is_focusable_)*/ false, /*decltype(_impl_.is_eligible_)*/ false,
        /*decltype(_impl_.form_control_ax_node_id_)*/ 0, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct FormFieldDataDefaultTypeInternal {
    PROTOBUF_CONSTEXPR FormFieldDataDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~FormFieldDataDefaultTypeInternal()
    {
    }
    union {
        FormFieldData _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FormFieldDataDefaultTypeInternal _FormFieldData_default_instance_;
PROTOBUF_CONSTEXPR SelectOption::SelectOption(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.value_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.text_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct SelectOptionDefaultTypeInternal {
    PROTOBUF_CONSTEXPR SelectOptionDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~SelectOptionDefaultTypeInternal()
    {
    }
    union {
        SelectOption _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SelectOptionDefaultTypeInternal _SelectOption_default_instance_;
PROTOBUF_CONSTEXPR UserAnnotationsEntry::UserAnnotationsEntry(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.key_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.value_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.entry_id_)*/ int64_t { 0 },
        /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct UserAnnotationsEntryDefaultTypeInternal {
    PROTOBUF_CONSTEXPR UserAnnotationsEntryDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~UserAnnotationsEntryDefaultTypeInternal()
    {
    }
    union {
        UserAnnotationsEntry _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserAnnotationsEntryDefaultTypeInternal
    _UserAnnotationsEntry_default_instance_;
PROTOBUF_CONSTEXPR TabGroup::TabGroup(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.tabs_)*/ {},
        /*decltype(_impl_.label_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.group_id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct TabGroupDefaultTypeInternal {
    PROTOBUF_CONSTEXPR TabGroupDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~TabGroupDefaultTypeInternal()
    {
    }
    union {
        TabGroup _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TabGroupDefaultTypeInternal _TabGroup_default_instance_;
PROTOBUF_CONSTEXPR Tab::Tab(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.title_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.page_context_)*/ nullptr,
        /*decltype(_impl_.tab_id_)*/ int64_t { 0 }, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct TabDefaultTypeInternal {
    PROTOBUF_CONSTEXPR TabDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~TabDefaultTypeInternal()
    {
    }
    union {
        Tab _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TabDefaultTypeInternal _Tab_default_instance_;
PROTOBUF_CONSTEXPR SiteEngagementEntry::SiteEngagementEntry(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.score_)*/ 0,
        /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct SiteEngagementEntryDefaultTypeInternal {
    PROTOBUF_CONSTEXPR SiteEngagementEntryDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~SiteEngagementEntryDefaultTypeInternal()
    {
    }
    union {
        SiteEngagementEntry _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SiteEngagementEntryDefaultTypeInternal
    _SiteEngagementEntry_default_instance_;
PROTOBUF_CONSTEXPR SiteEngagement::SiteEngagement(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.entries_)*/ {}, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct SiteEngagementDefaultTypeInternal {
    PROTOBUF_CONSTEXPR SiteEngagementDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~SiteEngagementDefaultTypeInternal()
    {
    }
    union {
        SiteEngagement _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SiteEngagementDefaultTypeInternal _SiteEngagement_default_instance_;
PROTOBUF_CONSTEXPR BrowserCollectedInformation::BrowserCollectedInformation(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.custom_data_)*/ {}, /*decltype(_impl_.entries_)*/ {}, /*decltype(_impl_.tabs_)*/ {},
        /*decltype(_impl_.pre_existing_tab_groups_)*/ {},
        /*decltype(_impl_.inner_text_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.page_context_)*/ nullptr,
        /*decltype(_impl_.form_data_)*/ nullptr, /*decltype(_impl_.site_engagement_)*/ nullptr, /*decltype(_impl_.inner_text_offset_)*/ uint64_t { 0u },
        /*decltype(_impl_.active_tab_id_)*/ int64_t { 0 }, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct BrowserCollectedInformationDefaultTypeInternal {
    PROTOBUF_CONSTEXPR BrowserCollectedInformationDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~BrowserCollectedInformationDefaultTypeInternal()
    {
    }
    union {
        BrowserCollectedInformation _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BrowserCollectedInformationDefaultTypeInternal
    _BrowserCollectedInformation_default_instance_;
} // namespace proto
} // namespace optimization_guide
namespace optimization_guide {
namespace proto {
bool AXTextAffinity_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> AXTextAffinity_strings[3] = {};

static const char AXTextAffinity_names[] = "AX_TEXT_AFFINITY_DOWNSTREAM"
                                           "AX_TEXT_AFFINITY_NONE"
                                           "AX_TEXT_AFFINITY_UPSTREAM";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry AXTextAffinity_entries[] = {
    { { AXTextAffinity_names + 0, 27 }, 1 },
    { { AXTextAffinity_names + 27, 21 }, 0 },
    { { AXTextAffinity_names + 48, 25 }, 2 },
};

static const int AXTextAffinity_entries_by_number[] = {
    1, // 0 -> AX_TEXT_AFFINITY_NONE
    0, // 1 -> AX_TEXT_AFFINITY_DOWNSTREAM
    2, // 2 -> AX_TEXT_AFFINITY_UPSTREAM
};

const std::string& AXTextAffinity_Name(AXTextAffinity value)
{
    static const bool dummy
        = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(AXTextAffinity_entries, AXTextAffinity_entries_by_number, 3, AXTextAffinity_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(AXTextAffinity_entries, AXTextAffinity_entries_by_number, 3, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : AXTextAffinity_strings[idx].get();
}
bool AXTextAffinity_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AXTextAffinity* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(AXTextAffinity_entries, 3, name, &int_value);
    if (success) {
        *value = static_cast<AXTextAffinity>(int_value);
    }
    return success;
}
bool AXRole_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 65:
    case 66:
    case 67:
    case 68:
    case 69:
    case 70:
    case 71:
    case 72:
    case 73:
    case 74:
    case 75:
    case 76:
    case 77:
    case 78:
    case 79:
    case 80:
    case 81:
    case 82:
    case 83:
    case 84:
    case 85:
    case 86:
    case 87:
    case 88:
    case 89:
    case 90:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 97:
    case 98:
    case 99:
    case 100:
    case 101:
    case 102:
    case 103:
    case 104:
    case 105:
    case 106:
    case 107:
    case 108:
    case 109:
    case 110:
    case 111:
    case 112:
    case 113:
    case 114:
    case 115:
    case 116:
    case 117:
    case 118:
    case 119:
    case 120:
    case 121:
    case 122:
    case 123:
    case 124:
    case 125:
    case 126:
    case 127:
    case 128:
    case 129:
    case 130:
    case 131:
    case 132:
    case 133:
    case 134:
    case 135:
    case 136:
    case 137:
    case 138:
    case 139:
    case 140:
    case 141:
    case 142:
    case 143:
    case 144:
    case 145:
    case 146:
    case 147:
    case 148:
    case 149:
    case 150:
    case 151:
    case 152:
    case 153:
    case 154:
    case 155:
    case 156:
    case 157:
    case 158:
    case 159:
    case 160:
    case 161:
    case 162:
    case 163:
    case 164:
    case 165:
    case 166:
    case 167:
    case 168:
    case 169:
    case 170:
    case 171:
    case 172:
    case 173:
    case 174:
    case 175:
    case 176:
    case 177:
    case 178:
    case 179:
    case 180:
    case 181:
    case 182:
    case 183:
    case 184:
    case 185:
    case 186:
    case 187:
    case 188:
    case 189:
    case 190:
    case 191:
    case 192:
    case 193:
    case 194:
    case 195:
    case 196:
    case 197:
    case 198:
    case 199:
    case 200:
    case 201:
    case 202:
    case 203:
    case 204:
    case 205:
    case 206:
    case 207:
    case 208:
    case 209:
    case 210:
    case 211:
    case 212:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> AXRole_strings[213] = {};

static const char AXRole_names[] = "AX_ROLE_ABBR"
                                   "AX_ROLE_ALERT"
                                   "AX_ROLE_ALERTDIALOG"
                                   "AX_ROLE_APPLICATION"
                                   "AX_ROLE_ARTICLE"
                                   "AX_ROLE_AUDIO"
                                   "AX_ROLE_BANNER"
                                   "AX_ROLE_BLOCKQUOTE"
                                   "AX_ROLE_BUTTON"
                                   "AX_ROLE_CANVAS"
                                   "AX_ROLE_CAPTION"
                                   "AX_ROLE_CARET"
                                   "AX_ROLE_CELL"
                                   "AX_ROLE_CHECKBOX"
                                   "AX_ROLE_CLIENT"
                                   "AX_ROLE_CODE"
                                   "AX_ROLE_COLORWELL"
                                   "AX_ROLE_COLUMN"
                                   "AX_ROLE_COLUMNHEADER"
                                   "AX_ROLE_COMBOBOXGROUPING"
                                   "AX_ROLE_COMBOBOXMENUBUTTON"
                                   "AX_ROLE_COMBOBOXSELECT"
                                   "AX_ROLE_COMMENT"
                                   "AX_ROLE_COMPLEMENTARY"
                                   "AX_ROLE_CONTENTDELETION"
                                   "AX_ROLE_CONTENTINFO"
                                   "AX_ROLE_CONTENTINSERTION"
                                   "AX_ROLE_DATE"
                                   "AX_ROLE_DATETIME"
                                   "AX_ROLE_DEFINITION"
                                   "AX_ROLE_DESCRIPTIONLIST"
                                   "AX_ROLE_DESCRIPTIONLISTDETAILDEPRECATED"
                                   "AX_ROLE_DESCRIPTIONLISTTERMDEPRECATED"
                                   "AX_ROLE_DESKTOP"
                                   "AX_ROLE_DETAILS"
                                   "AX_ROLE_DIALOG"
                                   "AX_ROLE_DIRECTORYDEPRECATED"
                                   "AX_ROLE_DISCLOSURETRIANGLE"
                                   "AX_ROLE_DISCLOSURETRIANGLEGROUPED"
                                   "AX_ROLE_DOCABSTRACT"
                                   "AX_ROLE_DOCACKNOWLEDGMENTS"
                                   "AX_ROLE_DOCAFTERWORD"
                                   "AX_ROLE_DOCAPPENDIX"
                                   "AX_ROLE_DOCBACKLINK"
                                   "AX_ROLE_DOCBIBLIOENTRY"
                                   "AX_ROLE_DOCBIBLIOGRAPHY"
                                   "AX_ROLE_DOCBIBLIOREF"
                                   "AX_ROLE_DOCCHAPTER"
                                   "AX_ROLE_DOCCOLOPHON"
                                   "AX_ROLE_DOCCONCLUSION"
                                   "AX_ROLE_DOCCOVER"
                                   "AX_ROLE_DOCCREDIT"
                                   "AX_ROLE_DOCCREDITS"
                                   "AX_ROLE_DOCDEDICATION"
                                   "AX_ROLE_DOCENDNOTE"
                                   "AX_ROLE_DOCENDNOTES"
                                   "AX_ROLE_DOCEPIGRAPH"
                                   "AX_ROLE_DOCEPILOGUE"
                                   "AX_ROLE_DOCERRATA"
                                   "AX_ROLE_DOCEXAMPLE"
                                   "AX_ROLE_DOCFOOTNOTE"
                                   "AX_ROLE_DOCFOREWORD"
                                   "AX_ROLE_DOCGLOSSARY"
                                   "AX_ROLE_DOCGLOSSREF"
                                   "AX_ROLE_DOCINDEX"
                                   "AX_ROLE_DOCINTRODUCTION"
                                   "AX_ROLE_DOCNOTEREF"
                                   "AX_ROLE_DOCNOTICE"
                                   "AX_ROLE_DOCPAGEBREAK"
                                   "AX_ROLE_DOCPAGEFOOTER"
                                   "AX_ROLE_DOCPAGEHEADER"
                                   "AX_ROLE_DOCPAGELIST"
                                   "AX_ROLE_DOCPART"
                                   "AX_ROLE_DOCPREFACE"
                                   "AX_ROLE_DOCPROLOGUE"
                                   "AX_ROLE_DOCPULLQUOTE"
                                   "AX_ROLE_DOCQNA"
                                   "AX_ROLE_DOCSUBTITLE"
                                   "AX_ROLE_DOCTIP"
                                   "AX_ROLE_DOCTOC"
                                   "AX_ROLE_DOCUMENT"
                                   "AX_ROLE_EMBEDDEDOBJECT"
                                   "AX_ROLE_EMPHASIS"
                                   "AX_ROLE_FEED"
                                   "AX_ROLE_FIGCAPTION"
                                   "AX_ROLE_FIGURE"
                                   "AX_ROLE_FOOTER"
                                   "AX_ROLE_FORM"
                                   "AX_ROLE_GENERICCONTAINER"
                                   "AX_ROLE_GRAPHICSDOCUMENT"
                                   "AX_ROLE_GRAPHICSOBJECT"
                                   "AX_ROLE_GRAPHICSSYMBOL"
                                   "AX_ROLE_GRID"
                                   "AX_ROLE_GRIDCELL"
                                   "AX_ROLE_GROUP"
                                   "AX_ROLE_HEADER"
                                   "AX_ROLE_HEADING"
                                   "AX_ROLE_IFRAME"
                                   "AX_ROLE_IFRAMEPRESENTATIONAL"
                                   "AX_ROLE_IMAGE"
                                   "AX_ROLE_IMECANDIDATE"
                                   "AX_ROLE_INLINETEXTBOX"
                                   "AX_ROLE_INPUTTIME"
                                   "AX_ROLE_KEYBOARD"
                                   "AX_ROLE_LABELTEXT"
                                   "AX_ROLE_LAYOUTTABLE"
                                   "AX_ROLE_LAYOUTTABLECELL"
                                   "AX_ROLE_LAYOUTTABLEROW"
                                   "AX_ROLE_LEGEND"
                                   "AX_ROLE_LINEBREAK"
                                   "AX_ROLE_LINK"
                                   "AX_ROLE_LIST"
                                   "AX_ROLE_LISTBOX"
                                   "AX_ROLE_LISTBOXOPTION"
                                   "AX_ROLE_LISTGRID"
                                   "AX_ROLE_LISTITEM"
                                   "AX_ROLE_LISTMARKER"
                                   "AX_ROLE_LOG"
                                   "AX_ROLE_MAIN"
                                   "AX_ROLE_MARK"
                                   "AX_ROLE_MARQUEE"
                                   "AX_ROLE_MATH"
                                   "AX_ROLE_MATHMLFRACTION"
                                   "AX_ROLE_MATHMLIDENTIFIER"
                                   "AX_ROLE_MATHMLMATH"
                                   "AX_ROLE_MATHMLMULTISCRIPTS"
                                   "AX_ROLE_MATHMLNONESCRIPT"
                                   "AX_ROLE_MATHMLNUMBER"
                                   "AX_ROLE_MATHMLOPERATOR"
                                   "AX_ROLE_MATHMLOVER"
                                   "AX_ROLE_MATHMLPRESCRIPTDELIMITER"
                                   "AX_ROLE_MATHMLROOT"
                                   "AX_ROLE_MATHMLROW"
                                   "AX_ROLE_MATHMLSQUAREROOT"
                                   "AX_ROLE_MATHMLSTRINGLITERAL"
                                   "AX_ROLE_MATHMLSUB"
                                   "AX_ROLE_MATHMLSUBSUP"
                                   "AX_ROLE_MATHMLSUP"
                                   "AX_ROLE_MATHMLTABLE"
                                   "AX_ROLE_MATHMLTABLECELL"
                                   "AX_ROLE_MATHMLTABLEROW"
                                   "AX_ROLE_MATHMLTEXT"
                                   "AX_ROLE_MATHMLUNDER"
                                   "AX_ROLE_MATHMLUNDEROVER"
                                   "AX_ROLE_MENU"
                                   "AX_ROLE_MENUBAR"
                                   "AX_ROLE_MENUITEM"
                                   "AX_ROLE_MENUITEMCHECKBOX"
                                   "AX_ROLE_MENUITEMRADIO"
                                   "AX_ROLE_MENULISTOPTION"
                                   "AX_ROLE_MENULISTPOPUP"
                                   "AX_ROLE_METER"
                                   "AX_ROLE_NAVIGATION"
                                   "AX_ROLE_NONE"
                                   "AX_ROLE_NOTE"
                                   "AX_ROLE_PANE"
                                   "AX_ROLE_PARAGRAPH"
                                   "AX_ROLE_PDFACTIONABLEHIGHLIGHT"
                                   "AX_ROLE_PDFROOT"
                                   "AX_ROLE_PLUGINOBJECT"
                                   "AX_ROLE_POPUPBUTTON"
                                   "AX_ROLE_PORTALDEPRECATED"
                                   "AX_ROLE_PREDEPRECATED"
                                   "AX_ROLE_PROGRESSINDICATOR"
                                   "AX_ROLE_RADIOBUTTON"
                                   "AX_ROLE_RADIOGROUP"
                                   "AX_ROLE_REGION"
                                   "AX_ROLE_ROOTWEBAREA"
                                   "AX_ROLE_ROW"
                                   "AX_ROLE_ROWGROUP"
                                   "AX_ROLE_ROWHEADER"
                                   "AX_ROLE_RUBY"
                                   "AX_ROLE_RUBYANNOTATION"
                                   "AX_ROLE_SCROLLBAR"
                                   "AX_ROLE_SCROLLVIEW"
                                   "AX_ROLE_SEARCH"
                                   "AX_ROLE_SEARCHBOX"
                                   "AX_ROLE_SECTION"
                                   "AX_ROLE_SECTIONFOOTER"
                                   "AX_ROLE_SECTIONHEADER"
                                   "AX_ROLE_SECTIONWITHOUTNAME"
                                   "AX_ROLE_SLIDER"
                                   "AX_ROLE_SPINBUTTON"
                                   "AX_ROLE_SPLITTER"
                                   "AX_ROLE_STATICTEXT"
                                   "AX_ROLE_STATUS"
                                   "AX_ROLE_STRONG"
                                   "AX_ROLE_SUBSCRIPT"
                                   "AX_ROLE_SUGGESTION"
                                   "AX_ROLE_SUPERSCRIPT"
                                   "AX_ROLE_SVGROOT"
                                   "AX_ROLE_SWITCH"
                                   "AX_ROLE_TAB"
                                   "AX_ROLE_TABLE"
                                   "AX_ROLE_TABLEHEADERCONTAINER"
                                   "AX_ROLE_TABLIST"
                                   "AX_ROLE_TABPANEL"
                                   "AX_ROLE_TERM"
                                   "AX_ROLE_TEXTFIELD"
                                   "AX_ROLE_TEXTFIELDWITHCOMBOBOX"
                                   "AX_ROLE_TIME"
                                   "AX_ROLE_TIMER"
                                   "AX_ROLE_TITLEBAR"
                                   "AX_ROLE_TOGGLEBUTTON"
                                   "AX_ROLE_TOOLBAR"
                                   "AX_ROLE_TOOLTIP"
                                   "AX_ROLE_TREE"
                                   "AX_ROLE_TREEGRID"
                                   "AX_ROLE_TREEITEM"
                                   "AX_ROLE_UNKNOWN"
                                   "AX_ROLE_VIDEO"
                                   "AX_ROLE_WEBVIEW"
                                   "AX_ROLE_WINDOW";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry AXRole_entries[] = {
    { { AXRole_names + 0, 12 }, 1 },
    { { AXRole_names + 12, 13 }, 2 },
    { { AXRole_names + 25, 19 }, 3 },
    { { AXRole_names + 44, 19 }, 4 },
    { { AXRole_names + 63, 15 }, 5 },
    { { AXRole_names + 78, 13 }, 6 },
    { { AXRole_names + 91, 14 }, 7 },
    { { AXRole_names + 105, 18 }, 8 },
    { { AXRole_names + 123, 14 }, 9 },
    { { AXRole_names + 137, 14 }, 10 },
    { { AXRole_names + 151, 15 }, 11 },
    { { AXRole_names + 166, 13 }, 12 },
    { { AXRole_names + 179, 12 }, 13 },
    { { AXRole_names + 191, 16 }, 14 },
    { { AXRole_names + 207, 14 }, 15 },
    { { AXRole_names + 221, 12 }, 16 },
    { { AXRole_names + 233, 17 }, 17 },
    { { AXRole_names + 250, 14 }, 18 },
    { { AXRole_names + 264, 20 }, 19 },
    { { AXRole_names + 284, 24 }, 20 },
    { { AXRole_names + 308, 26 }, 21 },
    { { AXRole_names + 334, 22 }, 209 },
    { { AXRole_names + 356, 15 }, 23 },
    { { AXRole_names + 371, 21 }, 22 },
    { { AXRole_names + 392, 23 }, 24 },
    { { AXRole_names + 415, 19 }, 26 },
    { { AXRole_names + 434, 24 }, 25 },
    { { AXRole_names + 458, 12 }, 27 },
    { { AXRole_names + 470, 16 }, 28 },
    { { AXRole_names + 486, 18 }, 29 },
    { { AXRole_names + 504, 23 }, 30 },
    { { AXRole_names + 527, 39 }, 31 },
    { { AXRole_names + 566, 37 }, 32 },
    { { AXRole_names + 603, 15 }, 33 },
    { { AXRole_names + 618, 15 }, 34 },
    { { AXRole_names + 633, 14 }, 35 },
    { { AXRole_names + 647, 27 }, 36 },
    { { AXRole_names + 674, 26 }, 37 },
    { { AXRole_names + 700, 33 }, 210 },
    { { AXRole_names + 733, 19 }, 38 },
    { { AXRole_names + 752, 26 }, 39 },
    { { AXRole_names + 778, 20 }, 40 },
    { { AXRole_names + 798, 19 }, 41 },
    { { AXRole_names + 817, 19 }, 42 },
    { { AXRole_names + 836, 22 }, 43 },
    { { AXRole_names + 858, 23 }, 44 },
    { { AXRole_names + 881, 20 }, 45 },
    { { AXRole_names + 901, 18 }, 46 },
    { { AXRole_names + 919, 19 }, 47 },
    { { AXRole_names + 938, 21 }, 48 },
    { { AXRole_names + 959, 16 }, 49 },
    { { AXRole_names + 975, 17 }, 50 },
    { { AXRole_names + 992, 18 }, 51 },
    { { AXRole_names + 1010, 21 }, 52 },
    { { AXRole_names + 1031, 18 }, 53 },
    { { AXRole_names + 1049, 19 }, 54 },
    { { AXRole_names + 1068, 19 }, 55 },
    { { AXRole_names + 1087, 19 }, 56 },
    { { AXRole_names + 1106, 17 }, 57 },
    { { AXRole_names + 1123, 18 }, 58 },
    { { AXRole_names + 1141, 19 }, 59 },
    { { AXRole_names + 1160, 19 }, 60 },
    { { AXRole_names + 1179, 19 }, 61 },
    { { AXRole_names + 1198, 19 }, 62 },
    { { AXRole_names + 1217, 16 }, 63 },
    { { AXRole_names + 1233, 23 }, 64 },
    { { AXRole_names + 1256, 18 }, 65 },
    { { AXRole_names + 1274, 17 }, 66 },
    { { AXRole_names + 1291, 20 }, 67 },
    { { AXRole_names + 1311, 21 }, 68 },
    { { AXRole_names + 1332, 21 }, 69 },
    { { AXRole_names + 1353, 19 }, 70 },
    { { AXRole_names + 1372, 15 }, 71 },
    { { AXRole_names + 1387, 18 }, 72 },
    { { AXRole_names + 1405, 19 }, 73 },
    { { AXRole_names + 1424, 20 }, 74 },
    { { AXRole_names + 1444, 14 }, 75 },
    { { AXRole_names + 1458, 19 }, 76 },
    { { AXRole_names + 1477, 14 }, 77 },
    { { AXRole_names + 1491, 14 }, 78 },
    { { AXRole_names + 1505, 16 }, 79 },
    { { AXRole_names + 1521, 22 }, 80 },
    { { AXRole_names + 1543, 16 }, 81 },
    { { AXRole_names + 1559, 12 }, 82 },
    { { AXRole_names + 1571, 18 }, 83 },
    { { AXRole_names + 1589, 14 }, 84 },
    { { AXRole_names + 1603, 14 }, 85 },
    { { AXRole_names + 1617, 12 }, 87 },
    { { AXRole_names + 1629, 24 }, 88 },
    { { AXRole_names + 1653, 24 }, 89 },
    { { AXRole_names + 1677, 22 }, 90 },
    { { AXRole_names + 1699, 22 }, 91 },
    { { AXRole_names + 1721, 12 }, 92 },
    { { AXRole_names + 1733, 16 }, 212 },
    { { AXRole_names + 1749, 13 }, 93 },
    { { AXRole_names + 1762, 14 }, 94 },
    { { AXRole_names + 1776, 15 }, 96 },
    { { AXRole_names + 1791, 14 }, 97 },
    { { AXRole_names + 1805, 28 }, 98 },
    { { AXRole_names + 1833, 13 }, 99 },
    { { AXRole_names + 1846, 20 }, 100 },
    { { AXRole_names + 1866, 21 }, 101 },
    { { AXRole_names + 1887, 17 }, 102 },
    { { AXRole_names + 1904, 16 }, 103 },
    { { AXRole_names + 1920, 17 }, 104 },
    { { AXRole_names + 1937, 19 }, 105 },
    { { AXRole_names + 1956, 23 }, 106 },
    { { AXRole_names + 1979, 22 }, 107 },
    { { AXRole_names + 2001, 14 }, 108 },
    { { AXRole_names + 2015, 17 }, 109 },
    { { AXRole_names + 2032, 12 }, 110 },
    { { AXRole_names + 2044, 12 }, 111 },
    { { AXRole_names + 2056, 15 }, 112 },
    { { AXRole_names + 2071, 21 }, 113 },
    { { AXRole_names + 2092, 16 }, 114 },
    { { AXRole_names + 2108, 16 }, 115 },
    { { AXRole_names + 2124, 18 }, 116 },
    { { AXRole_names + 2142, 11 }, 117 },
    { { AXRole_names + 2153, 12 }, 118 },
    { { AXRole_names + 2165, 12 }, 119 },
    { { AXRole_names + 2177, 15 }, 120 },
    { { AXRole_names + 2192, 12 }, 121 },
    { { AXRole_names + 2204, 22 }, 188 },
    { { AXRole_names + 2226, 24 }, 189 },
    { { AXRole_names + 2250, 18 }, 187 },
    { { AXRole_names + 2268, 26 }, 190 },
    { { AXRole_names + 2294, 24 }, 191 },
    { { AXRole_names + 2318, 20 }, 192 },
    { { AXRole_names + 2338, 22 }, 193 },
    { { AXRole_names + 2360, 18 }, 194 },
    { { AXRole_names + 2378, 32 }, 195 },
    { { AXRole_names + 2410, 18 }, 196 },
    { { AXRole_names + 2428, 17 }, 197 },
    { { AXRole_names + 2445, 24 }, 198 },
    { { AXRole_names + 2469, 27 }, 199 },
    { { AXRole_names + 2496, 17 }, 200 },
    { { AXRole_names + 2513, 20 }, 201 },
    { { AXRole_names + 2533, 17 }, 202 },
    { { AXRole_names + 2550, 19 }, 203 },
    { { AXRole_names + 2569, 23 }, 204 },
    { { AXRole_names + 2592, 22 }, 205 },
    { { AXRole_names + 2614, 18 }, 206 },
    { { AXRole_names + 2632, 19 }, 207 },
    { { AXRole_names + 2651, 23 }, 208 },
    { { AXRole_names + 2674, 12 }, 122 },
    { { AXRole_names + 2686, 15 }, 123 },
    { { AXRole_names + 2701, 16 }, 124 },
    { { AXRole_names + 2717, 24 }, 125 },
    { { AXRole_names + 2741, 21 }, 126 },
    { { AXRole_names + 2762, 22 }, 127 },
    { { AXRole_names + 2784, 21 }, 128 },
    { { AXRole_names + 2805, 13 }, 129 },
    { { AXRole_names + 2818, 18 }, 130 },
    { { AXRole_names + 2836, 12 }, 0 },
    { { AXRole_names + 2848, 12 }, 131 },
    { { AXRole_names + 2860, 12 }, 132 },
    { { AXRole_names + 2872, 17 }, 133 },
    { { AXRole_names + 2889, 30 }, 134 },
    { { AXRole_names + 2919, 15 }, 135 },
    { { AXRole_names + 2934, 20 }, 136 },
    { { AXRole_names + 2954, 19 }, 137 },
    { { AXRole_names + 2973, 24 }, 138 },
    { { AXRole_names + 2997, 21 }, 139 },
    { { AXRole_names + 3018, 25 }, 140 },
    { { AXRole_names + 3043, 19 }, 141 },
    { { AXRole_names + 3062, 18 }, 142 },
    { { AXRole_names + 3080, 14 }, 143 },
    { { AXRole_names + 3094, 19 }, 144 },
    { { AXRole_names + 3113, 11 }, 145 },
    { { AXRole_names + 3124, 16 }, 146 },
    { { AXRole_names + 3140, 17 }, 147 },
    { { AXRole_names + 3157, 12 }, 148 },
    { { AXRole_names + 3169, 22 }, 149 },
    { { AXRole_names + 3191, 17 }, 150 },
    { { AXRole_names + 3208, 18 }, 151 },
    { { AXRole_names + 3226, 14 }, 152 },
    { { AXRole_names + 3240, 17 }, 153 },
    { { AXRole_names + 3257, 15 }, 154 },
    { { AXRole_names + 3272, 21 }, 86 },
    { { AXRole_names + 3293, 21 }, 95 },
    { { AXRole_names + 3314, 26 }, 211 },
    { { AXRole_names + 3340, 14 }, 155 },
    { { AXRole_names + 3354, 18 }, 156 },
    { { AXRole_names + 3372, 16 }, 157 },
    { { AXRole_names + 3388, 18 }, 158 },
    { { AXRole_names + 3406, 14 }, 159 },
    { { AXRole_names + 3420, 14 }, 160 },
    { { AXRole_names + 3434, 17 }, 185 },
    { { AXRole_names + 3451, 18 }, 161 },
    { { AXRole_names + 3469, 19 }, 186 },
    { { AXRole_names + 3488, 15 }, 162 },
    { { AXRole_names + 3503, 14 }, 163 },
    { { AXRole_names + 3517, 11 }, 164 },
    { { AXRole_names + 3528, 13 }, 167 },
    { { AXRole_names + 3541, 28 }, 168 },
    { { AXRole_names + 3569, 15 }, 165 },
    { { AXRole_names + 3584, 16 }, 166 },
    { { AXRole_names + 3600, 12 }, 169 },
    { { AXRole_names + 3612, 17 }, 170 },
    { { AXRole_names + 3629, 29 }, 171 },
    { { AXRole_names + 3658, 12 }, 172 },
    { { AXRole_names + 3670, 13 }, 173 },
    { { AXRole_names + 3683, 16 }, 174 },
    { { AXRole_names + 3699, 20 }, 175 },
    { { AXRole_names + 3719, 15 }, 176 },
    { { AXRole_names + 3734, 15 }, 177 },
    { { AXRole_names + 3749, 12 }, 178 },
    { { AXRole_names + 3761, 16 }, 179 },
    { { AXRole_names + 3777, 16 }, 180 },
    { { AXRole_names + 3793, 15 }, 181 },
    { { AXRole_names + 3808, 13 }, 182 },
    { { AXRole_names + 3821, 15 }, 183 },
    { { AXRole_names + 3836, 14 }, 184 },
};

static const int AXRole_entries_by_number[] = {
    153, // 0 -> AX_ROLE_NONE
    0, // 1 -> AX_ROLE_ABBR
    1, // 2 -> AX_ROLE_ALERT
    2, // 3 -> AX_ROLE_ALERTDIALOG
    3, // 4 -> AX_ROLE_APPLICATION
    4, // 5 -> AX_ROLE_ARTICLE
    5, // 6 -> AX_ROLE_AUDIO
    6, // 7 -> AX_ROLE_BANNER
    7, // 8 -> AX_ROLE_BLOCKQUOTE
    8, // 9 -> AX_ROLE_BUTTON
    9, // 10 -> AX_ROLE_CANVAS
    10, // 11 -> AX_ROLE_CAPTION
    11, // 12 -> AX_ROLE_CARET
    12, // 13 -> AX_ROLE_CELL
    13, // 14 -> AX_ROLE_CHECKBOX
    14, // 15 -> AX_ROLE_CLIENT
    15, // 16 -> AX_ROLE_CODE
    16, // 17 -> AX_ROLE_COLORWELL
    17, // 18 -> AX_ROLE_COLUMN
    18, // 19 -> AX_ROLE_COLUMNHEADER
    19, // 20 -> AX_ROLE_COMBOBOXGROUPING
    20, // 21 -> AX_ROLE_COMBOBOXMENUBUTTON
    23, // 22 -> AX_ROLE_COMPLEMENTARY
    22, // 23 -> AX_ROLE_COMMENT
    24, // 24 -> AX_ROLE_CONTENTDELETION
    26, // 25 -> AX_ROLE_CONTENTINSERTION
    25, // 26 -> AX_ROLE_CONTENTINFO
    27, // 27 -> AX_ROLE_DATE
    28, // 28 -> AX_ROLE_DATETIME
    29, // 29 -> AX_ROLE_DEFINITION
    30, // 30 -> AX_ROLE_DESCRIPTIONLIST
    31, // 31 -> AX_ROLE_DESCRIPTIONLISTDETAILDEPRECATED
    32, // 32 -> AX_ROLE_DESCRIPTIONLISTTERMDEPRECATED
    33, // 33 -> AX_ROLE_DESKTOP
    34, // 34 -> AX_ROLE_DETAILS
    35, // 35 -> AX_ROLE_DIALOG
    36, // 36 -> AX_ROLE_DIRECTORYDEPRECATED
    37, // 37 -> AX_ROLE_DISCLOSURETRIANGLE
    39, // 38 -> AX_ROLE_DOCABSTRACT
    40, // 39 -> AX_ROLE_DOCACKNOWLEDGMENTS
    41, // 40 -> AX_ROLE_DOCAFTERWORD
    42, // 41 -> AX_ROLE_DOCAPPENDIX
    43, // 42 -> AX_ROLE_DOCBACKLINK
    44, // 43 -> AX_ROLE_DOCBIBLIOENTRY
    45, // 44 -> AX_ROLE_DOCBIBLIOGRAPHY
    46, // 45 -> AX_ROLE_DOCBIBLIOREF
    47, // 46 -> AX_ROLE_DOCCHAPTER
    48, // 47 -> AX_ROLE_DOCCOLOPHON
    49, // 48 -> AX_ROLE_DOCCONCLUSION
    50, // 49 -> AX_ROLE_DOCCOVER
    51, // 50 -> AX_ROLE_DOCCREDIT
    52, // 51 -> AX_ROLE_DOCCREDITS
    53, // 52 -> AX_ROLE_DOCDEDICATION
    54, // 53 -> AX_ROLE_DOCENDNOTE
    55, // 54 -> AX_ROLE_DOCENDNOTES
    56, // 55 -> AX_ROLE_DOCEPIGRAPH
    57, // 56 -> AX_ROLE_DOCEPILOGUE
    58, // 57 -> AX_ROLE_DOCERRATA
    59, // 58 -> AX_ROLE_DOCEXAMPLE
    60, // 59 -> AX_ROLE_DOCFOOTNOTE
    61, // 60 -> AX_ROLE_DOCFOREWORD
    62, // 61 -> AX_ROLE_DOCGLOSSARY
    63, // 62 -> AX_ROLE_DOCGLOSSREF
    64, // 63 -> AX_ROLE_DOCINDEX
    65, // 64 -> AX_ROLE_DOCINTRODUCTION
    66, // 65 -> AX_ROLE_DOCNOTEREF
    67, // 66 -> AX_ROLE_DOCNOTICE
    68, // 67 -> AX_ROLE_DOCPAGEBREAK
    69, // 68 -> AX_ROLE_DOCPAGEFOOTER
    70, // 69 -> AX_ROLE_DOCPAGEHEADER
    71, // 70 -> AX_ROLE_DOCPAGELIST
    72, // 71 -> AX_ROLE_DOCPART
    73, // 72 -> AX_ROLE_DOCPREFACE
    74, // 73 -> AX_ROLE_DOCPROLOGUE
    75, // 74 -> AX_ROLE_DOCPULLQUOTE
    76, // 75 -> AX_ROLE_DOCQNA
    77, // 76 -> AX_ROLE_DOCSUBTITLE
    78, // 77 -> AX_ROLE_DOCTIP
    79, // 78 -> AX_ROLE_DOCTOC
    80, // 79 -> AX_ROLE_DOCUMENT
    81, // 80 -> AX_ROLE_EMBEDDEDOBJECT
    82, // 81 -> AX_ROLE_EMPHASIS
    83, // 82 -> AX_ROLE_FEED
    84, // 83 -> AX_ROLE_FIGCAPTION
    85, // 84 -> AX_ROLE_FIGURE
    86, // 85 -> AX_ROLE_FOOTER
    178, // 86 -> AX_ROLE_SECTIONFOOTER
    87, // 87 -> AX_ROLE_FORM
    88, // 88 -> AX_ROLE_GENERICCONTAINER
    89, // 89 -> AX_ROLE_GRAPHICSDOCUMENT
    90, // 90 -> AX_ROLE_GRAPHICSOBJECT
    91, // 91 -> AX_ROLE_GRAPHICSSYMBOL
    92, // 92 -> AX_ROLE_GRID
    94, // 93 -> AX_ROLE_GROUP
    95, // 94 -> AX_ROLE_HEADER
    179, // 95 -> AX_ROLE_SECTIONHEADER
    96, // 96 -> AX_ROLE_HEADING
    97, // 97 -> AX_ROLE_IFRAME
    98, // 98 -> AX_ROLE_IFRAMEPRESENTATIONAL
    99, // 99 -> AX_ROLE_IMAGE
    100, // 100 -> AX_ROLE_IMECANDIDATE
    101, // 101 -> AX_ROLE_INLINETEXTBOX
    102, // 102 -> AX_ROLE_INPUTTIME
    103, // 103 -> AX_ROLE_KEYBOARD
    104, // 104 -> AX_ROLE_LABELTEXT
    105, // 105 -> AX_ROLE_LAYOUTTABLE
    106, // 106 -> AX_ROLE_LAYOUTTABLECELL
    107, // 107 -> AX_ROLE_LAYOUTTABLEROW
    108, // 108 -> AX_ROLE_LEGEND
    109, // 109 -> AX_ROLE_LINEBREAK
    110, // 110 -> AX_ROLE_LINK
    111, // 111 -> AX_ROLE_LIST
    112, // 112 -> AX_ROLE_LISTBOX
    113, // 113 -> AX_ROLE_LISTBOXOPTION
    114, // 114 -> AX_ROLE_LISTGRID
    115, // 115 -> AX_ROLE_LISTITEM
    116, // 116 -> AX_ROLE_LISTMARKER
    117, // 117 -> AX_ROLE_LOG
    118, // 118 -> AX_ROLE_MAIN
    119, // 119 -> AX_ROLE_MARK
    120, // 120 -> AX_ROLE_MARQUEE
    121, // 121 -> AX_ROLE_MATH
    144, // 122 -> AX_ROLE_MENU
    145, // 123 -> AX_ROLE_MENUBAR
    146, // 124 -> AX_ROLE_MENUITEM
    147, // 125 -> AX_ROLE_MENUITEMCHECKBOX
    148, // 126 -> AX_ROLE_MENUITEMRADIO
    149, // 127 -> AX_ROLE_MENULISTOPTION
    150, // 128 -> AX_ROLE_MENULISTPOPUP
    151, // 129 -> AX_ROLE_METER
    152, // 130 -> AX_ROLE_NAVIGATION
    154, // 131 -> AX_ROLE_NOTE
    155, // 132 -> AX_ROLE_PANE
    156, // 133 -> AX_ROLE_PARAGRAPH
    157, // 134 -> AX_ROLE_PDFACTIONABLEHIGHLIGHT
    158, // 135 -> AX_ROLE_PDFROOT
    159, // 136 -> AX_ROLE_PLUGINOBJECT
    160, // 137 -> AX_ROLE_POPUPBUTTON
    161, // 138 -> AX_ROLE_PORTALDEPRECATED
    162, // 139 -> AX_ROLE_PREDEPRECATED
    163, // 140 -> AX_ROLE_PROGRESSINDICATOR
    164, // 141 -> AX_ROLE_RADIOBUTTON
    165, // 142 -> AX_ROLE_RADIOGROUP
    166, // 143 -> AX_ROLE_REGION
    167, // 144 -> AX_ROLE_ROOTWEBAREA
    168, // 145 -> AX_ROLE_ROW
    169, // 146 -> AX_ROLE_ROWGROUP
    170, // 147 -> AX_ROLE_ROWHEADER
    171, // 148 -> AX_ROLE_RUBY
    172, // 149 -> AX_ROLE_RUBYANNOTATION
    173, // 150 -> AX_ROLE_SCROLLBAR
    174, // 151 -> AX_ROLE_SCROLLVIEW
    175, // 152 -> AX_ROLE_SEARCH
    176, // 153 -> AX_ROLE_SEARCHBOX
    177, // 154 -> AX_ROLE_SECTION
    181, // 155 -> AX_ROLE_SLIDER
    182, // 156 -> AX_ROLE_SPINBUTTON
    183, // 157 -> AX_ROLE_SPLITTER
    184, // 158 -> AX_ROLE_STATICTEXT
    185, // 159 -> AX_ROLE_STATUS
    186, // 160 -> AX_ROLE_STRONG
    188, // 161 -> AX_ROLE_SUGGESTION
    190, // 162 -> AX_ROLE_SVGROOT
    191, // 163 -> AX_ROLE_SWITCH
    192, // 164 -> AX_ROLE_TAB
    195, // 165 -> AX_ROLE_TABLIST
    196, // 166 -> AX_ROLE_TABPANEL
    193, // 167 -> AX_ROLE_TABLE
    194, // 168 -> AX_ROLE_TABLEHEADERCONTAINER
    197, // 169 -> AX_ROLE_TERM
    198, // 170 -> AX_ROLE_TEXTFIELD
    199, // 171 -> AX_ROLE_TEXTFIELDWITHCOMBOBOX
    200, // 172 -> AX_ROLE_TIME
    201, // 173 -> AX_ROLE_TIMER
    202, // 174 -> AX_ROLE_TITLEBAR
    203, // 175 -> AX_ROLE_TOGGLEBUTTON
    204, // 176 -> AX_ROLE_TOOLBAR
    205, // 177 -> AX_ROLE_TOOLTIP
    206, // 178 -> AX_ROLE_TREE
    207, // 179 -> AX_ROLE_TREEGRID
    208, // 180 -> AX_ROLE_TREEITEM
    209, // 181 -> AX_ROLE_UNKNOWN
    210, // 182 -> AX_ROLE_VIDEO
    211, // 183 -> AX_ROLE_WEBVIEW
    212, // 184 -> AX_ROLE_WINDOW
    187, // 185 -> AX_ROLE_SUBSCRIPT
    189, // 186 -> AX_ROLE_SUPERSCRIPT
    124, // 187 -> AX_ROLE_MATHMLMATH
    122, // 188 -> AX_ROLE_MATHMLFRACTION
    123, // 189 -> AX_ROLE_MATHMLIDENTIFIER
    125, // 190 -> AX_ROLE_MATHMLMULTISCRIPTS
    126, // 191 -> AX_ROLE_MATHMLNONESCRIPT
    127, // 192 -> AX_ROLE_MATHMLNUMBER
    128, // 193 -> AX_ROLE_MATHMLOPERATOR
    129, // 194 -> AX_ROLE_MATHMLOVER
    130, // 195 -> AX_ROLE_MATHMLPRESCRIPTDELIMITER
    131, // 196 -> AX_ROLE_MATHMLROOT
    132, // 197 -> AX_ROLE_MATHMLROW
    133, // 198 -> AX_ROLE_MATHMLSQUAREROOT
    134, // 199 -> AX_ROLE_MATHMLSTRINGLITERAL
    135, // 200 -> AX_ROLE_MATHMLSUB
    136, // 201 -> AX_ROLE_MATHMLSUBSUP
    137, // 202 -> AX_ROLE_MATHMLSUP
    138, // 203 -> AX_ROLE_MATHMLTABLE
    139, // 204 -> AX_ROLE_MATHMLTABLECELL
    140, // 205 -> AX_ROLE_MATHMLTABLEROW
    141, // 206 -> AX_ROLE_MATHMLTEXT
    142, // 207 -> AX_ROLE_MATHMLUNDER
    143, // 208 -> AX_ROLE_MATHMLUNDEROVER
    21, // 209 -> AX_ROLE_COMBOBOXSELECT
    38, // 210 -> AX_ROLE_DISCLOSURETRIANGLEGROUPED
    180, // 211 -> AX_ROLE_SECTIONWITHOUTNAME
    93, // 212 -> AX_ROLE_GRIDCELL
};

const std::string& AXRole_Name(AXRole value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(AXRole_entries, AXRole_entries_by_number, 213, AXRole_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(AXRole_entries, AXRole_entries_by_number, 213, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : AXRole_strings[idx].get();
}
bool AXRole_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AXRole* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(AXRole_entries, 213, name, &int_value);
    if (success) {
        *value = static_cast<AXRole>(int_value);
    }
    return success;
}
bool AXStringAttribute_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> AXStringAttribute_strings[43] = {};

static const char AXStringAttribute_names[] = "AX_SA_ACCESSKEY"
                                              "AX_SA_APPID"
                                              "AX_SA_ARIABRAILLELABEL"
                                              "AX_SA_ARIABRAILLEROLEDESCRIPTION"
                                              "AX_SA_ARIACELLCOLUMNINDEXTEXT"
                                              "AX_SA_ARIACELLROWINDEXTEXT"
                                              "AX_SA_ARIAINVALIDVALUEDEPRECATED"
                                              "AX_SA_ARIANOTIFICATIONANNOUNCEMENTDEPRECATED"
                                              "AX_SA_ARIANOTIFICATIONIDDEPRECATED"
                                              "AX_SA_AUTOCOMPLETE"
                                              "AX_SA_CHECKEDSTATEDESCRIPTION"
                                              "AX_SA_CHILDTREEID"
                                              "AX_SA_CHILDTREENODEAPPID"
                                              "AX_SA_CLASSNAME"
                                              "AX_SA_CONTAINERLIVERELEVANT"
                                              "AX_SA_CONTAINERLIVESTATUS"
                                              "AX_SA_DATETIME"
                                              "AX_SA_DESCRIPTION"
                                              "AX_SA_DISPLAY"
                                              "AX_SA_DODEFAULTLABEL"
                                              "AX_SA_FONTFAMILY"
                                              "AX_SA_HTMLID"
                                              "AX_SA_HTMLINPUTNAME"
                                              "AX_SA_HTMLTAG"
                                              "AX_SA_IMAGEANNOTATION"
                                              "AX_SA_IMAGEDATAURL"
                                              "AX_SA_INPUTTYPE"
                                              "AX_SA_KEYSHORTCUTS"
                                              "AX_SA_LANGUAGE"
                                              "AX_SA_LINKTARGET"
                                              "AX_SA_LIVERELEVANT"
                                              "AX_SA_LIVESTATUS"
                                              "AX_SA_LONGCLICKLABEL"
                                              "AX_SA_MATHCONTENT"
                                              "AX_SA_NAME"
                                              "AX_SA_NONE"
                                              "AX_SA_PLACEHOLDER"
                                              "AX_SA_ROLE"
                                              "AX_SA_ROLEDESCRIPTION"
                                              "AX_SA_TOOLTIP"
                                              "AX_SA_URL"
                                              "AX_SA_VALUE"
                                              "AX_SA_VIRTUALCONTENT";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry AXStringAttribute_entries[] = {
    { { AXStringAttribute_names + 0, 15 }, 1 },
    { { AXStringAttribute_names + 15, 11 }, 2 },
    { { AXStringAttribute_names + 26, 22 }, 33 },
    { { AXStringAttribute_names + 48, 32 }, 34 },
    { { AXStringAttribute_names + 80, 29 }, 39 },
    { { AXStringAttribute_names + 109, 26 }, 40 },
    { { AXStringAttribute_names + 135, 32 }, 3 },
    { { AXStringAttribute_names + 167, 44 }, 36 },
    { { AXStringAttribute_names + 211, 34 }, 37 },
    { { AXStringAttribute_names + 245, 18 }, 4 },
    { { AXStringAttribute_names + 263, 29 }, 5 },
    { { AXStringAttribute_names + 292, 17 }, 6 },
    { { AXStringAttribute_names + 309, 24 }, 7 },
    { { AXStringAttribute_names + 333, 15 }, 8 },
    { { AXStringAttribute_names + 348, 27 }, 9 },
    { { AXStringAttribute_names + 375, 25 }, 10 },
    { { AXStringAttribute_names + 400, 14 }, 41 },
    { { AXStringAttribute_names + 414, 17 }, 11 },
    { { AXStringAttribute_names + 431, 13 }, 12 },
    { { AXStringAttribute_names + 444, 20 }, 31 },
    { { AXStringAttribute_names + 464, 16 }, 13 },
    { { AXStringAttribute_names + 480, 12 }, 38 },
    { { AXStringAttribute_names + 492, 19 }, 42 },
    { { AXStringAttribute_names + 511, 13 }, 14 },
    { { AXStringAttribute_names + 524, 21 }, 15 },
    { { AXStringAttribute_names + 545, 18 }, 16 },
    { { AXStringAttribute_names + 563, 15 }, 18 },
    { { AXStringAttribute_names + 578, 18 }, 19 },
    { { AXStringAttribute_names + 596, 14 }, 20 },
    { { AXStringAttribute_names + 610, 16 }, 35 },
    { { AXStringAttribute_names + 626, 18 }, 22 },
    { { AXStringAttribute_names + 644, 16 }, 23 },
    { { AXStringAttribute_names + 660, 20 }, 32 },
    { { AXStringAttribute_names + 680, 17 }, 17 },
    { { AXStringAttribute_names + 697, 10 }, 21 },
    { { AXStringAttribute_names + 707, 10 }, 0 },
    { { AXStringAttribute_names + 717, 17 }, 24 },
    { { AXStringAttribute_names + 734, 10 }, 25 },
    { { AXStringAttribute_names + 744, 21 }, 26 },
    { { AXStringAttribute_names + 765, 13 }, 27 },
    { { AXStringAttribute_names + 778, 9 }, 28 },
    { { AXStringAttribute_names + 787, 11 }, 29 },
    { { AXStringAttribute_names + 798, 20 }, 30 },
};

static const int AXStringAttribute_entries_by_number[] = {
    35, // 0 -> AX_SA_NONE
    0, // 1 -> AX_SA_ACCESSKEY
    1, // 2 -> AX_SA_APPID
    6, // 3 -> AX_SA_ARIAINVALIDVALUEDEPRECATED
    9, // 4 -> AX_SA_AUTOCOMPLETE
    10, // 5 -> AX_SA_CHECKEDSTATEDESCRIPTION
    11, // 6 -> AX_SA_CHILDTREEID
    12, // 7 -> AX_SA_CHILDTREENODEAPPID
    13, // 8 -> AX_SA_CLASSNAME
    14, // 9 -> AX_SA_CONTAINERLIVERELEVANT
    15, // 10 -> AX_SA_CONTAINERLIVESTATUS
    17, // 11 -> AX_SA_DESCRIPTION
    18, // 12 -> AX_SA_DISPLAY
    20, // 13 -> AX_SA_FONTFAMILY
    23, // 14 -> AX_SA_HTMLTAG
    24, // 15 -> AX_SA_IMAGEANNOTATION
    25, // 16 -> AX_SA_IMAGEDATAURL
    33, // 17 -> AX_SA_MATHCONTENT
    26, // 18 -> AX_SA_INPUTTYPE
    27, // 19 -> AX_SA_KEYSHORTCUTS
    28, // 20 -> AX_SA_LANGUAGE
    34, // 21 -> AX_SA_NAME
    30, // 22 -> AX_SA_LIVERELEVANT
    31, // 23 -> AX_SA_LIVESTATUS
    36, // 24 -> AX_SA_PLACEHOLDER
    37, // 25 -> AX_SA_ROLE
    38, // 26 -> AX_SA_ROLEDESCRIPTION
    39, // 27 -> AX_SA_TOOLTIP
    40, // 28 -> AX_SA_URL
    41, // 29 -> AX_SA_VALUE
    42, // 30 -> AX_SA_VIRTUALCONTENT
    19, // 31 -> AX_SA_DODEFAULTLABEL
    32, // 32 -> AX_SA_LONGCLICKLABEL
    2, // 33 -> AX_SA_ARIABRAILLELABEL
    3, // 34 -> AX_SA_ARIABRAILLEROLEDESCRIPTION
    29, // 35 -> AX_SA_LINKTARGET
    7, // 36 -> AX_SA_ARIANOTIFICATIONANNOUNCEMENTDEPRECATED
    8, // 37 -> AX_SA_ARIANOTIFICATIONIDDEPRECATED
    21, // 38 -> AX_SA_HTMLID
    4, // 39 -> AX_SA_ARIACELLCOLUMNINDEXTEXT
    5, // 40 -> AX_SA_ARIACELLROWINDEXTEXT
    16, // 41 -> AX_SA_DATETIME
    22, // 42 -> AX_SA_HTMLINPUTNAME
};

const std::string& AXStringAttribute_Name(AXStringAttribute value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        AXStringAttribute_entries, AXStringAttribute_entries_by_number, 43, AXStringAttribute_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(AXStringAttribute_entries, AXStringAttribute_entries_by_number, 43, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : AXStringAttribute_strings[idx].get();
}
bool AXStringAttribute_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AXStringAttribute* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(AXStringAttribute_entries, 43, name, &int_value);
    if (success) {
        *value = static_cast<AXStringAttribute>(int_value);
    }
    return success;
}
bool AXIntAttribute_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 65:
    case 66:
    case 67:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> AXIntAttribute_strings[68] = {};

static const char AXIntAttribute_names[] = "AX_IA_ACTIVEDESCENDANTID"
                                           "AX_IA_ARIACELLCOLUMNINDEX"
                                           "AX_IA_ARIACELLCOLUMNSPAN"
                                           "AX_IA_ARIACELLROWINDEX"
                                           "AX_IA_ARIACELLROWSPAN"
                                           "AX_IA_ARIACOLUMNCOUNT"
                                           "AX_IA_ARIACURRENTSTATE"
                                           "AX_IA_ARIANOTIFICATIONINTERRUPTDEPRECATED"
                                           "AX_IA_ARIANOTIFICATIONPRIORITYDEPRECATED"
                                           "AX_IA_ARIAROWCOUNT"
                                           "AX_IA_BACKGROUNDCOLOR"
                                           "AX_IA_CHECKEDSTATE"
                                           "AX_IA_COLOR"
                                           "AX_IA_COLORVALUE"
                                           "AX_IA_DEFAULTACTIONVERB"
                                           "AX_IA_DESCRIPTIONFROM"
                                           "AX_IA_DETAILSFROM"
                                           "AX_IA_DOMNODEIDDEPRECATED"
                                           "AX_IA_DROPEFFECTDEPRECATED"
                                           "AX_IA_ERRORMESSAGEIDDEPRECATED"
                                           "AX_IA_HASPOPUP"
                                           "AX_IA_HIERARCHICALLEVEL"
                                           "AX_IA_IMAGEANNOTATIONSTATUS"
                                           "AX_IA_INPAGELINKTARGETID"
                                           "AX_IA_INVALIDSTATE"
                                           "AX_IA_ISPOPUP"
                                           "AX_IA_LISTSTYLE"
                                           "AX_IA_MAXLENGTH"
                                           "AX_IA_MEMBEROFID"
                                           "AX_IA_NAMEFROM"
                                           "AX_IA_NEXTFOCUSID"
                                           "AX_IA_NEXTONLINEID"
                                           "AX_IA_NEXTWINDOWFOCUSID"
                                           "AX_IA_NONE"
                                           "AX_IA_POPUPFORID"
                                           "AX_IA_POSINSET"
                                           "AX_IA_PREVIOUSFOCUSID"
                                           "AX_IA_PREVIOUSONLINEID"
                                           "AX_IA_PREVIOUSWINDOWFOCUSID"
                                           "AX_IA_RESTRICTION"
                                           "AX_IA_SCROLLX"
                                           "AX_IA_SCROLLXMAX"
                                           "AX_IA_SCROLLXMIN"
                                           "AX_IA_SCROLLY"
                                           "AX_IA_SCROLLYMAX"
                                           "AX_IA_SCROLLYMIN"
                                           "AX_IA_SETSIZE"
                                           "AX_IA_SORTDIRECTION"
                                           "AX_IA_TABLECELLCOLUMNINDEX"
                                           "AX_IA_TABLECELLCOLUMNSPAN"
                                           "AX_IA_TABLECELLROWINDEX"
                                           "AX_IA_TABLECELLROWSPAN"
                                           "AX_IA_TABLECOLUMNCOUNT"
                                           "AX_IA_TABLECOLUMNHEADERID"
                                           "AX_IA_TABLECOLUMNINDEX"
                                           "AX_IA_TABLEHEADERID"
                                           "AX_IA_TABLEROWCOUNT"
                                           "AX_IA_TABLEROWHEADERID"
                                           "AX_IA_TABLEROWINDEX"
                                           "AX_IA_TEXTALIGN"
                                           "AX_IA_TEXTDIRECTION"
                                           "AX_IA_TEXTOVERLINESTYLE"
                                           "AX_IA_TEXTPOSITION"
                                           "AX_IA_TEXTSELEND"
                                           "AX_IA_TEXTSELSTART"
                                           "AX_IA_TEXTSTRIKETHROUGHSTYLE"
                                           "AX_IA_TEXTSTYLE"
                                           "AX_IA_TEXTUNDERLINESTYLE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry AXIntAttribute_entries[] = {
    { { AXIntAttribute_names + 0, 24 }, 31 },
    { { AXIntAttribute_names + 24, 25 }, 11 },
    { { AXIntAttribute_names + 49, 24 }, 12 },
    { { AXIntAttribute_names + 73, 22 }, 14 },
    { { AXIntAttribute_names + 95, 21 }, 15 },
    { { AXIntAttribute_names + 116, 21 }, 10 },
    { { AXIntAttribute_names + 137, 22 }, 42 },
    { { AXIntAttribute_names + 159, 41 }, 64 },
    { { AXIntAttribute_names + 200, 40 }, 65 },
    { { AXIntAttribute_names + 240, 18 }, 13 },
    { { AXIntAttribute_names + 258, 21 }, 43 },
    { { AXIntAttribute_names + 279, 18 }, 48 },
    { { AXIntAttribute_names + 297, 11 }, 44 },
    { { AXIntAttribute_names + 308, 16 }, 41 },
    { { AXIntAttribute_names + 324, 23 }, 1 },
    { { AXIntAttribute_names + 347, 21 }, 30 },
    { { AXIntAttribute_names + 368, 17 }, 66 },
    { { AXIntAttribute_names + 385, 25 }, 60 },
    { { AXIntAttribute_names + 410, 26 }, 59 },
    { { AXIntAttribute_names + 436, 30 }, 32 },
    { { AXIntAttribute_names + 466, 14 }, 45 },
    { { AXIntAttribute_names + 480, 23 }, 28 },
    { { AXIntAttribute_names + 503, 27 }, 46 },
    { { AXIntAttribute_names + 530, 24 }, 33 },
    { { AXIntAttribute_names + 554, 18 }, 47 },
    { { AXIntAttribute_names + 572, 13 }, 61 },
    { { AXIntAttribute_names + 585, 15 }, 49 },
    { { AXIntAttribute_names + 600, 15 }, 67 },
    { { AXIntAttribute_names + 615, 16 }, 34 },
    { { AXIntAttribute_names + 631, 14 }, 29 },
    { { AXIntAttribute_names + 645, 17 }, 58 },
    { { AXIntAttribute_names + 662, 18 }, 35 },
    { { AXIntAttribute_names + 680, 23 }, 62 },
    { { AXIntAttribute_names + 703, 10 }, 0 },
    { { AXIntAttribute_names + 713, 16 }, 36 },
    { { AXIntAttribute_names + 729, 14 }, 40 },
    { { AXIntAttribute_names + 743, 21 }, 57 },
    { { AXIntAttribute_names + 764, 22 }, 37 },
    { { AXIntAttribute_names + 786, 27 }, 63 },
    { { AXIntAttribute_names + 813, 17 }, 38 },
    { { AXIntAttribute_names + 830, 13 }, 2 },
    { { AXIntAttribute_names + 843, 16 }, 4 },
    { { AXIntAttribute_names + 859, 16 }, 3 },
    { { AXIntAttribute_names + 875, 13 }, 5 },
    { { AXIntAttribute_names + 888, 16 }, 7 },
    { { AXIntAttribute_names + 904, 16 }, 6 },
    { { AXIntAttribute_names + 920, 13 }, 39 },
    { { AXIntAttribute_names + 933, 19 }, 27 },
    { { AXIntAttribute_names + 952, 26 }, 23 },
    { { AXIntAttribute_names + 978, 25 }, 24 },
    { { AXIntAttribute_names + 1003, 23 }, 25 },
    { { AXIntAttribute_names + 1026, 22 }, 26 },
    { { AXIntAttribute_names + 1048, 22 }, 17 },
    { { AXIntAttribute_names + 1070, 25 }, 22 },
    { { AXIntAttribute_names + 1095, 22 }, 21 },
    { { AXIntAttribute_names + 1117, 19 }, 18 },
    { { AXIntAttribute_names + 1136, 19 }, 16 },
    { { AXIntAttribute_names + 1155, 22 }, 20 },
    { { AXIntAttribute_names + 1177, 19 }, 19 },
    { { AXIntAttribute_names + 1196, 15 }, 50 },
    { { AXIntAttribute_names + 1211, 19 }, 51 },
    { { AXIntAttribute_names + 1230, 23 }, 54 },
    { { AXIntAttribute_names + 1253, 18 }, 52 },
    { { AXIntAttribute_names + 1271, 16 }, 9 },
    { { AXIntAttribute_names + 1287, 18 }, 8 },
    { { AXIntAttribute_names + 1305, 28 }, 55 },
    { { AXIntAttribute_names + 1333, 15 }, 53 },
    { { AXIntAttribute_names + 1348, 24 }, 56 },
};

static const int AXIntAttribute_entries_by_number[] = {
    33, // 0 -> AX_IA_NONE
    14, // 1 -> AX_IA_DEFAULTACTIONVERB
    40, // 2 -> AX_IA_SCROLLX
    42, // 3 -> AX_IA_SCROLLXMIN
    41, // 4 -> AX_IA_SCROLLXMAX
    43, // 5 -> AX_IA_SCROLLY
    45, // 6 -> AX_IA_SCROLLYMIN
    44, // 7 -> AX_IA_SCROLLYMAX
    64, // 8 -> AX_IA_TEXTSELSTART
    63, // 9 -> AX_IA_TEXTSELEND
    5, // 10 -> AX_IA_ARIACOLUMNCOUNT
    1, // 11 -> AX_IA_ARIACELLCOLUMNINDEX
    2, // 12 -> AX_IA_ARIACELLCOLUMNSPAN
    9, // 13 -> AX_IA_ARIAROWCOUNT
    3, // 14 -> AX_IA_ARIACELLROWINDEX
    4, // 15 -> AX_IA_ARIACELLROWSPAN
    56, // 16 -> AX_IA_TABLEROWCOUNT
    52, // 17 -> AX_IA_TABLECOLUMNCOUNT
    55, // 18 -> AX_IA_TABLEHEADERID
    58, // 19 -> AX_IA_TABLEROWINDEX
    57, // 20 -> AX_IA_TABLEROWHEADERID
    54, // 21 -> AX_IA_TABLECOLUMNINDEX
    53, // 22 -> AX_IA_TABLECOLUMNHEADERID
    48, // 23 -> AX_IA_TABLECELLCOLUMNINDEX
    49, // 24 -> AX_IA_TABLECELLCOLUMNSPAN
    50, // 25 -> AX_IA_TABLECELLROWINDEX
    51, // 26 -> AX_IA_TABLECELLROWSPAN
    47, // 27 -> AX_IA_SORTDIRECTION
    21, // 28 -> AX_IA_HIERARCHICALLEVEL
    29, // 29 -> AX_IA_NAMEFROM
    15, // 30 -> AX_IA_DESCRIPTIONFROM
    0, // 31 -> AX_IA_ACTIVEDESCENDANTID
    19, // 32 -> AX_IA_ERRORMESSAGEIDDEPRECATED
    23, // 33 -> AX_IA_INPAGELINKTARGETID
    28, // 34 -> AX_IA_MEMBEROFID
    31, // 35 -> AX_IA_NEXTONLINEID
    34, // 36 -> AX_IA_POPUPFORID
    37, // 37 -> AX_IA_PREVIOUSONLINEID
    39, // 38 -> AX_IA_RESTRICTION
    46, // 39 -> AX_IA_SETSIZE
    35, // 40 -> AX_IA_POSINSET
    13, // 41 -> AX_IA_COLORVALUE
    6, // 42 -> AX_IA_ARIACURRENTSTATE
    10, // 43 -> AX_IA_BACKGROUNDCOLOR
    12, // 44 -> AX_IA_COLOR
    20, // 45 -> AX_IA_HASPOPUP
    22, // 46 -> AX_IA_IMAGEANNOTATIONSTATUS
    24, // 47 -> AX_IA_INVALIDSTATE
    11, // 48 -> AX_IA_CHECKEDSTATE
    26, // 49 -> AX_IA_LISTSTYLE
    59, // 50 -> AX_IA_TEXTALIGN
    60, // 51 -> AX_IA_TEXTDIRECTION
    62, // 52 -> AX_IA_TEXTPOSITION
    66, // 53 -> AX_IA_TEXTSTYLE
    61, // 54 -> AX_IA_TEXTOVERLINESTYLE
    65, // 55 -> AX_IA_TEXTSTRIKETHROUGHSTYLE
    67, // 56 -> AX_IA_TEXTUNDERLINESTYLE
    36, // 57 -> AX_IA_PREVIOUSFOCUSID
    30, // 58 -> AX_IA_NEXTFOCUSID
    18, // 59 -> AX_IA_DROPEFFECTDEPRECATED
    17, // 60 -> AX_IA_DOMNODEIDDEPRECATED
    25, // 61 -> AX_IA_ISPOPUP
    32, // 62 -> AX_IA_NEXTWINDOWFOCUSID
    38, // 63 -> AX_IA_PREVIOUSWINDOWFOCUSID
    7, // 64 -> AX_IA_ARIANOTIFICATIONINTERRUPTDEPRECATED
    8, // 65 -> AX_IA_ARIANOTIFICATIONPRIORITYDEPRECATED
    16, // 66 -> AX_IA_DETAILSFROM
    27, // 67 -> AX_IA_MAXLENGTH
};

const std::string& AXIntAttribute_Name(AXIntAttribute value)
{
    static const bool dummy
        = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(AXIntAttribute_entries, AXIntAttribute_entries_by_number, 68, AXIntAttribute_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(AXIntAttribute_entries, AXIntAttribute_entries_by_number, 68, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : AXIntAttribute_strings[idx].get();
}
bool AXIntAttribute_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AXIntAttribute* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(AXIntAttribute_entries, 68, name, &int_value);
    if (success) {
        *value = static_cast<AXIntAttribute>(int_value);
    }
    return success;
}
bool AXFloatAttribute_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> AXFloatAttribute_strings[9] = {};

static const char AXFloatAttribute_names[] = "AX_FA_CHILDTREESCALE"
                                             "AX_FA_FONTSIZE"
                                             "AX_FA_FONTWEIGHT"
                                             "AX_FA_MAXVALUEFORRANGE"
                                             "AX_FA_MINVALUEFORRANGE"
                                             "AX_FA_NONE"
                                             "AX_FA_STEPVALUEFORRANGE"
                                             "AX_FA_TEXTINDENT"
                                             "AX_FA_VALUEFORRANGE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry AXFloatAttribute_entries[] = {
    { { AXFloatAttribute_names + 0, 20 }, 8 },
    { { AXFloatAttribute_names + 20, 14 }, 5 },
    { { AXFloatAttribute_names + 34, 16 }, 6 },
    { { AXFloatAttribute_names + 50, 22 }, 3 },
    { { AXFloatAttribute_names + 72, 22 }, 2 },
    { { AXFloatAttribute_names + 94, 10 }, 0 },
    { { AXFloatAttribute_names + 104, 23 }, 4 },
    { { AXFloatAttribute_names + 127, 16 }, 7 },
    { { AXFloatAttribute_names + 143, 19 }, 1 },
};

static const int AXFloatAttribute_entries_by_number[] = {
    5, // 0 -> AX_FA_NONE
    8, // 1 -> AX_FA_VALUEFORRANGE
    4, // 2 -> AX_FA_MINVALUEFORRANGE
    3, // 3 -> AX_FA_MAXVALUEFORRANGE
    6, // 4 -> AX_FA_STEPVALUEFORRANGE
    1, // 5 -> AX_FA_FONTSIZE
    2, // 6 -> AX_FA_FONTWEIGHT
    7, // 7 -> AX_FA_TEXTINDENT
    0, // 8 -> AX_FA_CHILDTREESCALE
};

const std::string& AXFloatAttribute_Name(AXFloatAttribute value)
{
    static const bool dummy
        = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(AXFloatAttribute_entries, AXFloatAttribute_entries_by_number, 9, AXFloatAttribute_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(AXFloatAttribute_entries, AXFloatAttribute_entries_by_number, 9, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : AXFloatAttribute_strings[idx].get();
}
bool AXFloatAttribute_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AXFloatAttribute* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(AXFloatAttribute_entries, 9, name, &int_value);
    if (success) {
        *value = static_cast<AXFloatAttribute>(int_value);
    }
    return success;
}
bool AXBoolAttribute_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> AXBoolAttribute_strings[23] = {};

static const char AXBoolAttribute_names[] = "AX_BA_BUSY"
                                            "AX_BA_CANVASHASFALLBACK"
                                            "AX_BA_CLICKABLE"
                                            "AX_BA_CLIPSCHILDREN"
                                            "AX_BA_CONTAINERLIVEATOMIC"
                                            "AX_BA_CONTAINERLIVEBUSY"
                                            "AX_BA_GRABBEDDEPRECATED"
                                            "AX_BA_HASARIAATTRIBUTE"
                                            "AX_BA_HASHIDDENOFFSCREENNODES"
                                            "AX_BA_ISLINEBREAKINGOBJECT"
                                            "AX_BA_ISPAGEBREAKINGOBJECT"
                                            "AX_BA_LIVEATOMIC"
                                            "AX_BA_LONGCLICKABLE"
                                            "AX_BA_MODAL"
                                            "AX_BA_NONATOMICTEXTFIELDROOT"
                                            "AX_BA_NONE"
                                            "AX_BA_NOTUSERSELECTABLESTYLE"
                                            "AX_BA_SCROLLABLE"
                                            "AX_BA_SELECTED"
                                            "AX_BA_SELECTEDFROMFOCUS"
                                            "AX_BA_SUPPORTSTEXTLOCATION"
                                            "AX_BA_TOUCHPASSTHROUGHDEPRECATED"
                                            "AX_BA_UPDATELOCATIONONLY";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry AXBoolAttribute_entries[] = {
    { { AXBoolAttribute_names + 0, 10 }, 1 },
    { { AXBoolAttribute_names + 10, 23 }, 8 },
    { { AXBoolAttribute_names + 33, 15 }, 10 },
    { { AXBoolAttribute_names + 48, 19 }, 11 },
    { { AXBoolAttribute_names + 67, 25 }, 3 },
    { { AXBoolAttribute_names + 92, 23 }, 4 },
    { { AXBoolAttribute_names + 115, 23 }, 16 },
    { { AXBoolAttribute_names + 138, 22 }, 19 },
    { { AXBoolAttribute_names + 160, 29 }, 22 },
    { { AXBoolAttribute_names + 189, 26 }, 17 },
    { { AXBoolAttribute_names + 215, 26 }, 18 },
    { { AXBoolAttribute_names + 241, 16 }, 5 },
    { { AXBoolAttribute_names + 257, 19 }, 21 },
    { { AXBoolAttribute_names + 276, 11 }, 6 },
    { { AXBoolAttribute_names + 287, 28 }, 2 },
    { { AXBoolAttribute_names + 315, 10 }, 0 },
    { { AXBoolAttribute_names + 325, 28 }, 12 },
    { { AXBoolAttribute_names + 353, 16 }, 9 },
    { { AXBoolAttribute_names + 369, 14 }, 13 },
    { { AXBoolAttribute_names + 383, 23 }, 14 },
    { { AXBoolAttribute_names + 406, 26 }, 15 },
    { { AXBoolAttribute_names + 432, 32 }, 20 },
    { { AXBoolAttribute_names + 464, 24 }, 7 },
};

static const int AXBoolAttribute_entries_by_number[] = {
    15, // 0 -> AX_BA_NONE
    0, // 1 -> AX_BA_BUSY
    14, // 2 -> AX_BA_NONATOMICTEXTFIELDROOT
    4, // 3 -> AX_BA_CONTAINERLIVEATOMIC
    5, // 4 -> AX_BA_CONTAINERLIVEBUSY
    11, // 5 -> AX_BA_LIVEATOMIC
    13, // 6 -> AX_BA_MODAL
    22, // 7 -> AX_BA_UPDATELOCATIONONLY
    1, // 8 -> AX_BA_CANVASHASFALLBACK
    17, // 9 -> AX_BA_SCROLLABLE
    2, // 10 -> AX_BA_CLICKABLE
    3, // 11 -> AX_BA_CLIPSCHILDREN
    16, // 12 -> AX_BA_NOTUSERSELECTABLESTYLE
    18, // 13 -> AX_BA_SELECTED
    19, // 14 -> AX_BA_SELECTEDFROMFOCUS
    20, // 15 -> AX_BA_SUPPORTSTEXTLOCATION
    6, // 16 -> AX_BA_GRABBEDDEPRECATED
    9, // 17 -> AX_BA_ISLINEBREAKINGOBJECT
    10, // 18 -> AX_BA_ISPAGEBREAKINGOBJECT
    7, // 19 -> AX_BA_HASARIAATTRIBUTE
    21, // 20 -> AX_BA_TOUCHPASSTHROUGHDEPRECATED
    12, // 21 -> AX_BA_LONGCLICKABLE
    8, // 22 -> AX_BA_HASHIDDENOFFSCREENNODES
};

const std::string& AXBoolAttribute_Name(AXBoolAttribute value)
{
    static const bool dummy
        = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(AXBoolAttribute_entries, AXBoolAttribute_entries_by_number, 23, AXBoolAttribute_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(AXBoolAttribute_entries, AXBoolAttribute_entries_by_number, 23, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : AXBoolAttribute_strings[idx].get();
}
bool AXBoolAttribute_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AXBoolAttribute* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(AXBoolAttribute_entries, 23, name, &int_value);
    if (success) {
        *value = static_cast<AXBoolAttribute>(int_value);
    }
    return success;
}
bool AXIntListAttribute_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> AXIntListAttribute_strings[30] = {};

static const char AXIntListAttribute_names[] = "AX_ILA_ACTIONSIDS"
                                               "AX_ILA_ARIANOTIFICATIONINTERRUPTPROPERTIES"
                                               "AX_ILA_ARIANOTIFICATIONPRIORITYPROPERTIES"
                                               "AX_ILA_CARETBOUNDS"
                                               "AX_ILA_CHARACTEROFFSETS"
                                               "AX_ILA_CONTROLSIDS"
                                               "AX_ILA_CUSTOMACTIONIDS"
                                               "AX_ILA_DESCRIBEDBYIDS"
                                               "AX_ILA_DETAILSIDS"
                                               "AX_ILA_ERRORMESSAGEIDS"
                                               "AX_ILA_FLOWTOIDS"
                                               "AX_ILA_HIGHLIGHTTYPES"
                                               "AX_ILA_INDIRECTCHILDIDS"
                                               "AX_ILA_LABELLEDBYIDS"
                                               "AX_ILA_LINEENDS"
                                               "AX_ILA_LINESTARTS"
                                               "AX_ILA_MARKERENDS"
                                               "AX_ILA_MARKERSTARTS"
                                               "AX_ILA_MARKERTYPES"
                                               "AX_ILA_NONE"
                                               "AX_ILA_RADIOGROUPIDS"
                                               "AX_ILA_SENTENCEENDS"
                                               "AX_ILA_SENTENCESTARTS"
                                               "AX_ILA_TEXTOPERATIONENDANCHORIDS"
                                               "AX_ILA_TEXTOPERATIONENDOFFSETS"
                                               "AX_ILA_TEXTOPERATIONS"
                                               "AX_ILA_TEXTOPERATIONSTARTANCHORIDS"
                                               "AX_ILA_TEXTOPERATIONSTARTOFFSETS"
                                               "AX_ILA_WORDENDS"
                                               "AX_ILA_WORDSTARTS";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry AXIntListAttribute_entries[] = {
    { { AXIntListAttribute_names + 0, 17 }, 29 },
    { { AXIntListAttribute_names + 17, 42 }, 27 },
    { { AXIntListAttribute_names + 59, 41 }, 28 },
    { { AXIntListAttribute_names + 100, 18 }, 16 },
    { { AXIntListAttribute_names + 118, 23 }, 11 },
    { { AXIntListAttribute_names + 141, 18 }, 2 },
    { { AXIntListAttribute_names + 159, 22 }, 15 },
    { { AXIntListAttribute_names + 181, 21 }, 4 },
    { { AXIntListAttribute_names + 202, 17 }, 3 },
    { { AXIntListAttribute_names + 219, 22 }, 26 },
    { { AXIntListAttribute_names + 241, 16 }, 5 },
    { { AXIntListAttribute_names + 257, 21 }, 20 },
    { { AXIntListAttribute_names + 278, 23 }, 1 },
    { { AXIntListAttribute_names + 301, 20 }, 6 },
    { { AXIntListAttribute_names + 321, 15 }, 17 },
    { { AXIntListAttribute_names + 336, 17 }, 12 },
    { { AXIntListAttribute_names + 353, 17 }, 10 },
    { { AXIntListAttribute_names + 370, 19 }, 9 },
    { { AXIntListAttribute_names + 389, 18 }, 8 },
    { { AXIntListAttribute_names + 407, 11 }, 0 },
    { { AXIntListAttribute_names + 418, 20 }, 7 },
    { { AXIntListAttribute_names + 438, 19 }, 19 },
    { { AXIntListAttribute_names + 457, 21 }, 18 },
    { { AXIntListAttribute_names + 478, 32 }, 23 },
    { { AXIntListAttribute_names + 510, 30 }, 24 },
    { { AXIntListAttribute_names + 540, 21 }, 25 },
    { { AXIntListAttribute_names + 561, 34 }, 21 },
    { { AXIntListAttribute_names + 595, 32 }, 22 },
    { { AXIntListAttribute_names + 627, 15 }, 14 },
    { { AXIntListAttribute_names + 642, 17 }, 13 },
};

static const int AXIntListAttribute_entries_by_number[] = {
    19, // 0 -> AX_ILA_NONE
    12, // 1 -> AX_ILA_INDIRECTCHILDIDS
    5, // 2 -> AX_ILA_CONTROLSIDS
    8, // 3 -> AX_ILA_DETAILSIDS
    7, // 4 -> AX_ILA_DESCRIBEDBYIDS
    10, // 5 -> AX_ILA_FLOWTOIDS
    13, // 6 -> AX_ILA_LABELLEDBYIDS
    20, // 7 -> AX_ILA_RADIOGROUPIDS
    18, // 8 -> AX_ILA_MARKERTYPES
    17, // 9 -> AX_ILA_MARKERSTARTS
    16, // 10 -> AX_ILA_MARKERENDS
    4, // 11 -> AX_ILA_CHARACTEROFFSETS
    15, // 12 -> AX_ILA_LINESTARTS
    29, // 13 -> AX_ILA_WORDSTARTS
    28, // 14 -> AX_ILA_WORDENDS
    6, // 15 -> AX_ILA_CUSTOMACTIONIDS
    3, // 16 -> AX_ILA_CARETBOUNDS
    14, // 17 -> AX_ILA_LINEENDS
    22, // 18 -> AX_ILA_SENTENCESTARTS
    21, // 19 -> AX_ILA_SENTENCEENDS
    11, // 20 -> AX_ILA_HIGHLIGHTTYPES
    26, // 21 -> AX_ILA_TEXTOPERATIONSTARTANCHORIDS
    27, // 22 -> AX_ILA_TEXTOPERATIONSTARTOFFSETS
    23, // 23 -> AX_ILA_TEXTOPERATIONENDANCHORIDS
    24, // 24 -> AX_ILA_TEXTOPERATIONENDOFFSETS
    25, // 25 -> AX_ILA_TEXTOPERATIONS
    9, // 26 -> AX_ILA_ERRORMESSAGEIDS
    1, // 27 -> AX_ILA_ARIANOTIFICATIONINTERRUPTPROPERTIES
    2, // 28 -> AX_ILA_ARIANOTIFICATIONPRIORITYPROPERTIES
    0, // 29 -> AX_ILA_ACTIONSIDS
};

const std::string& AXIntListAttribute_Name(AXIntListAttribute value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        AXIntListAttribute_entries, AXIntListAttribute_entries_by_number, 30, AXIntListAttribute_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(AXIntListAttribute_entries, AXIntListAttribute_entries_by_number, 30, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : AXIntListAttribute_strings[idx].get();
}
bool AXIntListAttribute_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AXIntListAttribute* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(AXIntListAttribute_entries, 30, name, &int_value);
    if (success) {
        *value = static_cast<AXIntListAttribute>(int_value);
    }
    return success;
}
bool AXStringListAttribute_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> AXStringListAttribute_strings[4] = {};

static const char AXStringListAttribute_names[] = "AX_SLA_ARIANOTIFICATIONANNOUNCEMENTS"
                                                  "AX_SLA_ARIANOTIFICATIONIDS"
                                                  "AX_SLA_CUSTOMACTIONDESCRIPTIONS"
                                                  "AX_SLA_NONE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry AXStringListAttribute_entries[] = {
    { { AXStringListAttribute_names + 0, 36 }, 2 },
    { { AXStringListAttribute_names + 36, 26 }, 3 },
    { { AXStringListAttribute_names + 62, 31 }, 1 },
    { { AXStringListAttribute_names + 93, 11 }, 0 },
};

static const int AXStringListAttribute_entries_by_number[] = {
    3, // 0 -> AX_SLA_NONE
    2, // 1 -> AX_SLA_CUSTOMACTIONDESCRIPTIONS
    0, // 2 -> AX_SLA_ARIANOTIFICATIONANNOUNCEMENTS
    1, // 3 -> AX_SLA_ARIANOTIFICATIONIDS
};

const std::string& AXStringListAttribute_Name(AXStringListAttribute value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        AXStringListAttribute_entries, AXStringListAttribute_entries_by_number, 4, AXStringListAttribute_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(AXStringListAttribute_entries, AXStringListAttribute_entries_by_number, 4, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : AXStringListAttribute_strings[idx].get();
}
bool AXStringListAttribute_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AXStringListAttribute* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(AXStringListAttribute_entries, 4, name, &int_value);
    if (success) {
        *value = static_cast<AXStringListAttribute>(int_value);
    }
    return success;
}
bool FormControlType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 15:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> FormControlType_strings[15] = {};

static const char FormControlType_names[] = "FORM_CONTROL_TYPE_CONTENT_EDITABLE"
                                            "FORM_CONTROL_TYPE_INPUT_CHECKBOX"
                                            "FORM_CONTROL_TYPE_INPUT_EMAIL"
                                            "FORM_CONTROL_TYPE_INPUT_MONTH"
                                            "FORM_CONTROL_TYPE_INPUT_NUMBER"
                                            "FORM_CONTROL_TYPE_INPUT_PASSWORD"
                                            "FORM_CONTROL_TYPE_INPUT_RADIO"
                                            "FORM_CONTROL_TYPE_INPUT_SEARCH"
                                            "FORM_CONTROL_TYPE_INPUT_TELEPHONE"
                                            "FORM_CONTROL_TYPE_INPUT_TEXT"
                                            "FORM_CONTROL_TYPE_INPUT_URL"
                                            "FORM_CONTROL_TYPE_SELECT_MULTIPLE"
                                            "FORM_CONTROL_TYPE_SELECT_ONE"
                                            "FORM_CONTROL_TYPE_TEXT_AREA"
                                            "FORM_CONTROL_TYPE_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry FormControlType_entries[] = {
    { { FormControlType_names + 0, 34 }, 1 },
    { { FormControlType_names + 34, 32 }, 2 },
    { { FormControlType_names + 66, 29 }, 3 },
    { { FormControlType_names + 95, 29 }, 4 },
    { { FormControlType_names + 124, 30 }, 5 },
    { { FormControlType_names + 154, 32 }, 6 },
    { { FormControlType_names + 186, 29 }, 7 },
    { { FormControlType_names + 215, 30 }, 8 },
    { { FormControlType_names + 245, 33 }, 9 },
    { { FormControlType_names + 278, 28 }, 10 },
    { { FormControlType_names + 306, 27 }, 11 },
    { { FormControlType_names + 333, 33 }, 13 },
    { { FormControlType_names + 366, 28 }, 12 },
    { { FormControlType_names + 394, 27 }, 15 },
    { { FormControlType_names + 421, 29 }, 0 },
};

static const int FormControlType_entries_by_number[] = {
    14, // 0 -> FORM_CONTROL_TYPE_UNSPECIFIED
    0, // 1 -> FORM_CONTROL_TYPE_CONTENT_EDITABLE
    1, // 2 -> FORM_CONTROL_TYPE_INPUT_CHECKBOX
    2, // 3 -> FORM_CONTROL_TYPE_INPUT_EMAIL
    3, // 4 -> FORM_CONTROL_TYPE_INPUT_MONTH
    4, // 5 -> FORM_CONTROL_TYPE_INPUT_NUMBER
    5, // 6 -> FORM_CONTROL_TYPE_INPUT_PASSWORD
    6, // 7 -> FORM_CONTROL_TYPE_INPUT_RADIO
    7, // 8 -> FORM_CONTROL_TYPE_INPUT_SEARCH
    8, // 9 -> FORM_CONTROL_TYPE_INPUT_TELEPHONE
    9, // 10 -> FORM_CONTROL_TYPE_INPUT_TEXT
    10, // 11 -> FORM_CONTROL_TYPE_INPUT_URL
    12, // 12 -> FORM_CONTROL_TYPE_SELECT_ONE
    11, // 13 -> FORM_CONTROL_TYPE_SELECT_MULTIPLE
    13, // 15 -> FORM_CONTROL_TYPE_TEXT_AREA
};

const std::string& FormControlType_Name(FormControlType value)
{
    static const bool dummy
        = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(FormControlType_entries, FormControlType_entries_by_number, 15, FormControlType_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(FormControlType_entries, FormControlType_entries_by_number, 15, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : FormControlType_strings[idx].get();
}
bool FormControlType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FormControlType* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(FormControlType_entries, 15, name, &int_value);
    if (success) {
        *value = static_cast<FormControlType>(int_value);
    }
    return success;
}
bool FinalModelStatus_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> FinalModelStatus_strings[3] = {};

static const char FinalModelStatus_names[] = "FINAL_MODEL_STATUS_FAILURE"
                                             "FINAL_MODEL_STATUS_SUCCESS"
                                             "FINAL_MODEL_STATUS_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry FinalModelStatus_entries[] = {
    { { FinalModelStatus_names + 0, 26 }, 2 },
    { { FinalModelStatus_names + 26, 26 }, 1 },
    { { FinalModelStatus_names + 52, 30 }, 0 },
};

static const int FinalModelStatus_entries_by_number[] = {
    2, // 0 -> FINAL_MODEL_STATUS_UNSPECIFIED
    1, // 1 -> FINAL_MODEL_STATUS_SUCCESS
    0, // 2 -> FINAL_MODEL_STATUS_FAILURE
};

const std::string& FinalModelStatus_Name(FinalModelStatus value)
{
    static const bool dummy
        = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(FinalModelStatus_entries, FinalModelStatus_entries_by_number, 3, FinalModelStatus_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(FinalModelStatus_entries, FinalModelStatus_entries_by_number, 3, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : FinalModelStatus_strings[idx].get();
}
bool FinalModelStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FinalModelStatus* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(FinalModelStatus_entries, 3, name, &int_value);
    if (success) {
        *value = static_cast<FinalModelStatus>(int_value);
    }
    return success;
}
bool UserFeedback_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> UserFeedback_strings[3] = {};

static const char UserFeedback_names[] = "USER_FEEDBACK_THUMBS_DOWN"
                                         "USER_FEEDBACK_THUMBS_UP"
                                         "USER_FEEDBACK_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry UserFeedback_entries[] = {
    { { UserFeedback_names + 0, 25 }, 1 },
    { { UserFeedback_names + 25, 23 }, 2 },
    { { UserFeedback_names + 48, 25 }, 0 },
};

static const int UserFeedback_entries_by_number[] = {
    2, // 0 -> USER_FEEDBACK_UNSPECIFIED
    0, // 1 -> USER_FEEDBACK_THUMBS_DOWN
    1, // 2 -> USER_FEEDBACK_THUMBS_UP
};

const std::string& UserFeedback_Name(UserFeedback value)
{
    static const bool dummy
        = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(UserFeedback_entries, UserFeedback_entries_by_number, 3, UserFeedback_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(UserFeedback_entries, UserFeedback_entries_by_number, 3, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : UserFeedback_strings[idx].get();
}
bool UserFeedback_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UserFeedback* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(UserFeedback_entries, 3, name, &int_value);
    if (success) {
        *value = static_cast<UserFeedback>(int_value);
    }
    return success;
}

// ===================================================================

class FloatArray::_Internal {
public:
};

FloatArray::FloatArray(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:optimization_guide.proto.FloatArray)
}
FloatArray::FloatArray(const FloatArray& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    FloatArray* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.values_) { from._impl_.values_ }, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:optimization_guide.proto.FloatArray)
}

inline void FloatArray::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.values_) { arena }, /*decltype(_impl_._cached_size_)*/ {} };
}

FloatArray::~FloatArray()
{
    // @@protoc_insertion_point(destructor:optimization_guide.proto.FloatArray)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void FloatArray::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.values_.~RepeatedField();
}

void FloatArray::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void FloatArray::Clear()
{
    // @@protoc_insertion_point(message_clear_start:optimization_guide.proto.FloatArray)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.values_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* FloatArray::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated float values = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_values(), ptr, ctx);
                CHK_(ptr);
            } else if (static_cast<uint8_t>(tag) == 13) {
                _internal_add_values(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
                ptr += sizeof(float);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* FloatArray::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:optimization_guide.proto.FloatArray)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated float values = 1;
    if (this->_internal_values_size() > 0) {
        target = stream->WriteFixedPacked(1, _internal_values(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:optimization_guide.proto.FloatArray)
    return target;
}

size_t FloatArray::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:optimization_guide.proto.FloatArray)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated float values = 1;
    {
        unsigned int count = static_cast<unsigned int>(this->_internal_values_size());
        size_t data_size = 4UL * count;
        if (data_size > 0) {
            total_size += 1 + ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
        }
        total_size += data_size;
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void FloatArray::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const FloatArray*>(&from));
}

void FloatArray::MergeFrom(const FloatArray& from)
{
    FloatArray* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:optimization_guide.proto.FloatArray)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.values_.MergeFrom(from._impl_.values_);
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FloatArray::CopyFrom(const FloatArray& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:optimization_guide.proto.FloatArray)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool FloatArray::IsInitialized() const
{
    return true;
}

void FloatArray::InternalSwap(FloatArray* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.values_.InternalSwap(&other->_impl_.values_);
}

std::string FloatArray::GetTypeName() const
{
    return "optimization_guide.proto.FloatArray";
}

// ===================================================================

class Embedding::_Internal {
public:
    static const ::optimization_guide::proto::FloatArray& floats(const Embedding* msg);
};

const ::optimization_guide::proto::FloatArray& Embedding::_Internal::floats(const Embedding* msg)
{
    return *msg->_impl_.floats_;
}
Embedding::Embedding(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:optimization_guide.proto.Embedding)
}
Embedding::Embedding(const Embedding& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    Embedding* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.floats_) { nullptr }, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_floats()) {
        _this->_impl_.floats_ = new ::optimization_guide::proto::FloatArray(*from._impl_.floats_);
    }
    // @@protoc_insertion_point(copy_constructor:optimization_guide.proto.Embedding)
}

inline void Embedding::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.floats_) { nullptr }, /*decltype(_impl_._cached_size_)*/ {} };
}

Embedding::~Embedding()
{
    // @@protoc_insertion_point(destructor:optimization_guide.proto.Embedding)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void Embedding::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (this != internal_default_instance())
        delete _impl_.floats_;
}

void Embedding::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void Embedding::Clear()
{
    // @@protoc_insertion_point(message_clear_start:optimization_guide.proto.Embedding)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    if (GetArenaForAllocation() == nullptr && _impl_.floats_ != nullptr) {
        delete _impl_.floats_;
    }
    _impl_.floats_ = nullptr;
    _internal_metadata_.Clear<std::string>();
}

const char* Embedding::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // .optimization_guide.proto.FloatArray floats = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_floats(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* Embedding::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:optimization_guide.proto.Embedding)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // .optimization_guide.proto.FloatArray floats = 1;
    if (this->_internal_has_floats()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::floats(this), _Internal::floats(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:optimization_guide.proto.Embedding)
    return target;
}

size_t Embedding::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:optimization_guide.proto.Embedding)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // .optimization_guide.proto.FloatArray floats = 1;
    if (this->_internal_has_floats()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.floats_);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void Embedding::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const Embedding*>(&from));
}

void Embedding::MergeFrom(const Embedding& from)
{
    Embedding* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:optimization_guide.proto.Embedding)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_floats()) {
        _this->_internal_mutable_floats()->::optimization_guide::proto::FloatArray::MergeFrom(from._internal_floats());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Embedding::CopyFrom(const Embedding& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:optimization_guide.proto.Embedding)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool Embedding::IsInitialized() const
{
    return true;
}

void Embedding::InternalSwap(Embedding* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_.floats_, other->_impl_.floats_);
}

std::string Embedding::GetTypeName() const
{
    return "optimization_guide.proto.Embedding";
}

// ===================================================================

class AXTreeUpdate::_Internal {
public:
    using HasBits = decltype(std::declval<AXTreeUpdate>()._impl_._has_bits_);
    static const ::optimization_guide::proto::AXTreeData& tree_data(const AXTreeUpdate* msg);
    static void set_has_tree_data(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

const ::optimization_guide::proto::AXTreeData& AXTreeUpdate::_Internal::tree_data(const AXTreeUpdate* msg)
{
    return *msg->_impl_.tree_data_;
}
AXTreeUpdate::AXTreeUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:optimization_guide.proto.AXTreeUpdate)
}
AXTreeUpdate::AXTreeUpdate(const AXTreeUpdate& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    AXTreeUpdate* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.nodes_) { from._impl_.nodes_ }, decltype(_impl_.tree_data_) { nullptr }, decltype(_impl_.root_id_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_tree_data()) {
        _this->_impl_.tree_data_ = new ::optimization_guide::proto::AXTreeData(*from._impl_.tree_data_);
    }
    _this->_impl_.root_id_ = from._impl_.root_id_;
    // @@protoc_insertion_point(copy_constructor:optimization_guide.proto.AXTreeUpdate)
}

inline void AXTreeUpdate::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.nodes_) { arena },
        decltype(_impl_.tree_data_) { nullptr }, decltype(_impl_.root_id_) { 0u } };
}

AXTreeUpdate::~AXTreeUpdate()
{
    // @@protoc_insertion_point(destructor:optimization_guide.proto.AXTreeUpdate)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void AXTreeUpdate::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.nodes_.~RepeatedPtrField();
    if (this != internal_default_instance())
        delete _impl_.tree_data_;
}

void AXTreeUpdate::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void AXTreeUpdate::Clear()
{
    // @@protoc_insertion_point(message_clear_start:optimization_guide.proto.AXTreeUpdate)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.nodes_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        GOOGLE_DCHECK(_impl_.tree_data_ != nullptr);
        _impl_.tree_data_->Clear();
    }
    _impl_.root_id_ = 0u;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* AXTreeUpdate::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .optimization_guide.proto.AXTreeData tree_data = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_tree_data(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // uint32 root_id = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _impl_.root_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .optimization_guide.proto.AXNodeData nodes = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_nodes(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* AXTreeUpdate::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:optimization_guide.proto.AXTreeUpdate)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // optional .optimization_guide.proto.AXTreeData tree_data = 1;
    if (_internal_has_tree_data()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::tree_data(this), _Internal::tree_data(this).GetCachedSize(), target, stream);
    }

    // uint32 root_id = 2;
    if (this->_internal_root_id() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_root_id(), target);
    }

    // repeated .optimization_guide.proto.AXNodeData nodes = 3;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_nodes_size()); i < n; i++) {
        const auto& repfield = this->_internal_nodes(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:optimization_guide.proto.AXTreeUpdate)
    return target;
}

size_t AXTreeUpdate::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:optimization_guide.proto.AXTreeUpdate)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .optimization_guide.proto.AXNodeData nodes = 3;
    total_size += 1UL * this->_internal_nodes_size();
    for (const auto& msg : this->_impl_.nodes_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // optional .optimization_guide.proto.AXTreeData tree_data = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.tree_data_);
    }

    // uint32 root_id = 2;
    if (this->_internal_root_id() != 0) {
        total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_root_id());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void AXTreeUpdate::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const AXTreeUpdate*>(&from));
}

void AXTreeUpdate::MergeFrom(const AXTreeUpdate& from)
{
    AXTreeUpdate* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:optimization_guide.proto.AXTreeUpdate)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.nodes_.MergeFrom(from._impl_.nodes_);
    if (from._internal_has_tree_data()) {
        _this->_internal_mutable_tree_data()->::optimization_guide::proto::AXTreeData::MergeFrom(from._internal_tree_data());
    }
    if (from._internal_root_id() != 0) {
        _this->_internal_set_root_id(from._internal_root_id());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AXTreeUpdate::CopyFrom(const AXTreeUpdate& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:optimization_guide.proto.AXTreeUpdate)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool AXTreeUpdate::IsInitialized() const
{
    return true;
}

void AXTreeUpdate::InternalSwap(AXTreeUpdate* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.nodes_.InternalSwap(&other->_impl_.nodes_);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(AXTreeUpdate, _impl_.root_id_) + sizeof(AXTreeUpdate::_impl_.root_id_)
        - PROTOBUF_FIELD_OFFSET(AXTreeUpdate, _impl_.tree_data_)>(
        reinterpret_cast<char*>(&_impl_.tree_data_), reinterpret_cast<char*>(&other->_impl_.tree_data_));
}

std::string AXTreeUpdate::GetTypeName() const
{
    return "optimization_guide.proto.AXTreeUpdate";
}

// ===================================================================

class AXTreeData::_Internal {
public:
};

AXTreeData::AXTreeData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:optimization_guide.proto.AXTreeData)
}
AXTreeData::AXTreeData(const AXTreeData& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    AXTreeData* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.metadata_) { from._impl_.metadata_ }, decltype(_impl_.doctype_) {}, decltype(_impl_.mimetype_) {},
        decltype(_impl_.title_) {}, decltype(_impl_.loading_progress_) {}, decltype(_impl_.loaded_) {}, decltype(_impl_.sel_is_backward_) {},
        decltype(_impl_.focus_id_) {}, decltype(_impl_.sel_anchor_object_id_) {}, decltype(_impl_.sel_anchor_offset_) {},
        decltype(_impl_.sel_anchor_affinity_) {}, decltype(_impl_.sel_focus_object_id_) {}, decltype(_impl_.sel_focus_offset_) {},
        decltype(_impl_.sel_focus_affinity_) {}, decltype(_impl_.root_scroller_id_) {}, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.doctype_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.doctype_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_doctype().empty()) {
        _this->_impl_.doctype_.Set(from._internal_doctype(), _this->GetArenaForAllocation());
    }
    _impl_.mimetype_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mimetype_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_mimetype().empty()) {
        _this->_impl_.mimetype_.Set(from._internal_mimetype(), _this->GetArenaForAllocation());
    }
    _impl_.title_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_title().empty()) {
        _this->_impl_.title_.Set(from._internal_title(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.loading_progress_, &from._impl_.loading_progress_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.root_scroller_id_) - reinterpret_cast<char*>(&_impl_.loading_progress_))
            + sizeof(_impl_.root_scroller_id_));
    // @@protoc_insertion_point(copy_constructor:optimization_guide.proto.AXTreeData)
}

inline void AXTreeData::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.metadata_) { arena }, decltype(_impl_.doctype_) {}, decltype(_impl_.mimetype_) {}, decltype(_impl_.title_) {},
        decltype(_impl_.loading_progress_) { 0 }, decltype(_impl_.loaded_) { false }, decltype(_impl_.sel_is_backward_) { false },
        decltype(_impl_.focus_id_) { 0u }, decltype(_impl_.sel_anchor_object_id_) { 0u }, decltype(_impl_.sel_anchor_offset_) { 0u },
        decltype(_impl_.sel_anchor_affinity_) { 0 }, decltype(_impl_.sel_focus_object_id_) { 0u }, decltype(_impl_.sel_focus_offset_) { 0u },
        decltype(_impl_.sel_focus_affinity_) { 0 }, decltype(_impl_.root_scroller_id_) { 0u }, /*decltype(_impl_._cached_size_)*/ {} };
    _impl_.doctype_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.doctype_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mimetype_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mimetype_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AXTreeData::~AXTreeData()
{
    // @@protoc_insertion_point(destructor:optimization_guide.proto.AXTreeData)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void AXTreeData::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.metadata_.~RepeatedPtrField();
    _impl_.doctype_.Destroy();
    _impl_.mimetype_.Destroy();
    _impl_.title_.Destroy();
}

void AXTreeData::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void AXTreeData::Clear()
{
    // @@protoc_insertion_point(message_clear_start:optimization_guide.proto.AXTreeData)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.metadata_.Clear();
    _impl_.doctype_.ClearToEmpty();
    _impl_.mimetype_.ClearToEmpty();
    _impl_.title_.ClearToEmpty();
    ::memset(&_impl_.loading_progress_, 0,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.root_scroller_id_) - reinterpret_cast<char*>(&_impl_.loading_progress_))
            + sizeof(_impl_.root_scroller_id_));
    _internal_metadata_.Clear<std::string>();
}

const char* AXTreeData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // string doctype = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_doctype();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // bool loaded = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _impl_.loaded_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // float loading_progress = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
                _impl_.loading_progress_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
                ptr += sizeof(float);
            } else
                goto handle_unusual;
            continue;
        // string mimetype = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                auto str = _internal_mutable_mimetype();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // string title = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                auto str = _internal_mutable_title();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // uint32 focus_id = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
                _impl_.focus_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // bool sel_is_backward = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
                _impl_.sel_is_backward_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // uint32 sel_anchor_object_id = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
                _impl_.sel_anchor_object_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // uint32 sel_anchor_offset = 9;
        case 9:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
                _impl_.sel_anchor_offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .optimization_guide.proto.AXTextAffinity sel_anchor_affinity = 10;
        case 10:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                _internal_set_sel_anchor_affinity(static_cast<::optimization_guide::proto::AXTextAffinity>(val));
            } else
                goto handle_unusual;
            continue;
        // uint32 sel_focus_object_id = 11;
        case 11:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
                _impl_.sel_focus_object_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // uint32 sel_focus_offset = 12;
        case 12:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
                _impl_.sel_focus_offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .optimization_guide.proto.AXTextAffinity sel_focus_affinity = 13;
        case 13:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                _internal_set_sel_focus_affinity(static_cast<::optimization_guide::proto::AXTextAffinity>(val));
            } else
                goto handle_unusual;
            continue;
        // uint32 root_scroller_id = 14;
        case 14:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
                _impl_.root_scroller_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated string metadata = 15;
        case 15:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    auto str = _internal_add_metadata();
                    ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(ptr);
                    CHK_(::_pbi::VerifyUTF8(str, nullptr));
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<122>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* AXTreeData::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:optimization_guide.proto.AXTreeData)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // string doctype = 1;
    if (!this->_internal_doctype().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_doctype().data(),
            static_cast<int>(this->_internal_doctype().length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
            "optimization_guide.proto.AXTreeData.doctype");
        target = stream->WriteStringMaybeAliased(1, this->_internal_doctype(), target);
    }

    // bool loaded = 2;
    if (this->_internal_loaded() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_loaded(), target);
    }

    // float loading_progress = 3;
    static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
    float tmp_loading_progress = this->_internal_loading_progress();
    uint32_t raw_loading_progress;
    memcpy(&raw_loading_progress, &tmp_loading_progress, sizeof(tmp_loading_progress));
    if (raw_loading_progress != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_loading_progress(), target);
    }

    // string mimetype = 4;
    if (!this->_internal_mimetype().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_mimetype().data(),
            static_cast<int>(this->_internal_mimetype().length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
            "optimization_guide.proto.AXTreeData.mimetype");
        target = stream->WriteStringMaybeAliased(4, this->_internal_mimetype(), target);
    }

    // string title = 5;
    if (!this->_internal_title().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_title().data(), static_cast<int>(this->_internal_title().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "optimization_guide.proto.AXTreeData.title");
        target = stream->WriteStringMaybeAliased(5, this->_internal_title(), target);
    }

    // uint32 focus_id = 6;
    if (this->_internal_focus_id() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_focus_id(), target);
    }

    // bool sel_is_backward = 7;
    if (this->_internal_sel_is_backward() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_sel_is_backward(), target);
    }

    // uint32 sel_anchor_object_id = 8;
    if (this->_internal_sel_anchor_object_id() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_sel_anchor_object_id(), target);
    }

    // uint32 sel_anchor_offset = 9;
    if (this->_internal_sel_anchor_offset() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_sel_anchor_offset(), target);
    }

    // .optimization_guide.proto.AXTextAffinity sel_anchor_affinity = 10;
    if (this->_internal_sel_anchor_affinity() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(10, this->_internal_sel_anchor_affinity(), target);
    }

    // uint32 sel_focus_object_id = 11;
    if (this->_internal_sel_focus_object_id() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_sel_focus_object_id(), target);
    }

    // uint32 sel_focus_offset = 12;
    if (this->_internal_sel_focus_offset() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_sel_focus_offset(), target);
    }

    // .optimization_guide.proto.AXTextAffinity sel_focus_affinity = 13;
    if (this->_internal_sel_focus_affinity() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(13, this->_internal_sel_focus_affinity(), target);
    }

    // uint32 root_scroller_id = 14;
    if (this->_internal_root_scroller_id() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(14, this->_internal_root_scroller_id(), target);
    }

    // repeated string metadata = 15;
    for (int i = 0, n = this->_internal_metadata_size(); i < n; i++) {
        const auto& s = this->_internal_metadata(i);
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s.data(), static_cast<int>(s.length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "optimization_guide.proto.AXTreeData.metadata");
        target = stream->WriteString(15, s, target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:optimization_guide.proto.AXTreeData)
    return target;
}

size_t AXTreeData::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:optimization_guide.proto.AXTreeData)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated string metadata = 15;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.metadata_.size());
    for (int i = 0, n = _impl_.metadata_.size(); i < n; i++) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(_impl_.metadata_.Get(i));
    }

    // string doctype = 1;
    if (!this->_internal_doctype().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_doctype());
    }

    // string mimetype = 4;
    if (!this->_internal_mimetype().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_mimetype());
    }

    // string title = 5;
    if (!this->_internal_title().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_title());
    }

    // float loading_progress = 3;
    static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
    float tmp_loading_progress = this->_internal_loading_progress();
    uint32_t raw_loading_progress;
    memcpy(&raw_loading_progress, &tmp_loading_progress, sizeof(tmp_loading_progress));
    if (raw_loading_progress != 0) {
        total_size += 1 + 4;
    }

    // bool loaded = 2;
    if (this->_internal_loaded() != 0) {
        total_size += 1 + 1;
    }

    // bool sel_is_backward = 7;
    if (this->_internal_sel_is_backward() != 0) {
        total_size += 1 + 1;
    }

    // uint32 focus_id = 6;
    if (this->_internal_focus_id() != 0) {
        total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_focus_id());
    }

    // uint32 sel_anchor_object_id = 8;
    if (this->_internal_sel_anchor_object_id() != 0) {
        total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_sel_anchor_object_id());
    }

    // uint32 sel_anchor_offset = 9;
    if (this->_internal_sel_anchor_offset() != 0) {
        total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_sel_anchor_offset());
    }

    // .optimization_guide.proto.AXTextAffinity sel_anchor_affinity = 10;
    if (this->_internal_sel_anchor_affinity() != 0) {
        total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_sel_anchor_affinity());
    }

    // uint32 sel_focus_object_id = 11;
    if (this->_internal_sel_focus_object_id() != 0) {
        total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_sel_focus_object_id());
    }

    // uint32 sel_focus_offset = 12;
    if (this->_internal_sel_focus_offset() != 0) {
        total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_sel_focus_offset());
    }

    // .optimization_guide.proto.AXTextAffinity sel_focus_affinity = 13;
    if (this->_internal_sel_focus_affinity() != 0) {
        total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_sel_focus_affinity());
    }

    // uint32 root_scroller_id = 14;
    if (this->_internal_root_scroller_id() != 0) {
        total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_root_scroller_id());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void AXTreeData::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const AXTreeData*>(&from));
}

void AXTreeData::MergeFrom(const AXTreeData& from)
{
    AXTreeData* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:optimization_guide.proto.AXTreeData)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.metadata_.MergeFrom(from._impl_.metadata_);
    if (!from._internal_doctype().empty()) {
        _this->_internal_set_doctype(from._internal_doctype());
    }
    if (!from._internal_mimetype().empty()) {
        _this->_internal_set_mimetype(from._internal_mimetype());
    }
    if (!from._internal_title().empty()) {
        _this->_internal_set_title(from._internal_title());
    }
    static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
    float tmp_loading_progress = from._internal_loading_progress();
    uint32_t raw_loading_progress;
    memcpy(&raw_loading_progress, &tmp_loading_progress, sizeof(tmp_loading_progress));
    if (raw_loading_progress != 0) {
        _this->_internal_set_loading_progress(from._internal_loading_progress());
    }
    if (from._internal_loaded() != 0) {
        _this->_internal_set_loaded(from._internal_loaded());
    }
    if (from._internal_sel_is_backward() != 0) {
        _this->_internal_set_sel_is_backward(from._internal_sel_is_backward());
    }
    if (from._internal_focus_id() != 0) {
        _this->_internal_set_focus_id(from._internal_focus_id());
    }
    if (from._internal_sel_anchor_object_id() != 0) {
        _this->_internal_set_sel_anchor_object_id(from._internal_sel_anchor_object_id());
    }
    if (from._internal_sel_anchor_offset() != 0) {
        _this->_internal_set_sel_anchor_offset(from._internal_sel_anchor_offset());
    }
    if (from._internal_sel_anchor_affinity() != 0) {
        _this->_internal_set_sel_anchor_affinity(from._internal_sel_anchor_affinity());
    }
    if (from._internal_sel_focus_object_id() != 0) {
        _this->_internal_set_sel_focus_object_id(from._internal_sel_focus_object_id());
    }
    if (from._internal_sel_focus_offset() != 0) {
        _this->_internal_set_sel_focus_offset(from._internal_sel_focus_offset());
    }
    if (from._internal_sel_focus_affinity() != 0) {
        _this->_internal_set_sel_focus_affinity(from._internal_sel_focus_affinity());
    }
    if (from._internal_root_scroller_id() != 0) {
        _this->_internal_set_root_scroller_id(from._internal_root_scroller_id());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AXTreeData::CopyFrom(const AXTreeData& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:optimization_guide.proto.AXTreeData)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool AXTreeData::IsInitialized() const
{
    return true;
}

void AXTreeData::InternalSwap(AXTreeData* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.metadata_.InternalSwap(&other->_impl_.metadata_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.doctype_, lhs_arena, &other->_impl_.doctype_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.mimetype_, lhs_arena, &other->_impl_.mimetype_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.title_, lhs_arena, &other->_impl_.title_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(AXTreeData, _impl_.root_scroller_id_) + sizeof(AXTreeData::_impl_.root_scroller_id_)
        - PROTOBUF_FIELD_OFFSET(AXTreeData, _impl_.loading_progress_)>(
        reinterpret_cast<char*>(&_impl_.loading_progress_), reinterpret_cast<char*>(&other->_impl_.loading_progress_));
}

std::string AXTreeData::GetTypeName() const
{
    return "optimization_guide.proto.AXTreeData";
}

// ===================================================================

class AXNodeData::_Internal {
public:
    static const ::optimization_guide::proto::AXRelativeBounds& relative_bounds(const AXNodeData* msg);
};

const ::optimization_guide::proto::AXRelativeBounds& AXNodeData::_Internal::relative_bounds(const AXNodeData* msg)
{
    return *msg->_impl_.relative_bounds_;
}
AXNodeData::AXNodeData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:optimization_guide.proto.AXNodeData)
}
AXNodeData::AXNodeData(const AXNodeData& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    AXNodeData* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.attributes_) { from._impl_.attributes_ }, decltype(_impl_.child_ids_) { from._impl_.child_ids_ },
        /*decltype(_impl_._child_ids_cached_byte_size_)*/ { 0 }, decltype(_impl_.relative_bounds_) { nullptr }, decltype(_impl_.id_) {},
        decltype(_impl_.role_) {}, decltype(_impl_.actions_) {}, decltype(_impl_.state_) {}, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_relative_bounds()) {
        _this->_impl_.relative_bounds_ = new ::optimization_guide::proto::AXRelativeBounds(*from._impl_.relative_bounds_);
    }
    ::memcpy(&_impl_.id_, &from._impl_.id_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.state_) - reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.state_));
    // @@protoc_insertion_point(copy_constructor:optimization_guide.proto.AXNodeData)
}

inline void AXNodeData::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.attributes_) { arena }, decltype(_impl_.child_ids_) { arena },
        /*decltype(_impl_._child_ids_cached_byte_size_)*/ { 0 }, decltype(_impl_.relative_bounds_) { nullptr }, decltype(_impl_.id_) { 0u },
        decltype(_impl_.role_) { 0 }, decltype(_impl_.actions_) { uint64_t { 0u } }, decltype(_impl_.state_) { 0u }, /*decltype(_impl_._cached_size_)*/ {} };
}

AXNodeData::~AXNodeData()
{
    // @@protoc_insertion_point(destructor:optimization_guide.proto.AXNodeData)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void AXNodeData::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.attributes_.~RepeatedPtrField();
    _impl_.child_ids_.~RepeatedField();
    if (this != internal_default_instance())
        delete _impl_.relative_bounds_;
}

void AXNodeData::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void AXNodeData::Clear()
{
    // @@protoc_insertion_point(message_clear_start:optimization_guide.proto.AXNodeData)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.attributes_.Clear();
    _impl_.child_ids_.Clear();
    if (GetArenaForAllocation() == nullptr && _impl_.relative_bounds_ != nullptr) {
        delete _impl_.relative_bounds_;
    }
    _impl_.relative_bounds_ = nullptr;
    ::memset(&_impl_.id_, 0, static_cast<size_t>(reinterpret_cast<char*>(&_impl_.state_) - reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.state_));
    _internal_metadata_.Clear<std::string>();
}

const char* AXNodeData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // uint32 id = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .optimization_guide.proto.AXRole role = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                _internal_set_role(static_cast<::optimization_guide::proto::AXRole>(val));
            } else
                goto handle_unusual;
            continue;
        // uint32 state = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _impl_.state_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // uint64 actions = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _impl_.actions_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .optimization_guide.proto.AXAttribute attributes = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_attributes(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
            } else
                goto handle_unusual;
            continue;
        // repeated int32 child_ids = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_child_ids(), ptr, ctx);
                CHK_(ptr);
            } else if (static_cast<uint8_t>(tag) == 48) {
                _internal_add_child_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .optimization_guide.proto.AXRelativeBounds relative_bounds = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
                ptr = ctx->ParseMessage(_internal_mutable_relative_bounds(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* AXNodeData::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:optimization_guide.proto.AXNodeData)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // uint32 id = 1;
    if (this->_internal_id() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_id(), target);
    }

    // .optimization_guide.proto.AXRole role = 2;
    if (this->_internal_role() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(2, this->_internal_role(), target);
    }

    // uint32 state = 3;
    if (this->_internal_state() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_state(), target);
    }

    // uint64 actions = 4;
    if (this->_internal_actions() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_actions(), target);
    }

    // repeated .optimization_guide.proto.AXAttribute attributes = 5;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_attributes_size()); i < n; i++) {
        const auto& repfield = this->_internal_attributes(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
    }

    // repeated int32 child_ids = 6;
    {
        int byte_size = _impl_._child_ids_cached_byte_size_.load(std::memory_order_relaxed);
        if (byte_size > 0) {
            target = stream->WriteInt32Packed(6, _internal_child_ids(), byte_size, target);
        }
    }

    // .optimization_guide.proto.AXRelativeBounds relative_bounds = 7;
    if (this->_internal_has_relative_bounds()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            7, _Internal::relative_bounds(this), _Internal::relative_bounds(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:optimization_guide.proto.AXNodeData)
    return target;
}

size_t AXNodeData::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:optimization_guide.proto.AXNodeData)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .optimization_guide.proto.AXAttribute attributes = 5;
    total_size += 1UL * this->_internal_attributes_size();
    for (const auto& msg : this->_impl_.attributes_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // repeated int32 child_ids = 6;
    {
        size_t data_size = ::_pbi::WireFormatLite::Int32Size(this->_impl_.child_ids_);
        if (data_size > 0) {
            total_size += 1 + ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
        }
        int cached_size = ::_pbi::ToCachedSize(data_size);
        _impl_._child_ids_cached_byte_size_.store(cached_size, std::memory_order_relaxed);
        total_size += data_size;
    }

    // .optimization_guide.proto.AXRelativeBounds relative_bounds = 7;
    if (this->_internal_has_relative_bounds()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.relative_bounds_);
    }

    // uint32 id = 1;
    if (this->_internal_id() != 0) {
        total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_id());
    }

    // .optimization_guide.proto.AXRole role = 2;
    if (this->_internal_role() != 0) {
        total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_role());
    }

    // uint64 actions = 4;
    if (this->_internal_actions() != 0) {
        total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_actions());
    }

    // uint32 state = 3;
    if (this->_internal_state() != 0) {
        total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_state());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void AXNodeData::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const AXNodeData*>(&from));
}

void AXNodeData::MergeFrom(const AXNodeData& from)
{
    AXNodeData* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:optimization_guide.proto.AXNodeData)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.attributes_.MergeFrom(from._impl_.attributes_);
    _this->_impl_.child_ids_.MergeFrom(from._impl_.child_ids_);
    if (from._internal_has_relative_bounds()) {
        _this->_internal_mutable_relative_bounds()->::optimization_guide::proto::AXRelativeBounds::MergeFrom(from._internal_relative_bounds());
    }
    if (from._internal_id() != 0) {
        _this->_internal_set_id(from._internal_id());
    }
    if (from._internal_role() != 0) {
        _this->_internal_set_role(from._internal_role());
    }
    if (from._internal_actions() != 0) {
        _this->_internal_set_actions(from._internal_actions());
    }
    if (from._internal_state() != 0) {
        _this->_internal_set_state(from._internal_state());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AXNodeData::CopyFrom(const AXNodeData& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:optimization_guide.proto.AXNodeData)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool AXNodeData::IsInitialized() const
{
    return true;
}

void AXNodeData::InternalSwap(AXNodeData* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.attributes_.InternalSwap(&other->_impl_.attributes_);
    _impl_.child_ids_.InternalSwap(&other->_impl_.child_ids_);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(AXNodeData, _impl_.state_) + sizeof(AXNodeData::_impl_.state_)
        - PROTOBUF_FIELD_OFFSET(AXNodeData, _impl_.relative_bounds_)>(
        reinterpret_cast<char*>(&_impl_.relative_bounds_), reinterpret_cast<char*>(&other->_impl_.relative_bounds_));
}

std::string AXNodeData::GetTypeName() const
{
    return "optimization_guide.proto.AXNodeData";
}

// ===================================================================

class AXAttribute::_Internal {
public:
    static const ::optimization_guide::proto::AXIntList& int_list_value(const AXAttribute* msg);
    static const ::optimization_guide::proto::AXStringList& string_list_value(const AXAttribute* msg);
};

const ::optimization_guide::proto::AXIntList& AXAttribute::_Internal::int_list_value(const AXAttribute* msg)
{
    return *msg->_impl_.attribute_value_.int_list_value_;
}
const ::optimization_guide::proto::AXStringList& AXAttribute::_Internal::string_list_value(const AXAttribute* msg)
{
    return *msg->_impl_.attribute_value_.string_list_value_;
}
void AXAttribute::set_allocated_int_list_value(::optimization_guide::proto::AXIntList* int_list_value)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_attribute_value();
    if (int_list_value) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(int_list_value);
        if (message_arena != submessage_arena) {
            int_list_value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, int_list_value, submessage_arena);
        }
        set_has_int_list_value();
        _impl_.attribute_value_.int_list_value_ = int_list_value;
    }
    // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.AXAttribute.int_list_value)
}
void AXAttribute::set_allocated_string_list_value(::optimization_guide::proto::AXStringList* string_list_value)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_attribute_value();
    if (string_list_value) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(string_list_value);
        if (message_arena != submessage_arena) {
            string_list_value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, string_list_value, submessage_arena);
        }
        set_has_string_list_value();
        _impl_.attribute_value_.string_list_value_ = string_list_value;
    }
    // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.AXAttribute.string_list_value)
}
AXAttribute::AXAttribute(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:optimization_guide.proto.AXAttribute)
}
AXAttribute::AXAttribute(const AXAttribute& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    AXAttribute* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.attribute_key_) {}, decltype(_impl_.attribute_value_) {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_._oneof_case_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    clear_has_attribute_key();
    switch (from.attribute_key_case()) {
    case kStringType: {
        _this->_internal_set_string_type(from._internal_string_type());
        break;
    }
    case kIntType: {
        _this->_internal_set_int_type(from._internal_int_type());
        break;
    }
    case kFloatType: {
        _this->_internal_set_float_type(from._internal_float_type());
        break;
    }
    case kBoolType: {
        _this->_internal_set_bool_type(from._internal_bool_type());
        break;
    }
    case kIntlistType: {
        _this->_internal_set_intlist_type(from._internal_intlist_type());
        break;
    }
    case kStringlistType: {
        _this->_internal_set_stringlist_type(from._internal_stringlist_type());
        break;
    }
    case kHtmlAttributeName: {
        _this->_internal_set_html_attribute_name(from._internal_html_attribute_name());
        break;
    }
    case ATTRIBUTE_KEY_NOT_SET: {
        break;
    }
    }
    clear_has_attribute_value();
    switch (from.attribute_value_case()) {
    case kStringValue: {
        _this->_internal_set_string_value(from._internal_string_value());
        break;
    }
    case kIntValue: {
        _this->_internal_set_int_value(from._internal_int_value());
        break;
    }
    case kFloatValue: {
        _this->_internal_set_float_value(from._internal_float_value());
        break;
    }
    case kBoolValue: {
        _this->_internal_set_bool_value(from._internal_bool_value());
        break;
    }
    case kIntListValue: {
        _this->_internal_mutable_int_list_value()->::optimization_guide::proto::AXIntList::MergeFrom(from._internal_int_list_value());
        break;
    }
    case kStringListValue: {
        _this->_internal_mutable_string_list_value()->::optimization_guide::proto::AXStringList::MergeFrom(from._internal_string_list_value());
        break;
    }
    case kHtmlAttributeValue: {
        _this->_internal_set_html_attribute_value(from._internal_html_attribute_value());
        break;
    }
    case ATTRIBUTE_VALUE_NOT_SET: {
        break;
    }
    }
    // @@protoc_insertion_point(copy_constructor:optimization_guide.proto.AXAttribute)
}

inline void AXAttribute::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.attribute_key_) {}, decltype(_impl_.attribute_value_) {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_._oneof_case_)*/ {} };
    clear_has_attribute_key();
    clear_has_attribute_value();
}

AXAttribute::~AXAttribute()
{
    // @@protoc_insertion_point(destructor:optimization_guide.proto.AXAttribute)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void AXAttribute::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (has_attribute_key()) {
        clear_attribute_key();
    }
    if (has_attribute_value()) {
        clear_attribute_value();
    }
}

void AXAttribute::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void AXAttribute::clear_attribute_key()
{
    // @@protoc_insertion_point(one_of_clear_start:optimization_guide.proto.AXAttribute)
    switch (attribute_key_case()) {
    case kStringType: {
        // No need to clear
        break;
    }
    case kIntType: {
        // No need to clear
        break;
    }
    case kFloatType: {
        // No need to clear
        break;
    }
    case kBoolType: {
        // No need to clear
        break;
    }
    case kIntlistType: {
        // No need to clear
        break;
    }
    case kStringlistType: {
        // No need to clear
        break;
    }
    case kHtmlAttributeName: {
        _impl_.attribute_key_.html_attribute_name_.Destroy();
        break;
    }
    case ATTRIBUTE_KEY_NOT_SET: {
        break;
    }
    }
    _impl_._oneof_case_[0] = ATTRIBUTE_KEY_NOT_SET;
}

void AXAttribute::clear_attribute_value()
{
    // @@protoc_insertion_point(one_of_clear_start:optimization_guide.proto.AXAttribute)
    switch (attribute_value_case()) {
    case kStringValue: {
        _impl_.attribute_value_.string_value_.Destroy();
        break;
    }
    case kIntValue: {
        // No need to clear
        break;
    }
    case kFloatValue: {
        // No need to clear
        break;
    }
    case kBoolValue: {
        // No need to clear
        break;
    }
    case kIntListValue: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.attribute_value_.int_list_value_;
        }
        break;
    }
    case kStringListValue: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.attribute_value_.string_list_value_;
        }
        break;
    }
    case kHtmlAttributeValue: {
        _impl_.attribute_value_.html_attribute_value_.Destroy();
        break;
    }
    case ATTRIBUTE_VALUE_NOT_SET: {
        break;
    }
    }
    _impl_._oneof_case_[1] = ATTRIBUTE_VALUE_NOT_SET;
}

void AXAttribute::Clear()
{
    // @@protoc_insertion_point(message_clear_start:optimization_guide.proto.AXAttribute)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    clear_attribute_key();
    clear_attribute_value();
    _internal_metadata_.Clear<std::string>();
}

const char* AXAttribute::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // .optimization_guide.proto.AXStringAttribute string_type = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                _internal_set_string_type(static_cast<::optimization_guide::proto::AXStringAttribute>(val));
            } else
                goto handle_unusual;
            continue;
        // .optimization_guide.proto.AXIntAttribute int_type = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                _internal_set_int_type(static_cast<::optimization_guide::proto::AXIntAttribute>(val));
            } else
                goto handle_unusual;
            continue;
        // .optimization_guide.proto.AXFloatAttribute float_type = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                _internal_set_float_type(static_cast<::optimization_guide::proto::AXFloatAttribute>(val));
            } else
                goto handle_unusual;
            continue;
        // .optimization_guide.proto.AXBoolAttribute bool_type = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                _internal_set_bool_type(static_cast<::optimization_guide::proto::AXBoolAttribute>(val));
            } else
                goto handle_unusual;
            continue;
        // .optimization_guide.proto.AXIntListAttribute intlist_type = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                _internal_set_intlist_type(static_cast<::optimization_guide::proto::AXIntListAttribute>(val));
            } else
                goto handle_unusual;
            continue;
        // .optimization_guide.proto.AXStringListAttribute stringlist_type = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                _internal_set_stringlist_type(static_cast<::optimization_guide::proto::AXStringListAttribute>(val));
            } else
                goto handle_unusual;
            continue;
        // string html_attribute_name = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
                auto str = _internal_mutable_html_attribute_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // string string_value = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
                auto str = _internal_mutable_string_value();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // int32 int_value = 9;
        case 9:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
                _internal_set_int_value(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // float float_value = 10;
        case 10:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 85)) {
                _internal_set_float_value(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
                ptr += sizeof(float);
            } else
                goto handle_unusual;
            continue;
        // bool bool_value = 11;
        case 11:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
                _internal_set_bool_value(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .optimization_guide.proto.AXIntList int_list_value = 12;
        case 12:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
                ptr = ctx->ParseMessage(_internal_mutable_int_list_value(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .optimization_guide.proto.AXStringList string_list_value = 13;
        case 13:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
                ptr = ctx->ParseMessage(_internal_mutable_string_list_value(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // string html_attribute_value = 14;
        case 14:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
                auto str = _internal_mutable_html_attribute_value();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* AXAttribute::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:optimization_guide.proto.AXAttribute)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // .optimization_guide.proto.AXStringAttribute string_type = 1;
    if (_internal_has_string_type()) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(1, this->_internal_string_type(), target);
    }

    // .optimization_guide.proto.AXIntAttribute int_type = 2;
    if (_internal_has_int_type()) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(2, this->_internal_int_type(), target);
    }

    // .optimization_guide.proto.AXFloatAttribute float_type = 3;
    if (_internal_has_float_type()) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(3, this->_internal_float_type(), target);
    }

    // .optimization_guide.proto.AXBoolAttribute bool_type = 4;
    if (_internal_has_bool_type()) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(4, this->_internal_bool_type(), target);
    }

    // .optimization_guide.proto.AXIntListAttribute intlist_type = 5;
    if (_internal_has_intlist_type()) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(5, this->_internal_intlist_type(), target);
    }

    // .optimization_guide.proto.AXStringListAttribute stringlist_type = 6;
    if (_internal_has_stringlist_type()) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(6, this->_internal_stringlist_type(), target);
    }

    // string html_attribute_name = 7;
    if (_internal_has_html_attribute_name()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_html_attribute_name().data(),
            static_cast<int>(this->_internal_html_attribute_name().length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
            "optimization_guide.proto.AXAttribute.html_attribute_name");
        target = stream->WriteStringMaybeAliased(7, this->_internal_html_attribute_name(), target);
    }

    // string string_value = 8;
    if (_internal_has_string_value()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_string_value().data(),
            static_cast<int>(this->_internal_string_value().length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
            "optimization_guide.proto.AXAttribute.string_value");
        target = stream->WriteStringMaybeAliased(8, this->_internal_string_value(), target);
    }

    // int32 int_value = 9;
    if (_internal_has_int_value()) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(9, this->_internal_int_value(), target);
    }

    // float float_value = 10;
    if (_internal_has_float_value()) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteFloatToArray(10, this->_internal_float_value(), target);
    }

    // bool bool_value = 11;
    if (_internal_has_bool_value()) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(11, this->_internal_bool_value(), target);
    }

    // .optimization_guide.proto.AXIntList int_list_value = 12;
    if (_internal_has_int_list_value()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            12, _Internal::int_list_value(this), _Internal::int_list_value(this).GetCachedSize(), target, stream);
    }

    // .optimization_guide.proto.AXStringList string_list_value = 13;
    if (_internal_has_string_list_value()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            13, _Internal::string_list_value(this), _Internal::string_list_value(this).GetCachedSize(), target, stream);
    }

    // string html_attribute_value = 14;
    if (_internal_has_html_attribute_value()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_html_attribute_value().data(),
            static_cast<int>(this->_internal_html_attribute_value().length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
            "optimization_guide.proto.AXAttribute.html_attribute_value");
        target = stream->WriteStringMaybeAliased(14, this->_internal_html_attribute_value(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:optimization_guide.proto.AXAttribute)
    return target;
}

size_t AXAttribute::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:optimization_guide.proto.AXAttribute)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    switch (attribute_key_case()) {
    // .optimization_guide.proto.AXStringAttribute string_type = 1;
    case kStringType: {
        total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_string_type());
        break;
    }
    // .optimization_guide.proto.AXIntAttribute int_type = 2;
    case kIntType: {
        total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_int_type());
        break;
    }
    // .optimization_guide.proto.AXFloatAttribute float_type = 3;
    case kFloatType: {
        total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_float_type());
        break;
    }
    // .optimization_guide.proto.AXBoolAttribute bool_type = 4;
    case kBoolType: {
        total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_bool_type());
        break;
    }
    // .optimization_guide.proto.AXIntListAttribute intlist_type = 5;
    case kIntlistType: {
        total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_intlist_type());
        break;
    }
    // .optimization_guide.proto.AXStringListAttribute stringlist_type = 6;
    case kStringlistType: {
        total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_stringlist_type());
        break;
    }
    // string html_attribute_name = 7;
    case kHtmlAttributeName: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_html_attribute_name());
        break;
    }
    case ATTRIBUTE_KEY_NOT_SET: {
        break;
    }
    }
    switch (attribute_value_case()) {
    // string string_value = 8;
    case kStringValue: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_string_value());
        break;
    }
    // int32 int_value = 9;
    case kIntValue: {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_int_value());
        break;
    }
    // float float_value = 10;
    case kFloatValue: {
        total_size += 1 + 4;
        break;
    }
    // bool bool_value = 11;
    case kBoolValue: {
        total_size += 1 + 1;
        break;
    }
    // .optimization_guide.proto.AXIntList int_list_value = 12;
    case kIntListValue: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.attribute_value_.int_list_value_);
        break;
    }
    // .optimization_guide.proto.AXStringList string_list_value = 13;
    case kStringListValue: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.attribute_value_.string_list_value_);
        break;
    }
    // string html_attribute_value = 14;
    case kHtmlAttributeValue: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_html_attribute_value());
        break;
    }
    case ATTRIBUTE_VALUE_NOT_SET: {
        break;
    }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void AXAttribute::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const AXAttribute*>(&from));
}

void AXAttribute::MergeFrom(const AXAttribute& from)
{
    AXAttribute* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:optimization_guide.proto.AXAttribute)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    switch (from.attribute_key_case()) {
    case kStringType: {
        _this->_internal_set_string_type(from._internal_string_type());
        break;
    }
    case kIntType: {
        _this->_internal_set_int_type(from._internal_int_type());
        break;
    }
    case kFloatType: {
        _this->_internal_set_float_type(from._internal_float_type());
        break;
    }
    case kBoolType: {
        _this->_internal_set_bool_type(from._internal_bool_type());
        break;
    }
    case kIntlistType: {
        _this->_internal_set_intlist_type(from._internal_intlist_type());
        break;
    }
    case kStringlistType: {
        _this->_internal_set_stringlist_type(from._internal_stringlist_type());
        break;
    }
    case kHtmlAttributeName: {
        _this->_internal_set_html_attribute_name(from._internal_html_attribute_name());
        break;
    }
    case ATTRIBUTE_KEY_NOT_SET: {
        break;
    }
    }
    switch (from.attribute_value_case()) {
    case kStringValue: {
        _this->_internal_set_string_value(from._internal_string_value());
        break;
    }
    case kIntValue: {
        _this->_internal_set_int_value(from._internal_int_value());
        break;
    }
    case kFloatValue: {
        _this->_internal_set_float_value(from._internal_float_value());
        break;
    }
    case kBoolValue: {
        _this->_internal_set_bool_value(from._internal_bool_value());
        break;
    }
    case kIntListValue: {
        _this->_internal_mutable_int_list_value()->::optimization_guide::proto::AXIntList::MergeFrom(from._internal_int_list_value());
        break;
    }
    case kStringListValue: {
        _this->_internal_mutable_string_list_value()->::optimization_guide::proto::AXStringList::MergeFrom(from._internal_string_list_value());
        break;
    }
    case kHtmlAttributeValue: {
        _this->_internal_set_html_attribute_value(from._internal_html_attribute_value());
        break;
    }
    case ATTRIBUTE_VALUE_NOT_SET: {
        break;
    }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AXAttribute::CopyFrom(const AXAttribute& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:optimization_guide.proto.AXAttribute)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool AXAttribute::IsInitialized() const
{
    return true;
}

void AXAttribute::InternalSwap(AXAttribute* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_.attribute_key_, other->_impl_.attribute_key_);
    swap(_impl_.attribute_value_, other->_impl_.attribute_value_);
    swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
    swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
}

std::string AXAttribute::GetTypeName() const
{
    return "optimization_guide.proto.AXAttribute";
}

// ===================================================================

class AXIntList::_Internal {
public:
};

AXIntList::AXIntList(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:optimization_guide.proto.AXIntList)
}
AXIntList::AXIntList(const AXIntList& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    AXIntList* const _this = this;
    (void)_this;
    new (&_impl_)
        Impl_ { decltype(_impl_.value_) { from._impl_.value_ }, /*decltype(_impl_._value_cached_byte_size_)*/ { 0 }, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:optimization_guide.proto.AXIntList)
}

inline void AXIntList::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.value_) { arena }, /*decltype(_impl_._value_cached_byte_size_)*/ { 0 }, /*decltype(_impl_._cached_size_)*/ {} };
}

AXIntList::~AXIntList()
{
    // @@protoc_insertion_point(destructor:optimization_guide.proto.AXIntList)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void AXIntList::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.value_.~RepeatedField();
}

void AXIntList::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void AXIntList::Clear()
{
    // @@protoc_insertion_point(message_clear_start:optimization_guide.proto.AXIntList)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.value_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* AXIntList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated int32 value = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_value(), ptr, ctx);
                CHK_(ptr);
            } else if (static_cast<uint8_t>(tag) == 8) {
                _internal_add_value(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* AXIntList::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:optimization_guide.proto.AXIntList)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated int32 value = 1;
    {
        int byte_size = _impl_._value_cached_byte_size_.load(std::memory_order_relaxed);
        if (byte_size > 0) {
            target = stream->WriteInt32Packed(1, _internal_value(), byte_size, target);
        }
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:optimization_guide.proto.AXIntList)
    return target;
}

size_t AXIntList::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:optimization_guide.proto.AXIntList)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated int32 value = 1;
    {
        size_t data_size = ::_pbi::WireFormatLite::Int32Size(this->_impl_.value_);
        if (data_size > 0) {
            total_size += 1 + ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
        }
        int cached_size = ::_pbi::ToCachedSize(data_size);
        _impl_._value_cached_byte_size_.store(cached_size, std::memory_order_relaxed);
        total_size += data_size;
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void AXIntList::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const AXIntList*>(&from));
}

void AXIntList::MergeFrom(const AXIntList& from)
{
    AXIntList* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:optimization_guide.proto.AXIntList)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.value_.MergeFrom(from._impl_.value_);
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AXIntList::CopyFrom(const AXIntList& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:optimization_guide.proto.AXIntList)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool AXIntList::IsInitialized() const
{
    return true;
}

void AXIntList::InternalSwap(AXIntList* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.value_.InternalSwap(&other->_impl_.value_);
}

std::string AXIntList::GetTypeName() const
{
    return "optimization_guide.proto.AXIntList";
}

// ===================================================================

class AXStringList::_Internal {
public:
};

AXStringList::AXStringList(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:optimization_guide.proto.AXStringList)
}
AXStringList::AXStringList(const AXStringList& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    AXStringList* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.value_) { from._impl_.value_ }, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:optimization_guide.proto.AXStringList)
}

inline void AXStringList::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.value_) { arena }, /*decltype(_impl_._cached_size_)*/ {} };
}

AXStringList::~AXStringList()
{
    // @@protoc_insertion_point(destructor:optimization_guide.proto.AXStringList)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void AXStringList::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.value_.~RepeatedPtrField();
}

void AXStringList::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void AXStringList::Clear()
{
    // @@protoc_insertion_point(message_clear_start:optimization_guide.proto.AXStringList)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.value_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* AXStringList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated string value = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    auto str = _internal_add_value();
                    ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(ptr);
                    CHK_(::_pbi::VerifyUTF8(str, nullptr));
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* AXStringList::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:optimization_guide.proto.AXStringList)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated string value = 1;
    for (int i = 0, n = this->_internal_value_size(); i < n; i++) {
        const auto& s = this->_internal_value(i);
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s.data(), static_cast<int>(s.length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "optimization_guide.proto.AXStringList.value");
        target = stream->WriteString(1, s, target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:optimization_guide.proto.AXStringList)
    return target;
}

size_t AXStringList::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:optimization_guide.proto.AXStringList)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated string value = 1;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.value_.size());
    for (int i = 0, n = _impl_.value_.size(); i < n; i++) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(_impl_.value_.Get(i));
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void AXStringList::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const AXStringList*>(&from));
}

void AXStringList::MergeFrom(const AXStringList& from)
{
    AXStringList* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:optimization_guide.proto.AXStringList)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.value_.MergeFrom(from._impl_.value_);
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AXStringList::CopyFrom(const AXStringList& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:optimization_guide.proto.AXStringList)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool AXStringList::IsInitialized() const
{
    return true;
}

void AXStringList::InternalSwap(AXStringList* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.value_.InternalSwap(&other->_impl_.value_);
}

std::string AXStringList::GetTypeName() const
{
    return "optimization_guide.proto.AXStringList";
}

// ===================================================================

class AXRelativeBounds::_Internal {
public:
};

AXRelativeBounds::AXRelativeBounds(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:optimization_guide.proto.AXRelativeBounds)
}
AXRelativeBounds::AXRelativeBounds(const AXRelativeBounds& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    AXRelativeBounds* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.transform_) { from._impl_.transform_ }, decltype(_impl_.offset_container_id_) {}, decltype(_impl_.x_) {},
        decltype(_impl_.y_) {}, decltype(_impl_.width_) {}, decltype(_impl_.height_) {}, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.offset_container_id_, &from._impl_.offset_container_id_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.height_) - reinterpret_cast<char*>(&_impl_.offset_container_id_)) + sizeof(_impl_.height_));
    // @@protoc_insertion_point(copy_constructor:optimization_guide.proto.AXRelativeBounds)
}

inline void AXRelativeBounds::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.transform_) { arena }, decltype(_impl_.offset_container_id_) { 0 }, decltype(_impl_.x_) { 0 },
        decltype(_impl_.y_) { 0 }, decltype(_impl_.width_) { 0 }, decltype(_impl_.height_) { 0 }, /*decltype(_impl_._cached_size_)*/ {} };
}

AXRelativeBounds::~AXRelativeBounds()
{
    // @@protoc_insertion_point(destructor:optimization_guide.proto.AXRelativeBounds)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void AXRelativeBounds::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.transform_.~RepeatedField();
}

void AXRelativeBounds::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void AXRelativeBounds::Clear()
{
    // @@protoc_insertion_point(message_clear_start:optimization_guide.proto.AXRelativeBounds)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.transform_.Clear();
    ::memset(&_impl_.offset_container_id_, 0,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.height_) - reinterpret_cast<char*>(&_impl_.offset_container_id_)) + sizeof(_impl_.height_));
    _internal_metadata_.Clear<std::string>();
}

const char* AXRelativeBounds::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // int32 offset_container_id = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _impl_.offset_container_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // float x = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
                _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
                ptr += sizeof(float);
            } else
                goto handle_unusual;
            continue;
        // float y = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
                _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
                ptr += sizeof(float);
            } else
                goto handle_unusual;
            continue;
        // float width = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
                _impl_.width_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
                ptr += sizeof(float);
            } else
                goto handle_unusual;
            continue;
        // float height = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
                _impl_.height_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
                ptr += sizeof(float);
            } else
                goto handle_unusual;
            continue;
        // repeated float transform = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_transform(), ptr, ctx);
                CHK_(ptr);
            } else if (static_cast<uint8_t>(tag) == 53) {
                _internal_add_transform(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
                ptr += sizeof(float);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* AXRelativeBounds::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:optimization_guide.proto.AXRelativeBounds)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // int32 offset_container_id = 1;
    if (this->_internal_offset_container_id() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_offset_container_id(), target);
    }

    // float x = 2;
    static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
    float tmp_x = this->_internal_x();
    uint32_t raw_x;
    memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
    if (raw_x != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_x(), target);
    }

    // float y = 3;
    static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
    float tmp_y = this->_internal_y();
    uint32_t raw_y;
    memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
    if (raw_y != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_y(), target);
    }

    // float width = 4;
    static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
    float tmp_width = this->_internal_width();
    uint32_t raw_width;
    memcpy(&raw_width, &tmp_width, sizeof(tmp_width));
    if (raw_width != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_width(), target);
    }

    // float height = 5;
    static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
    float tmp_height = this->_internal_height();
    uint32_t raw_height;
    memcpy(&raw_height, &tmp_height, sizeof(tmp_height));
    if (raw_height != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_height(), target);
    }

    // repeated float transform = 6;
    if (this->_internal_transform_size() > 0) {
        target = stream->WriteFixedPacked(6, _internal_transform(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:optimization_guide.proto.AXRelativeBounds)
    return target;
}

size_t AXRelativeBounds::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:optimization_guide.proto.AXRelativeBounds)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated float transform = 6;
    {
        unsigned int count = static_cast<unsigned int>(this->_internal_transform_size());
        size_t data_size = 4UL * count;
        if (data_size > 0) {
            total_size += 1 + ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
        }
        total_size += data_size;
    }

    // int32 offset_container_id = 1;
    if (this->_internal_offset_container_id() != 0) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_offset_container_id());
    }

    // float x = 2;
    static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
    float tmp_x = this->_internal_x();
    uint32_t raw_x;
    memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
    if (raw_x != 0) {
        total_size += 1 + 4;
    }

    // float y = 3;
    static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
    float tmp_y = this->_internal_y();
    uint32_t raw_y;
    memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
    if (raw_y != 0) {
        total_size += 1 + 4;
    }

    // float width = 4;
    static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
    float tmp_width = this->_internal_width();
    uint32_t raw_width;
    memcpy(&raw_width, &tmp_width, sizeof(tmp_width));
    if (raw_width != 0) {
        total_size += 1 + 4;
    }

    // float height = 5;
    static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
    float tmp_height = this->_internal_height();
    uint32_t raw_height;
    memcpy(&raw_height, &tmp_height, sizeof(tmp_height));
    if (raw_height != 0) {
        total_size += 1 + 4;
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void AXRelativeBounds::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const AXRelativeBounds*>(&from));
}

void AXRelativeBounds::MergeFrom(const AXRelativeBounds& from)
{
    AXRelativeBounds* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:optimization_guide.proto.AXRelativeBounds)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.transform_.MergeFrom(from._impl_.transform_);
    if (from._internal_offset_container_id() != 0) {
        _this->_internal_set_offset_container_id(from._internal_offset_container_id());
    }
    static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
    float tmp_x = from._internal_x();
    uint32_t raw_x;
    memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
    if (raw_x != 0) {
        _this->_internal_set_x(from._internal_x());
    }
    static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
    float tmp_y = from._internal_y();
    uint32_t raw_y;
    memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
    if (raw_y != 0) {
        _this->_internal_set_y(from._internal_y());
    }
    static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
    float tmp_width = from._internal_width();
    uint32_t raw_width;
    memcpy(&raw_width, &tmp_width, sizeof(tmp_width));
    if (raw_width != 0) {
        _this->_internal_set_width(from._internal_width());
    }
    static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
    float tmp_height = from._internal_height();
    uint32_t raw_height;
    memcpy(&raw_height, &tmp_height, sizeof(tmp_height));
    if (raw_height != 0) {
        _this->_internal_set_height(from._internal_height());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AXRelativeBounds::CopyFrom(const AXRelativeBounds& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:optimization_guide.proto.AXRelativeBounds)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool AXRelativeBounds::IsInitialized() const
{
    return true;
}

void AXRelativeBounds::InternalSwap(AXRelativeBounds* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.transform_.InternalSwap(&other->_impl_.transform_);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(AXRelativeBounds, _impl_.height_) + sizeof(AXRelativeBounds::_impl_.height_)
        - PROTOBUF_FIELD_OFFSET(AXRelativeBounds, _impl_.offset_container_id_)>(
        reinterpret_cast<char*>(&_impl_.offset_container_id_), reinterpret_cast<char*>(&other->_impl_.offset_container_id_));
}

std::string AXRelativeBounds::GetTypeName() const
{
    return "optimization_guide.proto.AXRelativeBounds";
}

// ===================================================================

class PageContext::_Internal {
public:
    static const ::optimization_guide::proto::AXTreeUpdate& ax_tree_data(const PageContext* msg);
};

const ::optimization_guide::proto::AXTreeUpdate& PageContext::_Internal::ax_tree_data(const PageContext* msg)
{
    return *msg->_impl_.ax_tree_data_;
}
PageContext::PageContext(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:optimization_guide.proto.PageContext)
}
PageContext::PageContext(const PageContext& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    PageContext* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.url_) {}, decltype(_impl_.title_) {}, decltype(_impl_.inner_text_) {}, decltype(_impl_.tab_screenshot_) {},
        decltype(_impl_.pdf_data_) {}, decltype(_impl_.ax_tree_data_) { nullptr }, decltype(_impl_.inner_text_offset_) {},
        /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_url().empty()) {
        _this->_impl_.url_.Set(from._internal_url(), _this->GetArenaForAllocation());
    }
    _impl_.title_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_title().empty()) {
        _this->_impl_.title_.Set(from._internal_title(), _this->GetArenaForAllocation());
    }
    _impl_.inner_text_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.inner_text_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_inner_text().empty()) {
        _this->_impl_.inner_text_.Set(from._internal_inner_text(), _this->GetArenaForAllocation());
    }
    _impl_.tab_screenshot_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tab_screenshot_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_tab_screenshot().empty()) {
        _this->_impl_.tab_screenshot_.Set(from._internal_tab_screenshot(), _this->GetArenaForAllocation());
    }
    _impl_.pdf_data_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pdf_data_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_pdf_data().empty()) {
        _this->_impl_.pdf_data_.Set(from._internal_pdf_data(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_ax_tree_data()) {
        _this->_impl_.ax_tree_data_ = new ::optimization_guide::proto::AXTreeUpdate(*from._impl_.ax_tree_data_);
    }
    _this->_impl_.inner_text_offset_ = from._impl_.inner_text_offset_;
    // @@protoc_insertion_point(copy_constructor:optimization_guide.proto.PageContext)
}

inline void PageContext::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.url_) {}, decltype(_impl_.title_) {}, decltype(_impl_.inner_text_) {}, decltype(_impl_.tab_screenshot_) {},
        decltype(_impl_.pdf_data_) {}, decltype(_impl_.ax_tree_data_) { nullptr }, decltype(_impl_.inner_text_offset_) { uint64_t { 0u } },
        /*decltype(_impl_._cached_size_)*/ {} };
    _impl_.url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.inner_text_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.inner_text_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tab_screenshot_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tab_screenshot_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pdf_data_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pdf_data_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PageContext::~PageContext()
{
    // @@protoc_insertion_point(destructor:optimization_guide.proto.PageContext)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void PageContext::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.url_.Destroy();
    _impl_.title_.Destroy();
    _impl_.inner_text_.Destroy();
    _impl_.tab_screenshot_.Destroy();
    _impl_.pdf_data_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.ax_tree_data_;
}

void PageContext::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void PageContext::Clear()
{
    // @@protoc_insertion_point(message_clear_start:optimization_guide.proto.PageContext)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.url_.ClearToEmpty();
    _impl_.title_.ClearToEmpty();
    _impl_.inner_text_.ClearToEmpty();
    _impl_.tab_screenshot_.ClearToEmpty();
    _impl_.pdf_data_.ClearToEmpty();
    if (GetArenaForAllocation() == nullptr && _impl_.ax_tree_data_ != nullptr) {
        delete _impl_.ax_tree_data_;
    }
    _impl_.ax_tree_data_ = nullptr;
    _impl_.inner_text_offset_ = uint64_t { 0u };
    _internal_metadata_.Clear<std::string>();
}

const char* PageContext::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // string url = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // string title = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_title();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // .optimization_guide.proto.AXTreeUpdate ax_tree_data = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr = ctx->ParseMessage(_internal_mutable_ax_tree_data(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // string inner_text = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                auto str = _internal_mutable_inner_text();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // uint64 inner_text_offset = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
                _impl_.inner_text_offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // string tab_screenshot = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
                auto str = _internal_mutable_tab_screenshot();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // string pdf_data = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
                auto str = _internal_mutable_pdf_data();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* PageContext::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:optimization_guide.proto.PageContext)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // string url = 1;
    if (!this->_internal_url().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_url().data(), static_cast<int>(this->_internal_url().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "optimization_guide.proto.PageContext.url");
        target = stream->WriteStringMaybeAliased(1, this->_internal_url(), target);
    }

    // string title = 2;
    if (!this->_internal_title().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_title().data(), static_cast<int>(this->_internal_title().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "optimization_guide.proto.PageContext.title");
        target = stream->WriteStringMaybeAliased(2, this->_internal_title(), target);
    }

    // .optimization_guide.proto.AXTreeUpdate ax_tree_data = 3;
    if (this->_internal_has_ax_tree_data()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            3, _Internal::ax_tree_data(this), _Internal::ax_tree_data(this).GetCachedSize(), target, stream);
    }

    // string inner_text = 4;
    if (!this->_internal_inner_text().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_inner_text().data(),
            static_cast<int>(this->_internal_inner_text().length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
            "optimization_guide.proto.PageContext.inner_text");
        target = stream->WriteStringMaybeAliased(4, this->_internal_inner_text(), target);
    }

    // uint64 inner_text_offset = 5;
    if (this->_internal_inner_text_offset() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_inner_text_offset(), target);
    }

    // string tab_screenshot = 6;
    if (!this->_internal_tab_screenshot().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_tab_screenshot().data(),
            static_cast<int>(this->_internal_tab_screenshot().length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
            "optimization_guide.proto.PageContext.tab_screenshot");
        target = stream->WriteStringMaybeAliased(6, this->_internal_tab_screenshot(), target);
    }

    // string pdf_data = 7;
    if (!this->_internal_pdf_data().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_pdf_data().data(),
            static_cast<int>(this->_internal_pdf_data().length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
            "optimization_guide.proto.PageContext.pdf_data");
        target = stream->WriteStringMaybeAliased(7, this->_internal_pdf_data(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:optimization_guide.proto.PageContext)
    return target;
}

size_t PageContext::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:optimization_guide.proto.PageContext)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // string url = 1;
    if (!this->_internal_url().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_url());
    }

    // string title = 2;
    if (!this->_internal_title().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_title());
    }

    // string inner_text = 4;
    if (!this->_internal_inner_text().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_inner_text());
    }

    // string tab_screenshot = 6;
    if (!this->_internal_tab_screenshot().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_tab_screenshot());
    }

    // string pdf_data = 7;
    if (!this->_internal_pdf_data().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_pdf_data());
    }

    // .optimization_guide.proto.AXTreeUpdate ax_tree_data = 3;
    if (this->_internal_has_ax_tree_data()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.ax_tree_data_);
    }

    // uint64 inner_text_offset = 5;
    if (this->_internal_inner_text_offset() != 0) {
        total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_inner_text_offset());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void PageContext::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const PageContext*>(&from));
}

void PageContext::MergeFrom(const PageContext& from)
{
    PageContext* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:optimization_guide.proto.PageContext)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (!from._internal_url().empty()) {
        _this->_internal_set_url(from._internal_url());
    }
    if (!from._internal_title().empty()) {
        _this->_internal_set_title(from._internal_title());
    }
    if (!from._internal_inner_text().empty()) {
        _this->_internal_set_inner_text(from._internal_inner_text());
    }
    if (!from._internal_tab_screenshot().empty()) {
        _this->_internal_set_tab_screenshot(from._internal_tab_screenshot());
    }
    if (!from._internal_pdf_data().empty()) {
        _this->_internal_set_pdf_data(from._internal_pdf_data());
    }
    if (from._internal_has_ax_tree_data()) {
        _this->_internal_mutable_ax_tree_data()->::optimization_guide::proto::AXTreeUpdate::MergeFrom(from._internal_ax_tree_data());
    }
    if (from._internal_inner_text_offset() != 0) {
        _this->_internal_set_inner_text_offset(from._internal_inner_text_offset());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PageContext::CopyFrom(const PageContext& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:optimization_guide.proto.PageContext)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool PageContext::IsInitialized() const
{
    return true;
}

void PageContext::InternalSwap(PageContext* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.url_, lhs_arena, &other->_impl_.url_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.title_, lhs_arena, &other->_impl_.title_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.inner_text_, lhs_arena, &other->_impl_.inner_text_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.tab_screenshot_, lhs_arena, &other->_impl_.tab_screenshot_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.pdf_data_, lhs_arena, &other->_impl_.pdf_data_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(PageContext, _impl_.inner_text_offset_) + sizeof(PageContext::_impl_.inner_text_offset_)
        - PROTOBUF_FIELD_OFFSET(PageContext, _impl_.ax_tree_data_)>(
        reinterpret_cast<char*>(&_impl_.ax_tree_data_), reinterpret_cast<char*>(&other->_impl_.ax_tree_data_));
}

std::string PageContext::GetTypeName() const
{
    return "optimization_guide.proto.PageContext";
}

// ===================================================================

class FormData::_Internal {
public:
};

FormData::FormData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:optimization_guide.proto.FormData)
}
FormData::FormData(const FormData& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    FormData* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.fields_) { from._impl_.fields_ }, decltype(_impl_.form_name_) {}, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.form_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.form_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_form_name().empty()) {
        _this->_impl_.form_name_.Set(from._internal_form_name(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:optimization_guide.proto.FormData)
}

inline void FormData::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.fields_) { arena }, decltype(_impl_.form_name_) {}, /*decltype(_impl_._cached_size_)*/ {} };
    _impl_.form_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.form_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FormData::~FormData()
{
    // @@protoc_insertion_point(destructor:optimization_guide.proto.FormData)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void FormData::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.fields_.~RepeatedPtrField();
    _impl_.form_name_.Destroy();
}

void FormData::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void FormData::Clear()
{
    // @@protoc_insertion_point(message_clear_start:optimization_guide.proto.FormData)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.fields_.Clear();
    _impl_.form_name_.ClearToEmpty();
    _internal_metadata_.Clear<std::string>();
}

const char* FormData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // string form_name = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_form_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // repeated .optimization_guide.proto.FormFieldData fields = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_fields(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* FormData::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:optimization_guide.proto.FormData)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // string form_name = 1;
    if (!this->_internal_form_name().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_form_name().data(),
            static_cast<int>(this->_internal_form_name().length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
            "optimization_guide.proto.FormData.form_name");
        target = stream->WriteStringMaybeAliased(1, this->_internal_form_name(), target);
    }

    // repeated .optimization_guide.proto.FormFieldData fields = 2;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_fields_size()); i < n; i++) {
        const auto& repfield = this->_internal_fields(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:optimization_guide.proto.FormData)
    return target;
}

size_t FormData::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:optimization_guide.proto.FormData)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .optimization_guide.proto.FormFieldData fields = 2;
    total_size += 1UL * this->_internal_fields_size();
    for (const auto& msg : this->_impl_.fields_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // string form_name = 1;
    if (!this->_internal_form_name().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_form_name());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void FormData::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const FormData*>(&from));
}

void FormData::MergeFrom(const FormData& from)
{
    FormData* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:optimization_guide.proto.FormData)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.fields_.MergeFrom(from._impl_.fields_);
    if (!from._internal_form_name().empty()) {
        _this->_internal_set_form_name(from._internal_form_name());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FormData::CopyFrom(const FormData& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:optimization_guide.proto.FormData)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool FormData::IsInitialized() const
{
    return true;
}

void FormData::InternalSwap(FormData* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.fields_.InternalSwap(&other->_impl_.fields_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.form_name_, lhs_arena, &other->_impl_.form_name_, rhs_arena);
}

std::string FormData::GetTypeName() const
{
    return "optimization_guide.proto.FormData";
}

// ===================================================================

class FormFieldData::_Internal {
public:
};

FormFieldData::FormFieldData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:optimization_guide.proto.FormFieldData)
}
FormFieldData::FormFieldData(const FormFieldData& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    FormFieldData* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.select_options_) { from._impl_.select_options_ }, decltype(_impl_.field_name_) {}, decltype(_impl_.field_label_) {},
        decltype(_impl_.field_value_) {}, decltype(_impl_.placeholder_) {}, decltype(_impl_.global_id_) {}, decltype(_impl_.form_control_type_) {},
        decltype(_impl_.is_visible_) {}, decltype(_impl_.is_focusable_) {}, decltype(_impl_.is_eligible_) {}, decltype(_impl_.form_control_ax_node_id_) {},
        /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.field_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.field_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_field_name().empty()) {
        _this->_impl_.field_name_.Set(from._internal_field_name(), _this->GetArenaForAllocation());
    }
    _impl_.field_label_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.field_label_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_field_label().empty()) {
        _this->_impl_.field_label_.Set(from._internal_field_label(), _this->GetArenaForAllocation());
    }
    _impl_.field_value_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.field_value_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_field_value().empty()) {
        _this->_impl_.field_value_.Set(from._internal_field_value(), _this->GetArenaForAllocation());
    }
    _impl_.placeholder_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.placeholder_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_placeholder().empty()) {
        _this->_impl_.placeholder_.Set(from._internal_placeholder(), _this->GetArenaForAllocation());
    }
    _impl_.global_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.global_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_global_id().empty()) {
        _this->_impl_.global_id_.Set(from._internal_global_id(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.form_control_type_, &from._impl_.form_control_type_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.form_control_ax_node_id_) - reinterpret_cast<char*>(&_impl_.form_control_type_))
            + sizeof(_impl_.form_control_ax_node_id_));
    // @@protoc_insertion_point(copy_constructor:optimization_guide.proto.FormFieldData)
}

inline void FormFieldData::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.select_options_) { arena }, decltype(_impl_.field_name_) {}, decltype(_impl_.field_label_) {},
        decltype(_impl_.field_value_) {}, decltype(_impl_.placeholder_) {}, decltype(_impl_.global_id_) {}, decltype(_impl_.form_control_type_) { 0 },
        decltype(_impl_.is_visible_) { false }, decltype(_impl_.is_focusable_) { false }, decltype(_impl_.is_eligible_) { false },
        decltype(_impl_.form_control_ax_node_id_) { 0 }, /*decltype(_impl_._cached_size_)*/ {} };
    _impl_.field_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.field_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.field_label_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.field_label_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.field_value_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.field_value_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.placeholder_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.placeholder_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.global_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.global_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FormFieldData::~FormFieldData()
{
    // @@protoc_insertion_point(destructor:optimization_guide.proto.FormFieldData)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void FormFieldData::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.select_options_.~RepeatedPtrField();
    _impl_.field_name_.Destroy();
    _impl_.field_label_.Destroy();
    _impl_.field_value_.Destroy();
    _impl_.placeholder_.Destroy();
    _impl_.global_id_.Destroy();
}

void FormFieldData::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void FormFieldData::Clear()
{
    // @@protoc_insertion_point(message_clear_start:optimization_guide.proto.FormFieldData)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.select_options_.Clear();
    _impl_.field_name_.ClearToEmpty();
    _impl_.field_label_.ClearToEmpty();
    _impl_.field_value_.ClearToEmpty();
    _impl_.placeholder_.ClearToEmpty();
    _impl_.global_id_.ClearToEmpty();
    ::memset(&_impl_.form_control_type_, 0,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.form_control_ax_node_id_) - reinterpret_cast<char*>(&_impl_.form_control_type_))
            + sizeof(_impl_.form_control_ax_node_id_));
    _internal_metadata_.Clear<std::string>();
}

const char* FormFieldData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // string field_name = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_field_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // string field_label = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_field_label();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // string field_value = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_field_value();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // bool is_visible = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _impl_.is_visible_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // bool is_focusable = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
                _impl_.is_focusable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .optimization_guide.proto.FormControlType form_control_type = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                _internal_set_form_control_type(static_cast<::optimization_guide::proto::FormControlType>(val));
            } else
                goto handle_unusual;
            continue;
        // repeated .optimization_guide.proto.SelectOption select_options = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_select_options(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
            } else
                goto handle_unusual;
            continue;
        // string placeholder = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
                auto str = _internal_mutable_placeholder();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // int32 form_control_ax_node_id = 9;
        case 9:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
                _impl_.form_control_ax_node_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // bool is_eligible = 10;
        case 10:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
                _impl_.is_eligible_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // string global_id = 11;
        case 11:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
                auto str = _internal_mutable_global_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* FormFieldData::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:optimization_guide.proto.FormFieldData)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // string field_name = 1;
    if (!this->_internal_field_name().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_field_name().data(),
            static_cast<int>(this->_internal_field_name().length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
            "optimization_guide.proto.FormFieldData.field_name");
        target = stream->WriteStringMaybeAliased(1, this->_internal_field_name(), target);
    }

    // string field_label = 2;
    if (!this->_internal_field_label().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_field_label().data(),
            static_cast<int>(this->_internal_field_label().length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
            "optimization_guide.proto.FormFieldData.field_label");
        target = stream->WriteStringMaybeAliased(2, this->_internal_field_label(), target);
    }

    // string field_value = 3;
    if (!this->_internal_field_value().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_field_value().data(),
            static_cast<int>(this->_internal_field_value().length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
            "optimization_guide.proto.FormFieldData.field_value");
        target = stream->WriteStringMaybeAliased(3, this->_internal_field_value(), target);
    }

    // bool is_visible = 4;
    if (this->_internal_is_visible() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_is_visible(), target);
    }

    // bool is_focusable = 5;
    if (this->_internal_is_focusable() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_is_focusable(), target);
    }

    // .optimization_guide.proto.FormControlType form_control_type = 6;
    if (this->_internal_form_control_type() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(6, this->_internal_form_control_type(), target);
    }

    // repeated .optimization_guide.proto.SelectOption select_options = 7;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_select_options_size()); i < n; i++) {
        const auto& repfield = this->_internal_select_options(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
    }

    // string placeholder = 8;
    if (!this->_internal_placeholder().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_placeholder().data(),
            static_cast<int>(this->_internal_placeholder().length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
            "optimization_guide.proto.FormFieldData.placeholder");
        target = stream->WriteStringMaybeAliased(8, this->_internal_placeholder(), target);
    }

    // int32 form_control_ax_node_id = 9;
    if (this->_internal_form_control_ax_node_id() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(9, this->_internal_form_control_ax_node_id(), target);
    }

    // bool is_eligible = 10;
    if (this->_internal_is_eligible() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_is_eligible(), target);
    }

    // string global_id = 11;
    if (!this->_internal_global_id().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_global_id().data(),
            static_cast<int>(this->_internal_global_id().length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
            "optimization_guide.proto.FormFieldData.global_id");
        target = stream->WriteStringMaybeAliased(11, this->_internal_global_id(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:optimization_guide.proto.FormFieldData)
    return target;
}

size_t FormFieldData::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:optimization_guide.proto.FormFieldData)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .optimization_guide.proto.SelectOption select_options = 7;
    total_size += 1UL * this->_internal_select_options_size();
    for (const auto& msg : this->_impl_.select_options_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // string field_name = 1;
    if (!this->_internal_field_name().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_field_name());
    }

    // string field_label = 2;
    if (!this->_internal_field_label().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_field_label());
    }

    // string field_value = 3;
    if (!this->_internal_field_value().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_field_value());
    }

    // string placeholder = 8;
    if (!this->_internal_placeholder().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_placeholder());
    }

    // string global_id = 11;
    if (!this->_internal_global_id().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_global_id());
    }

    // .optimization_guide.proto.FormControlType form_control_type = 6;
    if (this->_internal_form_control_type() != 0) {
        total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_form_control_type());
    }

    // bool is_visible = 4;
    if (this->_internal_is_visible() != 0) {
        total_size += 1 + 1;
    }

    // bool is_focusable = 5;
    if (this->_internal_is_focusable() != 0) {
        total_size += 1 + 1;
    }

    // bool is_eligible = 10;
    if (this->_internal_is_eligible() != 0) {
        total_size += 1 + 1;
    }

    // int32 form_control_ax_node_id = 9;
    if (this->_internal_form_control_ax_node_id() != 0) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_form_control_ax_node_id());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void FormFieldData::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const FormFieldData*>(&from));
}

void FormFieldData::MergeFrom(const FormFieldData& from)
{
    FormFieldData* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:optimization_guide.proto.FormFieldData)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.select_options_.MergeFrom(from._impl_.select_options_);
    if (!from._internal_field_name().empty()) {
        _this->_internal_set_field_name(from._internal_field_name());
    }
    if (!from._internal_field_label().empty()) {
        _this->_internal_set_field_label(from._internal_field_label());
    }
    if (!from._internal_field_value().empty()) {
        _this->_internal_set_field_value(from._internal_field_value());
    }
    if (!from._internal_placeholder().empty()) {
        _this->_internal_set_placeholder(from._internal_placeholder());
    }
    if (!from._internal_global_id().empty()) {
        _this->_internal_set_global_id(from._internal_global_id());
    }
    if (from._internal_form_control_type() != 0) {
        _this->_internal_set_form_control_type(from._internal_form_control_type());
    }
    if (from._internal_is_visible() != 0) {
        _this->_internal_set_is_visible(from._internal_is_visible());
    }
    if (from._internal_is_focusable() != 0) {
        _this->_internal_set_is_focusable(from._internal_is_focusable());
    }
    if (from._internal_is_eligible() != 0) {
        _this->_internal_set_is_eligible(from._internal_is_eligible());
    }
    if (from._internal_form_control_ax_node_id() != 0) {
        _this->_internal_set_form_control_ax_node_id(from._internal_form_control_ax_node_id());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FormFieldData::CopyFrom(const FormFieldData& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:optimization_guide.proto.FormFieldData)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool FormFieldData::IsInitialized() const
{
    return true;
}

void FormFieldData::InternalSwap(FormFieldData* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.select_options_.InternalSwap(&other->_impl_.select_options_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.field_name_, lhs_arena, &other->_impl_.field_name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.field_label_, lhs_arena, &other->_impl_.field_label_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.field_value_, lhs_arena, &other->_impl_.field_value_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.placeholder_, lhs_arena, &other->_impl_.placeholder_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.global_id_, lhs_arena, &other->_impl_.global_id_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(FormFieldData, _impl_.form_control_ax_node_id_)
        + sizeof(FormFieldData::_impl_.form_control_ax_node_id_) - PROTOBUF_FIELD_OFFSET(FormFieldData, _impl_.form_control_type_)>(
        reinterpret_cast<char*>(&_impl_.form_control_type_), reinterpret_cast<char*>(&other->_impl_.form_control_type_));
}

std::string FormFieldData::GetTypeName() const
{
    return "optimization_guide.proto.FormFieldData";
}

// ===================================================================

class SelectOption::_Internal {
public:
};

SelectOption::SelectOption(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:optimization_guide.proto.SelectOption)
}
SelectOption::SelectOption(const SelectOption& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    SelectOption* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.value_) {}, decltype(_impl_.text_) {}, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.value_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_value().empty()) {
        _this->_impl_.value_.Set(from._internal_value(), _this->GetArenaForAllocation());
    }
    _impl_.text_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.text_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_text().empty()) {
        _this->_impl_.text_.Set(from._internal_text(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:optimization_guide.proto.SelectOption)
}

inline void SelectOption::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.value_) {}, decltype(_impl_.text_) {}, /*decltype(_impl_._cached_size_)*/ {} };
    _impl_.value_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.text_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.text_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SelectOption::~SelectOption()
{
    // @@protoc_insertion_point(destructor:optimization_guide.proto.SelectOption)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void SelectOption::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.value_.Destroy();
    _impl_.text_.Destroy();
}

void SelectOption::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void SelectOption::Clear()
{
    // @@protoc_insertion_point(message_clear_start:optimization_guide.proto.SelectOption)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.value_.ClearToEmpty();
    _impl_.text_.ClearToEmpty();
    _internal_metadata_.Clear<std::string>();
}

const char* SelectOption::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // string value = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_value();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // string text = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_text();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* SelectOption::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:optimization_guide.proto.SelectOption)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // string value = 1;
    if (!this->_internal_value().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_value().data(), static_cast<int>(this->_internal_value().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "optimization_guide.proto.SelectOption.value");
        target = stream->WriteStringMaybeAliased(1, this->_internal_value(), target);
    }

    // string text = 2;
    if (!this->_internal_text().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_text().data(), static_cast<int>(this->_internal_text().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "optimization_guide.proto.SelectOption.text");
        target = stream->WriteStringMaybeAliased(2, this->_internal_text(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:optimization_guide.proto.SelectOption)
    return target;
}

size_t SelectOption::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:optimization_guide.proto.SelectOption)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // string value = 1;
    if (!this->_internal_value().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_value());
    }

    // string text = 2;
    if (!this->_internal_text().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_text());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void SelectOption::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const SelectOption*>(&from));
}

void SelectOption::MergeFrom(const SelectOption& from)
{
    SelectOption* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:optimization_guide.proto.SelectOption)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (!from._internal_value().empty()) {
        _this->_internal_set_value(from._internal_value());
    }
    if (!from._internal_text().empty()) {
        _this->_internal_set_text(from._internal_text());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SelectOption::CopyFrom(const SelectOption& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:optimization_guide.proto.SelectOption)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool SelectOption::IsInitialized() const
{
    return true;
}

void SelectOption::InternalSwap(SelectOption* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.value_, lhs_arena, &other->_impl_.value_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.text_, lhs_arena, &other->_impl_.text_, rhs_arena);
}

std::string SelectOption::GetTypeName() const
{
    return "optimization_guide.proto.SelectOption";
}

// ===================================================================

class UserAnnotationsEntry::_Internal {
public:
};

UserAnnotationsEntry::UserAnnotationsEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:optimization_guide.proto.UserAnnotationsEntry)
}
UserAnnotationsEntry::UserAnnotationsEntry(const UserAnnotationsEntry& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    UserAnnotationsEntry* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.key_) {}, decltype(_impl_.value_) {}, decltype(_impl_.entry_id_) {}, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.key_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_key().empty()) {
        _this->_impl_.key_.Set(from._internal_key(), _this->GetArenaForAllocation());
    }
    _impl_.value_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_value().empty()) {
        _this->_impl_.value_.Set(from._internal_value(), _this->GetArenaForAllocation());
    }
    _this->_impl_.entry_id_ = from._impl_.entry_id_;
    // @@protoc_insertion_point(copy_constructor:optimization_guide.proto.UserAnnotationsEntry)
}

inline void UserAnnotationsEntry::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_)
        Impl_ { decltype(_impl_.key_) {}, decltype(_impl_.value_) {}, decltype(_impl_.entry_id_) { int64_t { 0 } }, /*decltype(_impl_._cached_size_)*/ {} };
    _impl_.key_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

UserAnnotationsEntry::~UserAnnotationsEntry()
{
    // @@protoc_insertion_point(destructor:optimization_guide.proto.UserAnnotationsEntry)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void UserAnnotationsEntry::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.key_.Destroy();
    _impl_.value_.Destroy();
}

void UserAnnotationsEntry::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void UserAnnotationsEntry::Clear()
{
    // @@protoc_insertion_point(message_clear_start:optimization_guide.proto.UserAnnotationsEntry)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.key_.ClearToEmpty();
    _impl_.value_.ClearToEmpty();
    _impl_.entry_id_ = int64_t { 0 };
    _internal_metadata_.Clear<std::string>();
}

const char* UserAnnotationsEntry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // int64 entry_id = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _impl_.entry_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // string key = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_key();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // string value = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_value();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* UserAnnotationsEntry::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:optimization_guide.proto.UserAnnotationsEntry)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // int64 entry_id = 1;
    if (this->_internal_entry_id() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_entry_id(), target);
    }

    // string key = 2;
    if (!this->_internal_key().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_key().data(), static_cast<int>(this->_internal_key().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "optimization_guide.proto.UserAnnotationsEntry.key");
        target = stream->WriteStringMaybeAliased(2, this->_internal_key(), target);
    }

    // string value = 3;
    if (!this->_internal_value().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_value().data(), static_cast<int>(this->_internal_value().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "optimization_guide.proto.UserAnnotationsEntry.value");
        target = stream->WriteStringMaybeAliased(3, this->_internal_value(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:optimization_guide.proto.UserAnnotationsEntry)
    return target;
}

size_t UserAnnotationsEntry::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:optimization_guide.proto.UserAnnotationsEntry)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // string key = 2;
    if (!this->_internal_key().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_key());
    }

    // string value = 3;
    if (!this->_internal_value().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_value());
    }

    // int64 entry_id = 1;
    if (this->_internal_entry_id() != 0) {
        total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_entry_id());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void UserAnnotationsEntry::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const UserAnnotationsEntry*>(&from));
}

void UserAnnotationsEntry::MergeFrom(const UserAnnotationsEntry& from)
{
    UserAnnotationsEntry* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:optimization_guide.proto.UserAnnotationsEntry)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (!from._internal_key().empty()) {
        _this->_internal_set_key(from._internal_key());
    }
    if (!from._internal_value().empty()) {
        _this->_internal_set_value(from._internal_value());
    }
    if (from._internal_entry_id() != 0) {
        _this->_internal_set_entry_id(from._internal_entry_id());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UserAnnotationsEntry::CopyFrom(const UserAnnotationsEntry& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:optimization_guide.proto.UserAnnotationsEntry)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool UserAnnotationsEntry::IsInitialized() const
{
    return true;
}

void UserAnnotationsEntry::InternalSwap(UserAnnotationsEntry* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.key_, lhs_arena, &other->_impl_.key_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.value_, lhs_arena, &other->_impl_.value_, rhs_arena);
    swap(_impl_.entry_id_, other->_impl_.entry_id_);
}

std::string UserAnnotationsEntry::GetTypeName() const
{
    return "optimization_guide.proto.UserAnnotationsEntry";
}

// ===================================================================

class TabGroup::_Internal {
public:
    using HasBits = decltype(std::declval<TabGroup>()._impl_._has_bits_);
    static void set_has_group_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

TabGroup::TabGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:optimization_guide.proto.TabGroup)
}
TabGroup::TabGroup(const TabGroup& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    TabGroup* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.tabs_) { from._impl_.tabs_ }, decltype(_impl_.label_) {}, decltype(_impl_.group_id_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.label_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.label_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_label().empty()) {
        _this->_impl_.label_.Set(from._internal_label(), _this->GetArenaForAllocation());
    }
    _impl_.group_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.group_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_group_id()) {
        _this->_impl_.group_id_.Set(from._internal_group_id(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:optimization_guide.proto.TabGroup)
}

inline void TabGroup::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.tabs_) { arena }, decltype(_impl_.label_) {},
        decltype(_impl_.group_id_) {} };
    _impl_.label_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.label_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.group_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.group_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TabGroup::~TabGroup()
{
    // @@protoc_insertion_point(destructor:optimization_guide.proto.TabGroup)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void TabGroup::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.tabs_.~RepeatedPtrField();
    _impl_.label_.Destroy();
    _impl_.group_id_.Destroy();
}

void TabGroup::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void TabGroup::Clear()
{
    // @@protoc_insertion_point(message_clear_start:optimization_guide.proto.TabGroup)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.tabs_.Clear();
    _impl_.label_.ClearToEmpty();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.group_id_.ClearNonDefaultToEmpty();
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* TabGroup::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // string label = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_label();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // repeated .optimization_guide.proto.Tab tabs = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_tabs(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional string group_id = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_group_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* TabGroup::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:optimization_guide.proto.TabGroup)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // string label = 1;
    if (!this->_internal_label().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_label().data(), static_cast<int>(this->_internal_label().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "optimization_guide.proto.TabGroup.label");
        target = stream->WriteStringMaybeAliased(1, this->_internal_label(), target);
    }

    // repeated .optimization_guide.proto.Tab tabs = 2;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_tabs_size()); i < n; i++) {
        const auto& repfield = this->_internal_tabs(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
    }

    // optional string group_id = 3;
    if (_internal_has_group_id()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_group_id().data(),
            static_cast<int>(this->_internal_group_id().length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
            "optimization_guide.proto.TabGroup.group_id");
        target = stream->WriteStringMaybeAliased(3, this->_internal_group_id(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:optimization_guide.proto.TabGroup)
    return target;
}

size_t TabGroup::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:optimization_guide.proto.TabGroup)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .optimization_guide.proto.Tab tabs = 2;
    total_size += 1UL * this->_internal_tabs_size();
    for (const auto& msg : this->_impl_.tabs_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // string label = 1;
    if (!this->_internal_label().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_label());
    }

    // optional string group_id = 3;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_group_id());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void TabGroup::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const TabGroup*>(&from));
}

void TabGroup::MergeFrom(const TabGroup& from)
{
    TabGroup* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:optimization_guide.proto.TabGroup)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.tabs_.MergeFrom(from._impl_.tabs_);
    if (!from._internal_label().empty()) {
        _this->_internal_set_label(from._internal_label());
    }
    if (from._internal_has_group_id()) {
        _this->_internal_set_group_id(from._internal_group_id());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TabGroup::CopyFrom(const TabGroup& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:optimization_guide.proto.TabGroup)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool TabGroup::IsInitialized() const
{
    return true;
}

void TabGroup::InternalSwap(TabGroup* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.tabs_.InternalSwap(&other->_impl_.tabs_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.label_, lhs_arena, &other->_impl_.label_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.group_id_, lhs_arena, &other->_impl_.group_id_, rhs_arena);
}

std::string TabGroup::GetTypeName() const
{
    return "optimization_guide.proto.TabGroup";
}

// ===================================================================

class Tab::_Internal {
public:
    static const ::optimization_guide::proto::PageContext& page_context(const Tab* msg);
};

const ::optimization_guide::proto::PageContext& Tab::_Internal::page_context(const Tab* msg)
{
    return *msg->_impl_.page_context_;
}
Tab::Tab(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:optimization_guide.proto.Tab)
}
Tab::Tab(const Tab& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    Tab* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.title_) {}, decltype(_impl_.url_) {}, decltype(_impl_.page_context_) { nullptr }, decltype(_impl_.tab_id_) {},
        /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.title_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_title().empty()) {
        _this->_impl_.title_.Set(from._internal_title(), _this->GetArenaForAllocation());
    }
    _impl_.url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_url().empty()) {
        _this->_impl_.url_.Set(from._internal_url(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_page_context()) {
        _this->_impl_.page_context_ = new ::optimization_guide::proto::PageContext(*from._impl_.page_context_);
    }
    _this->_impl_.tab_id_ = from._impl_.tab_id_;
    // @@protoc_insertion_point(copy_constructor:optimization_guide.proto.Tab)
}

inline void Tab::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.title_) {}, decltype(_impl_.url_) {}, decltype(_impl_.page_context_) { nullptr },
        decltype(_impl_.tab_id_) { int64_t { 0 } }, /*decltype(_impl_._cached_size_)*/ {} };
    _impl_.title_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Tab::~Tab()
{
    // @@protoc_insertion_point(destructor:optimization_guide.proto.Tab)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void Tab::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.title_.Destroy();
    _impl_.url_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.page_context_;
}

void Tab::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void Tab::Clear()
{
    // @@protoc_insertion_point(message_clear_start:optimization_guide.proto.Tab)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.title_.ClearToEmpty();
    _impl_.url_.ClearToEmpty();
    if (GetArenaForAllocation() == nullptr && _impl_.page_context_ != nullptr) {
        delete _impl_.page_context_;
    }
    _impl_.page_context_ = nullptr;
    _impl_.tab_id_ = int64_t { 0 };
    _internal_metadata_.Clear<std::string>();
}

const char* Tab::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // int64 tab_id = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _impl_.tab_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // string title = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_title();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // string url = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // .optimization_guide.proto.PageContext page_context = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr = ctx->ParseMessage(_internal_mutable_page_context(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* Tab::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:optimization_guide.proto.Tab)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // int64 tab_id = 1;
    if (this->_internal_tab_id() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_tab_id(), target);
    }

    // string title = 2;
    if (!this->_internal_title().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_title().data(), static_cast<int>(this->_internal_title().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "optimization_guide.proto.Tab.title");
        target = stream->WriteStringMaybeAliased(2, this->_internal_title(), target);
    }

    // string url = 3;
    if (!this->_internal_url().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_url().data(), static_cast<int>(this->_internal_url().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "optimization_guide.proto.Tab.url");
        target = stream->WriteStringMaybeAliased(3, this->_internal_url(), target);
    }

    // .optimization_guide.proto.PageContext page_context = 4;
    if (this->_internal_has_page_context()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            4, _Internal::page_context(this), _Internal::page_context(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:optimization_guide.proto.Tab)
    return target;
}

size_t Tab::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:optimization_guide.proto.Tab)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // string title = 2;
    if (!this->_internal_title().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_title());
    }

    // string url = 3;
    if (!this->_internal_url().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_url());
    }

    // .optimization_guide.proto.PageContext page_context = 4;
    if (this->_internal_has_page_context()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.page_context_);
    }

    // int64 tab_id = 1;
    if (this->_internal_tab_id() != 0) {
        total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_tab_id());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void Tab::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const Tab*>(&from));
}

void Tab::MergeFrom(const Tab& from)
{
    Tab* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:optimization_guide.proto.Tab)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (!from._internal_title().empty()) {
        _this->_internal_set_title(from._internal_title());
    }
    if (!from._internal_url().empty()) {
        _this->_internal_set_url(from._internal_url());
    }
    if (from._internal_has_page_context()) {
        _this->_internal_mutable_page_context()->::optimization_guide::proto::PageContext::MergeFrom(from._internal_page_context());
    }
    if (from._internal_tab_id() != 0) {
        _this->_internal_set_tab_id(from._internal_tab_id());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Tab::CopyFrom(const Tab& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:optimization_guide.proto.Tab)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool Tab::IsInitialized() const
{
    return true;
}

void Tab::InternalSwap(Tab* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.title_, lhs_arena, &other->_impl_.title_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.url_, lhs_arena, &other->_impl_.url_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(Tab, _impl_.tab_id_) + sizeof(Tab::_impl_.tab_id_)
        - PROTOBUF_FIELD_OFFSET(Tab, _impl_.page_context_)>(
        reinterpret_cast<char*>(&_impl_.page_context_), reinterpret_cast<char*>(&other->_impl_.page_context_));
}

std::string Tab::GetTypeName() const
{
    return "optimization_guide.proto.Tab";
}

// ===================================================================

class SiteEngagementEntry::_Internal {
public:
};

SiteEngagementEntry::SiteEngagementEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:optimization_guide.proto.SiteEngagementEntry)
}
SiteEngagementEntry::SiteEngagementEntry(const SiteEngagementEntry& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    SiteEngagementEntry* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.url_) {}, decltype(_impl_.score_) {}, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_url().empty()) {
        _this->_impl_.url_.Set(from._internal_url(), _this->GetArenaForAllocation());
    }
    _this->_impl_.score_ = from._impl_.score_;
    // @@protoc_insertion_point(copy_constructor:optimization_guide.proto.SiteEngagementEntry)
}

inline void SiteEngagementEntry::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.url_) {}, decltype(_impl_.score_) { 0 }, /*decltype(_impl_._cached_size_)*/ {} };
    _impl_.url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SiteEngagementEntry::~SiteEngagementEntry()
{
    // @@protoc_insertion_point(destructor:optimization_guide.proto.SiteEngagementEntry)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void SiteEngagementEntry::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.url_.Destroy();
}

void SiteEngagementEntry::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void SiteEngagementEntry::Clear()
{
    // @@protoc_insertion_point(message_clear_start:optimization_guide.proto.SiteEngagementEntry)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.url_.ClearToEmpty();
    _impl_.score_ = 0;
    _internal_metadata_.Clear<std::string>();
}

const char* SiteEngagementEntry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // string url = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // float score = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
                _impl_.score_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
                ptr += sizeof(float);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* SiteEngagementEntry::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:optimization_guide.proto.SiteEngagementEntry)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // string url = 1;
    if (!this->_internal_url().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_url().data(), static_cast<int>(this->_internal_url().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "optimization_guide.proto.SiteEngagementEntry.url");
        target = stream->WriteStringMaybeAliased(1, this->_internal_url(), target);
    }

    // float score = 2;
    static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
    float tmp_score = this->_internal_score();
    uint32_t raw_score;
    memcpy(&raw_score, &tmp_score, sizeof(tmp_score));
    if (raw_score != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_score(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:optimization_guide.proto.SiteEngagementEntry)
    return target;
}

size_t SiteEngagementEntry::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:optimization_guide.proto.SiteEngagementEntry)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // string url = 1;
    if (!this->_internal_url().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_url());
    }

    // float score = 2;
    static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
    float tmp_score = this->_internal_score();
    uint32_t raw_score;
    memcpy(&raw_score, &tmp_score, sizeof(tmp_score));
    if (raw_score != 0) {
        total_size += 1 + 4;
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void SiteEngagementEntry::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const SiteEngagementEntry*>(&from));
}

void SiteEngagementEntry::MergeFrom(const SiteEngagementEntry& from)
{
    SiteEngagementEntry* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:optimization_guide.proto.SiteEngagementEntry)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (!from._internal_url().empty()) {
        _this->_internal_set_url(from._internal_url());
    }
    static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
    float tmp_score = from._internal_score();
    uint32_t raw_score;
    memcpy(&raw_score, &tmp_score, sizeof(tmp_score));
    if (raw_score != 0) {
        _this->_internal_set_score(from._internal_score());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SiteEngagementEntry::CopyFrom(const SiteEngagementEntry& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:optimization_guide.proto.SiteEngagementEntry)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool SiteEngagementEntry::IsInitialized() const
{
    return true;
}

void SiteEngagementEntry::InternalSwap(SiteEngagementEntry* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.url_, lhs_arena, &other->_impl_.url_, rhs_arena);
    swap(_impl_.score_, other->_impl_.score_);
}

std::string SiteEngagementEntry::GetTypeName() const
{
    return "optimization_guide.proto.SiteEngagementEntry";
}

// ===================================================================

class SiteEngagement::_Internal {
public:
};

SiteEngagement::SiteEngagement(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:optimization_guide.proto.SiteEngagement)
}
SiteEngagement::SiteEngagement(const SiteEngagement& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    SiteEngagement* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.entries_) { from._impl_.entries_ }, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:optimization_guide.proto.SiteEngagement)
}

inline void SiteEngagement::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.entries_) { arena }, /*decltype(_impl_._cached_size_)*/ {} };
}

SiteEngagement::~SiteEngagement()
{
    // @@protoc_insertion_point(destructor:optimization_guide.proto.SiteEngagement)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void SiteEngagement::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.entries_.~RepeatedPtrField();
}

void SiteEngagement::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void SiteEngagement::Clear()
{
    // @@protoc_insertion_point(message_clear_start:optimization_guide.proto.SiteEngagement)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.entries_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* SiteEngagement::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .optimization_guide.proto.SiteEngagementEntry entries = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_entries(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* SiteEngagement::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:optimization_guide.proto.SiteEngagement)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .optimization_guide.proto.SiteEngagementEntry entries = 1;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_entries_size()); i < n; i++) {
        const auto& repfield = this->_internal_entries(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:optimization_guide.proto.SiteEngagement)
    return target;
}

size_t SiteEngagement::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:optimization_guide.proto.SiteEngagement)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .optimization_guide.proto.SiteEngagementEntry entries = 1;
    total_size += 1UL * this->_internal_entries_size();
    for (const auto& msg : this->_impl_.entries_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void SiteEngagement::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const SiteEngagement*>(&from));
}

void SiteEngagement::MergeFrom(const SiteEngagement& from)
{
    SiteEngagement* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:optimization_guide.proto.SiteEngagement)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.entries_.MergeFrom(from._impl_.entries_);
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SiteEngagement::CopyFrom(const SiteEngagement& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:optimization_guide.proto.SiteEngagement)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool SiteEngagement::IsInitialized() const
{
    return true;
}

void SiteEngagement::InternalSwap(SiteEngagement* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.entries_.InternalSwap(&other->_impl_.entries_);
}

std::string SiteEngagement::GetTypeName() const
{
    return "optimization_guide.proto.SiteEngagement";
}

// ===================================================================

class BrowserCollectedInformation::_Internal {
public:
    static const ::optimization_guide::proto::PageContext& page_context(const BrowserCollectedInformation* msg);
    static const ::optimization_guide::proto::FormData& form_data(const BrowserCollectedInformation* msg);
    static const ::optimization_guide::proto::SiteEngagement& site_engagement(const BrowserCollectedInformation* msg);
};

const ::optimization_guide::proto::PageContext& BrowserCollectedInformation::_Internal::page_context(const BrowserCollectedInformation* msg)
{
    return *msg->_impl_.page_context_;
}
const ::optimization_guide::proto::FormData& BrowserCollectedInformation::_Internal::form_data(const BrowserCollectedInformation* msg)
{
    return *msg->_impl_.form_data_;
}
const ::optimization_guide::proto::SiteEngagement& BrowserCollectedInformation::_Internal::site_engagement(const BrowserCollectedInformation* msg)
{
    return *msg->_impl_.site_engagement_;
}
BrowserCollectedInformation::BrowserCollectedInformation(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:optimization_guide.proto.BrowserCollectedInformation)
}
BrowserCollectedInformation::BrowserCollectedInformation(const BrowserCollectedInformation& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    BrowserCollectedInformation* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.custom_data_) { from._impl_.custom_data_ }, decltype(_impl_.entries_) { from._impl_.entries_ },
        decltype(_impl_.tabs_) { from._impl_.tabs_ }, decltype(_impl_.pre_existing_tab_groups_) { from._impl_.pre_existing_tab_groups_ },
        decltype(_impl_.inner_text_) {}, decltype(_impl_.page_context_) { nullptr }, decltype(_impl_.form_data_) { nullptr },
        decltype(_impl_.site_engagement_) { nullptr }, decltype(_impl_.inner_text_offset_) {}, decltype(_impl_.active_tab_id_) {},
        /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.inner_text_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.inner_text_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_inner_text().empty()) {
        _this->_impl_.inner_text_.Set(from._internal_inner_text(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_page_context()) {
        _this->_impl_.page_context_ = new ::optimization_guide::proto::PageContext(*from._impl_.page_context_);
    }
    if (from._internal_has_form_data()) {
        _this->_impl_.form_data_ = new ::optimization_guide::proto::FormData(*from._impl_.form_data_);
    }
    if (from._internal_has_site_engagement()) {
        _this->_impl_.site_engagement_ = new ::optimization_guide::proto::SiteEngagement(*from._impl_.site_engagement_);
    }
    ::memcpy(&_impl_.inner_text_offset_, &from._impl_.inner_text_offset_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.active_tab_id_) - reinterpret_cast<char*>(&_impl_.inner_text_offset_))
            + sizeof(_impl_.active_tab_id_));
    // @@protoc_insertion_point(copy_constructor:optimization_guide.proto.BrowserCollectedInformation)
}

inline void BrowserCollectedInformation::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.custom_data_) { arena }, decltype(_impl_.entries_) { arena }, decltype(_impl_.tabs_) { arena },
        decltype(_impl_.pre_existing_tab_groups_) { arena }, decltype(_impl_.inner_text_) {}, decltype(_impl_.page_context_) { nullptr },
        decltype(_impl_.form_data_) { nullptr }, decltype(_impl_.site_engagement_) { nullptr }, decltype(_impl_.inner_text_offset_) { uint64_t { 0u } },
        decltype(_impl_.active_tab_id_) { int64_t { 0 } }, /*decltype(_impl_._cached_size_)*/ {} };
    _impl_.inner_text_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.inner_text_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

BrowserCollectedInformation::~BrowserCollectedInformation()
{
    // @@protoc_insertion_point(destructor:optimization_guide.proto.BrowserCollectedInformation)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void BrowserCollectedInformation::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.custom_data_.~RepeatedPtrField();
    _impl_.entries_.~RepeatedPtrField();
    _impl_.tabs_.~RepeatedPtrField();
    _impl_.pre_existing_tab_groups_.~RepeatedPtrField();
    _impl_.inner_text_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.page_context_;
    if (this != internal_default_instance())
        delete _impl_.form_data_;
    if (this != internal_default_instance())
        delete _impl_.site_engagement_;
}

void BrowserCollectedInformation::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void BrowserCollectedInformation::Clear()
{
    // @@protoc_insertion_point(message_clear_start:optimization_guide.proto.BrowserCollectedInformation)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.custom_data_.Clear();
    _impl_.entries_.Clear();
    _impl_.tabs_.Clear();
    _impl_.pre_existing_tab_groups_.Clear();
    _impl_.inner_text_.ClearToEmpty();
    if (GetArenaForAllocation() == nullptr && _impl_.page_context_ != nullptr) {
        delete _impl_.page_context_;
    }
    _impl_.page_context_ = nullptr;
    if (GetArenaForAllocation() == nullptr && _impl_.form_data_ != nullptr) {
        delete _impl_.form_data_;
    }
    _impl_.form_data_ = nullptr;
    if (GetArenaForAllocation() == nullptr && _impl_.site_engagement_ != nullptr) {
        delete _impl_.site_engagement_;
    }
    _impl_.site_engagement_ = nullptr;
    ::memset(&_impl_.inner_text_offset_, 0,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.active_tab_id_) - reinterpret_cast<char*>(&_impl_.inner_text_offset_))
            + sizeof(_impl_.active_tab_id_));
    _internal_metadata_.Clear<std::string>();
}

const char* BrowserCollectedInformation::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // .optimization_guide.proto.PageContext page_context = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_page_context(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // string inner_text = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_inner_text();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // uint64 inner_text_offset = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _impl_.inner_text_offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated string custom_data = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    auto str = _internal_add_custom_data();
                    ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(ptr);
                    CHK_(::_pbi::VerifyUTF8(str, nullptr));
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
            } else
                goto handle_unusual;
            continue;
        // .optimization_guide.proto.FormData form_data = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                ptr = ctx->ParseMessage(_internal_mutable_form_data(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .optimization_guide.proto.UserAnnotationsEntry entries = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_entries(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
            } else
                goto handle_unusual;
            continue;
        // repeated .optimization_guide.proto.Tab tabs = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_tabs(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
            } else
                goto handle_unusual;
            continue;
        // int64 active_tab_id = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
                _impl_.active_tab_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .optimization_guide.proto.TabGroup pre_existing_tab_groups = 9;
        case 9:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_pre_existing_tab_groups(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
            } else
                goto handle_unusual;
            continue;
        // .optimization_guide.proto.SiteEngagement site_engagement = 10;
        case 10:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
                ptr = ctx->ParseMessage(_internal_mutable_site_engagement(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* BrowserCollectedInformation::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:optimization_guide.proto.BrowserCollectedInformation)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // .optimization_guide.proto.PageContext page_context = 1;
    if (this->_internal_has_page_context()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::page_context(this), _Internal::page_context(this).GetCachedSize(), target, stream);
    }

    // string inner_text = 2;
    if (!this->_internal_inner_text().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_inner_text().data(),
            static_cast<int>(this->_internal_inner_text().length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
            "optimization_guide.proto.BrowserCollectedInformation.inner_text");
        target = stream->WriteStringMaybeAliased(2, this->_internal_inner_text(), target);
    }

    // uint64 inner_text_offset = 3;
    if (this->_internal_inner_text_offset() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_inner_text_offset(), target);
    }

    // repeated string custom_data = 4;
    for (int i = 0, n = this->_internal_custom_data_size(); i < n; i++) {
        const auto& s = this->_internal_custom_data(i);
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s.data(), static_cast<int>(s.length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "optimization_guide.proto.BrowserCollectedInformation.custom_data");
        target = stream->WriteString(4, s, target);
    }

    // .optimization_guide.proto.FormData form_data = 5;
    if (this->_internal_has_form_data()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            5, _Internal::form_data(this), _Internal::form_data(this).GetCachedSize(), target, stream);
    }

    // repeated .optimization_guide.proto.UserAnnotationsEntry entries = 6;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_entries_size()); i < n; i++) {
        const auto& repfield = this->_internal_entries(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
    }

    // repeated .optimization_guide.proto.Tab tabs = 7;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_tabs_size()); i < n; i++) {
        const auto& repfield = this->_internal_tabs(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
    }

    // int64 active_tab_id = 8;
    if (this->_internal_active_tab_id() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(8, this->_internal_active_tab_id(), target);
    }

    // repeated .optimization_guide.proto.TabGroup pre_existing_tab_groups = 9;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_pre_existing_tab_groups_size()); i < n; i++) {
        const auto& repfield = this->_internal_pre_existing_tab_groups(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(9, repfield, repfield.GetCachedSize(), target, stream);
    }

    // .optimization_guide.proto.SiteEngagement site_engagement = 10;
    if (this->_internal_has_site_engagement()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            10, _Internal::site_engagement(this), _Internal::site_engagement(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:optimization_guide.proto.BrowserCollectedInformation)
    return target;
}

size_t BrowserCollectedInformation::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:optimization_guide.proto.BrowserCollectedInformation)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated string custom_data = 4;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.custom_data_.size());
    for (int i = 0, n = _impl_.custom_data_.size(); i < n; i++) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(_impl_.custom_data_.Get(i));
    }

    // repeated .optimization_guide.proto.UserAnnotationsEntry entries = 6;
    total_size += 1UL * this->_internal_entries_size();
    for (const auto& msg : this->_impl_.entries_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // repeated .optimization_guide.proto.Tab tabs = 7;
    total_size += 1UL * this->_internal_tabs_size();
    for (const auto& msg : this->_impl_.tabs_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // repeated .optimization_guide.proto.TabGroup pre_existing_tab_groups = 9;
    total_size += 1UL * this->_internal_pre_existing_tab_groups_size();
    for (const auto& msg : this->_impl_.pre_existing_tab_groups_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // string inner_text = 2;
    if (!this->_internal_inner_text().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_inner_text());
    }

    // .optimization_guide.proto.PageContext page_context = 1;
    if (this->_internal_has_page_context()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.page_context_);
    }

    // .optimization_guide.proto.FormData form_data = 5;
    if (this->_internal_has_form_data()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.form_data_);
    }

    // .optimization_guide.proto.SiteEngagement site_engagement = 10;
    if (this->_internal_has_site_engagement()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.site_engagement_);
    }

    // uint64 inner_text_offset = 3;
    if (this->_internal_inner_text_offset() != 0) {
        total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_inner_text_offset());
    }

    // int64 active_tab_id = 8;
    if (this->_internal_active_tab_id() != 0) {
        total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_active_tab_id());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void BrowserCollectedInformation::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const BrowserCollectedInformation*>(&from));
}

void BrowserCollectedInformation::MergeFrom(const BrowserCollectedInformation& from)
{
    BrowserCollectedInformation* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:optimization_guide.proto.BrowserCollectedInformation)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.custom_data_.MergeFrom(from._impl_.custom_data_);
    _this->_impl_.entries_.MergeFrom(from._impl_.entries_);
    _this->_impl_.tabs_.MergeFrom(from._impl_.tabs_);
    _this->_impl_.pre_existing_tab_groups_.MergeFrom(from._impl_.pre_existing_tab_groups_);
    if (!from._internal_inner_text().empty()) {
        _this->_internal_set_inner_text(from._internal_inner_text());
    }
    if (from._internal_has_page_context()) {
        _this->_internal_mutable_page_context()->::optimization_guide::proto::PageContext::MergeFrom(from._internal_page_context());
    }
    if (from._internal_has_form_data()) {
        _this->_internal_mutable_form_data()->::optimization_guide::proto::FormData::MergeFrom(from._internal_form_data());
    }
    if (from._internal_has_site_engagement()) {
        _this->_internal_mutable_site_engagement()->::optimization_guide::proto::SiteEngagement::MergeFrom(from._internal_site_engagement());
    }
    if (from._internal_inner_text_offset() != 0) {
        _this->_internal_set_inner_text_offset(from._internal_inner_text_offset());
    }
    if (from._internal_active_tab_id() != 0) {
        _this->_internal_set_active_tab_id(from._internal_active_tab_id());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BrowserCollectedInformation::CopyFrom(const BrowserCollectedInformation& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:optimization_guide.proto.BrowserCollectedInformation)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool BrowserCollectedInformation::IsInitialized() const
{
    return true;
}

void BrowserCollectedInformation::InternalSwap(BrowserCollectedInformation* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.custom_data_.InternalSwap(&other->_impl_.custom_data_);
    _impl_.entries_.InternalSwap(&other->_impl_.entries_);
    _impl_.tabs_.InternalSwap(&other->_impl_.tabs_);
    _impl_.pre_existing_tab_groups_.InternalSwap(&other->_impl_.pre_existing_tab_groups_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.inner_text_, lhs_arena, &other->_impl_.inner_text_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(BrowserCollectedInformation, _impl_.active_tab_id_)
        + sizeof(BrowserCollectedInformation::_impl_.active_tab_id_) - PROTOBUF_FIELD_OFFSET(BrowserCollectedInformation, _impl_.page_context_)>(
        reinterpret_cast<char*>(&_impl_.page_context_), reinterpret_cast<char*>(&other->_impl_.page_context_));
}

std::string BrowserCollectedInformation::GetTypeName() const
{
    return "optimization_guide.proto.BrowserCollectedInformation";
}

// @@protoc_insertion_point(namespace_scope)
} // namespace proto
} // namespace optimization_guide
PROTOBUF_NAMESPACE_OPEN
template <> PROTOBUF_NOINLINE ::optimization_guide::proto::FloatArray* Arena::CreateMaybeMessage<::optimization_guide::proto::FloatArray>(Arena* arena)
{
    return Arena::CreateMessageInternal<::optimization_guide::proto::FloatArray>(arena);
}
template <> PROTOBUF_NOINLINE ::optimization_guide::proto::Embedding* Arena::CreateMaybeMessage<::optimization_guide::proto::Embedding>(Arena* arena)
{
    return Arena::CreateMessageInternal<::optimization_guide::proto::Embedding>(arena);
}
template <> PROTOBUF_NOINLINE ::optimization_guide::proto::AXTreeUpdate* Arena::CreateMaybeMessage<::optimization_guide::proto::AXTreeUpdate>(Arena* arena)
{
    return Arena::CreateMessageInternal<::optimization_guide::proto::AXTreeUpdate>(arena);
}
template <> PROTOBUF_NOINLINE ::optimization_guide::proto::AXTreeData* Arena::CreateMaybeMessage<::optimization_guide::proto::AXTreeData>(Arena* arena)
{
    return Arena::CreateMessageInternal<::optimization_guide::proto::AXTreeData>(arena);
}
template <> PROTOBUF_NOINLINE ::optimization_guide::proto::AXNodeData* Arena::CreateMaybeMessage<::optimization_guide::proto::AXNodeData>(Arena* arena)
{
    return Arena::CreateMessageInternal<::optimization_guide::proto::AXNodeData>(arena);
}
template <> PROTOBUF_NOINLINE ::optimization_guide::proto::AXAttribute* Arena::CreateMaybeMessage<::optimization_guide::proto::AXAttribute>(Arena* arena)
{
    return Arena::CreateMessageInternal<::optimization_guide::proto::AXAttribute>(arena);
}
template <> PROTOBUF_NOINLINE ::optimization_guide::proto::AXIntList* Arena::CreateMaybeMessage<::optimization_guide::proto::AXIntList>(Arena* arena)
{
    return Arena::CreateMessageInternal<::optimization_guide::proto::AXIntList>(arena);
}
template <> PROTOBUF_NOINLINE ::optimization_guide::proto::AXStringList* Arena::CreateMaybeMessage<::optimization_guide::proto::AXStringList>(Arena* arena)
{
    return Arena::CreateMessageInternal<::optimization_guide::proto::AXStringList>(arena);
}
template <>
PROTOBUF_NOINLINE ::optimization_guide::proto::AXRelativeBounds* Arena::CreateMaybeMessage<::optimization_guide::proto::AXRelativeBounds>(Arena* arena)
{
    return Arena::CreateMessageInternal<::optimization_guide::proto::AXRelativeBounds>(arena);
}
template <> PROTOBUF_NOINLINE ::optimization_guide::proto::PageContext* Arena::CreateMaybeMessage<::optimization_guide::proto::PageContext>(Arena* arena)
{
    return Arena::CreateMessageInternal<::optimization_guide::proto::PageContext>(arena);
}
template <> PROTOBUF_NOINLINE ::optimization_guide::proto::FormData* Arena::CreateMaybeMessage<::optimization_guide::proto::FormData>(Arena* arena)
{
    return Arena::CreateMessageInternal<::optimization_guide::proto::FormData>(arena);
}
template <> PROTOBUF_NOINLINE ::optimization_guide::proto::FormFieldData* Arena::CreateMaybeMessage<::optimization_guide::proto::FormFieldData>(Arena* arena)
{
    return Arena::CreateMessageInternal<::optimization_guide::proto::FormFieldData>(arena);
}
template <> PROTOBUF_NOINLINE ::optimization_guide::proto::SelectOption* Arena::CreateMaybeMessage<::optimization_guide::proto::SelectOption>(Arena* arena)
{
    return Arena::CreateMessageInternal<::optimization_guide::proto::SelectOption>(arena);
}
template <>
PROTOBUF_NOINLINE ::optimization_guide::proto::UserAnnotationsEntry* Arena::CreateMaybeMessage<::optimization_guide::proto::UserAnnotationsEntry>(Arena* arena)
{
    return Arena::CreateMessageInternal<::optimization_guide::proto::UserAnnotationsEntry>(arena);
}
template <> PROTOBUF_NOINLINE ::optimization_guide::proto::TabGroup* Arena::CreateMaybeMessage<::optimization_guide::proto::TabGroup>(Arena* arena)
{
    return Arena::CreateMessageInternal<::optimization_guide::proto::TabGroup>(arena);
}
template <> PROTOBUF_NOINLINE ::optimization_guide::proto::Tab* Arena::CreateMaybeMessage<::optimization_guide::proto::Tab>(Arena* arena)
{
    return Arena::CreateMessageInternal<::optimization_guide::proto::Tab>(arena);
}
template <>
PROTOBUF_NOINLINE ::optimization_guide::proto::SiteEngagementEntry* Arena::CreateMaybeMessage<::optimization_guide::proto::SiteEngagementEntry>(Arena* arena)
{
    return Arena::CreateMessageInternal<::optimization_guide::proto::SiteEngagementEntry>(arena);
}
template <> PROTOBUF_NOINLINE ::optimization_guide::proto::SiteEngagement* Arena::CreateMaybeMessage<::optimization_guide::proto::SiteEngagement>(Arena* arena)
{
    return Arena::CreateMessageInternal<::optimization_guide::proto::SiteEngagement>(arena);
}
template <>
PROTOBUF_NOINLINE ::optimization_guide::proto::BrowserCollectedInformation* Arena::CreateMaybeMessage<::optimization_guide::proto::BrowserCollectedInformation>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<::optimization_guide::proto::BrowserCollectedInformation>(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
