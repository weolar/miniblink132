// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/optimization_guide/proto/visual_search_model_metadata.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_components_2foptimization_5fguide_2fproto_2fvisual_5fsearch_5fmodel_5fmetadata_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_components_2foptimization_5fguide_2fproto_2fvisual_5fsearch_5fmodel_5fmetadata_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h> // IWYU pragma: export
#include <google/protobuf/extension_set.h> // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_components_2foptimization_5fguide_2fproto_2fvisual_5fsearch_5fmodel_5fmetadata_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
} // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_components_2foptimization_5fguide_2fproto_2fvisual_5fsearch_5fmodel_5fmetadata_2eproto {
    static const uint32_t offsets[];
};
namespace optimization_guide {
namespace proto {
class AdditionalCheapPruningOptions;
struct AdditionalCheapPruningOptionsDefaultTypeInternal;
extern AdditionalCheapPruningOptionsDefaultTypeInternal _AdditionalCheapPruningOptions_default_instance_;
class EligibilitySpec;
struct EligibilitySpecDefaultTypeInternal;
extern EligibilitySpecDefaultTypeInternal _EligibilitySpec_default_instance_;
class FeatureLibrary;
struct FeatureLibraryDefaultTypeInternal;
extern FeatureLibraryDefaultTypeInternal _FeatureLibrary_default_instance_;
class OrOfThresholdingRules;
struct OrOfThresholdingRulesDefaultTypeInternal;
extern OrOfThresholdingRulesDefaultTypeInternal _OrOfThresholdingRules_default_instance_;
class SortingClause;
struct SortingClauseDefaultTypeInternal;
extern SortingClauseDefaultTypeInternal _SortingClause_default_instance_;
class ThresholdingRule;
struct ThresholdingRuleDefaultTypeInternal;
extern ThresholdingRuleDefaultTypeInternal _ThresholdingRule_default_instance_;
class VisualSearchModelMetadata;
struct VisualSearchModelMetadataDefaultTypeInternal;
extern VisualSearchModelMetadataDefaultTypeInternal _VisualSearchModelMetadata_default_instance_;
} // namespace proto
} // namespace optimization_guide
PROTOBUF_NAMESPACE_OPEN
template <>
::optimization_guide::proto::AdditionalCheapPruningOptions* Arena::CreateMaybeMessage<::optimization_guide::proto::AdditionalCheapPruningOptions>(Arena*);
template <>::optimization_guide::proto::EligibilitySpec* Arena::CreateMaybeMessage<::optimization_guide::proto::EligibilitySpec>(Arena*);
template <>::optimization_guide::proto::FeatureLibrary* Arena::CreateMaybeMessage<::optimization_guide::proto::FeatureLibrary>(Arena*);
template <>::optimization_guide::proto::OrOfThresholdingRules* Arena::CreateMaybeMessage<::optimization_guide::proto::OrOfThresholdingRules>(Arena*);
template <>::optimization_guide::proto::SortingClause* Arena::CreateMaybeMessage<::optimization_guide::proto::SortingClause>(Arena*);
template <>::optimization_guide::proto::ThresholdingRule* Arena::CreateMaybeMessage<::optimization_guide::proto::ThresholdingRule>(Arena*);
template <>::optimization_guide::proto::VisualSearchModelMetadata* Arena::CreateMaybeMessage<::optimization_guide::proto::VisualSearchModelMetadata>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace optimization_guide {
namespace proto {

enum FeatureLibrary_ImageLevelFeatureName : int {
    FeatureLibrary_ImageLevelFeatureName_IMAGE_LEVEL_UNSPECIFIED = 0,
    FeatureLibrary_ImageLevelFeatureName_IMAGE_ORIGINAL_AREA = 1,
    FeatureLibrary_ImageLevelFeatureName_IMAGE_ORIGINAL_ASPECT_RATIO = 2,
    FeatureLibrary_ImageLevelFeatureName_IMAGE_ORIGINAL_HEIGHT = 11,
    FeatureLibrary_ImageLevelFeatureName_IMAGE_ORIGINAL_WIDTH = 12,
    FeatureLibrary_ImageLevelFeatureName_IMAGE_ONPAGE_AREA = 3,
    FeatureLibrary_ImageLevelFeatureName_IMAGE_ONPAGE_HEIGHT = 9,
    FeatureLibrary_ImageLevelFeatureName_IMAGE_ONPAGE_WIDTH = 10,
    FeatureLibrary_ImageLevelFeatureName_IMAGE_ONPAGE_ASPECT_RATIO = 4,
    FeatureLibrary_ImageLevelFeatureName_IMAGE_VISIBLE_AREA = 5,
    FeatureLibrary_ImageLevelFeatureName_IMAGE_FRACTION_VISIBLE = 6,
    FeatureLibrary_ImageLevelFeatureName_IMAGE_DISTANCE_TO_VIEWPORT_CENTER = 13,
    FeatureLibrary_ImageLevelFeatureName_SHOPPING_CLASSIFIER_SCORE = 7,
    FeatureLibrary_ImageLevelFeatureName_SENS_CLASSIFIER_SCORE = 8,
    FeatureLibrary_ImageLevelFeatureName_NAT_WORLD_CLASSIFIER_SCORE = 14,
    FeatureLibrary_ImageLevelFeatureName_PUB_FIGURES_CLASSIFIER_SCORE = 15
};
bool FeatureLibrary_ImageLevelFeatureName_IsValid(int value);
constexpr FeatureLibrary_ImageLevelFeatureName FeatureLibrary_ImageLevelFeatureName_ImageLevelFeatureName_MIN
    = FeatureLibrary_ImageLevelFeatureName_IMAGE_LEVEL_UNSPECIFIED;
constexpr FeatureLibrary_ImageLevelFeatureName FeatureLibrary_ImageLevelFeatureName_ImageLevelFeatureName_MAX
    = FeatureLibrary_ImageLevelFeatureName_PUB_FIGURES_CLASSIFIER_SCORE;
constexpr int FeatureLibrary_ImageLevelFeatureName_ImageLevelFeatureName_ARRAYSIZE = FeatureLibrary_ImageLevelFeatureName_ImageLevelFeatureName_MAX + 1;

const std::string& FeatureLibrary_ImageLevelFeatureName_Name(FeatureLibrary_ImageLevelFeatureName value);
template <typename T> inline const std::string& FeatureLibrary_ImageLevelFeatureName_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, FeatureLibrary_ImageLevelFeatureName>::value || ::std::is_integral<T>::value,
        "Incorrect type passed to function FeatureLibrary_ImageLevelFeatureName_Name.");
    return FeatureLibrary_ImageLevelFeatureName_Name(static_cast<FeatureLibrary_ImageLevelFeatureName>(enum_t_value));
}
bool FeatureLibrary_ImageLevelFeatureName_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FeatureLibrary_ImageLevelFeatureName* value);
enum FeatureLibrary_NormalizingOp : int {
    FeatureLibrary_NormalizingOp_NORMALIZE_UNSPECIFIED = 0,
    FeatureLibrary_NormalizingOp_BY_VIEWPORT_AREA = 1,
    FeatureLibrary_NormalizingOp_BY_MAX_VALUE = 2
};
bool FeatureLibrary_NormalizingOp_IsValid(int value);
constexpr FeatureLibrary_NormalizingOp FeatureLibrary_NormalizingOp_NormalizingOp_MIN = FeatureLibrary_NormalizingOp_NORMALIZE_UNSPECIFIED;
constexpr FeatureLibrary_NormalizingOp FeatureLibrary_NormalizingOp_NormalizingOp_MAX = FeatureLibrary_NormalizingOp_BY_MAX_VALUE;
constexpr int FeatureLibrary_NormalizingOp_NormalizingOp_ARRAYSIZE = FeatureLibrary_NormalizingOp_NormalizingOp_MAX + 1;

const std::string& FeatureLibrary_NormalizingOp_Name(FeatureLibrary_NormalizingOp value);
template <typename T> inline const std::string& FeatureLibrary_NormalizingOp_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, FeatureLibrary_NormalizingOp>::value || ::std::is_integral<T>::value,
        "Incorrect type passed to function FeatureLibrary_NormalizingOp_Name.");
    return FeatureLibrary_NormalizingOp_Name(static_cast<FeatureLibrary_NormalizingOp>(enum_t_value));
}
bool FeatureLibrary_NormalizingOp_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FeatureLibrary_NormalizingOp* value);
enum FeatureLibrary_ThresholdingOp : int {
    FeatureLibrary_ThresholdingOp_THRESHOLDING_UNSPECIFIED = 0,
    FeatureLibrary_ThresholdingOp_GT = 1,
    FeatureLibrary_ThresholdingOp_LT = 2
};
bool FeatureLibrary_ThresholdingOp_IsValid(int value);
constexpr FeatureLibrary_ThresholdingOp FeatureLibrary_ThresholdingOp_ThresholdingOp_MIN = FeatureLibrary_ThresholdingOp_THRESHOLDING_UNSPECIFIED;
constexpr FeatureLibrary_ThresholdingOp FeatureLibrary_ThresholdingOp_ThresholdingOp_MAX = FeatureLibrary_ThresholdingOp_LT;
constexpr int FeatureLibrary_ThresholdingOp_ThresholdingOp_ARRAYSIZE = FeatureLibrary_ThresholdingOp_ThresholdingOp_MAX + 1;

const std::string& FeatureLibrary_ThresholdingOp_Name(FeatureLibrary_ThresholdingOp value);
template <typename T> inline const std::string& FeatureLibrary_ThresholdingOp_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, FeatureLibrary_ThresholdingOp>::value || ::std::is_integral<T>::value,
        "Incorrect type passed to function FeatureLibrary_ThresholdingOp_Name.");
    return FeatureLibrary_ThresholdingOp_Name(static_cast<FeatureLibrary_ThresholdingOp>(enum_t_value));
}
bool FeatureLibrary_ThresholdingOp_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FeatureLibrary_ThresholdingOp* value);
enum FeatureLibrary_SortingOrder : int {
    FeatureLibrary_SortingOrder_SORT_UNSPECIFIED = 0,
    FeatureLibrary_SortingOrder_SORT_ASCENDING = 1,
    FeatureLibrary_SortingOrder_SORT_DESCENDING = 2
};
bool FeatureLibrary_SortingOrder_IsValid(int value);
constexpr FeatureLibrary_SortingOrder FeatureLibrary_SortingOrder_SortingOrder_MIN = FeatureLibrary_SortingOrder_SORT_UNSPECIFIED;
constexpr FeatureLibrary_SortingOrder FeatureLibrary_SortingOrder_SortingOrder_MAX = FeatureLibrary_SortingOrder_SORT_DESCENDING;
constexpr int FeatureLibrary_SortingOrder_SortingOrder_ARRAYSIZE = FeatureLibrary_SortingOrder_SortingOrder_MAX + 1;

const std::string& FeatureLibrary_SortingOrder_Name(FeatureLibrary_SortingOrder value);
template <typename T> inline const std::string& FeatureLibrary_SortingOrder_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, FeatureLibrary_SortingOrder>::value || ::std::is_integral<T>::value,
        "Incorrect type passed to function FeatureLibrary_SortingOrder_Name.");
    return FeatureLibrary_SortingOrder_Name(static_cast<FeatureLibrary_SortingOrder>(enum_t_value));
}
bool FeatureLibrary_SortingOrder_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FeatureLibrary_SortingOrder* value);
// ===================================================================

class FeatureLibrary final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.FeatureLibrary) */ {
public:
    inline FeatureLibrary()
        : FeatureLibrary(nullptr)
    {
    }
    ~FeatureLibrary() override;
    explicit PROTOBUF_CONSTEXPR FeatureLibrary(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    FeatureLibrary(const FeatureLibrary& from);
    FeatureLibrary(FeatureLibrary&& from) noexcept
        : FeatureLibrary()
    {
        *this = ::std::move(from);
    }

    inline FeatureLibrary& operator=(const FeatureLibrary& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline FeatureLibrary& operator=(FeatureLibrary&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const FeatureLibrary& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const FeatureLibrary* internal_default_instance()
    {
        return reinterpret_cast<const FeatureLibrary*>(&_FeatureLibrary_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 0;

    friend void swap(FeatureLibrary& a, FeatureLibrary& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(FeatureLibrary* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(FeatureLibrary* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    FeatureLibrary* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<FeatureLibrary>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const FeatureLibrary& from);
    void MergeFrom(const FeatureLibrary& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(FeatureLibrary* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "optimization_guide.proto.FeatureLibrary";
    }

protected:
    explicit FeatureLibrary(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef FeatureLibrary_ImageLevelFeatureName ImageLevelFeatureName;
    static constexpr ImageLevelFeatureName IMAGE_LEVEL_UNSPECIFIED = FeatureLibrary_ImageLevelFeatureName_IMAGE_LEVEL_UNSPECIFIED;
    static constexpr ImageLevelFeatureName IMAGE_ORIGINAL_AREA = FeatureLibrary_ImageLevelFeatureName_IMAGE_ORIGINAL_AREA;
    static constexpr ImageLevelFeatureName IMAGE_ORIGINAL_ASPECT_RATIO = FeatureLibrary_ImageLevelFeatureName_IMAGE_ORIGINAL_ASPECT_RATIO;
    static constexpr ImageLevelFeatureName IMAGE_ORIGINAL_HEIGHT = FeatureLibrary_ImageLevelFeatureName_IMAGE_ORIGINAL_HEIGHT;
    static constexpr ImageLevelFeatureName IMAGE_ORIGINAL_WIDTH = FeatureLibrary_ImageLevelFeatureName_IMAGE_ORIGINAL_WIDTH;
    static constexpr ImageLevelFeatureName IMAGE_ONPAGE_AREA = FeatureLibrary_ImageLevelFeatureName_IMAGE_ONPAGE_AREA;
    static constexpr ImageLevelFeatureName IMAGE_ONPAGE_HEIGHT = FeatureLibrary_ImageLevelFeatureName_IMAGE_ONPAGE_HEIGHT;
    static constexpr ImageLevelFeatureName IMAGE_ONPAGE_WIDTH = FeatureLibrary_ImageLevelFeatureName_IMAGE_ONPAGE_WIDTH;
    static constexpr ImageLevelFeatureName IMAGE_ONPAGE_ASPECT_RATIO = FeatureLibrary_ImageLevelFeatureName_IMAGE_ONPAGE_ASPECT_RATIO;
    static constexpr ImageLevelFeatureName IMAGE_VISIBLE_AREA = FeatureLibrary_ImageLevelFeatureName_IMAGE_VISIBLE_AREA;
    static constexpr ImageLevelFeatureName IMAGE_FRACTION_VISIBLE = FeatureLibrary_ImageLevelFeatureName_IMAGE_FRACTION_VISIBLE;
    static constexpr ImageLevelFeatureName IMAGE_DISTANCE_TO_VIEWPORT_CENTER = FeatureLibrary_ImageLevelFeatureName_IMAGE_DISTANCE_TO_VIEWPORT_CENTER;
    static constexpr ImageLevelFeatureName SHOPPING_CLASSIFIER_SCORE = FeatureLibrary_ImageLevelFeatureName_SHOPPING_CLASSIFIER_SCORE;
    static constexpr ImageLevelFeatureName SENS_CLASSIFIER_SCORE = FeatureLibrary_ImageLevelFeatureName_SENS_CLASSIFIER_SCORE;
    static constexpr ImageLevelFeatureName NAT_WORLD_CLASSIFIER_SCORE = FeatureLibrary_ImageLevelFeatureName_NAT_WORLD_CLASSIFIER_SCORE;
    static constexpr ImageLevelFeatureName PUB_FIGURES_CLASSIFIER_SCORE = FeatureLibrary_ImageLevelFeatureName_PUB_FIGURES_CLASSIFIER_SCORE;
    static inline bool ImageLevelFeatureName_IsValid(int value)
    {
        return FeatureLibrary_ImageLevelFeatureName_IsValid(value);
    }
    static constexpr ImageLevelFeatureName ImageLevelFeatureName_MIN = FeatureLibrary_ImageLevelFeatureName_ImageLevelFeatureName_MIN;
    static constexpr ImageLevelFeatureName ImageLevelFeatureName_MAX = FeatureLibrary_ImageLevelFeatureName_ImageLevelFeatureName_MAX;
    static constexpr int ImageLevelFeatureName_ARRAYSIZE = FeatureLibrary_ImageLevelFeatureName_ImageLevelFeatureName_ARRAYSIZE;
    template <typename T> static inline const std::string& ImageLevelFeatureName_Name(T enum_t_value)
    {
        static_assert(
            ::std::is_same<T, ImageLevelFeatureName>::value || ::std::is_integral<T>::value, "Incorrect type passed to function ImageLevelFeatureName_Name.");
        return FeatureLibrary_ImageLevelFeatureName_Name(enum_t_value);
    }
    static inline bool ImageLevelFeatureName_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ImageLevelFeatureName* value)
    {
        return FeatureLibrary_ImageLevelFeatureName_Parse(name, value);
    }

    typedef FeatureLibrary_NormalizingOp NormalizingOp;
    static constexpr NormalizingOp NORMALIZE_UNSPECIFIED = FeatureLibrary_NormalizingOp_NORMALIZE_UNSPECIFIED;
    static constexpr NormalizingOp BY_VIEWPORT_AREA = FeatureLibrary_NormalizingOp_BY_VIEWPORT_AREA;
    static constexpr NormalizingOp BY_MAX_VALUE = FeatureLibrary_NormalizingOp_BY_MAX_VALUE;
    static inline bool NormalizingOp_IsValid(int value)
    {
        return FeatureLibrary_NormalizingOp_IsValid(value);
    }
    static constexpr NormalizingOp NormalizingOp_MIN = FeatureLibrary_NormalizingOp_NormalizingOp_MIN;
    static constexpr NormalizingOp NormalizingOp_MAX = FeatureLibrary_NormalizingOp_NormalizingOp_MAX;
    static constexpr int NormalizingOp_ARRAYSIZE = FeatureLibrary_NormalizingOp_NormalizingOp_ARRAYSIZE;
    template <typename T> static inline const std::string& NormalizingOp_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, NormalizingOp>::value || ::std::is_integral<T>::value, "Incorrect type passed to function NormalizingOp_Name.");
        return FeatureLibrary_NormalizingOp_Name(enum_t_value);
    }
    static inline bool NormalizingOp_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NormalizingOp* value)
    {
        return FeatureLibrary_NormalizingOp_Parse(name, value);
    }

    typedef FeatureLibrary_ThresholdingOp ThresholdingOp;
    static constexpr ThresholdingOp THRESHOLDING_UNSPECIFIED = FeatureLibrary_ThresholdingOp_THRESHOLDING_UNSPECIFIED;
    static constexpr ThresholdingOp GT = FeatureLibrary_ThresholdingOp_GT;
    static constexpr ThresholdingOp LT = FeatureLibrary_ThresholdingOp_LT;
    static inline bool ThresholdingOp_IsValid(int value)
    {
        return FeatureLibrary_ThresholdingOp_IsValid(value);
    }
    static constexpr ThresholdingOp ThresholdingOp_MIN = FeatureLibrary_ThresholdingOp_ThresholdingOp_MIN;
    static constexpr ThresholdingOp ThresholdingOp_MAX = FeatureLibrary_ThresholdingOp_ThresholdingOp_MAX;
    static constexpr int ThresholdingOp_ARRAYSIZE = FeatureLibrary_ThresholdingOp_ThresholdingOp_ARRAYSIZE;
    template <typename T> static inline const std::string& ThresholdingOp_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, ThresholdingOp>::value || ::std::is_integral<T>::value, "Incorrect type passed to function ThresholdingOp_Name.");
        return FeatureLibrary_ThresholdingOp_Name(enum_t_value);
    }
    static inline bool ThresholdingOp_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ThresholdingOp* value)
    {
        return FeatureLibrary_ThresholdingOp_Parse(name, value);
    }

    typedef FeatureLibrary_SortingOrder SortingOrder;
    static constexpr SortingOrder SORT_UNSPECIFIED = FeatureLibrary_SortingOrder_SORT_UNSPECIFIED;
    static constexpr SortingOrder SORT_ASCENDING = FeatureLibrary_SortingOrder_SORT_ASCENDING;
    static constexpr SortingOrder SORT_DESCENDING = FeatureLibrary_SortingOrder_SORT_DESCENDING;
    static inline bool SortingOrder_IsValid(int value)
    {
        return FeatureLibrary_SortingOrder_IsValid(value);
    }
    static constexpr SortingOrder SortingOrder_MIN = FeatureLibrary_SortingOrder_SortingOrder_MIN;
    static constexpr SortingOrder SortingOrder_MAX = FeatureLibrary_SortingOrder_SortingOrder_MAX;
    static constexpr int SortingOrder_ARRAYSIZE = FeatureLibrary_SortingOrder_SortingOrder_ARRAYSIZE;
    template <typename T> static inline const std::string& SortingOrder_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, SortingOrder>::value || ::std::is_integral<T>::value, "Incorrect type passed to function SortingOrder_Name.");
        return FeatureLibrary_SortingOrder_Name(enum_t_value);
    }
    static inline bool SortingOrder_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SortingOrder* value)
    {
        return FeatureLibrary_SortingOrder_Parse(name, value);
    }

    // accessors -------------------------------------------------------

    // @@protoc_insertion_point(class_scope:optimization_guide.proto.FeatureLibrary)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2foptimization_5fguide_2fproto_2fvisual_5fsearch_5fmodel_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class ThresholdingRule final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.ThresholdingRule) */ {
public:
    inline ThresholdingRule()
        : ThresholdingRule(nullptr)
    {
    }
    ~ThresholdingRule() override;
    explicit PROTOBUF_CONSTEXPR ThresholdingRule(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ThresholdingRule(const ThresholdingRule& from);
    ThresholdingRule(ThresholdingRule&& from) noexcept
        : ThresholdingRule()
    {
        *this = ::std::move(from);
    }

    inline ThresholdingRule& operator=(const ThresholdingRule& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ThresholdingRule& operator=(ThresholdingRule&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ThresholdingRule& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ThresholdingRule* internal_default_instance()
    {
        return reinterpret_cast<const ThresholdingRule*>(&_ThresholdingRule_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 1;

    friend void swap(ThresholdingRule& a, ThresholdingRule& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ThresholdingRule* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ThresholdingRule* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ThresholdingRule* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ThresholdingRule>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ThresholdingRule& from);
    void MergeFrom(const ThresholdingRule& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ThresholdingRule* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "optimization_guide.proto.ThresholdingRule";
    }

protected:
    explicit ThresholdingRule(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kFeatureNameFieldNumber = 1,
        kNormalizingOpFieldNumber = 2,
        kThresholdingOpFieldNumber = 3,
        kThresholdFieldNumber = 4,
    };
    // optional .optimization_guide.proto.FeatureLibrary.ImageLevelFeatureName feature_name = 1;
    bool has_feature_name() const;

private:
    bool _internal_has_feature_name() const;

public:
    void clear_feature_name();
    ::optimization_guide::proto::FeatureLibrary_ImageLevelFeatureName feature_name() const;
    void set_feature_name(::optimization_guide::proto::FeatureLibrary_ImageLevelFeatureName value);

private:
    ::optimization_guide::proto::FeatureLibrary_ImageLevelFeatureName _internal_feature_name() const;
    void _internal_set_feature_name(::optimization_guide::proto::FeatureLibrary_ImageLevelFeatureName value);

public:
    // optional .optimization_guide.proto.FeatureLibrary.NormalizingOp normalizing_op = 2;
    bool has_normalizing_op() const;

private:
    bool _internal_has_normalizing_op() const;

public:
    void clear_normalizing_op();
    ::optimization_guide::proto::FeatureLibrary_NormalizingOp normalizing_op() const;
    void set_normalizing_op(::optimization_guide::proto::FeatureLibrary_NormalizingOp value);

private:
    ::optimization_guide::proto::FeatureLibrary_NormalizingOp _internal_normalizing_op() const;
    void _internal_set_normalizing_op(::optimization_guide::proto::FeatureLibrary_NormalizingOp value);

public:
    // optional .optimization_guide.proto.FeatureLibrary.ThresholdingOp thresholding_op = 3;
    bool has_thresholding_op() const;

private:
    bool _internal_has_thresholding_op() const;

public:
    void clear_thresholding_op();
    ::optimization_guide::proto::FeatureLibrary_ThresholdingOp thresholding_op() const;
    void set_thresholding_op(::optimization_guide::proto::FeatureLibrary_ThresholdingOp value);

private:
    ::optimization_guide::proto::FeatureLibrary_ThresholdingOp _internal_thresholding_op() const;
    void _internal_set_thresholding_op(::optimization_guide::proto::FeatureLibrary_ThresholdingOp value);

public:
    // optional float threshold = 4;
    bool has_threshold() const;

private:
    bool _internal_has_threshold() const;

public:
    void clear_threshold();
    float threshold() const;
    void set_threshold(float value);

private:
    float _internal_threshold() const;
    void _internal_set_threshold(float value);

public:
    // @@protoc_insertion_point(class_scope:optimization_guide.proto.ThresholdingRule)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        int feature_name_;
        int normalizing_op_;
        int thresholding_op_;
        float threshold_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2foptimization_5fguide_2fproto_2fvisual_5fsearch_5fmodel_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class OrOfThresholdingRules final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.OrOfThresholdingRules) */ {
public:
    inline OrOfThresholdingRules()
        : OrOfThresholdingRules(nullptr)
    {
    }
    ~OrOfThresholdingRules() override;
    explicit PROTOBUF_CONSTEXPR OrOfThresholdingRules(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    OrOfThresholdingRules(const OrOfThresholdingRules& from);
    OrOfThresholdingRules(OrOfThresholdingRules&& from) noexcept
        : OrOfThresholdingRules()
    {
        *this = ::std::move(from);
    }

    inline OrOfThresholdingRules& operator=(const OrOfThresholdingRules& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline OrOfThresholdingRules& operator=(OrOfThresholdingRules&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const OrOfThresholdingRules& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const OrOfThresholdingRules* internal_default_instance()
    {
        return reinterpret_cast<const OrOfThresholdingRules*>(&_OrOfThresholdingRules_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 2;

    friend void swap(OrOfThresholdingRules& a, OrOfThresholdingRules& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(OrOfThresholdingRules* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(OrOfThresholdingRules* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    OrOfThresholdingRules* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<OrOfThresholdingRules>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const OrOfThresholdingRules& from);
    void MergeFrom(const OrOfThresholdingRules& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(OrOfThresholdingRules* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "optimization_guide.proto.OrOfThresholdingRules";
    }

protected:
    explicit OrOfThresholdingRules(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kRulesFieldNumber = 1,
    };
    // repeated .optimization_guide.proto.ThresholdingRule rules = 1;
    int rules_size() const;

private:
    int _internal_rules_size() const;

public:
    void clear_rules();
    ::optimization_guide::proto::ThresholdingRule* mutable_rules(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::ThresholdingRule>* mutable_rules();

private:
    const ::optimization_guide::proto::ThresholdingRule& _internal_rules(int index) const;
    ::optimization_guide::proto::ThresholdingRule* _internal_add_rules();

public:
    const ::optimization_guide::proto::ThresholdingRule& rules(int index) const;
    ::optimization_guide::proto::ThresholdingRule* add_rules();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::ThresholdingRule>& rules() const;

    // @@protoc_insertion_point(class_scope:optimization_guide.proto.OrOfThresholdingRules)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::ThresholdingRule> rules_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2foptimization_5fguide_2fproto_2fvisual_5fsearch_5fmodel_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class SortingClause final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.SortingClause) */ {
public:
    inline SortingClause()
        : SortingClause(nullptr)
    {
    }
    ~SortingClause() override;
    explicit PROTOBUF_CONSTEXPR SortingClause(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    SortingClause(const SortingClause& from);
    SortingClause(SortingClause&& from) noexcept
        : SortingClause()
    {
        *this = ::std::move(from);
    }

    inline SortingClause& operator=(const SortingClause& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline SortingClause& operator=(SortingClause&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const SortingClause& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const SortingClause* internal_default_instance()
    {
        return reinterpret_cast<const SortingClause*>(&_SortingClause_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 3;

    friend void swap(SortingClause& a, SortingClause& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(SortingClause* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(SortingClause* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    SortingClause* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<SortingClause>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const SortingClause& from);
    void MergeFrom(const SortingClause& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(SortingClause* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "optimization_guide.proto.SortingClause";
    }

protected:
    explicit SortingClause(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kFeatureNameFieldNumber = 1,
        kSortingOrderFieldNumber = 2,
    };
    // optional .optimization_guide.proto.FeatureLibrary.ImageLevelFeatureName feature_name = 1;
    bool has_feature_name() const;

private:
    bool _internal_has_feature_name() const;

public:
    void clear_feature_name();
    ::optimization_guide::proto::FeatureLibrary_ImageLevelFeatureName feature_name() const;
    void set_feature_name(::optimization_guide::proto::FeatureLibrary_ImageLevelFeatureName value);

private:
    ::optimization_guide::proto::FeatureLibrary_ImageLevelFeatureName _internal_feature_name() const;
    void _internal_set_feature_name(::optimization_guide::proto::FeatureLibrary_ImageLevelFeatureName value);

public:
    // optional .optimization_guide.proto.FeatureLibrary.SortingOrder sorting_order = 2;
    bool has_sorting_order() const;

private:
    bool _internal_has_sorting_order() const;

public:
    void clear_sorting_order();
    ::optimization_guide::proto::FeatureLibrary_SortingOrder sorting_order() const;
    void set_sorting_order(::optimization_guide::proto::FeatureLibrary_SortingOrder value);

private:
    ::optimization_guide::proto::FeatureLibrary_SortingOrder _internal_sorting_order() const;
    void _internal_set_sorting_order(::optimization_guide::proto::FeatureLibrary_SortingOrder value);

public:
    // @@protoc_insertion_point(class_scope:optimization_guide.proto.SortingClause)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        int feature_name_;
        int sorting_order_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2foptimization_5fguide_2fproto_2fvisual_5fsearch_5fmodel_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class AdditionalCheapPruningOptions final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.AdditionalCheapPruningOptions) */ {
public:
    inline AdditionalCheapPruningOptions()
        : AdditionalCheapPruningOptions(nullptr)
    {
    }
    ~AdditionalCheapPruningOptions() override;
    explicit PROTOBUF_CONSTEXPR AdditionalCheapPruningOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    AdditionalCheapPruningOptions(const AdditionalCheapPruningOptions& from);
    AdditionalCheapPruningOptions(AdditionalCheapPruningOptions&& from) noexcept
        : AdditionalCheapPruningOptions()
    {
        *this = ::std::move(from);
    }

    inline AdditionalCheapPruningOptions& operator=(const AdditionalCheapPruningOptions& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline AdditionalCheapPruningOptions& operator=(AdditionalCheapPruningOptions&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const AdditionalCheapPruningOptions& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const AdditionalCheapPruningOptions* internal_default_instance()
    {
        return reinterpret_cast<const AdditionalCheapPruningOptions*>(&_AdditionalCheapPruningOptions_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 4;

    friend void swap(AdditionalCheapPruningOptions& a, AdditionalCheapPruningOptions& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(AdditionalCheapPruningOptions* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(AdditionalCheapPruningOptions* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    AdditionalCheapPruningOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<AdditionalCheapPruningOptions>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const AdditionalCheapPruningOptions& from);
    void MergeFrom(const AdditionalCheapPruningOptions& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(AdditionalCheapPruningOptions* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "optimization_guide.proto.AdditionalCheapPruningOptions";
    }

protected:
    explicit AdditionalCheapPruningOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kZIndexOverlapFractionFieldNumber = 1,
    };
    // optional float z_index_overlap_fraction = 1;
    bool has_z_index_overlap_fraction() const;

private:
    bool _internal_has_z_index_overlap_fraction() const;

public:
    void clear_z_index_overlap_fraction();
    float z_index_overlap_fraction() const;
    void set_z_index_overlap_fraction(float value);

private:
    float _internal_z_index_overlap_fraction() const;
    void _internal_set_z_index_overlap_fraction(float value);

public:
    // @@protoc_insertion_point(class_scope:optimization_guide.proto.AdditionalCheapPruningOptions)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        float z_index_overlap_fraction_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2foptimization_5fguide_2fproto_2fvisual_5fsearch_5fmodel_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class EligibilitySpec final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.EligibilitySpec) */ {
public:
    inline EligibilitySpec()
        : EligibilitySpec(nullptr)
    {
    }
    ~EligibilitySpec() override;
    explicit PROTOBUF_CONSTEXPR EligibilitySpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    EligibilitySpec(const EligibilitySpec& from);
    EligibilitySpec(EligibilitySpec&& from) noexcept
        : EligibilitySpec()
    {
        *this = ::std::move(from);
    }

    inline EligibilitySpec& operator=(const EligibilitySpec& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline EligibilitySpec& operator=(EligibilitySpec&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const EligibilitySpec& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const EligibilitySpec* internal_default_instance()
    {
        return reinterpret_cast<const EligibilitySpec*>(&_EligibilitySpec_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 5;

    friend void swap(EligibilitySpec& a, EligibilitySpec& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(EligibilitySpec* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(EligibilitySpec* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    EligibilitySpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<EligibilitySpec>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const EligibilitySpec& from);
    void MergeFrom(const EligibilitySpec& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(EligibilitySpec* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "optimization_guide.proto.EligibilitySpec";
    }

protected:
    explicit EligibilitySpec(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kCheapPruningRulesFieldNumber = 1,
        kClassifierScoreRulesFieldNumber = 2,
        kPostRenormalizationRulesFieldNumber = 3,
        kSortingClausesFieldNumber = 4,
        kAdditionalCheapPruningOptionsFieldNumber = 5,
    };
    // repeated .optimization_guide.proto.OrOfThresholdingRules cheap_pruning_rules = 1;
    int cheap_pruning_rules_size() const;

private:
    int _internal_cheap_pruning_rules_size() const;

public:
    void clear_cheap_pruning_rules();
    ::optimization_guide::proto::OrOfThresholdingRules* mutable_cheap_pruning_rules(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::OrOfThresholdingRules>* mutable_cheap_pruning_rules();

private:
    const ::optimization_guide::proto::OrOfThresholdingRules& _internal_cheap_pruning_rules(int index) const;
    ::optimization_guide::proto::OrOfThresholdingRules* _internal_add_cheap_pruning_rules();

public:
    const ::optimization_guide::proto::OrOfThresholdingRules& cheap_pruning_rules(int index) const;
    ::optimization_guide::proto::OrOfThresholdingRules* add_cheap_pruning_rules();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::OrOfThresholdingRules>& cheap_pruning_rules() const;

    // repeated .optimization_guide.proto.OrOfThresholdingRules classifier_score_rules = 2;
    int classifier_score_rules_size() const;

private:
    int _internal_classifier_score_rules_size() const;

public:
    void clear_classifier_score_rules();
    ::optimization_guide::proto::OrOfThresholdingRules* mutable_classifier_score_rules(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::OrOfThresholdingRules>* mutable_classifier_score_rules();

private:
    const ::optimization_guide::proto::OrOfThresholdingRules& _internal_classifier_score_rules(int index) const;
    ::optimization_guide::proto::OrOfThresholdingRules* _internal_add_classifier_score_rules();

public:
    const ::optimization_guide::proto::OrOfThresholdingRules& classifier_score_rules(int index) const;
    ::optimization_guide::proto::OrOfThresholdingRules* add_classifier_score_rules();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::OrOfThresholdingRules>& classifier_score_rules() const;

    // repeated .optimization_guide.proto.OrOfThresholdingRules post_renormalization_rules = 3;
    int post_renormalization_rules_size() const;

private:
    int _internal_post_renormalization_rules_size() const;

public:
    void clear_post_renormalization_rules();
    ::optimization_guide::proto::OrOfThresholdingRules* mutable_post_renormalization_rules(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::OrOfThresholdingRules>* mutable_post_renormalization_rules();

private:
    const ::optimization_guide::proto::OrOfThresholdingRules& _internal_post_renormalization_rules(int index) const;
    ::optimization_guide::proto::OrOfThresholdingRules* _internal_add_post_renormalization_rules();

public:
    const ::optimization_guide::proto::OrOfThresholdingRules& post_renormalization_rules(int index) const;
    ::optimization_guide::proto::OrOfThresholdingRules* add_post_renormalization_rules();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::OrOfThresholdingRules>& post_renormalization_rules() const;

    // repeated .optimization_guide.proto.SortingClause sorting_clauses = 4;
    int sorting_clauses_size() const;

private:
    int _internal_sorting_clauses_size() const;

public:
    void clear_sorting_clauses();
    ::optimization_guide::proto::SortingClause* mutable_sorting_clauses(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::SortingClause>* mutable_sorting_clauses();

private:
    const ::optimization_guide::proto::SortingClause& _internal_sorting_clauses(int index) const;
    ::optimization_guide::proto::SortingClause* _internal_add_sorting_clauses();

public:
    const ::optimization_guide::proto::SortingClause& sorting_clauses(int index) const;
    ::optimization_guide::proto::SortingClause* add_sorting_clauses();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::SortingClause>& sorting_clauses() const;

    // optional .optimization_guide.proto.AdditionalCheapPruningOptions additional_cheap_pruning_options = 5;
    bool has_additional_cheap_pruning_options() const;

private:
    bool _internal_has_additional_cheap_pruning_options() const;

public:
    void clear_additional_cheap_pruning_options();
    const ::optimization_guide::proto::AdditionalCheapPruningOptions& additional_cheap_pruning_options() const;
    PROTOBUF_NODISCARD ::optimization_guide::proto::AdditionalCheapPruningOptions* release_additional_cheap_pruning_options();
    ::optimization_guide::proto::AdditionalCheapPruningOptions* mutable_additional_cheap_pruning_options();
    void set_allocated_additional_cheap_pruning_options(::optimization_guide::proto::AdditionalCheapPruningOptions* additional_cheap_pruning_options);

private:
    const ::optimization_guide::proto::AdditionalCheapPruningOptions& _internal_additional_cheap_pruning_options() const;
    ::optimization_guide::proto::AdditionalCheapPruningOptions* _internal_mutable_additional_cheap_pruning_options();

public:
    void unsafe_arena_set_allocated_additional_cheap_pruning_options(
        ::optimization_guide::proto::AdditionalCheapPruningOptions* additional_cheap_pruning_options);
    ::optimization_guide::proto::AdditionalCheapPruningOptions* unsafe_arena_release_additional_cheap_pruning_options();

    // @@protoc_insertion_point(class_scope:optimization_guide.proto.EligibilitySpec)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::OrOfThresholdingRules> cheap_pruning_rules_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::OrOfThresholdingRules> classifier_score_rules_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::OrOfThresholdingRules> post_renormalization_rules_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::SortingClause> sorting_clauses_;
        ::optimization_guide::proto::AdditionalCheapPruningOptions* additional_cheap_pruning_options_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2foptimization_5fguide_2fproto_2fvisual_5fsearch_5fmodel_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class VisualSearchModelMetadata final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.VisualSearchModelMetadata) */ {
public:
    inline VisualSearchModelMetadata()
        : VisualSearchModelMetadata(nullptr)
    {
    }
    ~VisualSearchModelMetadata() override;
    explicit PROTOBUF_CONSTEXPR VisualSearchModelMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    VisualSearchModelMetadata(const VisualSearchModelMetadata& from);
    VisualSearchModelMetadata(VisualSearchModelMetadata&& from) noexcept
        : VisualSearchModelMetadata()
    {
        *this = ::std::move(from);
    }

    inline VisualSearchModelMetadata& operator=(const VisualSearchModelMetadata& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline VisualSearchModelMetadata& operator=(VisualSearchModelMetadata&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const VisualSearchModelMetadata& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const VisualSearchModelMetadata* internal_default_instance()
    {
        return reinterpret_cast<const VisualSearchModelMetadata*>(&_VisualSearchModelMetadata_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 6;

    friend void swap(VisualSearchModelMetadata& a, VisualSearchModelMetadata& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(VisualSearchModelMetadata* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(VisualSearchModelMetadata* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    VisualSearchModelMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<VisualSearchModelMetadata>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const VisualSearchModelMetadata& from);
    void MergeFrom(const VisualSearchModelMetadata& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(VisualSearchModelMetadata* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "optimization_guide.proto.VisualSearchModelMetadata";
    }

protected:
    explicit VisualSearchModelMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kEligibilitySpecFieldNumber = 1,
        kMetadataVersionFieldNumber = 2,
    };
    // optional .optimization_guide.proto.EligibilitySpec eligibility_spec = 1;
    bool has_eligibility_spec() const;

private:
    bool _internal_has_eligibility_spec() const;

public:
    void clear_eligibility_spec();
    const ::optimization_guide::proto::EligibilitySpec& eligibility_spec() const;
    PROTOBUF_NODISCARD ::optimization_guide::proto::EligibilitySpec* release_eligibility_spec();
    ::optimization_guide::proto::EligibilitySpec* mutable_eligibility_spec();
    void set_allocated_eligibility_spec(::optimization_guide::proto::EligibilitySpec* eligibility_spec);

private:
    const ::optimization_guide::proto::EligibilitySpec& _internal_eligibility_spec() const;
    ::optimization_guide::proto::EligibilitySpec* _internal_mutable_eligibility_spec();

public:
    void unsafe_arena_set_allocated_eligibility_spec(::optimization_guide::proto::EligibilitySpec* eligibility_spec);
    ::optimization_guide::proto::EligibilitySpec* unsafe_arena_release_eligibility_spec();

    // optional int64 metadata_version = 2;
    bool has_metadata_version() const;

private:
    bool _internal_has_metadata_version() const;

public:
    void clear_metadata_version();
    int64_t metadata_version() const;
    void set_metadata_version(int64_t value);

private:
    int64_t _internal_metadata_version() const;
    void _internal_set_metadata_version(int64_t value);

public:
    // @@protoc_insertion_point(class_scope:optimization_guide.proto.VisualSearchModelMetadata)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::optimization_guide::proto::EligibilitySpec* eligibility_spec_;
        int64_t metadata_version_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2foptimization_5fguide_2fproto_2fvisual_5fsearch_5fmodel_5fmetadata_2eproto;
};
// ===================================================================

// ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif // __GNUC__
// FeatureLibrary

// -------------------------------------------------------------------

// ThresholdingRule

// optional .optimization_guide.proto.FeatureLibrary.ImageLevelFeatureName feature_name = 1;
inline bool ThresholdingRule::_internal_has_feature_name() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool ThresholdingRule::has_feature_name() const
{
    return _internal_has_feature_name();
}
inline void ThresholdingRule::clear_feature_name()
{
    _impl_.feature_name_ = 0;
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::optimization_guide::proto::FeatureLibrary_ImageLevelFeatureName ThresholdingRule::_internal_feature_name() const
{
    return static_cast<::optimization_guide::proto::FeatureLibrary_ImageLevelFeatureName>(_impl_.feature_name_);
}
inline ::optimization_guide::proto::FeatureLibrary_ImageLevelFeatureName ThresholdingRule::feature_name() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.ThresholdingRule.feature_name)
    return _internal_feature_name();
}
inline void ThresholdingRule::_internal_set_feature_name(::optimization_guide::proto::FeatureLibrary_ImageLevelFeatureName value)
{
    assert(::optimization_guide::proto::FeatureLibrary_ImageLevelFeatureName_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.feature_name_ = value;
}
inline void ThresholdingRule::set_feature_name(::optimization_guide::proto::FeatureLibrary_ImageLevelFeatureName value)
{
    _internal_set_feature_name(value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.ThresholdingRule.feature_name)
}

// optional .optimization_guide.proto.FeatureLibrary.NormalizingOp normalizing_op = 2;
inline bool ThresholdingRule::_internal_has_normalizing_op() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool ThresholdingRule::has_normalizing_op() const
{
    return _internal_has_normalizing_op();
}
inline void ThresholdingRule::clear_normalizing_op()
{
    _impl_.normalizing_op_ = 0;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::optimization_guide::proto::FeatureLibrary_NormalizingOp ThresholdingRule::_internal_normalizing_op() const
{
    return static_cast<::optimization_guide::proto::FeatureLibrary_NormalizingOp>(_impl_.normalizing_op_);
}
inline ::optimization_guide::proto::FeatureLibrary_NormalizingOp ThresholdingRule::normalizing_op() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.ThresholdingRule.normalizing_op)
    return _internal_normalizing_op();
}
inline void ThresholdingRule::_internal_set_normalizing_op(::optimization_guide::proto::FeatureLibrary_NormalizingOp value)
{
    assert(::optimization_guide::proto::FeatureLibrary_NormalizingOp_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.normalizing_op_ = value;
}
inline void ThresholdingRule::set_normalizing_op(::optimization_guide::proto::FeatureLibrary_NormalizingOp value)
{
    _internal_set_normalizing_op(value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.ThresholdingRule.normalizing_op)
}

// optional .optimization_guide.proto.FeatureLibrary.ThresholdingOp thresholding_op = 3;
inline bool ThresholdingRule::_internal_has_thresholding_op() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool ThresholdingRule::has_thresholding_op() const
{
    return _internal_has_thresholding_op();
}
inline void ThresholdingRule::clear_thresholding_op()
{
    _impl_.thresholding_op_ = 0;
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::optimization_guide::proto::FeatureLibrary_ThresholdingOp ThresholdingRule::_internal_thresholding_op() const
{
    return static_cast<::optimization_guide::proto::FeatureLibrary_ThresholdingOp>(_impl_.thresholding_op_);
}
inline ::optimization_guide::proto::FeatureLibrary_ThresholdingOp ThresholdingRule::thresholding_op() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.ThresholdingRule.thresholding_op)
    return _internal_thresholding_op();
}
inline void ThresholdingRule::_internal_set_thresholding_op(::optimization_guide::proto::FeatureLibrary_ThresholdingOp value)
{
    assert(::optimization_guide::proto::FeatureLibrary_ThresholdingOp_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.thresholding_op_ = value;
}
inline void ThresholdingRule::set_thresholding_op(::optimization_guide::proto::FeatureLibrary_ThresholdingOp value)
{
    _internal_set_thresholding_op(value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.ThresholdingRule.thresholding_op)
}

// optional float threshold = 4;
inline bool ThresholdingRule::_internal_has_threshold() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    return value;
}
inline bool ThresholdingRule::has_threshold() const
{
    return _internal_has_threshold();
}
inline void ThresholdingRule::clear_threshold()
{
    _impl_.threshold_ = 0;
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float ThresholdingRule::_internal_threshold() const
{
    return _impl_.threshold_;
}
inline float ThresholdingRule::threshold() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.ThresholdingRule.threshold)
    return _internal_threshold();
}
inline void ThresholdingRule::_internal_set_threshold(float value)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.threshold_ = value;
}
inline void ThresholdingRule::set_threshold(float value)
{
    _internal_set_threshold(value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.ThresholdingRule.threshold)
}

// -------------------------------------------------------------------

// OrOfThresholdingRules

// repeated .optimization_guide.proto.ThresholdingRule rules = 1;
inline int OrOfThresholdingRules::_internal_rules_size() const
{
    return _impl_.rules_.size();
}
inline int OrOfThresholdingRules::rules_size() const
{
    return _internal_rules_size();
}
inline void OrOfThresholdingRules::clear_rules()
{
    _impl_.rules_.Clear();
}
inline ::optimization_guide::proto::ThresholdingRule* OrOfThresholdingRules::mutable_rules(int index)
{
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.OrOfThresholdingRules.rules)
    return _impl_.rules_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::ThresholdingRule>* OrOfThresholdingRules::mutable_rules()
{
    // @@protoc_insertion_point(field_mutable_list:optimization_guide.proto.OrOfThresholdingRules.rules)
    return &_impl_.rules_;
}
inline const ::optimization_guide::proto::ThresholdingRule& OrOfThresholdingRules::_internal_rules(int index) const
{
    return _impl_.rules_.Get(index);
}
inline const ::optimization_guide::proto::ThresholdingRule& OrOfThresholdingRules::rules(int index) const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.OrOfThresholdingRules.rules)
    return _internal_rules(index);
}
inline ::optimization_guide::proto::ThresholdingRule* OrOfThresholdingRules::_internal_add_rules()
{
    return _impl_.rules_.Add();
}
inline ::optimization_guide::proto::ThresholdingRule* OrOfThresholdingRules::add_rules()
{
    ::optimization_guide::proto::ThresholdingRule* _add = _internal_add_rules();
    // @@protoc_insertion_point(field_add:optimization_guide.proto.OrOfThresholdingRules.rules)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::ThresholdingRule>& OrOfThresholdingRules::rules() const
{
    // @@protoc_insertion_point(field_list:optimization_guide.proto.OrOfThresholdingRules.rules)
    return _impl_.rules_;
}

// -------------------------------------------------------------------

// SortingClause

// optional .optimization_guide.proto.FeatureLibrary.ImageLevelFeatureName feature_name = 1;
inline bool SortingClause::_internal_has_feature_name() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool SortingClause::has_feature_name() const
{
    return _internal_has_feature_name();
}
inline void SortingClause::clear_feature_name()
{
    _impl_.feature_name_ = 0;
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::optimization_guide::proto::FeatureLibrary_ImageLevelFeatureName SortingClause::_internal_feature_name() const
{
    return static_cast<::optimization_guide::proto::FeatureLibrary_ImageLevelFeatureName>(_impl_.feature_name_);
}
inline ::optimization_guide::proto::FeatureLibrary_ImageLevelFeatureName SortingClause::feature_name() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.SortingClause.feature_name)
    return _internal_feature_name();
}
inline void SortingClause::_internal_set_feature_name(::optimization_guide::proto::FeatureLibrary_ImageLevelFeatureName value)
{
    assert(::optimization_guide::proto::FeatureLibrary_ImageLevelFeatureName_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.feature_name_ = value;
}
inline void SortingClause::set_feature_name(::optimization_guide::proto::FeatureLibrary_ImageLevelFeatureName value)
{
    _internal_set_feature_name(value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.SortingClause.feature_name)
}

// optional .optimization_guide.proto.FeatureLibrary.SortingOrder sorting_order = 2;
inline bool SortingClause::_internal_has_sorting_order() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool SortingClause::has_sorting_order() const
{
    return _internal_has_sorting_order();
}
inline void SortingClause::clear_sorting_order()
{
    _impl_.sorting_order_ = 0;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::optimization_guide::proto::FeatureLibrary_SortingOrder SortingClause::_internal_sorting_order() const
{
    return static_cast<::optimization_guide::proto::FeatureLibrary_SortingOrder>(_impl_.sorting_order_);
}
inline ::optimization_guide::proto::FeatureLibrary_SortingOrder SortingClause::sorting_order() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.SortingClause.sorting_order)
    return _internal_sorting_order();
}
inline void SortingClause::_internal_set_sorting_order(::optimization_guide::proto::FeatureLibrary_SortingOrder value)
{
    assert(::optimization_guide::proto::FeatureLibrary_SortingOrder_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.sorting_order_ = value;
}
inline void SortingClause::set_sorting_order(::optimization_guide::proto::FeatureLibrary_SortingOrder value)
{
    _internal_set_sorting_order(value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.SortingClause.sorting_order)
}

// -------------------------------------------------------------------

// AdditionalCheapPruningOptions

// optional float z_index_overlap_fraction = 1;
inline bool AdditionalCheapPruningOptions::_internal_has_z_index_overlap_fraction() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool AdditionalCheapPruningOptions::has_z_index_overlap_fraction() const
{
    return _internal_has_z_index_overlap_fraction();
}
inline void AdditionalCheapPruningOptions::clear_z_index_overlap_fraction()
{
    _impl_.z_index_overlap_fraction_ = 0;
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float AdditionalCheapPruningOptions::_internal_z_index_overlap_fraction() const
{
    return _impl_.z_index_overlap_fraction_;
}
inline float AdditionalCheapPruningOptions::z_index_overlap_fraction() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.AdditionalCheapPruningOptions.z_index_overlap_fraction)
    return _internal_z_index_overlap_fraction();
}
inline void AdditionalCheapPruningOptions::_internal_set_z_index_overlap_fraction(float value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.z_index_overlap_fraction_ = value;
}
inline void AdditionalCheapPruningOptions::set_z_index_overlap_fraction(float value)
{
    _internal_set_z_index_overlap_fraction(value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.AdditionalCheapPruningOptions.z_index_overlap_fraction)
}

// -------------------------------------------------------------------

// EligibilitySpec

// repeated .optimization_guide.proto.OrOfThresholdingRules cheap_pruning_rules = 1;
inline int EligibilitySpec::_internal_cheap_pruning_rules_size() const
{
    return _impl_.cheap_pruning_rules_.size();
}
inline int EligibilitySpec::cheap_pruning_rules_size() const
{
    return _internal_cheap_pruning_rules_size();
}
inline void EligibilitySpec::clear_cheap_pruning_rules()
{
    _impl_.cheap_pruning_rules_.Clear();
}
inline ::optimization_guide::proto::OrOfThresholdingRules* EligibilitySpec::mutable_cheap_pruning_rules(int index)
{
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.EligibilitySpec.cheap_pruning_rules)
    return _impl_.cheap_pruning_rules_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::OrOfThresholdingRules>* EligibilitySpec::mutable_cheap_pruning_rules()
{
    // @@protoc_insertion_point(field_mutable_list:optimization_guide.proto.EligibilitySpec.cheap_pruning_rules)
    return &_impl_.cheap_pruning_rules_;
}
inline const ::optimization_guide::proto::OrOfThresholdingRules& EligibilitySpec::_internal_cheap_pruning_rules(int index) const
{
    return _impl_.cheap_pruning_rules_.Get(index);
}
inline const ::optimization_guide::proto::OrOfThresholdingRules& EligibilitySpec::cheap_pruning_rules(int index) const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.EligibilitySpec.cheap_pruning_rules)
    return _internal_cheap_pruning_rules(index);
}
inline ::optimization_guide::proto::OrOfThresholdingRules* EligibilitySpec::_internal_add_cheap_pruning_rules()
{
    return _impl_.cheap_pruning_rules_.Add();
}
inline ::optimization_guide::proto::OrOfThresholdingRules* EligibilitySpec::add_cheap_pruning_rules()
{
    ::optimization_guide::proto::OrOfThresholdingRules* _add = _internal_add_cheap_pruning_rules();
    // @@protoc_insertion_point(field_add:optimization_guide.proto.EligibilitySpec.cheap_pruning_rules)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::OrOfThresholdingRules>& EligibilitySpec::cheap_pruning_rules() const
{
    // @@protoc_insertion_point(field_list:optimization_guide.proto.EligibilitySpec.cheap_pruning_rules)
    return _impl_.cheap_pruning_rules_;
}

// optional .optimization_guide.proto.AdditionalCheapPruningOptions additional_cheap_pruning_options = 5;
inline bool EligibilitySpec::_internal_has_additional_cheap_pruning_options() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.additional_cheap_pruning_options_ != nullptr);
    return value;
}
inline bool EligibilitySpec::has_additional_cheap_pruning_options() const
{
    return _internal_has_additional_cheap_pruning_options();
}
inline void EligibilitySpec::clear_additional_cheap_pruning_options()
{
    if (_impl_.additional_cheap_pruning_options_ != nullptr)
        _impl_.additional_cheap_pruning_options_->Clear();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::optimization_guide::proto::AdditionalCheapPruningOptions& EligibilitySpec::_internal_additional_cheap_pruning_options() const
{
    const ::optimization_guide::proto::AdditionalCheapPruningOptions* p = _impl_.additional_cheap_pruning_options_;
    return p != nullptr ? *p
                        : reinterpret_cast<const ::optimization_guide::proto::AdditionalCheapPruningOptions&>(
                            ::optimization_guide::proto::_AdditionalCheapPruningOptions_default_instance_);
}
inline const ::optimization_guide::proto::AdditionalCheapPruningOptions& EligibilitySpec::additional_cheap_pruning_options() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.EligibilitySpec.additional_cheap_pruning_options)
    return _internal_additional_cheap_pruning_options();
}
inline void EligibilitySpec::unsafe_arena_set_allocated_additional_cheap_pruning_options(
    ::optimization_guide::proto::AdditionalCheapPruningOptions* additional_cheap_pruning_options)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.additional_cheap_pruning_options_);
    }
    _impl_.additional_cheap_pruning_options_ = additional_cheap_pruning_options;
    if (additional_cheap_pruning_options) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:optimization_guide.proto.EligibilitySpec.additional_cheap_pruning_options)
}
inline ::optimization_guide::proto::AdditionalCheapPruningOptions* EligibilitySpec::release_additional_cheap_pruning_options()
{
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::optimization_guide::proto::AdditionalCheapPruningOptions* temp = _impl_.additional_cheap_pruning_options_;
    _impl_.additional_cheap_pruning_options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::optimization_guide::proto::AdditionalCheapPruningOptions* EligibilitySpec::unsafe_arena_release_additional_cheap_pruning_options()
{
    // @@protoc_insertion_point(field_release:optimization_guide.proto.EligibilitySpec.additional_cheap_pruning_options)
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::optimization_guide::proto::AdditionalCheapPruningOptions* temp = _impl_.additional_cheap_pruning_options_;
    _impl_.additional_cheap_pruning_options_ = nullptr;
    return temp;
}
inline ::optimization_guide::proto::AdditionalCheapPruningOptions* EligibilitySpec::_internal_mutable_additional_cheap_pruning_options()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    if (_impl_.additional_cheap_pruning_options_ == nullptr) {
        auto* p = CreateMaybeMessage<::optimization_guide::proto::AdditionalCheapPruningOptions>(GetArenaForAllocation());
        _impl_.additional_cheap_pruning_options_ = p;
    }
    return _impl_.additional_cheap_pruning_options_;
}
inline ::optimization_guide::proto::AdditionalCheapPruningOptions* EligibilitySpec::mutable_additional_cheap_pruning_options()
{
    ::optimization_guide::proto::AdditionalCheapPruningOptions* _msg = _internal_mutable_additional_cheap_pruning_options();
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.EligibilitySpec.additional_cheap_pruning_options)
    return _msg;
}
inline void EligibilitySpec::set_allocated_additional_cheap_pruning_options(
    ::optimization_guide::proto::AdditionalCheapPruningOptions* additional_cheap_pruning_options)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.additional_cheap_pruning_options_;
    }
    if (additional_cheap_pruning_options) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(additional_cheap_pruning_options);
        if (message_arena != submessage_arena) {
            additional_cheap_pruning_options
                = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, additional_cheap_pruning_options, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.additional_cheap_pruning_options_ = additional_cheap_pruning_options;
    // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.EligibilitySpec.additional_cheap_pruning_options)
}

// repeated .optimization_guide.proto.OrOfThresholdingRules classifier_score_rules = 2;
inline int EligibilitySpec::_internal_classifier_score_rules_size() const
{
    return _impl_.classifier_score_rules_.size();
}
inline int EligibilitySpec::classifier_score_rules_size() const
{
    return _internal_classifier_score_rules_size();
}
inline void EligibilitySpec::clear_classifier_score_rules()
{
    _impl_.classifier_score_rules_.Clear();
}
inline ::optimization_guide::proto::OrOfThresholdingRules* EligibilitySpec::mutable_classifier_score_rules(int index)
{
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.EligibilitySpec.classifier_score_rules)
    return _impl_.classifier_score_rules_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::OrOfThresholdingRules>* EligibilitySpec::mutable_classifier_score_rules()
{
    // @@protoc_insertion_point(field_mutable_list:optimization_guide.proto.EligibilitySpec.classifier_score_rules)
    return &_impl_.classifier_score_rules_;
}
inline const ::optimization_guide::proto::OrOfThresholdingRules& EligibilitySpec::_internal_classifier_score_rules(int index) const
{
    return _impl_.classifier_score_rules_.Get(index);
}
inline const ::optimization_guide::proto::OrOfThresholdingRules& EligibilitySpec::classifier_score_rules(int index) const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.EligibilitySpec.classifier_score_rules)
    return _internal_classifier_score_rules(index);
}
inline ::optimization_guide::proto::OrOfThresholdingRules* EligibilitySpec::_internal_add_classifier_score_rules()
{
    return _impl_.classifier_score_rules_.Add();
}
inline ::optimization_guide::proto::OrOfThresholdingRules* EligibilitySpec::add_classifier_score_rules()
{
    ::optimization_guide::proto::OrOfThresholdingRules* _add = _internal_add_classifier_score_rules();
    // @@protoc_insertion_point(field_add:optimization_guide.proto.EligibilitySpec.classifier_score_rules)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::OrOfThresholdingRules>& EligibilitySpec::classifier_score_rules() const
{
    // @@protoc_insertion_point(field_list:optimization_guide.proto.EligibilitySpec.classifier_score_rules)
    return _impl_.classifier_score_rules_;
}

// repeated .optimization_guide.proto.OrOfThresholdingRules post_renormalization_rules = 3;
inline int EligibilitySpec::_internal_post_renormalization_rules_size() const
{
    return _impl_.post_renormalization_rules_.size();
}
inline int EligibilitySpec::post_renormalization_rules_size() const
{
    return _internal_post_renormalization_rules_size();
}
inline void EligibilitySpec::clear_post_renormalization_rules()
{
    _impl_.post_renormalization_rules_.Clear();
}
inline ::optimization_guide::proto::OrOfThresholdingRules* EligibilitySpec::mutable_post_renormalization_rules(int index)
{
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.EligibilitySpec.post_renormalization_rules)
    return _impl_.post_renormalization_rules_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::OrOfThresholdingRules>* EligibilitySpec::mutable_post_renormalization_rules()
{
    // @@protoc_insertion_point(field_mutable_list:optimization_guide.proto.EligibilitySpec.post_renormalization_rules)
    return &_impl_.post_renormalization_rules_;
}
inline const ::optimization_guide::proto::OrOfThresholdingRules& EligibilitySpec::_internal_post_renormalization_rules(int index) const
{
    return _impl_.post_renormalization_rules_.Get(index);
}
inline const ::optimization_guide::proto::OrOfThresholdingRules& EligibilitySpec::post_renormalization_rules(int index) const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.EligibilitySpec.post_renormalization_rules)
    return _internal_post_renormalization_rules(index);
}
inline ::optimization_guide::proto::OrOfThresholdingRules* EligibilitySpec::_internal_add_post_renormalization_rules()
{
    return _impl_.post_renormalization_rules_.Add();
}
inline ::optimization_guide::proto::OrOfThresholdingRules* EligibilitySpec::add_post_renormalization_rules()
{
    ::optimization_guide::proto::OrOfThresholdingRules* _add = _internal_add_post_renormalization_rules();
    // @@protoc_insertion_point(field_add:optimization_guide.proto.EligibilitySpec.post_renormalization_rules)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::OrOfThresholdingRules>& EligibilitySpec::post_renormalization_rules() const
{
    // @@protoc_insertion_point(field_list:optimization_guide.proto.EligibilitySpec.post_renormalization_rules)
    return _impl_.post_renormalization_rules_;
}

// repeated .optimization_guide.proto.SortingClause sorting_clauses = 4;
inline int EligibilitySpec::_internal_sorting_clauses_size() const
{
    return _impl_.sorting_clauses_.size();
}
inline int EligibilitySpec::sorting_clauses_size() const
{
    return _internal_sorting_clauses_size();
}
inline void EligibilitySpec::clear_sorting_clauses()
{
    _impl_.sorting_clauses_.Clear();
}
inline ::optimization_guide::proto::SortingClause* EligibilitySpec::mutable_sorting_clauses(int index)
{
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.EligibilitySpec.sorting_clauses)
    return _impl_.sorting_clauses_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::SortingClause>* EligibilitySpec::mutable_sorting_clauses()
{
    // @@protoc_insertion_point(field_mutable_list:optimization_guide.proto.EligibilitySpec.sorting_clauses)
    return &_impl_.sorting_clauses_;
}
inline const ::optimization_guide::proto::SortingClause& EligibilitySpec::_internal_sorting_clauses(int index) const
{
    return _impl_.sorting_clauses_.Get(index);
}
inline const ::optimization_guide::proto::SortingClause& EligibilitySpec::sorting_clauses(int index) const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.EligibilitySpec.sorting_clauses)
    return _internal_sorting_clauses(index);
}
inline ::optimization_guide::proto::SortingClause* EligibilitySpec::_internal_add_sorting_clauses()
{
    return _impl_.sorting_clauses_.Add();
}
inline ::optimization_guide::proto::SortingClause* EligibilitySpec::add_sorting_clauses()
{
    ::optimization_guide::proto::SortingClause* _add = _internal_add_sorting_clauses();
    // @@protoc_insertion_point(field_add:optimization_guide.proto.EligibilitySpec.sorting_clauses)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::SortingClause>& EligibilitySpec::sorting_clauses() const
{
    // @@protoc_insertion_point(field_list:optimization_guide.proto.EligibilitySpec.sorting_clauses)
    return _impl_.sorting_clauses_;
}

// -------------------------------------------------------------------

// VisualSearchModelMetadata

// optional .optimization_guide.proto.EligibilitySpec eligibility_spec = 1;
inline bool VisualSearchModelMetadata::_internal_has_eligibility_spec() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.eligibility_spec_ != nullptr);
    return value;
}
inline bool VisualSearchModelMetadata::has_eligibility_spec() const
{
    return _internal_has_eligibility_spec();
}
inline void VisualSearchModelMetadata::clear_eligibility_spec()
{
    if (_impl_.eligibility_spec_ != nullptr)
        _impl_.eligibility_spec_->Clear();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::optimization_guide::proto::EligibilitySpec& VisualSearchModelMetadata::_internal_eligibility_spec() const
{
    const ::optimization_guide::proto::EligibilitySpec* p = _impl_.eligibility_spec_;
    return p != nullptr
        ? *p
        : reinterpret_cast<const ::optimization_guide::proto::EligibilitySpec&>(::optimization_guide::proto::_EligibilitySpec_default_instance_);
}
inline const ::optimization_guide::proto::EligibilitySpec& VisualSearchModelMetadata::eligibility_spec() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.VisualSearchModelMetadata.eligibility_spec)
    return _internal_eligibility_spec();
}
inline void VisualSearchModelMetadata::unsafe_arena_set_allocated_eligibility_spec(::optimization_guide::proto::EligibilitySpec* eligibility_spec)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.eligibility_spec_);
    }
    _impl_.eligibility_spec_ = eligibility_spec;
    if (eligibility_spec) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:optimization_guide.proto.VisualSearchModelMetadata.eligibility_spec)
}
inline ::optimization_guide::proto::EligibilitySpec* VisualSearchModelMetadata::release_eligibility_spec()
{
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::optimization_guide::proto::EligibilitySpec* temp = _impl_.eligibility_spec_;
    _impl_.eligibility_spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::optimization_guide::proto::EligibilitySpec* VisualSearchModelMetadata::unsafe_arena_release_eligibility_spec()
{
    // @@protoc_insertion_point(field_release:optimization_guide.proto.VisualSearchModelMetadata.eligibility_spec)
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::optimization_guide::proto::EligibilitySpec* temp = _impl_.eligibility_spec_;
    _impl_.eligibility_spec_ = nullptr;
    return temp;
}
inline ::optimization_guide::proto::EligibilitySpec* VisualSearchModelMetadata::_internal_mutable_eligibility_spec()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    if (_impl_.eligibility_spec_ == nullptr) {
        auto* p = CreateMaybeMessage<::optimization_guide::proto::EligibilitySpec>(GetArenaForAllocation());
        _impl_.eligibility_spec_ = p;
    }
    return _impl_.eligibility_spec_;
}
inline ::optimization_guide::proto::EligibilitySpec* VisualSearchModelMetadata::mutable_eligibility_spec()
{
    ::optimization_guide::proto::EligibilitySpec* _msg = _internal_mutable_eligibility_spec();
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.VisualSearchModelMetadata.eligibility_spec)
    return _msg;
}
inline void VisualSearchModelMetadata::set_allocated_eligibility_spec(::optimization_guide::proto::EligibilitySpec* eligibility_spec)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.eligibility_spec_;
    }
    if (eligibility_spec) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(eligibility_spec);
        if (message_arena != submessage_arena) {
            eligibility_spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, eligibility_spec, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.eligibility_spec_ = eligibility_spec;
    // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.VisualSearchModelMetadata.eligibility_spec)
}

// optional int64 metadata_version = 2;
inline bool VisualSearchModelMetadata::_internal_has_metadata_version() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool VisualSearchModelMetadata::has_metadata_version() const
{
    return _internal_has_metadata_version();
}
inline void VisualSearchModelMetadata::clear_metadata_version()
{
    _impl_.metadata_version_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t VisualSearchModelMetadata::_internal_metadata_version() const
{
    return _impl_.metadata_version_;
}
inline int64_t VisualSearchModelMetadata::metadata_version() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.VisualSearchModelMetadata.metadata_version)
    return _internal_metadata_version();
}
inline void VisualSearchModelMetadata::_internal_set_metadata_version(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.metadata_version_ = value;
}
inline void VisualSearchModelMetadata::set_metadata_version(int64_t value)
{
    _internal_set_metadata_version(value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.VisualSearchModelMetadata.metadata_version)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// @@protoc_insertion_point(namespace_scope)

} // namespace proto
} // namespace optimization_guide

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum<::optimization_guide::proto::FeatureLibrary_ImageLevelFeatureName> : ::std::true_type { };
template <> struct is_proto_enum<::optimization_guide::proto::FeatureLibrary_NormalizingOp> : ::std::true_type { };
template <> struct is_proto_enum<::optimization_guide::proto::FeatureLibrary_ThresholdingOp> : ::std::true_type { };
template <> struct is_proto_enum<::optimization_guide::proto::FeatureLibrary_SortingOrder> : ::std::true_type { };

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_components_2foptimization_5fguide_2fproto_2fvisual_5fsearch_5fmodel_5fmetadata_2eproto
