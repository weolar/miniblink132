// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/optimization_guide/proto/substitution.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_components_2foptimization_5fguide_2fproto_2fsubstitution_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_components_2foptimization_5fguide_2fproto_2fsubstitution_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h> // IWYU pragma: export
#include <google/protobuf/extension_set.h> // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
#include "components/optimization_guide/proto/descriptors.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_components_2foptimization_5fguide_2fproto_2fsubstitution_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
} // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_components_2foptimization_5fguide_2fproto_2fsubstitution_2eproto {
    static const uint32_t offsets[];
};
namespace optimization_guide {
namespace proto {
class Condition;
struct ConditionDefaultTypeInternal;
extern ConditionDefaultTypeInternal _Condition_default_instance_;
class ConditionList;
struct ConditionListDefaultTypeInternal;
extern ConditionListDefaultTypeInternal _ConditionList_default_instance_;
class IndexExpr;
struct IndexExprDefaultTypeInternal;
extern IndexExprDefaultTypeInternal _IndexExpr_default_instance_;
class RangeExpr;
struct RangeExprDefaultTypeInternal;
extern RangeExprDefaultTypeInternal _RangeExpr_default_instance_;
class StringArg;
struct StringArgDefaultTypeInternal;
extern StringArgDefaultTypeInternal _StringArg_default_instance_;
class StringSubstitution;
struct StringSubstitutionDefaultTypeInternal;
extern StringSubstitutionDefaultTypeInternal _StringSubstitution_default_instance_;
class SubstitutedString;
struct SubstitutedStringDefaultTypeInternal;
extern SubstitutedStringDefaultTypeInternal _SubstitutedString_default_instance_;
} // namespace proto
} // namespace optimization_guide
PROTOBUF_NAMESPACE_OPEN
template <>::optimization_guide::proto::Condition* Arena::CreateMaybeMessage<::optimization_guide::proto::Condition>(Arena*);
template <>::optimization_guide::proto::ConditionList* Arena::CreateMaybeMessage<::optimization_guide::proto::ConditionList>(Arena*);
template <>::optimization_guide::proto::IndexExpr* Arena::CreateMaybeMessage<::optimization_guide::proto::IndexExpr>(Arena*);
template <>::optimization_guide::proto::RangeExpr* Arena::CreateMaybeMessage<::optimization_guide::proto::RangeExpr>(Arena*);
template <>::optimization_guide::proto::StringArg* Arena::CreateMaybeMessage<::optimization_guide::proto::StringArg>(Arena*);
template <>::optimization_guide::proto::StringSubstitution* Arena::CreateMaybeMessage<::optimization_guide::proto::StringSubstitution>(Arena*);
template <>::optimization_guide::proto::SubstitutedString* Arena::CreateMaybeMessage<::optimization_guide::proto::SubstitutedString>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace optimization_guide {
namespace proto {

enum ControlToken : int {
    CONTROL_TOKEN_UNKNOWN = 0,
    CONTROL_TOKEN_SYSTEM = 1,
    CONTROL_TOKEN_MODEL = 2,
    CONTROL_TOKEN_USER = 3,
    CONTROL_TOKEN_END = 4,
    ControlToken_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
    ControlToken_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ControlToken_IsValid(int value);
constexpr ControlToken ControlToken_MIN = CONTROL_TOKEN_UNKNOWN;
constexpr ControlToken ControlToken_MAX = CONTROL_TOKEN_END;
constexpr int ControlToken_ARRAYSIZE = ControlToken_MAX + 1;

const std::string& ControlToken_Name(ControlToken value);
template <typename T> inline const std::string& ControlToken_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, ControlToken>::value || ::std::is_integral<T>::value, "Incorrect type passed to function ControlToken_Name.");
    return ControlToken_Name(static_cast<ControlToken>(enum_t_value));
}
bool ControlToken_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ControlToken* value);
enum OperatorType : int {
    OPERATOR_TYPE_UNSPECIFIED = 0,
    OPERATOR_TYPE_EQUAL_TO = 1,
    OPERATOR_TYPE_NOT_EQUAL_TO = 2,
    OperatorType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
    OperatorType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool OperatorType_IsValid(int value);
constexpr OperatorType OperatorType_MIN = OPERATOR_TYPE_UNSPECIFIED;
constexpr OperatorType OperatorType_MAX = OPERATOR_TYPE_NOT_EQUAL_TO;
constexpr int OperatorType_ARRAYSIZE = OperatorType_MAX + 1;

const std::string& OperatorType_Name(OperatorType value);
template <typename T> inline const std::string& OperatorType_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, OperatorType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function OperatorType_Name.");
    return OperatorType_Name(static_cast<OperatorType>(enum_t_value));
}
bool OperatorType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OperatorType* value);
enum ConditionEvaluationType : int {
    CONDITION_EVALUATION_TYPE_UNSPECIFIED = 0,
    CONDITION_EVALUATION_TYPE_AND = 1,
    CONDITION_EVALUATION_TYPE_OR = 2,
    ConditionEvaluationType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
    ConditionEvaluationType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ConditionEvaluationType_IsValid(int value);
constexpr ConditionEvaluationType ConditionEvaluationType_MIN = CONDITION_EVALUATION_TYPE_UNSPECIFIED;
constexpr ConditionEvaluationType ConditionEvaluationType_MAX = CONDITION_EVALUATION_TYPE_OR;
constexpr int ConditionEvaluationType_ARRAYSIZE = ConditionEvaluationType_MAX + 1;

const std::string& ConditionEvaluationType_Name(ConditionEvaluationType value);
template <typename T> inline const std::string& ConditionEvaluationType_Name(T enum_t_value)
{
    static_assert(
        ::std::is_same<T, ConditionEvaluationType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function ConditionEvaluationType_Name.");
    return ConditionEvaluationType_Name(static_cast<ConditionEvaluationType>(enum_t_value));
}
bool ConditionEvaluationType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ConditionEvaluationType* value);
// ===================================================================

class SubstitutedString final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.SubstitutedString) */ {
public:
    inline SubstitutedString()
        : SubstitutedString(nullptr)
    {
    }
    ~SubstitutedString() override;
    explicit PROTOBUF_CONSTEXPR SubstitutedString(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    SubstitutedString(const SubstitutedString& from);
    SubstitutedString(SubstitutedString&& from) noexcept
        : SubstitutedString()
    {
        *this = ::std::move(from);
    }

    inline SubstitutedString& operator=(const SubstitutedString& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline SubstitutedString& operator=(SubstitutedString&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const SubstitutedString& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const SubstitutedString* internal_default_instance()
    {
        return reinterpret_cast<const SubstitutedString*>(&_SubstitutedString_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 0;

    friend void swap(SubstitutedString& a, SubstitutedString& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(SubstitutedString* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(SubstitutedString* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    SubstitutedString* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<SubstitutedString>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const SubstitutedString& from);
    void MergeFrom(const SubstitutedString& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(SubstitutedString* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "optimization_guide.proto.SubstitutedString";
    }

protected:
    explicit SubstitutedString(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kSubstitutionsFieldNumber = 6,
        kStringTemplateFieldNumber = 1,
        kConditionsFieldNumber = 4,
        kShouldIgnoreInputContextFieldNumber = 5,
    };
    // repeated .optimization_guide.proto.StringSubstitution substitutions = 6;
    int substitutions_size() const;

private:
    int _internal_substitutions_size() const;

public:
    void clear_substitutions();
    ::optimization_guide::proto::StringSubstitution* mutable_substitutions(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::StringSubstitution>* mutable_substitutions();

private:
    const ::optimization_guide::proto::StringSubstitution& _internal_substitutions(int index) const;
    ::optimization_guide::proto::StringSubstitution* _internal_add_substitutions();

public:
    const ::optimization_guide::proto::StringSubstitution& substitutions(int index) const;
    ::optimization_guide::proto::StringSubstitution* add_substitutions();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::StringSubstitution>& substitutions() const;

    // string string_template = 1;
    void clear_string_template();
    const std::string& string_template() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_string_template(ArgT0&& arg0, ArgT... args);
    std::string* mutable_string_template();
    PROTOBUF_NODISCARD std::string* release_string_template();
    void set_allocated_string_template(std::string* string_template);

private:
    const std::string& _internal_string_template() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_string_template(const std::string& value);
    std::string* _internal_mutable_string_template();

public:
    // .optimization_guide.proto.ConditionList conditions = 4;
    bool has_conditions() const;

private:
    bool _internal_has_conditions() const;

public:
    void clear_conditions();
    const ::optimization_guide::proto::ConditionList& conditions() const;
    PROTOBUF_NODISCARD ::optimization_guide::proto::ConditionList* release_conditions();
    ::optimization_guide::proto::ConditionList* mutable_conditions();
    void set_allocated_conditions(::optimization_guide::proto::ConditionList* conditions);

private:
    const ::optimization_guide::proto::ConditionList& _internal_conditions() const;
    ::optimization_guide::proto::ConditionList* _internal_mutable_conditions();

public:
    void unsafe_arena_set_allocated_conditions(::optimization_guide::proto::ConditionList* conditions);
    ::optimization_guide::proto::ConditionList* unsafe_arena_release_conditions();

    // bool should_ignore_input_context = 5;
    void clear_should_ignore_input_context();
    bool should_ignore_input_context() const;
    void set_should_ignore_input_context(bool value);

private:
    bool _internal_should_ignore_input_context() const;
    void _internal_set_should_ignore_input_context(bool value);

public:
    // @@protoc_insertion_point(class_scope:optimization_guide.proto.SubstitutedString)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::StringSubstitution> substitutions_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr string_template_;
        ::optimization_guide::proto::ConditionList* conditions_;
        bool should_ignore_input_context_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2foptimization_5fguide_2fproto_2fsubstitution_2eproto;
};
// -------------------------------------------------------------------

class StringSubstitution final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.StringSubstitution) */ {
public:
    inline StringSubstitution()
        : StringSubstitution(nullptr)
    {
    }
    ~StringSubstitution() override;
    explicit PROTOBUF_CONSTEXPR StringSubstitution(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    StringSubstitution(const StringSubstitution& from);
    StringSubstitution(StringSubstitution&& from) noexcept
        : StringSubstitution()
    {
        *this = ::std::move(from);
    }

    inline StringSubstitution& operator=(const StringSubstitution& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline StringSubstitution& operator=(StringSubstitution&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const StringSubstitution& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const StringSubstitution* internal_default_instance()
    {
        return reinterpret_cast<const StringSubstitution*>(&_StringSubstitution_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 1;

    friend void swap(StringSubstitution& a, StringSubstitution& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(StringSubstitution* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(StringSubstitution* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    StringSubstitution* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<StringSubstitution>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const StringSubstitution& from);
    void MergeFrom(const StringSubstitution& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(StringSubstitution* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "optimization_guide.proto.StringSubstitution";
    }

protected:
    explicit StringSubstitution(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kCandidatesFieldNumber = 1,
    };
    // repeated .optimization_guide.proto.StringArg candidates = 1;
    int candidates_size() const;

private:
    int _internal_candidates_size() const;

public:
    void clear_candidates();
    ::optimization_guide::proto::StringArg* mutable_candidates(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::StringArg>* mutable_candidates();

private:
    const ::optimization_guide::proto::StringArg& _internal_candidates(int index) const;
    ::optimization_guide::proto::StringArg* _internal_add_candidates();

public:
    const ::optimization_guide::proto::StringArg& candidates(int index) const;
    ::optimization_guide::proto::StringArg* add_candidates();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::StringArg>& candidates() const;

    // @@protoc_insertion_point(class_scope:optimization_guide.proto.StringSubstitution)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::StringArg> candidates_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2foptimization_5fguide_2fproto_2fsubstitution_2eproto;
};
// -------------------------------------------------------------------

class RangeExpr final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.RangeExpr) */ {
public:
    inline RangeExpr()
        : RangeExpr(nullptr)
    {
    }
    ~RangeExpr() override;
    explicit PROTOBUF_CONSTEXPR RangeExpr(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    RangeExpr(const RangeExpr& from);
    RangeExpr(RangeExpr&& from) noexcept
        : RangeExpr()
    {
        *this = ::std::move(from);
    }

    inline RangeExpr& operator=(const RangeExpr& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline RangeExpr& operator=(RangeExpr&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const RangeExpr& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const RangeExpr* internal_default_instance()
    {
        return reinterpret_cast<const RangeExpr*>(&_RangeExpr_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 2;

    friend void swap(RangeExpr& a, RangeExpr& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(RangeExpr* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(RangeExpr* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    RangeExpr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<RangeExpr>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const RangeExpr& from);
    void MergeFrom(const RangeExpr& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(RangeExpr* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "optimization_guide.proto.RangeExpr";
    }

protected:
    explicit RangeExpr(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kProtoFieldFieldNumber = 1,
        kExprFieldNumber = 2,
    };
    // .optimization_guide.proto.ProtoField proto_field = 1;
    bool has_proto_field() const;

private:
    bool _internal_has_proto_field() const;

public:
    void clear_proto_field();
    const ::optimization_guide::proto::ProtoField& proto_field() const;
    PROTOBUF_NODISCARD ::optimization_guide::proto::ProtoField* release_proto_field();
    ::optimization_guide::proto::ProtoField* mutable_proto_field();
    void set_allocated_proto_field(::optimization_guide::proto::ProtoField* proto_field);

private:
    const ::optimization_guide::proto::ProtoField& _internal_proto_field() const;
    ::optimization_guide::proto::ProtoField* _internal_mutable_proto_field();

public:
    void unsafe_arena_set_allocated_proto_field(::optimization_guide::proto::ProtoField* proto_field);
    ::optimization_guide::proto::ProtoField* unsafe_arena_release_proto_field();

    // .optimization_guide.proto.SubstitutedString expr = 2;
    bool has_expr() const;

private:
    bool _internal_has_expr() const;

public:
    void clear_expr();
    const ::optimization_guide::proto::SubstitutedString& expr() const;
    PROTOBUF_NODISCARD ::optimization_guide::proto::SubstitutedString* release_expr();
    ::optimization_guide::proto::SubstitutedString* mutable_expr();
    void set_allocated_expr(::optimization_guide::proto::SubstitutedString* expr);

private:
    const ::optimization_guide::proto::SubstitutedString& _internal_expr() const;
    ::optimization_guide::proto::SubstitutedString* _internal_mutable_expr();

public:
    void unsafe_arena_set_allocated_expr(::optimization_guide::proto::SubstitutedString* expr);
    ::optimization_guide::proto::SubstitutedString* unsafe_arena_release_expr();

    // @@protoc_insertion_point(class_scope:optimization_guide.proto.RangeExpr)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::optimization_guide::proto::ProtoField* proto_field_;
        ::optimization_guide::proto::SubstitutedString* expr_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2foptimization_5fguide_2fproto_2fsubstitution_2eproto;
};
// -------------------------------------------------------------------

class IndexExpr final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.IndexExpr) */ {
public:
    inline IndexExpr()
        : IndexExpr(nullptr)
    {
    }
    ~IndexExpr() override;
    explicit PROTOBUF_CONSTEXPR IndexExpr(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    IndexExpr(const IndexExpr& from);
    IndexExpr(IndexExpr&& from) noexcept
        : IndexExpr()
    {
        *this = ::std::move(from);
    }

    inline IndexExpr& operator=(const IndexExpr& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline IndexExpr& operator=(IndexExpr&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const IndexExpr& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const IndexExpr* internal_default_instance()
    {
        return reinterpret_cast<const IndexExpr*>(&_IndexExpr_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 3;

    friend void swap(IndexExpr& a, IndexExpr& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(IndexExpr* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(IndexExpr* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    IndexExpr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<IndexExpr>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const IndexExpr& from);
    void MergeFrom(const IndexExpr& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(IndexExpr* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "optimization_guide.proto.IndexExpr";
    }

protected:
    explicit IndexExpr(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kOneBasedFieldNumber = 1,
    };
    // bool one_based = 1;
    void clear_one_based();
    bool one_based() const;
    void set_one_based(bool value);

private:
    bool _internal_one_based() const;
    void _internal_set_one_based(bool value);

public:
    // @@protoc_insertion_point(class_scope:optimization_guide.proto.IndexExpr)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        bool one_based_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2foptimization_5fguide_2fproto_2fsubstitution_2eproto;
};
// -------------------------------------------------------------------

class StringArg final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.StringArg) */ {
public:
    inline StringArg()
        : StringArg(nullptr)
    {
    }
    ~StringArg() override;
    explicit PROTOBUF_CONSTEXPR StringArg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    StringArg(const StringArg& from);
    StringArg(StringArg&& from) noexcept
        : StringArg()
    {
        *this = ::std::move(from);
    }

    inline StringArg& operator=(const StringArg& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline StringArg& operator=(StringArg&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const StringArg& default_instance()
    {
        return *internal_default_instance();
    }
    enum ArgCase {
        kRawString = 1,
        kProtoField = 2,
        kRangeExpr = 4,
        kIndexExpr = 5,
        kControlToken = 6,
        ARG_NOT_SET = 0,
    };

    static inline const StringArg* internal_default_instance()
    {
        return reinterpret_cast<const StringArg*>(&_StringArg_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 4;

    friend void swap(StringArg& a, StringArg& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(StringArg* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(StringArg* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    StringArg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<StringArg>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const StringArg& from);
    void MergeFrom(const StringArg& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(StringArg* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "optimization_guide.proto.StringArg";
    }

protected:
    explicit StringArg(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kConditionsFieldNumber = 3,
        kRawStringFieldNumber = 1,
        kProtoFieldFieldNumber = 2,
        kRangeExprFieldNumber = 4,
        kIndexExprFieldNumber = 5,
        kControlTokenFieldNumber = 6,
    };
    // .optimization_guide.proto.ConditionList conditions = 3;
    bool has_conditions() const;

private:
    bool _internal_has_conditions() const;

public:
    void clear_conditions();
    const ::optimization_guide::proto::ConditionList& conditions() const;
    PROTOBUF_NODISCARD ::optimization_guide::proto::ConditionList* release_conditions();
    ::optimization_guide::proto::ConditionList* mutable_conditions();
    void set_allocated_conditions(::optimization_guide::proto::ConditionList* conditions);

private:
    const ::optimization_guide::proto::ConditionList& _internal_conditions() const;
    ::optimization_guide::proto::ConditionList* _internal_mutable_conditions();

public:
    void unsafe_arena_set_allocated_conditions(::optimization_guide::proto::ConditionList* conditions);
    ::optimization_guide::proto::ConditionList* unsafe_arena_release_conditions();

    // string raw_string = 1;
    bool has_raw_string() const;

private:
    bool _internal_has_raw_string() const;

public:
    void clear_raw_string();
    const std::string& raw_string() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_raw_string(ArgT0&& arg0, ArgT... args);
    std::string* mutable_raw_string();
    PROTOBUF_NODISCARD std::string* release_raw_string();
    void set_allocated_raw_string(std::string* raw_string);

private:
    const std::string& _internal_raw_string() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_raw_string(const std::string& value);
    std::string* _internal_mutable_raw_string();

public:
    // .optimization_guide.proto.ProtoField proto_field = 2;
    bool has_proto_field() const;

private:
    bool _internal_has_proto_field() const;

public:
    void clear_proto_field();
    const ::optimization_guide::proto::ProtoField& proto_field() const;
    PROTOBUF_NODISCARD ::optimization_guide::proto::ProtoField* release_proto_field();
    ::optimization_guide::proto::ProtoField* mutable_proto_field();
    void set_allocated_proto_field(::optimization_guide::proto::ProtoField* proto_field);

private:
    const ::optimization_guide::proto::ProtoField& _internal_proto_field() const;
    ::optimization_guide::proto::ProtoField* _internal_mutable_proto_field();

public:
    void unsafe_arena_set_allocated_proto_field(::optimization_guide::proto::ProtoField* proto_field);
    ::optimization_guide::proto::ProtoField* unsafe_arena_release_proto_field();

    // .optimization_guide.proto.RangeExpr range_expr = 4;
    bool has_range_expr() const;

private:
    bool _internal_has_range_expr() const;

public:
    void clear_range_expr();
    const ::optimization_guide::proto::RangeExpr& range_expr() const;
    PROTOBUF_NODISCARD ::optimization_guide::proto::RangeExpr* release_range_expr();
    ::optimization_guide::proto::RangeExpr* mutable_range_expr();
    void set_allocated_range_expr(::optimization_guide::proto::RangeExpr* range_expr);

private:
    const ::optimization_guide::proto::RangeExpr& _internal_range_expr() const;
    ::optimization_guide::proto::RangeExpr* _internal_mutable_range_expr();

public:
    void unsafe_arena_set_allocated_range_expr(::optimization_guide::proto::RangeExpr* range_expr);
    ::optimization_guide::proto::RangeExpr* unsafe_arena_release_range_expr();

    // .optimization_guide.proto.IndexExpr index_expr = 5;
    bool has_index_expr() const;

private:
    bool _internal_has_index_expr() const;

public:
    void clear_index_expr();
    const ::optimization_guide::proto::IndexExpr& index_expr() const;
    PROTOBUF_NODISCARD ::optimization_guide::proto::IndexExpr* release_index_expr();
    ::optimization_guide::proto::IndexExpr* mutable_index_expr();
    void set_allocated_index_expr(::optimization_guide::proto::IndexExpr* index_expr);

private:
    const ::optimization_guide::proto::IndexExpr& _internal_index_expr() const;
    ::optimization_guide::proto::IndexExpr* _internal_mutable_index_expr();

public:
    void unsafe_arena_set_allocated_index_expr(::optimization_guide::proto::IndexExpr* index_expr);
    ::optimization_guide::proto::IndexExpr* unsafe_arena_release_index_expr();

    // .optimization_guide.proto.ControlToken control_token = 6;
    bool has_control_token() const;

private:
    bool _internal_has_control_token() const;

public:
    void clear_control_token();
    ::optimization_guide::proto::ControlToken control_token() const;
    void set_control_token(::optimization_guide::proto::ControlToken value);

private:
    ::optimization_guide::proto::ControlToken _internal_control_token() const;
    void _internal_set_control_token(::optimization_guide::proto::ControlToken value);

public:
    void clear_arg();
    ArgCase arg_case() const;
    // @@protoc_insertion_point(class_scope:optimization_guide.proto.StringArg)
private:
    class _Internal;
    void set_has_raw_string();
    void set_has_proto_field();
    void set_has_range_expr();
    void set_has_index_expr();
    void set_has_control_token();

    inline bool has_arg() const;
    inline void clear_has_arg();

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::optimization_guide::proto::ConditionList* conditions_;
        union ArgUnion {
            constexpr ArgUnion()
                : _constinit_ {}
            {
            }
            ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
            ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr raw_string_;
            ::optimization_guide::proto::ProtoField* proto_field_;
            ::optimization_guide::proto::RangeExpr* range_expr_;
            ::optimization_guide::proto::IndexExpr* index_expr_;
            int control_token_;
        } arg_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        uint32_t _oneof_case_[1];
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2foptimization_5fguide_2fproto_2fsubstitution_2eproto;
};
// -------------------------------------------------------------------

class ConditionList final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.ConditionList) */ {
public:
    inline ConditionList()
        : ConditionList(nullptr)
    {
    }
    ~ConditionList() override;
    explicit PROTOBUF_CONSTEXPR ConditionList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ConditionList(const ConditionList& from);
    ConditionList(ConditionList&& from) noexcept
        : ConditionList()
    {
        *this = ::std::move(from);
    }

    inline ConditionList& operator=(const ConditionList& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ConditionList& operator=(ConditionList&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const ConditionList& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ConditionList* internal_default_instance()
    {
        return reinterpret_cast<const ConditionList*>(&_ConditionList_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 5;

    friend void swap(ConditionList& a, ConditionList& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ConditionList* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ConditionList* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ConditionList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ConditionList>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ConditionList& from);
    void MergeFrom(const ConditionList& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ConditionList* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "optimization_guide.proto.ConditionList";
    }

protected:
    explicit ConditionList(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kConditionsFieldNumber = 2,
        kConditionEvaluationTypeFieldNumber = 1,
    };
    // repeated .optimization_guide.proto.Condition conditions = 2;
    int conditions_size() const;

private:
    int _internal_conditions_size() const;

public:
    void clear_conditions();
    ::optimization_guide::proto::Condition* mutable_conditions(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::Condition>* mutable_conditions();

private:
    const ::optimization_guide::proto::Condition& _internal_conditions(int index) const;
    ::optimization_guide::proto::Condition* _internal_add_conditions();

public:
    const ::optimization_guide::proto::Condition& conditions(int index) const;
    ::optimization_guide::proto::Condition* add_conditions();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::Condition>& conditions() const;

    // .optimization_guide.proto.ConditionEvaluationType condition_evaluation_type = 1;
    void clear_condition_evaluation_type();
    ::optimization_guide::proto::ConditionEvaluationType condition_evaluation_type() const;
    void set_condition_evaluation_type(::optimization_guide::proto::ConditionEvaluationType value);

private:
    ::optimization_guide::proto::ConditionEvaluationType _internal_condition_evaluation_type() const;
    void _internal_set_condition_evaluation_type(::optimization_guide::proto::ConditionEvaluationType value);

public:
    // @@protoc_insertion_point(class_scope:optimization_guide.proto.ConditionList)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::Condition> conditions_;
        int condition_evaluation_type_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2foptimization_5fguide_2fproto_2fsubstitution_2eproto;
};
// -------------------------------------------------------------------

class Condition final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.Condition) */ {
public:
    inline Condition()
        : Condition(nullptr)
    {
    }
    ~Condition() override;
    explicit PROTOBUF_CONSTEXPR Condition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    Condition(const Condition& from);
    Condition(Condition&& from) noexcept
        : Condition()
    {
        *this = ::std::move(from);
    }

    inline Condition& operator=(const Condition& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline Condition& operator=(Condition&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const Condition& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const Condition* internal_default_instance()
    {
        return reinterpret_cast<const Condition*>(&_Condition_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 6;

    friend void swap(Condition& a, Condition& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(Condition* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(Condition* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    Condition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<Condition>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const Condition& from);
    void MergeFrom(const Condition& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(Condition* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "optimization_guide.proto.Condition";
    }

protected:
    explicit Condition(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kProtoFieldFieldNumber = 1,
        kValueFieldNumber = 3,
        kOperatorTypeFieldNumber = 2,
    };
    // .optimization_guide.proto.ProtoField proto_field = 1;
    bool has_proto_field() const;

private:
    bool _internal_has_proto_field() const;

public:
    void clear_proto_field();
    const ::optimization_guide::proto::ProtoField& proto_field() const;
    PROTOBUF_NODISCARD ::optimization_guide::proto::ProtoField* release_proto_field();
    ::optimization_guide::proto::ProtoField* mutable_proto_field();
    void set_allocated_proto_field(::optimization_guide::proto::ProtoField* proto_field);

private:
    const ::optimization_guide::proto::ProtoField& _internal_proto_field() const;
    ::optimization_guide::proto::ProtoField* _internal_mutable_proto_field();

public:
    void unsafe_arena_set_allocated_proto_field(::optimization_guide::proto::ProtoField* proto_field);
    ::optimization_guide::proto::ProtoField* unsafe_arena_release_proto_field();

    // .optimization_guide.proto.Value value = 3;
    bool has_value() const;

private:
    bool _internal_has_value() const;

public:
    void clear_value();
    const ::optimization_guide::proto::Value& value() const;
    PROTOBUF_NODISCARD ::optimization_guide::proto::Value* release_value();
    ::optimization_guide::proto::Value* mutable_value();
    void set_allocated_value(::optimization_guide::proto::Value* value);

private:
    const ::optimization_guide::proto::Value& _internal_value() const;
    ::optimization_guide::proto::Value* _internal_mutable_value();

public:
    void unsafe_arena_set_allocated_value(::optimization_guide::proto::Value* value);
    ::optimization_guide::proto::Value* unsafe_arena_release_value();

    // .optimization_guide.proto.OperatorType operator_type = 2;
    void clear_operator_type();
    ::optimization_guide::proto::OperatorType operator_type() const;
    void set_operator_type(::optimization_guide::proto::OperatorType value);

private:
    ::optimization_guide::proto::OperatorType _internal_operator_type() const;
    void _internal_set_operator_type(::optimization_guide::proto::OperatorType value);

public:
    // @@protoc_insertion_point(class_scope:optimization_guide.proto.Condition)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::optimization_guide::proto::ProtoField* proto_field_;
        ::optimization_guide::proto::Value* value_;
        int operator_type_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2foptimization_5fguide_2fproto_2fsubstitution_2eproto;
};
// ===================================================================

// ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif // __GNUC__
// SubstitutedString

// string string_template = 1;
inline void SubstitutedString::clear_string_template()
{
    _impl_.string_template_.ClearToEmpty();
}
inline const std::string& SubstitutedString::string_template() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.SubstitutedString.string_template)
    return _internal_string_template();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void SubstitutedString::set_string_template(ArgT0&& arg0, ArgT... args)
{

    _impl_.string_template_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:optimization_guide.proto.SubstitutedString.string_template)
}
inline std::string* SubstitutedString::mutable_string_template()
{
    std::string* _s = _internal_mutable_string_template();
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.SubstitutedString.string_template)
    return _s;
}
inline const std::string& SubstitutedString::_internal_string_template() const
{
    return _impl_.string_template_.Get();
}
inline void SubstitutedString::_internal_set_string_template(const std::string& value)
{

    _impl_.string_template_.Set(value, GetArenaForAllocation());
}
inline std::string* SubstitutedString::_internal_mutable_string_template()
{

    return _impl_.string_template_.Mutable(GetArenaForAllocation());
}
inline std::string* SubstitutedString::release_string_template()
{
    // @@protoc_insertion_point(field_release:optimization_guide.proto.SubstitutedString.string_template)
    return _impl_.string_template_.Release();
}
inline void SubstitutedString::set_allocated_string_template(std::string* string_template)
{
    if (string_template != nullptr) {

    } else {
    }
    _impl_.string_template_.SetAllocated(string_template, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.string_template_.IsDefault()) {
        _impl_.string_template_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.SubstitutedString.string_template)
}

// repeated .optimization_guide.proto.StringSubstitution substitutions = 6;
inline int SubstitutedString::_internal_substitutions_size() const
{
    return _impl_.substitutions_.size();
}
inline int SubstitutedString::substitutions_size() const
{
    return _internal_substitutions_size();
}
inline void SubstitutedString::clear_substitutions()
{
    _impl_.substitutions_.Clear();
}
inline ::optimization_guide::proto::StringSubstitution* SubstitutedString::mutable_substitutions(int index)
{
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.SubstitutedString.substitutions)
    return _impl_.substitutions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::StringSubstitution>* SubstitutedString::mutable_substitutions()
{
    // @@protoc_insertion_point(field_mutable_list:optimization_guide.proto.SubstitutedString.substitutions)
    return &_impl_.substitutions_;
}
inline const ::optimization_guide::proto::StringSubstitution& SubstitutedString::_internal_substitutions(int index) const
{
    return _impl_.substitutions_.Get(index);
}
inline const ::optimization_guide::proto::StringSubstitution& SubstitutedString::substitutions(int index) const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.SubstitutedString.substitutions)
    return _internal_substitutions(index);
}
inline ::optimization_guide::proto::StringSubstitution* SubstitutedString::_internal_add_substitutions()
{
    return _impl_.substitutions_.Add();
}
inline ::optimization_guide::proto::StringSubstitution* SubstitutedString::add_substitutions()
{
    ::optimization_guide::proto::StringSubstitution* _add = _internal_add_substitutions();
    // @@protoc_insertion_point(field_add:optimization_guide.proto.SubstitutedString.substitutions)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::StringSubstitution>& SubstitutedString::substitutions() const
{
    // @@protoc_insertion_point(field_list:optimization_guide.proto.SubstitutedString.substitutions)
    return _impl_.substitutions_;
}

// .optimization_guide.proto.ConditionList conditions = 4;
inline bool SubstitutedString::_internal_has_conditions() const
{
    return this != internal_default_instance() && _impl_.conditions_ != nullptr;
}
inline bool SubstitutedString::has_conditions() const
{
    return _internal_has_conditions();
}
inline void SubstitutedString::clear_conditions()
{
    if (GetArenaForAllocation() == nullptr && _impl_.conditions_ != nullptr) {
        delete _impl_.conditions_;
    }
    _impl_.conditions_ = nullptr;
}
inline const ::optimization_guide::proto::ConditionList& SubstitutedString::_internal_conditions() const
{
    const ::optimization_guide::proto::ConditionList* p = _impl_.conditions_;
    return p != nullptr ? *p
                        : reinterpret_cast<const ::optimization_guide::proto::ConditionList&>(::optimization_guide::proto::_ConditionList_default_instance_);
}
inline const ::optimization_guide::proto::ConditionList& SubstitutedString::conditions() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.SubstitutedString.conditions)
    return _internal_conditions();
}
inline void SubstitutedString::unsafe_arena_set_allocated_conditions(::optimization_guide::proto::ConditionList* conditions)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.conditions_);
    }
    _impl_.conditions_ = conditions;
    if (conditions) {

    } else {
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:optimization_guide.proto.SubstitutedString.conditions)
}
inline ::optimization_guide::proto::ConditionList* SubstitutedString::release_conditions()
{

    ::optimization_guide::proto::ConditionList* temp = _impl_.conditions_;
    _impl_.conditions_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::optimization_guide::proto::ConditionList* SubstitutedString::unsafe_arena_release_conditions()
{
    // @@protoc_insertion_point(field_release:optimization_guide.proto.SubstitutedString.conditions)

    ::optimization_guide::proto::ConditionList* temp = _impl_.conditions_;
    _impl_.conditions_ = nullptr;
    return temp;
}
inline ::optimization_guide::proto::ConditionList* SubstitutedString::_internal_mutable_conditions()
{

    if (_impl_.conditions_ == nullptr) {
        auto* p = CreateMaybeMessage<::optimization_guide::proto::ConditionList>(GetArenaForAllocation());
        _impl_.conditions_ = p;
    }
    return _impl_.conditions_;
}
inline ::optimization_guide::proto::ConditionList* SubstitutedString::mutable_conditions()
{
    ::optimization_guide::proto::ConditionList* _msg = _internal_mutable_conditions();
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.SubstitutedString.conditions)
    return _msg;
}
inline void SubstitutedString::set_allocated_conditions(::optimization_guide::proto::ConditionList* conditions)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.conditions_;
    }
    if (conditions) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(conditions);
        if (message_arena != submessage_arena) {
            conditions = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, conditions, submessage_arena);
        }

    } else {
    }
    _impl_.conditions_ = conditions;
    // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.SubstitutedString.conditions)
}

// bool should_ignore_input_context = 5;
inline void SubstitutedString::clear_should_ignore_input_context()
{
    _impl_.should_ignore_input_context_ = false;
}
inline bool SubstitutedString::_internal_should_ignore_input_context() const
{
    return _impl_.should_ignore_input_context_;
}
inline bool SubstitutedString::should_ignore_input_context() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.SubstitutedString.should_ignore_input_context)
    return _internal_should_ignore_input_context();
}
inline void SubstitutedString::_internal_set_should_ignore_input_context(bool value)
{

    _impl_.should_ignore_input_context_ = value;
}
inline void SubstitutedString::set_should_ignore_input_context(bool value)
{
    _internal_set_should_ignore_input_context(value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.SubstitutedString.should_ignore_input_context)
}

// -------------------------------------------------------------------

// StringSubstitution

// repeated .optimization_guide.proto.StringArg candidates = 1;
inline int StringSubstitution::_internal_candidates_size() const
{
    return _impl_.candidates_.size();
}
inline int StringSubstitution::candidates_size() const
{
    return _internal_candidates_size();
}
inline void StringSubstitution::clear_candidates()
{
    _impl_.candidates_.Clear();
}
inline ::optimization_guide::proto::StringArg* StringSubstitution::mutable_candidates(int index)
{
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.StringSubstitution.candidates)
    return _impl_.candidates_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::StringArg>* StringSubstitution::mutable_candidates()
{
    // @@protoc_insertion_point(field_mutable_list:optimization_guide.proto.StringSubstitution.candidates)
    return &_impl_.candidates_;
}
inline const ::optimization_guide::proto::StringArg& StringSubstitution::_internal_candidates(int index) const
{
    return _impl_.candidates_.Get(index);
}
inline const ::optimization_guide::proto::StringArg& StringSubstitution::candidates(int index) const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.StringSubstitution.candidates)
    return _internal_candidates(index);
}
inline ::optimization_guide::proto::StringArg* StringSubstitution::_internal_add_candidates()
{
    return _impl_.candidates_.Add();
}
inline ::optimization_guide::proto::StringArg* StringSubstitution::add_candidates()
{
    ::optimization_guide::proto::StringArg* _add = _internal_add_candidates();
    // @@protoc_insertion_point(field_add:optimization_guide.proto.StringSubstitution.candidates)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::StringArg>& StringSubstitution::candidates() const
{
    // @@protoc_insertion_point(field_list:optimization_guide.proto.StringSubstitution.candidates)
    return _impl_.candidates_;
}

// -------------------------------------------------------------------

// RangeExpr

// .optimization_guide.proto.ProtoField proto_field = 1;
inline bool RangeExpr::_internal_has_proto_field() const
{
    return this != internal_default_instance() && _impl_.proto_field_ != nullptr;
}
inline bool RangeExpr::has_proto_field() const
{
    return _internal_has_proto_field();
}
inline const ::optimization_guide::proto::ProtoField& RangeExpr::_internal_proto_field() const
{
    const ::optimization_guide::proto::ProtoField* p = _impl_.proto_field_;
    return p != nullptr ? *p : reinterpret_cast<const ::optimization_guide::proto::ProtoField&>(::optimization_guide::proto::_ProtoField_default_instance_);
}
inline const ::optimization_guide::proto::ProtoField& RangeExpr::proto_field() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.RangeExpr.proto_field)
    return _internal_proto_field();
}
inline void RangeExpr::unsafe_arena_set_allocated_proto_field(::optimization_guide::proto::ProtoField* proto_field)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.proto_field_);
    }
    _impl_.proto_field_ = proto_field;
    if (proto_field) {

    } else {
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:optimization_guide.proto.RangeExpr.proto_field)
}
inline ::optimization_guide::proto::ProtoField* RangeExpr::release_proto_field()
{

    ::optimization_guide::proto::ProtoField* temp = _impl_.proto_field_;
    _impl_.proto_field_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::optimization_guide::proto::ProtoField* RangeExpr::unsafe_arena_release_proto_field()
{
    // @@protoc_insertion_point(field_release:optimization_guide.proto.RangeExpr.proto_field)

    ::optimization_guide::proto::ProtoField* temp = _impl_.proto_field_;
    _impl_.proto_field_ = nullptr;
    return temp;
}
inline ::optimization_guide::proto::ProtoField* RangeExpr::_internal_mutable_proto_field()
{

    if (_impl_.proto_field_ == nullptr) {
        auto* p = CreateMaybeMessage<::optimization_guide::proto::ProtoField>(GetArenaForAllocation());
        _impl_.proto_field_ = p;
    }
    return _impl_.proto_field_;
}
inline ::optimization_guide::proto::ProtoField* RangeExpr::mutable_proto_field()
{
    ::optimization_guide::proto::ProtoField* _msg = _internal_mutable_proto_field();
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.RangeExpr.proto_field)
    return _msg;
}
inline void RangeExpr::set_allocated_proto_field(::optimization_guide::proto::ProtoField* proto_field)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.proto_field_);
    }
    if (proto_field) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena
            = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(proto_field));
        if (message_arena != submessage_arena) {
            proto_field = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, proto_field, submessage_arena);
        }

    } else {
    }
    _impl_.proto_field_ = proto_field;
    // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.RangeExpr.proto_field)
}

// .optimization_guide.proto.SubstitutedString expr = 2;
inline bool RangeExpr::_internal_has_expr() const
{
    return this != internal_default_instance() && _impl_.expr_ != nullptr;
}
inline bool RangeExpr::has_expr() const
{
    return _internal_has_expr();
}
inline void RangeExpr::clear_expr()
{
    if (GetArenaForAllocation() == nullptr && _impl_.expr_ != nullptr) {
        delete _impl_.expr_;
    }
    _impl_.expr_ = nullptr;
}
inline const ::optimization_guide::proto::SubstitutedString& RangeExpr::_internal_expr() const
{
    const ::optimization_guide::proto::SubstitutedString* p = _impl_.expr_;
    return p != nullptr
        ? *p
        : reinterpret_cast<const ::optimization_guide::proto::SubstitutedString&>(::optimization_guide::proto::_SubstitutedString_default_instance_);
}
inline const ::optimization_guide::proto::SubstitutedString& RangeExpr::expr() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.RangeExpr.expr)
    return _internal_expr();
}
inline void RangeExpr::unsafe_arena_set_allocated_expr(::optimization_guide::proto::SubstitutedString* expr)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.expr_);
    }
    _impl_.expr_ = expr;
    if (expr) {

    } else {
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:optimization_guide.proto.RangeExpr.expr)
}
inline ::optimization_guide::proto::SubstitutedString* RangeExpr::release_expr()
{

    ::optimization_guide::proto::SubstitutedString* temp = _impl_.expr_;
    _impl_.expr_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::optimization_guide::proto::SubstitutedString* RangeExpr::unsafe_arena_release_expr()
{
    // @@protoc_insertion_point(field_release:optimization_guide.proto.RangeExpr.expr)

    ::optimization_guide::proto::SubstitutedString* temp = _impl_.expr_;
    _impl_.expr_ = nullptr;
    return temp;
}
inline ::optimization_guide::proto::SubstitutedString* RangeExpr::_internal_mutable_expr()
{

    if (_impl_.expr_ == nullptr) {
        auto* p = CreateMaybeMessage<::optimization_guide::proto::SubstitutedString>(GetArenaForAllocation());
        _impl_.expr_ = p;
    }
    return _impl_.expr_;
}
inline ::optimization_guide::proto::SubstitutedString* RangeExpr::mutable_expr()
{
    ::optimization_guide::proto::SubstitutedString* _msg = _internal_mutable_expr();
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.RangeExpr.expr)
    return _msg;
}
inline void RangeExpr::set_allocated_expr(::optimization_guide::proto::SubstitutedString* expr)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.expr_;
    }
    if (expr) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(expr);
        if (message_arena != submessage_arena) {
            expr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, expr, submessage_arena);
        }

    } else {
    }
    _impl_.expr_ = expr;
    // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.RangeExpr.expr)
}

// -------------------------------------------------------------------

// IndexExpr

// bool one_based = 1;
inline void IndexExpr::clear_one_based()
{
    _impl_.one_based_ = false;
}
inline bool IndexExpr::_internal_one_based() const
{
    return _impl_.one_based_;
}
inline bool IndexExpr::one_based() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.IndexExpr.one_based)
    return _internal_one_based();
}
inline void IndexExpr::_internal_set_one_based(bool value)
{

    _impl_.one_based_ = value;
}
inline void IndexExpr::set_one_based(bool value)
{
    _internal_set_one_based(value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.IndexExpr.one_based)
}

// -------------------------------------------------------------------

// StringArg

// string raw_string = 1;
inline bool StringArg::_internal_has_raw_string() const
{
    return arg_case() == kRawString;
}
inline bool StringArg::has_raw_string() const
{
    return _internal_has_raw_string();
}
inline void StringArg::set_has_raw_string()
{
    _impl_._oneof_case_[0] = kRawString;
}
inline void StringArg::clear_raw_string()
{
    if (_internal_has_raw_string()) {
        _impl_.arg_.raw_string_.Destroy();
        clear_has_arg();
    }
}
inline const std::string& StringArg::raw_string() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.StringArg.raw_string)
    return _internal_raw_string();
}
template <typename ArgT0, typename... ArgT> inline void StringArg::set_raw_string(ArgT0&& arg0, ArgT... args)
{
    if (!_internal_has_raw_string()) {
        clear_arg();
        set_has_raw_string();
        _impl_.arg_.raw_string_.InitDefault();
    }
    _impl_.arg_.raw_string_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:optimization_guide.proto.StringArg.raw_string)
}
inline std::string* StringArg::mutable_raw_string()
{
    std::string* _s = _internal_mutable_raw_string();
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.StringArg.raw_string)
    return _s;
}
inline const std::string& StringArg::_internal_raw_string() const
{
    if (_internal_has_raw_string()) {
        return _impl_.arg_.raw_string_.Get();
    }
    return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void StringArg::_internal_set_raw_string(const std::string& value)
{
    if (!_internal_has_raw_string()) {
        clear_arg();
        set_has_raw_string();
        _impl_.arg_.raw_string_.InitDefault();
    }
    _impl_.arg_.raw_string_.Set(value, GetArenaForAllocation());
}
inline std::string* StringArg::_internal_mutable_raw_string()
{
    if (!_internal_has_raw_string()) {
        clear_arg();
        set_has_raw_string();
        _impl_.arg_.raw_string_.InitDefault();
    }
    return _impl_.arg_.raw_string_.Mutable(GetArenaForAllocation());
}
inline std::string* StringArg::release_raw_string()
{
    // @@protoc_insertion_point(field_release:optimization_guide.proto.StringArg.raw_string)
    if (_internal_has_raw_string()) {
        clear_has_arg();
        return _impl_.arg_.raw_string_.Release();
    } else {
        return nullptr;
    }
}
inline void StringArg::set_allocated_raw_string(std::string* raw_string)
{
    if (has_arg()) {
        clear_arg();
    }
    if (raw_string != nullptr) {
        set_has_raw_string();
        _impl_.arg_.raw_string_.InitAllocated(raw_string, GetArenaForAllocation());
    }
    // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.StringArg.raw_string)
}

// .optimization_guide.proto.ProtoField proto_field = 2;
inline bool StringArg::_internal_has_proto_field() const
{
    return arg_case() == kProtoField;
}
inline bool StringArg::has_proto_field() const
{
    return _internal_has_proto_field();
}
inline void StringArg::set_has_proto_field()
{
    _impl_._oneof_case_[0] = kProtoField;
}
inline ::optimization_guide::proto::ProtoField* StringArg::release_proto_field()
{
    // @@protoc_insertion_point(field_release:optimization_guide.proto.StringArg.proto_field)
    if (_internal_has_proto_field()) {
        clear_has_arg();
        ::optimization_guide::proto::ProtoField* temp = _impl_.arg_.proto_field_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.arg_.proto_field_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::optimization_guide::proto::ProtoField& StringArg::_internal_proto_field() const
{
    return _internal_has_proto_field() ? *_impl_.arg_.proto_field_
                                       : reinterpret_cast<::optimization_guide::proto::ProtoField&>(::optimization_guide::proto::_ProtoField_default_instance_);
}
inline const ::optimization_guide::proto::ProtoField& StringArg::proto_field() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.StringArg.proto_field)
    return _internal_proto_field();
}
inline ::optimization_guide::proto::ProtoField* StringArg::unsafe_arena_release_proto_field()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:optimization_guide.proto.StringArg.proto_field)
    if (_internal_has_proto_field()) {
        clear_has_arg();
        ::optimization_guide::proto::ProtoField* temp = _impl_.arg_.proto_field_;
        _impl_.arg_.proto_field_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void StringArg::unsafe_arena_set_allocated_proto_field(::optimization_guide::proto::ProtoField* proto_field)
{
    clear_arg();
    if (proto_field) {
        set_has_proto_field();
        _impl_.arg_.proto_field_ = proto_field;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:optimization_guide.proto.StringArg.proto_field)
}
inline ::optimization_guide::proto::ProtoField* StringArg::_internal_mutable_proto_field()
{
    if (!_internal_has_proto_field()) {
        clear_arg();
        set_has_proto_field();
        _impl_.arg_.proto_field_ = CreateMaybeMessage<::optimization_guide::proto::ProtoField>(GetArenaForAllocation());
    }
    return _impl_.arg_.proto_field_;
}
inline ::optimization_guide::proto::ProtoField* StringArg::mutable_proto_field()
{
    ::optimization_guide::proto::ProtoField* _msg = _internal_mutable_proto_field();
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.StringArg.proto_field)
    return _msg;
}

// .optimization_guide.proto.RangeExpr range_expr = 4;
inline bool StringArg::_internal_has_range_expr() const
{
    return arg_case() == kRangeExpr;
}
inline bool StringArg::has_range_expr() const
{
    return _internal_has_range_expr();
}
inline void StringArg::set_has_range_expr()
{
    _impl_._oneof_case_[0] = kRangeExpr;
}
inline void StringArg::clear_range_expr()
{
    if (_internal_has_range_expr()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.arg_.range_expr_;
        }
        clear_has_arg();
    }
}
inline ::optimization_guide::proto::RangeExpr* StringArg::release_range_expr()
{
    // @@protoc_insertion_point(field_release:optimization_guide.proto.StringArg.range_expr)
    if (_internal_has_range_expr()) {
        clear_has_arg();
        ::optimization_guide::proto::RangeExpr* temp = _impl_.arg_.range_expr_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.arg_.range_expr_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::optimization_guide::proto::RangeExpr& StringArg::_internal_range_expr() const
{
    return _internal_has_range_expr() ? *_impl_.arg_.range_expr_
                                      : reinterpret_cast<::optimization_guide::proto::RangeExpr&>(::optimization_guide::proto::_RangeExpr_default_instance_);
}
inline const ::optimization_guide::proto::RangeExpr& StringArg::range_expr() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.StringArg.range_expr)
    return _internal_range_expr();
}
inline ::optimization_guide::proto::RangeExpr* StringArg::unsafe_arena_release_range_expr()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:optimization_guide.proto.StringArg.range_expr)
    if (_internal_has_range_expr()) {
        clear_has_arg();
        ::optimization_guide::proto::RangeExpr* temp = _impl_.arg_.range_expr_;
        _impl_.arg_.range_expr_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void StringArg::unsafe_arena_set_allocated_range_expr(::optimization_guide::proto::RangeExpr* range_expr)
{
    clear_arg();
    if (range_expr) {
        set_has_range_expr();
        _impl_.arg_.range_expr_ = range_expr;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:optimization_guide.proto.StringArg.range_expr)
}
inline ::optimization_guide::proto::RangeExpr* StringArg::_internal_mutable_range_expr()
{
    if (!_internal_has_range_expr()) {
        clear_arg();
        set_has_range_expr();
        _impl_.arg_.range_expr_ = CreateMaybeMessage<::optimization_guide::proto::RangeExpr>(GetArenaForAllocation());
    }
    return _impl_.arg_.range_expr_;
}
inline ::optimization_guide::proto::RangeExpr* StringArg::mutable_range_expr()
{
    ::optimization_guide::proto::RangeExpr* _msg = _internal_mutable_range_expr();
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.StringArg.range_expr)
    return _msg;
}

// .optimization_guide.proto.IndexExpr index_expr = 5;
inline bool StringArg::_internal_has_index_expr() const
{
    return arg_case() == kIndexExpr;
}
inline bool StringArg::has_index_expr() const
{
    return _internal_has_index_expr();
}
inline void StringArg::set_has_index_expr()
{
    _impl_._oneof_case_[0] = kIndexExpr;
}
inline void StringArg::clear_index_expr()
{
    if (_internal_has_index_expr()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.arg_.index_expr_;
        }
        clear_has_arg();
    }
}
inline ::optimization_guide::proto::IndexExpr* StringArg::release_index_expr()
{
    // @@protoc_insertion_point(field_release:optimization_guide.proto.StringArg.index_expr)
    if (_internal_has_index_expr()) {
        clear_has_arg();
        ::optimization_guide::proto::IndexExpr* temp = _impl_.arg_.index_expr_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.arg_.index_expr_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::optimization_guide::proto::IndexExpr& StringArg::_internal_index_expr() const
{
    return _internal_has_index_expr() ? *_impl_.arg_.index_expr_
                                      : reinterpret_cast<::optimization_guide::proto::IndexExpr&>(::optimization_guide::proto::_IndexExpr_default_instance_);
}
inline const ::optimization_guide::proto::IndexExpr& StringArg::index_expr() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.StringArg.index_expr)
    return _internal_index_expr();
}
inline ::optimization_guide::proto::IndexExpr* StringArg::unsafe_arena_release_index_expr()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:optimization_guide.proto.StringArg.index_expr)
    if (_internal_has_index_expr()) {
        clear_has_arg();
        ::optimization_guide::proto::IndexExpr* temp = _impl_.arg_.index_expr_;
        _impl_.arg_.index_expr_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void StringArg::unsafe_arena_set_allocated_index_expr(::optimization_guide::proto::IndexExpr* index_expr)
{
    clear_arg();
    if (index_expr) {
        set_has_index_expr();
        _impl_.arg_.index_expr_ = index_expr;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:optimization_guide.proto.StringArg.index_expr)
}
inline ::optimization_guide::proto::IndexExpr* StringArg::_internal_mutable_index_expr()
{
    if (!_internal_has_index_expr()) {
        clear_arg();
        set_has_index_expr();
        _impl_.arg_.index_expr_ = CreateMaybeMessage<::optimization_guide::proto::IndexExpr>(GetArenaForAllocation());
    }
    return _impl_.arg_.index_expr_;
}
inline ::optimization_guide::proto::IndexExpr* StringArg::mutable_index_expr()
{
    ::optimization_guide::proto::IndexExpr* _msg = _internal_mutable_index_expr();
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.StringArg.index_expr)
    return _msg;
}

// .optimization_guide.proto.ControlToken control_token = 6;
inline bool StringArg::_internal_has_control_token() const
{
    return arg_case() == kControlToken;
}
inline bool StringArg::has_control_token() const
{
    return _internal_has_control_token();
}
inline void StringArg::set_has_control_token()
{
    _impl_._oneof_case_[0] = kControlToken;
}
inline void StringArg::clear_control_token()
{
    if (_internal_has_control_token()) {
        _impl_.arg_.control_token_ = 0;
        clear_has_arg();
    }
}
inline ::optimization_guide::proto::ControlToken StringArg::_internal_control_token() const
{
    if (_internal_has_control_token()) {
        return static_cast<::optimization_guide::proto::ControlToken>(_impl_.arg_.control_token_);
    }
    return static_cast<::optimization_guide::proto::ControlToken>(0);
}
inline ::optimization_guide::proto::ControlToken StringArg::control_token() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.StringArg.control_token)
    return _internal_control_token();
}
inline void StringArg::_internal_set_control_token(::optimization_guide::proto::ControlToken value)
{
    if (!_internal_has_control_token()) {
        clear_arg();
        set_has_control_token();
    }
    _impl_.arg_.control_token_ = value;
}
inline void StringArg::set_control_token(::optimization_guide::proto::ControlToken value)
{
    _internal_set_control_token(value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.StringArg.control_token)
}

// .optimization_guide.proto.ConditionList conditions = 3;
inline bool StringArg::_internal_has_conditions() const
{
    return this != internal_default_instance() && _impl_.conditions_ != nullptr;
}
inline bool StringArg::has_conditions() const
{
    return _internal_has_conditions();
}
inline void StringArg::clear_conditions()
{
    if (GetArenaForAllocation() == nullptr && _impl_.conditions_ != nullptr) {
        delete _impl_.conditions_;
    }
    _impl_.conditions_ = nullptr;
}
inline const ::optimization_guide::proto::ConditionList& StringArg::_internal_conditions() const
{
    const ::optimization_guide::proto::ConditionList* p = _impl_.conditions_;
    return p != nullptr ? *p
                        : reinterpret_cast<const ::optimization_guide::proto::ConditionList&>(::optimization_guide::proto::_ConditionList_default_instance_);
}
inline const ::optimization_guide::proto::ConditionList& StringArg::conditions() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.StringArg.conditions)
    return _internal_conditions();
}
inline void StringArg::unsafe_arena_set_allocated_conditions(::optimization_guide::proto::ConditionList* conditions)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.conditions_);
    }
    _impl_.conditions_ = conditions;
    if (conditions) {

    } else {
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:optimization_guide.proto.StringArg.conditions)
}
inline ::optimization_guide::proto::ConditionList* StringArg::release_conditions()
{

    ::optimization_guide::proto::ConditionList* temp = _impl_.conditions_;
    _impl_.conditions_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::optimization_guide::proto::ConditionList* StringArg::unsafe_arena_release_conditions()
{
    // @@protoc_insertion_point(field_release:optimization_guide.proto.StringArg.conditions)

    ::optimization_guide::proto::ConditionList* temp = _impl_.conditions_;
    _impl_.conditions_ = nullptr;
    return temp;
}
inline ::optimization_guide::proto::ConditionList* StringArg::_internal_mutable_conditions()
{

    if (_impl_.conditions_ == nullptr) {
        auto* p = CreateMaybeMessage<::optimization_guide::proto::ConditionList>(GetArenaForAllocation());
        _impl_.conditions_ = p;
    }
    return _impl_.conditions_;
}
inline ::optimization_guide::proto::ConditionList* StringArg::mutable_conditions()
{
    ::optimization_guide::proto::ConditionList* _msg = _internal_mutable_conditions();
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.StringArg.conditions)
    return _msg;
}
inline void StringArg::set_allocated_conditions(::optimization_guide::proto::ConditionList* conditions)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.conditions_;
    }
    if (conditions) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(conditions);
        if (message_arena != submessage_arena) {
            conditions = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, conditions, submessage_arena);
        }

    } else {
    }
    _impl_.conditions_ = conditions;
    // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.StringArg.conditions)
}

inline bool StringArg::has_arg() const
{
    return arg_case() != ARG_NOT_SET;
}
inline void StringArg::clear_has_arg()
{
    _impl_._oneof_case_[0] = ARG_NOT_SET;
}
inline StringArg::ArgCase StringArg::arg_case() const
{
    return StringArg::ArgCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ConditionList

// .optimization_guide.proto.ConditionEvaluationType condition_evaluation_type = 1;
inline void ConditionList::clear_condition_evaluation_type()
{
    _impl_.condition_evaluation_type_ = 0;
}
inline ::optimization_guide::proto::ConditionEvaluationType ConditionList::_internal_condition_evaluation_type() const
{
    return static_cast<::optimization_guide::proto::ConditionEvaluationType>(_impl_.condition_evaluation_type_);
}
inline ::optimization_guide::proto::ConditionEvaluationType ConditionList::condition_evaluation_type() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.ConditionList.condition_evaluation_type)
    return _internal_condition_evaluation_type();
}
inline void ConditionList::_internal_set_condition_evaluation_type(::optimization_guide::proto::ConditionEvaluationType value)
{

    _impl_.condition_evaluation_type_ = value;
}
inline void ConditionList::set_condition_evaluation_type(::optimization_guide::proto::ConditionEvaluationType value)
{
    _internal_set_condition_evaluation_type(value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.ConditionList.condition_evaluation_type)
}

// repeated .optimization_guide.proto.Condition conditions = 2;
inline int ConditionList::_internal_conditions_size() const
{
    return _impl_.conditions_.size();
}
inline int ConditionList::conditions_size() const
{
    return _internal_conditions_size();
}
inline void ConditionList::clear_conditions()
{
    _impl_.conditions_.Clear();
}
inline ::optimization_guide::proto::Condition* ConditionList::mutable_conditions(int index)
{
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.ConditionList.conditions)
    return _impl_.conditions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::Condition>* ConditionList::mutable_conditions()
{
    // @@protoc_insertion_point(field_mutable_list:optimization_guide.proto.ConditionList.conditions)
    return &_impl_.conditions_;
}
inline const ::optimization_guide::proto::Condition& ConditionList::_internal_conditions(int index) const
{
    return _impl_.conditions_.Get(index);
}
inline const ::optimization_guide::proto::Condition& ConditionList::conditions(int index) const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.ConditionList.conditions)
    return _internal_conditions(index);
}
inline ::optimization_guide::proto::Condition* ConditionList::_internal_add_conditions()
{
    return _impl_.conditions_.Add();
}
inline ::optimization_guide::proto::Condition* ConditionList::add_conditions()
{
    ::optimization_guide::proto::Condition* _add = _internal_add_conditions();
    // @@protoc_insertion_point(field_add:optimization_guide.proto.ConditionList.conditions)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::optimization_guide::proto::Condition>& ConditionList::conditions() const
{
    // @@protoc_insertion_point(field_list:optimization_guide.proto.ConditionList.conditions)
    return _impl_.conditions_;
}

// -------------------------------------------------------------------

// Condition

// .optimization_guide.proto.ProtoField proto_field = 1;
inline bool Condition::_internal_has_proto_field() const
{
    return this != internal_default_instance() && _impl_.proto_field_ != nullptr;
}
inline bool Condition::has_proto_field() const
{
    return _internal_has_proto_field();
}
inline const ::optimization_guide::proto::ProtoField& Condition::_internal_proto_field() const
{
    const ::optimization_guide::proto::ProtoField* p = _impl_.proto_field_;
    return p != nullptr ? *p : reinterpret_cast<const ::optimization_guide::proto::ProtoField&>(::optimization_guide::proto::_ProtoField_default_instance_);
}
inline const ::optimization_guide::proto::ProtoField& Condition::proto_field() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.Condition.proto_field)
    return _internal_proto_field();
}
inline void Condition::unsafe_arena_set_allocated_proto_field(::optimization_guide::proto::ProtoField* proto_field)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.proto_field_);
    }
    _impl_.proto_field_ = proto_field;
    if (proto_field) {

    } else {
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:optimization_guide.proto.Condition.proto_field)
}
inline ::optimization_guide::proto::ProtoField* Condition::release_proto_field()
{

    ::optimization_guide::proto::ProtoField* temp = _impl_.proto_field_;
    _impl_.proto_field_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::optimization_guide::proto::ProtoField* Condition::unsafe_arena_release_proto_field()
{
    // @@protoc_insertion_point(field_release:optimization_guide.proto.Condition.proto_field)

    ::optimization_guide::proto::ProtoField* temp = _impl_.proto_field_;
    _impl_.proto_field_ = nullptr;
    return temp;
}
inline ::optimization_guide::proto::ProtoField* Condition::_internal_mutable_proto_field()
{

    if (_impl_.proto_field_ == nullptr) {
        auto* p = CreateMaybeMessage<::optimization_guide::proto::ProtoField>(GetArenaForAllocation());
        _impl_.proto_field_ = p;
    }
    return _impl_.proto_field_;
}
inline ::optimization_guide::proto::ProtoField* Condition::mutable_proto_field()
{
    ::optimization_guide::proto::ProtoField* _msg = _internal_mutable_proto_field();
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.Condition.proto_field)
    return _msg;
}
inline void Condition::set_allocated_proto_field(::optimization_guide::proto::ProtoField* proto_field)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.proto_field_);
    }
    if (proto_field) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena
            = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(proto_field));
        if (message_arena != submessage_arena) {
            proto_field = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, proto_field, submessage_arena);
        }

    } else {
    }
    _impl_.proto_field_ = proto_field;
    // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.Condition.proto_field)
}

// .optimization_guide.proto.OperatorType operator_type = 2;
inline void Condition::clear_operator_type()
{
    _impl_.operator_type_ = 0;
}
inline ::optimization_guide::proto::OperatorType Condition::_internal_operator_type() const
{
    return static_cast<::optimization_guide::proto::OperatorType>(_impl_.operator_type_);
}
inline ::optimization_guide::proto::OperatorType Condition::operator_type() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.Condition.operator_type)
    return _internal_operator_type();
}
inline void Condition::_internal_set_operator_type(::optimization_guide::proto::OperatorType value)
{

    _impl_.operator_type_ = value;
}
inline void Condition::set_operator_type(::optimization_guide::proto::OperatorType value)
{
    _internal_set_operator_type(value);
    // @@protoc_insertion_point(field_set:optimization_guide.proto.Condition.operator_type)
}

// .optimization_guide.proto.Value value = 3;
inline bool Condition::_internal_has_value() const
{
    return this != internal_default_instance() && _impl_.value_ != nullptr;
}
inline bool Condition::has_value() const
{
    return _internal_has_value();
}
inline const ::optimization_guide::proto::Value& Condition::_internal_value() const
{
    const ::optimization_guide::proto::Value* p = _impl_.value_;
    return p != nullptr ? *p : reinterpret_cast<const ::optimization_guide::proto::Value&>(::optimization_guide::proto::_Value_default_instance_);
}
inline const ::optimization_guide::proto::Value& Condition::value() const
{
    // @@protoc_insertion_point(field_get:optimization_guide.proto.Condition.value)
    return _internal_value();
}
inline void Condition::unsafe_arena_set_allocated_value(::optimization_guide::proto::Value* value)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.value_);
    }
    _impl_.value_ = value;
    if (value) {

    } else {
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:optimization_guide.proto.Condition.value)
}
inline ::optimization_guide::proto::Value* Condition::release_value()
{

    ::optimization_guide::proto::Value* temp = _impl_.value_;
    _impl_.value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::optimization_guide::proto::Value* Condition::unsafe_arena_release_value()
{
    // @@protoc_insertion_point(field_release:optimization_guide.proto.Condition.value)

    ::optimization_guide::proto::Value* temp = _impl_.value_;
    _impl_.value_ = nullptr;
    return temp;
}
inline ::optimization_guide::proto::Value* Condition::_internal_mutable_value()
{

    if (_impl_.value_ == nullptr) {
        auto* p = CreateMaybeMessage<::optimization_guide::proto::Value>(GetArenaForAllocation());
        _impl_.value_ = p;
    }
    return _impl_.value_;
}
inline ::optimization_guide::proto::Value* Condition::mutable_value()
{
    ::optimization_guide::proto::Value* _msg = _internal_mutable_value();
    // @@protoc_insertion_point(field_mutable:optimization_guide.proto.Condition.value)
    return _msg;
}
inline void Condition::set_allocated_value(::optimization_guide::proto::Value* value)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.value_);
    }
    if (value) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena
            = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value));
        if (message_arena != submessage_arena) {
            value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, value, submessage_arena);
        }

    } else {
    }
    _impl_.value_ = value;
    // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.Condition.value)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// @@protoc_insertion_point(namespace_scope)

} // namespace proto
} // namespace optimization_guide

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum<::optimization_guide::proto::ControlToken> : ::std::true_type { };
template <> struct is_proto_enum<::optimization_guide::proto::OperatorType> : ::std::true_type { };
template <> struct is_proto_enum<::optimization_guide::proto::ConditionEvaluationType> : ::std::true_type { };

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_components_2foptimization_5fguide_2fproto_2fsubstitution_2eproto
