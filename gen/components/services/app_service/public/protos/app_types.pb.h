// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/services/app_service/public/protos/app_types.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_components_2fservices_2fapp_5fservice_2fpublic_2fprotos_2fapp_5ftypes_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_components_2fservices_2fapp_5fservice_2fpublic_2fprotos_2fapp_5ftypes_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/repeated_field.h> // IWYU pragma: export
#include <google/protobuf/extension_set.h> // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_components_2fservices_2fapp_5fservice_2fpublic_2fprotos_2fapp_5ftypes_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
} // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_components_2fservices_2fapp_5fservice_2fpublic_2fprotos_2fapp_5ftypes_2eproto {
    static const uint32_t offsets[];
};
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE
namespace apps {

enum ApplicationType : int {
    APPLICATION_TYPE_UNKNOWN = 0,
    APPLICATION_TYPE_ARC = 1,
    APPLICATION_TYPE_BUILT_IN = 2,
    APPLICATION_TYPE_CROSTINI = 3,
    APPLICATION_TYPE_CHROME_APP = 4,
    APPLICATION_TYPE_WEB = 5,
    APPLICATION_TYPE_PLUGIN_VM = 7,
    APPLICATION_TYPE_STANDALONE_BROWSER = 8,
    APPLICATION_TYPE_REMOTE = 9,
    APPLICATION_TYPE_BOREALIS = 10,
    APPLICATION_TYPE_SYSTEM_WEB = 11,
    APPLICATION_TYPE_STANDALONE_BROWSER_CHROME_APP = 12,
    APPLICATION_TYPE_EXTENSION = 13,
    APPLICATION_TYPE_STANDALONE_BROWSER_EXTENSION = 14,
    APPLICATION_TYPE_BRUSCHETTA = 15
};
bool ApplicationType_IsValid(int value);
constexpr ApplicationType ApplicationType_MIN = APPLICATION_TYPE_UNKNOWN;
constexpr ApplicationType ApplicationType_MAX = APPLICATION_TYPE_BRUSCHETTA;
constexpr int ApplicationType_ARRAYSIZE = ApplicationType_MAX + 1;

const std::string& ApplicationType_Name(ApplicationType value);
template <typename T> inline const std::string& ApplicationType_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, ApplicationType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function ApplicationType_Name.");
    return ApplicationType_Name(static_cast<ApplicationType>(enum_t_value));
}
bool ApplicationType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ApplicationType* value);
enum ApplicationInstallSource : int {
    APPLICATION_INSTALL_SOURCE_UNKNOWN = 0,
    APPLICATION_INSTALL_SOURCE_SYSTEM = 1,
    APPLICATION_INSTALL_SOURCE_SYNC = 2,
    APPLICATION_INSTALL_SOURCE_PLAY_STORE = 3,
    APPLICATION_INSTALL_SOURCE_CHROME_WEB_STORE = 4,
    APPLICATION_INSTALL_SOURCE_BROWSER = 5
};
bool ApplicationInstallSource_IsValid(int value);
constexpr ApplicationInstallSource ApplicationInstallSource_MIN = APPLICATION_INSTALL_SOURCE_UNKNOWN;
constexpr ApplicationInstallSource ApplicationInstallSource_MAX = APPLICATION_INSTALL_SOURCE_BROWSER;
constexpr int ApplicationInstallSource_ARRAYSIZE = ApplicationInstallSource_MAX + 1;

const std::string& ApplicationInstallSource_Name(ApplicationInstallSource value);
template <typename T> inline const std::string& ApplicationInstallSource_Name(T enum_t_value)
{
    static_assert(
        ::std::is_same<T, ApplicationInstallSource>::value || ::std::is_integral<T>::value, "Incorrect type passed to function ApplicationInstallSource_Name.");
    return ApplicationInstallSource_Name(static_cast<ApplicationInstallSource>(enum_t_value));
}
bool ApplicationInstallSource_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ApplicationInstallSource* value);
enum ApplicationInstallReason : int {
    APPLICATION_INSTALL_REASON_UNKNOWN = 0,
    APPLICATION_INSTALL_REASON_SYSTEM = 1,
    APPLICATION_INSTALL_REASON_POLICY = 2,
    APPLICATION_INSTALL_REASON_OEM = 3,
    APPLICATION_INSTALL_REASON_DEFAULT = 4,
    APPLICATION_INSTALL_REASON_SYNC = 5,
    APPLICATION_INSTALL_REASON_USER = 6,
    APPLICATION_INSTALL_REASON_SUB_APP = 7,
    APPLICATION_INSTALL_REASON_KIOSK = 8,
    APPLICATION_INSTALL_REASON_COMMAND_LINE = 9
};
bool ApplicationInstallReason_IsValid(int value);
constexpr ApplicationInstallReason ApplicationInstallReason_MIN = APPLICATION_INSTALL_REASON_UNKNOWN;
constexpr ApplicationInstallReason ApplicationInstallReason_MAX = APPLICATION_INSTALL_REASON_COMMAND_LINE;
constexpr int ApplicationInstallReason_ARRAYSIZE = ApplicationInstallReason_MAX + 1;

const std::string& ApplicationInstallReason_Name(ApplicationInstallReason value);
template <typename T> inline const std::string& ApplicationInstallReason_Name(T enum_t_value)
{
    static_assert(
        ::std::is_same<T, ApplicationInstallReason>::value || ::std::is_integral<T>::value, "Incorrect type passed to function ApplicationInstallReason_Name.");
    return ApplicationInstallReason_Name(static_cast<ApplicationInstallReason>(enum_t_value));
}
bool ApplicationInstallReason_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ApplicationInstallReason* value);
enum ApplicationInstallTime : int { APPLICATION_INSTALL_TIME_UNKNOWN = 0, APPLICATION_INSTALL_TIME_INIT = 1, APPLICATION_INSTALL_TIME_RUNNING = 2 };
bool ApplicationInstallTime_IsValid(int value);
constexpr ApplicationInstallTime ApplicationInstallTime_MIN = APPLICATION_INSTALL_TIME_UNKNOWN;
constexpr ApplicationInstallTime ApplicationInstallTime_MAX = APPLICATION_INSTALL_TIME_RUNNING;
constexpr int ApplicationInstallTime_ARRAYSIZE = ApplicationInstallTime_MAX + 1;

const std::string& ApplicationInstallTime_Name(ApplicationInstallTime value);
template <typename T> inline const std::string& ApplicationInstallTime_Name(T enum_t_value)
{
    static_assert(
        ::std::is_same<T, ApplicationInstallTime>::value || ::std::is_integral<T>::value, "Incorrect type passed to function ApplicationInstallTime_Name.");
    return ApplicationInstallTime_Name(static_cast<ApplicationInstallTime>(enum_t_value));
}
bool ApplicationInstallTime_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ApplicationInstallTime* value);
enum ApplicationLaunchSource : int {
    APPLICATION_LAUNCH_SOURCE_UNKNOWN = 0,
    APPLICATION_LAUNCH_SOURCE_APP_LIST_GRID = 1,
    APPLICATION_LAUNCH_SOURCE_APP_LIST_GRID_CONTEXT_MENU = 2,
    APPLICATION_LAUNCH_SOURCE_APP_LIST_QUERY = 3,
    APPLICATION_LAUNCH_SOURCE_APP_LIST_QUERY_CONTEXT_MENU = 4,
    APPLICATION_LAUNCH_SOURCE_APP_LIST_RECOMMENDATION = 5,
    APPLICATION_LAUNCH_SOURCE_PARENTAL_CONTROLS = 6,
    APPLICATION_LAUNCH_SOURCE_SHELF = 7,
    APPLICATION_LAUNCH_SOURCE_FILE_MANAGER = 8,
    APPLICATION_LAUNCH_SOURCE_LINK = 9,
    APPLICATION_LAUNCH_SOURCE_OMNIBOX = 10,
    APPLICATION_LAUNCH_SOURCE_CHROME_INTERNAL = 11,
    APPLICATION_LAUNCH_SOURCE_KEYBOARD = 12,
    APPLICATION_LAUNCH_SOURCE_OTHER_APP = 13,
    APPLICATION_LAUNCH_SOURCE_MENU = 14,
    APPLICATION_LAUNCH_SOURCE_INSTALLED_NOTIFICATION = 15,
    APPLICATION_LAUNCH_SOURCE_TEST = 16,
    APPLICATION_LAUNCH_SOURCE_ARC = 17,
    APPLICATION_LAUNCH_SOURCE_SHARESHEET = 18,
    APPLICATION_LAUNCH_SOURCE_RELEASE_NOTES_NOTIFICATION = 19,
    APPLICATION_LAUNCH_SOURCE_FULL_RESTORE = 20,
    APPLICATION_LAUNCH_SOURCE_SMART_TEXT_CONTEXT_MENU = 21,
    APPLICATION_LAUNCH_SOURCE_DISCOVER_TAB_NOTIFICATION = 22,
    APPLICATION_LAUNCH_SOURCE_MANAGEMENT_API = 23,
    APPLICATION_LAUNCH_SOURCE_KIOSK = 24,
    APPLICATION_LAUNCH_SOURCE_COMMAND_LINE = 25,
    APPLICATION_LAUNCH_SOURCE_BACKGROUND_MODE = 26,
    APPLICATION_LAUNCH_SOURCE_NEW_TAB_PAGE = 27,
    APPLICATION_LAUNCH_SOURCE_INTENT_URL = 28,
    APPLICATION_LAUNCH_SOURCE_OS_LOGIN = 29,
    APPLICATION_LAUNCH_SOURCE_PROTOCOL_HANDLER = 30,
    APPLICATION_LAUNCH_SOURCE_URL_HANDLER = 31,
    APPLICATION_LAUNCH_SOURCE_LOCK_SCREEN = 32,
    APPLICATION_LAUNCH_SOURCE_APP_HOME_PAGE = 33,
    APPLICATION_LAUNCH_SOURCE_REPARENTING = 34,
    APPLICATION_LAUNCH_SOURCE_PROFILE_MENU = 35,
    APPLICATION_LAUNCH_SOURCE_SYSTEM_TRAY_CALENDAR = 36,
    APPLICATION_LAUNCH_SOURCE_INSTALLER = 37,
    APPLICATION_LAUNCH_SOURCE_FIRST_RUN = 38,
    APPLICATION_LAUNCH_SOURCE_WELCOME_TOUR = 39,
    APPLICATION_LAUNCH_SOURCE_FOCUS_MODE = 40,
    APPLICATION_LAUNCH_SOURCE_SPARKY = 41,
    APPLICATION_LAUNCH_SOURCE_NAVIGATION_CAPTURING = 42,
    APPLICATION_LAUNCH_SOURCE_WEB_INSTALL_API = 43
};
bool ApplicationLaunchSource_IsValid(int value);
constexpr ApplicationLaunchSource ApplicationLaunchSource_MIN = APPLICATION_LAUNCH_SOURCE_UNKNOWN;
constexpr ApplicationLaunchSource ApplicationLaunchSource_MAX = APPLICATION_LAUNCH_SOURCE_WEB_INSTALL_API;
constexpr int ApplicationLaunchSource_ARRAYSIZE = ApplicationLaunchSource_MAX + 1;

const std::string& ApplicationLaunchSource_Name(ApplicationLaunchSource value);
template <typename T> inline const std::string& ApplicationLaunchSource_Name(T enum_t_value)
{
    static_assert(
        ::std::is_same<T, ApplicationLaunchSource>::value || ::std::is_integral<T>::value, "Incorrect type passed to function ApplicationLaunchSource_Name.");
    return ApplicationLaunchSource_Name(static_cast<ApplicationLaunchSource>(enum_t_value));
}
bool ApplicationLaunchSource_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ApplicationLaunchSource* value);
enum ApplicationUninstallSource : int {
    APPLICATION_UNINSTALL_SOURCE_UNKNOWN = 0,
    APPLICATION_UNINSTALL_SOURCE_APP_LIST = 1,
    APPLICATION_UNINSTALL_SOURCE_APP_MANAGEMENT = 2,
    APPLICATION_UNINSTALL_SOURCE_SHELF = 3,
    APPLICATION_UNINSTALL_SOURCE_MIGRATION = 4
};
bool ApplicationUninstallSource_IsValid(int value);
constexpr ApplicationUninstallSource ApplicationUninstallSource_MIN = APPLICATION_UNINSTALL_SOURCE_UNKNOWN;
constexpr ApplicationUninstallSource ApplicationUninstallSource_MAX = APPLICATION_UNINSTALL_SOURCE_MIGRATION;
constexpr int ApplicationUninstallSource_ARRAYSIZE = ApplicationUninstallSource_MAX + 1;

const std::string& ApplicationUninstallSource_Name(ApplicationUninstallSource value);
template <typename T> inline const std::string& ApplicationUninstallSource_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, ApplicationUninstallSource>::value || ::std::is_integral<T>::value,
        "Incorrect type passed to function ApplicationUninstallSource_Name.");
    return ApplicationUninstallSource_Name(static_cast<ApplicationUninstallSource>(enum_t_value));
}
bool ApplicationUninstallSource_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ApplicationUninstallSource* value);
// ===================================================================

// ===================================================================

// ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif // __GNUC__
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif // __GNUC__

// @@protoc_insertion_point(namespace_scope)

} // namespace apps

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum<::apps::ApplicationType> : ::std::true_type { };
template <> struct is_proto_enum<::apps::ApplicationInstallSource> : ::std::true_type { };
template <> struct is_proto_enum<::apps::ApplicationInstallReason> : ::std::true_type { };
template <> struct is_proto_enum<::apps::ApplicationInstallTime> : ::std::true_type { };
template <> struct is_proto_enum<::apps::ApplicationLaunchSource> : ::std::true_type { };
template <> struct is_proto_enum<::apps::ApplicationUninstallSource> : ::std::true_type { };

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_components_2fservices_2fapp_5fservice_2fpublic_2fprotos_2fapp_5ftypes_2eproto
