// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: service_worker_database.proto

#include "service_worker_database.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace storage {
PROTOBUF_CONSTEXPR ServiceWorkerOriginTrialFeature::ServiceWorkerOriginTrialFeature(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.tokens_)*/ {},
        /*decltype(_impl_.name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct ServiceWorkerOriginTrialFeatureDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ServiceWorkerOriginTrialFeatureDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ServiceWorkerOriginTrialFeatureDefaultTypeInternal()
    {
    }
    union {
        ServiceWorkerOriginTrialFeature _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ServiceWorkerOriginTrialFeatureDefaultTypeInternal
    _ServiceWorkerOriginTrialFeature_default_instance_;
PROTOBUF_CONSTEXPR ServiceWorkerOriginTrialInfo::ServiceWorkerOriginTrialInfo(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.features_)*/ {}, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct ServiceWorkerOriginTrialInfoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ServiceWorkerOriginTrialInfoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ServiceWorkerOriginTrialInfoDefaultTypeInternal()
    {
    }
    union {
        ServiceWorkerOriginTrialInfo _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ServiceWorkerOriginTrialInfoDefaultTypeInternal
    _ServiceWorkerOriginTrialInfo_default_instance_;
PROTOBUF_CONSTEXPR ServiceWorkerNavigationPreloadState::ServiceWorkerNavigationPreloadState(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.header_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.enabled_)*/ false }
{
}
struct ServiceWorkerNavigationPreloadStateDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ServiceWorkerNavigationPreloadStateDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ServiceWorkerNavigationPreloadStateDefaultTypeInternal()
    {
    }
    union {
        ServiceWorkerNavigationPreloadState _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ServiceWorkerNavigationPreloadStateDefaultTypeInternal
    _ServiceWorkerNavigationPreloadState_default_instance_;
PROTOBUF_CONSTEXPR ServiceWorkerRegistrationData_PolicyContainerPolicies::ServiceWorkerRegistrationData_PolicyContainerPolicies(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.sandbox_flags_)*/ 0,
        /*decltype(_impl_.ip_address_space_)*/ 0, /*decltype(_impl_.referrer_policy_)*/ 1 }
{
}
struct ServiceWorkerRegistrationData_PolicyContainerPoliciesDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ServiceWorkerRegistrationData_PolicyContainerPoliciesDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ServiceWorkerRegistrationData_PolicyContainerPoliciesDefaultTypeInternal()
    {
    }
    union {
        ServiceWorkerRegistrationData_PolicyContainerPolicies _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ServiceWorkerRegistrationData_PolicyContainerPoliciesDefaultTypeInternal
    _ServiceWorkerRegistrationData_PolicyContainerPolicies_default_instance_;
PROTOBUF_CONSTEXPR ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern::
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.value_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPatternDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPatternDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPatternDefaultTypeInternal()
    {
    }
    union {
        ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPatternDefaultTypeInternal
        _ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern_default_instance_;
PROTOBUF_CONSTEXPR ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern::
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.prefix_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.value_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.suffix_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPatternDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPatternDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPatternDefaultTypeInternal()
    {
    }
    union {
        ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPatternDefaultTypeInternal
        _ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern_default_instance_;
PROTOBUF_CONSTEXPR
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part(
        ::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.modifier_)*/ 0, /*decltype(_impl_.pattern_)*/ {},
        /*decltype(_impl_._oneof_case_)*/ {} }
{
}
struct ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_PartDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_PartDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_PartDefaultTypeInternal()
    {
    }
    union {
        ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_PartDefaultTypeInternal
        _ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_default_instance_;
PROTOBUF_CONSTEXPR ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options::
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.ignore_case_)*/ false }
{
}
struct ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_OptionsDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_OptionsDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_OptionsDefaultTypeInternal()
    {
    }
    union {
        ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_OptionsDefaultTypeInternal
        _ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options_default_instance_;
PROTOBUF_CONSTEXPR ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern(
    ::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.legacy_pathname_)*/ {},
        /*decltype(_impl_.hostname_)*/ {}, /*decltype(_impl_.protocol_)*/ {}, /*decltype(_impl_.username_)*/ {}, /*decltype(_impl_.password_)*/ {},
        /*decltype(_impl_.port_)*/ {}, /*decltype(_impl_.pathname_)*/ {}, /*decltype(_impl_.search_)*/ {}, /*decltype(_impl_.hash_)*/ {},
        /*decltype(_impl_.options_)*/ nullptr }
{
}
struct ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPatternDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPatternDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPatternDefaultTypeInternal()
    {
    }
    union {
        ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPatternDefaultTypeInternal
        _ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_default_instance_;
PROTOBUF_CONSTEXPR ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request(
    ::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.method_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.mode_)*/ 0,
        /*decltype(_impl_.destination_)*/ 0 }
{
}
struct ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RequestDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RequestDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RequestDefaultTypeInternal()
    {
    }
    union {
        ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RequestDefaultTypeInternal
        _ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_default_instance_;
PROTOBUF_CONSTEXPR
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus(
        ::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.status_)*/ 0 }
{
}
struct ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatusDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatusDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatusDefaultTypeInternal()
    {
    }
    union {
        ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatusDefaultTypeInternal
        _ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_default_instance_;
PROTOBUF_CONSTEXPR
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject(
        ::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.conditions_)*/ {}, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObjectDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObjectDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObjectDefaultTypeInternal()
    {
    }
    union {
        ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObjectDefaultTypeInternal
        _ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject_default_instance_;
PROTOBUF_CONSTEXPR
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition(
        ::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.objects_)*/ {}, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrConditionDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrConditionDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrConditionDefaultTypeInternal()
    {
    }
    union {
        ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrConditionDefaultTypeInternal
        _ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition_default_instance_;
PROTOBUF_CONSTEXPR
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition(
        ::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.object_)*/ nullptr }
{
}
struct ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotConditionDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotConditionDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotConditionDefaultTypeInternal()
    {
    }
    union {
        ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotConditionDefaultTypeInternal
        _ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition_default_instance_;
PROTOBUF_CONSTEXPR ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition(
    ::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.condition_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_._oneof_case_)*/ {} }
{
}
struct ServiceWorkerRegistrationData_RouterRules_RuleV1_ConditionDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ServiceWorkerRegistrationData_RouterRules_RuleV1_ConditionDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ServiceWorkerRegistrationData_RouterRules_RuleV1_ConditionDefaultTypeInternal()
    {
    }
    union {
        ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ServiceWorkerRegistrationData_RouterRules_RuleV1_ConditionDefaultTypeInternal
    _ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_default_instance_;
PROTOBUF_CONSTEXPR ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource(
    ::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSourceDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSourceDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSourceDefaultTypeInternal()
    {
    }
    union {
        ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSourceDefaultTypeInternal
        _ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource_default_instance_;
PROTOBUF_CONSTEXPR ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource(
    ::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSourceDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSourceDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSourceDefaultTypeInternal()
    {
    }
    union {
        ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSourceDefaultTypeInternal
        _ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource_default_instance_;
PROTOBUF_CONSTEXPR
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource(
        ::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSourceDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSourceDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSourceDefaultTypeInternal()
    {
    }
    union {
        ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSourceDefaultTypeInternal
        _ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource_default_instance_;
PROTOBUF_CONSTEXPR ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource(
    ::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.cache_name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSourceDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSourceDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSourceDefaultTypeInternal()
    {
    }
    union {
        ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSourceDefaultTypeInternal
        _ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource_default_instance_;
PROTOBUF_CONSTEXPR ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.source_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_._oneof_case_)*/ {} }
{
}
struct ServiceWorkerRegistrationData_RouterRules_RuleV1_SourceDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ServiceWorkerRegistrationData_RouterRules_RuleV1_SourceDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ServiceWorkerRegistrationData_RouterRules_RuleV1_SourceDefaultTypeInternal()
    {
    }
    union {
        ServiceWorkerRegistrationData_RouterRules_RuleV1_Source _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ServiceWorkerRegistrationData_RouterRules_RuleV1_SourceDefaultTypeInternal
    _ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_default_instance_;
PROTOBUF_CONSTEXPR ServiceWorkerRegistrationData_RouterRules_RuleV1::ServiceWorkerRegistrationData_RouterRules_RuleV1(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.condition_)*/ {}, /*decltype(_impl_.source_)*/ {}, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct ServiceWorkerRegistrationData_RouterRules_RuleV1DefaultTypeInternal {
    PROTOBUF_CONSTEXPR ServiceWorkerRegistrationData_RouterRules_RuleV1DefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ServiceWorkerRegistrationData_RouterRules_RuleV1DefaultTypeInternal()
    {
    }
    union {
        ServiceWorkerRegistrationData_RouterRules_RuleV1 _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ServiceWorkerRegistrationData_RouterRules_RuleV1DefaultTypeInternal
    _ServiceWorkerRegistrationData_RouterRules_RuleV1_default_instance_;
PROTOBUF_CONSTEXPR ServiceWorkerRegistrationData_RouterRules::ServiceWorkerRegistrationData_RouterRules(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.v1_)*/ {}, /*decltype(_impl_.version_)*/ 0 }
{
}
struct ServiceWorkerRegistrationData_RouterRulesDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ServiceWorkerRegistrationData_RouterRulesDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ServiceWorkerRegistrationData_RouterRulesDefaultTypeInternal()
    {
    }
    union {
        ServiceWorkerRegistrationData_RouterRules _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ServiceWorkerRegistrationData_RouterRulesDefaultTypeInternal
    _ServiceWorkerRegistrationData_RouterRules_default_instance_;
PROTOBUF_CONSTEXPR ServiceWorkerRegistrationData::ServiceWorkerRegistrationData(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.used_features_)*/ {},
        /*decltype(_impl_.scope_url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.script_url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.cross_origin_embedder_policy_reporting_endpoint_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.cross_origin_embedder_policy_report_only_reporting_endpoint_)*/
        { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.origin_trial_tokens_)*/ nullptr,
        /*decltype(_impl_.navigation_preload_state_)*/ nullptr, /*decltype(_impl_.policy_container_policies_)*/ nullptr,
        /*decltype(_impl_.router_rules_)*/ nullptr, /*decltype(_impl_.registration_id_)*/ int64_t { 0 }, /*decltype(_impl_.version_id_)*/ int64_t { 0 },
        /*decltype(_impl_.last_update_check_time_)*/ int64_t { 0 }, /*decltype(_impl_.resources_total_size_bytes_)*/ uint64_t { 0u },
        /*decltype(_impl_.update_via_cache_)*/ 0, /*decltype(_impl_.script_type_)*/ 0, /*decltype(_impl_.is_active_)*/ false,
        /*decltype(_impl_.has_fetch_handler_)*/ false, /*decltype(_impl_.has_hid_event_handlers_)*/ false, /*decltype(_impl_.has_usb_event_handlers_)*/ false,
        /*decltype(_impl_.cross_origin_embedder_policy_value_)*/ 0, /*decltype(_impl_.script_response_time_)*/ int64_t { 0 },
        /*decltype(_impl_.cross_origin_embedder_policy_report_only_value_)*/ 0, /*decltype(_impl_.ancestor_frame_type_)*/ 0,
        /*decltype(_impl_.fetch_handler_skippable_type_)*/ 1 }
{
}
struct ServiceWorkerRegistrationDataDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ServiceWorkerRegistrationDataDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ServiceWorkerRegistrationDataDefaultTypeInternal()
    {
    }
    union {
        ServiceWorkerRegistrationData _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ServiceWorkerRegistrationDataDefaultTypeInternal
    _ServiceWorkerRegistrationData_default_instance_;
PROTOBUF_CONSTEXPR ServiceWorkerResourceRecord::ServiceWorkerResourceRecord(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.sha256_checksum_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.resource_id_)*/ int64_t { 0 }, /*decltype(_impl_.size_bytes_)*/ uint64_t { 0u } }
{
}
struct ServiceWorkerResourceRecordDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ServiceWorkerResourceRecordDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ServiceWorkerResourceRecordDefaultTypeInternal()
    {
    }
    union {
        ServiceWorkerResourceRecord _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ServiceWorkerResourceRecordDefaultTypeInternal
    _ServiceWorkerResourceRecord_default_instance_;
} // namespace storage
namespace storage {
bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string>
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier_strings[4] = {};

static const char ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier_names[] = "kNone"
                                                                                                                "kOneOrMore"
                                                                                                                "kOptional"
                                                                                                                "kZeroOrMore";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier_entries[] = {
    { { ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier_names + 0, 5 }, 0 },
    { { ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier_names + 5, 10 }, 3 },
    { { ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier_names + 15, 9 }, 1 },
    { { ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier_names + 24, 11 }, 2 },
};

static const int ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier_entries_by_number[] = {
    0, // 0 -> kNone
    2, // 1 -> kOptional
    3, // 2 -> kZeroOrMore
    1, // 3 -> kOneOrMore
};

const std::string& ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier_Name(
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier value)
{
    static const bool dummy
        = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier_entries,
            ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier_entries_by_number, 4,
            ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier_entries,
        ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier_entries_by_number, 4, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString()
                     : ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier_strings[idx].get();
}
bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
        ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier_entries, 4, name, &int_value);
    if (success) {
        *value = static_cast<ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::kNone;
constexpr ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::kOptional;
constexpr ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::kZeroOrMore;
constexpr ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::kOneOrMore;
constexpr ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::Modifier_MIN;
constexpr ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::Modifier_MAX;
constexpr int ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::Modifier_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode_strings[5]
    = {};

static const char ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode_names[] = "kCorsMode"
                                                                                                    "kCorsWithForcedPreflightMode"
                                                                                                    "kNavigateMode"
                                                                                                    "kNoCorsMode"
                                                                                                    "kSameOriginMode";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode_entries[] = {
    { { ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode_names + 0, 9 }, 2 },
    { { ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode_names + 9, 28 }, 3 },
    { { ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode_names + 37, 13 }, 4 },
    { { ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode_names + 50, 11 }, 1 },
    { { ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode_names + 61, 15 }, 0 },
};

static const int ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode_entries_by_number[] = {
    4, // 0 -> kSameOriginMode
    3, // 1 -> kNoCorsMode
    0, // 2 -> kCorsMode
    1, // 3 -> kCorsWithForcedPreflightMode
    2, // 4 -> kNavigateMode
};

const std::string& ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode_Name(
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode value)
{
    static const bool dummy
        = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode_entries,
            ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode_entries_by_number, 5,
            ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode_entries,
        ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode_entries_by_number, 5, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString()
                     : ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode_strings[idx].get();
}
bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
        ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode_entries, 5, name, &int_value);
    if (success) {
        *value = static_cast<ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::kSameOriginMode;
constexpr ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::kNoCorsMode;
constexpr ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::kCorsMode;
constexpr ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::kCorsWithForcedPreflightMode;
constexpr ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::kNavigateMode;
constexpr ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::Mode_MIN;
constexpr ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::Mode_MAX;
constexpr int ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::Mode_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string>
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_strings[28] = {};

static const char ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_names[] = "kAudioDestination"
                                                                                                           "kAudioWorkletDestination"
                                                                                                           "kDictionaryDestination"
                                                                                                           "kDocumentDestination"
                                                                                                           "kEmbedDestination"
                                                                                                           "kEmptyDestination"
                                                                                                           "kFencedframeDestination"
                                                                                                           "kFontDestination"
                                                                                                           "kFrameDestination"
                                                                                                           "kIframeDestination"
                                                                                                           "kImageDestination"
                                                                                                           "kJsonDestination"
                                                                                                           "kManifestDestination"
                                                                                                           "kObjectDestination"
                                                                                                           "kPaintWorkletDestination"
                                                                                                           "kReportDestination"
                                                                                                           "kScriptDestination"
                                                                                                           "kServiceWorkerDestination"
                                                                                                           "kSharedStorageWorkletDestination"
                                                                                                           "kSharedWorkerDestination"
                                                                                                           "kSpeculationRulesDestination"
                                                                                                           "kStyleDestination"
                                                                                                           "kTrackDestination"
                                                                                                           "kVideoDestination"
                                                                                                           "kWebBundleDestination"
                                                                                                           "kWebIdentityDestination"
                                                                                                           "kWorkerDestination"
                                                                                                           "kXsltDestination";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_entries[] = {
    { { ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_names + 0, 17 }, 1 },
    { { ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_names + 17, 24 }, 2 },
    { { ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_names + 41, 22 }, 24 },
    { { ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_names + 63, 20 }, 3 },
    { { ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_names + 83, 17 }, 4 },
    { { ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_names + 100, 17 }, 0 },
    { { ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_names + 117, 23 }, 22 },
    { { ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_names + 140, 16 }, 5 },
    { { ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_names + 156, 17 }, 6 },
    { { ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_names + 173, 18 }, 7 },
    { { ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_names + 191, 17 }, 8 },
    { { ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_names + 208, 16 }, 26 },
    { { ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_names + 224, 20 }, 9 },
    { { ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_names + 244, 18 }, 10 },
    { { ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_names + 262, 24 }, 11 },
    { { ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_names + 286, 18 }, 12 },
    { { ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_names + 304, 18 }, 13 },
    { { ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_names + 322, 25 }, 14 },
    { { ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_names + 347, 32 }, 27 },
    { { ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_names + 379, 24 }, 15 },
    { { ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_names + 403, 28 }, 25 },
    { { ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_names + 431, 17 }, 16 },
    { { ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_names + 448, 17 }, 17 },
    { { ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_names + 465, 17 }, 18 },
    { { ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_names + 482, 21 }, 19 },
    { { ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_names + 503, 23 }, 23 },
    { { ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_names + 526, 18 }, 20 },
    { { ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_names + 544, 16 }, 21 },
};

static const int ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_entries_by_number[] = {
    5, // 0 -> kEmptyDestination
    0, // 1 -> kAudioDestination
    1, // 2 -> kAudioWorkletDestination
    3, // 3 -> kDocumentDestination
    4, // 4 -> kEmbedDestination
    7, // 5 -> kFontDestination
    8, // 6 -> kFrameDestination
    9, // 7 -> kIframeDestination
    10, // 8 -> kImageDestination
    12, // 9 -> kManifestDestination
    13, // 10 -> kObjectDestination
    14, // 11 -> kPaintWorkletDestination
    15, // 12 -> kReportDestination
    16, // 13 -> kScriptDestination
    17, // 14 -> kServiceWorkerDestination
    19, // 15 -> kSharedWorkerDestination
    21, // 16 -> kStyleDestination
    22, // 17 -> kTrackDestination
    23, // 18 -> kVideoDestination
    24, // 19 -> kWebBundleDestination
    26, // 20 -> kWorkerDestination
    27, // 21 -> kXsltDestination
    6, // 22 -> kFencedframeDestination
    25, // 23 -> kWebIdentityDestination
    2, // 24 -> kDictionaryDestination
    20, // 25 -> kSpeculationRulesDestination
    11, // 26 -> kJsonDestination
    18, // 27 -> kSharedStorageWorkletDestination
};

const std::string& ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_Name(
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination value)
{
    static const bool dummy
        = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_entries,
            ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_entries_by_number, 28,
            ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_entries,
        ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_entries_by_number, 28, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString()
                     : ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_strings[idx].get();
}
bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
        ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_entries, 28, name, &int_value);
    if (success) {
        *value = static_cast<ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::kEmptyDestination;
constexpr ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::kAudioDestination;
constexpr ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::kAudioWorkletDestination;
constexpr ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::kDocumentDestination;
constexpr ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::kEmbedDestination;
constexpr ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::kFontDestination;
constexpr ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::kFrameDestination;
constexpr ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::kIframeDestination;
constexpr ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::kImageDestination;
constexpr ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::kManifestDestination;
constexpr ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::kObjectDestination;
constexpr ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::kPaintWorkletDestination;
constexpr ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::kReportDestination;
constexpr ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::kScriptDestination;
constexpr ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::kServiceWorkerDestination;
constexpr ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::kSharedWorkerDestination;
constexpr ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::kStyleDestination;
constexpr ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::kTrackDestination;
constexpr ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::kVideoDestination;
constexpr ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::kWebBundleDestination;
constexpr ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::kWorkerDestination;
constexpr ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::kXsltDestination;
constexpr ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::kFencedframeDestination;
constexpr ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::kWebIdentityDestination;
constexpr ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::kDictionaryDestination;
constexpr ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::kSpeculationRulesDestination;
constexpr ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::kJsonDestination;
constexpr ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::kSharedStorageWorkletDestination;
constexpr ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::Destination_MIN;
constexpr ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::Destination_MAX;
constexpr int ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::Destination_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_Status_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string>
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_Status_strings[2] = {};

static const char ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_Status_names[] = "kNotRunning"
                                                                                                            "kRunning";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_Status_entries[] = {
    { { ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_Status_names + 0, 11 }, 1 },
    { { ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_Status_names + 11, 8 }, 0 },
};

static const int ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_Status_entries_by_number[] = {
    1, // 0 -> kRunning
    0, // 1 -> kNotRunning
};

const std::string& ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_Status_Name(
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_Status value)
{
    static const bool dummy
        = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_Status_entries,
            ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_Status_entries_by_number, 2,
            ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_Status_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_Status_entries,
        ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_Status_entries_by_number, 2, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString()
                     : ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_Status_strings[idx].get();
}
bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_Status* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
        ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_Status_entries, 2, name, &int_value);
    if (success) {
        *value = static_cast<ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_Status>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_Status
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus::kRunning;
constexpr ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_Status
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus::kNotRunning;
constexpr ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_Status
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus::Status_MIN;
constexpr ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_Status
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus::Status_MAX;
constexpr int ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus::Status_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ServiceWorkerRegistrationData_ServiceWorkerScriptType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ServiceWorkerRegistrationData_ServiceWorkerScriptType_strings[2] = {};

static const char ServiceWorkerRegistrationData_ServiceWorkerScriptType_names[] = "CLASSIC"
                                                                                  "MODULE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ServiceWorkerRegistrationData_ServiceWorkerScriptType_entries[] = {
    { { ServiceWorkerRegistrationData_ServiceWorkerScriptType_names + 0, 7 }, 0 },
    { { ServiceWorkerRegistrationData_ServiceWorkerScriptType_names + 7, 6 }, 1 },
};

static const int ServiceWorkerRegistrationData_ServiceWorkerScriptType_entries_by_number[] = {
    0, // 0 -> CLASSIC
    1, // 1 -> MODULE
};

const std::string& ServiceWorkerRegistrationData_ServiceWorkerScriptType_Name(ServiceWorkerRegistrationData_ServiceWorkerScriptType value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(ServiceWorkerRegistrationData_ServiceWorkerScriptType_entries,
        ServiceWorkerRegistrationData_ServiceWorkerScriptType_entries_by_number, 2, ServiceWorkerRegistrationData_ServiceWorkerScriptType_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        ServiceWorkerRegistrationData_ServiceWorkerScriptType_entries, ServiceWorkerRegistrationData_ServiceWorkerScriptType_entries_by_number, 2, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : ServiceWorkerRegistrationData_ServiceWorkerScriptType_strings[idx].get();
}
bool ServiceWorkerRegistrationData_ServiceWorkerScriptType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ServiceWorkerRegistrationData_ServiceWorkerScriptType* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(ServiceWorkerRegistrationData_ServiceWorkerScriptType_entries, 2, name, &int_value);
    if (success) {
        *value = static_cast<ServiceWorkerRegistrationData_ServiceWorkerScriptType>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ServiceWorkerRegistrationData_ServiceWorkerScriptType ServiceWorkerRegistrationData::CLASSIC;
constexpr ServiceWorkerRegistrationData_ServiceWorkerScriptType ServiceWorkerRegistrationData::MODULE;
constexpr ServiceWorkerRegistrationData_ServiceWorkerScriptType ServiceWorkerRegistrationData::ServiceWorkerScriptType_MIN;
constexpr ServiceWorkerRegistrationData_ServiceWorkerScriptType ServiceWorkerRegistrationData::ServiceWorkerScriptType_MAX;
constexpr int ServiceWorkerRegistrationData::ServiceWorkerScriptType_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType_strings[3] = {};

static const char ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType_names[] = "ALL"
                                                                                          "IMPORTS"
                                                                                          "NONE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType_entries[] = {
    { { ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType_names + 0, 3 }, 1 },
    { { ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType_names + 3, 7 }, 0 },
    { { ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType_names + 10, 4 }, 2 },
};

static const int ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType_entries_by_number[] = {
    1, // 0 -> IMPORTS
    0, // 1 -> ALL
    2, // 2 -> NONE
};

const std::string& ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType_Name(ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType_entries,
        ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType_entries_by_number, 3,
        ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType_entries,
        ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType_entries_by_number, 3, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType_strings[idx].get();
}
bool ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType* value)
{
    int int_value;
    bool success
        = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType_entries, 3, name, &int_value);
    if (success) {
        *value = static_cast<ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType ServiceWorkerRegistrationData::IMPORTS;
constexpr ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType ServiceWorkerRegistrationData::ALL;
constexpr ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType ServiceWorkerRegistrationData::NONE;
constexpr ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType ServiceWorkerRegistrationData::ServiceWorkerUpdateViaCacheType_MIN;
constexpr ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType ServiceWorkerRegistrationData::ServiceWorkerUpdateViaCacheType_MAX;
constexpr int ServiceWorkerRegistrationData::ServiceWorkerUpdateViaCacheType_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue_strings[3] = {};

static const char ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue_names[] = "CREDENTIALLESS"
                                                                                         "NONE_OR_NOT_EXIST"
                                                                                         "REQUIRE_CORP";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue_entries[] = {
    { { ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue_names + 0, 14 }, 2 },
    { { ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue_names + 14, 17 }, 0 },
    { { ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue_names + 31, 12 }, 1 },
};

static const int ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue_entries_by_number[] = {
    1, // 0 -> NONE_OR_NOT_EXIST
    2, // 1 -> REQUIRE_CORP
    0, // 2 -> CREDENTIALLESS
};

const std::string& ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue_Name(ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue_entries,
        ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue_entries_by_number, 3,
        ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue_entries,
        ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue_entries_by_number, 3, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue_strings[idx].get();
}
bool ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue* value)
{
    int int_value;
    bool success
        = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue_entries, 3, name, &int_value);
    if (success) {
        *value = static_cast<ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue ServiceWorkerRegistrationData::NONE_OR_NOT_EXIST;
constexpr ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue ServiceWorkerRegistrationData::REQUIRE_CORP;
constexpr ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue ServiceWorkerRegistrationData::CREDENTIALLESS;
constexpr ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue ServiceWorkerRegistrationData::CrossOriginEmbedderPolicyValue_MIN;
constexpr ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue ServiceWorkerRegistrationData::CrossOriginEmbedderPolicyValue_MAX;
constexpr int ServiceWorkerRegistrationData::CrossOriginEmbedderPolicyValue_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ServiceWorkerRegistrationData_AncestorFrameType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ServiceWorkerRegistrationData_AncestorFrameType_strings[2] = {};

static const char ServiceWorkerRegistrationData_AncestorFrameType_names[] = "FENCED_FRAME"
                                                                            "NORMAL_FRAME";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ServiceWorkerRegistrationData_AncestorFrameType_entries[] = {
    { { ServiceWorkerRegistrationData_AncestorFrameType_names + 0, 12 }, 1 },
    { { ServiceWorkerRegistrationData_AncestorFrameType_names + 12, 12 }, 0 },
};

static const int ServiceWorkerRegistrationData_AncestorFrameType_entries_by_number[] = {
    1, // 0 -> NORMAL_FRAME
    0, // 1 -> FENCED_FRAME
};

const std::string& ServiceWorkerRegistrationData_AncestorFrameType_Name(ServiceWorkerRegistrationData_AncestorFrameType value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(ServiceWorkerRegistrationData_AncestorFrameType_entries,
        ServiceWorkerRegistrationData_AncestorFrameType_entries_by_number, 2, ServiceWorkerRegistrationData_AncestorFrameType_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        ServiceWorkerRegistrationData_AncestorFrameType_entries, ServiceWorkerRegistrationData_AncestorFrameType_entries_by_number, 2, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : ServiceWorkerRegistrationData_AncestorFrameType_strings[idx].get();
}
bool ServiceWorkerRegistrationData_AncestorFrameType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ServiceWorkerRegistrationData_AncestorFrameType* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(ServiceWorkerRegistrationData_AncestorFrameType_entries, 2, name, &int_value);
    if (success) {
        *value = static_cast<ServiceWorkerRegistrationData_AncestorFrameType>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ServiceWorkerRegistrationData_AncestorFrameType ServiceWorkerRegistrationData::NORMAL_FRAME;
constexpr ServiceWorkerRegistrationData_AncestorFrameType ServiceWorkerRegistrationData::FENCED_FRAME;
constexpr ServiceWorkerRegistrationData_AncestorFrameType ServiceWorkerRegistrationData::AncestorFrameType_MIN;
constexpr ServiceWorkerRegistrationData_AncestorFrameType ServiceWorkerRegistrationData::AncestorFrameType_MAX;
constexpr int ServiceWorkerRegistrationData::AncestorFrameType_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ServiceWorkerRegistrationData_FetchHandlerSkippableType_IsValid(int value)
{
    switch (value) {
    case 1:
    case 2:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ServiceWorkerRegistrationData_FetchHandlerSkippableType_strings[2] = {};

static const char ServiceWorkerRegistrationData_FetchHandlerSkippableType_names[] = "NOT_SKIPPABLE"
                                                                                    "SKIPPABLE_EMPTY_FETCH_HANDLER";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ServiceWorkerRegistrationData_FetchHandlerSkippableType_entries[] = {
    { { ServiceWorkerRegistrationData_FetchHandlerSkippableType_names + 0, 13 }, 1 },
    { { ServiceWorkerRegistrationData_FetchHandlerSkippableType_names + 13, 29 }, 2 },
};

static const int ServiceWorkerRegistrationData_FetchHandlerSkippableType_entries_by_number[] = {
    0, // 1 -> NOT_SKIPPABLE
    1, // 2 -> SKIPPABLE_EMPTY_FETCH_HANDLER
};

const std::string& ServiceWorkerRegistrationData_FetchHandlerSkippableType_Name(ServiceWorkerRegistrationData_FetchHandlerSkippableType value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(ServiceWorkerRegistrationData_FetchHandlerSkippableType_entries,
        ServiceWorkerRegistrationData_FetchHandlerSkippableType_entries_by_number, 2, ServiceWorkerRegistrationData_FetchHandlerSkippableType_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        ServiceWorkerRegistrationData_FetchHandlerSkippableType_entries, ServiceWorkerRegistrationData_FetchHandlerSkippableType_entries_by_number, 2, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : ServiceWorkerRegistrationData_FetchHandlerSkippableType_strings[idx].get();
}
bool ServiceWorkerRegistrationData_FetchHandlerSkippableType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ServiceWorkerRegistrationData_FetchHandlerSkippableType* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(ServiceWorkerRegistrationData_FetchHandlerSkippableType_entries, 2, name, &int_value);
    if (success) {
        *value = static_cast<ServiceWorkerRegistrationData_FetchHandlerSkippableType>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ServiceWorkerRegistrationData_FetchHandlerSkippableType ServiceWorkerRegistrationData::NOT_SKIPPABLE;
constexpr ServiceWorkerRegistrationData_FetchHandlerSkippableType ServiceWorkerRegistrationData::SKIPPABLE_EMPTY_FETCH_HANDLER;
constexpr ServiceWorkerRegistrationData_FetchHandlerSkippableType ServiceWorkerRegistrationData::FetchHandlerSkippableType_MIN;
constexpr ServiceWorkerRegistrationData_FetchHandlerSkippableType ServiceWorkerRegistrationData::FetchHandlerSkippableType_MAX;
constexpr int ServiceWorkerRegistrationData::FetchHandlerSkippableType_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ServiceWorkerRegistrationData_ReferrerPolicyValue_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ServiceWorkerRegistrationData_ReferrerPolicyValue_strings[9] = {};

static const char ServiceWorkerRegistrationData_ReferrerPolicyValue_names[] = "ALWAYS"
                                                                              "DEFAULT"
                                                                              "NEVER"
                                                                              "NO_REFERRER_WHEN_DOWNGRADE"
                                                                              "ORIGIN"
                                                                              "ORIGIN_WHEN_CROSS_ORIGIN"
                                                                              "SAME_ORIGIN"
                                                                              "STRICT_ORIGIN"
                                                                              "STRICT_ORIGIN_WHEN_CROSS_ORIGIN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ServiceWorkerRegistrationData_ReferrerPolicyValue_entries[] = {
    { { ServiceWorkerRegistrationData_ReferrerPolicyValue_names + 0, 6 }, 0 },
    { { ServiceWorkerRegistrationData_ReferrerPolicyValue_names + 6, 7 }, 1 },
    { { ServiceWorkerRegistrationData_ReferrerPolicyValue_names + 13, 5 }, 3 },
    { { ServiceWorkerRegistrationData_ReferrerPolicyValue_names + 18, 26 }, 2 },
    { { ServiceWorkerRegistrationData_ReferrerPolicyValue_names + 44, 6 }, 4 },
    { { ServiceWorkerRegistrationData_ReferrerPolicyValue_names + 50, 24 }, 5 },
    { { ServiceWorkerRegistrationData_ReferrerPolicyValue_names + 74, 11 }, 7 },
    { { ServiceWorkerRegistrationData_ReferrerPolicyValue_names + 85, 13 }, 8 },
    { { ServiceWorkerRegistrationData_ReferrerPolicyValue_names + 98, 31 }, 6 },
};

static const int ServiceWorkerRegistrationData_ReferrerPolicyValue_entries_by_number[] = {
    0, // 0 -> ALWAYS
    1, // 1 -> DEFAULT
    3, // 2 -> NO_REFERRER_WHEN_DOWNGRADE
    2, // 3 -> NEVER
    4, // 4 -> ORIGIN
    5, // 5 -> ORIGIN_WHEN_CROSS_ORIGIN
    8, // 6 -> STRICT_ORIGIN_WHEN_CROSS_ORIGIN
    6, // 7 -> SAME_ORIGIN
    7, // 8 -> STRICT_ORIGIN
};

const std::string& ServiceWorkerRegistrationData_ReferrerPolicyValue_Name(ServiceWorkerRegistrationData_ReferrerPolicyValue value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(ServiceWorkerRegistrationData_ReferrerPolicyValue_entries,
        ServiceWorkerRegistrationData_ReferrerPolicyValue_entries_by_number, 9, ServiceWorkerRegistrationData_ReferrerPolicyValue_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        ServiceWorkerRegistrationData_ReferrerPolicyValue_entries, ServiceWorkerRegistrationData_ReferrerPolicyValue_entries_by_number, 9, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : ServiceWorkerRegistrationData_ReferrerPolicyValue_strings[idx].get();
}
bool ServiceWorkerRegistrationData_ReferrerPolicyValue_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ServiceWorkerRegistrationData_ReferrerPolicyValue* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(ServiceWorkerRegistrationData_ReferrerPolicyValue_entries, 9, name, &int_value);
    if (success) {
        *value = static_cast<ServiceWorkerRegistrationData_ReferrerPolicyValue>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ServiceWorkerRegistrationData_ReferrerPolicyValue ServiceWorkerRegistrationData::ALWAYS;
constexpr ServiceWorkerRegistrationData_ReferrerPolicyValue ServiceWorkerRegistrationData::DEFAULT;
constexpr ServiceWorkerRegistrationData_ReferrerPolicyValue ServiceWorkerRegistrationData::NO_REFERRER_WHEN_DOWNGRADE;
constexpr ServiceWorkerRegistrationData_ReferrerPolicyValue ServiceWorkerRegistrationData::NEVER;
constexpr ServiceWorkerRegistrationData_ReferrerPolicyValue ServiceWorkerRegistrationData::ORIGIN;
constexpr ServiceWorkerRegistrationData_ReferrerPolicyValue ServiceWorkerRegistrationData::ORIGIN_WHEN_CROSS_ORIGIN;
constexpr ServiceWorkerRegistrationData_ReferrerPolicyValue ServiceWorkerRegistrationData::STRICT_ORIGIN_WHEN_CROSS_ORIGIN;
constexpr ServiceWorkerRegistrationData_ReferrerPolicyValue ServiceWorkerRegistrationData::SAME_ORIGIN;
constexpr ServiceWorkerRegistrationData_ReferrerPolicyValue ServiceWorkerRegistrationData::STRICT_ORIGIN;
constexpr ServiceWorkerRegistrationData_ReferrerPolicyValue ServiceWorkerRegistrationData::ReferrerPolicyValue_MIN;
constexpr ServiceWorkerRegistrationData_ReferrerPolicyValue ServiceWorkerRegistrationData::ReferrerPolicyValue_MAX;
constexpr int ServiceWorkerRegistrationData::ReferrerPolicyValue_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ServiceWorkerRegistrationData_IPAddressSpace_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ServiceWorkerRegistrationData_IPAddressSpace_strings[4] = {};

static const char ServiceWorkerRegistrationData_IPAddressSpace_names[] = "LOCAL"
                                                                         "PRIVATE"
                                                                         "PUBLIC"
                                                                         "UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ServiceWorkerRegistrationData_IPAddressSpace_entries[] = {
    { { ServiceWorkerRegistrationData_IPAddressSpace_names + 0, 5 }, 1 },
    { { ServiceWorkerRegistrationData_IPAddressSpace_names + 5, 7 }, 2 },
    { { ServiceWorkerRegistrationData_IPAddressSpace_names + 12, 6 }, 3 },
    { { ServiceWorkerRegistrationData_IPAddressSpace_names + 18, 7 }, 0 },
};

static const int ServiceWorkerRegistrationData_IPAddressSpace_entries_by_number[] = {
    3, // 0 -> UNKNOWN
    0, // 1 -> LOCAL
    1, // 2 -> PRIVATE
    2, // 3 -> PUBLIC
};

const std::string& ServiceWorkerRegistrationData_IPAddressSpace_Name(ServiceWorkerRegistrationData_IPAddressSpace value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(ServiceWorkerRegistrationData_IPAddressSpace_entries,
        ServiceWorkerRegistrationData_IPAddressSpace_entries_by_number, 4, ServiceWorkerRegistrationData_IPAddressSpace_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        ServiceWorkerRegistrationData_IPAddressSpace_entries, ServiceWorkerRegistrationData_IPAddressSpace_entries_by_number, 4, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : ServiceWorkerRegistrationData_IPAddressSpace_strings[idx].get();
}
bool ServiceWorkerRegistrationData_IPAddressSpace_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ServiceWorkerRegistrationData_IPAddressSpace* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(ServiceWorkerRegistrationData_IPAddressSpace_entries, 4, name, &int_value);
    if (success) {
        *value = static_cast<ServiceWorkerRegistrationData_IPAddressSpace>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ServiceWorkerRegistrationData_IPAddressSpace ServiceWorkerRegistrationData::UNKNOWN;
constexpr ServiceWorkerRegistrationData_IPAddressSpace ServiceWorkerRegistrationData::LOCAL;
constexpr ServiceWorkerRegistrationData_IPAddressSpace ServiceWorkerRegistrationData::PRIVATE;
constexpr ServiceWorkerRegistrationData_IPAddressSpace ServiceWorkerRegistrationData::PUBLIC;
constexpr ServiceWorkerRegistrationData_IPAddressSpace ServiceWorkerRegistrationData::IPAddressSpace_MIN;
constexpr ServiceWorkerRegistrationData_IPAddressSpace ServiceWorkerRegistrationData::IPAddressSpace_MAX;
constexpr int ServiceWorkerRegistrationData::IPAddressSpace_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class ServiceWorkerOriginTrialFeature::_Internal {
public:
    using HasBits = decltype(std::declval<ServiceWorkerOriginTrialFeature>()._impl_._has_bits_);
    static void set_has_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static bool MissingRequiredFields(const HasBits& has_bits)
    {
        return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
    }
};

ServiceWorkerOriginTrialFeature::ServiceWorkerOriginTrialFeature(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:storage.ServiceWorkerOriginTrialFeature)
}
ServiceWorkerOriginTrialFeature::ServiceWorkerOriginTrialFeature(const ServiceWorkerOriginTrialFeature& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ServiceWorkerOriginTrialFeature* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.tokens_) { from._impl_.tokens_ }, decltype(_impl_.name_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_name()) {
        _this->_impl_.name_.Set(from._internal_name(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:storage.ServiceWorkerOriginTrialFeature)
}

inline void ServiceWorkerOriginTrialFeature::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_)
        Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.tokens_) { arena }, decltype(_impl_.name_) {} };
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ServiceWorkerOriginTrialFeature::~ServiceWorkerOriginTrialFeature()
{
    // @@protoc_insertion_point(destructor:storage.ServiceWorkerOriginTrialFeature)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ServiceWorkerOriginTrialFeature::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.tokens_.~RepeatedPtrField();
    _impl_.name_.Destroy();
}

void ServiceWorkerOriginTrialFeature::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ServiceWorkerOriginTrialFeature::Clear()
{
    // @@protoc_insertion_point(message_clear_start:storage.ServiceWorkerOriginTrialFeature)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.tokens_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.name_.ClearNonDefaultToEmpty();
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ServiceWorkerOriginTrialFeature::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // required string name = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated string tokens = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    auto str = _internal_add_tokens();
                    ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ServiceWorkerOriginTrialFeature::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:storage.ServiceWorkerOriginTrialFeature)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // required string name = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_name(), target);
    }

    // repeated string tokens = 2;
    for (int i = 0, n = this->_internal_tokens_size(); i < n; i++) {
        const auto& s = this->_internal_tokens(i);
        target = stream->WriteString(2, s, target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:storage.ServiceWorkerOriginTrialFeature)
    return target;
}

size_t ServiceWorkerOriginTrialFeature::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:storage.ServiceWorkerOriginTrialFeature)
    size_t total_size = 0;

    // required string name = 1;
    if (_internal_has_name()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_name());
    }
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated string tokens = 2;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.tokens_.size());
    for (int i = 0, n = _impl_.tokens_.size(); i < n; i++) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(_impl_.tokens_.Get(i));
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ServiceWorkerOriginTrialFeature::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ServiceWorkerOriginTrialFeature*>(&from));
}

void ServiceWorkerOriginTrialFeature::MergeFrom(const ServiceWorkerOriginTrialFeature& from)
{
    ServiceWorkerOriginTrialFeature* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:storage.ServiceWorkerOriginTrialFeature)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.tokens_.MergeFrom(from._impl_.tokens_);
    if (from._internal_has_name()) {
        _this->_internal_set_name(from._internal_name());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ServiceWorkerOriginTrialFeature::CopyFrom(const ServiceWorkerOriginTrialFeature& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:storage.ServiceWorkerOriginTrialFeature)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ServiceWorkerOriginTrialFeature::IsInitialized() const
{
    if (_Internal::MissingRequiredFields(_impl_._has_bits_))
        return false;
    return true;
}

void ServiceWorkerOriginTrialFeature::InternalSwap(ServiceWorkerOriginTrialFeature* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.tokens_.InternalSwap(&other->_impl_.tokens_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.name_, lhs_arena, &other->_impl_.name_, rhs_arena);
}

std::string ServiceWorkerOriginTrialFeature::GetTypeName() const
{
    return "storage.ServiceWorkerOriginTrialFeature";
}

// ===================================================================

class ServiceWorkerOriginTrialInfo::_Internal {
public:
};

ServiceWorkerOriginTrialInfo::ServiceWorkerOriginTrialInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:storage.ServiceWorkerOriginTrialInfo)
}
ServiceWorkerOriginTrialInfo::ServiceWorkerOriginTrialInfo(const ServiceWorkerOriginTrialInfo& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ServiceWorkerOriginTrialInfo* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.features_) { from._impl_.features_ }, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:storage.ServiceWorkerOriginTrialInfo)
}

inline void ServiceWorkerOriginTrialInfo::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.features_) { arena }, /*decltype(_impl_._cached_size_)*/ {} };
}

ServiceWorkerOriginTrialInfo::~ServiceWorkerOriginTrialInfo()
{
    // @@protoc_insertion_point(destructor:storage.ServiceWorkerOriginTrialInfo)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ServiceWorkerOriginTrialInfo::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.features_.~RepeatedPtrField();
}

void ServiceWorkerOriginTrialInfo::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ServiceWorkerOriginTrialInfo::Clear()
{
    // @@protoc_insertion_point(message_clear_start:storage.ServiceWorkerOriginTrialInfo)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.features_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ServiceWorkerOriginTrialInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .storage.ServiceWorkerOriginTrialFeature features = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_features(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ServiceWorkerOriginTrialInfo::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:storage.ServiceWorkerOriginTrialInfo)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .storage.ServiceWorkerOriginTrialFeature features = 1;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_features_size()); i < n; i++) {
        const auto& repfield = this->_internal_features(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:storage.ServiceWorkerOriginTrialInfo)
    return target;
}

size_t ServiceWorkerOriginTrialInfo::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:storage.ServiceWorkerOriginTrialInfo)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .storage.ServiceWorkerOriginTrialFeature features = 1;
    total_size += 1UL * this->_internal_features_size();
    for (const auto& msg : this->_impl_.features_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ServiceWorkerOriginTrialInfo::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ServiceWorkerOriginTrialInfo*>(&from));
}

void ServiceWorkerOriginTrialInfo::MergeFrom(const ServiceWorkerOriginTrialInfo& from)
{
    ServiceWorkerOriginTrialInfo* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:storage.ServiceWorkerOriginTrialInfo)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.features_.MergeFrom(from._impl_.features_);
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ServiceWorkerOriginTrialInfo::CopyFrom(const ServiceWorkerOriginTrialInfo& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:storage.ServiceWorkerOriginTrialInfo)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ServiceWorkerOriginTrialInfo::IsInitialized() const
{
    if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.features_))
        return false;
    return true;
}

void ServiceWorkerOriginTrialInfo::InternalSwap(ServiceWorkerOriginTrialInfo* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.features_.InternalSwap(&other->_impl_.features_);
}

std::string ServiceWorkerOriginTrialInfo::GetTypeName() const
{
    return "storage.ServiceWorkerOriginTrialInfo";
}

// ===================================================================

class ServiceWorkerNavigationPreloadState::_Internal {
public:
    using HasBits = decltype(std::declval<ServiceWorkerNavigationPreloadState>()._impl_._has_bits_);
    static void set_has_enabled(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_header(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static bool MissingRequiredFields(const HasBits& has_bits)
    {
        return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
    }
};

ServiceWorkerNavigationPreloadState::ServiceWorkerNavigationPreloadState(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:storage.ServiceWorkerNavigationPreloadState)
}
ServiceWorkerNavigationPreloadState::ServiceWorkerNavigationPreloadState(const ServiceWorkerNavigationPreloadState& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ServiceWorkerNavigationPreloadState* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.header_) {},
        decltype(_impl_.enabled_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.header_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.header_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_header()) {
        _this->_impl_.header_.Set(from._internal_header(), _this->GetArenaForAllocation());
    }
    _this->_impl_.enabled_ = from._impl_.enabled_;
    // @@protoc_insertion_point(copy_constructor:storage.ServiceWorkerNavigationPreloadState)
}

inline void ServiceWorkerNavigationPreloadState::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_)
        Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.header_) {}, decltype(_impl_.enabled_) { false } };
    _impl_.header_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.header_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ServiceWorkerNavigationPreloadState::~ServiceWorkerNavigationPreloadState()
{
    // @@protoc_insertion_point(destructor:storage.ServiceWorkerNavigationPreloadState)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ServiceWorkerNavigationPreloadState::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.header_.Destroy();
}

void ServiceWorkerNavigationPreloadState::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ServiceWorkerNavigationPreloadState::Clear()
{
    // @@protoc_insertion_point(message_clear_start:storage.ServiceWorkerNavigationPreloadState)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.header_.ClearNonDefaultToEmpty();
    }
    _impl_.enabled_ = false;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ServiceWorkerNavigationPreloadState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // required bool enabled = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_enabled(&has_bits);
                _impl_.enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string header = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_header();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ServiceWorkerNavigationPreloadState::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:storage.ServiceWorkerNavigationPreloadState)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // required bool enabled = 1;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_enabled(), target);
    }

    // optional string header = 2;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_header(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:storage.ServiceWorkerNavigationPreloadState)
    return target;
}

size_t ServiceWorkerNavigationPreloadState::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:storage.ServiceWorkerNavigationPreloadState)
    size_t total_size = 0;

    // required bool enabled = 1;
    if (_internal_has_enabled()) {
        total_size += 1 + 1;
    }
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional string header = 2;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_header());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ServiceWorkerNavigationPreloadState::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ServiceWorkerNavigationPreloadState*>(&from));
}

void ServiceWorkerNavigationPreloadState::MergeFrom(const ServiceWorkerNavigationPreloadState& from)
{
    ServiceWorkerNavigationPreloadState* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:storage.ServiceWorkerNavigationPreloadState)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_header(from._internal_header());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.enabled_ = from._impl_.enabled_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ServiceWorkerNavigationPreloadState::CopyFrom(const ServiceWorkerNavigationPreloadState& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:storage.ServiceWorkerNavigationPreloadState)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ServiceWorkerNavigationPreloadState::IsInitialized() const
{
    if (_Internal::MissingRequiredFields(_impl_._has_bits_))
        return false;
    return true;
}

void ServiceWorkerNavigationPreloadState::InternalSwap(ServiceWorkerNavigationPreloadState* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.header_, lhs_arena, &other->_impl_.header_, rhs_arena);
    swap(_impl_.enabled_, other->_impl_.enabled_);
}

std::string ServiceWorkerNavigationPreloadState::GetTypeName() const
{
    return "storage.ServiceWorkerNavigationPreloadState";
}

// ===================================================================

class ServiceWorkerRegistrationData_PolicyContainerPolicies::_Internal {
public:
    using HasBits = decltype(std::declval<ServiceWorkerRegistrationData_PolicyContainerPolicies>()._impl_._has_bits_);
    static void set_has_referrer_policy(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_sandbox_flags(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_ip_address_space(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

ServiceWorkerRegistrationData_PolicyContainerPolicies::ServiceWorkerRegistrationData_PolicyContainerPolicies(
    ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:storage.ServiceWorkerRegistrationData.PolicyContainerPolicies)
}
ServiceWorkerRegistrationData_PolicyContainerPolicies::ServiceWorkerRegistrationData_PolicyContainerPolicies(
    const ServiceWorkerRegistrationData_PolicyContainerPolicies& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ServiceWorkerRegistrationData_PolicyContainerPolicies* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.sandbox_flags_) {},
        decltype(_impl_.ip_address_space_) {}, decltype(_impl_.referrer_policy_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.sandbox_flags_, &from._impl_.sandbox_flags_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.referrer_policy_) - reinterpret_cast<char*>(&_impl_.sandbox_flags_))
            + sizeof(_impl_.referrer_policy_));
    // @@protoc_insertion_point(copy_constructor:storage.ServiceWorkerRegistrationData.PolicyContainerPolicies)
}

inline void ServiceWorkerRegistrationData_PolicyContainerPolicies::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.sandbox_flags_) { 0 },
        decltype(_impl_.ip_address_space_) { 0 }, decltype(_impl_.referrer_policy_) { 1 } };
}

ServiceWorkerRegistrationData_PolicyContainerPolicies::~ServiceWorkerRegistrationData_PolicyContainerPolicies()
{
    // @@protoc_insertion_point(destructor:storage.ServiceWorkerRegistrationData.PolicyContainerPolicies)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ServiceWorkerRegistrationData_PolicyContainerPolicies::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ServiceWorkerRegistrationData_PolicyContainerPolicies::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ServiceWorkerRegistrationData_PolicyContainerPolicies::Clear()
{
    // @@protoc_insertion_point(message_clear_start:storage.ServiceWorkerRegistrationData.PolicyContainerPolicies)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        ::memset(&_impl_.sandbox_flags_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.ip_address_space_) - reinterpret_cast<char*>(&_impl_.sandbox_flags_))
                + sizeof(_impl_.ip_address_space_));
        _impl_.referrer_policy_ = 1;
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ServiceWorkerRegistrationData_PolicyContainerPolicies::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .storage.ServiceWorkerRegistrationData.ReferrerPolicyValue referrer_policy = 1 [default = DEFAULT];
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::storage::ServiceWorkerRegistrationData_ReferrerPolicyValue_IsValid(val))) {
                    _internal_set_referrer_policy(static_cast<::storage::ServiceWorkerRegistrationData_ReferrerPolicyValue>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional int32 sandbox_flags = 2 [default = 0];
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_sandbox_flags(&has_bits);
                _impl_.sandbox_flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .storage.ServiceWorkerRegistrationData.IPAddressSpace ip_address_space = 3 [default = UNKNOWN];
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::storage::ServiceWorkerRegistrationData_IPAddressSpace_IsValid(val))) {
                    _internal_set_ip_address_space(static_cast<::storage::ServiceWorkerRegistrationData_IPAddressSpace>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ServiceWorkerRegistrationData_PolicyContainerPolicies::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:storage.ServiceWorkerRegistrationData.PolicyContainerPolicies)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .storage.ServiceWorkerRegistrationData.ReferrerPolicyValue referrer_policy = 1 [default = DEFAULT];
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(1, this->_internal_referrer_policy(), target);
    }

    // optional int32 sandbox_flags = 2 [default = 0];
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_sandbox_flags(), target);
    }

    // optional .storage.ServiceWorkerRegistrationData.IPAddressSpace ip_address_space = 3 [default = UNKNOWN];
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(3, this->_internal_ip_address_space(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:storage.ServiceWorkerRegistrationData.PolicyContainerPolicies)
    return target;
}

size_t ServiceWorkerRegistrationData_PolicyContainerPolicies::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:storage.ServiceWorkerRegistrationData.PolicyContainerPolicies)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional int32 sandbox_flags = 2 [default = 0];
        if (cached_has_bits & 0x00000001u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_sandbox_flags());
        }

        // optional .storage.ServiceWorkerRegistrationData.IPAddressSpace ip_address_space = 3 [default = UNKNOWN];
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_ip_address_space());
        }

        // optional .storage.ServiceWorkerRegistrationData.ReferrerPolicyValue referrer_policy = 1 [default = DEFAULT];
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_referrer_policy());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ServiceWorkerRegistrationData_PolicyContainerPolicies::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ServiceWorkerRegistrationData_PolicyContainerPolicies*>(&from));
}

void ServiceWorkerRegistrationData_PolicyContainerPolicies::MergeFrom(const ServiceWorkerRegistrationData_PolicyContainerPolicies& from)
{
    ServiceWorkerRegistrationData_PolicyContainerPolicies* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:storage.ServiceWorkerRegistrationData.PolicyContainerPolicies)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_impl_.sandbox_flags_ = from._impl_.sandbox_flags_;
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.ip_address_space_ = from._impl_.ip_address_space_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.referrer_policy_ = from._impl_.referrer_policy_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ServiceWorkerRegistrationData_PolicyContainerPolicies::CopyFrom(const ServiceWorkerRegistrationData_PolicyContainerPolicies& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:storage.ServiceWorkerRegistrationData.PolicyContainerPolicies)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ServiceWorkerRegistrationData_PolicyContainerPolicies::IsInitialized() const
{
    return true;
}

void ServiceWorkerRegistrationData_PolicyContainerPolicies::InternalSwap(ServiceWorkerRegistrationData_PolicyContainerPolicies* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(ServiceWorkerRegistrationData_PolicyContainerPolicies, _impl_.ip_address_space_)
        + sizeof(ServiceWorkerRegistrationData_PolicyContainerPolicies::_impl_.ip_address_space_)
        - PROTOBUF_FIELD_OFFSET(ServiceWorkerRegistrationData_PolicyContainerPolicies, _impl_.sandbox_flags_)>(
        reinterpret_cast<char*>(&_impl_.sandbox_flags_), reinterpret_cast<char*>(&other->_impl_.sandbox_flags_));
    swap(_impl_.referrer_policy_, other->_impl_.referrer_policy_);
}

std::string ServiceWorkerRegistrationData_PolicyContainerPolicies::GetTypeName() const
{
    return "storage.ServiceWorkerRegistrationData.PolicyContainerPolicies";
}

// ===================================================================

class ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern::_Internal {
public:
    using HasBits = decltype(std::declval<ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern>()._impl_._has_bits_);
    static void set_has_value(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern::
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.FixedPattern)
}
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern::
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern(
        const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.value_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.value_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_value()) {
        _this->_impl_.value_.Set(from._internal_value(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.FixedPattern)
}

inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.value_) {} };
    _impl_.value_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern::
    ~ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern()
{
    // @@protoc_insertion_point(destructor:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.FixedPattern)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.value_.Destroy();
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern::Clear()
{
    // @@protoc_insertion_point(message_clear_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.FixedPattern)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.value_.ClearNonDefaultToEmpty();
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string value = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_value();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.FixedPattern)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string value = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_value(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.FixedPattern)
    return target;
}

size_t ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.FixedPattern)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional string value = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_value());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern*>(&from));
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern::MergeFrom(
    const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern& from)
{
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.FixedPattern)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_value()) {
        _this->_internal_set_value(from._internal_value());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern::CopyFrom(
    const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.FixedPattern)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern::IsInitialized() const
{
    return true;
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern::InternalSwap(
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.value_, lhs_arena, &other->_impl_.value_, rhs_arena);
}

std::string ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern::GetTypeName() const
{
    return "storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.FixedPattern";
}

// ===================================================================

class ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern::_Internal {
public:
    using HasBits = decltype(std::declval<ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern>()._impl_._has_bits_);
    static void set_has_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_prefix(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_value(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_suffix(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
};

ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern::
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.WildcardPattern)
}
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern::
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern(
        const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.name_) {},
        decltype(_impl_.prefix_) {}, decltype(_impl_.value_) {}, decltype(_impl_.suffix_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_name()) {
        _this->_impl_.name_.Set(from._internal_name(), _this->GetArenaForAllocation());
    }
    _impl_.prefix_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.prefix_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_prefix()) {
        _this->_impl_.prefix_.Set(from._internal_prefix(), _this->GetArenaForAllocation());
    }
    _impl_.value_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_value()) {
        _this->_impl_.value_.Set(from._internal_value(), _this->GetArenaForAllocation());
    }
    _impl_.suffix_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.suffix_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_suffix()) {
        _this->_impl_.suffix_.Set(from._internal_suffix(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.WildcardPattern)
}

inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.name_) {}, decltype(_impl_.prefix_) {},
        decltype(_impl_.value_) {}, decltype(_impl_.suffix_) {} };
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.prefix_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.prefix_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.suffix_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.suffix_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern::
    ~ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern()
{
    // @@protoc_insertion_point(destructor:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.WildcardPattern)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.name_.Destroy();
    _impl_.prefix_.Destroy();
    _impl_.value_.Destroy();
    _impl_.suffix_.Destroy();
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern::Clear()
{
    // @@protoc_insertion_point(message_clear_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.WildcardPattern)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.name_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.prefix_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            _impl_.value_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000008u) {
            _impl_.suffix_.ClearNonDefaultToEmpty();
        }
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string name = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string prefix = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_prefix();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string value = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_value();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string suffix = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                auto str = _internal_mutable_suffix();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.WildcardPattern)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_name(), target);
    }

    // optional string prefix = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_prefix(), target);
    }

    // optional string value = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->WriteStringMaybeAliased(3, this->_internal_value(), target);
    }

    // optional string suffix = 4;
    if (cached_has_bits & 0x00000008u) {
        target = stream->WriteStringMaybeAliased(4, this->_internal_suffix(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.WildcardPattern)
    return target;
}

size_t ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.WildcardPattern)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        // optional string name = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_name());
        }

        // optional string prefix = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_prefix());
        }

        // optional string value = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_value());
        }

        // optional string suffix = 4;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_suffix());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern*>(&from));
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern::MergeFrom(
    const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern& from)
{
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.WildcardPattern)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_name(from._internal_name());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_prefix(from._internal_prefix());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_set_value(from._internal_value());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_set_suffix(from._internal_suffix());
        }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern::CopyFrom(
    const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.WildcardPattern)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern::IsInitialized() const
{
    return true;
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern::InternalSwap(
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.name_, lhs_arena, &other->_impl_.name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.prefix_, lhs_arena, &other->_impl_.prefix_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.value_, lhs_arena, &other->_impl_.value_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.suffix_, lhs_arena, &other->_impl_.suffix_, rhs_arena);
}

std::string ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern::GetTypeName() const
{
    return "storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.WildcardPattern";
}

// ===================================================================

class ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::_Internal {
public:
    using HasBits = decltype(std::declval<ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part>()._impl_._has_bits_);
    static void set_has_modifier(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern& fixed(
        const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part* msg);
    static const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern& segment_wildcard(
        const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part* msg);
    static const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern& full_wildcard(
        const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part* msg);
};

const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::_Internal::fixed(
    const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part* msg)
{
    return *msg->_impl_.pattern_.fixed_;
}
const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::_Internal::segment_wildcard(
    const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part* msg)
{
    return *msg->_impl_.pattern_.segment_wildcard_;
}
const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::_Internal::full_wildcard(
    const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part* msg)
{
    return *msg->_impl_.pattern_.full_wildcard_;
}
void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::set_allocated_fixed(
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern* fixed)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_pattern();
    if (fixed) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fixed);
        if (message_arena != submessage_arena) {
            fixed = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, fixed, submessage_arena);
        }
        set_has_fixed();
        _impl_.pattern_.fixed_ = fixed;
    }
    // @@protoc_insertion_point(field_set_allocated:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.fixed)
}
void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::set_allocated_segment_wildcard(
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern* segment_wildcard)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_pattern();
    if (segment_wildcard) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(segment_wildcard);
        if (message_arena != submessage_arena) {
            segment_wildcard = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, segment_wildcard, submessage_arena);
        }
        set_has_segment_wildcard();
        _impl_.pattern_.segment_wildcard_ = segment_wildcard;
    }
    // @@protoc_insertion_point(field_set_allocated:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.segment_wildcard)
}
void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::set_allocated_full_wildcard(
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern* full_wildcard)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_pattern();
    if (full_wildcard) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(full_wildcard);
        if (message_arena != submessage_arena) {
            full_wildcard = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, full_wildcard, submessage_arena);
        }
        set_has_full_wildcard();
        _impl_.pattern_.full_wildcard_ = full_wildcard;
    }
    // @@protoc_insertion_point(field_set_allocated:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.full_wildcard)
}
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part(
    ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part)
}
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part(
    const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.modifier_) {},
        decltype(_impl_.pattern_) {}, /*decltype(_impl_._oneof_case_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _this->_impl_.modifier_ = from._impl_.modifier_;
    clear_has_pattern();
    switch (from.pattern_case()) {
    case kFixed: {
        _this->_internal_mutable_fixed()->::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern::MergeFrom(
            from._internal_fixed());
        break;
    }
    case kSegmentWildcard: {
        _this->_internal_mutable_segment_wildcard()
            ->::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern::MergeFrom(
                from._internal_segment_wildcard());
        break;
    }
    case kFullWildcard: {
        _this->_internal_mutable_full_wildcard()
            ->::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern::MergeFrom(from._internal_full_wildcard());
        break;
    }
    case PATTERN_NOT_SET: {
        break;
    }
    }
    // @@protoc_insertion_point(copy_constructor:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part)
}

inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.modifier_) { 0 }, decltype(_impl_.pattern_) {},
        /*decltype(_impl_._oneof_case_)*/ {} };
    clear_has_pattern();
}

ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::~ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part()
{
    // @@protoc_insertion_point(destructor:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (has_pattern()) {
        clear_pattern();
    }
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::clear_pattern()
{
    // @@protoc_insertion_point(one_of_clear_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part)
    switch (pattern_case()) {
    case kFixed: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.pattern_.fixed_;
        }
        break;
    }
    case kSegmentWildcard: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.pattern_.segment_wildcard_;
        }
        break;
    }
    case kFullWildcard: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.pattern_.full_wildcard_;
        }
        break;
    }
    case PATTERN_NOT_SET: {
        break;
    }
    }
    _impl_._oneof_case_[0] = PATTERN_NOT_SET;
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::Clear()
{
    // @@protoc_insertion_point(message_clear_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.modifier_ = 0;
    clear_pattern();
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.Modifier modifier = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier_IsValid(val))) {
                    _internal_set_modifier(static_cast<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.FixedPattern fixed = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_fixed(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.WildcardPattern segment_wildcard = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr = ctx->ParseMessage(_internal_mutable_segment_wildcard(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.WildcardPattern full_wildcard = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                ptr = ctx->ParseMessage(_internal_mutable_full_wildcard(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.Modifier modifier = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(1, this->_internal_modifier(), target);
    }

    switch (pattern_case()) {
    case kFixed: {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::fixed(this), _Internal::fixed(this).GetCachedSize(), target, stream);
        break;
    }
    case kSegmentWildcard: {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            4, _Internal::segment_wildcard(this), _Internal::segment_wildcard(this).GetCachedSize(), target, stream);
        break;
    }
    case kFullWildcard: {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            5, _Internal::full_wildcard(this), _Internal::full_wildcard(this).GetCachedSize(), target, stream);
        break;
    }
    default:;
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part)
    return target;
}

size_t ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.Modifier modifier = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_modifier());
    }

    switch (pattern_case()) {
    // .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.FixedPattern fixed = 2;
    case kFixed: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.pattern_.fixed_);
        break;
    }
    // .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.WildcardPattern segment_wildcard = 4;
    case kSegmentWildcard: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.pattern_.segment_wildcard_);
        break;
    }
    // .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.WildcardPattern full_wildcard = 5;
    case kFullWildcard: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.pattern_.full_wildcard_);
        break;
    }
    case PATTERN_NOT_SET: {
        break;
    }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part*>(&from));
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::MergeFrom(
    const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part& from)
{
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_modifier()) {
        _this->_internal_set_modifier(from._internal_modifier());
    }
    switch (from.pattern_case()) {
    case kFixed: {
        _this->_internal_mutable_fixed()->::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern::MergeFrom(
            from._internal_fixed());
        break;
    }
    case kSegmentWildcard: {
        _this->_internal_mutable_segment_wildcard()
            ->::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern::MergeFrom(
                from._internal_segment_wildcard());
        break;
    }
    case kFullWildcard: {
        _this->_internal_mutable_full_wildcard()
            ->::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern::MergeFrom(from._internal_full_wildcard());
        break;
    }
    case PATTERN_NOT_SET: {
        break;
    }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::CopyFrom(
    const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::IsInitialized() const
{
    return true;
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::InternalSwap(
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    swap(_impl_.modifier_, other->_impl_.modifier_);
    swap(_impl_.pattern_, other->_impl_.pattern_);
    swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

std::string ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::GetTypeName() const
{
    return "storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part";
}

// ===================================================================

class ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options::_Internal {
public:
    using HasBits = decltype(std::declval<ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options>()._impl_._has_bits_);
    static void set_has_ignore_case(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options(
    ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Options)
}
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options(
    const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.ignore_case_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _this->_impl_.ignore_case_ = from._impl_.ignore_case_;
    // @@protoc_insertion_point(copy_constructor:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Options)
}

inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.ignore_case_) { false } };
}

ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options::~ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options()
{
    // @@protoc_insertion_point(destructor:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Options)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options::Clear()
{
    // @@protoc_insertion_point(message_clear_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Options)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.ignore_case_ = false;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional bool ignore_case = 1 [default = false];
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_ignore_case(&has_bits);
                _impl_.ignore_case_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Options)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional bool ignore_case = 1 [default = false];
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_ignore_case(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Options)
    return target;
}

size_t ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Options)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional bool ignore_case = 1 [default = false];
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + 1;
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options*>(&from));
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options::MergeFrom(
    const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options& from)
{
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Options)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_ignore_case()) {
        _this->_internal_set_ignore_case(from._internal_ignore_case());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options::CopyFrom(
    const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Options)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options::IsInitialized() const
{
    return true;
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options::InternalSwap(
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    swap(_impl_.ignore_case_, other->_impl_.ignore_case_);
}

std::string ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options::GetTypeName() const
{
    return "storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Options";
}

// ===================================================================

class ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::_Internal {
public:
    using HasBits = decltype(std::declval<ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern>()._impl_._has_bits_);
    static const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options& options(
        const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern* msg);
    static void set_has_options(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::_Internal::options(
    const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern* msg)
{
    return *msg->_impl_.options_;
}
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern(
    ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern)
}
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern(
    const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.legacy_pathname_) { from._impl_.legacy_pathname_ }, decltype(_impl_.hostname_) { from._impl_.hostname_ },
        decltype(_impl_.protocol_) { from._impl_.protocol_ }, decltype(_impl_.username_) { from._impl_.username_ },
        decltype(_impl_.password_) { from._impl_.password_ }, decltype(_impl_.port_) { from._impl_.port_ },
        decltype(_impl_.pathname_) { from._impl_.pathname_ }, decltype(_impl_.search_) { from._impl_.search_ }, decltype(_impl_.hash_) { from._impl_.hash_ },
        decltype(_impl_.options_) { nullptr } };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_options()) {
        _this->_impl_.options_ = new ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options(*from._impl_.options_);
    }
    // @@protoc_insertion_point(copy_constructor:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern)
}

inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.legacy_pathname_) { arena },
        decltype(_impl_.hostname_) { arena }, decltype(_impl_.protocol_) { arena }, decltype(_impl_.username_) { arena }, decltype(_impl_.password_) { arena },
        decltype(_impl_.port_) { arena }, decltype(_impl_.pathname_) { arena }, decltype(_impl_.search_) { arena }, decltype(_impl_.hash_) { arena },
        decltype(_impl_.options_) { nullptr } };
}

ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::~ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern()
{
    // @@protoc_insertion_point(destructor:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.legacy_pathname_.~RepeatedPtrField();
    _impl_.hostname_.~RepeatedPtrField();
    _impl_.protocol_.~RepeatedPtrField();
    _impl_.username_.~RepeatedPtrField();
    _impl_.password_.~RepeatedPtrField();
    _impl_.port_.~RepeatedPtrField();
    _impl_.pathname_.~RepeatedPtrField();
    _impl_.search_.~RepeatedPtrField();
    _impl_.hash_.~RepeatedPtrField();
    if (this != internal_default_instance())
        delete _impl_.options_;
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::Clear()
{
    // @@protoc_insertion_point(message_clear_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.legacy_pathname_.Clear();
    _impl_.hostname_.Clear();
    _impl_.protocol_.Clear();
    _impl_.username_.Clear();
    _impl_.password_.Clear();
    _impl_.port_.Clear();
    _impl_.pathname_.Clear();
    _impl_.search_.Clear();
    _impl_.hash_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        GOOGLE_DCHECK(_impl_.options_ != nullptr);
        _impl_.options_->Clear();
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part legacy_pathname = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_legacy_pathname(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        // repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part hostname = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_hostname(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
            } else
                goto handle_unusual;
            continue;
        // repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part protocol = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_protocol(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
            } else
                goto handle_unusual;
            continue;
        // repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part username = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_username(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
            } else
                goto handle_unusual;
            continue;
        // repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part password = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_password(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
            } else
                goto handle_unusual;
            continue;
        // repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part port = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_port(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
            } else
                goto handle_unusual;
            continue;
        // repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part pathname = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_pathname(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
            } else
                goto handle_unusual;
            continue;
        // repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part search = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_search(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
            } else
                goto handle_unusual;
            continue;
        // repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part hash = 9;
        case 9:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_hash(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Options options = 10;
        case 10:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
                ptr = ctx->ParseMessage(_internal_mutable_options(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part legacy_pathname = 1;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_legacy_pathname_size()); i < n; i++) {
        const auto& repfield = this->_internal_legacy_pathname(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
    }

    // repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part hostname = 2;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_hostname_size()); i < n; i++) {
        const auto& repfield = this->_internal_hostname(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
    }

    // repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part protocol = 3;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_protocol_size()); i < n; i++) {
        const auto& repfield = this->_internal_protocol(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
    }

    // repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part username = 4;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_username_size()); i < n; i++) {
        const auto& repfield = this->_internal_username(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
    }

    // repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part password = 5;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_password_size()); i < n; i++) {
        const auto& repfield = this->_internal_password(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
    }

    // repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part port = 6;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_port_size()); i < n; i++) {
        const auto& repfield = this->_internal_port(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
    }

    // repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part pathname = 7;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_pathname_size()); i < n; i++) {
        const auto& repfield = this->_internal_pathname(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
    }

    // repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part search = 8;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_search_size()); i < n; i++) {
        const auto& repfield = this->_internal_search(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(8, repfield, repfield.GetCachedSize(), target, stream);
    }

    // repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part hash = 9;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_hash_size()); i < n; i++) {
        const auto& repfield = this->_internal_hash(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(9, repfield, repfield.GetCachedSize(), target, stream);
    }

    cached_has_bits = _impl_._has_bits_[0];
    // optional .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Options options = 10;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            10, _Internal::options(this), _Internal::options(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern)
    return target;
}

size_t ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part legacy_pathname = 1;
    total_size += 1UL * this->_internal_legacy_pathname_size();
    for (const auto& msg : this->_impl_.legacy_pathname_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part hostname = 2;
    total_size += 1UL * this->_internal_hostname_size();
    for (const auto& msg : this->_impl_.hostname_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part protocol = 3;
    total_size += 1UL * this->_internal_protocol_size();
    for (const auto& msg : this->_impl_.protocol_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part username = 4;
    total_size += 1UL * this->_internal_username_size();
    for (const auto& msg : this->_impl_.username_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part password = 5;
    total_size += 1UL * this->_internal_password_size();
    for (const auto& msg : this->_impl_.password_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part port = 6;
    total_size += 1UL * this->_internal_port_size();
    for (const auto& msg : this->_impl_.port_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part pathname = 7;
    total_size += 1UL * this->_internal_pathname_size();
    for (const auto& msg : this->_impl_.pathname_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part search = 8;
    total_size += 1UL * this->_internal_search_size();
    for (const auto& msg : this->_impl_.search_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part hash = 9;
    total_size += 1UL * this->_internal_hash_size();
    for (const auto& msg : this->_impl_.hash_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // optional .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Options options = 10;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.options_);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern*>(&from));
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::MergeFrom(
    const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern& from)
{
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.legacy_pathname_.MergeFrom(from._impl_.legacy_pathname_);
    _this->_impl_.hostname_.MergeFrom(from._impl_.hostname_);
    _this->_impl_.protocol_.MergeFrom(from._impl_.protocol_);
    _this->_impl_.username_.MergeFrom(from._impl_.username_);
    _this->_impl_.password_.MergeFrom(from._impl_.password_);
    _this->_impl_.port_.MergeFrom(from._impl_.port_);
    _this->_impl_.pathname_.MergeFrom(from._impl_.pathname_);
    _this->_impl_.search_.MergeFrom(from._impl_.search_);
    _this->_impl_.hash_.MergeFrom(from._impl_.hash_);
    if (from._internal_has_options()) {
        _this->_internal_mutable_options()->::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options::MergeFrom(
            from._internal_options());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::CopyFrom(
    const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::IsInitialized() const
{
    return true;
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::InternalSwap(
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.legacy_pathname_.InternalSwap(&other->_impl_.legacy_pathname_);
    _impl_.hostname_.InternalSwap(&other->_impl_.hostname_);
    _impl_.protocol_.InternalSwap(&other->_impl_.protocol_);
    _impl_.username_.InternalSwap(&other->_impl_.username_);
    _impl_.password_.InternalSwap(&other->_impl_.password_);
    _impl_.port_.InternalSwap(&other->_impl_.port_);
    _impl_.pathname_.InternalSwap(&other->_impl_.pathname_);
    _impl_.search_.InternalSwap(&other->_impl_.search_);
    _impl_.hash_.InternalSwap(&other->_impl_.hash_);
    swap(_impl_.options_, other->_impl_.options_);
}

std::string ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::GetTypeName() const
{
    return "storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern";
}

// ===================================================================

class ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::_Internal {
public:
    using HasBits = decltype(std::declval<ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request>()._impl_._has_bits_);
    static void set_has_method(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_mode(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_destination(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
};

ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request(
    ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.Request)
}
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request(
    const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.method_) {},
        decltype(_impl_.mode_) {}, decltype(_impl_.destination_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.method_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.method_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_method()) {
        _this->_impl_.method_.Set(from._internal_method(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.mode_, &from._impl_.mode_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.destination_) - reinterpret_cast<char*>(&_impl_.mode_)) + sizeof(_impl_.destination_));
    // @@protoc_insertion_point(copy_constructor:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.Request)
}

inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.method_) {}, decltype(_impl_.mode_) { 0 },
        decltype(_impl_.destination_) { 0 } };
    _impl_.method_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.method_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::~ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request()
{
    // @@protoc_insertion_point(destructor:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.Request)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.method_.Destroy();
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::Clear()
{
    // @@protoc_insertion_point(message_clear_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.Request)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.method_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000006u) {
        ::memset(&_impl_.mode_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.destination_) - reinterpret_cast<char*>(&_impl_.mode_)) + sizeof(_impl_.destination_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string method = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_method();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.Request.Mode mode = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode_IsValid(val))) {
                    _internal_set_mode(static_cast<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.Request.Destination destination = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_IsValid(val))) {
                    _internal_set_destination(static_cast<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.Request)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string method = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_method(), target);
    }

    // optional .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.Request.Mode mode = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(2, this->_internal_mode(), target);
    }

    // optional .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.Request.Destination destination = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(3, this->_internal_destination(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.Request)
    return target;
}

size_t ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.Request)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional string method = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_method());
        }

        // optional .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.Request.Mode mode = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_mode());
        }

        // optional .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.Request.Destination destination = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_destination());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request*>(&from));
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::MergeFrom(
    const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request& from)
{
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.Request)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_method(from._internal_method());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.mode_ = from._impl_.mode_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.destination_ = from._impl_.destination_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::CopyFrom(
    const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.Request)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::IsInitialized() const
{
    return true;
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::InternalSwap(ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.method_, lhs_arena, &other->_impl_.method_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request, _impl_.destination_)
        + sizeof(ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::_impl_.destination_)
        - PROTOBUF_FIELD_OFFSET(ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request, _impl_.mode_)>(
        reinterpret_cast<char*>(&_impl_.mode_), reinterpret_cast<char*>(&other->_impl_.mode_));
}

std::string ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::GetTypeName() const
{
    return "storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.Request";
}

// ===================================================================

class ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus::_Internal {
public:
    using HasBits = decltype(std::declval<ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus>()._impl_._has_bits_);
    static void set_has_status(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus(
    ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.RunningStatus)
}
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus(
    const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.status_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _this->_impl_.status_ = from._impl_.status_;
    // @@protoc_insertion_point(copy_constructor:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.RunningStatus)
}

inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.status_) { 0 } };
}

ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus::~ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus()
{
    // @@protoc_insertion_point(destructor:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.RunningStatus)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus::Clear()
{
    // @@protoc_insertion_point(message_clear_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.RunningStatus)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.status_ = 0;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.RunningStatus.Status status = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_Status_IsValid(val))) {
                    _internal_set_status(static_cast<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_Status>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.RunningStatus)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.RunningStatus.Status status = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(1, this->_internal_status(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.RunningStatus)
    return target;
}

size_t ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.RunningStatus)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.RunningStatus.Status status = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_status());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus*>(&from));
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus::MergeFrom(
    const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus& from)
{
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.RunningStatus)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_status()) {
        _this->_internal_set_status(from._internal_status());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus::CopyFrom(
    const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.RunningStatus)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus::IsInitialized() const
{
    return true;
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus::InternalSwap(
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    swap(_impl_.status_, other->_impl_.status_);
}

std::string ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus::GetTypeName() const
{
    return "storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.RunningStatus";
}

// ===================================================================

class ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject::_Internal {
public:
};

ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject(
    ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.ConditionObject)
}
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject(
    const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.conditions_) { from._impl_.conditions_ }, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.ConditionObject)
}

inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.conditions_) { arena }, /*decltype(_impl_._cached_size_)*/ {} };
}

ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject::~ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject()
{
    // @@protoc_insertion_point(destructor:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.ConditionObject)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.conditions_.~RepeatedPtrField();
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject::Clear()
{
    // @@protoc_insertion_point(message_clear_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.ConditionObject)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.conditions_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition conditions = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_conditions(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.ConditionObject)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition conditions = 1;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_conditions_size()); i < n; i++) {
        const auto& repfield = this->_internal_conditions(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.ConditionObject)
    return target;
}

size_t ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.ConditionObject)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition conditions = 1;
    total_size += 1UL * this->_internal_conditions_size();
    for (const auto& msg : this->_impl_.conditions_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject*>(&from));
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject::MergeFrom(
    const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject& from)
{
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.ConditionObject)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.conditions_.MergeFrom(from._impl_.conditions_);
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject::CopyFrom(
    const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.ConditionObject)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject::IsInitialized() const
{
    if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.conditions_))
        return false;
    return true;
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject::InternalSwap(
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.conditions_.InternalSwap(&other->_impl_.conditions_);
}

std::string ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject::GetTypeName() const
{
    return "storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.ConditionObject";
}

// ===================================================================

class ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition::_Internal {
public:
};

ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition(
    ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.OrCondition)
}
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition(
    const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.objects_) { from._impl_.objects_ }, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.OrCondition)
}

inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.objects_) { arena }, /*decltype(_impl_._cached_size_)*/ {} };
}

ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition::~ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition()
{
    // @@protoc_insertion_point(destructor:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.OrCondition)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.objects_.~RepeatedPtrField();
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition::Clear()
{
    // @@protoc_insertion_point(message_clear_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.OrCondition)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.objects_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.ConditionObject objects = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_objects(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.OrCondition)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.ConditionObject objects = 1;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_objects_size()); i < n; i++) {
        const auto& repfield = this->_internal_objects(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.OrCondition)
    return target;
}

size_t ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.OrCondition)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.ConditionObject objects = 1;
    total_size += 1UL * this->_internal_objects_size();
    for (const auto& msg : this->_impl_.objects_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition*>(&from));
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition::MergeFrom(
    const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition& from)
{
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.OrCondition)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.objects_.MergeFrom(from._impl_.objects_);
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition::CopyFrom(
    const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.OrCondition)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition::IsInitialized() const
{
    if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.objects_))
        return false;
    return true;
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition::InternalSwap(
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.objects_.InternalSwap(&other->_impl_.objects_);
}

std::string ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition::GetTypeName() const
{
    return "storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.OrCondition";
}

// ===================================================================

class ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition::_Internal {
public:
    using HasBits = decltype(std::declval<ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition>()._impl_._has_bits_);
    static const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject& object(
        const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition* msg);
    static void set_has_object(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static bool MissingRequiredFields(const HasBits& has_bits)
    {
        return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
    }
};

const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition::_Internal::object(
    const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition* msg)
{
    return *msg->_impl_.object_;
}
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition(
    ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.NotCondition)
}
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition(
    const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.object_) { nullptr } };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_object()) {
        _this->_impl_.object_ = new ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject(*from._impl_.object_);
    }
    // @@protoc_insertion_point(copy_constructor:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.NotCondition)
}

inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.object_) { nullptr } };
}

ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition::~ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition()
{
    // @@protoc_insertion_point(destructor:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.NotCondition)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (this != internal_default_instance())
        delete _impl_.object_;
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition::Clear()
{
    // @@protoc_insertion_point(message_clear_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.NotCondition)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        GOOGLE_DCHECK(_impl_.object_ != nullptr);
        _impl_.object_->Clear();
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // required .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.ConditionObject object = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_object(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.NotCondition)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // required .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.ConditionObject object = 1;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::object(this), _Internal::object(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.NotCondition)
    return target;
}

size_t ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.NotCondition)
    size_t total_size = 0;

    // required .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.ConditionObject object = 1;
    if (_internal_has_object()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.object_);
    }
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition*>(&from));
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition::MergeFrom(
    const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition& from)
{
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.NotCondition)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_object()) {
        _this->_internal_mutable_object()->::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject::MergeFrom(
            from._internal_object());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition::CopyFrom(
    const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.NotCondition)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition::IsInitialized() const
{
    if (_Internal::MissingRequiredFields(_impl_._has_bits_))
        return false;
    if (_internal_has_object()) {
        if (!_impl_.object_->IsInitialized())
            return false;
    }
    return true;
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition::InternalSwap(
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    swap(_impl_.object_, other->_impl_.object_);
}

std::string ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition::GetTypeName() const
{
    return "storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.NotCondition";
}

// ===================================================================

class ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::_Internal {
public:
    static const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern& url_pattern(
        const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition* msg);
    static const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request& request(
        const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition* msg);
    static const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus& running_status(
        const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition* msg);
    static const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition& or_condition(
        const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition* msg);
    static const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition& not_condition(
        const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition* msg);
};

const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::_Internal::url_pattern(const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition* msg)
{
    return *msg->_impl_.condition_.url_pattern_;
}
const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::_Internal::request(const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition* msg)
{
    return *msg->_impl_.condition_.request_;
}
const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::_Internal::running_status(const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition* msg)
{
    return *msg->_impl_.condition_.running_status_;
}
const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::_Internal::or_condition(const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition* msg)
{
    return *msg->_impl_.condition_.or_condition_;
}
const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::_Internal::not_condition(const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition* msg)
{
    return *msg->_impl_.condition_.not_condition_;
}
void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::set_allocated_url_pattern(
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern* url_pattern)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_condition();
    if (url_pattern) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(url_pattern);
        if (message_arena != submessage_arena) {
            url_pattern = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, url_pattern, submessage_arena);
        }
        set_has_url_pattern();
        _impl_.condition_.url_pattern_ = url_pattern;
    }
    // @@protoc_insertion_point(field_set_allocated:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.url_pattern)
}
void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::set_allocated_request(
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request* request)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_condition();
    if (request) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(request);
        if (message_arena != submessage_arena) {
            request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, request, submessage_arena);
        }
        set_has_request();
        _impl_.condition_.request_ = request;
    }
    // @@protoc_insertion_point(field_set_allocated:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.request)
}
void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::set_allocated_running_status(
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus* running_status)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_condition();
    if (running_status) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(running_status);
        if (message_arena != submessage_arena) {
            running_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, running_status, submessage_arena);
        }
        set_has_running_status();
        _impl_.condition_.running_status_ = running_status;
    }
    // @@protoc_insertion_point(field_set_allocated:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.running_status)
}
void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::set_allocated_or_condition(
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition* or_condition)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_condition();
    if (or_condition) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(or_condition);
        if (message_arena != submessage_arena) {
            or_condition = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, or_condition, submessage_arena);
        }
        set_has_or_condition();
        _impl_.condition_.or_condition_ = or_condition;
    }
    // @@protoc_insertion_point(field_set_allocated:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.or_condition)
}
void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::set_allocated_not_condition(
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition* not_condition)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_condition();
    if (not_condition) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(not_condition);
        if (message_arena != submessage_arena) {
            not_condition = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, not_condition, submessage_arena);
        }
        set_has_not_condition();
        _impl_.condition_.not_condition_ = not_condition;
    }
    // @@protoc_insertion_point(field_set_allocated:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.not_condition)
}
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition(
    ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition)
}
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition(
    const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.condition_) {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_._oneof_case_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    clear_has_condition();
    switch (from.condition_case()) {
    case kUrlPattern: {
        _this->_internal_mutable_url_pattern()->::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::MergeFrom(
            from._internal_url_pattern());
        break;
    }
    case kRequest: {
        _this->_internal_mutable_request()->::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::MergeFrom(from._internal_request());
        break;
    }
    case kRunningStatus: {
        _this->_internal_mutable_running_status()->::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus::MergeFrom(
            from._internal_running_status());
        break;
    }
    case kOrCondition: {
        _this->_internal_mutable_or_condition()->::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition::MergeFrom(
            from._internal_or_condition());
        break;
    }
    case kNotCondition: {
        _this->_internal_mutable_not_condition()->::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition::MergeFrom(
            from._internal_not_condition());
        break;
    }
    case CONDITION_NOT_SET: {
        break;
    }
    }
    // @@protoc_insertion_point(copy_constructor:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition)
}

inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.condition_) {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_._oneof_case_)*/ {} };
    clear_has_condition();
}

ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::~ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition()
{
    // @@protoc_insertion_point(destructor:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (has_condition()) {
        clear_condition();
    }
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::clear_condition()
{
    // @@protoc_insertion_point(one_of_clear_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition)
    switch (condition_case()) {
    case kUrlPattern: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.condition_.url_pattern_;
        }
        break;
    }
    case kRequest: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.condition_.request_;
        }
        break;
    }
    case kRunningStatus: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.condition_.running_status_;
        }
        break;
    }
    case kOrCondition: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.condition_.or_condition_;
        }
        break;
    }
    case kNotCondition: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.condition_.not_condition_;
        }
        break;
    }
    case CONDITION_NOT_SET: {
        break;
    }
    }
    _impl_._oneof_case_[0] = CONDITION_NOT_SET;
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::Clear()
{
    // @@protoc_insertion_point(message_clear_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    clear_condition();
    _internal_metadata_.Clear<std::string>();
}

const char* ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern url_pattern = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_url_pattern(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.Request request = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_request(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.RunningStatus running_status = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr = ctx->ParseMessage(_internal_mutable_running_status(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.OrCondition or_condition = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr = ctx->ParseMessage(_internal_mutable_or_condition(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.NotCondition not_condition = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                ptr = ctx->ParseMessage(_internal_mutable_not_condition(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    switch (condition_case()) {
    case kUrlPattern: {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::url_pattern(this), _Internal::url_pattern(this).GetCachedSize(), target, stream);
        break;
    }
    case kRequest: {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::request(this), _Internal::request(this).GetCachedSize(), target, stream);
        break;
    }
    case kRunningStatus: {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            3, _Internal::running_status(this), _Internal::running_status(this).GetCachedSize(), target, stream);
        break;
    }
    case kOrCondition: {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            4, _Internal::or_condition(this), _Internal::or_condition(this).GetCachedSize(), target, stream);
        break;
    }
    case kNotCondition: {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            5, _Internal::not_condition(this), _Internal::not_condition(this).GetCachedSize(), target, stream);
        break;
    }
    default:;
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition)
    return target;
}

size_t ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    switch (condition_case()) {
    // .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern url_pattern = 1;
    case kUrlPattern: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.condition_.url_pattern_);
        break;
    }
    // .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.Request request = 2;
    case kRequest: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.condition_.request_);
        break;
    }
    // .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.RunningStatus running_status = 3;
    case kRunningStatus: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.condition_.running_status_);
        break;
    }
    // .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.OrCondition or_condition = 4;
    case kOrCondition: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.condition_.or_condition_);
        break;
    }
    // .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.NotCondition not_condition = 5;
    case kNotCondition: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.condition_.not_condition_);
        break;
    }
    case CONDITION_NOT_SET: {
        break;
    }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition*>(&from));
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::MergeFrom(const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition& from)
{
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    switch (from.condition_case()) {
    case kUrlPattern: {
        _this->_internal_mutable_url_pattern()->::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::MergeFrom(
            from._internal_url_pattern());
        break;
    }
    case kRequest: {
        _this->_internal_mutable_request()->::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::MergeFrom(from._internal_request());
        break;
    }
    case kRunningStatus: {
        _this->_internal_mutable_running_status()->::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus::MergeFrom(
            from._internal_running_status());
        break;
    }
    case kOrCondition: {
        _this->_internal_mutable_or_condition()->::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition::MergeFrom(
            from._internal_or_condition());
        break;
    }
    case kNotCondition: {
        _this->_internal_mutable_not_condition()->::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition::MergeFrom(
            from._internal_not_condition());
        break;
    }
    case CONDITION_NOT_SET: {
        break;
    }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::CopyFrom(const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::IsInitialized() const
{
    switch (condition_case()) {
    case kUrlPattern: {
        break;
    }
    case kRequest: {
        break;
    }
    case kRunningStatus: {
        break;
    }
    case kOrCondition: {
        if (_internal_has_or_condition()) {
            if (!_impl_.condition_.or_condition_->IsInitialized())
                return false;
        }
        break;
    }
    case kNotCondition: {
        if (_internal_has_not_condition()) {
            if (!_impl_.condition_.not_condition_->IsInitialized())
                return false;
        }
        break;
    }
    case CONDITION_NOT_SET: {
        break;
    }
    }
    return true;
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::InternalSwap(ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_.condition_, other->_impl_.condition_);
    swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

std::string ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::GetTypeName() const
{
    return "storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition";
}

// ===================================================================

class ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource::_Internal {
public:
};

ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource(
    ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.NetworkSource)
}
ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource(
    const ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.NetworkSource)
}

inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { /*decltype(_impl_._cached_size_)*/ {} };
}

ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource::~ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource()
{
    // @@protoc_insertion_point(destructor:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.NetworkSource)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource::Clear()
{
    // @@protoc_insertion_point(message_clear_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.NetworkSource)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _internal_metadata_.Clear<std::string>();
}

const char* ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.NetworkSource)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.NetworkSource)
    return target;
}

size_t ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.NetworkSource)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource*>(&from));
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource::MergeFrom(
    const ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource& from)
{
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.NetworkSource)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource::CopyFrom(
    const ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.NetworkSource)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource::IsInitialized() const
{
    return true;
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource::InternalSwap(
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource::GetTypeName() const
{
    return "storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.NetworkSource";
}

// ===================================================================

class ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource::_Internal {
public:
};

ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource(
    ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.RaceSource)
}
ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource(
    const ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.RaceSource)
}

inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { /*decltype(_impl_._cached_size_)*/ {} };
}

ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource::~ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource()
{
    // @@protoc_insertion_point(destructor:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.RaceSource)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource::Clear()
{
    // @@protoc_insertion_point(message_clear_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.RaceSource)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _internal_metadata_.Clear<std::string>();
}

const char* ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.RaceSource)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.RaceSource)
    return target;
}

size_t ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.RaceSource)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource*>(&from));
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource::MergeFrom(
    const ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource& from)
{
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.RaceSource)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource::CopyFrom(
    const ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.RaceSource)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource::IsInitialized() const
{
    return true;
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource::InternalSwap(ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource::GetTypeName() const
{
    return "storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.RaceSource";
}

// ===================================================================

class ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource::_Internal {
public:
};

ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource(
    ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.FetchEventSource)
}
ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource(
    const ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.FetchEventSource)
}

inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { /*decltype(_impl_._cached_size_)*/ {} };
}

ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource::~ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource()
{
    // @@protoc_insertion_point(destructor:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.FetchEventSource)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource::Clear()
{
    // @@protoc_insertion_point(message_clear_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.FetchEventSource)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _internal_metadata_.Clear<std::string>();
}

const char* ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.FetchEventSource)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.FetchEventSource)
    return target;
}

size_t ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.FetchEventSource)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource*>(&from));
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource::MergeFrom(
    const ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource& from)
{
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.FetchEventSource)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource::CopyFrom(
    const ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.FetchEventSource)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource::IsInitialized() const
{
    return true;
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource::InternalSwap(
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource::GetTypeName() const
{
    return "storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.FetchEventSource";
}

// ===================================================================

class ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource::_Internal {
public:
    using HasBits = decltype(std::declval<ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource>()._impl_._has_bits_);
    static void set_has_cache_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource(
    ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.CacheSource)
}
ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource(
    const ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.cache_name_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.cache_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cache_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_cache_name()) {
        _this->_impl_.cache_name_.Set(from._internal_cache_name(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.CacheSource)
}

inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.cache_name_) {} };
    _impl_.cache_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cache_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource::~ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource()
{
    // @@protoc_insertion_point(destructor:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.CacheSource)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.cache_name_.Destroy();
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource::Clear()
{
    // @@protoc_insertion_point(message_clear_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.CacheSource)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.cache_name_.ClearNonDefaultToEmpty();
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string cache_name = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_cache_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.CacheSource)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string cache_name = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_cache_name(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.CacheSource)
    return target;
}

size_t ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.CacheSource)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional string cache_name = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_cache_name());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource*>(&from));
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource::MergeFrom(
    const ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource& from)
{
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.CacheSource)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_cache_name()) {
        _this->_internal_set_cache_name(from._internal_cache_name());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource::CopyFrom(
    const ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.CacheSource)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource::IsInitialized() const
{
    return true;
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource::InternalSwap(
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.cache_name_, lhs_arena, &other->_impl_.cache_name_, rhs_arena);
}

std::string ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource::GetTypeName() const
{
    return "storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.CacheSource";
}

// ===================================================================

class ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::_Internal {
public:
    static const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource& network_source(
        const ServiceWorkerRegistrationData_RouterRules_RuleV1_Source* msg);
    static const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource& race_source(
        const ServiceWorkerRegistrationData_RouterRules_RuleV1_Source* msg);
    static const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource& fetch_event_source(
        const ServiceWorkerRegistrationData_RouterRules_RuleV1_Source* msg);
    static const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource& cache_source(
        const ServiceWorkerRegistrationData_RouterRules_RuleV1_Source* msg);
};

const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::_Internal::network_source(const ServiceWorkerRegistrationData_RouterRules_RuleV1_Source* msg)
{
    return *msg->_impl_.source_.network_source_;
}
const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::_Internal::race_source(const ServiceWorkerRegistrationData_RouterRules_RuleV1_Source* msg)
{
    return *msg->_impl_.source_.race_source_;
}
const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::_Internal::fetch_event_source(const ServiceWorkerRegistrationData_RouterRules_RuleV1_Source* msg)
{
    return *msg->_impl_.source_.fetch_event_source_;
}
const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::_Internal::cache_source(const ServiceWorkerRegistrationData_RouterRules_RuleV1_Source* msg)
{
    return *msg->_impl_.source_.cache_source_;
}
void ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::set_allocated_network_source(
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource* network_source)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_source();
    if (network_source) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(network_source);
        if (message_arena != submessage_arena) {
            network_source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, network_source, submessage_arena);
        }
        set_has_network_source();
        _impl_.source_.network_source_ = network_source;
    }
    // @@protoc_insertion_point(field_set_allocated:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.network_source)
}
void ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::set_allocated_race_source(
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource* race_source)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_source();
    if (race_source) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(race_source);
        if (message_arena != submessage_arena) {
            race_source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, race_source, submessage_arena);
        }
        set_has_race_source();
        _impl_.source_.race_source_ = race_source;
    }
    // @@protoc_insertion_point(field_set_allocated:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.race_source)
}
void ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::set_allocated_fetch_event_source(
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource* fetch_event_source)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_source();
    if (fetch_event_source) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fetch_event_source);
        if (message_arena != submessage_arena) {
            fetch_event_source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, fetch_event_source, submessage_arena);
        }
        set_has_fetch_event_source();
        _impl_.source_.fetch_event_source_ = fetch_event_source;
    }
    // @@protoc_insertion_point(field_set_allocated:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.fetch_event_source)
}
void ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::set_allocated_cache_source(
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource* cache_source)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_source();
    if (cache_source) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cache_source);
        if (message_arena != submessage_arena) {
            cache_source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, cache_source, submessage_arena);
        }
        set_has_cache_source();
        _impl_.source_.cache_source_ = cache_source;
    }
    // @@protoc_insertion_point(field_set_allocated:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.cache_source)
}
ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source(
    ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source)
}
ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source(
    const ServiceWorkerRegistrationData_RouterRules_RuleV1_Source& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Source* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.source_) {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_._oneof_case_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    clear_has_source();
    switch (from.source_case()) {
    case kNetworkSource: {
        _this->_internal_mutable_network_source()->::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource::MergeFrom(
            from._internal_network_source());
        break;
    }
    case kRaceSource: {
        _this->_internal_mutable_race_source()->::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource::MergeFrom(
            from._internal_race_source());
        break;
    }
    case kFetchEventSource: {
        _this->_internal_mutable_fetch_event_source()->::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource::MergeFrom(
            from._internal_fetch_event_source());
        break;
    }
    case kCacheSource: {
        _this->_internal_mutable_cache_source()->::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource::MergeFrom(
            from._internal_cache_source());
        break;
    }
    case SOURCE_NOT_SET: {
        break;
    }
    }
    // @@protoc_insertion_point(copy_constructor:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source)
}

inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.source_) {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_._oneof_case_)*/ {} };
    clear_has_source();
}

ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::~ServiceWorkerRegistrationData_RouterRules_RuleV1_Source()
{
    // @@protoc_insertion_point(destructor:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (has_source()) {
        clear_source();
    }
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::clear_source()
{
    // @@protoc_insertion_point(one_of_clear_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source)
    switch (source_case()) {
    case kNetworkSource: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.source_.network_source_;
        }
        break;
    }
    case kRaceSource: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.source_.race_source_;
        }
        break;
    }
    case kFetchEventSource: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.source_.fetch_event_source_;
        }
        break;
    }
    case kCacheSource: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.source_.cache_source_;
        }
        break;
    }
    case SOURCE_NOT_SET: {
        break;
    }
    }
    _impl_._oneof_case_[0] = SOURCE_NOT_SET;
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::Clear()
{
    // @@protoc_insertion_point(message_clear_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    clear_source();
    _internal_metadata_.Clear<std::string>();
}

const char* ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.NetworkSource network_source = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_network_source(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.RaceSource race_source = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_race_source(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.FetchEventSource fetch_event_source = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr = ctx->ParseMessage(_internal_mutable_fetch_event_source(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.CacheSource cache_source = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr = ctx->ParseMessage(_internal_mutable_cache_source(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    switch (source_case()) {
    case kNetworkSource: {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::network_source(this), _Internal::network_source(this).GetCachedSize(), target, stream);
        break;
    }
    case kRaceSource: {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::race_source(this), _Internal::race_source(this).GetCachedSize(), target, stream);
        break;
    }
    case kFetchEventSource: {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            3, _Internal::fetch_event_source(this), _Internal::fetch_event_source(this).GetCachedSize(), target, stream);
        break;
    }
    case kCacheSource: {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            4, _Internal::cache_source(this), _Internal::cache_source(this).GetCachedSize(), target, stream);
        break;
    }
    default:;
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source)
    return target;
}

size_t ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    switch (source_case()) {
    // .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.NetworkSource network_source = 1;
    case kNetworkSource: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.source_.network_source_);
        break;
    }
    // .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.RaceSource race_source = 2;
    case kRaceSource: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.source_.race_source_);
        break;
    }
    // .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.FetchEventSource fetch_event_source = 3;
    case kFetchEventSource: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.source_.fetch_event_source_);
        break;
    }
    // .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.CacheSource cache_source = 4;
    case kCacheSource: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.source_.cache_source_);
        break;
    }
    case SOURCE_NOT_SET: {
        break;
    }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ServiceWorkerRegistrationData_RouterRules_RuleV1_Source*>(&from));
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::MergeFrom(const ServiceWorkerRegistrationData_RouterRules_RuleV1_Source& from)
{
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Source* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    switch (from.source_case()) {
    case kNetworkSource: {
        _this->_internal_mutable_network_source()->::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource::MergeFrom(
            from._internal_network_source());
        break;
    }
    case kRaceSource: {
        _this->_internal_mutable_race_source()->::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource::MergeFrom(
            from._internal_race_source());
        break;
    }
    case kFetchEventSource: {
        _this->_internal_mutable_fetch_event_source()->::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource::MergeFrom(
            from._internal_fetch_event_source());
        break;
    }
    case kCacheSource: {
        _this->_internal_mutable_cache_source()->::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource::MergeFrom(
            from._internal_cache_source());
        break;
    }
    case SOURCE_NOT_SET: {
        break;
    }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::CopyFrom(const ServiceWorkerRegistrationData_RouterRules_RuleV1_Source& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::IsInitialized() const
{
    return true;
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::InternalSwap(ServiceWorkerRegistrationData_RouterRules_RuleV1_Source* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_.source_, other->_impl_.source_);
    swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

std::string ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::GetTypeName() const
{
    return "storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source";
}

// ===================================================================

class ServiceWorkerRegistrationData_RouterRules_RuleV1::_Internal {
public:
};

ServiceWorkerRegistrationData_RouterRules_RuleV1::ServiceWorkerRegistrationData_RouterRules_RuleV1(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1)
}
ServiceWorkerRegistrationData_RouterRules_RuleV1::ServiceWorkerRegistrationData_RouterRules_RuleV1(const ServiceWorkerRegistrationData_RouterRules_RuleV1& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ServiceWorkerRegistrationData_RouterRules_RuleV1* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.condition_) { from._impl_.condition_ }, decltype(_impl_.source_) { from._impl_.source_ },
        /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1)
}

inline void ServiceWorkerRegistrationData_RouterRules_RuleV1::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.condition_) { arena }, decltype(_impl_.source_) { arena }, /*decltype(_impl_._cached_size_)*/ {} };
}

ServiceWorkerRegistrationData_RouterRules_RuleV1::~ServiceWorkerRegistrationData_RouterRules_RuleV1()
{
    // @@protoc_insertion_point(destructor:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ServiceWorkerRegistrationData_RouterRules_RuleV1::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.condition_.~RepeatedPtrField();
    _impl_.source_.~RepeatedPtrField();
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1::Clear()
{
    // @@protoc_insertion_point(message_clear_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.condition_.Clear();
    _impl_.source_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ServiceWorkerRegistrationData_RouterRules_RuleV1::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition condition = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_condition(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        // repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source source = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_source(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ServiceWorkerRegistrationData_RouterRules_RuleV1::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition condition = 1;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_condition_size()); i < n; i++) {
        const auto& repfield = this->_internal_condition(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
    }

    // repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source source = 2;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_source_size()); i < n; i++) {
        const auto& repfield = this->_internal_source(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1)
    return target;
}

size_t ServiceWorkerRegistrationData_RouterRules_RuleV1::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition condition = 1;
    total_size += 1UL * this->_internal_condition_size();
    for (const auto& msg : this->_impl_.condition_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source source = 2;
    total_size += 1UL * this->_internal_source_size();
    for (const auto& msg : this->_impl_.source_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ServiceWorkerRegistrationData_RouterRules_RuleV1*>(&from));
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1::MergeFrom(const ServiceWorkerRegistrationData_RouterRules_RuleV1& from)
{
    ServiceWorkerRegistrationData_RouterRules_RuleV1* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.condition_.MergeFrom(from._impl_.condition_);
    _this->_impl_.source_.MergeFrom(from._impl_.source_);
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1::CopyFrom(const ServiceWorkerRegistrationData_RouterRules_RuleV1& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ServiceWorkerRegistrationData_RouterRules_RuleV1::IsInitialized() const
{
    if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.condition_))
        return false;
    return true;
}

void ServiceWorkerRegistrationData_RouterRules_RuleV1::InternalSwap(ServiceWorkerRegistrationData_RouterRules_RuleV1* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.condition_.InternalSwap(&other->_impl_.condition_);
    _impl_.source_.InternalSwap(&other->_impl_.source_);
}

std::string ServiceWorkerRegistrationData_RouterRules_RuleV1::GetTypeName() const
{
    return "storage.ServiceWorkerRegistrationData.RouterRules.RuleV1";
}

// ===================================================================

class ServiceWorkerRegistrationData_RouterRules::_Internal {
public:
    using HasBits = decltype(std::declval<ServiceWorkerRegistrationData_RouterRules>()._impl_._has_bits_);
    static void set_has_version(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static bool MissingRequiredFields(const HasBits& has_bits)
    {
        return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
    }
};

ServiceWorkerRegistrationData_RouterRules::ServiceWorkerRegistrationData_RouterRules(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:storage.ServiceWorkerRegistrationData.RouterRules)
}
ServiceWorkerRegistrationData_RouterRules::ServiceWorkerRegistrationData_RouterRules(const ServiceWorkerRegistrationData_RouterRules& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ServiceWorkerRegistrationData_RouterRules* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.v1_) { from._impl_.v1_ }, decltype(_impl_.version_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _this->_impl_.version_ = from._impl_.version_;
    // @@protoc_insertion_point(copy_constructor:storage.ServiceWorkerRegistrationData.RouterRules)
}

inline void ServiceWorkerRegistrationData_RouterRules::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_)
        Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.v1_) { arena }, decltype(_impl_.version_) { 0 } };
}

ServiceWorkerRegistrationData_RouterRules::~ServiceWorkerRegistrationData_RouterRules()
{
    // @@protoc_insertion_point(destructor:storage.ServiceWorkerRegistrationData.RouterRules)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ServiceWorkerRegistrationData_RouterRules::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.v1_.~RepeatedPtrField();
}

void ServiceWorkerRegistrationData_RouterRules::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ServiceWorkerRegistrationData_RouterRules::Clear()
{
    // @@protoc_insertion_point(message_clear_start:storage.ServiceWorkerRegistrationData.RouterRules)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.v1_.Clear();
    _impl_.version_ = 0;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ServiceWorkerRegistrationData_RouterRules::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // required int32 version = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_version(&has_bits);
                _impl_.version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1 v1 = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_v1(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ServiceWorkerRegistrationData_RouterRules::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:storage.ServiceWorkerRegistrationData.RouterRules)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // required int32 version = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_version(), target);
    }

    // repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1 v1 = 2;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_v1_size()); i < n; i++) {
        const auto& repfield = this->_internal_v1(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:storage.ServiceWorkerRegistrationData.RouterRules)
    return target;
}

size_t ServiceWorkerRegistrationData_RouterRules::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:storage.ServiceWorkerRegistrationData.RouterRules)
    size_t total_size = 0;

    // required int32 version = 1;
    if (_internal_has_version()) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_version());
    }
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1 v1 = 2;
    total_size += 1UL * this->_internal_v1_size();
    for (const auto& msg : this->_impl_.v1_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ServiceWorkerRegistrationData_RouterRules::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ServiceWorkerRegistrationData_RouterRules*>(&from));
}

void ServiceWorkerRegistrationData_RouterRules::MergeFrom(const ServiceWorkerRegistrationData_RouterRules& from)
{
    ServiceWorkerRegistrationData_RouterRules* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:storage.ServiceWorkerRegistrationData.RouterRules)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.v1_.MergeFrom(from._impl_.v1_);
    if (from._internal_has_version()) {
        _this->_internal_set_version(from._internal_version());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ServiceWorkerRegistrationData_RouterRules::CopyFrom(const ServiceWorkerRegistrationData_RouterRules& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:storage.ServiceWorkerRegistrationData.RouterRules)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ServiceWorkerRegistrationData_RouterRules::IsInitialized() const
{
    if (_Internal::MissingRequiredFields(_impl_._has_bits_))
        return false;
    if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.v1_))
        return false;
    return true;
}

void ServiceWorkerRegistrationData_RouterRules::InternalSwap(ServiceWorkerRegistrationData_RouterRules* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.v1_.InternalSwap(&other->_impl_.v1_);
    swap(_impl_.version_, other->_impl_.version_);
}

std::string ServiceWorkerRegistrationData_RouterRules::GetTypeName() const
{
    return "storage.ServiceWorkerRegistrationData.RouterRules";
}

// ===================================================================

class ServiceWorkerRegistrationData::_Internal {
public:
    using HasBits = decltype(std::declval<ServiceWorkerRegistrationData>()._impl_._has_bits_);
    static void set_has_registration_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 256u;
    }
    static void set_has_scope_url(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_script_url(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_version_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 512u;
    }
    static void set_has_is_active(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16384u;
    }
    static void set_has_has_fetch_handler(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32768u;
    }
    static void set_has_fetch_handler_skippable_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4194304u;
    }
    static void set_has_last_update_check_time(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1024u;
    }
    static void set_has_resources_total_size_bytes(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2048u;
    }
    static const ::storage::ServiceWorkerOriginTrialInfo& origin_trial_tokens(const ServiceWorkerRegistrationData* msg);
    static void set_has_origin_trial_tokens(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static const ::storage::ServiceWorkerNavigationPreloadState& navigation_preload_state(const ServiceWorkerRegistrationData* msg);
    static void set_has_navigation_preload_state(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
    static void set_has_update_via_cache(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4096u;
    }
    static void set_has_script_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8192u;
    }
    static void set_has_script_response_time(HasBits* has_bits)
    {
        (*has_bits)[0] |= 524288u;
    }
    static void set_has_cross_origin_embedder_policy_value(HasBits* has_bits)
    {
        (*has_bits)[0] |= 262144u;
    }
    static void set_has_cross_origin_embedder_policy_reporting_endpoint(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_cross_origin_embedder_policy_report_only_value(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1048576u;
    }
    static void set_has_cross_origin_embedder_policy_report_only_reporting_endpoint(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_ancestor_frame_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2097152u;
    }
    static const ::storage::ServiceWorkerRegistrationData_PolicyContainerPolicies& policy_container_policies(const ServiceWorkerRegistrationData* msg);
    static void set_has_policy_container_policies(HasBits* has_bits)
    {
        (*has_bits)[0] |= 64u;
    }
    static const ::storage::ServiceWorkerRegistrationData_RouterRules& router_rules(const ServiceWorkerRegistrationData* msg);
    static void set_has_router_rules(HasBits* has_bits)
    {
        (*has_bits)[0] |= 128u;
    }
    static void set_has_has_hid_event_handlers(HasBits* has_bits)
    {
        (*has_bits)[0] |= 65536u;
    }
    static void set_has_has_usb_event_handlers(HasBits* has_bits)
    {
        (*has_bits)[0] |= 131072u;
    }
    static bool MissingRequiredFields(const HasBits& has_bits)
    {
        return ((has_bits[0] & 0x0000c703) ^ 0x0000c703) != 0;
    }
};

const ::storage::ServiceWorkerOriginTrialInfo& ServiceWorkerRegistrationData::_Internal::origin_trial_tokens(const ServiceWorkerRegistrationData* msg)
{
    return *msg->_impl_.origin_trial_tokens_;
}
const ::storage::ServiceWorkerNavigationPreloadState& ServiceWorkerRegistrationData::_Internal::navigation_preload_state(
    const ServiceWorkerRegistrationData* msg)
{
    return *msg->_impl_.navigation_preload_state_;
}
const ::storage::ServiceWorkerRegistrationData_PolicyContainerPolicies& ServiceWorkerRegistrationData::_Internal::policy_container_policies(
    const ServiceWorkerRegistrationData* msg)
{
    return *msg->_impl_.policy_container_policies_;
}
const ::storage::ServiceWorkerRegistrationData_RouterRules& ServiceWorkerRegistrationData::_Internal::router_rules(const ServiceWorkerRegistrationData* msg)
{
    return *msg->_impl_.router_rules_;
}
ServiceWorkerRegistrationData::ServiceWorkerRegistrationData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:storage.ServiceWorkerRegistrationData)
}
ServiceWorkerRegistrationData::ServiceWorkerRegistrationData(const ServiceWorkerRegistrationData& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ServiceWorkerRegistrationData* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.used_features_) { from._impl_.used_features_ }, decltype(_impl_.scope_url_) {}, decltype(_impl_.script_url_) {},
        decltype(_impl_.cross_origin_embedder_policy_reporting_endpoint_) {}, decltype(_impl_.cross_origin_embedder_policy_report_only_reporting_endpoint_) {},
        decltype(_impl_.origin_trial_tokens_) { nullptr }, decltype(_impl_.navigation_preload_state_) { nullptr },
        decltype(_impl_.policy_container_policies_) { nullptr }, decltype(_impl_.router_rules_) { nullptr }, decltype(_impl_.registration_id_) {},
        decltype(_impl_.version_id_) {}, decltype(_impl_.last_update_check_time_) {}, decltype(_impl_.resources_total_size_bytes_) {},
        decltype(_impl_.update_via_cache_) {}, decltype(_impl_.script_type_) {}, decltype(_impl_.is_active_) {}, decltype(_impl_.has_fetch_handler_) {},
        decltype(_impl_.has_hid_event_handlers_) {}, decltype(_impl_.has_usb_event_handlers_) {}, decltype(_impl_.cross_origin_embedder_policy_value_) {},
        decltype(_impl_.script_response_time_) {}, decltype(_impl_.cross_origin_embedder_policy_report_only_value_) {},
        decltype(_impl_.ancestor_frame_type_) {}, decltype(_impl_.fetch_handler_skippable_type_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.scope_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.scope_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_scope_url()) {
        _this->_impl_.scope_url_.Set(from._internal_scope_url(), _this->GetArenaForAllocation());
    }
    _impl_.script_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.script_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_script_url()) {
        _this->_impl_.script_url_.Set(from._internal_script_url(), _this->GetArenaForAllocation());
    }
    _impl_.cross_origin_embedder_policy_reporting_endpoint_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cross_origin_embedder_policy_reporting_endpoint_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_cross_origin_embedder_policy_reporting_endpoint()) {
        _this->_impl_.cross_origin_embedder_policy_reporting_endpoint_.Set(
            from._internal_cross_origin_embedder_policy_reporting_endpoint(), _this->GetArenaForAllocation());
    }
    _impl_.cross_origin_embedder_policy_report_only_reporting_endpoint_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cross_origin_embedder_policy_report_only_reporting_endpoint_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_cross_origin_embedder_policy_report_only_reporting_endpoint()) {
        _this->_impl_.cross_origin_embedder_policy_report_only_reporting_endpoint_.Set(
            from._internal_cross_origin_embedder_policy_report_only_reporting_endpoint(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_origin_trial_tokens()) {
        _this->_impl_.origin_trial_tokens_ = new ::storage::ServiceWorkerOriginTrialInfo(*from._impl_.origin_trial_tokens_);
    }
    if (from._internal_has_navigation_preload_state()) {
        _this->_impl_.navigation_preload_state_ = new ::storage::ServiceWorkerNavigationPreloadState(*from._impl_.navigation_preload_state_);
    }
    if (from._internal_has_policy_container_policies()) {
        _this->_impl_.policy_container_policies_
            = new ::storage::ServiceWorkerRegistrationData_PolicyContainerPolicies(*from._impl_.policy_container_policies_);
    }
    if (from._internal_has_router_rules()) {
        _this->_impl_.router_rules_ = new ::storage::ServiceWorkerRegistrationData_RouterRules(*from._impl_.router_rules_);
    }
    ::memcpy(&_impl_.registration_id_, &from._impl_.registration_id_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.fetch_handler_skippable_type_) - reinterpret_cast<char*>(&_impl_.registration_id_))
            + sizeof(_impl_.fetch_handler_skippable_type_));
    // @@protoc_insertion_point(copy_constructor:storage.ServiceWorkerRegistrationData)
}

inline void ServiceWorkerRegistrationData::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.used_features_) { arena },
        decltype(_impl_.scope_url_) {}, decltype(_impl_.script_url_) {}, decltype(_impl_.cross_origin_embedder_policy_reporting_endpoint_) {},
        decltype(_impl_.cross_origin_embedder_policy_report_only_reporting_endpoint_) {}, decltype(_impl_.origin_trial_tokens_) { nullptr },
        decltype(_impl_.navigation_preload_state_) { nullptr }, decltype(_impl_.policy_container_policies_) { nullptr },
        decltype(_impl_.router_rules_) { nullptr }, decltype(_impl_.registration_id_) { int64_t { 0 } }, decltype(_impl_.version_id_) { int64_t { 0 } },
        decltype(_impl_.last_update_check_time_) { int64_t { 0 } }, decltype(_impl_.resources_total_size_bytes_) { uint64_t { 0u } },
        decltype(_impl_.update_via_cache_) { 0 }, decltype(_impl_.script_type_) { 0 }, decltype(_impl_.is_active_) { false },
        decltype(_impl_.has_fetch_handler_) { false }, decltype(_impl_.has_hid_event_handlers_) { false }, decltype(_impl_.has_usb_event_handlers_) { false },
        decltype(_impl_.cross_origin_embedder_policy_value_) { 0 }, decltype(_impl_.script_response_time_) { int64_t { 0 } },
        decltype(_impl_.cross_origin_embedder_policy_report_only_value_) { 0 }, decltype(_impl_.ancestor_frame_type_) { 0 },
        decltype(_impl_.fetch_handler_skippable_type_) { 1 } };
    _impl_.scope_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.scope_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.script_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.script_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cross_origin_embedder_policy_reporting_endpoint_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cross_origin_embedder_policy_reporting_endpoint_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cross_origin_embedder_policy_report_only_reporting_endpoint_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cross_origin_embedder_policy_report_only_reporting_endpoint_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ServiceWorkerRegistrationData::~ServiceWorkerRegistrationData()
{
    // @@protoc_insertion_point(destructor:storage.ServiceWorkerRegistrationData)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ServiceWorkerRegistrationData::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.used_features_.~RepeatedField();
    _impl_.scope_url_.Destroy();
    _impl_.script_url_.Destroy();
    _impl_.cross_origin_embedder_policy_reporting_endpoint_.Destroy();
    _impl_.cross_origin_embedder_policy_report_only_reporting_endpoint_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.origin_trial_tokens_;
    if (this != internal_default_instance())
        delete _impl_.navigation_preload_state_;
    if (this != internal_default_instance())
        delete _impl_.policy_container_policies_;
    if (this != internal_default_instance())
        delete _impl_.router_rules_;
}

void ServiceWorkerRegistrationData::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ServiceWorkerRegistrationData::Clear()
{
    // @@protoc_insertion_point(message_clear_start:storage.ServiceWorkerRegistrationData)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.used_features_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.scope_url_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.script_url_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            _impl_.cross_origin_embedder_policy_reporting_endpoint_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000008u) {
            _impl_.cross_origin_embedder_policy_report_only_reporting_endpoint_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000010u) {
            GOOGLE_DCHECK(_impl_.origin_trial_tokens_ != nullptr);
            _impl_.origin_trial_tokens_->Clear();
        }
        if (cached_has_bits & 0x00000020u) {
            GOOGLE_DCHECK(_impl_.navigation_preload_state_ != nullptr);
            _impl_.navigation_preload_state_->Clear();
        }
        if (cached_has_bits & 0x00000040u) {
            GOOGLE_DCHECK(_impl_.policy_container_policies_ != nullptr);
            _impl_.policy_container_policies_->Clear();
        }
        if (cached_has_bits & 0x00000080u) {
            GOOGLE_DCHECK(_impl_.router_rules_ != nullptr);
            _impl_.router_rules_->Clear();
        }
    }
    if (cached_has_bits & 0x0000ff00u) {
        ::memset(&_impl_.registration_id_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.has_fetch_handler_) - reinterpret_cast<char*>(&_impl_.registration_id_))
                + sizeof(_impl_.has_fetch_handler_));
    }
    if (cached_has_bits & 0x007f0000u) {
        ::memset(&_impl_.has_hid_event_handlers_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.ancestor_frame_type_) - reinterpret_cast<char*>(&_impl_.has_hid_event_handlers_))
                + sizeof(_impl_.ancestor_frame_type_));
        _impl_.fetch_handler_skippable_type_ = 1;
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ServiceWorkerRegistrationData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // required int64 registration_id = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_registration_id(&has_bits);
                _impl_.registration_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // required string scope_url = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_scope_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // required string script_url = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_script_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // required int64 version_id = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _Internal::set_has_version_id(&has_bits);
                _impl_.version_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // required bool is_active = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
                _Internal::set_has_is_active(&has_bits);
                _impl_.is_active_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // required bool has_fetch_handler = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
                _Internal::set_has_has_fetch_handler(&has_bits);
                _impl_.has_fetch_handler_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // required int64 last_update_check_time = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
                _Internal::set_has_last_update_check_time(&has_bits);
                _impl_.last_update_check_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional uint64 resources_total_size_bytes = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
                _Internal::set_has_resources_total_size_bytes(&has_bits);
                _impl_.resources_total_size_bytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .storage.ServiceWorkerOriginTrialInfo origin_trial_tokens = 11;
        case 11:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
                ptr = ctx->ParseMessage(_internal_mutable_origin_trial_tokens(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .storage.ServiceWorkerNavigationPreloadState navigation_preload_state = 12;
        case 12:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
                ptr = ctx->ParseMessage(_internal_mutable_navigation_preload_state(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated uint32 used_features = 13;
        case 13:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    _internal_add_used_features(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<104>(ptr));
            } else if (static_cast<uint8_t>(tag) == 106) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_used_features(), ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .storage.ServiceWorkerRegistrationData.ServiceWorkerUpdateViaCacheType update_via_cache = 14 [default = IMPORTS];
        case 14:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::storage::ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType_IsValid(val))) {
                    _internal_set_update_via_cache(static_cast<::storage::ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(14, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional .storage.ServiceWorkerRegistrationData.ServiceWorkerScriptType script_type = 15 [default = CLASSIC];
        case 15:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::storage::ServiceWorkerRegistrationData_ServiceWorkerScriptType_IsValid(val))) {
                    _internal_set_script_type(static_cast<::storage::ServiceWorkerRegistrationData_ServiceWorkerScriptType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(15, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional int64 script_response_time = 16;
        case 16:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
                _Internal::set_has_script_response_time(&has_bits);
                _impl_.script_response_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .storage.ServiceWorkerRegistrationData.CrossOriginEmbedderPolicyValue cross_origin_embedder_policy_value = 17 [default = NONE_OR_NOT_EXIST];
        case 17:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::storage::ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue_IsValid(val))) {
                    _internal_set_cross_origin_embedder_policy_value(static_cast<::storage::ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(17, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional string cross_origin_embedder_policy_reporting_endpoint = 18;
        case 18:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
                auto str = _internal_mutable_cross_origin_embedder_policy_reporting_endpoint();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .storage.ServiceWorkerRegistrationData.CrossOriginEmbedderPolicyValue cross_origin_embedder_policy_report_only_value = 19 [default = NONE_OR_NOT_EXIST];
        case 19:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::storage::ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue_IsValid(val))) {
                    _internal_set_cross_origin_embedder_policy_report_only_value(
                        static_cast<::storage::ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(19, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional string cross_origin_embedder_policy_report_only_reporting_endpoint = 20;
        case 20:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
                auto str = _internal_mutable_cross_origin_embedder_policy_report_only_reporting_endpoint();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .storage.ServiceWorkerRegistrationData.AncestorFrameType ancestor_frame_type = 21 [default = NORMAL_FRAME];
        case 21:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::storage::ServiceWorkerRegistrationData_AncestorFrameType_IsValid(val))) {
                    _internal_set_ancestor_frame_type(static_cast<::storage::ServiceWorkerRegistrationData_AncestorFrameType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(21, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional .storage.ServiceWorkerRegistrationData.FetchHandlerSkippableType fetch_handler_skippable_type = 22;
        case 22:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::storage::ServiceWorkerRegistrationData_FetchHandlerSkippableType_IsValid(val))) {
                    _internal_set_fetch_handler_skippable_type(static_cast<::storage::ServiceWorkerRegistrationData_FetchHandlerSkippableType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(22, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional .storage.ServiceWorkerRegistrationData.PolicyContainerPolicies policy_container_policies = 23;
        case 23:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
                ptr = ctx->ParseMessage(_internal_mutable_policy_container_policies(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .storage.ServiceWorkerRegistrationData.RouterRules router_rules = 24;
        case 24:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 194)) {
                ptr = ctx->ParseMessage(_internal_mutable_router_rules(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool has_hid_event_handlers = 25;
        case 25:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 200)) {
                _Internal::set_has_has_hid_event_handlers(&has_bits);
                _impl_.has_hid_event_handlers_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool has_usb_event_handlers = 26;
        case 26:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 208)) {
                _Internal::set_has_has_usb_event_handlers(&has_bits);
                _impl_.has_usb_event_handlers_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ServiceWorkerRegistrationData::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:storage.ServiceWorkerRegistrationData)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // required int64 registration_id = 1;
    if (cached_has_bits & 0x00000100u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_registration_id(), target);
    }

    // required string scope_url = 2;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_scope_url(), target);
    }

    // required string script_url = 3;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(3, this->_internal_script_url(), target);
    }

    // required int64 version_id = 4;
    if (cached_has_bits & 0x00000200u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_version_id(), target);
    }

    // required bool is_active = 5;
    if (cached_has_bits & 0x00004000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_is_active(), target);
    }

    // required bool has_fetch_handler = 6;
    if (cached_has_bits & 0x00008000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_has_fetch_handler(), target);
    }

    // required int64 last_update_check_time = 7;
    if (cached_has_bits & 0x00000400u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(7, this->_internal_last_update_check_time(), target);
    }

    // optional uint64 resources_total_size_bytes = 8;
    if (cached_has_bits & 0x00000800u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt64ToArray(8, this->_internal_resources_total_size_bytes(), target);
    }

    // optional .storage.ServiceWorkerOriginTrialInfo origin_trial_tokens = 11;
    if (cached_has_bits & 0x00000010u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            11, _Internal::origin_trial_tokens(this), _Internal::origin_trial_tokens(this).GetCachedSize(), target, stream);
    }

    // optional .storage.ServiceWorkerNavigationPreloadState navigation_preload_state = 12;
    if (cached_has_bits & 0x00000020u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            12, _Internal::navigation_preload_state(this), _Internal::navigation_preload_state(this).GetCachedSize(), target, stream);
    }

    // repeated uint32 used_features = 13;
    for (int i = 0, n = this->_internal_used_features_size(); i < n; i++) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(13, this->_internal_used_features(i), target);
    }

    // optional .storage.ServiceWorkerRegistrationData.ServiceWorkerUpdateViaCacheType update_via_cache = 14 [default = IMPORTS];
    if (cached_has_bits & 0x00001000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(14, this->_internal_update_via_cache(), target);
    }

    // optional .storage.ServiceWorkerRegistrationData.ServiceWorkerScriptType script_type = 15 [default = CLASSIC];
    if (cached_has_bits & 0x00002000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(15, this->_internal_script_type(), target);
    }

    // optional int64 script_response_time = 16;
    if (cached_has_bits & 0x00080000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(16, this->_internal_script_response_time(), target);
    }

    // optional .storage.ServiceWorkerRegistrationData.CrossOriginEmbedderPolicyValue cross_origin_embedder_policy_value = 17 [default = NONE_OR_NOT_EXIST];
    if (cached_has_bits & 0x00040000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(17, this->_internal_cross_origin_embedder_policy_value(), target);
    }

    // optional string cross_origin_embedder_policy_reporting_endpoint = 18;
    if (cached_has_bits & 0x00000004u) {
        target = stream->WriteStringMaybeAliased(18, this->_internal_cross_origin_embedder_policy_reporting_endpoint(), target);
    }

    // optional .storage.ServiceWorkerRegistrationData.CrossOriginEmbedderPolicyValue cross_origin_embedder_policy_report_only_value = 19 [default = NONE_OR_NOT_EXIST];
    if (cached_has_bits & 0x00100000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(19, this->_internal_cross_origin_embedder_policy_report_only_value(), target);
    }

    // optional string cross_origin_embedder_policy_report_only_reporting_endpoint = 20;
    if (cached_has_bits & 0x00000008u) {
        target = stream->WriteStringMaybeAliased(20, this->_internal_cross_origin_embedder_policy_report_only_reporting_endpoint(), target);
    }

    // optional .storage.ServiceWorkerRegistrationData.AncestorFrameType ancestor_frame_type = 21 [default = NORMAL_FRAME];
    if (cached_has_bits & 0x00200000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(21, this->_internal_ancestor_frame_type(), target);
    }

    // optional .storage.ServiceWorkerRegistrationData.FetchHandlerSkippableType fetch_handler_skippable_type = 22;
    if (cached_has_bits & 0x00400000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(22, this->_internal_fetch_handler_skippable_type(), target);
    }

    // optional .storage.ServiceWorkerRegistrationData.PolicyContainerPolicies policy_container_policies = 23;
    if (cached_has_bits & 0x00000040u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            23, _Internal::policy_container_policies(this), _Internal::policy_container_policies(this).GetCachedSize(), target, stream);
    }

    // optional .storage.ServiceWorkerRegistrationData.RouterRules router_rules = 24;
    if (cached_has_bits & 0x00000080u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            24, _Internal::router_rules(this), _Internal::router_rules(this).GetCachedSize(), target, stream);
    }

    // optional bool has_hid_event_handlers = 25;
    if (cached_has_bits & 0x00010000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(25, this->_internal_has_hid_event_handlers(), target);
    }

    // optional bool has_usb_event_handlers = 26;
    if (cached_has_bits & 0x00020000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(26, this->_internal_has_usb_event_handlers(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:storage.ServiceWorkerRegistrationData)
    return target;
}

size_t ServiceWorkerRegistrationData::RequiredFieldsByteSizeFallback() const
{
    // @@protoc_insertion_point(required_fields_byte_size_fallback_start:storage.ServiceWorkerRegistrationData)
    size_t total_size = 0;

    if (_internal_has_scope_url()) {
        // required string scope_url = 2;
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_scope_url());
    }

    if (_internal_has_script_url()) {
        // required string script_url = 3;
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_script_url());
    }

    if (_internal_has_registration_id()) {
        // required int64 registration_id = 1;
        total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_registration_id());
    }

    if (_internal_has_version_id()) {
        // required int64 version_id = 4;
        total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_version_id());
    }

    if (_internal_has_last_update_check_time()) {
        // required int64 last_update_check_time = 7;
        total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_last_update_check_time());
    }

    if (_internal_has_is_active()) {
        // required bool is_active = 5;
        total_size += 1 + 1;
    }

    if (_internal_has_has_fetch_handler()) {
        // required bool has_fetch_handler = 6;
        total_size += 1 + 1;
    }

    return total_size;
}
size_t ServiceWorkerRegistrationData::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:storage.ServiceWorkerRegistrationData)
    size_t total_size = 0;

    if (((_impl_._has_bits_[0] & 0x0000c703) ^ 0x0000c703) == 0) { // All required fields are present.
        // required string scope_url = 2;
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_scope_url());

        // required string script_url = 3;
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_script_url());

        // required int64 registration_id = 1;
        total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_registration_id());

        // required int64 version_id = 4;
        total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_version_id());

        // required int64 last_update_check_time = 7;
        total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_last_update_check_time());

        // required bool is_active = 5;
        total_size += 1 + 1;

        // required bool has_fetch_handler = 6;
        total_size += 1 + 1;

    } else {
        total_size += RequiredFieldsByteSizeFallback();
    }
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated uint32 used_features = 13;
    {
        size_t data_size = ::_pbi::WireFormatLite::UInt32Size(this->_impl_.used_features_);
        total_size += 1 * ::_pbi::FromIntSize(this->_internal_used_features_size());
        total_size += data_size;
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x000000fcu) {
        // optional string cross_origin_embedder_policy_reporting_endpoint = 18;
        if (cached_has_bits & 0x00000004u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_cross_origin_embedder_policy_reporting_endpoint());
        }

        // optional string cross_origin_embedder_policy_report_only_reporting_endpoint = 20;
        if (cached_has_bits & 0x00000008u) {
            total_size += 2
                + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_cross_origin_embedder_policy_report_only_reporting_endpoint());
        }

        // optional .storage.ServiceWorkerOriginTrialInfo origin_trial_tokens = 11;
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.origin_trial_tokens_);
        }

        // optional .storage.ServiceWorkerNavigationPreloadState navigation_preload_state = 12;
        if (cached_has_bits & 0x00000020u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.navigation_preload_state_);
        }

        // optional .storage.ServiceWorkerRegistrationData.PolicyContainerPolicies policy_container_policies = 23;
        if (cached_has_bits & 0x00000040u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.policy_container_policies_);
        }

        // optional .storage.ServiceWorkerRegistrationData.RouterRules router_rules = 24;
        if (cached_has_bits & 0x00000080u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.router_rules_);
        }
    }
    if (cached_has_bits & 0x00003800u) {
        // optional uint64 resources_total_size_bytes = 8;
        if (cached_has_bits & 0x00000800u) {
            total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_resources_total_size_bytes());
        }

        // optional .storage.ServiceWorkerRegistrationData.ServiceWorkerUpdateViaCacheType update_via_cache = 14 [default = IMPORTS];
        if (cached_has_bits & 0x00001000u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_update_via_cache());
        }

        // optional .storage.ServiceWorkerRegistrationData.ServiceWorkerScriptType script_type = 15 [default = CLASSIC];
        if (cached_has_bits & 0x00002000u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_script_type());
        }
    }
    if (cached_has_bits & 0x007f0000u) {
        // optional bool has_hid_event_handlers = 25;
        if (cached_has_bits & 0x00010000u) {
            total_size += 2 + 1;
        }

        // optional bool has_usb_event_handlers = 26;
        if (cached_has_bits & 0x00020000u) {
            total_size += 2 + 1;
        }

        // optional .storage.ServiceWorkerRegistrationData.CrossOriginEmbedderPolicyValue cross_origin_embedder_policy_value = 17 [default = NONE_OR_NOT_EXIST];
        if (cached_has_bits & 0x00040000u) {
            total_size += 2 + ::_pbi::WireFormatLite::EnumSize(this->_internal_cross_origin_embedder_policy_value());
        }

        // optional int64 script_response_time = 16;
        if (cached_has_bits & 0x00080000u) {
            total_size += 2 + ::_pbi::WireFormatLite::Int64Size(this->_internal_script_response_time());
        }

        // optional .storage.ServiceWorkerRegistrationData.CrossOriginEmbedderPolicyValue cross_origin_embedder_policy_report_only_value = 19 [default = NONE_OR_NOT_EXIST];
        if (cached_has_bits & 0x00100000u) {
            total_size += 2 + ::_pbi::WireFormatLite::EnumSize(this->_internal_cross_origin_embedder_policy_report_only_value());
        }

        // optional .storage.ServiceWorkerRegistrationData.AncestorFrameType ancestor_frame_type = 21 [default = NORMAL_FRAME];
        if (cached_has_bits & 0x00200000u) {
            total_size += 2 + ::_pbi::WireFormatLite::EnumSize(this->_internal_ancestor_frame_type());
        }

        // optional .storage.ServiceWorkerRegistrationData.FetchHandlerSkippableType fetch_handler_skippable_type = 22;
        if (cached_has_bits & 0x00400000u) {
            total_size += 2 + ::_pbi::WireFormatLite::EnumSize(this->_internal_fetch_handler_skippable_type());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ServiceWorkerRegistrationData::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ServiceWorkerRegistrationData*>(&from));
}

void ServiceWorkerRegistrationData::MergeFrom(const ServiceWorkerRegistrationData& from)
{
    ServiceWorkerRegistrationData* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:storage.ServiceWorkerRegistrationData)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.used_features_.MergeFrom(from._impl_.used_features_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_scope_url(from._internal_scope_url());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_script_url(from._internal_script_url());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_set_cross_origin_embedder_policy_reporting_endpoint(from._internal_cross_origin_embedder_policy_reporting_endpoint());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_set_cross_origin_embedder_policy_report_only_reporting_endpoint(
                from._internal_cross_origin_embedder_policy_report_only_reporting_endpoint());
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_internal_mutable_origin_trial_tokens()->::storage::ServiceWorkerOriginTrialInfo::MergeFrom(from._internal_origin_trial_tokens());
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_internal_mutable_navigation_preload_state()->::storage::ServiceWorkerNavigationPreloadState::MergeFrom(
                from._internal_navigation_preload_state());
        }
        if (cached_has_bits & 0x00000040u) {
            _this->_internal_mutable_policy_container_policies()->::storage::ServiceWorkerRegistrationData_PolicyContainerPolicies::MergeFrom(
                from._internal_policy_container_policies());
        }
        if (cached_has_bits & 0x00000080u) {
            _this->_internal_mutable_router_rules()->::storage::ServiceWorkerRegistrationData_RouterRules::MergeFrom(from._internal_router_rules());
        }
    }
    if (cached_has_bits & 0x0000ff00u) {
        if (cached_has_bits & 0x00000100u) {
            _this->_impl_.registration_id_ = from._impl_.registration_id_;
        }
        if (cached_has_bits & 0x00000200u) {
            _this->_impl_.version_id_ = from._impl_.version_id_;
        }
        if (cached_has_bits & 0x00000400u) {
            _this->_impl_.last_update_check_time_ = from._impl_.last_update_check_time_;
        }
        if (cached_has_bits & 0x00000800u) {
            _this->_impl_.resources_total_size_bytes_ = from._impl_.resources_total_size_bytes_;
        }
        if (cached_has_bits & 0x00001000u) {
            _this->_impl_.update_via_cache_ = from._impl_.update_via_cache_;
        }
        if (cached_has_bits & 0x00002000u) {
            _this->_impl_.script_type_ = from._impl_.script_type_;
        }
        if (cached_has_bits & 0x00004000u) {
            _this->_impl_.is_active_ = from._impl_.is_active_;
        }
        if (cached_has_bits & 0x00008000u) {
            _this->_impl_.has_fetch_handler_ = from._impl_.has_fetch_handler_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    if (cached_has_bits & 0x007f0000u) {
        if (cached_has_bits & 0x00010000u) {
            _this->_impl_.has_hid_event_handlers_ = from._impl_.has_hid_event_handlers_;
        }
        if (cached_has_bits & 0x00020000u) {
            _this->_impl_.has_usb_event_handlers_ = from._impl_.has_usb_event_handlers_;
        }
        if (cached_has_bits & 0x00040000u) {
            _this->_impl_.cross_origin_embedder_policy_value_ = from._impl_.cross_origin_embedder_policy_value_;
        }
        if (cached_has_bits & 0x00080000u) {
            _this->_impl_.script_response_time_ = from._impl_.script_response_time_;
        }
        if (cached_has_bits & 0x00100000u) {
            _this->_impl_.cross_origin_embedder_policy_report_only_value_ = from._impl_.cross_origin_embedder_policy_report_only_value_;
        }
        if (cached_has_bits & 0x00200000u) {
            _this->_impl_.ancestor_frame_type_ = from._impl_.ancestor_frame_type_;
        }
        if (cached_has_bits & 0x00400000u) {
            _this->_impl_.fetch_handler_skippable_type_ = from._impl_.fetch_handler_skippable_type_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ServiceWorkerRegistrationData::CopyFrom(const ServiceWorkerRegistrationData& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:storage.ServiceWorkerRegistrationData)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ServiceWorkerRegistrationData::IsInitialized() const
{
    if (_Internal::MissingRequiredFields(_impl_._has_bits_))
        return false;
    if (_internal_has_origin_trial_tokens()) {
        if (!_impl_.origin_trial_tokens_->IsInitialized())
            return false;
    }
    if (_internal_has_navigation_preload_state()) {
        if (!_impl_.navigation_preload_state_->IsInitialized())
            return false;
    }
    if (_internal_has_router_rules()) {
        if (!_impl_.router_rules_->IsInitialized())
            return false;
    }
    return true;
}

void ServiceWorkerRegistrationData::InternalSwap(ServiceWorkerRegistrationData* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.used_features_.InternalSwap(&other->_impl_.used_features_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.scope_url_, lhs_arena, &other->_impl_.scope_url_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.script_url_, lhs_arena, &other->_impl_.script_url_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
        &_impl_.cross_origin_embedder_policy_reporting_endpoint_, lhs_arena, &other->_impl_.cross_origin_embedder_policy_reporting_endpoint_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.cross_origin_embedder_policy_report_only_reporting_endpoint_, lhs_arena,
        &other->_impl_.cross_origin_embedder_policy_report_only_reporting_endpoint_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(ServiceWorkerRegistrationData, _impl_.ancestor_frame_type_)
        + sizeof(ServiceWorkerRegistrationData::_impl_.ancestor_frame_type_)
        - PROTOBUF_FIELD_OFFSET(ServiceWorkerRegistrationData, _impl_.origin_trial_tokens_)>(
        reinterpret_cast<char*>(&_impl_.origin_trial_tokens_), reinterpret_cast<char*>(&other->_impl_.origin_trial_tokens_));
    swap(_impl_.fetch_handler_skippable_type_, other->_impl_.fetch_handler_skippable_type_);
}

std::string ServiceWorkerRegistrationData::GetTypeName() const
{
    return "storage.ServiceWorkerRegistrationData";
}

// ===================================================================

class ServiceWorkerResourceRecord::_Internal {
public:
    using HasBits = decltype(std::declval<ServiceWorkerResourceRecord>()._impl_._has_bits_);
    static void set_has_resource_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_url(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_size_bytes(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_sha256_checksum(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static bool MissingRequiredFields(const HasBits& has_bits)
    {
        return ((has_bits[0] & 0x00000005) ^ 0x00000005) != 0;
    }
};

ServiceWorkerResourceRecord::ServiceWorkerResourceRecord(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:storage.ServiceWorkerResourceRecord)
}
ServiceWorkerResourceRecord::ServiceWorkerResourceRecord(const ServiceWorkerResourceRecord& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ServiceWorkerResourceRecord* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.url_) {},
        decltype(_impl_.sha256_checksum_) {}, decltype(_impl_.resource_id_) {}, decltype(_impl_.size_bytes_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_url()) {
        _this->_impl_.url_.Set(from._internal_url(), _this->GetArenaForAllocation());
    }
    _impl_.sha256_checksum_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sha256_checksum_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_sha256_checksum()) {
        _this->_impl_.sha256_checksum_.Set(from._internal_sha256_checksum(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.resource_id_, &from._impl_.resource_id_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.size_bytes_) - reinterpret_cast<char*>(&_impl_.resource_id_)) + sizeof(_impl_.size_bytes_));
    // @@protoc_insertion_point(copy_constructor:storage.ServiceWorkerResourceRecord)
}

inline void ServiceWorkerResourceRecord::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.url_) {}, decltype(_impl_.sha256_checksum_) {},
        decltype(_impl_.resource_id_) { int64_t { 0 } }, decltype(_impl_.size_bytes_) { uint64_t { 0u } } };
    _impl_.url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sha256_checksum_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sha256_checksum_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ServiceWorkerResourceRecord::~ServiceWorkerResourceRecord()
{
    // @@protoc_insertion_point(destructor:storage.ServiceWorkerResourceRecord)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ServiceWorkerResourceRecord::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.url_.Destroy();
    _impl_.sha256_checksum_.Destroy();
}

void ServiceWorkerResourceRecord::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ServiceWorkerResourceRecord::Clear()
{
    // @@protoc_insertion_point(message_clear_start:storage.ServiceWorkerResourceRecord)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.url_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.sha256_checksum_.ClearNonDefaultToEmpty();
        }
    }
    if (cached_has_bits & 0x0000000cu) {
        ::memset(&_impl_.resource_id_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.size_bytes_) - reinterpret_cast<char*>(&_impl_.resource_id_)) + sizeof(_impl_.size_bytes_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ServiceWorkerResourceRecord::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // required int64 resource_id = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_resource_id(&has_bits);
                _impl_.resource_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // required string url = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional uint64 size_bytes = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_size_bytes(&has_bits);
                _impl_.size_bytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string sha256_checksum = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                auto str = _internal_mutable_sha256_checksum();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ServiceWorkerResourceRecord::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:storage.ServiceWorkerResourceRecord)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // required int64 resource_id = 1;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_resource_id(), target);
    }

    // required string url = 2;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_url(), target);
    }

    // optional uint64 size_bytes = 3;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_size_bytes(), target);
    }

    // optional string sha256_checksum = 4;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(4, this->_internal_sha256_checksum(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:storage.ServiceWorkerResourceRecord)
    return target;
}

size_t ServiceWorkerResourceRecord::RequiredFieldsByteSizeFallback() const
{
    // @@protoc_insertion_point(required_fields_byte_size_fallback_start:storage.ServiceWorkerResourceRecord)
    size_t total_size = 0;

    if (_internal_has_url()) {
        // required string url = 2;
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_url());
    }

    if (_internal_has_resource_id()) {
        // required int64 resource_id = 1;
        total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_resource_id());
    }

    return total_size;
}
size_t ServiceWorkerResourceRecord::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:storage.ServiceWorkerResourceRecord)
    size_t total_size = 0;

    if (((_impl_._has_bits_[0] & 0x00000005) ^ 0x00000005) == 0) { // All required fields are present.
        // required string url = 2;
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_url());

        // required int64 resource_id = 1;
        total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_resource_id());

    } else {
        total_size += RequiredFieldsByteSizeFallback();
    }
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional string sha256_checksum = 4;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000002u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_sha256_checksum());
    }

    // optional uint64 size_bytes = 3;
    if (cached_has_bits & 0x00000008u) {
        total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_size_bytes());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ServiceWorkerResourceRecord::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ServiceWorkerResourceRecord*>(&from));
}

void ServiceWorkerResourceRecord::MergeFrom(const ServiceWorkerResourceRecord& from)
{
    ServiceWorkerResourceRecord* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:storage.ServiceWorkerResourceRecord)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_url(from._internal_url());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_sha256_checksum(from._internal_sha256_checksum());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.resource_id_ = from._impl_.resource_id_;
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.size_bytes_ = from._impl_.size_bytes_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ServiceWorkerResourceRecord::CopyFrom(const ServiceWorkerResourceRecord& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:storage.ServiceWorkerResourceRecord)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ServiceWorkerResourceRecord::IsInitialized() const
{
    if (_Internal::MissingRequiredFields(_impl_._has_bits_))
        return false;
    return true;
}

void ServiceWorkerResourceRecord::InternalSwap(ServiceWorkerResourceRecord* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.url_, lhs_arena, &other->_impl_.url_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.sha256_checksum_, lhs_arena, &other->_impl_.sha256_checksum_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(ServiceWorkerResourceRecord, _impl_.size_bytes_)
        + sizeof(ServiceWorkerResourceRecord::_impl_.size_bytes_) - PROTOBUF_FIELD_OFFSET(ServiceWorkerResourceRecord, _impl_.resource_id_)>(
        reinterpret_cast<char*>(&_impl_.resource_id_), reinterpret_cast<char*>(&other->_impl_.resource_id_));
}

std::string ServiceWorkerResourceRecord::GetTypeName() const
{
    return "storage.ServiceWorkerResourceRecord";
}

// @@protoc_insertion_point(namespace_scope)
} // namespace storage
PROTOBUF_NAMESPACE_OPEN
template <> PROTOBUF_NOINLINE ::storage::ServiceWorkerOriginTrialFeature* Arena::CreateMaybeMessage<::storage::ServiceWorkerOriginTrialFeature>(Arena* arena)
{
    return Arena::CreateMessageInternal<::storage::ServiceWorkerOriginTrialFeature>(arena);
}
template <> PROTOBUF_NOINLINE ::storage::ServiceWorkerOriginTrialInfo* Arena::CreateMaybeMessage<::storage::ServiceWorkerOriginTrialInfo>(Arena* arena)
{
    return Arena::CreateMessageInternal<::storage::ServiceWorkerOriginTrialInfo>(arena);
}
template <>
PROTOBUF_NOINLINE ::storage::ServiceWorkerNavigationPreloadState* Arena::CreateMaybeMessage<::storage::ServiceWorkerNavigationPreloadState>(Arena* arena)
{
    return Arena::CreateMessageInternal<::storage::ServiceWorkerNavigationPreloadState>(arena);
}
template <>
PROTOBUF_NOINLINE ::storage::ServiceWorkerRegistrationData_PolicyContainerPolicies*
Arena::CreateMaybeMessage<::storage::ServiceWorkerRegistrationData_PolicyContainerPolicies>(Arena* arena)
{
    return Arena::CreateMessageInternal<::storage::ServiceWorkerRegistrationData_PolicyContainerPolicies>(arena);
}
template <>
PROTOBUF_NOINLINE ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern*
Arena::CreateMaybeMessage<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern>(Arena* arena)
{
    return Arena::CreateMessageInternal<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern>(arena);
}
template <>
PROTOBUF_NOINLINE ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern*
Arena::CreateMaybeMessage<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern>(Arena* arena)
{
    return Arena::CreateMessageInternal<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern>(arena);
}
template <>
PROTOBUF_NOINLINE ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part*
Arena::CreateMaybeMessage<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part>(Arena* arena)
{
    return Arena::CreateMessageInternal<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part>(arena);
}
template <>
PROTOBUF_NOINLINE ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options*
Arena::CreateMaybeMessage<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options>(Arena* arena)
{
    return Arena::CreateMessageInternal<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options>(arena);
}
template <>
PROTOBUF_NOINLINE ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern*
Arena::CreateMaybeMessage<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern>(Arena* arena)
{
    return Arena::CreateMessageInternal<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern>(arena);
}
template <>
PROTOBUF_NOINLINE ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request*
Arena::CreateMaybeMessage<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request>(Arena* arena)
{
    return Arena::CreateMessageInternal<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request>(arena);
}
template <>
PROTOBUF_NOINLINE ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus*
Arena::CreateMaybeMessage<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus>(Arena* arena)
{
    return Arena::CreateMessageInternal<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus>(arena);
}
template <>
PROTOBUF_NOINLINE ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject*
Arena::CreateMaybeMessage<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject>(Arena* arena)
{
    return Arena::CreateMessageInternal<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject>(arena);
}
template <>
PROTOBUF_NOINLINE ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition*
Arena::CreateMaybeMessage<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition>(Arena* arena)
{
    return Arena::CreateMessageInternal<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition>(arena);
}
template <>
PROTOBUF_NOINLINE ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition*
Arena::CreateMaybeMessage<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition>(Arena* arena)
{
    return Arena::CreateMessageInternal<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition>(arena);
}
template <>
PROTOBUF_NOINLINE ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition*
Arena::CreateMaybeMessage<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition>(Arena* arena)
{
    return Arena::CreateMessageInternal<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition>(arena);
}
template <>
PROTOBUF_NOINLINE ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource*
Arena::CreateMaybeMessage<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource>(Arena* arena)
{
    return Arena::CreateMessageInternal<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource>(arena);
}
template <>
PROTOBUF_NOINLINE ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource*
Arena::CreateMaybeMessage<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource>(Arena* arena)
{
    return Arena::CreateMessageInternal<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource>(arena);
}
template <>
PROTOBUF_NOINLINE ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource*
Arena::CreateMaybeMessage<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource>(Arena* arena)
{
    return Arena::CreateMessageInternal<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource>(arena);
}
template <>
PROTOBUF_NOINLINE ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource*
Arena::CreateMaybeMessage<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource>(Arena* arena)
{
    return Arena::CreateMessageInternal<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource>(arena);
}
template <>
PROTOBUF_NOINLINE ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source*
Arena::CreateMaybeMessage<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source>(Arena* arena)
{
    return Arena::CreateMessageInternal<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source>(arena);
}
template <>
PROTOBUF_NOINLINE ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1*
Arena::CreateMaybeMessage<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1>(Arena* arena)
{
    return Arena::CreateMessageInternal<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1>(arena);
}
template <>
PROTOBUF_NOINLINE ::storage::ServiceWorkerRegistrationData_RouterRules* Arena::CreateMaybeMessage<::storage::ServiceWorkerRegistrationData_RouterRules>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<::storage::ServiceWorkerRegistrationData_RouterRules>(arena);
}
template <> PROTOBUF_NOINLINE ::storage::ServiceWorkerRegistrationData* Arena::CreateMaybeMessage<::storage::ServiceWorkerRegistrationData>(Arena* arena)
{
    return Arena::CreateMessageInternal<::storage::ServiceWorkerRegistrationData>(arena);
}
template <> PROTOBUF_NOINLINE ::storage::ServiceWorkerResourceRecord* Arena::CreateMaybeMessage<::storage::ServiceWorkerResourceRecord>(Arena* arena)
{
    return Arena::CreateMessageInternal<::storage::ServiceWorkerResourceRecord>(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
