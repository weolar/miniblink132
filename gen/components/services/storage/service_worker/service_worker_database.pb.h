// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: service_worker_database.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_service_5fworker_5fdatabase_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_service_5fworker_5fdatabase_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h> // IWYU pragma: export
#include <google/protobuf/extension_set.h> // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_service_5fworker_5fdatabase_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
} // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_service_5fworker_5fdatabase_2eproto {
    static const uint32_t offsets[];
};
namespace storage {
class ServiceWorkerNavigationPreloadState;
struct ServiceWorkerNavigationPreloadStateDefaultTypeInternal;
extern ServiceWorkerNavigationPreloadStateDefaultTypeInternal _ServiceWorkerNavigationPreloadState_default_instance_;
class ServiceWorkerOriginTrialFeature;
struct ServiceWorkerOriginTrialFeatureDefaultTypeInternal;
extern ServiceWorkerOriginTrialFeatureDefaultTypeInternal _ServiceWorkerOriginTrialFeature_default_instance_;
class ServiceWorkerOriginTrialInfo;
struct ServiceWorkerOriginTrialInfoDefaultTypeInternal;
extern ServiceWorkerOriginTrialInfoDefaultTypeInternal _ServiceWorkerOriginTrialInfo_default_instance_;
class ServiceWorkerRegistrationData;
struct ServiceWorkerRegistrationDataDefaultTypeInternal;
extern ServiceWorkerRegistrationDataDefaultTypeInternal _ServiceWorkerRegistrationData_default_instance_;
class ServiceWorkerRegistrationData_PolicyContainerPolicies;
struct ServiceWorkerRegistrationData_PolicyContainerPoliciesDefaultTypeInternal;
extern ServiceWorkerRegistrationData_PolicyContainerPoliciesDefaultTypeInternal _ServiceWorkerRegistrationData_PolicyContainerPolicies_default_instance_;
class ServiceWorkerRegistrationData_RouterRules;
struct ServiceWorkerRegistrationData_RouterRulesDefaultTypeInternal;
extern ServiceWorkerRegistrationData_RouterRulesDefaultTypeInternal _ServiceWorkerRegistrationData_RouterRules_default_instance_;
class ServiceWorkerRegistrationData_RouterRules_RuleV1;
struct ServiceWorkerRegistrationData_RouterRules_RuleV1DefaultTypeInternal;
extern ServiceWorkerRegistrationData_RouterRules_RuleV1DefaultTypeInternal _ServiceWorkerRegistrationData_RouterRules_RuleV1_default_instance_;
class ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition;
struct ServiceWorkerRegistrationData_RouterRules_RuleV1_ConditionDefaultTypeInternal;
extern ServiceWorkerRegistrationData_RouterRules_RuleV1_ConditionDefaultTypeInternal
    _ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_default_instance_;
class ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject;
struct ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObjectDefaultTypeInternal;
extern ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObjectDefaultTypeInternal
    _ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject_default_instance_;
class ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition;
struct ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotConditionDefaultTypeInternal;
extern ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotConditionDefaultTypeInternal
    _ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition_default_instance_;
class ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition;
struct ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrConditionDefaultTypeInternal;
extern ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrConditionDefaultTypeInternal
    _ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition_default_instance_;
class ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request;
struct ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RequestDefaultTypeInternal;
extern ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RequestDefaultTypeInternal
    _ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_default_instance_;
class ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus;
struct ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatusDefaultTypeInternal;
extern ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatusDefaultTypeInternal
    _ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_default_instance_;
class ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern;
struct ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPatternDefaultTypeInternal;
extern ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPatternDefaultTypeInternal
    _ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_default_instance_;
class ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options;
struct ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_OptionsDefaultTypeInternal;
extern ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_OptionsDefaultTypeInternal
    _ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options_default_instance_;
class ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part;
struct ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_PartDefaultTypeInternal;
extern ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_PartDefaultTypeInternal
    _ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_default_instance_;
class ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern;
struct ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPatternDefaultTypeInternal;
extern ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPatternDefaultTypeInternal
    _ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern_default_instance_;
class ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern;
struct ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPatternDefaultTypeInternal;
extern ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPatternDefaultTypeInternal
    _ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern_default_instance_;
class ServiceWorkerRegistrationData_RouterRules_RuleV1_Source;
struct ServiceWorkerRegistrationData_RouterRules_RuleV1_SourceDefaultTypeInternal;
extern ServiceWorkerRegistrationData_RouterRules_RuleV1_SourceDefaultTypeInternal _ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_default_instance_;
class ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource;
struct ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSourceDefaultTypeInternal;
extern ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSourceDefaultTypeInternal
    _ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource_default_instance_;
class ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource;
struct ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSourceDefaultTypeInternal;
extern ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSourceDefaultTypeInternal
    _ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource_default_instance_;
class ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource;
struct ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSourceDefaultTypeInternal;
extern ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSourceDefaultTypeInternal
    _ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource_default_instance_;
class ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource;
struct ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSourceDefaultTypeInternal;
extern ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSourceDefaultTypeInternal
    _ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource_default_instance_;
class ServiceWorkerResourceRecord;
struct ServiceWorkerResourceRecordDefaultTypeInternal;
extern ServiceWorkerResourceRecordDefaultTypeInternal _ServiceWorkerResourceRecord_default_instance_;
} // namespace storage
PROTOBUF_NAMESPACE_OPEN
template <>::storage::ServiceWorkerNavigationPreloadState* Arena::CreateMaybeMessage<::storage::ServiceWorkerNavigationPreloadState>(Arena*);
template <>::storage::ServiceWorkerOriginTrialFeature* Arena::CreateMaybeMessage<::storage::ServiceWorkerOriginTrialFeature>(Arena*);
template <>::storage::ServiceWorkerOriginTrialInfo* Arena::CreateMaybeMessage<::storage::ServiceWorkerOriginTrialInfo>(Arena*);
template <>::storage::ServiceWorkerRegistrationData* Arena::CreateMaybeMessage<::storage::ServiceWorkerRegistrationData>(Arena*);
template <>
::storage::ServiceWorkerRegistrationData_PolicyContainerPolicies* Arena::CreateMaybeMessage<::storage::ServiceWorkerRegistrationData_PolicyContainerPolicies>(
    Arena*);
template <>::storage::ServiceWorkerRegistrationData_RouterRules* Arena::CreateMaybeMessage<::storage::ServiceWorkerRegistrationData_RouterRules>(Arena*);
template <>
::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1* Arena::CreateMaybeMessage<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1>(Arena*);
template <>
::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition*
Arena::CreateMaybeMessage<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition>(Arena*);
template <>
::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject*
Arena::CreateMaybeMessage<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject>(Arena*);
template <>
::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition*
Arena::CreateMaybeMessage<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition>(Arena*);
template <>
::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition*
Arena::CreateMaybeMessage<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition>(Arena*);
template <>
::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request*
Arena::CreateMaybeMessage<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request>(Arena*);
template <>
::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus*
Arena::CreateMaybeMessage<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus>(Arena*);
template <>
::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern*
Arena::CreateMaybeMessage<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern>(Arena*);
template <>
::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options*
Arena::CreateMaybeMessage<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options>(Arena*);
template <>
::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part*
Arena::CreateMaybeMessage<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part>(Arena*);
template <>
::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern*
Arena::CreateMaybeMessage<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern>(Arena*);
template <>
::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern*
Arena::CreateMaybeMessage<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern>(Arena*);
template <>
::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source*
Arena::CreateMaybeMessage<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source>(Arena*);
template <>
::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource*
Arena::CreateMaybeMessage<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource>(Arena*);
template <>
::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource*
Arena::CreateMaybeMessage<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource>(Arena*);
template <>
::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource*
Arena::CreateMaybeMessage<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource>(Arena*);
template <>
::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource*
Arena::CreateMaybeMessage<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource>(Arena*);
template <>::storage::ServiceWorkerResourceRecord* Arena::CreateMaybeMessage<::storage::ServiceWorkerResourceRecord>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace storage {

enum ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier : int {
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier_kNone = 0,
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier_kOptional = 1,
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier_kZeroOrMore = 2,
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier_kOneOrMore = 3
};
bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier_IsValid(int value);
constexpr ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier_Modifier_MIN
    = ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier_kNone;
constexpr ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier_Modifier_MAX
    = ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier_kOneOrMore;
constexpr int ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier_Modifier_ARRAYSIZE
    = ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier_Modifier_MAX + 1;

const std::string& ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier_Name(
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier value);
template <typename T> inline const std::string& ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier>::value || ::std::is_integral<T>::value,
        "Incorrect type passed to function ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier_Name.");
    return ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier_Name(
        static_cast<ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier>(enum_t_value));
}
bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier* value);
enum ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode : int {
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode_kSameOriginMode = 0,
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode_kNoCorsMode = 1,
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode_kCorsMode = 2,
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode_kCorsWithForcedPreflightMode = 3,
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode_kNavigateMode = 4
};
bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode_IsValid(int value);
constexpr ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode_Mode_MIN
    = ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode_kSameOriginMode;
constexpr ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode_Mode_MAX
    = ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode_kNavigateMode;
constexpr int ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode_Mode_ARRAYSIZE
    = ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode_Mode_MAX + 1;

const std::string& ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode_Name(
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode value);
template <typename T> inline const std::string& ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode>::value || ::std::is_integral<T>::value,
        "Incorrect type passed to function ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode_Name.");
    return ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode_Name(
        static_cast<ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode>(enum_t_value));
}
bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode* value);
enum ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination : int {
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_kEmptyDestination = 0,
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_kAudioDestination = 1,
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_kAudioWorkletDestination = 2,
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_kDocumentDestination = 3,
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_kEmbedDestination = 4,
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_kFontDestination = 5,
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_kFrameDestination = 6,
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_kIframeDestination = 7,
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_kImageDestination = 8,
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_kManifestDestination = 9,
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_kObjectDestination = 10,
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_kPaintWorkletDestination = 11,
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_kReportDestination = 12,
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_kScriptDestination = 13,
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_kServiceWorkerDestination = 14,
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_kSharedWorkerDestination = 15,
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_kStyleDestination = 16,
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_kTrackDestination = 17,
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_kVideoDestination = 18,
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_kWebBundleDestination = 19,
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_kWorkerDestination = 20,
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_kXsltDestination = 21,
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_kFencedframeDestination = 22,
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_kWebIdentityDestination = 23,
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_kDictionaryDestination = 24,
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_kSpeculationRulesDestination = 25,
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_kJsonDestination = 26,
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_kSharedStorageWorkletDestination = 27
};
bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_IsValid(int value);
constexpr ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_Destination_MIN
    = ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_kEmptyDestination;
constexpr ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_Destination_MAX
    = ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_kSharedStorageWorkletDestination;
constexpr int ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_Destination_ARRAYSIZE
    = ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_Destination_MAX + 1;

const std::string& ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_Name(
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination value);
template <typename T> inline const std::string& ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination>::value || ::std::is_integral<T>::value,
        "Incorrect type passed to function ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_Name.");
    return ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_Name(
        static_cast<ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination>(enum_t_value));
}
bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination* value);
enum ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_Status : int {
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_Status_kRunning = 0,
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_Status_kNotRunning = 1
};
bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_Status_IsValid(int value);
constexpr ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_Status
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_Status_Status_MIN
    = ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_Status_kRunning;
constexpr ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_Status
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_Status_Status_MAX
    = ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_Status_kNotRunning;
constexpr int ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_Status_Status_ARRAYSIZE
    = ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_Status_Status_MAX + 1;

const std::string& ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_Status_Name(
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_Status value);
template <typename T> inline const std::string& ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_Status_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_Status>::value || ::std::is_integral<T>::value,
        "Incorrect type passed to function ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_Status_Name.");
    return ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_Status_Name(
        static_cast<ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_Status>(enum_t_value));
}
bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_Status* value);
enum ServiceWorkerRegistrationData_ServiceWorkerScriptType : int {
    ServiceWorkerRegistrationData_ServiceWorkerScriptType_CLASSIC = 0,
    ServiceWorkerRegistrationData_ServiceWorkerScriptType_MODULE = 1
};
bool ServiceWorkerRegistrationData_ServiceWorkerScriptType_IsValid(int value);
constexpr ServiceWorkerRegistrationData_ServiceWorkerScriptType ServiceWorkerRegistrationData_ServiceWorkerScriptType_ServiceWorkerScriptType_MIN
    = ServiceWorkerRegistrationData_ServiceWorkerScriptType_CLASSIC;
constexpr ServiceWorkerRegistrationData_ServiceWorkerScriptType ServiceWorkerRegistrationData_ServiceWorkerScriptType_ServiceWorkerScriptType_MAX
    = ServiceWorkerRegistrationData_ServiceWorkerScriptType_MODULE;
constexpr int ServiceWorkerRegistrationData_ServiceWorkerScriptType_ServiceWorkerScriptType_ARRAYSIZE
    = ServiceWorkerRegistrationData_ServiceWorkerScriptType_ServiceWorkerScriptType_MAX + 1;

const std::string& ServiceWorkerRegistrationData_ServiceWorkerScriptType_Name(ServiceWorkerRegistrationData_ServiceWorkerScriptType value);
template <typename T> inline const std::string& ServiceWorkerRegistrationData_ServiceWorkerScriptType_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, ServiceWorkerRegistrationData_ServiceWorkerScriptType>::value || ::std::is_integral<T>::value,
        "Incorrect type passed to function ServiceWorkerRegistrationData_ServiceWorkerScriptType_Name.");
    return ServiceWorkerRegistrationData_ServiceWorkerScriptType_Name(static_cast<ServiceWorkerRegistrationData_ServiceWorkerScriptType>(enum_t_value));
}
bool ServiceWorkerRegistrationData_ServiceWorkerScriptType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ServiceWorkerRegistrationData_ServiceWorkerScriptType* value);
enum ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType : int {
    ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType_IMPORTS = 0,
    ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType_ALL = 1,
    ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType_NONE = 2
};
bool ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType_IsValid(int value);
constexpr ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType
    ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType_ServiceWorkerUpdateViaCacheType_MIN
    = ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType_IMPORTS;
constexpr ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType
    ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType_ServiceWorkerUpdateViaCacheType_MAX
    = ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType_NONE;
constexpr int ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType_ServiceWorkerUpdateViaCacheType_ARRAYSIZE
    = ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType_ServiceWorkerUpdateViaCacheType_MAX + 1;

const std::string& ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType_Name(ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType value);
template <typename T> inline const std::string& ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType>::value || ::std::is_integral<T>::value,
        "Incorrect type passed to function ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType_Name.");
    return ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType_Name(
        static_cast<ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType>(enum_t_value));
}
bool ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType* value);
enum ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue : int {
    ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue_NONE_OR_NOT_EXIST = 0,
    ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue_REQUIRE_CORP = 1,
    ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue_CREDENTIALLESS = 2
};
bool ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue_IsValid(int value);
constexpr ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue
    ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue_CrossOriginEmbedderPolicyValue_MIN
    = ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue_NONE_OR_NOT_EXIST;
constexpr ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue
    ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue_CrossOriginEmbedderPolicyValue_MAX
    = ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue_CREDENTIALLESS;
constexpr int ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue_CrossOriginEmbedderPolicyValue_ARRAYSIZE
    = ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue_CrossOriginEmbedderPolicyValue_MAX + 1;

const std::string& ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue_Name(ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue value);
template <typename T> inline const std::string& ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue>::value || ::std::is_integral<T>::value,
        "Incorrect type passed to function ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue_Name.");
    return ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue_Name(
        static_cast<ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue>(enum_t_value));
}
bool ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue* value);
enum ServiceWorkerRegistrationData_AncestorFrameType : int {
    ServiceWorkerRegistrationData_AncestorFrameType_NORMAL_FRAME = 0,
    ServiceWorkerRegistrationData_AncestorFrameType_FENCED_FRAME = 1
};
bool ServiceWorkerRegistrationData_AncestorFrameType_IsValid(int value);
constexpr ServiceWorkerRegistrationData_AncestorFrameType ServiceWorkerRegistrationData_AncestorFrameType_AncestorFrameType_MIN
    = ServiceWorkerRegistrationData_AncestorFrameType_NORMAL_FRAME;
constexpr ServiceWorkerRegistrationData_AncestorFrameType ServiceWorkerRegistrationData_AncestorFrameType_AncestorFrameType_MAX
    = ServiceWorkerRegistrationData_AncestorFrameType_FENCED_FRAME;
constexpr int ServiceWorkerRegistrationData_AncestorFrameType_AncestorFrameType_ARRAYSIZE
    = ServiceWorkerRegistrationData_AncestorFrameType_AncestorFrameType_MAX + 1;

const std::string& ServiceWorkerRegistrationData_AncestorFrameType_Name(ServiceWorkerRegistrationData_AncestorFrameType value);
template <typename T> inline const std::string& ServiceWorkerRegistrationData_AncestorFrameType_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, ServiceWorkerRegistrationData_AncestorFrameType>::value || ::std::is_integral<T>::value,
        "Incorrect type passed to function ServiceWorkerRegistrationData_AncestorFrameType_Name.");
    return ServiceWorkerRegistrationData_AncestorFrameType_Name(static_cast<ServiceWorkerRegistrationData_AncestorFrameType>(enum_t_value));
}
bool ServiceWorkerRegistrationData_AncestorFrameType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ServiceWorkerRegistrationData_AncestorFrameType* value);
enum ServiceWorkerRegistrationData_FetchHandlerSkippableType : int {
    ServiceWorkerRegistrationData_FetchHandlerSkippableType_NOT_SKIPPABLE = 1,
    ServiceWorkerRegistrationData_FetchHandlerSkippableType_SKIPPABLE_EMPTY_FETCH_HANDLER = 2
};
bool ServiceWorkerRegistrationData_FetchHandlerSkippableType_IsValid(int value);
constexpr ServiceWorkerRegistrationData_FetchHandlerSkippableType ServiceWorkerRegistrationData_FetchHandlerSkippableType_FetchHandlerSkippableType_MIN
    = ServiceWorkerRegistrationData_FetchHandlerSkippableType_NOT_SKIPPABLE;
constexpr ServiceWorkerRegistrationData_FetchHandlerSkippableType ServiceWorkerRegistrationData_FetchHandlerSkippableType_FetchHandlerSkippableType_MAX
    = ServiceWorkerRegistrationData_FetchHandlerSkippableType_SKIPPABLE_EMPTY_FETCH_HANDLER;
constexpr int ServiceWorkerRegistrationData_FetchHandlerSkippableType_FetchHandlerSkippableType_ARRAYSIZE
    = ServiceWorkerRegistrationData_FetchHandlerSkippableType_FetchHandlerSkippableType_MAX + 1;

const std::string& ServiceWorkerRegistrationData_FetchHandlerSkippableType_Name(ServiceWorkerRegistrationData_FetchHandlerSkippableType value);
template <typename T> inline const std::string& ServiceWorkerRegistrationData_FetchHandlerSkippableType_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, ServiceWorkerRegistrationData_FetchHandlerSkippableType>::value || ::std::is_integral<T>::value,
        "Incorrect type passed to function ServiceWorkerRegistrationData_FetchHandlerSkippableType_Name.");
    return ServiceWorkerRegistrationData_FetchHandlerSkippableType_Name(static_cast<ServiceWorkerRegistrationData_FetchHandlerSkippableType>(enum_t_value));
}
bool ServiceWorkerRegistrationData_FetchHandlerSkippableType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ServiceWorkerRegistrationData_FetchHandlerSkippableType* value);
enum ServiceWorkerRegistrationData_ReferrerPolicyValue : int {
    ServiceWorkerRegistrationData_ReferrerPolicyValue_ALWAYS = 0,
    ServiceWorkerRegistrationData_ReferrerPolicyValue_DEFAULT = 1,
    ServiceWorkerRegistrationData_ReferrerPolicyValue_NO_REFERRER_WHEN_DOWNGRADE = 2,
    ServiceWorkerRegistrationData_ReferrerPolicyValue_NEVER = 3,
    ServiceWorkerRegistrationData_ReferrerPolicyValue_ORIGIN = 4,
    ServiceWorkerRegistrationData_ReferrerPolicyValue_ORIGIN_WHEN_CROSS_ORIGIN = 5,
    ServiceWorkerRegistrationData_ReferrerPolicyValue_STRICT_ORIGIN_WHEN_CROSS_ORIGIN = 6,
    ServiceWorkerRegistrationData_ReferrerPolicyValue_SAME_ORIGIN = 7,
    ServiceWorkerRegistrationData_ReferrerPolicyValue_STRICT_ORIGIN = 8
};
bool ServiceWorkerRegistrationData_ReferrerPolicyValue_IsValid(int value);
constexpr ServiceWorkerRegistrationData_ReferrerPolicyValue ServiceWorkerRegistrationData_ReferrerPolicyValue_ReferrerPolicyValue_MIN
    = ServiceWorkerRegistrationData_ReferrerPolicyValue_ALWAYS;
constexpr ServiceWorkerRegistrationData_ReferrerPolicyValue ServiceWorkerRegistrationData_ReferrerPolicyValue_ReferrerPolicyValue_MAX
    = ServiceWorkerRegistrationData_ReferrerPolicyValue_STRICT_ORIGIN;
constexpr int ServiceWorkerRegistrationData_ReferrerPolicyValue_ReferrerPolicyValue_ARRAYSIZE
    = ServiceWorkerRegistrationData_ReferrerPolicyValue_ReferrerPolicyValue_MAX + 1;

const std::string& ServiceWorkerRegistrationData_ReferrerPolicyValue_Name(ServiceWorkerRegistrationData_ReferrerPolicyValue value);
template <typename T> inline const std::string& ServiceWorkerRegistrationData_ReferrerPolicyValue_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, ServiceWorkerRegistrationData_ReferrerPolicyValue>::value || ::std::is_integral<T>::value,
        "Incorrect type passed to function ServiceWorkerRegistrationData_ReferrerPolicyValue_Name.");
    return ServiceWorkerRegistrationData_ReferrerPolicyValue_Name(static_cast<ServiceWorkerRegistrationData_ReferrerPolicyValue>(enum_t_value));
}
bool ServiceWorkerRegistrationData_ReferrerPolicyValue_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ServiceWorkerRegistrationData_ReferrerPolicyValue* value);
enum ServiceWorkerRegistrationData_IPAddressSpace : int {
    ServiceWorkerRegistrationData_IPAddressSpace_UNKNOWN = 0,
    ServiceWorkerRegistrationData_IPAddressSpace_LOCAL = 1,
    ServiceWorkerRegistrationData_IPAddressSpace_PRIVATE = 2,
    ServiceWorkerRegistrationData_IPAddressSpace_PUBLIC = 3
};
bool ServiceWorkerRegistrationData_IPAddressSpace_IsValid(int value);
constexpr ServiceWorkerRegistrationData_IPAddressSpace ServiceWorkerRegistrationData_IPAddressSpace_IPAddressSpace_MIN
    = ServiceWorkerRegistrationData_IPAddressSpace_UNKNOWN;
constexpr ServiceWorkerRegistrationData_IPAddressSpace ServiceWorkerRegistrationData_IPAddressSpace_IPAddressSpace_MAX
    = ServiceWorkerRegistrationData_IPAddressSpace_PUBLIC;
constexpr int ServiceWorkerRegistrationData_IPAddressSpace_IPAddressSpace_ARRAYSIZE = ServiceWorkerRegistrationData_IPAddressSpace_IPAddressSpace_MAX + 1;

const std::string& ServiceWorkerRegistrationData_IPAddressSpace_Name(ServiceWorkerRegistrationData_IPAddressSpace value);
template <typename T> inline const std::string& ServiceWorkerRegistrationData_IPAddressSpace_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, ServiceWorkerRegistrationData_IPAddressSpace>::value || ::std::is_integral<T>::value,
        "Incorrect type passed to function ServiceWorkerRegistrationData_IPAddressSpace_Name.");
    return ServiceWorkerRegistrationData_IPAddressSpace_Name(static_cast<ServiceWorkerRegistrationData_IPAddressSpace>(enum_t_value));
}
bool ServiceWorkerRegistrationData_IPAddressSpace_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ServiceWorkerRegistrationData_IPAddressSpace* value);
// ===================================================================

class ServiceWorkerOriginTrialFeature final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:storage.ServiceWorkerOriginTrialFeature) */ {
public:
    inline ServiceWorkerOriginTrialFeature()
        : ServiceWorkerOriginTrialFeature(nullptr)
    {
    }
    ~ServiceWorkerOriginTrialFeature() override;
    explicit PROTOBUF_CONSTEXPR ServiceWorkerOriginTrialFeature(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ServiceWorkerOriginTrialFeature(const ServiceWorkerOriginTrialFeature& from);
    ServiceWorkerOriginTrialFeature(ServiceWorkerOriginTrialFeature&& from) noexcept
        : ServiceWorkerOriginTrialFeature()
    {
        *this = ::std::move(from);
    }

    inline ServiceWorkerOriginTrialFeature& operator=(const ServiceWorkerOriginTrialFeature& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ServiceWorkerOriginTrialFeature& operator=(ServiceWorkerOriginTrialFeature&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ServiceWorkerOriginTrialFeature& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ServiceWorkerOriginTrialFeature* internal_default_instance()
    {
        return reinterpret_cast<const ServiceWorkerOriginTrialFeature*>(&_ServiceWorkerOriginTrialFeature_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 0;

    friend void swap(ServiceWorkerOriginTrialFeature& a, ServiceWorkerOriginTrialFeature& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ServiceWorkerOriginTrialFeature* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ServiceWorkerOriginTrialFeature* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ServiceWorkerOriginTrialFeature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ServiceWorkerOriginTrialFeature>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ServiceWorkerOriginTrialFeature& from);
    void MergeFrom(const ServiceWorkerOriginTrialFeature& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ServiceWorkerOriginTrialFeature* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "storage.ServiceWorkerOriginTrialFeature";
    }

protected:
    explicit ServiceWorkerOriginTrialFeature(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kTokensFieldNumber = 2,
        kNameFieldNumber = 1,
    };
    // repeated string tokens = 2;
    int tokens_size() const;

private:
    int _internal_tokens_size() const;

public:
    void clear_tokens();
    const std::string& tokens(int index) const;
    std::string* mutable_tokens(int index);
    void set_tokens(int index, const std::string& value);
    void set_tokens(int index, std::string&& value);
    void set_tokens(int index, const char* value);
    void set_tokens(int index, const char* value, size_t size);
    std::string* add_tokens();
    void add_tokens(const std::string& value);
    void add_tokens(std::string&& value);
    void add_tokens(const char* value);
    void add_tokens(const char* value, size_t size);
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tokens() const;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tokens();

private:
    const std::string& _internal_tokens(int index) const;
    std::string* _internal_add_tokens();

public:
    // required string name = 1;
    bool has_name() const;

private:
    bool _internal_has_name() const;

public:
    void clear_name();
    const std::string& name() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_name(ArgT0&& arg0, ArgT... args);
    std::string* mutable_name();
    PROTOBUF_NODISCARD std::string* release_name();
    void set_allocated_name(std::string* name);

private:
    const std::string& _internal_name() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
    std::string* _internal_mutable_name();

public:
    // @@protoc_insertion_point(class_scope:storage.ServiceWorkerOriginTrialFeature)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tokens_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_service_5fworker_5fdatabase_2eproto;
};
// -------------------------------------------------------------------

class ServiceWorkerOriginTrialInfo final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:storage.ServiceWorkerOriginTrialInfo) */ {
public:
    inline ServiceWorkerOriginTrialInfo()
        : ServiceWorkerOriginTrialInfo(nullptr)
    {
    }
    ~ServiceWorkerOriginTrialInfo() override;
    explicit PROTOBUF_CONSTEXPR ServiceWorkerOriginTrialInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ServiceWorkerOriginTrialInfo(const ServiceWorkerOriginTrialInfo& from);
    ServiceWorkerOriginTrialInfo(ServiceWorkerOriginTrialInfo&& from) noexcept
        : ServiceWorkerOriginTrialInfo()
    {
        *this = ::std::move(from);
    }

    inline ServiceWorkerOriginTrialInfo& operator=(const ServiceWorkerOriginTrialInfo& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ServiceWorkerOriginTrialInfo& operator=(ServiceWorkerOriginTrialInfo&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ServiceWorkerOriginTrialInfo& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ServiceWorkerOriginTrialInfo* internal_default_instance()
    {
        return reinterpret_cast<const ServiceWorkerOriginTrialInfo*>(&_ServiceWorkerOriginTrialInfo_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 1;

    friend void swap(ServiceWorkerOriginTrialInfo& a, ServiceWorkerOriginTrialInfo& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ServiceWorkerOriginTrialInfo* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ServiceWorkerOriginTrialInfo* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ServiceWorkerOriginTrialInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ServiceWorkerOriginTrialInfo>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ServiceWorkerOriginTrialInfo& from);
    void MergeFrom(const ServiceWorkerOriginTrialInfo& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ServiceWorkerOriginTrialInfo* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "storage.ServiceWorkerOriginTrialInfo";
    }

protected:
    explicit ServiceWorkerOriginTrialInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kFeaturesFieldNumber = 1,
    };
    // repeated .storage.ServiceWorkerOriginTrialFeature features = 1;
    int features_size() const;

private:
    int _internal_features_size() const;

public:
    void clear_features();
    ::storage::ServiceWorkerOriginTrialFeature* mutable_features(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerOriginTrialFeature>* mutable_features();

private:
    const ::storage::ServiceWorkerOriginTrialFeature& _internal_features(int index) const;
    ::storage::ServiceWorkerOriginTrialFeature* _internal_add_features();

public:
    const ::storage::ServiceWorkerOriginTrialFeature& features(int index) const;
    ::storage::ServiceWorkerOriginTrialFeature* add_features();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerOriginTrialFeature>& features() const;

    // @@protoc_insertion_point(class_scope:storage.ServiceWorkerOriginTrialInfo)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerOriginTrialFeature> features_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_service_5fworker_5fdatabase_2eproto;
};
// -------------------------------------------------------------------

class ServiceWorkerNavigationPreloadState final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:storage.ServiceWorkerNavigationPreloadState) */ {
public:
    inline ServiceWorkerNavigationPreloadState()
        : ServiceWorkerNavigationPreloadState(nullptr)
    {
    }
    ~ServiceWorkerNavigationPreloadState() override;
    explicit PROTOBUF_CONSTEXPR ServiceWorkerNavigationPreloadState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ServiceWorkerNavigationPreloadState(const ServiceWorkerNavigationPreloadState& from);
    ServiceWorkerNavigationPreloadState(ServiceWorkerNavigationPreloadState&& from) noexcept
        : ServiceWorkerNavigationPreloadState()
    {
        *this = ::std::move(from);
    }

    inline ServiceWorkerNavigationPreloadState& operator=(const ServiceWorkerNavigationPreloadState& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ServiceWorkerNavigationPreloadState& operator=(ServiceWorkerNavigationPreloadState&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ServiceWorkerNavigationPreloadState& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ServiceWorkerNavigationPreloadState* internal_default_instance()
    {
        return reinterpret_cast<const ServiceWorkerNavigationPreloadState*>(&_ServiceWorkerNavigationPreloadState_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 2;

    friend void swap(ServiceWorkerNavigationPreloadState& a, ServiceWorkerNavigationPreloadState& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ServiceWorkerNavigationPreloadState* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ServiceWorkerNavigationPreloadState* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ServiceWorkerNavigationPreloadState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ServiceWorkerNavigationPreloadState>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ServiceWorkerNavigationPreloadState& from);
    void MergeFrom(const ServiceWorkerNavigationPreloadState& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ServiceWorkerNavigationPreloadState* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "storage.ServiceWorkerNavigationPreloadState";
    }

protected:
    explicit ServiceWorkerNavigationPreloadState(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kHeaderFieldNumber = 2,
        kEnabledFieldNumber = 1,
    };
    // optional string header = 2;
    bool has_header() const;

private:
    bool _internal_has_header() const;

public:
    void clear_header();
    const std::string& header() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_header(ArgT0&& arg0, ArgT... args);
    std::string* mutable_header();
    PROTOBUF_NODISCARD std::string* release_header();
    void set_allocated_header(std::string* header);

private:
    const std::string& _internal_header() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_header(const std::string& value);
    std::string* _internal_mutable_header();

public:
    // required bool enabled = 1;
    bool has_enabled() const;

private:
    bool _internal_has_enabled() const;

public:
    void clear_enabled();
    bool enabled() const;
    void set_enabled(bool value);

private:
    bool _internal_enabled() const;
    void _internal_set_enabled(bool value);

public:
    // @@protoc_insertion_point(class_scope:storage.ServiceWorkerNavigationPreloadState)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr header_;
        bool enabled_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_service_5fworker_5fdatabase_2eproto;
};
// -------------------------------------------------------------------

class ServiceWorkerRegistrationData_PolicyContainerPolicies final
    : public ::PROTOBUF_NAMESPACE_ID::
          MessageLite /* @@protoc_insertion_point(class_definition:storage.ServiceWorkerRegistrationData.PolicyContainerPolicies) */ {
public:
    inline ServiceWorkerRegistrationData_PolicyContainerPolicies()
        : ServiceWorkerRegistrationData_PolicyContainerPolicies(nullptr)
    {
    }
    ~ServiceWorkerRegistrationData_PolicyContainerPolicies() override;
    explicit PROTOBUF_CONSTEXPR ServiceWorkerRegistrationData_PolicyContainerPolicies(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ServiceWorkerRegistrationData_PolicyContainerPolicies(const ServiceWorkerRegistrationData_PolicyContainerPolicies& from);
    ServiceWorkerRegistrationData_PolicyContainerPolicies(ServiceWorkerRegistrationData_PolicyContainerPolicies&& from) noexcept
        : ServiceWorkerRegistrationData_PolicyContainerPolicies()
    {
        *this = ::std::move(from);
    }

    inline ServiceWorkerRegistrationData_PolicyContainerPolicies& operator=(const ServiceWorkerRegistrationData_PolicyContainerPolicies& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ServiceWorkerRegistrationData_PolicyContainerPolicies& operator=(ServiceWorkerRegistrationData_PolicyContainerPolicies&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ServiceWorkerRegistrationData_PolicyContainerPolicies& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ServiceWorkerRegistrationData_PolicyContainerPolicies* internal_default_instance()
    {
        return reinterpret_cast<const ServiceWorkerRegistrationData_PolicyContainerPolicies*>(
            &_ServiceWorkerRegistrationData_PolicyContainerPolicies_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 3;

    friend void swap(ServiceWorkerRegistrationData_PolicyContainerPolicies& a, ServiceWorkerRegistrationData_PolicyContainerPolicies& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ServiceWorkerRegistrationData_PolicyContainerPolicies* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ServiceWorkerRegistrationData_PolicyContainerPolicies* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ServiceWorkerRegistrationData_PolicyContainerPolicies* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ServiceWorkerRegistrationData_PolicyContainerPolicies>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ServiceWorkerRegistrationData_PolicyContainerPolicies& from);
    void MergeFrom(const ServiceWorkerRegistrationData_PolicyContainerPolicies& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ServiceWorkerRegistrationData_PolicyContainerPolicies* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "storage.ServiceWorkerRegistrationData.PolicyContainerPolicies";
    }

protected:
    explicit ServiceWorkerRegistrationData_PolicyContainerPolicies(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kSandboxFlagsFieldNumber = 2,
        kIpAddressSpaceFieldNumber = 3,
        kReferrerPolicyFieldNumber = 1,
    };
    // optional int32 sandbox_flags = 2 [default = 0];
    bool has_sandbox_flags() const;

private:
    bool _internal_has_sandbox_flags() const;

public:
    void clear_sandbox_flags();
    int32_t sandbox_flags() const;
    void set_sandbox_flags(int32_t value);

private:
    int32_t _internal_sandbox_flags() const;
    void _internal_set_sandbox_flags(int32_t value);

public:
    // optional .storage.ServiceWorkerRegistrationData.IPAddressSpace ip_address_space = 3 [default = UNKNOWN];
    bool has_ip_address_space() const;

private:
    bool _internal_has_ip_address_space() const;

public:
    void clear_ip_address_space();
    ::storage::ServiceWorkerRegistrationData_IPAddressSpace ip_address_space() const;
    void set_ip_address_space(::storage::ServiceWorkerRegistrationData_IPAddressSpace value);

private:
    ::storage::ServiceWorkerRegistrationData_IPAddressSpace _internal_ip_address_space() const;
    void _internal_set_ip_address_space(::storage::ServiceWorkerRegistrationData_IPAddressSpace value);

public:
    // optional .storage.ServiceWorkerRegistrationData.ReferrerPolicyValue referrer_policy = 1 [default = DEFAULT];
    bool has_referrer_policy() const;

private:
    bool _internal_has_referrer_policy() const;

public:
    void clear_referrer_policy();
    ::storage::ServiceWorkerRegistrationData_ReferrerPolicyValue referrer_policy() const;
    void set_referrer_policy(::storage::ServiceWorkerRegistrationData_ReferrerPolicyValue value);

private:
    ::storage::ServiceWorkerRegistrationData_ReferrerPolicyValue _internal_referrer_policy() const;
    void _internal_set_referrer_policy(::storage::ServiceWorkerRegistrationData_ReferrerPolicyValue value);

public:
    // @@protoc_insertion_point(class_scope:storage.ServiceWorkerRegistrationData.PolicyContainerPolicies)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        int32_t sandbox_flags_;
        int ip_address_space_;
        int referrer_policy_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_service_5fworker_5fdatabase_2eproto;
};
// -------------------------------------------------------------------

class ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern final
    : public ::PROTOBUF_NAMESPACE_ID::
          MessageLite /* @@protoc_insertion_point(class_definition:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.FixedPattern) */
{
public:
    inline ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern()
        : ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern(nullptr)
    {
    }
    ~ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern() override;
    explicit PROTOBUF_CONSTEXPR ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern(
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern(
        const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern& from);
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern(
        ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern&& from) noexcept
        : ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern()
    {
        *this = ::std::move(from);
    }

    inline ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern& operator=(
        const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern& operator=(
        ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern* internal_default_instance()
    {
        return reinterpret_cast<const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern*>(
            &_ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 4;

    friend void swap(ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern& a,
        ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern& from);
    void MergeFrom(const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.FixedPattern";
    }

protected:
    explicit ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern(
        ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kValueFieldNumber = 1,
    };
    // optional string value = 1;
    bool has_value() const;

private:
    bool _internal_has_value() const;

public:
    void clear_value();
    const std::string& value() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_value(ArgT0&& arg0, ArgT... args);
    std::string* mutable_value();
    PROTOBUF_NODISCARD std::string* release_value();
    void set_allocated_value(std::string* value);

private:
    const std::string& _internal_value() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
    std::string* _internal_mutable_value();

public:
    // @@protoc_insertion_point(class_scope:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.FixedPattern)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_service_5fworker_5fdatabase_2eproto;
};
// -------------------------------------------------------------------

class ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern final
    : public ::PROTOBUF_NAMESPACE_ID::
          MessageLite /* @@protoc_insertion_point(class_definition:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.WildcardPattern) */
{
public:
    inline ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern()
        : ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern(nullptr)
    {
    }
    ~ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern() override;
    explicit PROTOBUF_CONSTEXPR ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern(
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern(
        const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern& from);
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern(
        ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern&& from) noexcept
        : ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern()
    {
        *this = ::std::move(from);
    }

    inline ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern& operator=(
        const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern& operator=(
        ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern* internal_default_instance()
    {
        return reinterpret_cast<const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern*>(
            &_ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 5;

    friend void swap(ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern& a,
        ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern& from);
    void MergeFrom(const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.WildcardPattern";
    }

protected:
    explicit ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern(
        ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kNameFieldNumber = 1,
        kPrefixFieldNumber = 2,
        kValueFieldNumber = 3,
        kSuffixFieldNumber = 4,
    };
    // optional string name = 1;
    bool has_name() const;

private:
    bool _internal_has_name() const;

public:
    void clear_name();
    const std::string& name() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_name(ArgT0&& arg0, ArgT... args);
    std::string* mutable_name();
    PROTOBUF_NODISCARD std::string* release_name();
    void set_allocated_name(std::string* name);

private:
    const std::string& _internal_name() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
    std::string* _internal_mutable_name();

public:
    // optional string prefix = 2;
    bool has_prefix() const;

private:
    bool _internal_has_prefix() const;

public:
    void clear_prefix();
    const std::string& prefix() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_prefix(ArgT0&& arg0, ArgT... args);
    std::string* mutable_prefix();
    PROTOBUF_NODISCARD std::string* release_prefix();
    void set_allocated_prefix(std::string* prefix);

private:
    const std::string& _internal_prefix() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_prefix(const std::string& value);
    std::string* _internal_mutable_prefix();

public:
    // optional string value = 3;
    bool has_value() const;

private:
    bool _internal_has_value() const;

public:
    void clear_value();
    const std::string& value() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_value(ArgT0&& arg0, ArgT... args);
    std::string* mutable_value();
    PROTOBUF_NODISCARD std::string* release_value();
    void set_allocated_value(std::string* value);

private:
    const std::string& _internal_value() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
    std::string* _internal_mutable_value();

public:
    // optional string suffix = 4;
    bool has_suffix() const;

private:
    bool _internal_has_suffix() const;

public:
    void clear_suffix();
    const std::string& suffix() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_suffix(ArgT0&& arg0, ArgT... args);
    std::string* mutable_suffix();
    PROTOBUF_NODISCARD std::string* release_suffix();
    void set_allocated_suffix(std::string* suffix);

private:
    const std::string& _internal_suffix() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_suffix(const std::string& value);
    std::string* _internal_mutable_suffix();

public:
    // @@protoc_insertion_point(class_scope:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.WildcardPattern)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr prefix_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr suffix_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_service_5fworker_5fdatabase_2eproto;
};
// -------------------------------------------------------------------

class ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part final
    : public ::PROTOBUF_NAMESPACE_ID::
          MessageLite /* @@protoc_insertion_point(class_definition:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part) */ {
public:
    inline ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part()
        : ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part(nullptr)
    {
    }
    ~ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part() override;
    explicit PROTOBUF_CONSTEXPR ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part(
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part(
        const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part& from);
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part(
        ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part&& from) noexcept
        : ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part()
    {
        *this = ::std::move(from);
    }

    inline ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part& operator=(
        const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part& operator=(
        ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part& default_instance()
    {
        return *internal_default_instance();
    }
    enum PatternCase {
        kFixed = 2,
        kSegmentWildcard = 4,
        kFullWildcard = 5,
        PATTERN_NOT_SET = 0,
    };

    static inline const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part* internal_default_instance()
    {
        return reinterpret_cast<const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part*>(
            &_ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 6;

    friend void swap(ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part& a,
        ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part& from);
    void MergeFrom(const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part";
    }

protected:
    explicit ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern FixedPattern;
    typedef ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern WildcardPattern;

    typedef ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier Modifier;
    static constexpr Modifier kNone = ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier_kNone;
    static constexpr Modifier kOptional = ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier_kOptional;
    static constexpr Modifier kZeroOrMore = ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier_kZeroOrMore;
    static constexpr Modifier kOneOrMore = ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier_kOneOrMore;
    static inline bool Modifier_IsValid(int value)
    {
        return ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier_IsValid(value);
    }
    static constexpr Modifier Modifier_MIN = ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier_Modifier_MIN;
    static constexpr Modifier Modifier_MAX = ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier_Modifier_MAX;
    static constexpr int Modifier_ARRAYSIZE = ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier_Modifier_ARRAYSIZE;
    template <typename T> static inline const std::string& Modifier_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, Modifier>::value || ::std::is_integral<T>::value, "Incorrect type passed to function Modifier_Name.");
        return ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier_Name(enum_t_value);
    }
    static inline bool Modifier_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Modifier* value)
    {
        return ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier_Parse(name, value);
    }

    // accessors -------------------------------------------------------

    enum : int {
        kModifierFieldNumber = 1,
        kFixedFieldNumber = 2,
        kSegmentWildcardFieldNumber = 4,
        kFullWildcardFieldNumber = 5,
    };
    // optional .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.Modifier modifier = 1;
    bool has_modifier() const;

private:
    bool _internal_has_modifier() const;

public:
    void clear_modifier();
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier modifier() const;
    void set_modifier(::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier value);

private:
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier _internal_modifier() const;
    void _internal_set_modifier(::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier value);

public:
    // .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.FixedPattern fixed = 2;
    bool has_fixed() const;

private:
    bool _internal_has_fixed() const;

public:
    void clear_fixed();
    const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern& fixed() const;
    PROTOBUF_NODISCARD ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern* release_fixed();
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern* mutable_fixed();
    void set_allocated_fixed(::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern* fixed);

private:
    const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern& _internal_fixed() const;
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern* _internal_mutable_fixed();

public:
    void unsafe_arena_set_allocated_fixed(::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern* fixed);
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern* unsafe_arena_release_fixed();

    // .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.WildcardPattern segment_wildcard = 4;
    bool has_segment_wildcard() const;

private:
    bool _internal_has_segment_wildcard() const;

public:
    void clear_segment_wildcard();
    const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern& segment_wildcard() const;
    PROTOBUF_NODISCARD ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern* release_segment_wildcard();
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern* mutable_segment_wildcard();
    void set_allocated_segment_wildcard(
        ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern* segment_wildcard);

private:
    const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern& _internal_segment_wildcard() const;
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern* _internal_mutable_segment_wildcard();

public:
    void unsafe_arena_set_allocated_segment_wildcard(
        ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern* segment_wildcard);
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern* unsafe_arena_release_segment_wildcard();

    // .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.WildcardPattern full_wildcard = 5;
    bool has_full_wildcard() const;

private:
    bool _internal_has_full_wildcard() const;

public:
    void clear_full_wildcard();
    const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern& full_wildcard() const;
    PROTOBUF_NODISCARD ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern* release_full_wildcard();
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern* mutable_full_wildcard();
    void set_allocated_full_wildcard(::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern* full_wildcard);

private:
    const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern& _internal_full_wildcard() const;
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern* _internal_mutable_full_wildcard();

public:
    void unsafe_arena_set_allocated_full_wildcard(
        ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern* full_wildcard);
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern* unsafe_arena_release_full_wildcard();

    void clear_pattern();
    PatternCase pattern_case() const;
    // @@protoc_insertion_point(class_scope:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part)
private:
    class _Internal;
    void set_has_fixed();
    void set_has_segment_wildcard();
    void set_has_full_wildcard();

    inline bool has_pattern() const;
    inline void clear_has_pattern();

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        int modifier_;
        union PatternUnion {
            constexpr PatternUnion()
                : _constinit_ {}
            {
            }
            ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
            ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern* fixed_;
            ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern* segment_wildcard_;
            ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern* full_wildcard_;
        } pattern_;
        uint32_t _oneof_case_[1];
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_service_5fworker_5fdatabase_2eproto;
};
// -------------------------------------------------------------------

class ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options final
    : public ::PROTOBUF_NAMESPACE_ID::
          MessageLite /* @@protoc_insertion_point(class_definition:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Options) */ {
public:
    inline ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options()
        : ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options(nullptr)
    {
    }
    ~ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options() override;
    explicit PROTOBUF_CONSTEXPR ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options(
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options(
        const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options& from);
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options(
        ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options&& from) noexcept
        : ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options()
    {
        *this = ::std::move(from);
    }

    inline ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options& operator=(
        const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options& operator=(
        ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options* internal_default_instance()
    {
        return reinterpret_cast<const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options*>(
            &_ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 7;

    friend void swap(ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options& a,
        ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options& from);
    void MergeFrom(const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Options";
    }

protected:
    explicit ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options(
        ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kIgnoreCaseFieldNumber = 1,
    };
    // optional bool ignore_case = 1 [default = false];
    bool has_ignore_case() const;

private:
    bool _internal_has_ignore_case() const;

public:
    void clear_ignore_case();
    bool ignore_case() const;
    void set_ignore_case(bool value);

private:
    bool _internal_ignore_case() const;
    void _internal_set_ignore_case(bool value);

public:
    // @@protoc_insertion_point(class_scope:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Options)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        bool ignore_case_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_service_5fworker_5fdatabase_2eproto;
};
// -------------------------------------------------------------------

class ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern final
    : public ::PROTOBUF_NAMESPACE_ID::
          MessageLite /* @@protoc_insertion_point(class_definition:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern) */ {
public:
    inline ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern()
        : ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern(nullptr)
    {
    }
    ~ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern() override;
    explicit PROTOBUF_CONSTEXPR ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern(const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern& from);
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern(ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern&& from) noexcept
        : ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern()
    {
        *this = ::std::move(from);
    }

    inline ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern& operator=(
        const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern& operator=(
        ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern* internal_default_instance()
    {
        return reinterpret_cast<const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern*>(
            &_ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 8;

    friend void swap(
        ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern& a, ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern& from);
    void MergeFrom(const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern";
    }

protected:
    explicit ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part Part;
    typedef ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options Options;

    // accessors -------------------------------------------------------

    enum : int {
        kLegacyPathnameFieldNumber = 1,
        kHostnameFieldNumber = 2,
        kProtocolFieldNumber = 3,
        kUsernameFieldNumber = 4,
        kPasswordFieldNumber = 5,
        kPortFieldNumber = 6,
        kPathnameFieldNumber = 7,
        kSearchFieldNumber = 8,
        kHashFieldNumber = 9,
        kOptionsFieldNumber = 10,
    };
    // repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part legacy_pathname = 1;
    int legacy_pathname_size() const;

private:
    int _internal_legacy_pathname_size() const;

public:
    void clear_legacy_pathname();
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part* mutable_legacy_pathname(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part>* mutable_legacy_pathname();

private:
    const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part& _internal_legacy_pathname(int index) const;
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part* _internal_add_legacy_pathname();

public:
    const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part& legacy_pathname(int index) const;
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part* add_legacy_pathname();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part>&
    legacy_pathname() const;

    // repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part hostname = 2;
    int hostname_size() const;

private:
    int _internal_hostname_size() const;

public:
    void clear_hostname();
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part* mutable_hostname(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part>* mutable_hostname();

private:
    const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part& _internal_hostname(int index) const;
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part* _internal_add_hostname();

public:
    const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part& hostname(int index) const;
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part* add_hostname();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part>& hostname() const;

    // repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part protocol = 3;
    int protocol_size() const;

private:
    int _internal_protocol_size() const;

public:
    void clear_protocol();
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part* mutable_protocol(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part>* mutable_protocol();

private:
    const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part& _internal_protocol(int index) const;
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part* _internal_add_protocol();

public:
    const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part& protocol(int index) const;
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part* add_protocol();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part>& protocol() const;

    // repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part username = 4;
    int username_size() const;

private:
    int _internal_username_size() const;

public:
    void clear_username();
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part* mutable_username(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part>* mutable_username();

private:
    const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part& _internal_username(int index) const;
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part* _internal_add_username();

public:
    const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part& username(int index) const;
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part* add_username();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part>& username() const;

    // repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part password = 5;
    int password_size() const;

private:
    int _internal_password_size() const;

public:
    void clear_password();
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part* mutable_password(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part>* mutable_password();

private:
    const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part& _internal_password(int index) const;
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part* _internal_add_password();

public:
    const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part& password(int index) const;
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part* add_password();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part>& password() const;

    // repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part port = 6;
    int port_size() const;

private:
    int _internal_port_size() const;

public:
    void clear_port();
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part* mutable_port(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part>* mutable_port();

private:
    const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part& _internal_port(int index) const;
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part* _internal_add_port();

public:
    const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part& port(int index) const;
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part* add_port();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part>& port() const;

    // repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part pathname = 7;
    int pathname_size() const;

private:
    int _internal_pathname_size() const;

public:
    void clear_pathname();
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part* mutable_pathname(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part>* mutable_pathname();

private:
    const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part& _internal_pathname(int index) const;
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part* _internal_add_pathname();

public:
    const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part& pathname(int index) const;
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part* add_pathname();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part>& pathname() const;

    // repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part search = 8;
    int search_size() const;

private:
    int _internal_search_size() const;

public:
    void clear_search();
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part* mutable_search(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part>* mutable_search();

private:
    const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part& _internal_search(int index) const;
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part* _internal_add_search();

public:
    const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part& search(int index) const;
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part* add_search();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part>& search() const;

    // repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part hash = 9;
    int hash_size() const;

private:
    int _internal_hash_size() const;

public:
    void clear_hash();
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part* mutable_hash(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part>* mutable_hash();

private:
    const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part& _internal_hash(int index) const;
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part* _internal_add_hash();

public:
    const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part& hash(int index) const;
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part* add_hash();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part>& hash() const;

    // optional .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Options options = 10;
    bool has_options() const;

private:
    bool _internal_has_options() const;

public:
    void clear_options();
    const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options& options() const;
    PROTOBUF_NODISCARD ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options* release_options();
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options* mutable_options();
    void set_allocated_options(::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options* options);

private:
    const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options& _internal_options() const;
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options* _internal_mutable_options();

public:
    void unsafe_arena_set_allocated_options(::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options* options);
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options* unsafe_arena_release_options();

    // @@protoc_insertion_point(class_scope:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part> legacy_pathname_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part> hostname_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part> protocol_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part> username_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part> password_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part> port_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part> pathname_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part> search_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part> hash_;
        ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options* options_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_service_5fworker_5fdatabase_2eproto;
};
// -------------------------------------------------------------------

class ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request final
    : public ::PROTOBUF_NAMESPACE_ID::
          MessageLite /* @@protoc_insertion_point(class_definition:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.Request) */ {
public:
    inline ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request()
        : ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request(nullptr)
    {
    }
    ~ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request() override;
    explicit PROTOBUF_CONSTEXPR ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request(const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request& from);
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request(ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request&& from) noexcept
        : ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request()
    {
        *this = ::std::move(from);
    }

    inline ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request& operator=(
        const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request& operator=(
        ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request* internal_default_instance()
    {
        return reinterpret_cast<const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request*>(
            &_ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 9;

    friend void swap(
        ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request& a, ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request& from);
    void MergeFrom(const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.Request";
    }

protected:
    explicit ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode Mode;
    static constexpr Mode kSameOriginMode = ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode_kSameOriginMode;
    static constexpr Mode kNoCorsMode = ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode_kNoCorsMode;
    static constexpr Mode kCorsMode = ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode_kCorsMode;
    static constexpr Mode kCorsWithForcedPreflightMode = ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode_kCorsWithForcedPreflightMode;
    static constexpr Mode kNavigateMode = ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode_kNavigateMode;
    static inline bool Mode_IsValid(int value)
    {
        return ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode_IsValid(value);
    }
    static constexpr Mode Mode_MIN = ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode_Mode_MIN;
    static constexpr Mode Mode_MAX = ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode_Mode_MAX;
    static constexpr int Mode_ARRAYSIZE = ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode_Mode_ARRAYSIZE;
    template <typename T> static inline const std::string& Mode_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, Mode>::value || ::std::is_integral<T>::value, "Incorrect type passed to function Mode_Name.");
        return ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode_Name(enum_t_value);
    }
    static inline bool Mode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Mode* value)
    {
        return ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode_Parse(name, value);
    }

    typedef ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination Destination;
    static constexpr Destination kEmptyDestination = ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_kEmptyDestination;
    static constexpr Destination kAudioDestination = ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_kAudioDestination;
    static constexpr Destination kAudioWorkletDestination
        = ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_kAudioWorkletDestination;
    static constexpr Destination kDocumentDestination = ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_kDocumentDestination;
    static constexpr Destination kEmbedDestination = ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_kEmbedDestination;
    static constexpr Destination kFontDestination = ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_kFontDestination;
    static constexpr Destination kFrameDestination = ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_kFrameDestination;
    static constexpr Destination kIframeDestination = ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_kIframeDestination;
    static constexpr Destination kImageDestination = ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_kImageDestination;
    static constexpr Destination kManifestDestination = ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_kManifestDestination;
    static constexpr Destination kObjectDestination = ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_kObjectDestination;
    static constexpr Destination kPaintWorkletDestination
        = ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_kPaintWorkletDestination;
    static constexpr Destination kReportDestination = ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_kReportDestination;
    static constexpr Destination kScriptDestination = ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_kScriptDestination;
    static constexpr Destination kServiceWorkerDestination
        = ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_kServiceWorkerDestination;
    static constexpr Destination kSharedWorkerDestination
        = ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_kSharedWorkerDestination;
    static constexpr Destination kStyleDestination = ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_kStyleDestination;
    static constexpr Destination kTrackDestination = ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_kTrackDestination;
    static constexpr Destination kVideoDestination = ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_kVideoDestination;
    static constexpr Destination kWebBundleDestination = ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_kWebBundleDestination;
    static constexpr Destination kWorkerDestination = ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_kWorkerDestination;
    static constexpr Destination kXsltDestination = ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_kXsltDestination;
    static constexpr Destination kFencedframeDestination
        = ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_kFencedframeDestination;
    static constexpr Destination kWebIdentityDestination
        = ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_kWebIdentityDestination;
    static constexpr Destination kDictionaryDestination = ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_kDictionaryDestination;
    static constexpr Destination kSpeculationRulesDestination
        = ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_kSpeculationRulesDestination;
    static constexpr Destination kJsonDestination = ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_kJsonDestination;
    static constexpr Destination kSharedStorageWorkletDestination
        = ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_kSharedStorageWorkletDestination;
    static inline bool Destination_IsValid(int value)
    {
        return ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_IsValid(value);
    }
    static constexpr Destination Destination_MIN = ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_Destination_MIN;
    static constexpr Destination Destination_MAX = ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_Destination_MAX;
    static constexpr int Destination_ARRAYSIZE = ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_Destination_ARRAYSIZE;
    template <typename T> static inline const std::string& Destination_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, Destination>::value || ::std::is_integral<T>::value, "Incorrect type passed to function Destination_Name.");
        return ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_Name(enum_t_value);
    }
    static inline bool Destination_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Destination* value)
    {
        return ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_Parse(name, value);
    }

    // accessors -------------------------------------------------------

    enum : int {
        kMethodFieldNumber = 1,
        kModeFieldNumber = 2,
        kDestinationFieldNumber = 3,
    };
    // optional string method = 1;
    bool has_method() const;

private:
    bool _internal_has_method() const;

public:
    void clear_method();
    const std::string& method() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_method(ArgT0&& arg0, ArgT... args);
    std::string* mutable_method();
    PROTOBUF_NODISCARD std::string* release_method();
    void set_allocated_method(std::string* method);

private:
    const std::string& _internal_method() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_method(const std::string& value);
    std::string* _internal_mutable_method();

public:
    // optional .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.Request.Mode mode = 2;
    bool has_mode() const;

private:
    bool _internal_has_mode() const;

public:
    void clear_mode();
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode mode() const;
    void set_mode(::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode value);

private:
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode _internal_mode() const;
    void _internal_set_mode(::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode value);

public:
    // optional .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.Request.Destination destination = 3;
    bool has_destination() const;

private:
    bool _internal_has_destination() const;

public:
    void clear_destination();
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination destination() const;
    void set_destination(::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination value);

private:
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination _internal_destination() const;
    void _internal_set_destination(::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination value);

public:
    // @@protoc_insertion_point(class_scope:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.Request)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr method_;
        int mode_;
        int destination_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_service_5fworker_5fdatabase_2eproto;
};
// -------------------------------------------------------------------

class ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus final
    : public ::PROTOBUF_NAMESPACE_ID::
          MessageLite /* @@protoc_insertion_point(class_definition:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.RunningStatus) */ {
public:
    inline ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus()
        : ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus(nullptr)
    {
    }
    ~ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus() override;
    explicit PROTOBUF_CONSTEXPR ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus(
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus(
        const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus& from);
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus(
        ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus&& from) noexcept
        : ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus()
    {
        *this = ::std::move(from);
    }

    inline ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus& operator=(
        const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus& operator=(
        ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus* internal_default_instance()
    {
        return reinterpret_cast<const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus*>(
            &_ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 10;

    friend void swap(ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus& a,
        ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus& from);
    void MergeFrom(const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.RunningStatus";
    }

protected:
    explicit ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_Status Status;
    static constexpr Status kRunning = ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_Status_kRunning;
    static constexpr Status kNotRunning = ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_Status_kNotRunning;
    static inline bool Status_IsValid(int value)
    {
        return ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_Status_IsValid(value);
    }
    static constexpr Status Status_MIN = ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_Status_Status_MIN;
    static constexpr Status Status_MAX = ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_Status_Status_MAX;
    static constexpr int Status_ARRAYSIZE = ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_Status_Status_ARRAYSIZE;
    template <typename T> static inline const std::string& Status_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, Status>::value || ::std::is_integral<T>::value, "Incorrect type passed to function Status_Name.");
        return ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_Status_Name(enum_t_value);
    }
    static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Status* value)
    {
        return ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_Status_Parse(name, value);
    }

    // accessors -------------------------------------------------------

    enum : int {
        kStatusFieldNumber = 1,
    };
    // optional .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.RunningStatus.Status status = 1;
    bool has_status() const;

private:
    bool _internal_has_status() const;

public:
    void clear_status();
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_Status status() const;
    void set_status(::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_Status value);

private:
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_Status _internal_status() const;
    void _internal_set_status(::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_Status value);

public:
    // @@protoc_insertion_point(class_scope:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.RunningStatus)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        int status_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_service_5fworker_5fdatabase_2eproto;
};
// -------------------------------------------------------------------

class ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject final
    : public ::PROTOBUF_NAMESPACE_ID::
          MessageLite /* @@protoc_insertion_point(class_definition:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.ConditionObject) */ {
public:
    inline ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject()
        : ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject(nullptr)
    {
    }
    ~ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject() override;
    explicit PROTOBUF_CONSTEXPR ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject(
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject(
        const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject& from);
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject(
        ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject&& from) noexcept
        : ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject()
    {
        *this = ::std::move(from);
    }

    inline ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject& operator=(
        const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject& operator=(
        ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject* internal_default_instance()
    {
        return reinterpret_cast<const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject*>(
            &_ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 11;

    friend void swap(ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject& a,
        ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject& from);
    void MergeFrom(const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.ConditionObject";
    }

protected:
    explicit ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kConditionsFieldNumber = 1,
    };
    // repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition conditions = 1;
    int conditions_size() const;

private:
    int _internal_conditions_size() const;

public:
    void clear_conditions();
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition* mutable_conditions(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition>* mutable_conditions();

private:
    const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition& _internal_conditions(int index) const;
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition* _internal_add_conditions();

public:
    const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition& conditions(int index) const;
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition* add_conditions();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition>& conditions() const;

    // @@protoc_insertion_point(class_scope:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.ConditionObject)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition> conditions_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_service_5fworker_5fdatabase_2eproto;
};
// -------------------------------------------------------------------

class ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition final
    : public ::PROTOBUF_NAMESPACE_ID::
          MessageLite /* @@protoc_insertion_point(class_definition:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.OrCondition) */ {
public:
    inline ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition()
        : ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition(nullptr)
    {
    }
    ~ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition() override;
    explicit PROTOBUF_CONSTEXPR ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition(const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition& from);
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition(
        ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition&& from) noexcept
        : ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition()
    {
        *this = ::std::move(from);
    }

    inline ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition& operator=(
        const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition& operator=(
        ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition* internal_default_instance()
    {
        return reinterpret_cast<const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition*>(
            &_ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 12;

    friend void swap(
        ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition& a, ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition& from);
    void MergeFrom(const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.OrCondition";
    }

protected:
    explicit ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kObjectsFieldNumber = 1,
    };
    // repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.ConditionObject objects = 1;
    int objects_size() const;

private:
    int _internal_objects_size() const;

public:
    void clear_objects();
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject* mutable_objects(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject>* mutable_objects();

private:
    const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject& _internal_objects(int index) const;
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject* _internal_add_objects();

public:
    const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject& objects(int index) const;
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject* add_objects();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject>& objects() const;

    // @@protoc_insertion_point(class_scope:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.OrCondition)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject> objects_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_service_5fworker_5fdatabase_2eproto;
};
// -------------------------------------------------------------------

class ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition final
    : public ::PROTOBUF_NAMESPACE_ID::
          MessageLite /* @@protoc_insertion_point(class_definition:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.NotCondition) */ {
public:
    inline ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition()
        : ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition(nullptr)
    {
    }
    ~ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition() override;
    explicit PROTOBUF_CONSTEXPR ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition(
        const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition& from);
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition(
        ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition&& from) noexcept
        : ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition()
    {
        *this = ::std::move(from);
    }

    inline ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition& operator=(
        const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition& operator=(
        ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition* internal_default_instance()
    {
        return reinterpret_cast<const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition*>(
            &_ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 13;

    friend void swap(
        ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition& a, ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition& from);
    void MergeFrom(const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.NotCondition";
    }

protected:
    explicit ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kObjectFieldNumber = 1,
    };
    // required .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.ConditionObject object = 1;
    bool has_object() const;

private:
    bool _internal_has_object() const;

public:
    void clear_object();
    const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject& object() const;
    PROTOBUF_NODISCARD ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject* release_object();
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject* mutable_object();
    void set_allocated_object(::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject* object);

private:
    const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject& _internal_object() const;
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject* _internal_mutable_object();

public:
    void unsafe_arena_set_allocated_object(::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject* object);
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject* unsafe_arena_release_object();

    // @@protoc_insertion_point(class_scope:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.NotCondition)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject* object_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_service_5fworker_5fdatabase_2eproto;
};
// -------------------------------------------------------------------

class ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition final
    : public ::PROTOBUF_NAMESPACE_ID::
          MessageLite /* @@protoc_insertion_point(class_definition:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition) */ {
public:
    inline ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition()
        : ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition(nullptr)
    {
    }
    ~ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition() override;
    explicit PROTOBUF_CONSTEXPR ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition(const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition& from);
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition(ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition&& from) noexcept
        : ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition()
    {
        *this = ::std::move(from);
    }

    inline ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition& operator=(const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition& operator=(ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition& default_instance()
    {
        return *internal_default_instance();
    }
    enum ConditionCase {
        kUrlPattern = 1,
        kRequest = 2,
        kRunningStatus = 3,
        kOrCondition = 4,
        kNotCondition = 5,
        CONDITION_NOT_SET = 0,
    };

    static inline const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition* internal_default_instance()
    {
        return reinterpret_cast<const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition*>(
            &_ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 14;

    friend void swap(ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition& a, ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition& from);
    void MergeFrom(const ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition";
    }

protected:
    explicit ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern URLPattern;
    typedef ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request Request;
    typedef ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus RunningStatus;
    typedef ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject ConditionObject;
    typedef ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition OrCondition;
    typedef ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition NotCondition;

    // accessors -------------------------------------------------------

    enum : int {
        kUrlPatternFieldNumber = 1,
        kRequestFieldNumber = 2,
        kRunningStatusFieldNumber = 3,
        kOrConditionFieldNumber = 4,
        kNotConditionFieldNumber = 5,
    };
    // .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern url_pattern = 1;
    bool has_url_pattern() const;

private:
    bool _internal_has_url_pattern() const;

public:
    void clear_url_pattern();
    const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern& url_pattern() const;
    PROTOBUF_NODISCARD ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern* release_url_pattern();
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern* mutable_url_pattern();
    void set_allocated_url_pattern(::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern* url_pattern);

private:
    const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern& _internal_url_pattern() const;
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern* _internal_mutable_url_pattern();

public:
    void unsafe_arena_set_allocated_url_pattern(::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern* url_pattern);
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern* unsafe_arena_release_url_pattern();

    // .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.Request request = 2;
    bool has_request() const;

private:
    bool _internal_has_request() const;

public:
    void clear_request();
    const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request& request() const;
    PROTOBUF_NODISCARD ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request* release_request();
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request* mutable_request();
    void set_allocated_request(::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request* request);

private:
    const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request& _internal_request() const;
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request* _internal_mutable_request();

public:
    void unsafe_arena_set_allocated_request(::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request* request);
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request* unsafe_arena_release_request();

    // .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.RunningStatus running_status = 3;
    bool has_running_status() const;

private:
    bool _internal_has_running_status() const;

public:
    void clear_running_status();
    const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus& running_status() const;
    PROTOBUF_NODISCARD ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus* release_running_status();
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus* mutable_running_status();
    void set_allocated_running_status(::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus* running_status);

private:
    const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus& _internal_running_status() const;
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus* _internal_mutable_running_status();

public:
    void unsafe_arena_set_allocated_running_status(::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus* running_status);
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus* unsafe_arena_release_running_status();

    // .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.OrCondition or_condition = 4;
    bool has_or_condition() const;

private:
    bool _internal_has_or_condition() const;

public:
    void clear_or_condition();
    const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition& or_condition() const;
    PROTOBUF_NODISCARD ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition* release_or_condition();
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition* mutable_or_condition();
    void set_allocated_or_condition(::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition* or_condition);

private:
    const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition& _internal_or_condition() const;
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition* _internal_mutable_or_condition();

public:
    void unsafe_arena_set_allocated_or_condition(::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition* or_condition);
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition* unsafe_arena_release_or_condition();

    // .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.NotCondition not_condition = 5;
    bool has_not_condition() const;

private:
    bool _internal_has_not_condition() const;

public:
    void clear_not_condition();
    const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition& not_condition() const;
    PROTOBUF_NODISCARD ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition* release_not_condition();
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition* mutable_not_condition();
    void set_allocated_not_condition(::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition* not_condition);

private:
    const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition& _internal_not_condition() const;
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition* _internal_mutable_not_condition();

public:
    void unsafe_arena_set_allocated_not_condition(::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition* not_condition);
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition* unsafe_arena_release_not_condition();

    void clear_condition();
    ConditionCase condition_case() const;
    // @@protoc_insertion_point(class_scope:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition)
private:
    class _Internal;
    void set_has_url_pattern();
    void set_has_request();
    void set_has_running_status();
    void set_has_or_condition();
    void set_has_not_condition();

    inline bool has_condition() const;
    inline void clear_has_condition();

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        union ConditionUnion {
            constexpr ConditionUnion()
                : _constinit_ {}
            {
            }
            ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
            ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern* url_pattern_;
            ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request* request_;
            ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus* running_status_;
            ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition* or_condition_;
            ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition* not_condition_;
        } condition_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        uint32_t _oneof_case_[1];
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_service_5fworker_5fdatabase_2eproto;
};
// -------------------------------------------------------------------

class ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource final
    : public ::PROTOBUF_NAMESPACE_ID::
          MessageLite /* @@protoc_insertion_point(class_definition:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.NetworkSource) */ {
public:
    inline ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource()
        : ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource(nullptr)
    {
    }
    ~ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource() override;
    explicit PROTOBUF_CONSTEXPR ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource(const ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource& from);
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource(ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource&& from) noexcept
        : ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource()
    {
        *this = ::std::move(from);
    }

    inline ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource& operator=(
        const ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource& operator=(
        ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource* internal_default_instance()
    {
        return reinterpret_cast<const ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource*>(
            &_ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 15;

    friend void swap(
        ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource& a, ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource& from);
    void MergeFrom(const ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.NetworkSource";
    }

protected:
    explicit ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // @@protoc_insertion_point(class_scope:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.NetworkSource)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_service_5fworker_5fdatabase_2eproto;
};
// -------------------------------------------------------------------

class ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource final
    : public ::PROTOBUF_NAMESPACE_ID::
          MessageLite /* @@protoc_insertion_point(class_definition:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.RaceSource) */ {
public:
    inline ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource()
        : ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource(nullptr)
    {
    }
    ~ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource() override;
    explicit PROTOBUF_CONSTEXPR ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource(const ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource& from);
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource(ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource&& from) noexcept
        : ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource()
    {
        *this = ::std::move(from);
    }

    inline ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource& operator=(
        const ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource& operator=(
        ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource* internal_default_instance()
    {
        return reinterpret_cast<const ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource*>(
            &_ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 16;

    friend void swap(
        ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource& a, ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource& from);
    void MergeFrom(const ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.RaceSource";
    }

protected:
    explicit ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // @@protoc_insertion_point(class_scope:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.RaceSource)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_service_5fworker_5fdatabase_2eproto;
};
// -------------------------------------------------------------------

class ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource final
    : public ::PROTOBUF_NAMESPACE_ID::
          MessageLite /* @@protoc_insertion_point(class_definition:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.FetchEventSource) */ {
public:
    inline ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource()
        : ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource(nullptr)
    {
    }
    ~ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource() override;
    explicit PROTOBUF_CONSTEXPR ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource(
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource(
        const ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource& from);
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource(
        ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource&& from) noexcept
        : ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource()
    {
        *this = ::std::move(from);
    }

    inline ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource& operator=(
        const ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource& operator=(
        ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource* internal_default_instance()
    {
        return reinterpret_cast<const ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource*>(
            &_ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 17;

    friend void swap(ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource& a,
        ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource& from);
    void MergeFrom(const ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.FetchEventSource";
    }

protected:
    explicit ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // @@protoc_insertion_point(class_scope:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.FetchEventSource)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_service_5fworker_5fdatabase_2eproto;
};
// -------------------------------------------------------------------

class ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource final
    : public ::PROTOBUF_NAMESPACE_ID::
          MessageLite /* @@protoc_insertion_point(class_definition:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.CacheSource) */ {
public:
    inline ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource()
        : ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource(nullptr)
    {
    }
    ~ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource() override;
    explicit PROTOBUF_CONSTEXPR ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource(const ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource& from);
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource(ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource&& from) noexcept
        : ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource()
    {
        *this = ::std::move(from);
    }

    inline ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource& operator=(
        const ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource& operator=(
        ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource* internal_default_instance()
    {
        return reinterpret_cast<const ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource*>(
            &_ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 18;

    friend void swap(
        ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource& a, ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource& from);
    void MergeFrom(const ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.CacheSource";
    }

protected:
    explicit ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kCacheNameFieldNumber = 1,
    };
    // optional string cache_name = 1;
    bool has_cache_name() const;

private:
    bool _internal_has_cache_name() const;

public:
    void clear_cache_name();
    const std::string& cache_name() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_cache_name(ArgT0&& arg0, ArgT... args);
    std::string* mutable_cache_name();
    PROTOBUF_NODISCARD std::string* release_cache_name();
    void set_allocated_cache_name(std::string* cache_name);

private:
    const std::string& _internal_cache_name() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_cache_name(const std::string& value);
    std::string* _internal_mutable_cache_name();

public:
    // @@protoc_insertion_point(class_scope:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.CacheSource)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cache_name_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_service_5fworker_5fdatabase_2eproto;
};
// -------------------------------------------------------------------

class ServiceWorkerRegistrationData_RouterRules_RuleV1_Source final
    : public ::PROTOBUF_NAMESPACE_ID::
          MessageLite /* @@protoc_insertion_point(class_definition:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source) */ {
public:
    inline ServiceWorkerRegistrationData_RouterRules_RuleV1_Source()
        : ServiceWorkerRegistrationData_RouterRules_RuleV1_Source(nullptr)
    {
    }
    ~ServiceWorkerRegistrationData_RouterRules_RuleV1_Source() override;
    explicit PROTOBUF_CONSTEXPR ServiceWorkerRegistrationData_RouterRules_RuleV1_Source(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ServiceWorkerRegistrationData_RouterRules_RuleV1_Source(const ServiceWorkerRegistrationData_RouterRules_RuleV1_Source& from);
    ServiceWorkerRegistrationData_RouterRules_RuleV1_Source(ServiceWorkerRegistrationData_RouterRules_RuleV1_Source&& from) noexcept
        : ServiceWorkerRegistrationData_RouterRules_RuleV1_Source()
    {
        *this = ::std::move(from);
    }

    inline ServiceWorkerRegistrationData_RouterRules_RuleV1_Source& operator=(const ServiceWorkerRegistrationData_RouterRules_RuleV1_Source& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ServiceWorkerRegistrationData_RouterRules_RuleV1_Source& operator=(ServiceWorkerRegistrationData_RouterRules_RuleV1_Source&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ServiceWorkerRegistrationData_RouterRules_RuleV1_Source& default_instance()
    {
        return *internal_default_instance();
    }
    enum SourceCase {
        kNetworkSource = 1,
        kRaceSource = 2,
        kFetchEventSource = 3,
        kCacheSource = 4,
        SOURCE_NOT_SET = 0,
    };

    static inline const ServiceWorkerRegistrationData_RouterRules_RuleV1_Source* internal_default_instance()
    {
        return reinterpret_cast<const ServiceWorkerRegistrationData_RouterRules_RuleV1_Source*>(
            &_ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 19;

    friend void swap(ServiceWorkerRegistrationData_RouterRules_RuleV1_Source& a, ServiceWorkerRegistrationData_RouterRules_RuleV1_Source& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ServiceWorkerRegistrationData_RouterRules_RuleV1_Source* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ServiceWorkerRegistrationData_RouterRules_RuleV1_Source* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ServiceWorkerRegistrationData_RouterRules_RuleV1_Source* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ServiceWorkerRegistrationData_RouterRules_RuleV1_Source>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ServiceWorkerRegistrationData_RouterRules_RuleV1_Source& from);
    void MergeFrom(const ServiceWorkerRegistrationData_RouterRules_RuleV1_Source& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ServiceWorkerRegistrationData_RouterRules_RuleV1_Source* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source";
    }

protected:
    explicit ServiceWorkerRegistrationData_RouterRules_RuleV1_Source(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource NetworkSource;
    typedef ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource RaceSource;
    typedef ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource FetchEventSource;
    typedef ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource CacheSource;

    // accessors -------------------------------------------------------

    enum : int {
        kNetworkSourceFieldNumber = 1,
        kRaceSourceFieldNumber = 2,
        kFetchEventSourceFieldNumber = 3,
        kCacheSourceFieldNumber = 4,
    };
    // .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.NetworkSource network_source = 1;
    bool has_network_source() const;

private:
    bool _internal_has_network_source() const;

public:
    void clear_network_source();
    const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource& network_source() const;
    PROTOBUF_NODISCARD ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource* release_network_source();
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource* mutable_network_source();
    void set_allocated_network_source(::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource* network_source);

private:
    const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource& _internal_network_source() const;
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource* _internal_mutable_network_source();

public:
    void unsafe_arena_set_allocated_network_source(::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource* network_source);
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource* unsafe_arena_release_network_source();

    // .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.RaceSource race_source = 2;
    bool has_race_source() const;

private:
    bool _internal_has_race_source() const;

public:
    void clear_race_source();
    const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource& race_source() const;
    PROTOBUF_NODISCARD ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource* release_race_source();
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource* mutable_race_source();
    void set_allocated_race_source(::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource* race_source);

private:
    const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource& _internal_race_source() const;
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource* _internal_mutable_race_source();

public:
    void unsafe_arena_set_allocated_race_source(::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource* race_source);
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource* unsafe_arena_release_race_source();

    // .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.FetchEventSource fetch_event_source = 3;
    bool has_fetch_event_source() const;

private:
    bool _internal_has_fetch_event_source() const;

public:
    void clear_fetch_event_source();
    const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource& fetch_event_source() const;
    PROTOBUF_NODISCARD ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource* release_fetch_event_source();
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource* mutable_fetch_event_source();
    void set_allocated_fetch_event_source(::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource* fetch_event_source);

private:
    const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource& _internal_fetch_event_source() const;
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource* _internal_mutable_fetch_event_source();

public:
    void unsafe_arena_set_allocated_fetch_event_source(::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource* fetch_event_source);
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource* unsafe_arena_release_fetch_event_source();

    // .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.CacheSource cache_source = 4;
    bool has_cache_source() const;

private:
    bool _internal_has_cache_source() const;

public:
    void clear_cache_source();
    const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource& cache_source() const;
    PROTOBUF_NODISCARD ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource* release_cache_source();
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource* mutable_cache_source();
    void set_allocated_cache_source(::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource* cache_source);

private:
    const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource& _internal_cache_source() const;
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource* _internal_mutable_cache_source();

public:
    void unsafe_arena_set_allocated_cache_source(::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource* cache_source);
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource* unsafe_arena_release_cache_source();

    void clear_source();
    SourceCase source_case() const;
    // @@protoc_insertion_point(class_scope:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source)
private:
    class _Internal;
    void set_has_network_source();
    void set_has_race_source();
    void set_has_fetch_event_source();
    void set_has_cache_source();

    inline bool has_source() const;
    inline void clear_has_source();

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        union SourceUnion {
            constexpr SourceUnion()
                : _constinit_ {}
            {
            }
            ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
            ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource* network_source_;
            ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource* race_source_;
            ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource* fetch_event_source_;
            ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource* cache_source_;
        } source_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        uint32_t _oneof_case_[1];
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_service_5fworker_5fdatabase_2eproto;
};
// -------------------------------------------------------------------

class ServiceWorkerRegistrationData_RouterRules_RuleV1 final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1) */ {
public:
    inline ServiceWorkerRegistrationData_RouterRules_RuleV1()
        : ServiceWorkerRegistrationData_RouterRules_RuleV1(nullptr)
    {
    }
    ~ServiceWorkerRegistrationData_RouterRules_RuleV1() override;
    explicit PROTOBUF_CONSTEXPR ServiceWorkerRegistrationData_RouterRules_RuleV1(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ServiceWorkerRegistrationData_RouterRules_RuleV1(const ServiceWorkerRegistrationData_RouterRules_RuleV1& from);
    ServiceWorkerRegistrationData_RouterRules_RuleV1(ServiceWorkerRegistrationData_RouterRules_RuleV1&& from) noexcept
        : ServiceWorkerRegistrationData_RouterRules_RuleV1()
    {
        *this = ::std::move(from);
    }

    inline ServiceWorkerRegistrationData_RouterRules_RuleV1& operator=(const ServiceWorkerRegistrationData_RouterRules_RuleV1& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ServiceWorkerRegistrationData_RouterRules_RuleV1& operator=(ServiceWorkerRegistrationData_RouterRules_RuleV1&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ServiceWorkerRegistrationData_RouterRules_RuleV1& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ServiceWorkerRegistrationData_RouterRules_RuleV1* internal_default_instance()
    {
        return reinterpret_cast<const ServiceWorkerRegistrationData_RouterRules_RuleV1*>(&_ServiceWorkerRegistrationData_RouterRules_RuleV1_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 20;

    friend void swap(ServiceWorkerRegistrationData_RouterRules_RuleV1& a, ServiceWorkerRegistrationData_RouterRules_RuleV1& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ServiceWorkerRegistrationData_RouterRules_RuleV1* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ServiceWorkerRegistrationData_RouterRules_RuleV1* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ServiceWorkerRegistrationData_RouterRules_RuleV1* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ServiceWorkerRegistrationData_RouterRules_RuleV1>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ServiceWorkerRegistrationData_RouterRules_RuleV1& from);
    void MergeFrom(const ServiceWorkerRegistrationData_RouterRules_RuleV1& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ServiceWorkerRegistrationData_RouterRules_RuleV1* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "storage.ServiceWorkerRegistrationData.RouterRules.RuleV1";
    }

protected:
    explicit ServiceWorkerRegistrationData_RouterRules_RuleV1(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition Condition;
    typedef ServiceWorkerRegistrationData_RouterRules_RuleV1_Source Source;

    // accessors -------------------------------------------------------

    enum : int {
        kConditionFieldNumber = 1,
        kSourceFieldNumber = 2,
    };
    // repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition condition = 1;
    int condition_size() const;

private:
    int _internal_condition_size() const;

public:
    void clear_condition();
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition* mutable_condition(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition>* mutable_condition();

private:
    const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition& _internal_condition(int index) const;
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition* _internal_add_condition();

public:
    const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition& condition(int index) const;
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition* add_condition();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition>& condition() const;

    // repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source source = 2;
    int source_size() const;

private:
    int _internal_source_size() const;

public:
    void clear_source();
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source* mutable_source(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source>* mutable_source();

private:
    const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source& _internal_source(int index) const;
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source* _internal_add_source();

public:
    const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source& source(int index) const;
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source* add_source();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source>& source() const;

    // @@protoc_insertion_point(class_scope:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition> condition_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source> source_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_service_5fworker_5fdatabase_2eproto;
};
// -------------------------------------------------------------------

class ServiceWorkerRegistrationData_RouterRules final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:storage.ServiceWorkerRegistrationData.RouterRules) */ {
public:
    inline ServiceWorkerRegistrationData_RouterRules()
        : ServiceWorkerRegistrationData_RouterRules(nullptr)
    {
    }
    ~ServiceWorkerRegistrationData_RouterRules() override;
    explicit PROTOBUF_CONSTEXPR ServiceWorkerRegistrationData_RouterRules(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ServiceWorkerRegistrationData_RouterRules(const ServiceWorkerRegistrationData_RouterRules& from);
    ServiceWorkerRegistrationData_RouterRules(ServiceWorkerRegistrationData_RouterRules&& from) noexcept
        : ServiceWorkerRegistrationData_RouterRules()
    {
        *this = ::std::move(from);
    }

    inline ServiceWorkerRegistrationData_RouterRules& operator=(const ServiceWorkerRegistrationData_RouterRules& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ServiceWorkerRegistrationData_RouterRules& operator=(ServiceWorkerRegistrationData_RouterRules&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ServiceWorkerRegistrationData_RouterRules& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ServiceWorkerRegistrationData_RouterRules* internal_default_instance()
    {
        return reinterpret_cast<const ServiceWorkerRegistrationData_RouterRules*>(&_ServiceWorkerRegistrationData_RouterRules_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 21;

    friend void swap(ServiceWorkerRegistrationData_RouterRules& a, ServiceWorkerRegistrationData_RouterRules& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ServiceWorkerRegistrationData_RouterRules* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ServiceWorkerRegistrationData_RouterRules* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ServiceWorkerRegistrationData_RouterRules* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ServiceWorkerRegistrationData_RouterRules>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ServiceWorkerRegistrationData_RouterRules& from);
    void MergeFrom(const ServiceWorkerRegistrationData_RouterRules& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ServiceWorkerRegistrationData_RouterRules* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "storage.ServiceWorkerRegistrationData.RouterRules";
    }

protected:
    explicit ServiceWorkerRegistrationData_RouterRules(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef ServiceWorkerRegistrationData_RouterRules_RuleV1 RuleV1;

    // accessors -------------------------------------------------------

    enum : int {
        kV1FieldNumber = 2,
        kVersionFieldNumber = 1,
    };
    // repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1 v1 = 2;
    int v1_size() const;

private:
    int _internal_v1_size() const;

public:
    void clear_v1();
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1* mutable_v1(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1>* mutable_v1();

private:
    const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1& _internal_v1(int index) const;
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1* _internal_add_v1();

public:
    const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1& v1(int index) const;
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1* add_v1();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1>& v1() const;

    // required int32 version = 1;
    bool has_version() const;

private:
    bool _internal_has_version() const;

public:
    void clear_version();
    int32_t version() const;
    void set_version(int32_t value);

private:
    int32_t _internal_version() const;
    void _internal_set_version(int32_t value);

public:
    // @@protoc_insertion_point(class_scope:storage.ServiceWorkerRegistrationData.RouterRules)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1> v1_;
        int32_t version_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_service_5fworker_5fdatabase_2eproto;
};
// -------------------------------------------------------------------

class ServiceWorkerRegistrationData final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:storage.ServiceWorkerRegistrationData) */ {
public:
    inline ServiceWorkerRegistrationData()
        : ServiceWorkerRegistrationData(nullptr)
    {
    }
    ~ServiceWorkerRegistrationData() override;
    explicit PROTOBUF_CONSTEXPR ServiceWorkerRegistrationData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ServiceWorkerRegistrationData(const ServiceWorkerRegistrationData& from);
    ServiceWorkerRegistrationData(ServiceWorkerRegistrationData&& from) noexcept
        : ServiceWorkerRegistrationData()
    {
        *this = ::std::move(from);
    }

    inline ServiceWorkerRegistrationData& operator=(const ServiceWorkerRegistrationData& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ServiceWorkerRegistrationData& operator=(ServiceWorkerRegistrationData&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ServiceWorkerRegistrationData& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ServiceWorkerRegistrationData* internal_default_instance()
    {
        return reinterpret_cast<const ServiceWorkerRegistrationData*>(&_ServiceWorkerRegistrationData_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 22;

    friend void swap(ServiceWorkerRegistrationData& a, ServiceWorkerRegistrationData& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ServiceWorkerRegistrationData* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ServiceWorkerRegistrationData* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ServiceWorkerRegistrationData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ServiceWorkerRegistrationData>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ServiceWorkerRegistrationData& from);
    void MergeFrom(const ServiceWorkerRegistrationData& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ServiceWorkerRegistrationData* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "storage.ServiceWorkerRegistrationData";
    }

protected:
    explicit ServiceWorkerRegistrationData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef ServiceWorkerRegistrationData_PolicyContainerPolicies PolicyContainerPolicies;
    typedef ServiceWorkerRegistrationData_RouterRules RouterRules;

    typedef ServiceWorkerRegistrationData_ServiceWorkerScriptType ServiceWorkerScriptType;
    static constexpr ServiceWorkerScriptType CLASSIC = ServiceWorkerRegistrationData_ServiceWorkerScriptType_CLASSIC;
    static constexpr ServiceWorkerScriptType MODULE = ServiceWorkerRegistrationData_ServiceWorkerScriptType_MODULE;
    static inline bool ServiceWorkerScriptType_IsValid(int value)
    {
        return ServiceWorkerRegistrationData_ServiceWorkerScriptType_IsValid(value);
    }
    static constexpr ServiceWorkerScriptType ServiceWorkerScriptType_MIN = ServiceWorkerRegistrationData_ServiceWorkerScriptType_ServiceWorkerScriptType_MIN;
    static constexpr ServiceWorkerScriptType ServiceWorkerScriptType_MAX = ServiceWorkerRegistrationData_ServiceWorkerScriptType_ServiceWorkerScriptType_MAX;
    static constexpr int ServiceWorkerScriptType_ARRAYSIZE = ServiceWorkerRegistrationData_ServiceWorkerScriptType_ServiceWorkerScriptType_ARRAYSIZE;
    template <typename T> static inline const std::string& ServiceWorkerScriptType_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, ServiceWorkerScriptType>::value || ::std::is_integral<T>::value,
            "Incorrect type passed to function ServiceWorkerScriptType_Name.");
        return ServiceWorkerRegistrationData_ServiceWorkerScriptType_Name(enum_t_value);
    }
    static inline bool ServiceWorkerScriptType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ServiceWorkerScriptType* value)
    {
        return ServiceWorkerRegistrationData_ServiceWorkerScriptType_Parse(name, value);
    }

    typedef ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType ServiceWorkerUpdateViaCacheType;
    static constexpr ServiceWorkerUpdateViaCacheType IMPORTS = ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType_IMPORTS;
    static constexpr ServiceWorkerUpdateViaCacheType ALL = ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType_ALL;
    static constexpr ServiceWorkerUpdateViaCacheType NONE = ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType_NONE;
    static inline bool ServiceWorkerUpdateViaCacheType_IsValid(int value)
    {
        return ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType_IsValid(value);
    }
    static constexpr ServiceWorkerUpdateViaCacheType ServiceWorkerUpdateViaCacheType_MIN
        = ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType_ServiceWorkerUpdateViaCacheType_MIN;
    static constexpr ServiceWorkerUpdateViaCacheType ServiceWorkerUpdateViaCacheType_MAX
        = ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType_ServiceWorkerUpdateViaCacheType_MAX;
    static constexpr int ServiceWorkerUpdateViaCacheType_ARRAYSIZE
        = ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType_ServiceWorkerUpdateViaCacheType_ARRAYSIZE;
    template <typename T> static inline const std::string& ServiceWorkerUpdateViaCacheType_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, ServiceWorkerUpdateViaCacheType>::value || ::std::is_integral<T>::value,
            "Incorrect type passed to function ServiceWorkerUpdateViaCacheType_Name.");
        return ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType_Name(enum_t_value);
    }
    static inline bool ServiceWorkerUpdateViaCacheType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ServiceWorkerUpdateViaCacheType* value)
    {
        return ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType_Parse(name, value);
    }

    typedef ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue CrossOriginEmbedderPolicyValue;
    static constexpr CrossOriginEmbedderPolicyValue NONE_OR_NOT_EXIST = ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue_NONE_OR_NOT_EXIST;
    static constexpr CrossOriginEmbedderPolicyValue REQUIRE_CORP = ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue_REQUIRE_CORP;
    static constexpr CrossOriginEmbedderPolicyValue CREDENTIALLESS = ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue_CREDENTIALLESS;
    static inline bool CrossOriginEmbedderPolicyValue_IsValid(int value)
    {
        return ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue_IsValid(value);
    }
    static constexpr CrossOriginEmbedderPolicyValue CrossOriginEmbedderPolicyValue_MIN
        = ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue_CrossOriginEmbedderPolicyValue_MIN;
    static constexpr CrossOriginEmbedderPolicyValue CrossOriginEmbedderPolicyValue_MAX
        = ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue_CrossOriginEmbedderPolicyValue_MAX;
    static constexpr int CrossOriginEmbedderPolicyValue_ARRAYSIZE
        = ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue_CrossOriginEmbedderPolicyValue_ARRAYSIZE;
    template <typename T> static inline const std::string& CrossOriginEmbedderPolicyValue_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, CrossOriginEmbedderPolicyValue>::value || ::std::is_integral<T>::value,
            "Incorrect type passed to function CrossOriginEmbedderPolicyValue_Name.");
        return ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue_Name(enum_t_value);
    }
    static inline bool CrossOriginEmbedderPolicyValue_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CrossOriginEmbedderPolicyValue* value)
    {
        return ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue_Parse(name, value);
    }

    typedef ServiceWorkerRegistrationData_AncestorFrameType AncestorFrameType;
    static constexpr AncestorFrameType NORMAL_FRAME = ServiceWorkerRegistrationData_AncestorFrameType_NORMAL_FRAME;
    static constexpr AncestorFrameType FENCED_FRAME = ServiceWorkerRegistrationData_AncestorFrameType_FENCED_FRAME;
    static inline bool AncestorFrameType_IsValid(int value)
    {
        return ServiceWorkerRegistrationData_AncestorFrameType_IsValid(value);
    }
    static constexpr AncestorFrameType AncestorFrameType_MIN = ServiceWorkerRegistrationData_AncestorFrameType_AncestorFrameType_MIN;
    static constexpr AncestorFrameType AncestorFrameType_MAX = ServiceWorkerRegistrationData_AncestorFrameType_AncestorFrameType_MAX;
    static constexpr int AncestorFrameType_ARRAYSIZE = ServiceWorkerRegistrationData_AncestorFrameType_AncestorFrameType_ARRAYSIZE;
    template <typename T> static inline const std::string& AncestorFrameType_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, AncestorFrameType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function AncestorFrameType_Name.");
        return ServiceWorkerRegistrationData_AncestorFrameType_Name(enum_t_value);
    }
    static inline bool AncestorFrameType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AncestorFrameType* value)
    {
        return ServiceWorkerRegistrationData_AncestorFrameType_Parse(name, value);
    }

    typedef ServiceWorkerRegistrationData_FetchHandlerSkippableType FetchHandlerSkippableType;
    static constexpr FetchHandlerSkippableType NOT_SKIPPABLE = ServiceWorkerRegistrationData_FetchHandlerSkippableType_NOT_SKIPPABLE;
    static constexpr FetchHandlerSkippableType SKIPPABLE_EMPTY_FETCH_HANDLER
        = ServiceWorkerRegistrationData_FetchHandlerSkippableType_SKIPPABLE_EMPTY_FETCH_HANDLER;
    static inline bool FetchHandlerSkippableType_IsValid(int value)
    {
        return ServiceWorkerRegistrationData_FetchHandlerSkippableType_IsValid(value);
    }
    static constexpr FetchHandlerSkippableType FetchHandlerSkippableType_MIN
        = ServiceWorkerRegistrationData_FetchHandlerSkippableType_FetchHandlerSkippableType_MIN;
    static constexpr FetchHandlerSkippableType FetchHandlerSkippableType_MAX
        = ServiceWorkerRegistrationData_FetchHandlerSkippableType_FetchHandlerSkippableType_MAX;
    static constexpr int FetchHandlerSkippableType_ARRAYSIZE = ServiceWorkerRegistrationData_FetchHandlerSkippableType_FetchHandlerSkippableType_ARRAYSIZE;
    template <typename T> static inline const std::string& FetchHandlerSkippableType_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, FetchHandlerSkippableType>::value || ::std::is_integral<T>::value,
            "Incorrect type passed to function FetchHandlerSkippableType_Name.");
        return ServiceWorkerRegistrationData_FetchHandlerSkippableType_Name(enum_t_value);
    }
    static inline bool FetchHandlerSkippableType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FetchHandlerSkippableType* value)
    {
        return ServiceWorkerRegistrationData_FetchHandlerSkippableType_Parse(name, value);
    }

    typedef ServiceWorkerRegistrationData_ReferrerPolicyValue ReferrerPolicyValue;
    static constexpr ReferrerPolicyValue ALWAYS = ServiceWorkerRegistrationData_ReferrerPolicyValue_ALWAYS;
    static constexpr ReferrerPolicyValue DEFAULT = ServiceWorkerRegistrationData_ReferrerPolicyValue_DEFAULT;
    static constexpr ReferrerPolicyValue NO_REFERRER_WHEN_DOWNGRADE = ServiceWorkerRegistrationData_ReferrerPolicyValue_NO_REFERRER_WHEN_DOWNGRADE;
    static constexpr ReferrerPolicyValue NEVER = ServiceWorkerRegistrationData_ReferrerPolicyValue_NEVER;
    static constexpr ReferrerPolicyValue ORIGIN = ServiceWorkerRegistrationData_ReferrerPolicyValue_ORIGIN;
    static constexpr ReferrerPolicyValue ORIGIN_WHEN_CROSS_ORIGIN = ServiceWorkerRegistrationData_ReferrerPolicyValue_ORIGIN_WHEN_CROSS_ORIGIN;
    static constexpr ReferrerPolicyValue STRICT_ORIGIN_WHEN_CROSS_ORIGIN = ServiceWorkerRegistrationData_ReferrerPolicyValue_STRICT_ORIGIN_WHEN_CROSS_ORIGIN;
    static constexpr ReferrerPolicyValue SAME_ORIGIN = ServiceWorkerRegistrationData_ReferrerPolicyValue_SAME_ORIGIN;
    static constexpr ReferrerPolicyValue STRICT_ORIGIN = ServiceWorkerRegistrationData_ReferrerPolicyValue_STRICT_ORIGIN;
    static inline bool ReferrerPolicyValue_IsValid(int value)
    {
        return ServiceWorkerRegistrationData_ReferrerPolicyValue_IsValid(value);
    }
    static constexpr ReferrerPolicyValue ReferrerPolicyValue_MIN = ServiceWorkerRegistrationData_ReferrerPolicyValue_ReferrerPolicyValue_MIN;
    static constexpr ReferrerPolicyValue ReferrerPolicyValue_MAX = ServiceWorkerRegistrationData_ReferrerPolicyValue_ReferrerPolicyValue_MAX;
    static constexpr int ReferrerPolicyValue_ARRAYSIZE = ServiceWorkerRegistrationData_ReferrerPolicyValue_ReferrerPolicyValue_ARRAYSIZE;
    template <typename T> static inline const std::string& ReferrerPolicyValue_Name(T enum_t_value)
    {
        static_assert(
            ::std::is_same<T, ReferrerPolicyValue>::value || ::std::is_integral<T>::value, "Incorrect type passed to function ReferrerPolicyValue_Name.");
        return ServiceWorkerRegistrationData_ReferrerPolicyValue_Name(enum_t_value);
    }
    static inline bool ReferrerPolicyValue_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ReferrerPolicyValue* value)
    {
        return ServiceWorkerRegistrationData_ReferrerPolicyValue_Parse(name, value);
    }

    typedef ServiceWorkerRegistrationData_IPAddressSpace IPAddressSpace;
    static constexpr IPAddressSpace UNKNOWN = ServiceWorkerRegistrationData_IPAddressSpace_UNKNOWN;
    static constexpr IPAddressSpace LOCAL = ServiceWorkerRegistrationData_IPAddressSpace_LOCAL;
    static constexpr IPAddressSpace PRIVATE = ServiceWorkerRegistrationData_IPAddressSpace_PRIVATE;
    static constexpr IPAddressSpace PUBLIC = ServiceWorkerRegistrationData_IPAddressSpace_PUBLIC;
    static inline bool IPAddressSpace_IsValid(int value)
    {
        return ServiceWorkerRegistrationData_IPAddressSpace_IsValid(value);
    }
    static constexpr IPAddressSpace IPAddressSpace_MIN = ServiceWorkerRegistrationData_IPAddressSpace_IPAddressSpace_MIN;
    static constexpr IPAddressSpace IPAddressSpace_MAX = ServiceWorkerRegistrationData_IPAddressSpace_IPAddressSpace_MAX;
    static constexpr int IPAddressSpace_ARRAYSIZE = ServiceWorkerRegistrationData_IPAddressSpace_IPAddressSpace_ARRAYSIZE;
    template <typename T> static inline const std::string& IPAddressSpace_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, IPAddressSpace>::value || ::std::is_integral<T>::value, "Incorrect type passed to function IPAddressSpace_Name.");
        return ServiceWorkerRegistrationData_IPAddressSpace_Name(enum_t_value);
    }
    static inline bool IPAddressSpace_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, IPAddressSpace* value)
    {
        return ServiceWorkerRegistrationData_IPAddressSpace_Parse(name, value);
    }

    // accessors -------------------------------------------------------

    enum : int {
        kUsedFeaturesFieldNumber = 13,
        kScopeUrlFieldNumber = 2,
        kScriptUrlFieldNumber = 3,
        kCrossOriginEmbedderPolicyReportingEndpointFieldNumber = 18,
        kCrossOriginEmbedderPolicyReportOnlyReportingEndpointFieldNumber = 20,
        kOriginTrialTokensFieldNumber = 11,
        kNavigationPreloadStateFieldNumber = 12,
        kPolicyContainerPoliciesFieldNumber = 23,
        kRouterRulesFieldNumber = 24,
        kRegistrationIdFieldNumber = 1,
        kVersionIdFieldNumber = 4,
        kLastUpdateCheckTimeFieldNumber = 7,
        kResourcesTotalSizeBytesFieldNumber = 8,
        kUpdateViaCacheFieldNumber = 14,
        kScriptTypeFieldNumber = 15,
        kIsActiveFieldNumber = 5,
        kHasFetchHandlerFieldNumber = 6,
        kHasHidEventHandlersFieldNumber = 25,
        kHasUsbEventHandlersFieldNumber = 26,
        kCrossOriginEmbedderPolicyValueFieldNumber = 17,
        kScriptResponseTimeFieldNumber = 16,
        kCrossOriginEmbedderPolicyReportOnlyValueFieldNumber = 19,
        kAncestorFrameTypeFieldNumber = 21,
        kFetchHandlerSkippableTypeFieldNumber = 22,
    };
    // repeated uint32 used_features = 13;
    int used_features_size() const;

private:
    int _internal_used_features_size() const;

public:
    void clear_used_features();

private:
    uint32_t _internal_used_features(int index) const;
    const ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t>& _internal_used_features() const;
    void _internal_add_used_features(uint32_t value);
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t>* _internal_mutable_used_features();

public:
    uint32_t used_features(int index) const;
    void set_used_features(int index, uint32_t value);
    void add_used_features(uint32_t value);
    const ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t>& used_features() const;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t>* mutable_used_features();

    // required string scope_url = 2;
    bool has_scope_url() const;

private:
    bool _internal_has_scope_url() const;

public:
    void clear_scope_url();
    const std::string& scope_url() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_scope_url(ArgT0&& arg0, ArgT... args);
    std::string* mutable_scope_url();
    PROTOBUF_NODISCARD std::string* release_scope_url();
    void set_allocated_scope_url(std::string* scope_url);

private:
    const std::string& _internal_scope_url() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_scope_url(const std::string& value);
    std::string* _internal_mutable_scope_url();

public:
    // required string script_url = 3;
    bool has_script_url() const;

private:
    bool _internal_has_script_url() const;

public:
    void clear_script_url();
    const std::string& script_url() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_script_url(ArgT0&& arg0, ArgT... args);
    std::string* mutable_script_url();
    PROTOBUF_NODISCARD std::string* release_script_url();
    void set_allocated_script_url(std::string* script_url);

private:
    const std::string& _internal_script_url() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_script_url(const std::string& value);
    std::string* _internal_mutable_script_url();

public:
    // optional string cross_origin_embedder_policy_reporting_endpoint = 18;
    bool has_cross_origin_embedder_policy_reporting_endpoint() const;

private:
    bool _internal_has_cross_origin_embedder_policy_reporting_endpoint() const;

public:
    void clear_cross_origin_embedder_policy_reporting_endpoint();
    const std::string& cross_origin_embedder_policy_reporting_endpoint() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_cross_origin_embedder_policy_reporting_endpoint(ArgT0&& arg0, ArgT... args);
    std::string* mutable_cross_origin_embedder_policy_reporting_endpoint();
    PROTOBUF_NODISCARD std::string* release_cross_origin_embedder_policy_reporting_endpoint();
    void set_allocated_cross_origin_embedder_policy_reporting_endpoint(std::string* cross_origin_embedder_policy_reporting_endpoint);

private:
    const std::string& _internal_cross_origin_embedder_policy_reporting_endpoint() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_cross_origin_embedder_policy_reporting_endpoint(const std::string& value);
    std::string* _internal_mutable_cross_origin_embedder_policy_reporting_endpoint();

public:
    // optional string cross_origin_embedder_policy_report_only_reporting_endpoint = 20;
    bool has_cross_origin_embedder_policy_report_only_reporting_endpoint() const;

private:
    bool _internal_has_cross_origin_embedder_policy_report_only_reporting_endpoint() const;

public:
    void clear_cross_origin_embedder_policy_report_only_reporting_endpoint();
    const std::string& cross_origin_embedder_policy_report_only_reporting_endpoint() const;
    template <typename ArgT0 = const std::string&, typename... ArgT>
    void set_cross_origin_embedder_policy_report_only_reporting_endpoint(ArgT0&& arg0, ArgT... args);
    std::string* mutable_cross_origin_embedder_policy_report_only_reporting_endpoint();
    PROTOBUF_NODISCARD std::string* release_cross_origin_embedder_policy_report_only_reporting_endpoint();
    void set_allocated_cross_origin_embedder_policy_report_only_reporting_endpoint(std::string* cross_origin_embedder_policy_report_only_reporting_endpoint);

private:
    const std::string& _internal_cross_origin_embedder_policy_report_only_reporting_endpoint() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_cross_origin_embedder_policy_report_only_reporting_endpoint(const std::string& value);
    std::string* _internal_mutable_cross_origin_embedder_policy_report_only_reporting_endpoint();

public:
    // optional .storage.ServiceWorkerOriginTrialInfo origin_trial_tokens = 11;
    bool has_origin_trial_tokens() const;

private:
    bool _internal_has_origin_trial_tokens() const;

public:
    void clear_origin_trial_tokens();
    const ::storage::ServiceWorkerOriginTrialInfo& origin_trial_tokens() const;
    PROTOBUF_NODISCARD ::storage::ServiceWorkerOriginTrialInfo* release_origin_trial_tokens();
    ::storage::ServiceWorkerOriginTrialInfo* mutable_origin_trial_tokens();
    void set_allocated_origin_trial_tokens(::storage::ServiceWorkerOriginTrialInfo* origin_trial_tokens);

private:
    const ::storage::ServiceWorkerOriginTrialInfo& _internal_origin_trial_tokens() const;
    ::storage::ServiceWorkerOriginTrialInfo* _internal_mutable_origin_trial_tokens();

public:
    void unsafe_arena_set_allocated_origin_trial_tokens(::storage::ServiceWorkerOriginTrialInfo* origin_trial_tokens);
    ::storage::ServiceWorkerOriginTrialInfo* unsafe_arena_release_origin_trial_tokens();

    // optional .storage.ServiceWorkerNavigationPreloadState navigation_preload_state = 12;
    bool has_navigation_preload_state() const;

private:
    bool _internal_has_navigation_preload_state() const;

public:
    void clear_navigation_preload_state();
    const ::storage::ServiceWorkerNavigationPreloadState& navigation_preload_state() const;
    PROTOBUF_NODISCARD ::storage::ServiceWorkerNavigationPreloadState* release_navigation_preload_state();
    ::storage::ServiceWorkerNavigationPreloadState* mutable_navigation_preload_state();
    void set_allocated_navigation_preload_state(::storage::ServiceWorkerNavigationPreloadState* navigation_preload_state);

private:
    const ::storage::ServiceWorkerNavigationPreloadState& _internal_navigation_preload_state() const;
    ::storage::ServiceWorkerNavigationPreloadState* _internal_mutable_navigation_preload_state();

public:
    void unsafe_arena_set_allocated_navigation_preload_state(::storage::ServiceWorkerNavigationPreloadState* navigation_preload_state);
    ::storage::ServiceWorkerNavigationPreloadState* unsafe_arena_release_navigation_preload_state();

    // optional .storage.ServiceWorkerRegistrationData.PolicyContainerPolicies policy_container_policies = 23;
    bool has_policy_container_policies() const;

private:
    bool _internal_has_policy_container_policies() const;

public:
    void clear_policy_container_policies();
    const ::storage::ServiceWorkerRegistrationData_PolicyContainerPolicies& policy_container_policies() const;
    PROTOBUF_NODISCARD ::storage::ServiceWorkerRegistrationData_PolicyContainerPolicies* release_policy_container_policies();
    ::storage::ServiceWorkerRegistrationData_PolicyContainerPolicies* mutable_policy_container_policies();
    void set_allocated_policy_container_policies(::storage::ServiceWorkerRegistrationData_PolicyContainerPolicies* policy_container_policies);

private:
    const ::storage::ServiceWorkerRegistrationData_PolicyContainerPolicies& _internal_policy_container_policies() const;
    ::storage::ServiceWorkerRegistrationData_PolicyContainerPolicies* _internal_mutable_policy_container_policies();

public:
    void unsafe_arena_set_allocated_policy_container_policies(::storage::ServiceWorkerRegistrationData_PolicyContainerPolicies* policy_container_policies);
    ::storage::ServiceWorkerRegistrationData_PolicyContainerPolicies* unsafe_arena_release_policy_container_policies();

    // optional .storage.ServiceWorkerRegistrationData.RouterRules router_rules = 24;
    bool has_router_rules() const;

private:
    bool _internal_has_router_rules() const;

public:
    void clear_router_rules();
    const ::storage::ServiceWorkerRegistrationData_RouterRules& router_rules() const;
    PROTOBUF_NODISCARD ::storage::ServiceWorkerRegistrationData_RouterRules* release_router_rules();
    ::storage::ServiceWorkerRegistrationData_RouterRules* mutable_router_rules();
    void set_allocated_router_rules(::storage::ServiceWorkerRegistrationData_RouterRules* router_rules);

private:
    const ::storage::ServiceWorkerRegistrationData_RouterRules& _internal_router_rules() const;
    ::storage::ServiceWorkerRegistrationData_RouterRules* _internal_mutable_router_rules();

public:
    void unsafe_arena_set_allocated_router_rules(::storage::ServiceWorkerRegistrationData_RouterRules* router_rules);
    ::storage::ServiceWorkerRegistrationData_RouterRules* unsafe_arena_release_router_rules();

    // required int64 registration_id = 1;
    bool has_registration_id() const;

private:
    bool _internal_has_registration_id() const;

public:
    void clear_registration_id();
    int64_t registration_id() const;
    void set_registration_id(int64_t value);

private:
    int64_t _internal_registration_id() const;
    void _internal_set_registration_id(int64_t value);

public:
    // required int64 version_id = 4;
    bool has_version_id() const;

private:
    bool _internal_has_version_id() const;

public:
    void clear_version_id();
    int64_t version_id() const;
    void set_version_id(int64_t value);

private:
    int64_t _internal_version_id() const;
    void _internal_set_version_id(int64_t value);

public:
    // required int64 last_update_check_time = 7;
    bool has_last_update_check_time() const;

private:
    bool _internal_has_last_update_check_time() const;

public:
    void clear_last_update_check_time();
    int64_t last_update_check_time() const;
    void set_last_update_check_time(int64_t value);

private:
    int64_t _internal_last_update_check_time() const;
    void _internal_set_last_update_check_time(int64_t value);

public:
    // optional uint64 resources_total_size_bytes = 8;
    bool has_resources_total_size_bytes() const;

private:
    bool _internal_has_resources_total_size_bytes() const;

public:
    void clear_resources_total_size_bytes();
    uint64_t resources_total_size_bytes() const;
    void set_resources_total_size_bytes(uint64_t value);

private:
    uint64_t _internal_resources_total_size_bytes() const;
    void _internal_set_resources_total_size_bytes(uint64_t value);

public:
    // optional .storage.ServiceWorkerRegistrationData.ServiceWorkerUpdateViaCacheType update_via_cache = 14 [default = IMPORTS];
    bool has_update_via_cache() const;

private:
    bool _internal_has_update_via_cache() const;

public:
    void clear_update_via_cache();
    ::storage::ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType update_via_cache() const;
    void set_update_via_cache(::storage::ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType value);

private:
    ::storage::ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType _internal_update_via_cache() const;
    void _internal_set_update_via_cache(::storage::ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType value);

public:
    // optional .storage.ServiceWorkerRegistrationData.ServiceWorkerScriptType script_type = 15 [default = CLASSIC];
    bool has_script_type() const;

private:
    bool _internal_has_script_type() const;

public:
    void clear_script_type();
    ::storage::ServiceWorkerRegistrationData_ServiceWorkerScriptType script_type() const;
    void set_script_type(::storage::ServiceWorkerRegistrationData_ServiceWorkerScriptType value);

private:
    ::storage::ServiceWorkerRegistrationData_ServiceWorkerScriptType _internal_script_type() const;
    void _internal_set_script_type(::storage::ServiceWorkerRegistrationData_ServiceWorkerScriptType value);

public:
    // required bool is_active = 5;
    bool has_is_active() const;

private:
    bool _internal_has_is_active() const;

public:
    void clear_is_active();
    bool is_active() const;
    void set_is_active(bool value);

private:
    bool _internal_is_active() const;
    void _internal_set_is_active(bool value);

public:
    // required bool has_fetch_handler = 6;
    bool has_has_fetch_handler() const;

private:
    bool _internal_has_has_fetch_handler() const;

public:
    void clear_has_fetch_handler();
    bool has_fetch_handler() const;
    void set_has_fetch_handler(bool value);

private:
    bool _internal_has_fetch_handler() const;
    void _internal_set_has_fetch_handler(bool value);

public:
    // optional bool has_hid_event_handlers = 25;
    bool has_has_hid_event_handlers() const;

private:
    bool _internal_has_has_hid_event_handlers() const;

public:
    void clear_has_hid_event_handlers();
    bool has_hid_event_handlers() const;
    void set_has_hid_event_handlers(bool value);

private:
    bool _internal_has_hid_event_handlers() const;
    void _internal_set_has_hid_event_handlers(bool value);

public:
    // optional bool has_usb_event_handlers = 26;
    bool has_has_usb_event_handlers() const;

private:
    bool _internal_has_has_usb_event_handlers() const;

public:
    void clear_has_usb_event_handlers();
    bool has_usb_event_handlers() const;
    void set_has_usb_event_handlers(bool value);

private:
    bool _internal_has_usb_event_handlers() const;
    void _internal_set_has_usb_event_handlers(bool value);

public:
    // optional .storage.ServiceWorkerRegistrationData.CrossOriginEmbedderPolicyValue cross_origin_embedder_policy_value = 17 [default = NONE_OR_NOT_EXIST];
    bool has_cross_origin_embedder_policy_value() const;

private:
    bool _internal_has_cross_origin_embedder_policy_value() const;

public:
    void clear_cross_origin_embedder_policy_value();
    ::storage::ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue cross_origin_embedder_policy_value() const;
    void set_cross_origin_embedder_policy_value(::storage::ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue value);

private:
    ::storage::ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue _internal_cross_origin_embedder_policy_value() const;
    void _internal_set_cross_origin_embedder_policy_value(::storage::ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue value);

public:
    // optional int64 script_response_time = 16;
    bool has_script_response_time() const;

private:
    bool _internal_has_script_response_time() const;

public:
    void clear_script_response_time();
    int64_t script_response_time() const;
    void set_script_response_time(int64_t value);

private:
    int64_t _internal_script_response_time() const;
    void _internal_set_script_response_time(int64_t value);

public:
    // optional .storage.ServiceWorkerRegistrationData.CrossOriginEmbedderPolicyValue cross_origin_embedder_policy_report_only_value = 19 [default = NONE_OR_NOT_EXIST];
    bool has_cross_origin_embedder_policy_report_only_value() const;

private:
    bool _internal_has_cross_origin_embedder_policy_report_only_value() const;

public:
    void clear_cross_origin_embedder_policy_report_only_value();
    ::storage::ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue cross_origin_embedder_policy_report_only_value() const;
    void set_cross_origin_embedder_policy_report_only_value(::storage::ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue value);

private:
    ::storage::ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue _internal_cross_origin_embedder_policy_report_only_value() const;
    void _internal_set_cross_origin_embedder_policy_report_only_value(::storage::ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue value);

public:
    // optional .storage.ServiceWorkerRegistrationData.AncestorFrameType ancestor_frame_type = 21 [default = NORMAL_FRAME];
    bool has_ancestor_frame_type() const;

private:
    bool _internal_has_ancestor_frame_type() const;

public:
    void clear_ancestor_frame_type();
    ::storage::ServiceWorkerRegistrationData_AncestorFrameType ancestor_frame_type() const;
    void set_ancestor_frame_type(::storage::ServiceWorkerRegistrationData_AncestorFrameType value);

private:
    ::storage::ServiceWorkerRegistrationData_AncestorFrameType _internal_ancestor_frame_type() const;
    void _internal_set_ancestor_frame_type(::storage::ServiceWorkerRegistrationData_AncestorFrameType value);

public:
    // optional .storage.ServiceWorkerRegistrationData.FetchHandlerSkippableType fetch_handler_skippable_type = 22;
    bool has_fetch_handler_skippable_type() const;

private:
    bool _internal_has_fetch_handler_skippable_type() const;

public:
    void clear_fetch_handler_skippable_type();
    ::storage::ServiceWorkerRegistrationData_FetchHandlerSkippableType fetch_handler_skippable_type() const;
    void set_fetch_handler_skippable_type(::storage::ServiceWorkerRegistrationData_FetchHandlerSkippableType value);

private:
    ::storage::ServiceWorkerRegistrationData_FetchHandlerSkippableType _internal_fetch_handler_skippable_type() const;
    void _internal_set_fetch_handler_skippable_type(::storage::ServiceWorkerRegistrationData_FetchHandlerSkippableType value);

public:
    // @@protoc_insertion_point(class_scope:storage.ServiceWorkerRegistrationData)
private:
    class _Internal;

    // helper for ByteSizeLong()
    size_t RequiredFieldsByteSizeFallback() const;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t> used_features_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr scope_url_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr script_url_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cross_origin_embedder_policy_reporting_endpoint_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cross_origin_embedder_policy_report_only_reporting_endpoint_;
        ::storage::ServiceWorkerOriginTrialInfo* origin_trial_tokens_;
        ::storage::ServiceWorkerNavigationPreloadState* navigation_preload_state_;
        ::storage::ServiceWorkerRegistrationData_PolicyContainerPolicies* policy_container_policies_;
        ::storage::ServiceWorkerRegistrationData_RouterRules* router_rules_;
        int64_t registration_id_;
        int64_t version_id_;
        int64_t last_update_check_time_;
        uint64_t resources_total_size_bytes_;
        int update_via_cache_;
        int script_type_;
        bool is_active_;
        bool has_fetch_handler_;
        bool has_hid_event_handlers_;
        bool has_usb_event_handlers_;
        int cross_origin_embedder_policy_value_;
        int64_t script_response_time_;
        int cross_origin_embedder_policy_report_only_value_;
        int ancestor_frame_type_;
        int fetch_handler_skippable_type_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_service_5fworker_5fdatabase_2eproto;
};
// -------------------------------------------------------------------

class ServiceWorkerResourceRecord final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:storage.ServiceWorkerResourceRecord) */ {
public:
    inline ServiceWorkerResourceRecord()
        : ServiceWorkerResourceRecord(nullptr)
    {
    }
    ~ServiceWorkerResourceRecord() override;
    explicit PROTOBUF_CONSTEXPR ServiceWorkerResourceRecord(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ServiceWorkerResourceRecord(const ServiceWorkerResourceRecord& from);
    ServiceWorkerResourceRecord(ServiceWorkerResourceRecord&& from) noexcept
        : ServiceWorkerResourceRecord()
    {
        *this = ::std::move(from);
    }

    inline ServiceWorkerResourceRecord& operator=(const ServiceWorkerResourceRecord& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ServiceWorkerResourceRecord& operator=(ServiceWorkerResourceRecord&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ServiceWorkerResourceRecord& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ServiceWorkerResourceRecord* internal_default_instance()
    {
        return reinterpret_cast<const ServiceWorkerResourceRecord*>(&_ServiceWorkerResourceRecord_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 23;

    friend void swap(ServiceWorkerResourceRecord& a, ServiceWorkerResourceRecord& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ServiceWorkerResourceRecord* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ServiceWorkerResourceRecord* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ServiceWorkerResourceRecord* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ServiceWorkerResourceRecord>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ServiceWorkerResourceRecord& from);
    void MergeFrom(const ServiceWorkerResourceRecord& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ServiceWorkerResourceRecord* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "storage.ServiceWorkerResourceRecord";
    }

protected:
    explicit ServiceWorkerResourceRecord(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kUrlFieldNumber = 2,
        kSha256ChecksumFieldNumber = 4,
        kResourceIdFieldNumber = 1,
        kSizeBytesFieldNumber = 3,
    };
    // required string url = 2;
    bool has_url() const;

private:
    bool _internal_has_url() const;

public:
    void clear_url();
    const std::string& url() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_url(ArgT0&& arg0, ArgT... args);
    std::string* mutable_url();
    PROTOBUF_NODISCARD std::string* release_url();
    void set_allocated_url(std::string* url);

private:
    const std::string& _internal_url() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
    std::string* _internal_mutable_url();

public:
    // optional string sha256_checksum = 4;
    bool has_sha256_checksum() const;

private:
    bool _internal_has_sha256_checksum() const;

public:
    void clear_sha256_checksum();
    const std::string& sha256_checksum() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_sha256_checksum(ArgT0&& arg0, ArgT... args);
    std::string* mutable_sha256_checksum();
    PROTOBUF_NODISCARD std::string* release_sha256_checksum();
    void set_allocated_sha256_checksum(std::string* sha256_checksum);

private:
    const std::string& _internal_sha256_checksum() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_sha256_checksum(const std::string& value);
    std::string* _internal_mutable_sha256_checksum();

public:
    // required int64 resource_id = 1;
    bool has_resource_id() const;

private:
    bool _internal_has_resource_id() const;

public:
    void clear_resource_id();
    int64_t resource_id() const;
    void set_resource_id(int64_t value);

private:
    int64_t _internal_resource_id() const;
    void _internal_set_resource_id(int64_t value);

public:
    // optional uint64 size_bytes = 3;
    bool has_size_bytes() const;

private:
    bool _internal_has_size_bytes() const;

public:
    void clear_size_bytes();
    uint64_t size_bytes() const;
    void set_size_bytes(uint64_t value);

private:
    uint64_t _internal_size_bytes() const;
    void _internal_set_size_bytes(uint64_t value);

public:
    // @@protoc_insertion_point(class_scope:storage.ServiceWorkerResourceRecord)
private:
    class _Internal;

    // helper for ByteSizeLong()
    size_t RequiredFieldsByteSizeFallback() const;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sha256_checksum_;
        int64_t resource_id_;
        uint64_t size_bytes_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_service_5fworker_5fdatabase_2eproto;
};
// ===================================================================

// ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif // __GNUC__
// ServiceWorkerOriginTrialFeature

// required string name = 1;
inline bool ServiceWorkerOriginTrialFeature::_internal_has_name() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool ServiceWorkerOriginTrialFeature::has_name() const
{
    return _internal_has_name();
}
inline void ServiceWorkerOriginTrialFeature::clear_name()
{
    _impl_.name_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ServiceWorkerOriginTrialFeature::name() const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerOriginTrialFeature.name)
    return _internal_name();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ServiceWorkerOriginTrialFeature::set_name(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.name_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:storage.ServiceWorkerOriginTrialFeature.name)
}
inline std::string* ServiceWorkerOriginTrialFeature::mutable_name()
{
    std::string* _s = _internal_mutable_name();
    // @@protoc_insertion_point(field_mutable:storage.ServiceWorkerOriginTrialFeature.name)
    return _s;
}
inline const std::string& ServiceWorkerOriginTrialFeature::_internal_name() const
{
    return _impl_.name_.Get();
}
inline void ServiceWorkerOriginTrialFeature::_internal_set_name(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceWorkerOriginTrialFeature::_internal_mutable_name()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ServiceWorkerOriginTrialFeature::release_name()
{
    // @@protoc_insertion_point(field_release:storage.ServiceWorkerOriginTrialFeature.name)
    if (!_internal_has_name()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.name_.IsDefault()) {
        _impl_.name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ServiceWorkerOriginTrialFeature::set_allocated_name(std::string* name)
{
    if (name != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.name_.IsDefault()) {
        _impl_.name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:storage.ServiceWorkerOriginTrialFeature.name)
}

// repeated string tokens = 2;
inline int ServiceWorkerOriginTrialFeature::_internal_tokens_size() const
{
    return _impl_.tokens_.size();
}
inline int ServiceWorkerOriginTrialFeature::tokens_size() const
{
    return _internal_tokens_size();
}
inline void ServiceWorkerOriginTrialFeature::clear_tokens()
{
    _impl_.tokens_.Clear();
}
inline std::string* ServiceWorkerOriginTrialFeature::add_tokens()
{
    std::string* _s = _internal_add_tokens();
    // @@protoc_insertion_point(field_add_mutable:storage.ServiceWorkerOriginTrialFeature.tokens)
    return _s;
}
inline const std::string& ServiceWorkerOriginTrialFeature::_internal_tokens(int index) const
{
    return _impl_.tokens_.Get(index);
}
inline const std::string& ServiceWorkerOriginTrialFeature::tokens(int index) const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerOriginTrialFeature.tokens)
    return _internal_tokens(index);
}
inline std::string* ServiceWorkerOriginTrialFeature::mutable_tokens(int index)
{
    // @@protoc_insertion_point(field_mutable:storage.ServiceWorkerOriginTrialFeature.tokens)
    return _impl_.tokens_.Mutable(index);
}
inline void ServiceWorkerOriginTrialFeature::set_tokens(int index, const std::string& value)
{
    _impl_.tokens_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set:storage.ServiceWorkerOriginTrialFeature.tokens)
}
inline void ServiceWorkerOriginTrialFeature::set_tokens(int index, std::string&& value)
{
    _impl_.tokens_.Mutable(index)->assign(std::move(value));
    // @@protoc_insertion_point(field_set:storage.ServiceWorkerOriginTrialFeature.tokens)
}
inline void ServiceWorkerOriginTrialFeature::set_tokens(int index, const char* value)
{
    GOOGLE_DCHECK(value != nullptr);
    _impl_.tokens_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set_char:storage.ServiceWorkerOriginTrialFeature.tokens)
}
inline void ServiceWorkerOriginTrialFeature::set_tokens(int index, const char* value, size_t size)
{
    _impl_.tokens_.Mutable(index)->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:storage.ServiceWorkerOriginTrialFeature.tokens)
}
inline std::string* ServiceWorkerOriginTrialFeature::_internal_add_tokens()
{
    return _impl_.tokens_.Add();
}
inline void ServiceWorkerOriginTrialFeature::add_tokens(const std::string& value)
{
    _impl_.tokens_.Add()->assign(value);
    // @@protoc_insertion_point(field_add:storage.ServiceWorkerOriginTrialFeature.tokens)
}
inline void ServiceWorkerOriginTrialFeature::add_tokens(std::string&& value)
{
    _impl_.tokens_.Add(std::move(value));
    // @@protoc_insertion_point(field_add:storage.ServiceWorkerOriginTrialFeature.tokens)
}
inline void ServiceWorkerOriginTrialFeature::add_tokens(const char* value)
{
    GOOGLE_DCHECK(value != nullptr);
    _impl_.tokens_.Add()->assign(value);
    // @@protoc_insertion_point(field_add_char:storage.ServiceWorkerOriginTrialFeature.tokens)
}
inline void ServiceWorkerOriginTrialFeature::add_tokens(const char* value, size_t size)
{
    _impl_.tokens_.Add()->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_add_pointer:storage.ServiceWorkerOriginTrialFeature.tokens)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& ServiceWorkerOriginTrialFeature::tokens() const
{
    // @@protoc_insertion_point(field_list:storage.ServiceWorkerOriginTrialFeature.tokens)
    return _impl_.tokens_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* ServiceWorkerOriginTrialFeature::mutable_tokens()
{
    // @@protoc_insertion_point(field_mutable_list:storage.ServiceWorkerOriginTrialFeature.tokens)
    return &_impl_.tokens_;
}

// -------------------------------------------------------------------

// ServiceWorkerOriginTrialInfo

// repeated .storage.ServiceWorkerOriginTrialFeature features = 1;
inline int ServiceWorkerOriginTrialInfo::_internal_features_size() const
{
    return _impl_.features_.size();
}
inline int ServiceWorkerOriginTrialInfo::features_size() const
{
    return _internal_features_size();
}
inline void ServiceWorkerOriginTrialInfo::clear_features()
{
    _impl_.features_.Clear();
}
inline ::storage::ServiceWorkerOriginTrialFeature* ServiceWorkerOriginTrialInfo::mutable_features(int index)
{
    // @@protoc_insertion_point(field_mutable:storage.ServiceWorkerOriginTrialInfo.features)
    return _impl_.features_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerOriginTrialFeature>* ServiceWorkerOriginTrialInfo::mutable_features()
{
    // @@protoc_insertion_point(field_mutable_list:storage.ServiceWorkerOriginTrialInfo.features)
    return &_impl_.features_;
}
inline const ::storage::ServiceWorkerOriginTrialFeature& ServiceWorkerOriginTrialInfo::_internal_features(int index) const
{
    return _impl_.features_.Get(index);
}
inline const ::storage::ServiceWorkerOriginTrialFeature& ServiceWorkerOriginTrialInfo::features(int index) const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerOriginTrialInfo.features)
    return _internal_features(index);
}
inline ::storage::ServiceWorkerOriginTrialFeature* ServiceWorkerOriginTrialInfo::_internal_add_features()
{
    return _impl_.features_.Add();
}
inline ::storage::ServiceWorkerOriginTrialFeature* ServiceWorkerOriginTrialInfo::add_features()
{
    ::storage::ServiceWorkerOriginTrialFeature* _add = _internal_add_features();
    // @@protoc_insertion_point(field_add:storage.ServiceWorkerOriginTrialInfo.features)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerOriginTrialFeature>& ServiceWorkerOriginTrialInfo::features() const
{
    // @@protoc_insertion_point(field_list:storage.ServiceWorkerOriginTrialInfo.features)
    return _impl_.features_;
}

// -------------------------------------------------------------------

// ServiceWorkerNavigationPreloadState

// required bool enabled = 1;
inline bool ServiceWorkerNavigationPreloadState::_internal_has_enabled() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool ServiceWorkerNavigationPreloadState::has_enabled() const
{
    return _internal_has_enabled();
}
inline void ServiceWorkerNavigationPreloadState::clear_enabled()
{
    _impl_.enabled_ = false;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool ServiceWorkerNavigationPreloadState::_internal_enabled() const
{
    return _impl_.enabled_;
}
inline bool ServiceWorkerNavigationPreloadState::enabled() const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerNavigationPreloadState.enabled)
    return _internal_enabled();
}
inline void ServiceWorkerNavigationPreloadState::_internal_set_enabled(bool value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.enabled_ = value;
}
inline void ServiceWorkerNavigationPreloadState::set_enabled(bool value)
{
    _internal_set_enabled(value);
    // @@protoc_insertion_point(field_set:storage.ServiceWorkerNavigationPreloadState.enabled)
}

// optional string header = 2;
inline bool ServiceWorkerNavigationPreloadState::_internal_has_header() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool ServiceWorkerNavigationPreloadState::has_header() const
{
    return _internal_has_header();
}
inline void ServiceWorkerNavigationPreloadState::clear_header()
{
    _impl_.header_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ServiceWorkerNavigationPreloadState::header() const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerNavigationPreloadState.header)
    return _internal_header();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ServiceWorkerNavigationPreloadState::set_header(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.header_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:storage.ServiceWorkerNavigationPreloadState.header)
}
inline std::string* ServiceWorkerNavigationPreloadState::mutable_header()
{
    std::string* _s = _internal_mutable_header();
    // @@protoc_insertion_point(field_mutable:storage.ServiceWorkerNavigationPreloadState.header)
    return _s;
}
inline const std::string& ServiceWorkerNavigationPreloadState::_internal_header() const
{
    return _impl_.header_.Get();
}
inline void ServiceWorkerNavigationPreloadState::_internal_set_header(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.header_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceWorkerNavigationPreloadState::_internal_mutable_header()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.header_.Mutable(GetArenaForAllocation());
}
inline std::string* ServiceWorkerNavigationPreloadState::release_header()
{
    // @@protoc_insertion_point(field_release:storage.ServiceWorkerNavigationPreloadState.header)
    if (!_internal_has_header()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.header_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.header_.IsDefault()) {
        _impl_.header_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ServiceWorkerNavigationPreloadState::set_allocated_header(std::string* header)
{
    if (header != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.header_.SetAllocated(header, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.header_.IsDefault()) {
        _impl_.header_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:storage.ServiceWorkerNavigationPreloadState.header)
}

// -------------------------------------------------------------------

// ServiceWorkerRegistrationData_PolicyContainerPolicies

// optional .storage.ServiceWorkerRegistrationData.ReferrerPolicyValue referrer_policy = 1 [default = DEFAULT];
inline bool ServiceWorkerRegistrationData_PolicyContainerPolicies::_internal_has_referrer_policy() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool ServiceWorkerRegistrationData_PolicyContainerPolicies::has_referrer_policy() const
{
    return _internal_has_referrer_policy();
}
inline void ServiceWorkerRegistrationData_PolicyContainerPolicies::clear_referrer_policy()
{
    _impl_.referrer_policy_ = 1;
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::storage::ServiceWorkerRegistrationData_ReferrerPolicyValue ServiceWorkerRegistrationData_PolicyContainerPolicies::_internal_referrer_policy() const
{
    return static_cast<::storage::ServiceWorkerRegistrationData_ReferrerPolicyValue>(_impl_.referrer_policy_);
}
inline ::storage::ServiceWorkerRegistrationData_ReferrerPolicyValue ServiceWorkerRegistrationData_PolicyContainerPolicies::referrer_policy() const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.PolicyContainerPolicies.referrer_policy)
    return _internal_referrer_policy();
}
inline void ServiceWorkerRegistrationData_PolicyContainerPolicies::_internal_set_referrer_policy(
    ::storage::ServiceWorkerRegistrationData_ReferrerPolicyValue value)
{
    assert(::storage::ServiceWorkerRegistrationData_ReferrerPolicyValue_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.referrer_policy_ = value;
}
inline void ServiceWorkerRegistrationData_PolicyContainerPolicies::set_referrer_policy(::storage::ServiceWorkerRegistrationData_ReferrerPolicyValue value)
{
    _internal_set_referrer_policy(value);
    // @@protoc_insertion_point(field_set:storage.ServiceWorkerRegistrationData.PolicyContainerPolicies.referrer_policy)
}

// optional int32 sandbox_flags = 2 [default = 0];
inline bool ServiceWorkerRegistrationData_PolicyContainerPolicies::_internal_has_sandbox_flags() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool ServiceWorkerRegistrationData_PolicyContainerPolicies::has_sandbox_flags() const
{
    return _internal_has_sandbox_flags();
}
inline void ServiceWorkerRegistrationData_PolicyContainerPolicies::clear_sandbox_flags()
{
    _impl_.sandbox_flags_ = 0;
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t ServiceWorkerRegistrationData_PolicyContainerPolicies::_internal_sandbox_flags() const
{
    return _impl_.sandbox_flags_;
}
inline int32_t ServiceWorkerRegistrationData_PolicyContainerPolicies::sandbox_flags() const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.PolicyContainerPolicies.sandbox_flags)
    return _internal_sandbox_flags();
}
inline void ServiceWorkerRegistrationData_PolicyContainerPolicies::_internal_set_sandbox_flags(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.sandbox_flags_ = value;
}
inline void ServiceWorkerRegistrationData_PolicyContainerPolicies::set_sandbox_flags(int32_t value)
{
    _internal_set_sandbox_flags(value);
    // @@protoc_insertion_point(field_set:storage.ServiceWorkerRegistrationData.PolicyContainerPolicies.sandbox_flags)
}

// optional .storage.ServiceWorkerRegistrationData.IPAddressSpace ip_address_space = 3 [default = UNKNOWN];
inline bool ServiceWorkerRegistrationData_PolicyContainerPolicies::_internal_has_ip_address_space() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool ServiceWorkerRegistrationData_PolicyContainerPolicies::has_ip_address_space() const
{
    return _internal_has_ip_address_space();
}
inline void ServiceWorkerRegistrationData_PolicyContainerPolicies::clear_ip_address_space()
{
    _impl_.ip_address_space_ = 0;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::storage::ServiceWorkerRegistrationData_IPAddressSpace ServiceWorkerRegistrationData_PolicyContainerPolicies::_internal_ip_address_space() const
{
    return static_cast<::storage::ServiceWorkerRegistrationData_IPAddressSpace>(_impl_.ip_address_space_);
}
inline ::storage::ServiceWorkerRegistrationData_IPAddressSpace ServiceWorkerRegistrationData_PolicyContainerPolicies::ip_address_space() const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.PolicyContainerPolicies.ip_address_space)
    return _internal_ip_address_space();
}
inline void ServiceWorkerRegistrationData_PolicyContainerPolicies::_internal_set_ip_address_space(::storage::ServiceWorkerRegistrationData_IPAddressSpace value)
{
    assert(::storage::ServiceWorkerRegistrationData_IPAddressSpace_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.ip_address_space_ = value;
}
inline void ServiceWorkerRegistrationData_PolicyContainerPolicies::set_ip_address_space(::storage::ServiceWorkerRegistrationData_IPAddressSpace value)
{
    _internal_set_ip_address_space(value);
    // @@protoc_insertion_point(field_set:storage.ServiceWorkerRegistrationData.PolicyContainerPolicies.ip_address_space)
}

// -------------------------------------------------------------------

// ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern

// optional string value = 1;
inline bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern::_internal_has_value() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern::has_value() const
{
    return _internal_has_value();
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern::clear_value()
{
    _impl_.value_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern::value() const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.FixedPattern.value)
    return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern::set_value(
    ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.value_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.FixedPattern.value)
}
inline std::string* ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern::mutable_value()
{
    std::string* _s = _internal_mutable_value();
    // @@protoc_insertion_point(field_mutable:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.FixedPattern.value)
    return _s;
}
inline const std::string& ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern::_internal_value() const
{
    return _impl_.value_.Get();
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern::_internal_set_value(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern::_internal_mutable_value()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern::release_value()
{
    // @@protoc_insertion_point(field_release:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.FixedPattern.value)
    if (!_internal_has_value()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.value_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.value_.IsDefault()) {
        _impl_.value_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern::set_allocated_value(std::string* value)
{
    if (value != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.value_.IsDefault()) {
        _impl_.value_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.FixedPattern.value)
}

// -------------------------------------------------------------------

// ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern

// optional string name = 1;
inline bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern::_internal_has_name() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern::has_name() const
{
    return _internal_has_name();
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern::clear_name()
{
    _impl_.name_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern::name() const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.WildcardPattern.name)
    return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern::set_name(
    ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.name_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.WildcardPattern.name)
}
inline std::string* ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern::mutable_name()
{
    std::string* _s = _internal_mutable_name();
    // @@protoc_insertion_point(field_mutable:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.WildcardPattern.name)
    return _s;
}
inline const std::string& ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern::_internal_name() const
{
    return _impl_.name_.Get();
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern::_internal_set_name(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern::_internal_mutable_name()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern::release_name()
{
    // @@protoc_insertion_point(field_release:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.WildcardPattern.name)
    if (!_internal_has_name()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.name_.IsDefault()) {
        _impl_.name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern::set_allocated_name(std::string* name)
{
    if (name != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.name_.IsDefault()) {
        _impl_.name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.WildcardPattern.name)
}

// optional string prefix = 2;
inline bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern::_internal_has_prefix() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern::has_prefix() const
{
    return _internal_has_prefix();
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern::clear_prefix()
{
    _impl_.prefix_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern::prefix() const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.WildcardPattern.prefix)
    return _internal_prefix();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern::set_prefix(
    ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.prefix_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.WildcardPattern.prefix)
}
inline std::string* ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern::mutable_prefix()
{
    std::string* _s = _internal_mutable_prefix();
    // @@protoc_insertion_point(field_mutable:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.WildcardPattern.prefix)
    return _s;
}
inline const std::string& ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern::_internal_prefix() const
{
    return _impl_.prefix_.Get();
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern::_internal_set_prefix(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.prefix_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern::_internal_mutable_prefix()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.prefix_.Mutable(GetArenaForAllocation());
}
inline std::string* ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern::release_prefix()
{
    // @@protoc_insertion_point(field_release:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.WildcardPattern.prefix)
    if (!_internal_has_prefix()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.prefix_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.prefix_.IsDefault()) {
        _impl_.prefix_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern::set_allocated_prefix(std::string* prefix)
{
    if (prefix != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.prefix_.SetAllocated(prefix, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.prefix_.IsDefault()) {
        _impl_.prefix_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.WildcardPattern.prefix)
}

// optional string value = 3;
inline bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern::_internal_has_value() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern::has_value() const
{
    return _internal_has_value();
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern::clear_value()
{
    _impl_.value_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern::value() const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.WildcardPattern.value)
    return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern::set_value(
    ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.value_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.WildcardPattern.value)
}
inline std::string* ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern::mutable_value()
{
    std::string* _s = _internal_mutable_value();
    // @@protoc_insertion_point(field_mutable:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.WildcardPattern.value)
    return _s;
}
inline const std::string& ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern::_internal_value() const
{
    return _impl_.value_.Get();
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern::_internal_set_value(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern::_internal_mutable_value()
{
    _impl_._has_bits_[0] |= 0x00000004u;
    return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern::release_value()
{
    // @@protoc_insertion_point(field_release:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.WildcardPattern.value)
    if (!_internal_has_value()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000004u;
    auto* p = _impl_.value_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.value_.IsDefault()) {
        _impl_.value_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern::set_allocated_value(std::string* value)
{
    if (value != nullptr) {
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.value_.IsDefault()) {
        _impl_.value_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.WildcardPattern.value)
}

// optional string suffix = 4;
inline bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern::_internal_has_suffix() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    return value;
}
inline bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern::has_suffix() const
{
    return _internal_has_suffix();
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern::clear_suffix()
{
    _impl_.suffix_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern::suffix() const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.WildcardPattern.suffix)
    return _internal_suffix();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern::set_suffix(
    ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.suffix_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.WildcardPattern.suffix)
}
inline std::string* ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern::mutable_suffix()
{
    std::string* _s = _internal_mutable_suffix();
    // @@protoc_insertion_point(field_mutable:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.WildcardPattern.suffix)
    return _s;
}
inline const std::string& ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern::_internal_suffix() const
{
    return _impl_.suffix_.Get();
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern::_internal_set_suffix(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.suffix_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern::_internal_mutable_suffix()
{
    _impl_._has_bits_[0] |= 0x00000008u;
    return _impl_.suffix_.Mutable(GetArenaForAllocation());
}
inline std::string* ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern::release_suffix()
{
    // @@protoc_insertion_point(field_release:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.WildcardPattern.suffix)
    if (!_internal_has_suffix()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000008u;
    auto* p = _impl_.suffix_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.suffix_.IsDefault()) {
        _impl_.suffix_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern::set_allocated_suffix(std::string* suffix)
{
    if (suffix != nullptr) {
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    _impl_.suffix_.SetAllocated(suffix, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.suffix_.IsDefault()) {
        _impl_.suffix_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.WildcardPattern.suffix)
}

// -------------------------------------------------------------------

// ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part

// optional .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.Modifier modifier = 1;
inline bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::_internal_has_modifier() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::has_modifier() const
{
    return _internal_has_modifier();
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::clear_modifier()
{
    _impl_.modifier_ = 0;
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::_internal_modifier() const
{
    return static_cast<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier>(_impl_.modifier_);
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::modifier() const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.modifier)
    return _internal_modifier();
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::_internal_set_modifier(
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier value)
{
    assert(::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.modifier_ = value;
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::set_modifier(
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier value)
{
    _internal_set_modifier(value);
    // @@protoc_insertion_point(field_set:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.modifier)
}

// .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.FixedPattern fixed = 2;
inline bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::_internal_has_fixed() const
{
    return pattern_case() == kFixed;
}
inline bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::has_fixed() const
{
    return _internal_has_fixed();
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::set_has_fixed()
{
    _impl_._oneof_case_[0] = kFixed;
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::clear_fixed()
{
    if (_internal_has_fixed()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.pattern_.fixed_;
        }
        clear_has_pattern();
    }
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::release_fixed()
{
    // @@protoc_insertion_point(field_release:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.fixed)
    if (_internal_has_fixed()) {
        clear_has_pattern();
        ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern* temp = _impl_.pattern_.fixed_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.pattern_.fixed_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::_internal_fixed() const
{
    return _internal_has_fixed() ? *_impl_.pattern_.fixed_
                                 : reinterpret_cast<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern&>(
                                     ::storage::_ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern_default_instance_);
}
inline const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::fixed() const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.fixed)
    return _internal_fixed();
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::unsafe_arena_release_fixed()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.fixed)
    if (_internal_has_fixed()) {
        clear_has_pattern();
        ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern* temp = _impl_.pattern_.fixed_;
        _impl_.pattern_.fixed_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::unsafe_arena_set_allocated_fixed(
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern* fixed)
{
    clear_pattern();
    if (fixed) {
        set_has_fixed();
        _impl_.pattern_.fixed_ = fixed;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.fixed)
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::_internal_mutable_fixed()
{
    if (!_internal_has_fixed()) {
        clear_pattern();
        set_has_fixed();
        _impl_.pattern_.fixed_
            = CreateMaybeMessage<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern>(GetArenaForAllocation());
    }
    return _impl_.pattern_.fixed_;
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::mutable_fixed()
{
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_FixedPattern* _msg = _internal_mutable_fixed();
    // @@protoc_insertion_point(field_mutable:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.fixed)
    return _msg;
}

// .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.WildcardPattern segment_wildcard = 4;
inline bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::_internal_has_segment_wildcard() const
{
    return pattern_case() == kSegmentWildcard;
}
inline bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::has_segment_wildcard() const
{
    return _internal_has_segment_wildcard();
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::set_has_segment_wildcard()
{
    _impl_._oneof_case_[0] = kSegmentWildcard;
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::clear_segment_wildcard()
{
    if (_internal_has_segment_wildcard()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.pattern_.segment_wildcard_;
        }
        clear_has_pattern();
    }
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::release_segment_wildcard()
{
    // @@protoc_insertion_point(field_release:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.segment_wildcard)
    if (_internal_has_segment_wildcard()) {
        clear_has_pattern();
        ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern* temp = _impl_.pattern_.segment_wildcard_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.pattern_.segment_wildcard_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::_internal_segment_wildcard() const
{
    return _internal_has_segment_wildcard()
        ? *_impl_.pattern_.segment_wildcard_
        : reinterpret_cast<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern&>(
            ::storage::_ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern_default_instance_);
}
inline const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::segment_wildcard() const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.segment_wildcard)
    return _internal_segment_wildcard();
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::unsafe_arena_release_segment_wildcard()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.segment_wildcard)
    if (_internal_has_segment_wildcard()) {
        clear_has_pattern();
        ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern* temp = _impl_.pattern_.segment_wildcard_;
        _impl_.pattern_.segment_wildcard_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::unsafe_arena_set_allocated_segment_wildcard(
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern* segment_wildcard)
{
    clear_pattern();
    if (segment_wildcard) {
        set_has_segment_wildcard();
        _impl_.pattern_.segment_wildcard_ = segment_wildcard;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.segment_wildcard)
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::_internal_mutable_segment_wildcard()
{
    if (!_internal_has_segment_wildcard()) {
        clear_pattern();
        set_has_segment_wildcard();
        _impl_.pattern_.segment_wildcard_
            = CreateMaybeMessage<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern>(
                GetArenaForAllocation());
    }
    return _impl_.pattern_.segment_wildcard_;
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::mutable_segment_wildcard()
{
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern* _msg = _internal_mutable_segment_wildcard();
    // @@protoc_insertion_point(field_mutable:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.segment_wildcard)
    return _msg;
}

// .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.WildcardPattern full_wildcard = 5;
inline bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::_internal_has_full_wildcard() const
{
    return pattern_case() == kFullWildcard;
}
inline bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::has_full_wildcard() const
{
    return _internal_has_full_wildcard();
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::set_has_full_wildcard()
{
    _impl_._oneof_case_[0] = kFullWildcard;
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::clear_full_wildcard()
{
    if (_internal_has_full_wildcard()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.pattern_.full_wildcard_;
        }
        clear_has_pattern();
    }
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::release_full_wildcard()
{
    // @@protoc_insertion_point(field_release:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.full_wildcard)
    if (_internal_has_full_wildcard()) {
        clear_has_pattern();
        ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern* temp = _impl_.pattern_.full_wildcard_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.pattern_.full_wildcard_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::_internal_full_wildcard() const
{
    return _internal_has_full_wildcard()
        ? *_impl_.pattern_.full_wildcard_
        : reinterpret_cast<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern&>(
            ::storage::_ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern_default_instance_);
}
inline const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::full_wildcard() const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.full_wildcard)
    return _internal_full_wildcard();
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::unsafe_arena_release_full_wildcard()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.full_wildcard)
    if (_internal_has_full_wildcard()) {
        clear_has_pattern();
        ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern* temp = _impl_.pattern_.full_wildcard_;
        _impl_.pattern_.full_wildcard_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::unsafe_arena_set_allocated_full_wildcard(
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern* full_wildcard)
{
    clear_pattern();
    if (full_wildcard) {
        set_has_full_wildcard();
        _impl_.pattern_.full_wildcard_ = full_wildcard;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.full_wildcard)
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::_internal_mutable_full_wildcard()
{
    if (!_internal_has_full_wildcard()) {
        clear_pattern();
        set_has_full_wildcard();
        _impl_.pattern_.full_wildcard_
            = CreateMaybeMessage<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern>(
                GetArenaForAllocation());
    }
    return _impl_.pattern_.full_wildcard_;
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::mutable_full_wildcard()
{
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_WildcardPattern* _msg = _internal_mutable_full_wildcard();
    // @@protoc_insertion_point(field_mutable:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part.full_wildcard)
    return _msg;
}

inline bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::has_pattern() const
{
    return pattern_case() != PATTERN_NOT_SET;
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::clear_has_pattern()
{
    _impl_._oneof_case_[0] = PATTERN_NOT_SET;
}
inline ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::PatternCase
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::pattern_case() const
{
    return ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part::PatternCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options

// optional bool ignore_case = 1 [default = false];
inline bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options::_internal_has_ignore_case() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options::has_ignore_case() const
{
    return _internal_has_ignore_case();
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options::clear_ignore_case()
{
    _impl_.ignore_case_ = false;
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options::_internal_ignore_case() const
{
    return _impl_.ignore_case_;
}
inline bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options::ignore_case() const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Options.ignore_case)
    return _internal_ignore_case();
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options::_internal_set_ignore_case(bool value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.ignore_case_ = value;
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options::set_ignore_case(bool value)
{
    _internal_set_ignore_case(value);
    // @@protoc_insertion_point(field_set:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Options.ignore_case)
}

// -------------------------------------------------------------------

// ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern

// repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part legacy_pathname = 1;
inline int ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::_internal_legacy_pathname_size() const
{
    return _impl_.legacy_pathname_.size();
}
inline int ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::legacy_pathname_size() const
{
    return _internal_legacy_pathname_size();
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::clear_legacy_pathname()
{
    _impl_.legacy_pathname_.Clear();
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::mutable_legacy_pathname(int index)
{
    // @@protoc_insertion_point(field_mutable:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.legacy_pathname)
    return _impl_.legacy_pathname_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part>*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::mutable_legacy_pathname()
{
    // @@protoc_insertion_point(field_mutable_list:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.legacy_pathname)
    return &_impl_.legacy_pathname_;
}
inline const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::_internal_legacy_pathname(int index) const
{
    return _impl_.legacy_pathname_.Get(index);
}
inline const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::legacy_pathname(int index) const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.legacy_pathname)
    return _internal_legacy_pathname(index);
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::_internal_add_legacy_pathname()
{
    return _impl_.legacy_pathname_.Add();
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::add_legacy_pathname()
{
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part* _add = _internal_add_legacy_pathname();
    // @@protoc_insertion_point(field_add:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.legacy_pathname)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part>&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::legacy_pathname() const
{
    // @@protoc_insertion_point(field_list:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.legacy_pathname)
    return _impl_.legacy_pathname_;
}

// repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part protocol = 3;
inline int ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::_internal_protocol_size() const
{
    return _impl_.protocol_.size();
}
inline int ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::protocol_size() const
{
    return _internal_protocol_size();
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::clear_protocol()
{
    _impl_.protocol_.Clear();
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::mutable_protocol(int index)
{
    // @@protoc_insertion_point(field_mutable:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.protocol)
    return _impl_.protocol_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part>*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::mutable_protocol()
{
    // @@protoc_insertion_point(field_mutable_list:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.protocol)
    return &_impl_.protocol_;
}
inline const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::_internal_protocol(int index) const
{
    return _impl_.protocol_.Get(index);
}
inline const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::protocol(int index) const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.protocol)
    return _internal_protocol(index);
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::_internal_add_protocol()
{
    return _impl_.protocol_.Add();
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::add_protocol()
{
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part* _add = _internal_add_protocol();
    // @@protoc_insertion_point(field_add:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.protocol)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part>&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::protocol() const
{
    // @@protoc_insertion_point(field_list:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.protocol)
    return _impl_.protocol_;
}

// repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part username = 4;
inline int ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::_internal_username_size() const
{
    return _impl_.username_.size();
}
inline int ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::username_size() const
{
    return _internal_username_size();
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::clear_username()
{
    _impl_.username_.Clear();
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::mutable_username(int index)
{
    // @@protoc_insertion_point(field_mutable:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.username)
    return _impl_.username_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part>*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::mutable_username()
{
    // @@protoc_insertion_point(field_mutable_list:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.username)
    return &_impl_.username_;
}
inline const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::_internal_username(int index) const
{
    return _impl_.username_.Get(index);
}
inline const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::username(int index) const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.username)
    return _internal_username(index);
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::_internal_add_username()
{
    return _impl_.username_.Add();
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::add_username()
{
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part* _add = _internal_add_username();
    // @@protoc_insertion_point(field_add:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.username)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part>&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::username() const
{
    // @@protoc_insertion_point(field_list:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.username)
    return _impl_.username_;
}

// repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part password = 5;
inline int ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::_internal_password_size() const
{
    return _impl_.password_.size();
}
inline int ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::password_size() const
{
    return _internal_password_size();
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::clear_password()
{
    _impl_.password_.Clear();
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::mutable_password(int index)
{
    // @@protoc_insertion_point(field_mutable:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.password)
    return _impl_.password_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part>*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::mutable_password()
{
    // @@protoc_insertion_point(field_mutable_list:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.password)
    return &_impl_.password_;
}
inline const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::_internal_password(int index) const
{
    return _impl_.password_.Get(index);
}
inline const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::password(int index) const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.password)
    return _internal_password(index);
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::_internal_add_password()
{
    return _impl_.password_.Add();
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::add_password()
{
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part* _add = _internal_add_password();
    // @@protoc_insertion_point(field_add:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.password)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part>&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::password() const
{
    // @@protoc_insertion_point(field_list:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.password)
    return _impl_.password_;
}

// repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part hostname = 2;
inline int ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::_internal_hostname_size() const
{
    return _impl_.hostname_.size();
}
inline int ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::hostname_size() const
{
    return _internal_hostname_size();
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::clear_hostname()
{
    _impl_.hostname_.Clear();
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::mutable_hostname(int index)
{
    // @@protoc_insertion_point(field_mutable:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.hostname)
    return _impl_.hostname_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part>*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::mutable_hostname()
{
    // @@protoc_insertion_point(field_mutable_list:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.hostname)
    return &_impl_.hostname_;
}
inline const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::_internal_hostname(int index) const
{
    return _impl_.hostname_.Get(index);
}
inline const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::hostname(int index) const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.hostname)
    return _internal_hostname(index);
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::_internal_add_hostname()
{
    return _impl_.hostname_.Add();
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::add_hostname()
{
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part* _add = _internal_add_hostname();
    // @@protoc_insertion_point(field_add:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.hostname)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part>&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::hostname() const
{
    // @@protoc_insertion_point(field_list:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.hostname)
    return _impl_.hostname_;
}

// repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part port = 6;
inline int ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::_internal_port_size() const
{
    return _impl_.port_.size();
}
inline int ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::port_size() const
{
    return _internal_port_size();
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::clear_port()
{
    _impl_.port_.Clear();
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::mutable_port(int index)
{
    // @@protoc_insertion_point(field_mutable:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.port)
    return _impl_.port_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part>*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::mutable_port()
{
    // @@protoc_insertion_point(field_mutable_list:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.port)
    return &_impl_.port_;
}
inline const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::_internal_port(int index) const
{
    return _impl_.port_.Get(index);
}
inline const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::port(int index) const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.port)
    return _internal_port(index);
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::_internal_add_port()
{
    return _impl_.port_.Add();
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::add_port()
{
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part* _add = _internal_add_port();
    // @@protoc_insertion_point(field_add:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.port)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part>&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::port() const
{
    // @@protoc_insertion_point(field_list:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.port)
    return _impl_.port_;
}

// repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part pathname = 7;
inline int ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::_internal_pathname_size() const
{
    return _impl_.pathname_.size();
}
inline int ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::pathname_size() const
{
    return _internal_pathname_size();
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::clear_pathname()
{
    _impl_.pathname_.Clear();
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::mutable_pathname(int index)
{
    // @@protoc_insertion_point(field_mutable:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.pathname)
    return _impl_.pathname_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part>*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::mutable_pathname()
{
    // @@protoc_insertion_point(field_mutable_list:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.pathname)
    return &_impl_.pathname_;
}
inline const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::_internal_pathname(int index) const
{
    return _impl_.pathname_.Get(index);
}
inline const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::pathname(int index) const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.pathname)
    return _internal_pathname(index);
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::_internal_add_pathname()
{
    return _impl_.pathname_.Add();
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::add_pathname()
{
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part* _add = _internal_add_pathname();
    // @@protoc_insertion_point(field_add:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.pathname)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part>&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::pathname() const
{
    // @@protoc_insertion_point(field_list:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.pathname)
    return _impl_.pathname_;
}

// repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part search = 8;
inline int ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::_internal_search_size() const
{
    return _impl_.search_.size();
}
inline int ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::search_size() const
{
    return _internal_search_size();
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::clear_search()
{
    _impl_.search_.Clear();
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::mutable_search(int index)
{
    // @@protoc_insertion_point(field_mutable:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.search)
    return _impl_.search_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part>*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::mutable_search()
{
    // @@protoc_insertion_point(field_mutable_list:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.search)
    return &_impl_.search_;
}
inline const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::_internal_search(int index) const
{
    return _impl_.search_.Get(index);
}
inline const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::search(int index) const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.search)
    return _internal_search(index);
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::_internal_add_search()
{
    return _impl_.search_.Add();
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::add_search()
{
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part* _add = _internal_add_search();
    // @@protoc_insertion_point(field_add:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.search)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part>&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::search() const
{
    // @@protoc_insertion_point(field_list:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.search)
    return _impl_.search_;
}

// repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Part hash = 9;
inline int ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::_internal_hash_size() const
{
    return _impl_.hash_.size();
}
inline int ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::hash_size() const
{
    return _internal_hash_size();
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::clear_hash()
{
    _impl_.hash_.Clear();
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::mutable_hash(int index)
{
    // @@protoc_insertion_point(field_mutable:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.hash)
    return _impl_.hash_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part>*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::mutable_hash()
{
    // @@protoc_insertion_point(field_mutable_list:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.hash)
    return &_impl_.hash_;
}
inline const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::_internal_hash(int index) const
{
    return _impl_.hash_.Get(index);
}
inline const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::hash(int index) const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.hash)
    return _internal_hash(index);
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::_internal_add_hash()
{
    return _impl_.hash_.Add();
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::add_hash()
{
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part* _add = _internal_add_hash();
    // @@protoc_insertion_point(field_add:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.hash)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part>&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::hash() const
{
    // @@protoc_insertion_point(field_list:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.hash)
    return _impl_.hash_;
}

// optional .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.Options options = 10;
inline bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::_internal_has_options() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.options_ != nullptr);
    return value;
}
inline bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::has_options() const
{
    return _internal_has_options();
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::clear_options()
{
    if (_impl_.options_ != nullptr)
        _impl_.options_->Clear();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::_internal_options() const
{
    const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options* p = _impl_.options_;
    return p != nullptr ? *p
                        : reinterpret_cast<const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options&>(
                            ::storage::_ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options_default_instance_);
}
inline const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::options() const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.options)
    return _internal_options();
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::unsafe_arena_set_allocated_options(
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options* options)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.options_);
    }
    _impl_.options_ = options;
    if (options) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.options)
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::release_options()
{
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options* temp = _impl_.options_;
    _impl_.options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::unsafe_arena_release_options()
{
    // @@protoc_insertion_point(field_release:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.options)
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options* temp = _impl_.options_;
    _impl_.options_ = nullptr;
    return temp;
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::_internal_mutable_options()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    if (_impl_.options_ == nullptr) {
        auto* p = CreateMaybeMessage<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options>(GetArenaForAllocation());
        _impl_.options_ = p;
    }
    return _impl_.options_;
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::mutable_options()
{
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options* _msg = _internal_mutable_options();
    // @@protoc_insertion_point(field_mutable:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.options)
    return _msg;
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern::set_allocated_options(
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Options* options)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.options_;
    }
    if (options) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(options);
        if (message_arena != submessage_arena) {
            options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, options, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.options_ = options;
    // @@protoc_insertion_point(field_set_allocated:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern.options)
}

// -------------------------------------------------------------------

// ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request

// optional string method = 1;
inline bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::_internal_has_method() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::has_method() const
{
    return _internal_has_method();
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::clear_method()
{
    _impl_.method_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::method() const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.Request.method)
    return _internal_method();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::set_method(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.method_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.Request.method)
}
inline std::string* ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::mutable_method()
{
    std::string* _s = _internal_mutable_method();
    // @@protoc_insertion_point(field_mutable:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.Request.method)
    return _s;
}
inline const std::string& ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::_internal_method() const
{
    return _impl_.method_.Get();
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::_internal_set_method(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.method_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::_internal_mutable_method()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.method_.Mutable(GetArenaForAllocation());
}
inline std::string* ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::release_method()
{
    // @@protoc_insertion_point(field_release:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.Request.method)
    if (!_internal_has_method()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.method_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.method_.IsDefault()) {
        _impl_.method_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::set_allocated_method(std::string* method)
{
    if (method != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.method_.SetAllocated(method, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.method_.IsDefault()) {
        _impl_.method_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.Request.method)
}

// optional .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.Request.Mode mode = 2;
inline bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::_internal_has_mode() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::has_mode() const
{
    return _internal_has_mode();
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::clear_mode()
{
    _impl_.mode_ = 0;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::_internal_mode() const
{
    return static_cast<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode>(_impl_.mode_);
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::mode() const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.Request.mode)
    return _internal_mode();
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::_internal_set_mode(
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode value)
{
    assert(::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.mode_ = value;
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::set_mode(
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode value)
{
    _internal_set_mode(value);
    // @@protoc_insertion_point(field_set:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.Request.mode)
}

// optional .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.Request.Destination destination = 3;
inline bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::_internal_has_destination() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::has_destination() const
{
    return _internal_has_destination();
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::clear_destination()
{
    _impl_.destination_ = 0;
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::_internal_destination() const
{
    return static_cast<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination>(_impl_.destination_);
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::destination() const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.Request.destination)
    return _internal_destination();
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::_internal_set_destination(
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination value)
{
    assert(::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.destination_ = value;
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request::set_destination(
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination value)
{
    _internal_set_destination(value);
    // @@protoc_insertion_point(field_set:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.Request.destination)
}

// -------------------------------------------------------------------

// ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus

// optional .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.RunningStatus.Status status = 1;
inline bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus::_internal_has_status() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus::has_status() const
{
    return _internal_has_status();
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus::clear_status()
{
    _impl_.status_ = 0;
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_Status
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus::_internal_status() const
{
    return static_cast<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_Status>(_impl_.status_);
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_Status
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus::status() const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.RunningStatus.status)
    return _internal_status();
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus::_internal_set_status(
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_Status value)
{
    assert(::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_Status_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.status_ = value;
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus::set_status(
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_Status value)
{
    _internal_set_status(value);
    // @@protoc_insertion_point(field_set:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.RunningStatus.status)
}

// -------------------------------------------------------------------

// ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject

// repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition conditions = 1;
inline int ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject::_internal_conditions_size() const
{
    return _impl_.conditions_.size();
}
inline int ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject::conditions_size() const
{
    return _internal_conditions_size();
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject::clear_conditions()
{
    _impl_.conditions_.Clear();
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject::mutable_conditions(int index)
{
    // @@protoc_insertion_point(field_mutable:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.ConditionObject.conditions)
    return _impl_.conditions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition>*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject::mutable_conditions()
{
    // @@protoc_insertion_point(field_mutable_list:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.ConditionObject.conditions)
    return &_impl_.conditions_;
}
inline const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject::_internal_conditions(int index) const
{
    return _impl_.conditions_.Get(index);
}
inline const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject::conditions(int index) const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.ConditionObject.conditions)
    return _internal_conditions(index);
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject::_internal_add_conditions()
{
    return _impl_.conditions_.Add();
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject::add_conditions()
{
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition* _add = _internal_add_conditions();
    // @@protoc_insertion_point(field_add:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.ConditionObject.conditions)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition>&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject::conditions() const
{
    // @@protoc_insertion_point(field_list:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.ConditionObject.conditions)
    return _impl_.conditions_;
}

// -------------------------------------------------------------------

// ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition

// repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.ConditionObject objects = 1;
inline int ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition::_internal_objects_size() const
{
    return _impl_.objects_.size();
}
inline int ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition::objects_size() const
{
    return _internal_objects_size();
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition::clear_objects()
{
    _impl_.objects_.Clear();
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition::mutable_objects(int index)
{
    // @@protoc_insertion_point(field_mutable:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.OrCondition.objects)
    return _impl_.objects_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject>*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition::mutable_objects()
{
    // @@protoc_insertion_point(field_mutable_list:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.OrCondition.objects)
    return &_impl_.objects_;
}
inline const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition::_internal_objects(int index) const
{
    return _impl_.objects_.Get(index);
}
inline const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition::objects(int index) const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.OrCondition.objects)
    return _internal_objects(index);
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition::_internal_add_objects()
{
    return _impl_.objects_.Add();
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition::add_objects()
{
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject* _add = _internal_add_objects();
    // @@protoc_insertion_point(field_add:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.OrCondition.objects)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject>&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition::objects() const
{
    // @@protoc_insertion_point(field_list:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.OrCondition.objects)
    return _impl_.objects_;
}

// -------------------------------------------------------------------

// ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition

// required .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.ConditionObject object = 1;
inline bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition::_internal_has_object() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.object_ != nullptr);
    return value;
}
inline bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition::has_object() const
{
    return _internal_has_object();
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition::clear_object()
{
    if (_impl_.object_ != nullptr)
        _impl_.object_->Clear();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition::_internal_object() const
{
    const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject* p = _impl_.object_;
    return p != nullptr ? *p
                        : reinterpret_cast<const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject&>(
                            ::storage::_ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject_default_instance_);
}
inline const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition::object() const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.NotCondition.object)
    return _internal_object();
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition::unsafe_arena_set_allocated_object(
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject* object)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.object_);
    }
    _impl_.object_ = object;
    if (object) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.NotCondition.object)
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition::release_object()
{
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject* temp = _impl_.object_;
    _impl_.object_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition::unsafe_arena_release_object()
{
    // @@protoc_insertion_point(field_release:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.NotCondition.object)
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject* temp = _impl_.object_;
    _impl_.object_ = nullptr;
    return temp;
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition::_internal_mutable_object()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    if (_impl_.object_ == nullptr) {
        auto* p = CreateMaybeMessage<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject>(GetArenaForAllocation());
        _impl_.object_ = p;
    }
    return _impl_.object_;
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition::mutable_object()
{
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject* _msg = _internal_mutable_object();
    // @@protoc_insertion_point(field_mutable:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.NotCondition.object)
    return _msg;
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition::set_allocated_object(
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_ConditionObject* object)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.object_;
    }
    if (object) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(object);
        if (message_arena != submessage_arena) {
            object = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, object, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.object_ = object;
    // @@protoc_insertion_point(field_set_allocated:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.NotCondition.object)
}

// -------------------------------------------------------------------

// ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition

// .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.URLPattern url_pattern = 1;
inline bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::_internal_has_url_pattern() const
{
    return condition_case() == kUrlPattern;
}
inline bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::has_url_pattern() const
{
    return _internal_has_url_pattern();
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::set_has_url_pattern()
{
    _impl_._oneof_case_[0] = kUrlPattern;
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::clear_url_pattern()
{
    if (_internal_has_url_pattern()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.condition_.url_pattern_;
        }
        clear_has_condition();
    }
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::release_url_pattern()
{
    // @@protoc_insertion_point(field_release:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.url_pattern)
    if (_internal_has_url_pattern()) {
        clear_has_condition();
        ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern* temp = _impl_.condition_.url_pattern_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.condition_.url_pattern_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::_internal_url_pattern() const
{
    return _internal_has_url_pattern() ? *_impl_.condition_.url_pattern_
                                       : reinterpret_cast<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern&>(
                                           ::storage::_ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_default_instance_);
}
inline const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::url_pattern() const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.url_pattern)
    return _internal_url_pattern();
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::unsafe_arena_release_url_pattern()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.url_pattern)
    if (_internal_has_url_pattern()) {
        clear_has_condition();
        ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern* temp = _impl_.condition_.url_pattern_;
        _impl_.condition_.url_pattern_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::unsafe_arena_set_allocated_url_pattern(
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern* url_pattern)
{
    clear_condition();
    if (url_pattern) {
        set_has_url_pattern();
        _impl_.condition_.url_pattern_ = url_pattern;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.url_pattern)
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::_internal_mutable_url_pattern()
{
    if (!_internal_has_url_pattern()) {
        clear_condition();
        set_has_url_pattern();
        _impl_.condition_.url_pattern_
            = CreateMaybeMessage<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern>(GetArenaForAllocation());
    }
    return _impl_.condition_.url_pattern_;
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::mutable_url_pattern()
{
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern* _msg = _internal_mutable_url_pattern();
    // @@protoc_insertion_point(field_mutable:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.url_pattern)
    return _msg;
}

// .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.Request request = 2;
inline bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::_internal_has_request() const
{
    return condition_case() == kRequest;
}
inline bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::has_request() const
{
    return _internal_has_request();
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::set_has_request()
{
    _impl_._oneof_case_[0] = kRequest;
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::clear_request()
{
    if (_internal_has_request()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.condition_.request_;
        }
        clear_has_condition();
    }
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::release_request()
{
    // @@protoc_insertion_point(field_release:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.request)
    if (_internal_has_request()) {
        clear_has_condition();
        ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request* temp = _impl_.condition_.request_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.condition_.request_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::_internal_request() const
{
    return _internal_has_request() ? *_impl_.condition_.request_
                                   : reinterpret_cast<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request&>(
                                       ::storage::_ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_default_instance_);
}
inline const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::request() const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.request)
    return _internal_request();
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::unsafe_arena_release_request()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.request)
    if (_internal_has_request()) {
        clear_has_condition();
        ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request* temp = _impl_.condition_.request_;
        _impl_.condition_.request_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::unsafe_arena_set_allocated_request(
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request* request)
{
    clear_condition();
    if (request) {
        set_has_request();
        _impl_.condition_.request_ = request;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.request)
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::_internal_mutable_request()
{
    if (!_internal_has_request()) {
        clear_condition();
        set_has_request();
        _impl_.condition_.request_ = CreateMaybeMessage<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request>(GetArenaForAllocation());
    }
    return _impl_.condition_.request_;
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::mutable_request()
{
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request* _msg = _internal_mutable_request();
    // @@protoc_insertion_point(field_mutable:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.request)
    return _msg;
}

// .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.RunningStatus running_status = 3;
inline bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::_internal_has_running_status() const
{
    return condition_case() == kRunningStatus;
}
inline bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::has_running_status() const
{
    return _internal_has_running_status();
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::set_has_running_status()
{
    _impl_._oneof_case_[0] = kRunningStatus;
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::clear_running_status()
{
    if (_internal_has_running_status()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.condition_.running_status_;
        }
        clear_has_condition();
    }
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::release_running_status()
{
    // @@protoc_insertion_point(field_release:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.running_status)
    if (_internal_has_running_status()) {
        clear_has_condition();
        ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus* temp = _impl_.condition_.running_status_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.condition_.running_status_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::_internal_running_status() const
{
    return _internal_has_running_status() ? *_impl_.condition_.running_status_
                                          : reinterpret_cast<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus&>(
                                              ::storage::_ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_default_instance_);
}
inline const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::running_status() const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.running_status)
    return _internal_running_status();
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::unsafe_arena_release_running_status()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.running_status)
    if (_internal_has_running_status()) {
        clear_has_condition();
        ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus* temp = _impl_.condition_.running_status_;
        _impl_.condition_.running_status_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::unsafe_arena_set_allocated_running_status(
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus* running_status)
{
    clear_condition();
    if (running_status) {
        set_has_running_status();
        _impl_.condition_.running_status_ = running_status;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.running_status)
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::_internal_mutable_running_status()
{
    if (!_internal_has_running_status()) {
        clear_condition();
        set_has_running_status();
        _impl_.condition_.running_status_
            = CreateMaybeMessage<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus>(GetArenaForAllocation());
    }
    return _impl_.condition_.running_status_;
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::mutable_running_status()
{
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus* _msg = _internal_mutable_running_status();
    // @@protoc_insertion_point(field_mutable:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.running_status)
    return _msg;
}

// .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.OrCondition or_condition = 4;
inline bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::_internal_has_or_condition() const
{
    return condition_case() == kOrCondition;
}
inline bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::has_or_condition() const
{
    return _internal_has_or_condition();
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::set_has_or_condition()
{
    _impl_._oneof_case_[0] = kOrCondition;
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::clear_or_condition()
{
    if (_internal_has_or_condition()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.condition_.or_condition_;
        }
        clear_has_condition();
    }
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::release_or_condition()
{
    // @@protoc_insertion_point(field_release:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.or_condition)
    if (_internal_has_or_condition()) {
        clear_has_condition();
        ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition* temp = _impl_.condition_.or_condition_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.condition_.or_condition_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::_internal_or_condition() const
{
    return _internal_has_or_condition() ? *_impl_.condition_.or_condition_
                                        : reinterpret_cast<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition&>(
                                            ::storage::_ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition_default_instance_);
}
inline const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::or_condition() const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.or_condition)
    return _internal_or_condition();
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::unsafe_arena_release_or_condition()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.or_condition)
    if (_internal_has_or_condition()) {
        clear_has_condition();
        ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition* temp = _impl_.condition_.or_condition_;
        _impl_.condition_.or_condition_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::unsafe_arena_set_allocated_or_condition(
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition* or_condition)
{
    clear_condition();
    if (or_condition) {
        set_has_or_condition();
        _impl_.condition_.or_condition_ = or_condition;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.or_condition)
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::_internal_mutable_or_condition()
{
    if (!_internal_has_or_condition()) {
        clear_condition();
        set_has_or_condition();
        _impl_.condition_.or_condition_
            = CreateMaybeMessage<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition>(GetArenaForAllocation());
    }
    return _impl_.condition_.or_condition_;
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::mutable_or_condition()
{
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_OrCondition* _msg = _internal_mutable_or_condition();
    // @@protoc_insertion_point(field_mutable:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.or_condition)
    return _msg;
}

// .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.NotCondition not_condition = 5;
inline bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::_internal_has_not_condition() const
{
    return condition_case() == kNotCondition;
}
inline bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::has_not_condition() const
{
    return _internal_has_not_condition();
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::set_has_not_condition()
{
    _impl_._oneof_case_[0] = kNotCondition;
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::clear_not_condition()
{
    if (_internal_has_not_condition()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.condition_.not_condition_;
        }
        clear_has_condition();
    }
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::release_not_condition()
{
    // @@protoc_insertion_point(field_release:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.not_condition)
    if (_internal_has_not_condition()) {
        clear_has_condition();
        ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition* temp = _impl_.condition_.not_condition_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.condition_.not_condition_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::_internal_not_condition() const
{
    return _internal_has_not_condition() ? *_impl_.condition_.not_condition_
                                         : reinterpret_cast<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition&>(
                                             ::storage::_ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition_default_instance_);
}
inline const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::not_condition() const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.not_condition)
    return _internal_not_condition();
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::unsafe_arena_release_not_condition()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.not_condition)
    if (_internal_has_not_condition()) {
        clear_has_condition();
        ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition* temp = _impl_.condition_.not_condition_;
        _impl_.condition_.not_condition_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::unsafe_arena_set_allocated_not_condition(
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition* not_condition)
{
    clear_condition();
    if (not_condition) {
        set_has_not_condition();
        _impl_.condition_.not_condition_ = not_condition;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.not_condition)
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::_internal_mutable_not_condition()
{
    if (!_internal_has_not_condition()) {
        clear_condition();
        set_has_not_condition();
        _impl_.condition_.not_condition_
            = CreateMaybeMessage<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition>(GetArenaForAllocation());
    }
    return _impl_.condition_.not_condition_;
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::mutable_not_condition()
{
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_NotCondition* _msg = _internal_mutable_not_condition();
    // @@protoc_insertion_point(field_mutable:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition.not_condition)
    return _msg;
}

inline bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::has_condition() const
{
    return condition_case() != CONDITION_NOT_SET;
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::clear_has_condition()
{
    _impl_._oneof_case_[0] = CONDITION_NOT_SET;
}
inline ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::ConditionCase
ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::condition_case() const
{
    return ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition::ConditionCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource

// -------------------------------------------------------------------

// ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource

// -------------------------------------------------------------------

// ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource

// -------------------------------------------------------------------

// ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource

// optional string cache_name = 1;
inline bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource::_internal_has_cache_name() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource::has_cache_name() const
{
    return _internal_has_cache_name();
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource::clear_cache_name()
{
    _impl_.cache_name_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource::cache_name() const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.CacheSource.cache_name)
    return _internal_cache_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE void ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource::set_cache_name(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.cache_name_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.CacheSource.cache_name)
}
inline std::string* ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource::mutable_cache_name()
{
    std::string* _s = _internal_mutable_cache_name();
    // @@protoc_insertion_point(field_mutable:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.CacheSource.cache_name)
    return _s;
}
inline const std::string& ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource::_internal_cache_name() const
{
    return _impl_.cache_name_.Get();
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource::_internal_set_cache_name(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.cache_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource::_internal_mutable_cache_name()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.cache_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource::release_cache_name()
{
    // @@protoc_insertion_point(field_release:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.CacheSource.cache_name)
    if (!_internal_has_cache_name()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.cache_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.cache_name_.IsDefault()) {
        _impl_.cache_name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource::set_allocated_cache_name(std::string* cache_name)
{
    if (cache_name != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.cache_name_.SetAllocated(cache_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.cache_name_.IsDefault()) {
        _impl_.cache_name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.CacheSource.cache_name)
}

// -------------------------------------------------------------------

// ServiceWorkerRegistrationData_RouterRules_RuleV1_Source

// .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.NetworkSource network_source = 1;
inline bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::_internal_has_network_source() const
{
    return source_case() == kNetworkSource;
}
inline bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::has_network_source() const
{
    return _internal_has_network_source();
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::set_has_network_source()
{
    _impl_._oneof_case_[0] = kNetworkSource;
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::clear_network_source()
{
    if (_internal_has_network_source()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.source_.network_source_;
        }
        clear_has_source();
    }
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::release_network_source()
{
    // @@protoc_insertion_point(field_release:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.network_source)
    if (_internal_has_network_source()) {
        clear_has_source();
        ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource* temp = _impl_.source_.network_source_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.source_.network_source_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::_internal_network_source() const
{
    return _internal_has_network_source() ? *_impl_.source_.network_source_
                                          : reinterpret_cast<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource&>(
                                              ::storage::_ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource_default_instance_);
}
inline const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::network_source() const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.network_source)
    return _internal_network_source();
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::unsafe_arena_release_network_source()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.network_source)
    if (_internal_has_network_source()) {
        clear_has_source();
        ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource* temp = _impl_.source_.network_source_;
        _impl_.source_.network_source_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::unsafe_arena_set_allocated_network_source(
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource* network_source)
{
    clear_source();
    if (network_source) {
        set_has_network_source();
        _impl_.source_.network_source_ = network_source;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.network_source)
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::_internal_mutable_network_source()
{
    if (!_internal_has_network_source()) {
        clear_source();
        set_has_network_source();
        _impl_.source_.network_source_
            = CreateMaybeMessage<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource>(GetArenaForAllocation());
    }
    return _impl_.source_.network_source_;
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::mutable_network_source()
{
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_NetworkSource* _msg = _internal_mutable_network_source();
    // @@protoc_insertion_point(field_mutable:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.network_source)
    return _msg;
}

// .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.RaceSource race_source = 2;
inline bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::_internal_has_race_source() const
{
    return source_case() == kRaceSource;
}
inline bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::has_race_source() const
{
    return _internal_has_race_source();
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::set_has_race_source()
{
    _impl_._oneof_case_[0] = kRaceSource;
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::clear_race_source()
{
    if (_internal_has_race_source()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.source_.race_source_;
        }
        clear_has_source();
    }
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::release_race_source()
{
    // @@protoc_insertion_point(field_release:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.race_source)
    if (_internal_has_race_source()) {
        clear_has_source();
        ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource* temp = _impl_.source_.race_source_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.source_.race_source_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::_internal_race_source() const
{
    return _internal_has_race_source() ? *_impl_.source_.race_source_
                                       : reinterpret_cast<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource&>(
                                           ::storage::_ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource_default_instance_);
}
inline const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::race_source() const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.race_source)
    return _internal_race_source();
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::unsafe_arena_release_race_source()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.race_source)
    if (_internal_has_race_source()) {
        clear_has_source();
        ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource* temp = _impl_.source_.race_source_;
        _impl_.source_.race_source_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::unsafe_arena_set_allocated_race_source(
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource* race_source)
{
    clear_source();
    if (race_source) {
        set_has_race_source();
        _impl_.source_.race_source_ = race_source;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.race_source)
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::_internal_mutable_race_source()
{
    if (!_internal_has_race_source()) {
        clear_source();
        set_has_race_source();
        _impl_.source_.race_source_
            = CreateMaybeMessage<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource>(GetArenaForAllocation());
    }
    return _impl_.source_.race_source_;
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::mutable_race_source()
{
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_RaceSource* _msg = _internal_mutable_race_source();
    // @@protoc_insertion_point(field_mutable:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.race_source)
    return _msg;
}

// .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.FetchEventSource fetch_event_source = 3;
inline bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::_internal_has_fetch_event_source() const
{
    return source_case() == kFetchEventSource;
}
inline bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::has_fetch_event_source() const
{
    return _internal_has_fetch_event_source();
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::set_has_fetch_event_source()
{
    _impl_._oneof_case_[0] = kFetchEventSource;
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::clear_fetch_event_source()
{
    if (_internal_has_fetch_event_source()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.source_.fetch_event_source_;
        }
        clear_has_source();
    }
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::release_fetch_event_source()
{
    // @@protoc_insertion_point(field_release:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.fetch_event_source)
    if (_internal_has_fetch_event_source()) {
        clear_has_source();
        ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource* temp = _impl_.source_.fetch_event_source_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.source_.fetch_event_source_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::_internal_fetch_event_source() const
{
    return _internal_has_fetch_event_source() ? *_impl_.source_.fetch_event_source_
                                              : reinterpret_cast<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource&>(
                                                  ::storage::_ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource_default_instance_);
}
inline const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::fetch_event_source() const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.fetch_event_source)
    return _internal_fetch_event_source();
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::unsafe_arena_release_fetch_event_source()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.fetch_event_source)
    if (_internal_has_fetch_event_source()) {
        clear_has_source();
        ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource* temp = _impl_.source_.fetch_event_source_;
        _impl_.source_.fetch_event_source_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::unsafe_arena_set_allocated_fetch_event_source(
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource* fetch_event_source)
{
    clear_source();
    if (fetch_event_source) {
        set_has_fetch_event_source();
        _impl_.source_.fetch_event_source_ = fetch_event_source;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.fetch_event_source)
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::_internal_mutable_fetch_event_source()
{
    if (!_internal_has_fetch_event_source()) {
        clear_source();
        set_has_fetch_event_source();
        _impl_.source_.fetch_event_source_
            = CreateMaybeMessage<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource>(GetArenaForAllocation());
    }
    return _impl_.source_.fetch_event_source_;
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::mutable_fetch_event_source()
{
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_FetchEventSource* _msg = _internal_mutable_fetch_event_source();
    // @@protoc_insertion_point(field_mutable:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.fetch_event_source)
    return _msg;
}

// .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.CacheSource cache_source = 4;
inline bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::_internal_has_cache_source() const
{
    return source_case() == kCacheSource;
}
inline bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::has_cache_source() const
{
    return _internal_has_cache_source();
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::set_has_cache_source()
{
    _impl_._oneof_case_[0] = kCacheSource;
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::clear_cache_source()
{
    if (_internal_has_cache_source()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.source_.cache_source_;
        }
        clear_has_source();
    }
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::release_cache_source()
{
    // @@protoc_insertion_point(field_release:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.cache_source)
    if (_internal_has_cache_source()) {
        clear_has_source();
        ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource* temp = _impl_.source_.cache_source_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.source_.cache_source_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::_internal_cache_source() const
{
    return _internal_has_cache_source() ? *_impl_.source_.cache_source_
                                        : reinterpret_cast<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource&>(
                                            ::storage::_ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource_default_instance_);
}
inline const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource&
ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::cache_source() const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.cache_source)
    return _internal_cache_source();
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::unsafe_arena_release_cache_source()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.cache_source)
    if (_internal_has_cache_source()) {
        clear_has_source();
        ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource* temp = _impl_.source_.cache_source_;
        _impl_.source_.cache_source_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::unsafe_arena_set_allocated_cache_source(
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource* cache_source)
{
    clear_source();
    if (cache_source) {
        set_has_cache_source();
        _impl_.source_.cache_source_ = cache_source;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.cache_source)
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::_internal_mutable_cache_source()
{
    if (!_internal_has_cache_source()) {
        clear_source();
        set_has_cache_source();
        _impl_.source_.cache_source_
            = CreateMaybeMessage<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource>(GetArenaForAllocation());
    }
    return _impl_.source_.cache_source_;
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource*
ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::mutable_cache_source()
{
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source_CacheSource* _msg = _internal_mutable_cache_source();
    // @@protoc_insertion_point(field_mutable:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source.cache_source)
    return _msg;
}

inline bool ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::has_source() const
{
    return source_case() != SOURCE_NOT_SET;
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::clear_has_source()
{
    _impl_._oneof_case_[0] = SOURCE_NOT_SET;
}
inline ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::SourceCase ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::source_case() const
{
    return ServiceWorkerRegistrationData_RouterRules_RuleV1_Source::SourceCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ServiceWorkerRegistrationData_RouterRules_RuleV1

// repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Condition condition = 1;
inline int ServiceWorkerRegistrationData_RouterRules_RuleV1::_internal_condition_size() const
{
    return _impl_.condition_.size();
}
inline int ServiceWorkerRegistrationData_RouterRules_RuleV1::condition_size() const
{
    return _internal_condition_size();
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1::clear_condition()
{
    _impl_.condition_.Clear();
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition* ServiceWorkerRegistrationData_RouterRules_RuleV1::mutable_condition(int index)
{
    // @@protoc_insertion_point(field_mutable:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.condition)
    return _impl_.condition_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition>*
ServiceWorkerRegistrationData_RouterRules_RuleV1::mutable_condition()
{
    // @@protoc_insertion_point(field_mutable_list:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.condition)
    return &_impl_.condition_;
}
inline const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition& ServiceWorkerRegistrationData_RouterRules_RuleV1::_internal_condition(
    int index) const
{
    return _impl_.condition_.Get(index);
}
inline const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition& ServiceWorkerRegistrationData_RouterRules_RuleV1::condition(int index) const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.condition)
    return _internal_condition(index);
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition* ServiceWorkerRegistrationData_RouterRules_RuleV1::_internal_add_condition()
{
    return _impl_.condition_.Add();
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition* ServiceWorkerRegistrationData_RouterRules_RuleV1::add_condition()
{
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition* _add = _internal_add_condition();
    // @@protoc_insertion_point(field_add:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.condition)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition>&
ServiceWorkerRegistrationData_RouterRules_RuleV1::condition() const
{
    // @@protoc_insertion_point(field_list:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.condition)
    return _impl_.condition_;
}

// repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.Source source = 2;
inline int ServiceWorkerRegistrationData_RouterRules_RuleV1::_internal_source_size() const
{
    return _impl_.source_.size();
}
inline int ServiceWorkerRegistrationData_RouterRules_RuleV1::source_size() const
{
    return _internal_source_size();
}
inline void ServiceWorkerRegistrationData_RouterRules_RuleV1::clear_source()
{
    _impl_.source_.Clear();
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source* ServiceWorkerRegistrationData_RouterRules_RuleV1::mutable_source(int index)
{
    // @@protoc_insertion_point(field_mutable:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.source)
    return _impl_.source_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source>*
ServiceWorkerRegistrationData_RouterRules_RuleV1::mutable_source()
{
    // @@protoc_insertion_point(field_mutable_list:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.source)
    return &_impl_.source_;
}
inline const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source& ServiceWorkerRegistrationData_RouterRules_RuleV1::_internal_source(
    int index) const
{
    return _impl_.source_.Get(index);
}
inline const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source& ServiceWorkerRegistrationData_RouterRules_RuleV1::source(int index) const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.source)
    return _internal_source(index);
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source* ServiceWorkerRegistrationData_RouterRules_RuleV1::_internal_add_source()
{
    return _impl_.source_.Add();
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source* ServiceWorkerRegistrationData_RouterRules_RuleV1::add_source()
{
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source* _add = _internal_add_source();
    // @@protoc_insertion_point(field_add:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.source)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Source>&
ServiceWorkerRegistrationData_RouterRules_RuleV1::source() const
{
    // @@protoc_insertion_point(field_list:storage.ServiceWorkerRegistrationData.RouterRules.RuleV1.source)
    return _impl_.source_;
}

// -------------------------------------------------------------------

// ServiceWorkerRegistrationData_RouterRules

// required int32 version = 1;
inline bool ServiceWorkerRegistrationData_RouterRules::_internal_has_version() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool ServiceWorkerRegistrationData_RouterRules::has_version() const
{
    return _internal_has_version();
}
inline void ServiceWorkerRegistrationData_RouterRules::clear_version()
{
    _impl_.version_ = 0;
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t ServiceWorkerRegistrationData_RouterRules::_internal_version() const
{
    return _impl_.version_;
}
inline int32_t ServiceWorkerRegistrationData_RouterRules::version() const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.RouterRules.version)
    return _internal_version();
}
inline void ServiceWorkerRegistrationData_RouterRules::_internal_set_version(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.version_ = value;
}
inline void ServiceWorkerRegistrationData_RouterRules::set_version(int32_t value)
{
    _internal_set_version(value);
    // @@protoc_insertion_point(field_set:storage.ServiceWorkerRegistrationData.RouterRules.version)
}

// repeated .storage.ServiceWorkerRegistrationData.RouterRules.RuleV1 v1 = 2;
inline int ServiceWorkerRegistrationData_RouterRules::_internal_v1_size() const
{
    return _impl_.v1_.size();
}
inline int ServiceWorkerRegistrationData_RouterRules::v1_size() const
{
    return _internal_v1_size();
}
inline void ServiceWorkerRegistrationData_RouterRules::clear_v1()
{
    _impl_.v1_.Clear();
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1* ServiceWorkerRegistrationData_RouterRules::mutable_v1(int index)
{
    // @@protoc_insertion_point(field_mutable:storage.ServiceWorkerRegistrationData.RouterRules.v1)
    return _impl_.v1_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1>*
ServiceWorkerRegistrationData_RouterRules::mutable_v1()
{
    // @@protoc_insertion_point(field_mutable_list:storage.ServiceWorkerRegistrationData.RouterRules.v1)
    return &_impl_.v1_;
}
inline const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1& ServiceWorkerRegistrationData_RouterRules::_internal_v1(int index) const
{
    return _impl_.v1_.Get(index);
}
inline const ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1& ServiceWorkerRegistrationData_RouterRules::v1(int index) const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.RouterRules.v1)
    return _internal_v1(index);
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1* ServiceWorkerRegistrationData_RouterRules::_internal_add_v1()
{
    return _impl_.v1_.Add();
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1* ServiceWorkerRegistrationData_RouterRules::add_v1()
{
    ::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1* _add = _internal_add_v1();
    // @@protoc_insertion_point(field_add:storage.ServiceWorkerRegistrationData.RouterRules.v1)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1>&
ServiceWorkerRegistrationData_RouterRules::v1() const
{
    // @@protoc_insertion_point(field_list:storage.ServiceWorkerRegistrationData.RouterRules.v1)
    return _impl_.v1_;
}

// -------------------------------------------------------------------

// ServiceWorkerRegistrationData

// required int64 registration_id = 1;
inline bool ServiceWorkerRegistrationData::_internal_has_registration_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
    return value;
}
inline bool ServiceWorkerRegistrationData::has_registration_id() const
{
    return _internal_has_registration_id();
}
inline void ServiceWorkerRegistrationData::clear_registration_id()
{
    _impl_.registration_id_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000100u;
}
inline int64_t ServiceWorkerRegistrationData::_internal_registration_id() const
{
    return _impl_.registration_id_;
}
inline int64_t ServiceWorkerRegistrationData::registration_id() const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.registration_id)
    return _internal_registration_id();
}
inline void ServiceWorkerRegistrationData::_internal_set_registration_id(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000100u;
    _impl_.registration_id_ = value;
}
inline void ServiceWorkerRegistrationData::set_registration_id(int64_t value)
{
    _internal_set_registration_id(value);
    // @@protoc_insertion_point(field_set:storage.ServiceWorkerRegistrationData.registration_id)
}

// required string scope_url = 2;
inline bool ServiceWorkerRegistrationData::_internal_has_scope_url() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool ServiceWorkerRegistrationData::has_scope_url() const
{
    return _internal_has_scope_url();
}
inline void ServiceWorkerRegistrationData::clear_scope_url()
{
    _impl_.scope_url_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ServiceWorkerRegistrationData::scope_url() const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.scope_url)
    return _internal_scope_url();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ServiceWorkerRegistrationData::set_scope_url(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.scope_url_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:storage.ServiceWorkerRegistrationData.scope_url)
}
inline std::string* ServiceWorkerRegistrationData::mutable_scope_url()
{
    std::string* _s = _internal_mutable_scope_url();
    // @@protoc_insertion_point(field_mutable:storage.ServiceWorkerRegistrationData.scope_url)
    return _s;
}
inline const std::string& ServiceWorkerRegistrationData::_internal_scope_url() const
{
    return _impl_.scope_url_.Get();
}
inline void ServiceWorkerRegistrationData::_internal_set_scope_url(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.scope_url_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceWorkerRegistrationData::_internal_mutable_scope_url()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.scope_url_.Mutable(GetArenaForAllocation());
}
inline std::string* ServiceWorkerRegistrationData::release_scope_url()
{
    // @@protoc_insertion_point(field_release:storage.ServiceWorkerRegistrationData.scope_url)
    if (!_internal_has_scope_url()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.scope_url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.scope_url_.IsDefault()) {
        _impl_.scope_url_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ServiceWorkerRegistrationData::set_allocated_scope_url(std::string* scope_url)
{
    if (scope_url != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.scope_url_.SetAllocated(scope_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.scope_url_.IsDefault()) {
        _impl_.scope_url_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:storage.ServiceWorkerRegistrationData.scope_url)
}

// required string script_url = 3;
inline bool ServiceWorkerRegistrationData::_internal_has_script_url() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool ServiceWorkerRegistrationData::has_script_url() const
{
    return _internal_has_script_url();
}
inline void ServiceWorkerRegistrationData::clear_script_url()
{
    _impl_.script_url_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ServiceWorkerRegistrationData::script_url() const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.script_url)
    return _internal_script_url();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ServiceWorkerRegistrationData::set_script_url(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.script_url_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:storage.ServiceWorkerRegistrationData.script_url)
}
inline std::string* ServiceWorkerRegistrationData::mutable_script_url()
{
    std::string* _s = _internal_mutable_script_url();
    // @@protoc_insertion_point(field_mutable:storage.ServiceWorkerRegistrationData.script_url)
    return _s;
}
inline const std::string& ServiceWorkerRegistrationData::_internal_script_url() const
{
    return _impl_.script_url_.Get();
}
inline void ServiceWorkerRegistrationData::_internal_set_script_url(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.script_url_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceWorkerRegistrationData::_internal_mutable_script_url()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.script_url_.Mutable(GetArenaForAllocation());
}
inline std::string* ServiceWorkerRegistrationData::release_script_url()
{
    // @@protoc_insertion_point(field_release:storage.ServiceWorkerRegistrationData.script_url)
    if (!_internal_has_script_url()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.script_url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.script_url_.IsDefault()) {
        _impl_.script_url_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ServiceWorkerRegistrationData::set_allocated_script_url(std::string* script_url)
{
    if (script_url != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.script_url_.SetAllocated(script_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.script_url_.IsDefault()) {
        _impl_.script_url_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:storage.ServiceWorkerRegistrationData.script_url)
}

// required int64 version_id = 4;
inline bool ServiceWorkerRegistrationData::_internal_has_version_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
    return value;
}
inline bool ServiceWorkerRegistrationData::has_version_id() const
{
    return _internal_has_version_id();
}
inline void ServiceWorkerRegistrationData::clear_version_id()
{
    _impl_.version_id_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000200u;
}
inline int64_t ServiceWorkerRegistrationData::_internal_version_id() const
{
    return _impl_.version_id_;
}
inline int64_t ServiceWorkerRegistrationData::version_id() const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.version_id)
    return _internal_version_id();
}
inline void ServiceWorkerRegistrationData::_internal_set_version_id(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000200u;
    _impl_.version_id_ = value;
}
inline void ServiceWorkerRegistrationData::set_version_id(int64_t value)
{
    _internal_set_version_id(value);
    // @@protoc_insertion_point(field_set:storage.ServiceWorkerRegistrationData.version_id)
}

// required bool is_active = 5;
inline bool ServiceWorkerRegistrationData::_internal_has_is_active() const
{
    bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
    return value;
}
inline bool ServiceWorkerRegistrationData::has_is_active() const
{
    return _internal_has_is_active();
}
inline void ServiceWorkerRegistrationData::clear_is_active()
{
    _impl_.is_active_ = false;
    _impl_._has_bits_[0] &= ~0x00004000u;
}
inline bool ServiceWorkerRegistrationData::_internal_is_active() const
{
    return _impl_.is_active_;
}
inline bool ServiceWorkerRegistrationData::is_active() const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.is_active)
    return _internal_is_active();
}
inline void ServiceWorkerRegistrationData::_internal_set_is_active(bool value)
{
    _impl_._has_bits_[0] |= 0x00004000u;
    _impl_.is_active_ = value;
}
inline void ServiceWorkerRegistrationData::set_is_active(bool value)
{
    _internal_set_is_active(value);
    // @@protoc_insertion_point(field_set:storage.ServiceWorkerRegistrationData.is_active)
}

// required bool has_fetch_handler = 6;
inline bool ServiceWorkerRegistrationData::_internal_has_has_fetch_handler() const
{
    bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
    return value;
}
inline bool ServiceWorkerRegistrationData::has_has_fetch_handler() const
{
    return _internal_has_has_fetch_handler();
}
inline void ServiceWorkerRegistrationData::clear_has_fetch_handler()
{
    _impl_.has_fetch_handler_ = false;
    _impl_._has_bits_[0] &= ~0x00008000u;
}
inline bool ServiceWorkerRegistrationData::_internal_has_fetch_handler() const
{
    return _impl_.has_fetch_handler_;
}
inline bool ServiceWorkerRegistrationData::has_fetch_handler() const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.has_fetch_handler)
    return _internal_has_fetch_handler();
}
inline void ServiceWorkerRegistrationData::_internal_set_has_fetch_handler(bool value)
{
    _impl_._has_bits_[0] |= 0x00008000u;
    _impl_.has_fetch_handler_ = value;
}
inline void ServiceWorkerRegistrationData::set_has_fetch_handler(bool value)
{
    _internal_set_has_fetch_handler(value);
    // @@protoc_insertion_point(field_set:storage.ServiceWorkerRegistrationData.has_fetch_handler)
}

// optional .storage.ServiceWorkerRegistrationData.FetchHandlerSkippableType fetch_handler_skippable_type = 22;
inline bool ServiceWorkerRegistrationData::_internal_has_fetch_handler_skippable_type() const
{
    bool value = (_impl_._has_bits_[0] & 0x00400000u) != 0;
    return value;
}
inline bool ServiceWorkerRegistrationData::has_fetch_handler_skippable_type() const
{
    return _internal_has_fetch_handler_skippable_type();
}
inline void ServiceWorkerRegistrationData::clear_fetch_handler_skippable_type()
{
    _impl_.fetch_handler_skippable_type_ = 1;
    _impl_._has_bits_[0] &= ~0x00400000u;
}
inline ::storage::ServiceWorkerRegistrationData_FetchHandlerSkippableType ServiceWorkerRegistrationData::_internal_fetch_handler_skippable_type() const
{
    return static_cast<::storage::ServiceWorkerRegistrationData_FetchHandlerSkippableType>(_impl_.fetch_handler_skippable_type_);
}
inline ::storage::ServiceWorkerRegistrationData_FetchHandlerSkippableType ServiceWorkerRegistrationData::fetch_handler_skippable_type() const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.fetch_handler_skippable_type)
    return _internal_fetch_handler_skippable_type();
}
inline void ServiceWorkerRegistrationData::_internal_set_fetch_handler_skippable_type(::storage::ServiceWorkerRegistrationData_FetchHandlerSkippableType value)
{
    assert(::storage::ServiceWorkerRegistrationData_FetchHandlerSkippableType_IsValid(value));
    _impl_._has_bits_[0] |= 0x00400000u;
    _impl_.fetch_handler_skippable_type_ = value;
}
inline void ServiceWorkerRegistrationData::set_fetch_handler_skippable_type(::storage::ServiceWorkerRegistrationData_FetchHandlerSkippableType value)
{
    _internal_set_fetch_handler_skippable_type(value);
    // @@protoc_insertion_point(field_set:storage.ServiceWorkerRegistrationData.fetch_handler_skippable_type)
}

// required int64 last_update_check_time = 7;
inline bool ServiceWorkerRegistrationData::_internal_has_last_update_check_time() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
    return value;
}
inline bool ServiceWorkerRegistrationData::has_last_update_check_time() const
{
    return _internal_has_last_update_check_time();
}
inline void ServiceWorkerRegistrationData::clear_last_update_check_time()
{
    _impl_.last_update_check_time_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000400u;
}
inline int64_t ServiceWorkerRegistrationData::_internal_last_update_check_time() const
{
    return _impl_.last_update_check_time_;
}
inline int64_t ServiceWorkerRegistrationData::last_update_check_time() const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.last_update_check_time)
    return _internal_last_update_check_time();
}
inline void ServiceWorkerRegistrationData::_internal_set_last_update_check_time(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000400u;
    _impl_.last_update_check_time_ = value;
}
inline void ServiceWorkerRegistrationData::set_last_update_check_time(int64_t value)
{
    _internal_set_last_update_check_time(value);
    // @@protoc_insertion_point(field_set:storage.ServiceWorkerRegistrationData.last_update_check_time)
}

// optional uint64 resources_total_size_bytes = 8;
inline bool ServiceWorkerRegistrationData::_internal_has_resources_total_size_bytes() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
    return value;
}
inline bool ServiceWorkerRegistrationData::has_resources_total_size_bytes() const
{
    return _internal_has_resources_total_size_bytes();
}
inline void ServiceWorkerRegistrationData::clear_resources_total_size_bytes()
{
    _impl_.resources_total_size_bytes_ = uint64_t { 0u };
    _impl_._has_bits_[0] &= ~0x00000800u;
}
inline uint64_t ServiceWorkerRegistrationData::_internal_resources_total_size_bytes() const
{
    return _impl_.resources_total_size_bytes_;
}
inline uint64_t ServiceWorkerRegistrationData::resources_total_size_bytes() const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.resources_total_size_bytes)
    return _internal_resources_total_size_bytes();
}
inline void ServiceWorkerRegistrationData::_internal_set_resources_total_size_bytes(uint64_t value)
{
    _impl_._has_bits_[0] |= 0x00000800u;
    _impl_.resources_total_size_bytes_ = value;
}
inline void ServiceWorkerRegistrationData::set_resources_total_size_bytes(uint64_t value)
{
    _internal_set_resources_total_size_bytes(value);
    // @@protoc_insertion_point(field_set:storage.ServiceWorkerRegistrationData.resources_total_size_bytes)
}

// optional .storage.ServiceWorkerOriginTrialInfo origin_trial_tokens = 11;
inline bool ServiceWorkerRegistrationData::_internal_has_origin_trial_tokens() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.origin_trial_tokens_ != nullptr);
    return value;
}
inline bool ServiceWorkerRegistrationData::has_origin_trial_tokens() const
{
    return _internal_has_origin_trial_tokens();
}
inline void ServiceWorkerRegistrationData::clear_origin_trial_tokens()
{
    if (_impl_.origin_trial_tokens_ != nullptr)
        _impl_.origin_trial_tokens_->Clear();
    _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::storage::ServiceWorkerOriginTrialInfo& ServiceWorkerRegistrationData::_internal_origin_trial_tokens() const
{
    const ::storage::ServiceWorkerOriginTrialInfo* p = _impl_.origin_trial_tokens_;
    return p != nullptr ? *p : reinterpret_cast<const ::storage::ServiceWorkerOriginTrialInfo&>(::storage::_ServiceWorkerOriginTrialInfo_default_instance_);
}
inline const ::storage::ServiceWorkerOriginTrialInfo& ServiceWorkerRegistrationData::origin_trial_tokens() const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.origin_trial_tokens)
    return _internal_origin_trial_tokens();
}
inline void ServiceWorkerRegistrationData::unsafe_arena_set_allocated_origin_trial_tokens(::storage::ServiceWorkerOriginTrialInfo* origin_trial_tokens)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.origin_trial_tokens_);
    }
    _impl_.origin_trial_tokens_ = origin_trial_tokens;
    if (origin_trial_tokens) {
        _impl_._has_bits_[0] |= 0x00000010u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000010u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:storage.ServiceWorkerRegistrationData.origin_trial_tokens)
}
inline ::storage::ServiceWorkerOriginTrialInfo* ServiceWorkerRegistrationData::release_origin_trial_tokens()
{
    _impl_._has_bits_[0] &= ~0x00000010u;
    ::storage::ServiceWorkerOriginTrialInfo* temp = _impl_.origin_trial_tokens_;
    _impl_.origin_trial_tokens_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::storage::ServiceWorkerOriginTrialInfo* ServiceWorkerRegistrationData::unsafe_arena_release_origin_trial_tokens()
{
    // @@protoc_insertion_point(field_release:storage.ServiceWorkerRegistrationData.origin_trial_tokens)
    _impl_._has_bits_[0] &= ~0x00000010u;
    ::storage::ServiceWorkerOriginTrialInfo* temp = _impl_.origin_trial_tokens_;
    _impl_.origin_trial_tokens_ = nullptr;
    return temp;
}
inline ::storage::ServiceWorkerOriginTrialInfo* ServiceWorkerRegistrationData::_internal_mutable_origin_trial_tokens()
{
    _impl_._has_bits_[0] |= 0x00000010u;
    if (_impl_.origin_trial_tokens_ == nullptr) {
        auto* p = CreateMaybeMessage<::storage::ServiceWorkerOriginTrialInfo>(GetArenaForAllocation());
        _impl_.origin_trial_tokens_ = p;
    }
    return _impl_.origin_trial_tokens_;
}
inline ::storage::ServiceWorkerOriginTrialInfo* ServiceWorkerRegistrationData::mutable_origin_trial_tokens()
{
    ::storage::ServiceWorkerOriginTrialInfo* _msg = _internal_mutable_origin_trial_tokens();
    // @@protoc_insertion_point(field_mutable:storage.ServiceWorkerRegistrationData.origin_trial_tokens)
    return _msg;
}
inline void ServiceWorkerRegistrationData::set_allocated_origin_trial_tokens(::storage::ServiceWorkerOriginTrialInfo* origin_trial_tokens)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.origin_trial_tokens_;
    }
    if (origin_trial_tokens) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(origin_trial_tokens);
        if (message_arena != submessage_arena) {
            origin_trial_tokens = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, origin_trial_tokens, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000010u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000010u;
    }
    _impl_.origin_trial_tokens_ = origin_trial_tokens;
    // @@protoc_insertion_point(field_set_allocated:storage.ServiceWorkerRegistrationData.origin_trial_tokens)
}

// optional .storage.ServiceWorkerNavigationPreloadState navigation_preload_state = 12;
inline bool ServiceWorkerRegistrationData::_internal_has_navigation_preload_state() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.navigation_preload_state_ != nullptr);
    return value;
}
inline bool ServiceWorkerRegistrationData::has_navigation_preload_state() const
{
    return _internal_has_navigation_preload_state();
}
inline void ServiceWorkerRegistrationData::clear_navigation_preload_state()
{
    if (_impl_.navigation_preload_state_ != nullptr)
        _impl_.navigation_preload_state_->Clear();
    _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::storage::ServiceWorkerNavigationPreloadState& ServiceWorkerRegistrationData::_internal_navigation_preload_state() const
{
    const ::storage::ServiceWorkerNavigationPreloadState* p = _impl_.navigation_preload_state_;
    return p != nullptr
        ? *p
        : reinterpret_cast<const ::storage::ServiceWorkerNavigationPreloadState&>(::storage::_ServiceWorkerNavigationPreloadState_default_instance_);
}
inline const ::storage::ServiceWorkerNavigationPreloadState& ServiceWorkerRegistrationData::navigation_preload_state() const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.navigation_preload_state)
    return _internal_navigation_preload_state();
}
inline void ServiceWorkerRegistrationData::unsafe_arena_set_allocated_navigation_preload_state(
    ::storage::ServiceWorkerNavigationPreloadState* navigation_preload_state)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.navigation_preload_state_);
    }
    _impl_.navigation_preload_state_ = navigation_preload_state;
    if (navigation_preload_state) {
        _impl_._has_bits_[0] |= 0x00000020u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000020u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:storage.ServiceWorkerRegistrationData.navigation_preload_state)
}
inline ::storage::ServiceWorkerNavigationPreloadState* ServiceWorkerRegistrationData::release_navigation_preload_state()
{
    _impl_._has_bits_[0] &= ~0x00000020u;
    ::storage::ServiceWorkerNavigationPreloadState* temp = _impl_.navigation_preload_state_;
    _impl_.navigation_preload_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::storage::ServiceWorkerNavigationPreloadState* ServiceWorkerRegistrationData::unsafe_arena_release_navigation_preload_state()
{
    // @@protoc_insertion_point(field_release:storage.ServiceWorkerRegistrationData.navigation_preload_state)
    _impl_._has_bits_[0] &= ~0x00000020u;
    ::storage::ServiceWorkerNavigationPreloadState* temp = _impl_.navigation_preload_state_;
    _impl_.navigation_preload_state_ = nullptr;
    return temp;
}
inline ::storage::ServiceWorkerNavigationPreloadState* ServiceWorkerRegistrationData::_internal_mutable_navigation_preload_state()
{
    _impl_._has_bits_[0] |= 0x00000020u;
    if (_impl_.navigation_preload_state_ == nullptr) {
        auto* p = CreateMaybeMessage<::storage::ServiceWorkerNavigationPreloadState>(GetArenaForAllocation());
        _impl_.navigation_preload_state_ = p;
    }
    return _impl_.navigation_preload_state_;
}
inline ::storage::ServiceWorkerNavigationPreloadState* ServiceWorkerRegistrationData::mutable_navigation_preload_state()
{
    ::storage::ServiceWorkerNavigationPreloadState* _msg = _internal_mutable_navigation_preload_state();
    // @@protoc_insertion_point(field_mutable:storage.ServiceWorkerRegistrationData.navigation_preload_state)
    return _msg;
}
inline void ServiceWorkerRegistrationData::set_allocated_navigation_preload_state(::storage::ServiceWorkerNavigationPreloadState* navigation_preload_state)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.navigation_preload_state_;
    }
    if (navigation_preload_state) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(navigation_preload_state);
        if (message_arena != submessage_arena) {
            navigation_preload_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, navigation_preload_state, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000020u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000020u;
    }
    _impl_.navigation_preload_state_ = navigation_preload_state;
    // @@protoc_insertion_point(field_set_allocated:storage.ServiceWorkerRegistrationData.navigation_preload_state)
}

// repeated uint32 used_features = 13;
inline int ServiceWorkerRegistrationData::_internal_used_features_size() const
{
    return _impl_.used_features_.size();
}
inline int ServiceWorkerRegistrationData::used_features_size() const
{
    return _internal_used_features_size();
}
inline void ServiceWorkerRegistrationData::clear_used_features()
{
    _impl_.used_features_.Clear();
}
inline uint32_t ServiceWorkerRegistrationData::_internal_used_features(int index) const
{
    return _impl_.used_features_.Get(index);
}
inline uint32_t ServiceWorkerRegistrationData::used_features(int index) const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.used_features)
    return _internal_used_features(index);
}
inline void ServiceWorkerRegistrationData::set_used_features(int index, uint32_t value)
{
    _impl_.used_features_.Set(index, value);
    // @@protoc_insertion_point(field_set:storage.ServiceWorkerRegistrationData.used_features)
}
inline void ServiceWorkerRegistrationData::_internal_add_used_features(uint32_t value)
{
    _impl_.used_features_.Add(value);
}
inline void ServiceWorkerRegistrationData::add_used_features(uint32_t value)
{
    _internal_add_used_features(value);
    // @@protoc_insertion_point(field_add:storage.ServiceWorkerRegistrationData.used_features)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t>& ServiceWorkerRegistrationData::_internal_used_features() const
{
    return _impl_.used_features_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t>& ServiceWorkerRegistrationData::used_features() const
{
    // @@protoc_insertion_point(field_list:storage.ServiceWorkerRegistrationData.used_features)
    return _internal_used_features();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t>* ServiceWorkerRegistrationData::_internal_mutable_used_features()
{
    return &_impl_.used_features_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t>* ServiceWorkerRegistrationData::mutable_used_features()
{
    // @@protoc_insertion_point(field_mutable_list:storage.ServiceWorkerRegistrationData.used_features)
    return _internal_mutable_used_features();
}

// optional .storage.ServiceWorkerRegistrationData.ServiceWorkerUpdateViaCacheType update_via_cache = 14 [default = IMPORTS];
inline bool ServiceWorkerRegistrationData::_internal_has_update_via_cache() const
{
    bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
    return value;
}
inline bool ServiceWorkerRegistrationData::has_update_via_cache() const
{
    return _internal_has_update_via_cache();
}
inline void ServiceWorkerRegistrationData::clear_update_via_cache()
{
    _impl_.update_via_cache_ = 0;
    _impl_._has_bits_[0] &= ~0x00001000u;
}
inline ::storage::ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType ServiceWorkerRegistrationData::_internal_update_via_cache() const
{
    return static_cast<::storage::ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType>(_impl_.update_via_cache_);
}
inline ::storage::ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType ServiceWorkerRegistrationData::update_via_cache() const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.update_via_cache)
    return _internal_update_via_cache();
}
inline void ServiceWorkerRegistrationData::_internal_set_update_via_cache(::storage::ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType value)
{
    assert(::storage::ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType_IsValid(value));
    _impl_._has_bits_[0] |= 0x00001000u;
    _impl_.update_via_cache_ = value;
}
inline void ServiceWorkerRegistrationData::set_update_via_cache(::storage::ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType value)
{
    _internal_set_update_via_cache(value);
    // @@protoc_insertion_point(field_set:storage.ServiceWorkerRegistrationData.update_via_cache)
}

// optional .storage.ServiceWorkerRegistrationData.ServiceWorkerScriptType script_type = 15 [default = CLASSIC];
inline bool ServiceWorkerRegistrationData::_internal_has_script_type() const
{
    bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
    return value;
}
inline bool ServiceWorkerRegistrationData::has_script_type() const
{
    return _internal_has_script_type();
}
inline void ServiceWorkerRegistrationData::clear_script_type()
{
    _impl_.script_type_ = 0;
    _impl_._has_bits_[0] &= ~0x00002000u;
}
inline ::storage::ServiceWorkerRegistrationData_ServiceWorkerScriptType ServiceWorkerRegistrationData::_internal_script_type() const
{
    return static_cast<::storage::ServiceWorkerRegistrationData_ServiceWorkerScriptType>(_impl_.script_type_);
}
inline ::storage::ServiceWorkerRegistrationData_ServiceWorkerScriptType ServiceWorkerRegistrationData::script_type() const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.script_type)
    return _internal_script_type();
}
inline void ServiceWorkerRegistrationData::_internal_set_script_type(::storage::ServiceWorkerRegistrationData_ServiceWorkerScriptType value)
{
    assert(::storage::ServiceWorkerRegistrationData_ServiceWorkerScriptType_IsValid(value));
    _impl_._has_bits_[0] |= 0x00002000u;
    _impl_.script_type_ = value;
}
inline void ServiceWorkerRegistrationData::set_script_type(::storage::ServiceWorkerRegistrationData_ServiceWorkerScriptType value)
{
    _internal_set_script_type(value);
    // @@protoc_insertion_point(field_set:storage.ServiceWorkerRegistrationData.script_type)
}

// optional int64 script_response_time = 16;
inline bool ServiceWorkerRegistrationData::_internal_has_script_response_time() const
{
    bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
    return value;
}
inline bool ServiceWorkerRegistrationData::has_script_response_time() const
{
    return _internal_has_script_response_time();
}
inline void ServiceWorkerRegistrationData::clear_script_response_time()
{
    _impl_.script_response_time_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00080000u;
}
inline int64_t ServiceWorkerRegistrationData::_internal_script_response_time() const
{
    return _impl_.script_response_time_;
}
inline int64_t ServiceWorkerRegistrationData::script_response_time() const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.script_response_time)
    return _internal_script_response_time();
}
inline void ServiceWorkerRegistrationData::_internal_set_script_response_time(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00080000u;
    _impl_.script_response_time_ = value;
}
inline void ServiceWorkerRegistrationData::set_script_response_time(int64_t value)
{
    _internal_set_script_response_time(value);
    // @@protoc_insertion_point(field_set:storage.ServiceWorkerRegistrationData.script_response_time)
}

// optional .storage.ServiceWorkerRegistrationData.CrossOriginEmbedderPolicyValue cross_origin_embedder_policy_value = 17 [default = NONE_OR_NOT_EXIST];
inline bool ServiceWorkerRegistrationData::_internal_has_cross_origin_embedder_policy_value() const
{
    bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
    return value;
}
inline bool ServiceWorkerRegistrationData::has_cross_origin_embedder_policy_value() const
{
    return _internal_has_cross_origin_embedder_policy_value();
}
inline void ServiceWorkerRegistrationData::clear_cross_origin_embedder_policy_value()
{
    _impl_.cross_origin_embedder_policy_value_ = 0;
    _impl_._has_bits_[0] &= ~0x00040000u;
}
inline ::storage::ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue
ServiceWorkerRegistrationData::_internal_cross_origin_embedder_policy_value() const
{
    return static_cast<::storage::ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue>(_impl_.cross_origin_embedder_policy_value_);
}
inline ::storage::ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue ServiceWorkerRegistrationData::cross_origin_embedder_policy_value() const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.cross_origin_embedder_policy_value)
    return _internal_cross_origin_embedder_policy_value();
}
inline void ServiceWorkerRegistrationData::_internal_set_cross_origin_embedder_policy_value(
    ::storage::ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue value)
{
    assert(::storage::ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue_IsValid(value));
    _impl_._has_bits_[0] |= 0x00040000u;
    _impl_.cross_origin_embedder_policy_value_ = value;
}
inline void ServiceWorkerRegistrationData::set_cross_origin_embedder_policy_value(::storage::ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue value)
{
    _internal_set_cross_origin_embedder_policy_value(value);
    // @@protoc_insertion_point(field_set:storage.ServiceWorkerRegistrationData.cross_origin_embedder_policy_value)
}

// optional string cross_origin_embedder_policy_reporting_endpoint = 18;
inline bool ServiceWorkerRegistrationData::_internal_has_cross_origin_embedder_policy_reporting_endpoint() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool ServiceWorkerRegistrationData::has_cross_origin_embedder_policy_reporting_endpoint() const
{
    return _internal_has_cross_origin_embedder_policy_reporting_endpoint();
}
inline void ServiceWorkerRegistrationData::clear_cross_origin_embedder_policy_reporting_endpoint()
{
    _impl_.cross_origin_embedder_policy_reporting_endpoint_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ServiceWorkerRegistrationData::cross_origin_embedder_policy_reporting_endpoint() const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.cross_origin_embedder_policy_reporting_endpoint)
    return _internal_cross_origin_embedder_policy_reporting_endpoint();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE void ServiceWorkerRegistrationData::set_cross_origin_embedder_policy_reporting_endpoint(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.cross_origin_embedder_policy_reporting_endpoint_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:storage.ServiceWorkerRegistrationData.cross_origin_embedder_policy_reporting_endpoint)
}
inline std::string* ServiceWorkerRegistrationData::mutable_cross_origin_embedder_policy_reporting_endpoint()
{
    std::string* _s = _internal_mutable_cross_origin_embedder_policy_reporting_endpoint();
    // @@protoc_insertion_point(field_mutable:storage.ServiceWorkerRegistrationData.cross_origin_embedder_policy_reporting_endpoint)
    return _s;
}
inline const std::string& ServiceWorkerRegistrationData::_internal_cross_origin_embedder_policy_reporting_endpoint() const
{
    return _impl_.cross_origin_embedder_policy_reporting_endpoint_.Get();
}
inline void ServiceWorkerRegistrationData::_internal_set_cross_origin_embedder_policy_reporting_endpoint(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.cross_origin_embedder_policy_reporting_endpoint_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceWorkerRegistrationData::_internal_mutable_cross_origin_embedder_policy_reporting_endpoint()
{
    _impl_._has_bits_[0] |= 0x00000004u;
    return _impl_.cross_origin_embedder_policy_reporting_endpoint_.Mutable(GetArenaForAllocation());
}
inline std::string* ServiceWorkerRegistrationData::release_cross_origin_embedder_policy_reporting_endpoint()
{
    // @@protoc_insertion_point(field_release:storage.ServiceWorkerRegistrationData.cross_origin_embedder_policy_reporting_endpoint)
    if (!_internal_has_cross_origin_embedder_policy_reporting_endpoint()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000004u;
    auto* p = _impl_.cross_origin_embedder_policy_reporting_endpoint_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.cross_origin_embedder_policy_reporting_endpoint_.IsDefault()) {
        _impl_.cross_origin_embedder_policy_reporting_endpoint_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ServiceWorkerRegistrationData::set_allocated_cross_origin_embedder_policy_reporting_endpoint(
    std::string* cross_origin_embedder_policy_reporting_endpoint)
{
    if (cross_origin_embedder_policy_reporting_endpoint != nullptr) {
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    _impl_.cross_origin_embedder_policy_reporting_endpoint_.SetAllocated(cross_origin_embedder_policy_reporting_endpoint, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.cross_origin_embedder_policy_reporting_endpoint_.IsDefault()) {
        _impl_.cross_origin_embedder_policy_reporting_endpoint_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:storage.ServiceWorkerRegistrationData.cross_origin_embedder_policy_reporting_endpoint)
}

// optional .storage.ServiceWorkerRegistrationData.CrossOriginEmbedderPolicyValue cross_origin_embedder_policy_report_only_value = 19 [default = NONE_OR_NOT_EXIST];
inline bool ServiceWorkerRegistrationData::_internal_has_cross_origin_embedder_policy_report_only_value() const
{
    bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
    return value;
}
inline bool ServiceWorkerRegistrationData::has_cross_origin_embedder_policy_report_only_value() const
{
    return _internal_has_cross_origin_embedder_policy_report_only_value();
}
inline void ServiceWorkerRegistrationData::clear_cross_origin_embedder_policy_report_only_value()
{
    _impl_.cross_origin_embedder_policy_report_only_value_ = 0;
    _impl_._has_bits_[0] &= ~0x00100000u;
}
inline ::storage::ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue
ServiceWorkerRegistrationData::_internal_cross_origin_embedder_policy_report_only_value() const
{
    return static_cast<::storage::ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue>(_impl_.cross_origin_embedder_policy_report_only_value_);
}
inline ::storage::ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue
ServiceWorkerRegistrationData::cross_origin_embedder_policy_report_only_value() const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.cross_origin_embedder_policy_report_only_value)
    return _internal_cross_origin_embedder_policy_report_only_value();
}
inline void ServiceWorkerRegistrationData::_internal_set_cross_origin_embedder_policy_report_only_value(
    ::storage::ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue value)
{
    assert(::storage::ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue_IsValid(value));
    _impl_._has_bits_[0] |= 0x00100000u;
    _impl_.cross_origin_embedder_policy_report_only_value_ = value;
}
inline void ServiceWorkerRegistrationData::set_cross_origin_embedder_policy_report_only_value(
    ::storage::ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue value)
{
    _internal_set_cross_origin_embedder_policy_report_only_value(value);
    // @@protoc_insertion_point(field_set:storage.ServiceWorkerRegistrationData.cross_origin_embedder_policy_report_only_value)
}

// optional string cross_origin_embedder_policy_report_only_reporting_endpoint = 20;
inline bool ServiceWorkerRegistrationData::_internal_has_cross_origin_embedder_policy_report_only_reporting_endpoint() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    return value;
}
inline bool ServiceWorkerRegistrationData::has_cross_origin_embedder_policy_report_only_reporting_endpoint() const
{
    return _internal_has_cross_origin_embedder_policy_report_only_reporting_endpoint();
}
inline void ServiceWorkerRegistrationData::clear_cross_origin_embedder_policy_report_only_reporting_endpoint()
{
    _impl_.cross_origin_embedder_policy_report_only_reporting_endpoint_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ServiceWorkerRegistrationData::cross_origin_embedder_policy_report_only_reporting_endpoint() const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.cross_origin_embedder_policy_report_only_reporting_endpoint)
    return _internal_cross_origin_embedder_policy_report_only_reporting_endpoint();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE void ServiceWorkerRegistrationData::set_cross_origin_embedder_policy_report_only_reporting_endpoint(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.cross_origin_embedder_policy_report_only_reporting_endpoint_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:storage.ServiceWorkerRegistrationData.cross_origin_embedder_policy_report_only_reporting_endpoint)
}
inline std::string* ServiceWorkerRegistrationData::mutable_cross_origin_embedder_policy_report_only_reporting_endpoint()
{
    std::string* _s = _internal_mutable_cross_origin_embedder_policy_report_only_reporting_endpoint();
    // @@protoc_insertion_point(field_mutable:storage.ServiceWorkerRegistrationData.cross_origin_embedder_policy_report_only_reporting_endpoint)
    return _s;
}
inline const std::string& ServiceWorkerRegistrationData::_internal_cross_origin_embedder_policy_report_only_reporting_endpoint() const
{
    return _impl_.cross_origin_embedder_policy_report_only_reporting_endpoint_.Get();
}
inline void ServiceWorkerRegistrationData::_internal_set_cross_origin_embedder_policy_report_only_reporting_endpoint(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.cross_origin_embedder_policy_report_only_reporting_endpoint_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceWorkerRegistrationData::_internal_mutable_cross_origin_embedder_policy_report_only_reporting_endpoint()
{
    _impl_._has_bits_[0] |= 0x00000008u;
    return _impl_.cross_origin_embedder_policy_report_only_reporting_endpoint_.Mutable(GetArenaForAllocation());
}
inline std::string* ServiceWorkerRegistrationData::release_cross_origin_embedder_policy_report_only_reporting_endpoint()
{
    // @@protoc_insertion_point(field_release:storage.ServiceWorkerRegistrationData.cross_origin_embedder_policy_report_only_reporting_endpoint)
    if (!_internal_has_cross_origin_embedder_policy_report_only_reporting_endpoint()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000008u;
    auto* p = _impl_.cross_origin_embedder_policy_report_only_reporting_endpoint_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.cross_origin_embedder_policy_report_only_reporting_endpoint_.IsDefault()) {
        _impl_.cross_origin_embedder_policy_report_only_reporting_endpoint_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ServiceWorkerRegistrationData::set_allocated_cross_origin_embedder_policy_report_only_reporting_endpoint(
    std::string* cross_origin_embedder_policy_report_only_reporting_endpoint)
{
    if (cross_origin_embedder_policy_report_only_reporting_endpoint != nullptr) {
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    _impl_.cross_origin_embedder_policy_report_only_reporting_endpoint_.SetAllocated(
        cross_origin_embedder_policy_report_only_reporting_endpoint, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.cross_origin_embedder_policy_report_only_reporting_endpoint_.IsDefault()) {
        _impl_.cross_origin_embedder_policy_report_only_reporting_endpoint_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:storage.ServiceWorkerRegistrationData.cross_origin_embedder_policy_report_only_reporting_endpoint)
}

// optional .storage.ServiceWorkerRegistrationData.AncestorFrameType ancestor_frame_type = 21 [default = NORMAL_FRAME];
inline bool ServiceWorkerRegistrationData::_internal_has_ancestor_frame_type() const
{
    bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
    return value;
}
inline bool ServiceWorkerRegistrationData::has_ancestor_frame_type() const
{
    return _internal_has_ancestor_frame_type();
}
inline void ServiceWorkerRegistrationData::clear_ancestor_frame_type()
{
    _impl_.ancestor_frame_type_ = 0;
    _impl_._has_bits_[0] &= ~0x00200000u;
}
inline ::storage::ServiceWorkerRegistrationData_AncestorFrameType ServiceWorkerRegistrationData::_internal_ancestor_frame_type() const
{
    return static_cast<::storage::ServiceWorkerRegistrationData_AncestorFrameType>(_impl_.ancestor_frame_type_);
}
inline ::storage::ServiceWorkerRegistrationData_AncestorFrameType ServiceWorkerRegistrationData::ancestor_frame_type() const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.ancestor_frame_type)
    return _internal_ancestor_frame_type();
}
inline void ServiceWorkerRegistrationData::_internal_set_ancestor_frame_type(::storage::ServiceWorkerRegistrationData_AncestorFrameType value)
{
    assert(::storage::ServiceWorkerRegistrationData_AncestorFrameType_IsValid(value));
    _impl_._has_bits_[0] |= 0x00200000u;
    _impl_.ancestor_frame_type_ = value;
}
inline void ServiceWorkerRegistrationData::set_ancestor_frame_type(::storage::ServiceWorkerRegistrationData_AncestorFrameType value)
{
    _internal_set_ancestor_frame_type(value);
    // @@protoc_insertion_point(field_set:storage.ServiceWorkerRegistrationData.ancestor_frame_type)
}

// optional .storage.ServiceWorkerRegistrationData.PolicyContainerPolicies policy_container_policies = 23;
inline bool ServiceWorkerRegistrationData::_internal_has_policy_container_policies() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.policy_container_policies_ != nullptr);
    return value;
}
inline bool ServiceWorkerRegistrationData::has_policy_container_policies() const
{
    return _internal_has_policy_container_policies();
}
inline void ServiceWorkerRegistrationData::clear_policy_container_policies()
{
    if (_impl_.policy_container_policies_ != nullptr)
        _impl_.policy_container_policies_->Clear();
    _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::storage::ServiceWorkerRegistrationData_PolicyContainerPolicies& ServiceWorkerRegistrationData::_internal_policy_container_policies() const
{
    const ::storage::ServiceWorkerRegistrationData_PolicyContainerPolicies* p = _impl_.policy_container_policies_;
    return p != nullptr ? *p
                        : reinterpret_cast<const ::storage::ServiceWorkerRegistrationData_PolicyContainerPolicies&>(
                            ::storage::_ServiceWorkerRegistrationData_PolicyContainerPolicies_default_instance_);
}
inline const ::storage::ServiceWorkerRegistrationData_PolicyContainerPolicies& ServiceWorkerRegistrationData::policy_container_policies() const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.policy_container_policies)
    return _internal_policy_container_policies();
}
inline void ServiceWorkerRegistrationData::unsafe_arena_set_allocated_policy_container_policies(
    ::storage::ServiceWorkerRegistrationData_PolicyContainerPolicies* policy_container_policies)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.policy_container_policies_);
    }
    _impl_.policy_container_policies_ = policy_container_policies;
    if (policy_container_policies) {
        _impl_._has_bits_[0] |= 0x00000040u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000040u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:storage.ServiceWorkerRegistrationData.policy_container_policies)
}
inline ::storage::ServiceWorkerRegistrationData_PolicyContainerPolicies* ServiceWorkerRegistrationData::release_policy_container_policies()
{
    _impl_._has_bits_[0] &= ~0x00000040u;
    ::storage::ServiceWorkerRegistrationData_PolicyContainerPolicies* temp = _impl_.policy_container_policies_;
    _impl_.policy_container_policies_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::storage::ServiceWorkerRegistrationData_PolicyContainerPolicies* ServiceWorkerRegistrationData::unsafe_arena_release_policy_container_policies()
{
    // @@protoc_insertion_point(field_release:storage.ServiceWorkerRegistrationData.policy_container_policies)
    _impl_._has_bits_[0] &= ~0x00000040u;
    ::storage::ServiceWorkerRegistrationData_PolicyContainerPolicies* temp = _impl_.policy_container_policies_;
    _impl_.policy_container_policies_ = nullptr;
    return temp;
}
inline ::storage::ServiceWorkerRegistrationData_PolicyContainerPolicies* ServiceWorkerRegistrationData::_internal_mutable_policy_container_policies()
{
    _impl_._has_bits_[0] |= 0x00000040u;
    if (_impl_.policy_container_policies_ == nullptr) {
        auto* p = CreateMaybeMessage<::storage::ServiceWorkerRegistrationData_PolicyContainerPolicies>(GetArenaForAllocation());
        _impl_.policy_container_policies_ = p;
    }
    return _impl_.policy_container_policies_;
}
inline ::storage::ServiceWorkerRegistrationData_PolicyContainerPolicies* ServiceWorkerRegistrationData::mutable_policy_container_policies()
{
    ::storage::ServiceWorkerRegistrationData_PolicyContainerPolicies* _msg = _internal_mutable_policy_container_policies();
    // @@protoc_insertion_point(field_mutable:storage.ServiceWorkerRegistrationData.policy_container_policies)
    return _msg;
}
inline void ServiceWorkerRegistrationData::set_allocated_policy_container_policies(
    ::storage::ServiceWorkerRegistrationData_PolicyContainerPolicies* policy_container_policies)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.policy_container_policies_;
    }
    if (policy_container_policies) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(policy_container_policies);
        if (message_arena != submessage_arena) {
            policy_container_policies = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, policy_container_policies, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000040u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000040u;
    }
    _impl_.policy_container_policies_ = policy_container_policies;
    // @@protoc_insertion_point(field_set_allocated:storage.ServiceWorkerRegistrationData.policy_container_policies)
}

// optional .storage.ServiceWorkerRegistrationData.RouterRules router_rules = 24;
inline bool ServiceWorkerRegistrationData::_internal_has_router_rules() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.router_rules_ != nullptr);
    return value;
}
inline bool ServiceWorkerRegistrationData::has_router_rules() const
{
    return _internal_has_router_rules();
}
inline void ServiceWorkerRegistrationData::clear_router_rules()
{
    if (_impl_.router_rules_ != nullptr)
        _impl_.router_rules_->Clear();
    _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::storage::ServiceWorkerRegistrationData_RouterRules& ServiceWorkerRegistrationData::_internal_router_rules() const
{
    const ::storage::ServiceWorkerRegistrationData_RouterRules* p = _impl_.router_rules_;
    return p != nullptr ? *p
                        : reinterpret_cast<const ::storage::ServiceWorkerRegistrationData_RouterRules&>(
                            ::storage::_ServiceWorkerRegistrationData_RouterRules_default_instance_);
}
inline const ::storage::ServiceWorkerRegistrationData_RouterRules& ServiceWorkerRegistrationData::router_rules() const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.router_rules)
    return _internal_router_rules();
}
inline void ServiceWorkerRegistrationData::unsafe_arena_set_allocated_router_rules(::storage::ServiceWorkerRegistrationData_RouterRules* router_rules)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.router_rules_);
    }
    _impl_.router_rules_ = router_rules;
    if (router_rules) {
        _impl_._has_bits_[0] |= 0x00000080u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000080u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:storage.ServiceWorkerRegistrationData.router_rules)
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules* ServiceWorkerRegistrationData::release_router_rules()
{
    _impl_._has_bits_[0] &= ~0x00000080u;
    ::storage::ServiceWorkerRegistrationData_RouterRules* temp = _impl_.router_rules_;
    _impl_.router_rules_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules* ServiceWorkerRegistrationData::unsafe_arena_release_router_rules()
{
    // @@protoc_insertion_point(field_release:storage.ServiceWorkerRegistrationData.router_rules)
    _impl_._has_bits_[0] &= ~0x00000080u;
    ::storage::ServiceWorkerRegistrationData_RouterRules* temp = _impl_.router_rules_;
    _impl_.router_rules_ = nullptr;
    return temp;
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules* ServiceWorkerRegistrationData::_internal_mutable_router_rules()
{
    _impl_._has_bits_[0] |= 0x00000080u;
    if (_impl_.router_rules_ == nullptr) {
        auto* p = CreateMaybeMessage<::storage::ServiceWorkerRegistrationData_RouterRules>(GetArenaForAllocation());
        _impl_.router_rules_ = p;
    }
    return _impl_.router_rules_;
}
inline ::storage::ServiceWorkerRegistrationData_RouterRules* ServiceWorkerRegistrationData::mutable_router_rules()
{
    ::storage::ServiceWorkerRegistrationData_RouterRules* _msg = _internal_mutable_router_rules();
    // @@protoc_insertion_point(field_mutable:storage.ServiceWorkerRegistrationData.router_rules)
    return _msg;
}
inline void ServiceWorkerRegistrationData::set_allocated_router_rules(::storage::ServiceWorkerRegistrationData_RouterRules* router_rules)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.router_rules_;
    }
    if (router_rules) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(router_rules);
        if (message_arena != submessage_arena) {
            router_rules = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, router_rules, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000080u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000080u;
    }
    _impl_.router_rules_ = router_rules;
    // @@protoc_insertion_point(field_set_allocated:storage.ServiceWorkerRegistrationData.router_rules)
}

// optional bool has_hid_event_handlers = 25;
inline bool ServiceWorkerRegistrationData::_internal_has_has_hid_event_handlers() const
{
    bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
    return value;
}
inline bool ServiceWorkerRegistrationData::has_has_hid_event_handlers() const
{
    return _internal_has_has_hid_event_handlers();
}
inline void ServiceWorkerRegistrationData::clear_has_hid_event_handlers()
{
    _impl_.has_hid_event_handlers_ = false;
    _impl_._has_bits_[0] &= ~0x00010000u;
}
inline bool ServiceWorkerRegistrationData::_internal_has_hid_event_handlers() const
{
    return _impl_.has_hid_event_handlers_;
}
inline bool ServiceWorkerRegistrationData::has_hid_event_handlers() const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.has_hid_event_handlers)
    return _internal_has_hid_event_handlers();
}
inline void ServiceWorkerRegistrationData::_internal_set_has_hid_event_handlers(bool value)
{
    _impl_._has_bits_[0] |= 0x00010000u;
    _impl_.has_hid_event_handlers_ = value;
}
inline void ServiceWorkerRegistrationData::set_has_hid_event_handlers(bool value)
{
    _internal_set_has_hid_event_handlers(value);
    // @@protoc_insertion_point(field_set:storage.ServiceWorkerRegistrationData.has_hid_event_handlers)
}

// optional bool has_usb_event_handlers = 26;
inline bool ServiceWorkerRegistrationData::_internal_has_has_usb_event_handlers() const
{
    bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
    return value;
}
inline bool ServiceWorkerRegistrationData::has_has_usb_event_handlers() const
{
    return _internal_has_has_usb_event_handlers();
}
inline void ServiceWorkerRegistrationData::clear_has_usb_event_handlers()
{
    _impl_.has_usb_event_handlers_ = false;
    _impl_._has_bits_[0] &= ~0x00020000u;
}
inline bool ServiceWorkerRegistrationData::_internal_has_usb_event_handlers() const
{
    return _impl_.has_usb_event_handlers_;
}
inline bool ServiceWorkerRegistrationData::has_usb_event_handlers() const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerRegistrationData.has_usb_event_handlers)
    return _internal_has_usb_event_handlers();
}
inline void ServiceWorkerRegistrationData::_internal_set_has_usb_event_handlers(bool value)
{
    _impl_._has_bits_[0] |= 0x00020000u;
    _impl_.has_usb_event_handlers_ = value;
}
inline void ServiceWorkerRegistrationData::set_has_usb_event_handlers(bool value)
{
    _internal_set_has_usb_event_handlers(value);
    // @@protoc_insertion_point(field_set:storage.ServiceWorkerRegistrationData.has_usb_event_handlers)
}

// -------------------------------------------------------------------

// ServiceWorkerResourceRecord

// required int64 resource_id = 1;
inline bool ServiceWorkerResourceRecord::_internal_has_resource_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool ServiceWorkerResourceRecord::has_resource_id() const
{
    return _internal_has_resource_id();
}
inline void ServiceWorkerResourceRecord::clear_resource_id()
{
    _impl_.resource_id_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t ServiceWorkerResourceRecord::_internal_resource_id() const
{
    return _impl_.resource_id_;
}
inline int64_t ServiceWorkerResourceRecord::resource_id() const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerResourceRecord.resource_id)
    return _internal_resource_id();
}
inline void ServiceWorkerResourceRecord::_internal_set_resource_id(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.resource_id_ = value;
}
inline void ServiceWorkerResourceRecord::set_resource_id(int64_t value)
{
    _internal_set_resource_id(value);
    // @@protoc_insertion_point(field_set:storage.ServiceWorkerResourceRecord.resource_id)
}

// required string url = 2;
inline bool ServiceWorkerResourceRecord::_internal_has_url() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool ServiceWorkerResourceRecord::has_url() const
{
    return _internal_has_url();
}
inline void ServiceWorkerResourceRecord::clear_url()
{
    _impl_.url_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ServiceWorkerResourceRecord::url() const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerResourceRecord.url)
    return _internal_url();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ServiceWorkerResourceRecord::set_url(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.url_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:storage.ServiceWorkerResourceRecord.url)
}
inline std::string* ServiceWorkerResourceRecord::mutable_url()
{
    std::string* _s = _internal_mutable_url();
    // @@protoc_insertion_point(field_mutable:storage.ServiceWorkerResourceRecord.url)
    return _s;
}
inline const std::string& ServiceWorkerResourceRecord::_internal_url() const
{
    return _impl_.url_.Get();
}
inline void ServiceWorkerResourceRecord::_internal_set_url(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceWorkerResourceRecord::_internal_mutable_url()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* ServiceWorkerResourceRecord::release_url()
{
    // @@protoc_insertion_point(field_release:storage.ServiceWorkerResourceRecord.url)
    if (!_internal_has_url()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.url_.IsDefault()) {
        _impl_.url_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ServiceWorkerResourceRecord::set_allocated_url(std::string* url)
{
    if (url != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.url_.IsDefault()) {
        _impl_.url_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:storage.ServiceWorkerResourceRecord.url)
}

// optional uint64 size_bytes = 3;
inline bool ServiceWorkerResourceRecord::_internal_has_size_bytes() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    return value;
}
inline bool ServiceWorkerResourceRecord::has_size_bytes() const
{
    return _internal_has_size_bytes();
}
inline void ServiceWorkerResourceRecord::clear_size_bytes()
{
    _impl_.size_bytes_ = uint64_t { 0u };
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint64_t ServiceWorkerResourceRecord::_internal_size_bytes() const
{
    return _impl_.size_bytes_;
}
inline uint64_t ServiceWorkerResourceRecord::size_bytes() const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerResourceRecord.size_bytes)
    return _internal_size_bytes();
}
inline void ServiceWorkerResourceRecord::_internal_set_size_bytes(uint64_t value)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.size_bytes_ = value;
}
inline void ServiceWorkerResourceRecord::set_size_bytes(uint64_t value)
{
    _internal_set_size_bytes(value);
    // @@protoc_insertion_point(field_set:storage.ServiceWorkerResourceRecord.size_bytes)
}

// optional string sha256_checksum = 4;
inline bool ServiceWorkerResourceRecord::_internal_has_sha256_checksum() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool ServiceWorkerResourceRecord::has_sha256_checksum() const
{
    return _internal_has_sha256_checksum();
}
inline void ServiceWorkerResourceRecord::clear_sha256_checksum()
{
    _impl_.sha256_checksum_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ServiceWorkerResourceRecord::sha256_checksum() const
{
    // @@protoc_insertion_point(field_get:storage.ServiceWorkerResourceRecord.sha256_checksum)
    return _internal_sha256_checksum();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ServiceWorkerResourceRecord::set_sha256_checksum(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.sha256_checksum_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:storage.ServiceWorkerResourceRecord.sha256_checksum)
}
inline std::string* ServiceWorkerResourceRecord::mutable_sha256_checksum()
{
    std::string* _s = _internal_mutable_sha256_checksum();
    // @@protoc_insertion_point(field_mutable:storage.ServiceWorkerResourceRecord.sha256_checksum)
    return _s;
}
inline const std::string& ServiceWorkerResourceRecord::_internal_sha256_checksum() const
{
    return _impl_.sha256_checksum_.Get();
}
inline void ServiceWorkerResourceRecord::_internal_set_sha256_checksum(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.sha256_checksum_.Set(value, GetArenaForAllocation());
}
inline std::string* ServiceWorkerResourceRecord::_internal_mutable_sha256_checksum()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.sha256_checksum_.Mutable(GetArenaForAllocation());
}
inline std::string* ServiceWorkerResourceRecord::release_sha256_checksum()
{
    // @@protoc_insertion_point(field_release:storage.ServiceWorkerResourceRecord.sha256_checksum)
    if (!_internal_has_sha256_checksum()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.sha256_checksum_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.sha256_checksum_.IsDefault()) {
        _impl_.sha256_checksum_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ServiceWorkerResourceRecord::set_allocated_sha256_checksum(std::string* sha256_checksum)
{
    if (sha256_checksum != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.sha256_checksum_.SetAllocated(sha256_checksum, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.sha256_checksum_.IsDefault()) {
        _impl_.sha256_checksum_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:storage.ServiceWorkerResourceRecord.sha256_checksum)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// @@protoc_insertion_point(namespace_scope)

} // namespace storage

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_URLPattern_Part_Modifier> : ::std::true_type { };
template <> struct is_proto_enum<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Mode> : ::std::true_type { };
template <> struct is_proto_enum<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_Request_Destination> : ::std::true_type { };
template <> struct is_proto_enum<::storage::ServiceWorkerRegistrationData_RouterRules_RuleV1_Condition_RunningStatus_Status> : ::std::true_type { };
template <> struct is_proto_enum<::storage::ServiceWorkerRegistrationData_ServiceWorkerScriptType> : ::std::true_type { };
template <> struct is_proto_enum<::storage::ServiceWorkerRegistrationData_ServiceWorkerUpdateViaCacheType> : ::std::true_type { };
template <> struct is_proto_enum<::storage::ServiceWorkerRegistrationData_CrossOriginEmbedderPolicyValue> : ::std::true_type { };
template <> struct is_proto_enum<::storage::ServiceWorkerRegistrationData_AncestorFrameType> : ::std::true_type { };
template <> struct is_proto_enum<::storage::ServiceWorkerRegistrationData_FetchHandlerSkippableType> : ::std::true_type { };
template <> struct is_proto_enum<::storage::ServiceWorkerRegistrationData_ReferrerPolicyValue> : ::std::true_type { };
template <> struct is_proto_enum<::storage::ServiceWorkerRegistrationData_IPAddressSpace> : ::std::true_type { };

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_service_5fworker_5fdatabase_2eproto
