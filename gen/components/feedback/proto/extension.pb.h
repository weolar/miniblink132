// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: extension.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_extension_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_extension_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h> // IWYU pragma: export
#include <google/protobuf/extension_set.h> // IWYU pragma: export
#include "common.pb.h"
#include "chrome.pb.h"
#include "dom.pb.h"
#include "math.pb.h"
#include "web.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_extension_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
} // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_extension_2eproto {
    static const uint32_t offsets[];
};
namespace userfeedback {
class ExtensionErrors;
struct ExtensionErrorsDefaultTypeInternal;
extern ExtensionErrorsDefaultTypeInternal _ExtensionErrors_default_instance_;
class ExtensionPageRequestParams;
struct ExtensionPageRequestParamsDefaultTypeInternal;
extern ExtensionPageRequestParamsDefaultTypeInternal _ExtensionPageRequestParams_default_instance_;
class ExtensionSubmit;
struct ExtensionSubmitDefaultTypeInternal;
extern ExtensionSubmitDefaultTypeInternal _ExtensionSubmit_default_instance_;
class PostedScreenshot;
struct PostedScreenshotDefaultTypeInternal;
extern PostedScreenshotDefaultTypeInternal _PostedScreenshot_default_instance_;
class SuggestQuery;
struct SuggestQueryDefaultTypeInternal;
extern SuggestQueryDefaultTypeInternal _SuggestQuery_default_instance_;
} // namespace userfeedback
PROTOBUF_NAMESPACE_OPEN
template <>::userfeedback::ExtensionErrors* Arena::CreateMaybeMessage<::userfeedback::ExtensionErrors>(Arena*);
template <>::userfeedback::ExtensionPageRequestParams* Arena::CreateMaybeMessage<::userfeedback::ExtensionPageRequestParams>(Arena*);
template <>::userfeedback::ExtensionSubmit* Arena::CreateMaybeMessage<::userfeedback::ExtensionSubmit>(Arena*);
template <>::userfeedback::PostedScreenshot* Arena::CreateMaybeMessage<::userfeedback::PostedScreenshot>(Arena*);
template <>::userfeedback::SuggestQuery* Arena::CreateMaybeMessage<::userfeedback::SuggestQuery>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace userfeedback {

// ===================================================================

class ExtensionPageRequestParams final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:userfeedback.ExtensionPageRequestParams) */ {
public:
    inline ExtensionPageRequestParams()
        : ExtensionPageRequestParams(nullptr)
    {
    }
    ~ExtensionPageRequestParams() override;
    explicit PROTOBUF_CONSTEXPR ExtensionPageRequestParams(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ExtensionPageRequestParams(const ExtensionPageRequestParams& from);
    ExtensionPageRequestParams(ExtensionPageRequestParams&& from) noexcept
        : ExtensionPageRequestParams()
    {
        *this = ::std::move(from);
    }

    inline ExtensionPageRequestParams& operator=(const ExtensionPageRequestParams& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ExtensionPageRequestParams& operator=(ExtensionPageRequestParams&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ExtensionPageRequestParams& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ExtensionPageRequestParams* internal_default_instance()
    {
        return reinterpret_cast<const ExtensionPageRequestParams*>(&_ExtensionPageRequestParams_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 0;

    friend void swap(ExtensionPageRequestParams& a, ExtensionPageRequestParams& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ExtensionPageRequestParams* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ExtensionPageRequestParams* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ExtensionPageRequestParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ExtensionPageRequestParams>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ExtensionPageRequestParams& from);
    void MergeFrom(const ExtensionPageRequestParams& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ExtensionPageRequestParams* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "userfeedback.ExtensionPageRequestParams";
    }

protected:
    explicit ExtensionPageRequestParams(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kUrlFieldNumber = 2,
        kExtensionDetailsFieldNumber = 1,
    };
    // required string url = 2;
    bool has_url() const;

private:
    bool _internal_has_url() const;

public:
    void clear_url();
    const std::string& url() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_url(ArgT0&& arg0, ArgT... args);
    std::string* mutable_url();
    PROTOBUF_NODISCARD std::string* release_url();
    void set_allocated_url(std::string* url);

private:
    const std::string& _internal_url() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
    std::string* _internal_mutable_url();

public:
    // required .userfeedback.ExtensionDetails extension_details = 1;
    bool has_extension_details() const;

private:
    bool _internal_has_extension_details() const;

public:
    void clear_extension_details();
    const ::userfeedback::ExtensionDetails& extension_details() const;
    PROTOBUF_NODISCARD ::userfeedback::ExtensionDetails* release_extension_details();
    ::userfeedback::ExtensionDetails* mutable_extension_details();
    void set_allocated_extension_details(::userfeedback::ExtensionDetails* extension_details);

private:
    const ::userfeedback::ExtensionDetails& _internal_extension_details() const;
    ::userfeedback::ExtensionDetails* _internal_mutable_extension_details();

public:
    void unsafe_arena_set_allocated_extension_details(::userfeedback::ExtensionDetails* extension_details);
    ::userfeedback::ExtensionDetails* unsafe_arena_release_extension_details();

    // @@protoc_insertion_point(class_scope:userfeedback.ExtensionPageRequestParams)
private:
    class _Internal;

    // helper for ByteSizeLong()
    size_t RequiredFieldsByteSizeFallback() const;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
        ::userfeedback::ExtensionDetails* extension_details_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_extension_2eproto;
};
// -------------------------------------------------------------------

class PostedScreenshot final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:userfeedback.PostedScreenshot) */ {
public:
    inline PostedScreenshot()
        : PostedScreenshot(nullptr)
    {
    }
    ~PostedScreenshot() override;
    explicit PROTOBUF_CONSTEXPR PostedScreenshot(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    PostedScreenshot(const PostedScreenshot& from);
    PostedScreenshot(PostedScreenshot&& from) noexcept
        : PostedScreenshot()
    {
        *this = ::std::move(from);
    }

    inline PostedScreenshot& operator=(const PostedScreenshot& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline PostedScreenshot& operator=(PostedScreenshot&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const PostedScreenshot& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const PostedScreenshot* internal_default_instance()
    {
        return reinterpret_cast<const PostedScreenshot*>(&_PostedScreenshot_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 1;

    friend void swap(PostedScreenshot& a, PostedScreenshot& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(PostedScreenshot* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(PostedScreenshot* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    PostedScreenshot* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<PostedScreenshot>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const PostedScreenshot& from);
    void MergeFrom(const PostedScreenshot& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(PostedScreenshot* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "userfeedback.PostedScreenshot";
    }

protected:
    explicit PostedScreenshot(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kMimeTypeFieldNumber = 1,
        kBase64ContentFieldNumber = 3,
        kBinaryContentFieldNumber = 4,
        kDimensionsFieldNumber = 2,
    };
    // required string mime_type = 1;
    bool has_mime_type() const;

private:
    bool _internal_has_mime_type() const;

public:
    void clear_mime_type();
    const std::string& mime_type() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_mime_type(ArgT0&& arg0, ArgT... args);
    std::string* mutable_mime_type();
    PROTOBUF_NODISCARD std::string* release_mime_type();
    void set_allocated_mime_type(std::string* mime_type);

private:
    const std::string& _internal_mime_type() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_mime_type(const std::string& value);
    std::string* _internal_mutable_mime_type();

public:
    // optional string base64_content = 3;
    bool has_base64_content() const;

private:
    bool _internal_has_base64_content() const;

public:
    void clear_base64_content();
    const std::string& base64_content() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_base64_content(ArgT0&& arg0, ArgT... args);
    std::string* mutable_base64_content();
    PROTOBUF_NODISCARD std::string* release_base64_content();
    void set_allocated_base64_content(std::string* base64_content);

private:
    const std::string& _internal_base64_content() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_base64_content(const std::string& value);
    std::string* _internal_mutable_base64_content();

public:
    // optional bytes binary_content = 4;
    bool has_binary_content() const;

private:
    bool _internal_has_binary_content() const;

public:
    void clear_binary_content();
    const std::string& binary_content() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_binary_content(ArgT0&& arg0, ArgT... args);
    std::string* mutable_binary_content();
    PROTOBUF_NODISCARD std::string* release_binary_content();
    void set_allocated_binary_content(std::string* binary_content);

private:
    const std::string& _internal_binary_content() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_binary_content(const std::string& value);
    std::string* _internal_mutable_binary_content();

public:
    // required .userfeedback.Dimensions dimensions = 2;
    bool has_dimensions() const;

private:
    bool _internal_has_dimensions() const;

public:
    void clear_dimensions();
    const ::userfeedback::Dimensions& dimensions() const;
    PROTOBUF_NODISCARD ::userfeedback::Dimensions* release_dimensions();
    ::userfeedback::Dimensions* mutable_dimensions();
    void set_allocated_dimensions(::userfeedback::Dimensions* dimensions);

private:
    const ::userfeedback::Dimensions& _internal_dimensions() const;
    ::userfeedback::Dimensions* _internal_mutable_dimensions();

public:
    void unsafe_arena_set_allocated_dimensions(::userfeedback::Dimensions* dimensions);
    ::userfeedback::Dimensions* unsafe_arena_release_dimensions();

    // @@protoc_insertion_point(class_scope:userfeedback.PostedScreenshot)
private:
    class _Internal;

    // helper for ByteSizeLong()
    size_t RequiredFieldsByteSizeFallback() const;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mime_type_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr base64_content_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr binary_content_;
        ::userfeedback::Dimensions* dimensions_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_extension_2eproto;
};
// -------------------------------------------------------------------

class ExtensionErrors final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:userfeedback.ExtensionErrors) */ {
public:
    inline ExtensionErrors()
        : ExtensionErrors(nullptr)
    {
    }
    ~ExtensionErrors() override;
    explicit PROTOBUF_CONSTEXPR ExtensionErrors(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ExtensionErrors(const ExtensionErrors& from);
    ExtensionErrors(ExtensionErrors&& from) noexcept
        : ExtensionErrors()
    {
        *this = ::std::move(from);
    }

    inline ExtensionErrors& operator=(const ExtensionErrors& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ExtensionErrors& operator=(ExtensionErrors&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ExtensionErrors& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ExtensionErrors* internal_default_instance()
    {
        return reinterpret_cast<const ExtensionErrors*>(&_ExtensionErrors_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 2;

    friend void swap(ExtensionErrors& a, ExtensionErrors& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ExtensionErrors* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ExtensionErrors* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ExtensionErrors* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ExtensionErrors>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ExtensionErrors& from);
    void MergeFrom(const ExtensionErrors& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ExtensionErrors* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "userfeedback.ExtensionErrors";
    }

protected:
    explicit ExtensionErrors(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kErrorsFieldNumber = 2,
        kNumberOfAttemptsFieldNumber = 1,
    };
    // required string errors = 2;
    bool has_errors() const;

private:
    bool _internal_has_errors() const;

public:
    void clear_errors();
    const std::string& errors() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_errors(ArgT0&& arg0, ArgT... args);
    std::string* mutable_errors();
    PROTOBUF_NODISCARD std::string* release_errors();
    void set_allocated_errors(std::string* errors);

private:
    const std::string& _internal_errors() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_errors(const std::string& value);
    std::string* _internal_mutable_errors();

public:
    // required int32 number_of_attempts = 1;
    bool has_number_of_attempts() const;

private:
    bool _internal_has_number_of_attempts() const;

public:
    void clear_number_of_attempts();
    int32_t number_of_attempts() const;
    void set_number_of_attempts(int32_t value);

private:
    int32_t _internal_number_of_attempts() const;
    void _internal_set_number_of_attempts(int32_t value);

public:
    // @@protoc_insertion_point(class_scope:userfeedback.ExtensionErrors)
private:
    class _Internal;

    // helper for ByteSizeLong()
    size_t RequiredFieldsByteSizeFallback() const;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errors_;
        int32_t number_of_attempts_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_extension_2eproto;
};
// -------------------------------------------------------------------

class ExtensionSubmit final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:userfeedback.ExtensionSubmit) */ {
public:
    inline ExtensionSubmit()
        : ExtensionSubmit(nullptr)
    {
    }
    ~ExtensionSubmit() override;
    explicit PROTOBUF_CONSTEXPR ExtensionSubmit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ExtensionSubmit(const ExtensionSubmit& from);
    ExtensionSubmit(ExtensionSubmit&& from) noexcept
        : ExtensionSubmit()
    {
        *this = ::std::move(from);
    }

    inline ExtensionSubmit& operator=(const ExtensionSubmit& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ExtensionSubmit& operator=(ExtensionSubmit&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ExtensionSubmit& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ExtensionSubmit* internal_default_instance()
    {
        return reinterpret_cast<const ExtensionSubmit*>(&_ExtensionSubmit_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 3;

    friend void swap(ExtensionSubmit& a, ExtensionSubmit& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ExtensionSubmit* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ExtensionSubmit* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ExtensionSubmit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ExtensionSubmit>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ExtensionSubmit& from);
    void MergeFrom(const ExtensionSubmit& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ExtensionSubmit* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "userfeedback.ExtensionSubmit";
    }

protected:
    explicit ExtensionSubmit(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kProductSpecificBinaryDataFieldNumber = 15,
        kCategoryTagFieldNumber = 16,
        kBucketFieldNumber = 18,
        kCommonDataFieldNumber = 1,
        kWebDataFieldNumber = 2,
        kScreenshotFieldNumber = 4,
        kChromeDataFieldNumber = 14,
        kTypeIdFieldNumber = 3,
        kProductIdFieldNumber = 17,
    };
    // repeated .userfeedback.ProductSpecificBinaryData product_specific_binary_data = 15;
    int product_specific_binary_data_size() const;

private:
    int _internal_product_specific_binary_data_size() const;

public:
    void clear_product_specific_binary_data();
    ::userfeedback::ProductSpecificBinaryData* mutable_product_specific_binary_data(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::userfeedback::ProductSpecificBinaryData>* mutable_product_specific_binary_data();

private:
    const ::userfeedback::ProductSpecificBinaryData& _internal_product_specific_binary_data(int index) const;
    ::userfeedback::ProductSpecificBinaryData* _internal_add_product_specific_binary_data();

public:
    const ::userfeedback::ProductSpecificBinaryData& product_specific_binary_data(int index) const;
    ::userfeedback::ProductSpecificBinaryData* add_product_specific_binary_data();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::userfeedback::ProductSpecificBinaryData>& product_specific_binary_data() const;

    // optional string category_tag = 16;
    bool has_category_tag() const;

private:
    bool _internal_has_category_tag() const;

public:
    void clear_category_tag();
    const std::string& category_tag() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_category_tag(ArgT0&& arg0, ArgT... args);
    std::string* mutable_category_tag();
    PROTOBUF_NODISCARD std::string* release_category_tag();
    void set_allocated_category_tag(std::string* category_tag);

private:
    const std::string& _internal_category_tag() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_category_tag(const std::string& value);
    std::string* _internal_mutable_category_tag();

public:
    // optional string bucket = 18;
    bool has_bucket() const;

private:
    bool _internal_has_bucket() const;

public:
    void clear_bucket();
    const std::string& bucket() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_bucket(ArgT0&& arg0, ArgT... args);
    std::string* mutable_bucket();
    PROTOBUF_NODISCARD std::string* release_bucket();
    void set_allocated_bucket(std::string* bucket);

private:
    const std::string& _internal_bucket() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_bucket(const std::string& value);
    std::string* _internal_mutable_bucket();

public:
    // required .userfeedback.CommonData common_data = 1;
    bool has_common_data() const;

private:
    bool _internal_has_common_data() const;

public:
    void clear_common_data();
    const ::userfeedback::CommonData& common_data() const;
    PROTOBUF_NODISCARD ::userfeedback::CommonData* release_common_data();
    ::userfeedback::CommonData* mutable_common_data();
    void set_allocated_common_data(::userfeedback::CommonData* common_data);

private:
    const ::userfeedback::CommonData& _internal_common_data() const;
    ::userfeedback::CommonData* _internal_mutable_common_data();

public:
    void unsafe_arena_set_allocated_common_data(::userfeedback::CommonData* common_data);
    ::userfeedback::CommonData* unsafe_arena_release_common_data();

    // required .userfeedback.WebData web_data = 2;
    bool has_web_data() const;

private:
    bool _internal_has_web_data() const;

public:
    void clear_web_data();
    const ::userfeedback::WebData& web_data() const;
    PROTOBUF_NODISCARD ::userfeedback::WebData* release_web_data();
    ::userfeedback::WebData* mutable_web_data();
    void set_allocated_web_data(::userfeedback::WebData* web_data);

private:
    const ::userfeedback::WebData& _internal_web_data() const;
    ::userfeedback::WebData* _internal_mutable_web_data();

public:
    void unsafe_arena_set_allocated_web_data(::userfeedback::WebData* web_data);
    ::userfeedback::WebData* unsafe_arena_release_web_data();

    // optional .userfeedback.PostedScreenshot screenshot = 4;
    bool has_screenshot() const;

private:
    bool _internal_has_screenshot() const;

public:
    void clear_screenshot();
    const ::userfeedback::PostedScreenshot& screenshot() const;
    PROTOBUF_NODISCARD ::userfeedback::PostedScreenshot* release_screenshot();
    ::userfeedback::PostedScreenshot* mutable_screenshot();
    void set_allocated_screenshot(::userfeedback::PostedScreenshot* screenshot);

private:
    const ::userfeedback::PostedScreenshot& _internal_screenshot() const;
    ::userfeedback::PostedScreenshot* _internal_mutable_screenshot();

public:
    void unsafe_arena_set_allocated_screenshot(::userfeedback::PostedScreenshot* screenshot);
    ::userfeedback::PostedScreenshot* unsafe_arena_release_screenshot();

    // optional .userfeedback.ChromeData chrome_data = 14;
    bool has_chrome_data() const;

private:
    bool _internal_has_chrome_data() const;

public:
    void clear_chrome_data();
    const ::userfeedback::ChromeData& chrome_data() const;
    PROTOBUF_NODISCARD ::userfeedback::ChromeData* release_chrome_data();
    ::userfeedback::ChromeData* mutable_chrome_data();
    void set_allocated_chrome_data(::userfeedback::ChromeData* chrome_data);

private:
    const ::userfeedback::ChromeData& _internal_chrome_data() const;
    ::userfeedback::ChromeData* _internal_mutable_chrome_data();

public:
    void unsafe_arena_set_allocated_chrome_data(::userfeedback::ChromeData* chrome_data);
    ::userfeedback::ChromeData* unsafe_arena_release_chrome_data();

    // required int32 type_id = 3;
    bool has_type_id() const;

private:
    bool _internal_has_type_id() const;

public:
    void clear_type_id();
    int32_t type_id() const;
    void set_type_id(int32_t value);

private:
    int32_t _internal_type_id() const;
    void _internal_set_type_id(int32_t value);

public:
    // optional int32 product_id = 17;
    bool has_product_id() const;

private:
    bool _internal_has_product_id() const;

public:
    void clear_product_id();
    int32_t product_id() const;
    void set_product_id(int32_t value);

private:
    int32_t _internal_product_id() const;
    void _internal_set_product_id(int32_t value);

public:
    // @@protoc_insertion_point(class_scope:userfeedback.ExtensionSubmit)
private:
    class _Internal;

    // helper for ByteSizeLong()
    size_t RequiredFieldsByteSizeFallback() const;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::userfeedback::ProductSpecificBinaryData> product_specific_binary_data_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr category_tag_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bucket_;
        ::userfeedback::CommonData* common_data_;
        ::userfeedback::WebData* web_data_;
        ::userfeedback::PostedScreenshot* screenshot_;
        ::userfeedback::ChromeData* chrome_data_;
        int32_t type_id_;
        int32_t product_id_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_extension_2eproto;
};
// -------------------------------------------------------------------

class SuggestQuery final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:userfeedback.SuggestQuery) */ {
public:
    inline SuggestQuery()
        : SuggestQuery(nullptr)
    {
    }
    ~SuggestQuery() override;
    explicit PROTOBUF_CONSTEXPR SuggestQuery(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    SuggestQuery(const SuggestQuery& from);
    SuggestQuery(SuggestQuery&& from) noexcept
        : SuggestQuery()
    {
        *this = ::std::move(from);
    }

    inline SuggestQuery& operator=(const SuggestQuery& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline SuggestQuery& operator=(SuggestQuery&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const SuggestQuery& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const SuggestQuery* internal_default_instance()
    {
        return reinterpret_cast<const SuggestQuery*>(&_SuggestQuery_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 4;

    friend void swap(SuggestQuery& a, SuggestQuery& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(SuggestQuery* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(SuggestQuery* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    SuggestQuery* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<SuggestQuery>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const SuggestQuery& from);
    void MergeFrom(const SuggestQuery& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(SuggestQuery* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "userfeedback.SuggestQuery";
    }

protected:
    explicit SuggestQuery(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kCommonDataFieldNumber = 1,
        kWebDataFieldNumber = 2,
        kHtmlDocumentStructureFieldNumber = 4,
        kChromeDataFieldNumber = 5,
        kTypeIdFieldNumber = 3,
    };
    // required .userfeedback.CommonData common_data = 1;
    bool has_common_data() const;

private:
    bool _internal_has_common_data() const;

public:
    void clear_common_data();
    const ::userfeedback::CommonData& common_data() const;
    PROTOBUF_NODISCARD ::userfeedback::CommonData* release_common_data();
    ::userfeedback::CommonData* mutable_common_data();
    void set_allocated_common_data(::userfeedback::CommonData* common_data);

private:
    const ::userfeedback::CommonData& _internal_common_data() const;
    ::userfeedback::CommonData* _internal_mutable_common_data();

public:
    void unsafe_arena_set_allocated_common_data(::userfeedback::CommonData* common_data);
    ::userfeedback::CommonData* unsafe_arena_release_common_data();

    // required .userfeedback.WebData web_data = 2;
    bool has_web_data() const;

private:
    bool _internal_has_web_data() const;

public:
    void clear_web_data();
    const ::userfeedback::WebData& web_data() const;
    PROTOBUF_NODISCARD ::userfeedback::WebData* release_web_data();
    ::userfeedback::WebData* mutable_web_data();
    void set_allocated_web_data(::userfeedback::WebData* web_data);

private:
    const ::userfeedback::WebData& _internal_web_data() const;
    ::userfeedback::WebData* _internal_mutable_web_data();

public:
    void unsafe_arena_set_allocated_web_data(::userfeedback::WebData* web_data);
    ::userfeedback::WebData* unsafe_arena_release_web_data();

    // optional .userfeedback.HtmlDocument html_document_structure = 4;
    bool has_html_document_structure() const;

private:
    bool _internal_has_html_document_structure() const;

public:
    void clear_html_document_structure();
    const ::userfeedback::HtmlDocument& html_document_structure() const;
    PROTOBUF_NODISCARD ::userfeedback::HtmlDocument* release_html_document_structure();
    ::userfeedback::HtmlDocument* mutable_html_document_structure();
    void set_allocated_html_document_structure(::userfeedback::HtmlDocument* html_document_structure);

private:
    const ::userfeedback::HtmlDocument& _internal_html_document_structure() const;
    ::userfeedback::HtmlDocument* _internal_mutable_html_document_structure();

public:
    void unsafe_arena_set_allocated_html_document_structure(::userfeedback::HtmlDocument* html_document_structure);
    ::userfeedback::HtmlDocument* unsafe_arena_release_html_document_structure();

    // optional .userfeedback.ChromeData chrome_data = 5;
    bool has_chrome_data() const;

private:
    bool _internal_has_chrome_data() const;

public:
    void clear_chrome_data();
    const ::userfeedback::ChromeData& chrome_data() const;
    PROTOBUF_NODISCARD ::userfeedback::ChromeData* release_chrome_data();
    ::userfeedback::ChromeData* mutable_chrome_data();
    void set_allocated_chrome_data(::userfeedback::ChromeData* chrome_data);

private:
    const ::userfeedback::ChromeData& _internal_chrome_data() const;
    ::userfeedback::ChromeData* _internal_mutable_chrome_data();

public:
    void unsafe_arena_set_allocated_chrome_data(::userfeedback::ChromeData* chrome_data);
    ::userfeedback::ChromeData* unsafe_arena_release_chrome_data();

    // required int32 type_id = 3;
    bool has_type_id() const;

private:
    bool _internal_has_type_id() const;

public:
    void clear_type_id();
    int32_t type_id() const;
    void set_type_id(int32_t value);

private:
    int32_t _internal_type_id() const;
    void _internal_set_type_id(int32_t value);

public:
    // @@protoc_insertion_point(class_scope:userfeedback.SuggestQuery)
private:
    class _Internal;

    // helper for ByteSizeLong()
    size_t RequiredFieldsByteSizeFallback() const;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::userfeedback::CommonData* common_data_;
        ::userfeedback::WebData* web_data_;
        ::userfeedback::HtmlDocument* html_document_structure_;
        ::userfeedback::ChromeData* chrome_data_;
        int32_t type_id_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_extension_2eproto;
};
// ===================================================================

// ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif // __GNUC__
// ExtensionPageRequestParams

// required .userfeedback.ExtensionDetails extension_details = 1;
inline bool ExtensionPageRequestParams::_internal_has_extension_details() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.extension_details_ != nullptr);
    return value;
}
inline bool ExtensionPageRequestParams::has_extension_details() const
{
    return _internal_has_extension_details();
}
inline const ::userfeedback::ExtensionDetails& ExtensionPageRequestParams::_internal_extension_details() const
{
    const ::userfeedback::ExtensionDetails* p = _impl_.extension_details_;
    return p != nullptr ? *p : reinterpret_cast<const ::userfeedback::ExtensionDetails&>(::userfeedback::_ExtensionDetails_default_instance_);
}
inline const ::userfeedback::ExtensionDetails& ExtensionPageRequestParams::extension_details() const
{
    // @@protoc_insertion_point(field_get:userfeedback.ExtensionPageRequestParams.extension_details)
    return _internal_extension_details();
}
inline void ExtensionPageRequestParams::unsafe_arena_set_allocated_extension_details(::userfeedback::ExtensionDetails* extension_details)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.extension_details_);
    }
    _impl_.extension_details_ = extension_details;
    if (extension_details) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:userfeedback.ExtensionPageRequestParams.extension_details)
}
inline ::userfeedback::ExtensionDetails* ExtensionPageRequestParams::release_extension_details()
{
    _impl_._has_bits_[0] &= ~0x00000002u;
    ::userfeedback::ExtensionDetails* temp = _impl_.extension_details_;
    _impl_.extension_details_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::userfeedback::ExtensionDetails* ExtensionPageRequestParams::unsafe_arena_release_extension_details()
{
    // @@protoc_insertion_point(field_release:userfeedback.ExtensionPageRequestParams.extension_details)
    _impl_._has_bits_[0] &= ~0x00000002u;
    ::userfeedback::ExtensionDetails* temp = _impl_.extension_details_;
    _impl_.extension_details_ = nullptr;
    return temp;
}
inline ::userfeedback::ExtensionDetails* ExtensionPageRequestParams::_internal_mutable_extension_details()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    if (_impl_.extension_details_ == nullptr) {
        auto* p = CreateMaybeMessage<::userfeedback::ExtensionDetails>(GetArenaForAllocation());
        _impl_.extension_details_ = p;
    }
    return _impl_.extension_details_;
}
inline ::userfeedback::ExtensionDetails* ExtensionPageRequestParams::mutable_extension_details()
{
    ::userfeedback::ExtensionDetails* _msg = _internal_mutable_extension_details();
    // @@protoc_insertion_point(field_mutable:userfeedback.ExtensionPageRequestParams.extension_details)
    return _msg;
}
inline void ExtensionPageRequestParams::set_allocated_extension_details(::userfeedback::ExtensionDetails* extension_details)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.extension_details_);
    }
    if (extension_details) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena
            = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(extension_details));
        if (message_arena != submessage_arena) {
            extension_details = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, extension_details, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.extension_details_ = extension_details;
    // @@protoc_insertion_point(field_set_allocated:userfeedback.ExtensionPageRequestParams.extension_details)
}

// required string url = 2;
inline bool ExtensionPageRequestParams::_internal_has_url() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool ExtensionPageRequestParams::has_url() const
{
    return _internal_has_url();
}
inline void ExtensionPageRequestParams::clear_url()
{
    _impl_.url_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ExtensionPageRequestParams::url() const
{
    // @@protoc_insertion_point(field_get:userfeedback.ExtensionPageRequestParams.url)
    return _internal_url();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ExtensionPageRequestParams::set_url(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.url_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:userfeedback.ExtensionPageRequestParams.url)
}
inline std::string* ExtensionPageRequestParams::mutable_url()
{
    std::string* _s = _internal_mutable_url();
    // @@protoc_insertion_point(field_mutable:userfeedback.ExtensionPageRequestParams.url)
    return _s;
}
inline const std::string& ExtensionPageRequestParams::_internal_url() const
{
    return _impl_.url_.Get();
}
inline void ExtensionPageRequestParams::_internal_set_url(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* ExtensionPageRequestParams::_internal_mutable_url()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* ExtensionPageRequestParams::release_url()
{
    // @@protoc_insertion_point(field_release:userfeedback.ExtensionPageRequestParams.url)
    if (!_internal_has_url()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.url_.IsDefault()) {
        _impl_.url_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ExtensionPageRequestParams::set_allocated_url(std::string* url)
{
    if (url != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.url_.IsDefault()) {
        _impl_.url_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:userfeedback.ExtensionPageRequestParams.url)
}

// -------------------------------------------------------------------

// PostedScreenshot

// required string mime_type = 1;
inline bool PostedScreenshot::_internal_has_mime_type() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool PostedScreenshot::has_mime_type() const
{
    return _internal_has_mime_type();
}
inline void PostedScreenshot::clear_mime_type()
{
    _impl_.mime_type_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PostedScreenshot::mime_type() const
{
    // @@protoc_insertion_point(field_get:userfeedback.PostedScreenshot.mime_type)
    return _internal_mime_type();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void PostedScreenshot::set_mime_type(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.mime_type_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:userfeedback.PostedScreenshot.mime_type)
}
inline std::string* PostedScreenshot::mutable_mime_type()
{
    std::string* _s = _internal_mutable_mime_type();
    // @@protoc_insertion_point(field_mutable:userfeedback.PostedScreenshot.mime_type)
    return _s;
}
inline const std::string& PostedScreenshot::_internal_mime_type() const
{
    return _impl_.mime_type_.Get();
}
inline void PostedScreenshot::_internal_set_mime_type(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.mime_type_.Set(value, GetArenaForAllocation());
}
inline std::string* PostedScreenshot::_internal_mutable_mime_type()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.mime_type_.Mutable(GetArenaForAllocation());
}
inline std::string* PostedScreenshot::release_mime_type()
{
    // @@protoc_insertion_point(field_release:userfeedback.PostedScreenshot.mime_type)
    if (!_internal_has_mime_type()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.mime_type_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.mime_type_.IsDefault()) {
        _impl_.mime_type_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void PostedScreenshot::set_allocated_mime_type(std::string* mime_type)
{
    if (mime_type != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.mime_type_.SetAllocated(mime_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.mime_type_.IsDefault()) {
        _impl_.mime_type_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:userfeedback.PostedScreenshot.mime_type)
}

// required .userfeedback.Dimensions dimensions = 2;
inline bool PostedScreenshot::_internal_has_dimensions() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.dimensions_ != nullptr);
    return value;
}
inline bool PostedScreenshot::has_dimensions() const
{
    return _internal_has_dimensions();
}
inline const ::userfeedback::Dimensions& PostedScreenshot::_internal_dimensions() const
{
    const ::userfeedback::Dimensions* p = _impl_.dimensions_;
    return p != nullptr ? *p : reinterpret_cast<const ::userfeedback::Dimensions&>(::userfeedback::_Dimensions_default_instance_);
}
inline const ::userfeedback::Dimensions& PostedScreenshot::dimensions() const
{
    // @@protoc_insertion_point(field_get:userfeedback.PostedScreenshot.dimensions)
    return _internal_dimensions();
}
inline void PostedScreenshot::unsafe_arena_set_allocated_dimensions(::userfeedback::Dimensions* dimensions)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dimensions_);
    }
    _impl_.dimensions_ = dimensions;
    if (dimensions) {
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:userfeedback.PostedScreenshot.dimensions)
}
inline ::userfeedback::Dimensions* PostedScreenshot::release_dimensions()
{
    _impl_._has_bits_[0] &= ~0x00000008u;
    ::userfeedback::Dimensions* temp = _impl_.dimensions_;
    _impl_.dimensions_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::userfeedback::Dimensions* PostedScreenshot::unsafe_arena_release_dimensions()
{
    // @@protoc_insertion_point(field_release:userfeedback.PostedScreenshot.dimensions)
    _impl_._has_bits_[0] &= ~0x00000008u;
    ::userfeedback::Dimensions* temp = _impl_.dimensions_;
    _impl_.dimensions_ = nullptr;
    return temp;
}
inline ::userfeedback::Dimensions* PostedScreenshot::_internal_mutable_dimensions()
{
    _impl_._has_bits_[0] |= 0x00000008u;
    if (_impl_.dimensions_ == nullptr) {
        auto* p = CreateMaybeMessage<::userfeedback::Dimensions>(GetArenaForAllocation());
        _impl_.dimensions_ = p;
    }
    return _impl_.dimensions_;
}
inline ::userfeedback::Dimensions* PostedScreenshot::mutable_dimensions()
{
    ::userfeedback::Dimensions* _msg = _internal_mutable_dimensions();
    // @@protoc_insertion_point(field_mutable:userfeedback.PostedScreenshot.dimensions)
    return _msg;
}
inline void PostedScreenshot::set_allocated_dimensions(::userfeedback::Dimensions* dimensions)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dimensions_);
    }
    if (dimensions) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena
            = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dimensions));
        if (message_arena != submessage_arena) {
            dimensions = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, dimensions, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    _impl_.dimensions_ = dimensions;
    // @@protoc_insertion_point(field_set_allocated:userfeedback.PostedScreenshot.dimensions)
}

// optional string base64_content = 3;
inline bool PostedScreenshot::_internal_has_base64_content() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool PostedScreenshot::has_base64_content() const
{
    return _internal_has_base64_content();
}
inline void PostedScreenshot::clear_base64_content()
{
    _impl_.base64_content_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PostedScreenshot::base64_content() const
{
    // @@protoc_insertion_point(field_get:userfeedback.PostedScreenshot.base64_content)
    return _internal_base64_content();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void PostedScreenshot::set_base64_content(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.base64_content_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:userfeedback.PostedScreenshot.base64_content)
}
inline std::string* PostedScreenshot::mutable_base64_content()
{
    std::string* _s = _internal_mutable_base64_content();
    // @@protoc_insertion_point(field_mutable:userfeedback.PostedScreenshot.base64_content)
    return _s;
}
inline const std::string& PostedScreenshot::_internal_base64_content() const
{
    return _impl_.base64_content_.Get();
}
inline void PostedScreenshot::_internal_set_base64_content(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.base64_content_.Set(value, GetArenaForAllocation());
}
inline std::string* PostedScreenshot::_internal_mutable_base64_content()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.base64_content_.Mutable(GetArenaForAllocation());
}
inline std::string* PostedScreenshot::release_base64_content()
{
    // @@protoc_insertion_point(field_release:userfeedback.PostedScreenshot.base64_content)
    if (!_internal_has_base64_content()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.base64_content_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.base64_content_.IsDefault()) {
        _impl_.base64_content_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void PostedScreenshot::set_allocated_base64_content(std::string* base64_content)
{
    if (base64_content != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.base64_content_.SetAllocated(base64_content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.base64_content_.IsDefault()) {
        _impl_.base64_content_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:userfeedback.PostedScreenshot.base64_content)
}

// optional bytes binary_content = 4;
inline bool PostedScreenshot::_internal_has_binary_content() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool PostedScreenshot::has_binary_content() const
{
    return _internal_has_binary_content();
}
inline void PostedScreenshot::clear_binary_content()
{
    _impl_.binary_content_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& PostedScreenshot::binary_content() const
{
    // @@protoc_insertion_point(field_get:userfeedback.PostedScreenshot.binary_content)
    return _internal_binary_content();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void PostedScreenshot::set_binary_content(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.binary_content_.SetBytes(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:userfeedback.PostedScreenshot.binary_content)
}
inline std::string* PostedScreenshot::mutable_binary_content()
{
    std::string* _s = _internal_mutable_binary_content();
    // @@protoc_insertion_point(field_mutable:userfeedback.PostedScreenshot.binary_content)
    return _s;
}
inline const std::string& PostedScreenshot::_internal_binary_content() const
{
    return _impl_.binary_content_.Get();
}
inline void PostedScreenshot::_internal_set_binary_content(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.binary_content_.Set(value, GetArenaForAllocation());
}
inline std::string* PostedScreenshot::_internal_mutable_binary_content()
{
    _impl_._has_bits_[0] |= 0x00000004u;
    return _impl_.binary_content_.Mutable(GetArenaForAllocation());
}
inline std::string* PostedScreenshot::release_binary_content()
{
    // @@protoc_insertion_point(field_release:userfeedback.PostedScreenshot.binary_content)
    if (!_internal_has_binary_content()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000004u;
    auto* p = _impl_.binary_content_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.binary_content_.IsDefault()) {
        _impl_.binary_content_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void PostedScreenshot::set_allocated_binary_content(std::string* binary_content)
{
    if (binary_content != nullptr) {
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    _impl_.binary_content_.SetAllocated(binary_content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.binary_content_.IsDefault()) {
        _impl_.binary_content_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:userfeedback.PostedScreenshot.binary_content)
}

// -------------------------------------------------------------------

// ExtensionErrors

// required int32 number_of_attempts = 1;
inline bool ExtensionErrors::_internal_has_number_of_attempts() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool ExtensionErrors::has_number_of_attempts() const
{
    return _internal_has_number_of_attempts();
}
inline void ExtensionErrors::clear_number_of_attempts()
{
    _impl_.number_of_attempts_ = 0;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t ExtensionErrors::_internal_number_of_attempts() const
{
    return _impl_.number_of_attempts_;
}
inline int32_t ExtensionErrors::number_of_attempts() const
{
    // @@protoc_insertion_point(field_get:userfeedback.ExtensionErrors.number_of_attempts)
    return _internal_number_of_attempts();
}
inline void ExtensionErrors::_internal_set_number_of_attempts(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.number_of_attempts_ = value;
}
inline void ExtensionErrors::set_number_of_attempts(int32_t value)
{
    _internal_set_number_of_attempts(value);
    // @@protoc_insertion_point(field_set:userfeedback.ExtensionErrors.number_of_attempts)
}

// required string errors = 2;
inline bool ExtensionErrors::_internal_has_errors() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool ExtensionErrors::has_errors() const
{
    return _internal_has_errors();
}
inline void ExtensionErrors::clear_errors()
{
    _impl_.errors_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ExtensionErrors::errors() const
{
    // @@protoc_insertion_point(field_get:userfeedback.ExtensionErrors.errors)
    return _internal_errors();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ExtensionErrors::set_errors(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.errors_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:userfeedback.ExtensionErrors.errors)
}
inline std::string* ExtensionErrors::mutable_errors()
{
    std::string* _s = _internal_mutable_errors();
    // @@protoc_insertion_point(field_mutable:userfeedback.ExtensionErrors.errors)
    return _s;
}
inline const std::string& ExtensionErrors::_internal_errors() const
{
    return _impl_.errors_.Get();
}
inline void ExtensionErrors::_internal_set_errors(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.errors_.Set(value, GetArenaForAllocation());
}
inline std::string* ExtensionErrors::_internal_mutable_errors()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.errors_.Mutable(GetArenaForAllocation());
}
inline std::string* ExtensionErrors::release_errors()
{
    // @@protoc_insertion_point(field_release:userfeedback.ExtensionErrors.errors)
    if (!_internal_has_errors()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.errors_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.errors_.IsDefault()) {
        _impl_.errors_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ExtensionErrors::set_allocated_errors(std::string* errors)
{
    if (errors != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.errors_.SetAllocated(errors, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.errors_.IsDefault()) {
        _impl_.errors_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:userfeedback.ExtensionErrors.errors)
}

// -------------------------------------------------------------------

// ExtensionSubmit

// required .userfeedback.CommonData common_data = 1;
inline bool ExtensionSubmit::_internal_has_common_data() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.common_data_ != nullptr);
    return value;
}
inline bool ExtensionSubmit::has_common_data() const
{
    return _internal_has_common_data();
}
inline const ::userfeedback::CommonData& ExtensionSubmit::_internal_common_data() const
{
    const ::userfeedback::CommonData* p = _impl_.common_data_;
    return p != nullptr ? *p : reinterpret_cast<const ::userfeedback::CommonData&>(::userfeedback::_CommonData_default_instance_);
}
inline const ::userfeedback::CommonData& ExtensionSubmit::common_data() const
{
    // @@protoc_insertion_point(field_get:userfeedback.ExtensionSubmit.common_data)
    return _internal_common_data();
}
inline void ExtensionSubmit::unsafe_arena_set_allocated_common_data(::userfeedback::CommonData* common_data)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.common_data_);
    }
    _impl_.common_data_ = common_data;
    if (common_data) {
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:userfeedback.ExtensionSubmit.common_data)
}
inline ::userfeedback::CommonData* ExtensionSubmit::release_common_data()
{
    _impl_._has_bits_[0] &= ~0x00000004u;
    ::userfeedback::CommonData* temp = _impl_.common_data_;
    _impl_.common_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::userfeedback::CommonData* ExtensionSubmit::unsafe_arena_release_common_data()
{
    // @@protoc_insertion_point(field_release:userfeedback.ExtensionSubmit.common_data)
    _impl_._has_bits_[0] &= ~0x00000004u;
    ::userfeedback::CommonData* temp = _impl_.common_data_;
    _impl_.common_data_ = nullptr;
    return temp;
}
inline ::userfeedback::CommonData* ExtensionSubmit::_internal_mutable_common_data()
{
    _impl_._has_bits_[0] |= 0x00000004u;
    if (_impl_.common_data_ == nullptr) {
        auto* p = CreateMaybeMessage<::userfeedback::CommonData>(GetArenaForAllocation());
        _impl_.common_data_ = p;
    }
    return _impl_.common_data_;
}
inline ::userfeedback::CommonData* ExtensionSubmit::mutable_common_data()
{
    ::userfeedback::CommonData* _msg = _internal_mutable_common_data();
    // @@protoc_insertion_point(field_mutable:userfeedback.ExtensionSubmit.common_data)
    return _msg;
}
inline void ExtensionSubmit::set_allocated_common_data(::userfeedback::CommonData* common_data)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.common_data_);
    }
    if (common_data) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena
            = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(common_data));
        if (message_arena != submessage_arena) {
            common_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, common_data, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    _impl_.common_data_ = common_data;
    // @@protoc_insertion_point(field_set_allocated:userfeedback.ExtensionSubmit.common_data)
}

// required .userfeedback.WebData web_data = 2;
inline bool ExtensionSubmit::_internal_has_web_data() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.web_data_ != nullptr);
    return value;
}
inline bool ExtensionSubmit::has_web_data() const
{
    return _internal_has_web_data();
}
inline const ::userfeedback::WebData& ExtensionSubmit::_internal_web_data() const
{
    const ::userfeedback::WebData* p = _impl_.web_data_;
    return p != nullptr ? *p : reinterpret_cast<const ::userfeedback::WebData&>(::userfeedback::_WebData_default_instance_);
}
inline const ::userfeedback::WebData& ExtensionSubmit::web_data() const
{
    // @@protoc_insertion_point(field_get:userfeedback.ExtensionSubmit.web_data)
    return _internal_web_data();
}
inline void ExtensionSubmit::unsafe_arena_set_allocated_web_data(::userfeedback::WebData* web_data)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.web_data_);
    }
    _impl_.web_data_ = web_data;
    if (web_data) {
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:userfeedback.ExtensionSubmit.web_data)
}
inline ::userfeedback::WebData* ExtensionSubmit::release_web_data()
{
    _impl_._has_bits_[0] &= ~0x00000008u;
    ::userfeedback::WebData* temp = _impl_.web_data_;
    _impl_.web_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::userfeedback::WebData* ExtensionSubmit::unsafe_arena_release_web_data()
{
    // @@protoc_insertion_point(field_release:userfeedback.ExtensionSubmit.web_data)
    _impl_._has_bits_[0] &= ~0x00000008u;
    ::userfeedback::WebData* temp = _impl_.web_data_;
    _impl_.web_data_ = nullptr;
    return temp;
}
inline ::userfeedback::WebData* ExtensionSubmit::_internal_mutable_web_data()
{
    _impl_._has_bits_[0] |= 0x00000008u;
    if (_impl_.web_data_ == nullptr) {
        auto* p = CreateMaybeMessage<::userfeedback::WebData>(GetArenaForAllocation());
        _impl_.web_data_ = p;
    }
    return _impl_.web_data_;
}
inline ::userfeedback::WebData* ExtensionSubmit::mutable_web_data()
{
    ::userfeedback::WebData* _msg = _internal_mutable_web_data();
    // @@protoc_insertion_point(field_mutable:userfeedback.ExtensionSubmit.web_data)
    return _msg;
}
inline void ExtensionSubmit::set_allocated_web_data(::userfeedback::WebData* web_data)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.web_data_);
    }
    if (web_data) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena
            = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(web_data));
        if (message_arena != submessage_arena) {
            web_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, web_data, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    _impl_.web_data_ = web_data;
    // @@protoc_insertion_point(field_set_allocated:userfeedback.ExtensionSubmit.web_data)
}

// required int32 type_id = 3;
inline bool ExtensionSubmit::_internal_has_type_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
    return value;
}
inline bool ExtensionSubmit::has_type_id() const
{
    return _internal_has_type_id();
}
inline void ExtensionSubmit::clear_type_id()
{
    _impl_.type_id_ = 0;
    _impl_._has_bits_[0] &= ~0x00000040u;
}
inline int32_t ExtensionSubmit::_internal_type_id() const
{
    return _impl_.type_id_;
}
inline int32_t ExtensionSubmit::type_id() const
{
    // @@protoc_insertion_point(field_get:userfeedback.ExtensionSubmit.type_id)
    return _internal_type_id();
}
inline void ExtensionSubmit::_internal_set_type_id(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000040u;
    _impl_.type_id_ = value;
}
inline void ExtensionSubmit::set_type_id(int32_t value)
{
    _internal_set_type_id(value);
    // @@protoc_insertion_point(field_set:userfeedback.ExtensionSubmit.type_id)
}

// optional .userfeedback.PostedScreenshot screenshot = 4;
inline bool ExtensionSubmit::_internal_has_screenshot() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.screenshot_ != nullptr);
    return value;
}
inline bool ExtensionSubmit::has_screenshot() const
{
    return _internal_has_screenshot();
}
inline void ExtensionSubmit::clear_screenshot()
{
    if (_impl_.screenshot_ != nullptr)
        _impl_.screenshot_->Clear();
    _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::userfeedback::PostedScreenshot& ExtensionSubmit::_internal_screenshot() const
{
    const ::userfeedback::PostedScreenshot* p = _impl_.screenshot_;
    return p != nullptr ? *p : reinterpret_cast<const ::userfeedback::PostedScreenshot&>(::userfeedback::_PostedScreenshot_default_instance_);
}
inline const ::userfeedback::PostedScreenshot& ExtensionSubmit::screenshot() const
{
    // @@protoc_insertion_point(field_get:userfeedback.ExtensionSubmit.screenshot)
    return _internal_screenshot();
}
inline void ExtensionSubmit::unsafe_arena_set_allocated_screenshot(::userfeedback::PostedScreenshot* screenshot)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.screenshot_);
    }
    _impl_.screenshot_ = screenshot;
    if (screenshot) {
        _impl_._has_bits_[0] |= 0x00000010u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000010u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:userfeedback.ExtensionSubmit.screenshot)
}
inline ::userfeedback::PostedScreenshot* ExtensionSubmit::release_screenshot()
{
    _impl_._has_bits_[0] &= ~0x00000010u;
    ::userfeedback::PostedScreenshot* temp = _impl_.screenshot_;
    _impl_.screenshot_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::userfeedback::PostedScreenshot* ExtensionSubmit::unsafe_arena_release_screenshot()
{
    // @@protoc_insertion_point(field_release:userfeedback.ExtensionSubmit.screenshot)
    _impl_._has_bits_[0] &= ~0x00000010u;
    ::userfeedback::PostedScreenshot* temp = _impl_.screenshot_;
    _impl_.screenshot_ = nullptr;
    return temp;
}
inline ::userfeedback::PostedScreenshot* ExtensionSubmit::_internal_mutable_screenshot()
{
    _impl_._has_bits_[0] |= 0x00000010u;
    if (_impl_.screenshot_ == nullptr) {
        auto* p = CreateMaybeMessage<::userfeedback::PostedScreenshot>(GetArenaForAllocation());
        _impl_.screenshot_ = p;
    }
    return _impl_.screenshot_;
}
inline ::userfeedback::PostedScreenshot* ExtensionSubmit::mutable_screenshot()
{
    ::userfeedback::PostedScreenshot* _msg = _internal_mutable_screenshot();
    // @@protoc_insertion_point(field_mutable:userfeedback.ExtensionSubmit.screenshot)
    return _msg;
}
inline void ExtensionSubmit::set_allocated_screenshot(::userfeedback::PostedScreenshot* screenshot)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.screenshot_;
    }
    if (screenshot) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(screenshot);
        if (message_arena != submessage_arena) {
            screenshot = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, screenshot, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000010u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000010u;
    }
    _impl_.screenshot_ = screenshot;
    // @@protoc_insertion_point(field_set_allocated:userfeedback.ExtensionSubmit.screenshot)
}

// optional .userfeedback.ChromeData chrome_data = 14;
inline bool ExtensionSubmit::_internal_has_chrome_data() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.chrome_data_ != nullptr);
    return value;
}
inline bool ExtensionSubmit::has_chrome_data() const
{
    return _internal_has_chrome_data();
}
inline const ::userfeedback::ChromeData& ExtensionSubmit::_internal_chrome_data() const
{
    const ::userfeedback::ChromeData* p = _impl_.chrome_data_;
    return p != nullptr ? *p : reinterpret_cast<const ::userfeedback::ChromeData&>(::userfeedback::_ChromeData_default_instance_);
}
inline const ::userfeedback::ChromeData& ExtensionSubmit::chrome_data() const
{
    // @@protoc_insertion_point(field_get:userfeedback.ExtensionSubmit.chrome_data)
    return _internal_chrome_data();
}
inline void ExtensionSubmit::unsafe_arena_set_allocated_chrome_data(::userfeedback::ChromeData* chrome_data)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.chrome_data_);
    }
    _impl_.chrome_data_ = chrome_data;
    if (chrome_data) {
        _impl_._has_bits_[0] |= 0x00000020u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000020u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:userfeedback.ExtensionSubmit.chrome_data)
}
inline ::userfeedback::ChromeData* ExtensionSubmit::release_chrome_data()
{
    _impl_._has_bits_[0] &= ~0x00000020u;
    ::userfeedback::ChromeData* temp = _impl_.chrome_data_;
    _impl_.chrome_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::userfeedback::ChromeData* ExtensionSubmit::unsafe_arena_release_chrome_data()
{
    // @@protoc_insertion_point(field_release:userfeedback.ExtensionSubmit.chrome_data)
    _impl_._has_bits_[0] &= ~0x00000020u;
    ::userfeedback::ChromeData* temp = _impl_.chrome_data_;
    _impl_.chrome_data_ = nullptr;
    return temp;
}
inline ::userfeedback::ChromeData* ExtensionSubmit::_internal_mutable_chrome_data()
{
    _impl_._has_bits_[0] |= 0x00000020u;
    if (_impl_.chrome_data_ == nullptr) {
        auto* p = CreateMaybeMessage<::userfeedback::ChromeData>(GetArenaForAllocation());
        _impl_.chrome_data_ = p;
    }
    return _impl_.chrome_data_;
}
inline ::userfeedback::ChromeData* ExtensionSubmit::mutable_chrome_data()
{
    ::userfeedback::ChromeData* _msg = _internal_mutable_chrome_data();
    // @@protoc_insertion_point(field_mutable:userfeedback.ExtensionSubmit.chrome_data)
    return _msg;
}
inline void ExtensionSubmit::set_allocated_chrome_data(::userfeedback::ChromeData* chrome_data)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.chrome_data_);
    }
    if (chrome_data) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena
            = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(chrome_data));
        if (message_arena != submessage_arena) {
            chrome_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, chrome_data, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000020u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000020u;
    }
    _impl_.chrome_data_ = chrome_data;
    // @@protoc_insertion_point(field_set_allocated:userfeedback.ExtensionSubmit.chrome_data)
}

// repeated .userfeedback.ProductSpecificBinaryData product_specific_binary_data = 15;
inline int ExtensionSubmit::_internal_product_specific_binary_data_size() const
{
    return _impl_.product_specific_binary_data_.size();
}
inline int ExtensionSubmit::product_specific_binary_data_size() const
{
    return _internal_product_specific_binary_data_size();
}
inline ::userfeedback::ProductSpecificBinaryData* ExtensionSubmit::mutable_product_specific_binary_data(int index)
{
    // @@protoc_insertion_point(field_mutable:userfeedback.ExtensionSubmit.product_specific_binary_data)
    return _impl_.product_specific_binary_data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::userfeedback::ProductSpecificBinaryData>* ExtensionSubmit::mutable_product_specific_binary_data()
{
    // @@protoc_insertion_point(field_mutable_list:userfeedback.ExtensionSubmit.product_specific_binary_data)
    return &_impl_.product_specific_binary_data_;
}
inline const ::userfeedback::ProductSpecificBinaryData& ExtensionSubmit::_internal_product_specific_binary_data(int index) const
{
    return _impl_.product_specific_binary_data_.Get(index);
}
inline const ::userfeedback::ProductSpecificBinaryData& ExtensionSubmit::product_specific_binary_data(int index) const
{
    // @@protoc_insertion_point(field_get:userfeedback.ExtensionSubmit.product_specific_binary_data)
    return _internal_product_specific_binary_data(index);
}
inline ::userfeedback::ProductSpecificBinaryData* ExtensionSubmit::_internal_add_product_specific_binary_data()
{
    return _impl_.product_specific_binary_data_.Add();
}
inline ::userfeedback::ProductSpecificBinaryData* ExtensionSubmit::add_product_specific_binary_data()
{
    ::userfeedback::ProductSpecificBinaryData* _add = _internal_add_product_specific_binary_data();
    // @@protoc_insertion_point(field_add:userfeedback.ExtensionSubmit.product_specific_binary_data)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::userfeedback::ProductSpecificBinaryData>& ExtensionSubmit::product_specific_binary_data() const
{
    // @@protoc_insertion_point(field_list:userfeedback.ExtensionSubmit.product_specific_binary_data)
    return _impl_.product_specific_binary_data_;
}

// optional string category_tag = 16;
inline bool ExtensionSubmit::_internal_has_category_tag() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool ExtensionSubmit::has_category_tag() const
{
    return _internal_has_category_tag();
}
inline void ExtensionSubmit::clear_category_tag()
{
    _impl_.category_tag_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ExtensionSubmit::category_tag() const
{
    // @@protoc_insertion_point(field_get:userfeedback.ExtensionSubmit.category_tag)
    return _internal_category_tag();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ExtensionSubmit::set_category_tag(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.category_tag_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:userfeedback.ExtensionSubmit.category_tag)
}
inline std::string* ExtensionSubmit::mutable_category_tag()
{
    std::string* _s = _internal_mutable_category_tag();
    // @@protoc_insertion_point(field_mutable:userfeedback.ExtensionSubmit.category_tag)
    return _s;
}
inline const std::string& ExtensionSubmit::_internal_category_tag() const
{
    return _impl_.category_tag_.Get();
}
inline void ExtensionSubmit::_internal_set_category_tag(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.category_tag_.Set(value, GetArenaForAllocation());
}
inline std::string* ExtensionSubmit::_internal_mutable_category_tag()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.category_tag_.Mutable(GetArenaForAllocation());
}
inline std::string* ExtensionSubmit::release_category_tag()
{
    // @@protoc_insertion_point(field_release:userfeedback.ExtensionSubmit.category_tag)
    if (!_internal_has_category_tag()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.category_tag_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.category_tag_.IsDefault()) {
        _impl_.category_tag_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ExtensionSubmit::set_allocated_category_tag(std::string* category_tag)
{
    if (category_tag != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.category_tag_.SetAllocated(category_tag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.category_tag_.IsDefault()) {
        _impl_.category_tag_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:userfeedback.ExtensionSubmit.category_tag)
}

// optional int32 product_id = 17;
inline bool ExtensionSubmit::_internal_has_product_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
    return value;
}
inline bool ExtensionSubmit::has_product_id() const
{
    return _internal_has_product_id();
}
inline void ExtensionSubmit::clear_product_id()
{
    _impl_.product_id_ = 0;
    _impl_._has_bits_[0] &= ~0x00000080u;
}
inline int32_t ExtensionSubmit::_internal_product_id() const
{
    return _impl_.product_id_;
}
inline int32_t ExtensionSubmit::product_id() const
{
    // @@protoc_insertion_point(field_get:userfeedback.ExtensionSubmit.product_id)
    return _internal_product_id();
}
inline void ExtensionSubmit::_internal_set_product_id(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000080u;
    _impl_.product_id_ = value;
}
inline void ExtensionSubmit::set_product_id(int32_t value)
{
    _internal_set_product_id(value);
    // @@protoc_insertion_point(field_set:userfeedback.ExtensionSubmit.product_id)
}

// optional string bucket = 18;
inline bool ExtensionSubmit::_internal_has_bucket() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool ExtensionSubmit::has_bucket() const
{
    return _internal_has_bucket();
}
inline void ExtensionSubmit::clear_bucket()
{
    _impl_.bucket_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ExtensionSubmit::bucket() const
{
    // @@protoc_insertion_point(field_get:userfeedback.ExtensionSubmit.bucket)
    return _internal_bucket();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ExtensionSubmit::set_bucket(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.bucket_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:userfeedback.ExtensionSubmit.bucket)
}
inline std::string* ExtensionSubmit::mutable_bucket()
{
    std::string* _s = _internal_mutable_bucket();
    // @@protoc_insertion_point(field_mutable:userfeedback.ExtensionSubmit.bucket)
    return _s;
}
inline const std::string& ExtensionSubmit::_internal_bucket() const
{
    return _impl_.bucket_.Get();
}
inline void ExtensionSubmit::_internal_set_bucket(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.bucket_.Set(value, GetArenaForAllocation());
}
inline std::string* ExtensionSubmit::_internal_mutable_bucket()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.bucket_.Mutable(GetArenaForAllocation());
}
inline std::string* ExtensionSubmit::release_bucket()
{
    // @@protoc_insertion_point(field_release:userfeedback.ExtensionSubmit.bucket)
    if (!_internal_has_bucket()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.bucket_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.bucket_.IsDefault()) {
        _impl_.bucket_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ExtensionSubmit::set_allocated_bucket(std::string* bucket)
{
    if (bucket != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.bucket_.SetAllocated(bucket, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.bucket_.IsDefault()) {
        _impl_.bucket_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:userfeedback.ExtensionSubmit.bucket)
}

// -------------------------------------------------------------------

// SuggestQuery

// required .userfeedback.CommonData common_data = 1;
inline bool SuggestQuery::_internal_has_common_data() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.common_data_ != nullptr);
    return value;
}
inline bool SuggestQuery::has_common_data() const
{
    return _internal_has_common_data();
}
inline const ::userfeedback::CommonData& SuggestQuery::_internal_common_data() const
{
    const ::userfeedback::CommonData* p = _impl_.common_data_;
    return p != nullptr ? *p : reinterpret_cast<const ::userfeedback::CommonData&>(::userfeedback::_CommonData_default_instance_);
}
inline const ::userfeedback::CommonData& SuggestQuery::common_data() const
{
    // @@protoc_insertion_point(field_get:userfeedback.SuggestQuery.common_data)
    return _internal_common_data();
}
inline void SuggestQuery::unsafe_arena_set_allocated_common_data(::userfeedback::CommonData* common_data)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.common_data_);
    }
    _impl_.common_data_ = common_data;
    if (common_data) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:userfeedback.SuggestQuery.common_data)
}
inline ::userfeedback::CommonData* SuggestQuery::release_common_data()
{
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::userfeedback::CommonData* temp = _impl_.common_data_;
    _impl_.common_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::userfeedback::CommonData* SuggestQuery::unsafe_arena_release_common_data()
{
    // @@protoc_insertion_point(field_release:userfeedback.SuggestQuery.common_data)
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::userfeedback::CommonData* temp = _impl_.common_data_;
    _impl_.common_data_ = nullptr;
    return temp;
}
inline ::userfeedback::CommonData* SuggestQuery::_internal_mutable_common_data()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    if (_impl_.common_data_ == nullptr) {
        auto* p = CreateMaybeMessage<::userfeedback::CommonData>(GetArenaForAllocation());
        _impl_.common_data_ = p;
    }
    return _impl_.common_data_;
}
inline ::userfeedback::CommonData* SuggestQuery::mutable_common_data()
{
    ::userfeedback::CommonData* _msg = _internal_mutable_common_data();
    // @@protoc_insertion_point(field_mutable:userfeedback.SuggestQuery.common_data)
    return _msg;
}
inline void SuggestQuery::set_allocated_common_data(::userfeedback::CommonData* common_data)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.common_data_);
    }
    if (common_data) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena
            = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(common_data));
        if (message_arena != submessage_arena) {
            common_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, common_data, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.common_data_ = common_data;
    // @@protoc_insertion_point(field_set_allocated:userfeedback.SuggestQuery.common_data)
}

// required .userfeedback.WebData web_data = 2;
inline bool SuggestQuery::_internal_has_web_data() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.web_data_ != nullptr);
    return value;
}
inline bool SuggestQuery::has_web_data() const
{
    return _internal_has_web_data();
}
inline const ::userfeedback::WebData& SuggestQuery::_internal_web_data() const
{
    const ::userfeedback::WebData* p = _impl_.web_data_;
    return p != nullptr ? *p : reinterpret_cast<const ::userfeedback::WebData&>(::userfeedback::_WebData_default_instance_);
}
inline const ::userfeedback::WebData& SuggestQuery::web_data() const
{
    // @@protoc_insertion_point(field_get:userfeedback.SuggestQuery.web_data)
    return _internal_web_data();
}
inline void SuggestQuery::unsafe_arena_set_allocated_web_data(::userfeedback::WebData* web_data)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.web_data_);
    }
    _impl_.web_data_ = web_data;
    if (web_data) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:userfeedback.SuggestQuery.web_data)
}
inline ::userfeedback::WebData* SuggestQuery::release_web_data()
{
    _impl_._has_bits_[0] &= ~0x00000002u;
    ::userfeedback::WebData* temp = _impl_.web_data_;
    _impl_.web_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::userfeedback::WebData* SuggestQuery::unsafe_arena_release_web_data()
{
    // @@protoc_insertion_point(field_release:userfeedback.SuggestQuery.web_data)
    _impl_._has_bits_[0] &= ~0x00000002u;
    ::userfeedback::WebData* temp = _impl_.web_data_;
    _impl_.web_data_ = nullptr;
    return temp;
}
inline ::userfeedback::WebData* SuggestQuery::_internal_mutable_web_data()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    if (_impl_.web_data_ == nullptr) {
        auto* p = CreateMaybeMessage<::userfeedback::WebData>(GetArenaForAllocation());
        _impl_.web_data_ = p;
    }
    return _impl_.web_data_;
}
inline ::userfeedback::WebData* SuggestQuery::mutable_web_data()
{
    ::userfeedback::WebData* _msg = _internal_mutable_web_data();
    // @@protoc_insertion_point(field_mutable:userfeedback.SuggestQuery.web_data)
    return _msg;
}
inline void SuggestQuery::set_allocated_web_data(::userfeedback::WebData* web_data)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.web_data_);
    }
    if (web_data) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena
            = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(web_data));
        if (message_arena != submessage_arena) {
            web_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, web_data, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.web_data_ = web_data;
    // @@protoc_insertion_point(field_set_allocated:userfeedback.SuggestQuery.web_data)
}

// required int32 type_id = 3;
inline bool SuggestQuery::_internal_has_type_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
    return value;
}
inline bool SuggestQuery::has_type_id() const
{
    return _internal_has_type_id();
}
inline void SuggestQuery::clear_type_id()
{
    _impl_.type_id_ = 0;
    _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t SuggestQuery::_internal_type_id() const
{
    return _impl_.type_id_;
}
inline int32_t SuggestQuery::type_id() const
{
    // @@protoc_insertion_point(field_get:userfeedback.SuggestQuery.type_id)
    return _internal_type_id();
}
inline void SuggestQuery::_internal_set_type_id(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000010u;
    _impl_.type_id_ = value;
}
inline void SuggestQuery::set_type_id(int32_t value)
{
    _internal_set_type_id(value);
    // @@protoc_insertion_point(field_set:userfeedback.SuggestQuery.type_id)
}

// optional .userfeedback.HtmlDocument html_document_structure = 4;
inline bool SuggestQuery::_internal_has_html_document_structure() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.html_document_structure_ != nullptr);
    return value;
}
inline bool SuggestQuery::has_html_document_structure() const
{
    return _internal_has_html_document_structure();
}
inline const ::userfeedback::HtmlDocument& SuggestQuery::_internal_html_document_structure() const
{
    const ::userfeedback::HtmlDocument* p = _impl_.html_document_structure_;
    return p != nullptr ? *p : reinterpret_cast<const ::userfeedback::HtmlDocument&>(::userfeedback::_HtmlDocument_default_instance_);
}
inline const ::userfeedback::HtmlDocument& SuggestQuery::html_document_structure() const
{
    // @@protoc_insertion_point(field_get:userfeedback.SuggestQuery.html_document_structure)
    return _internal_html_document_structure();
}
inline void SuggestQuery::unsafe_arena_set_allocated_html_document_structure(::userfeedback::HtmlDocument* html_document_structure)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.html_document_structure_);
    }
    _impl_.html_document_structure_ = html_document_structure;
    if (html_document_structure) {
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:userfeedback.SuggestQuery.html_document_structure)
}
inline ::userfeedback::HtmlDocument* SuggestQuery::release_html_document_structure()
{
    _impl_._has_bits_[0] &= ~0x00000004u;
    ::userfeedback::HtmlDocument* temp = _impl_.html_document_structure_;
    _impl_.html_document_structure_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::userfeedback::HtmlDocument* SuggestQuery::unsafe_arena_release_html_document_structure()
{
    // @@protoc_insertion_point(field_release:userfeedback.SuggestQuery.html_document_structure)
    _impl_._has_bits_[0] &= ~0x00000004u;
    ::userfeedback::HtmlDocument* temp = _impl_.html_document_structure_;
    _impl_.html_document_structure_ = nullptr;
    return temp;
}
inline ::userfeedback::HtmlDocument* SuggestQuery::_internal_mutable_html_document_structure()
{
    _impl_._has_bits_[0] |= 0x00000004u;
    if (_impl_.html_document_structure_ == nullptr) {
        auto* p = CreateMaybeMessage<::userfeedback::HtmlDocument>(GetArenaForAllocation());
        _impl_.html_document_structure_ = p;
    }
    return _impl_.html_document_structure_;
}
inline ::userfeedback::HtmlDocument* SuggestQuery::mutable_html_document_structure()
{
    ::userfeedback::HtmlDocument* _msg = _internal_mutable_html_document_structure();
    // @@protoc_insertion_point(field_mutable:userfeedback.SuggestQuery.html_document_structure)
    return _msg;
}
inline void SuggestQuery::set_allocated_html_document_structure(::userfeedback::HtmlDocument* html_document_structure)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.html_document_structure_);
    }
    if (html_document_structure) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena
            = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(html_document_structure));
        if (message_arena != submessage_arena) {
            html_document_structure = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, html_document_structure, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    _impl_.html_document_structure_ = html_document_structure;
    // @@protoc_insertion_point(field_set_allocated:userfeedback.SuggestQuery.html_document_structure)
}

// optional .userfeedback.ChromeData chrome_data = 5;
inline bool SuggestQuery::_internal_has_chrome_data() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.chrome_data_ != nullptr);
    return value;
}
inline bool SuggestQuery::has_chrome_data() const
{
    return _internal_has_chrome_data();
}
inline const ::userfeedback::ChromeData& SuggestQuery::_internal_chrome_data() const
{
    const ::userfeedback::ChromeData* p = _impl_.chrome_data_;
    return p != nullptr ? *p : reinterpret_cast<const ::userfeedback::ChromeData&>(::userfeedback::_ChromeData_default_instance_);
}
inline const ::userfeedback::ChromeData& SuggestQuery::chrome_data() const
{
    // @@protoc_insertion_point(field_get:userfeedback.SuggestQuery.chrome_data)
    return _internal_chrome_data();
}
inline void SuggestQuery::unsafe_arena_set_allocated_chrome_data(::userfeedback::ChromeData* chrome_data)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.chrome_data_);
    }
    _impl_.chrome_data_ = chrome_data;
    if (chrome_data) {
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:userfeedback.SuggestQuery.chrome_data)
}
inline ::userfeedback::ChromeData* SuggestQuery::release_chrome_data()
{
    _impl_._has_bits_[0] &= ~0x00000008u;
    ::userfeedback::ChromeData* temp = _impl_.chrome_data_;
    _impl_.chrome_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::userfeedback::ChromeData* SuggestQuery::unsafe_arena_release_chrome_data()
{
    // @@protoc_insertion_point(field_release:userfeedback.SuggestQuery.chrome_data)
    _impl_._has_bits_[0] &= ~0x00000008u;
    ::userfeedback::ChromeData* temp = _impl_.chrome_data_;
    _impl_.chrome_data_ = nullptr;
    return temp;
}
inline ::userfeedback::ChromeData* SuggestQuery::_internal_mutable_chrome_data()
{
    _impl_._has_bits_[0] |= 0x00000008u;
    if (_impl_.chrome_data_ == nullptr) {
        auto* p = CreateMaybeMessage<::userfeedback::ChromeData>(GetArenaForAllocation());
        _impl_.chrome_data_ = p;
    }
    return _impl_.chrome_data_;
}
inline ::userfeedback::ChromeData* SuggestQuery::mutable_chrome_data()
{
    ::userfeedback::ChromeData* _msg = _internal_mutable_chrome_data();
    // @@protoc_insertion_point(field_mutable:userfeedback.SuggestQuery.chrome_data)
    return _msg;
}
inline void SuggestQuery::set_allocated_chrome_data(::userfeedback::ChromeData* chrome_data)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.chrome_data_);
    }
    if (chrome_data) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena
            = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(chrome_data));
        if (message_arena != submessage_arena) {
            chrome_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, chrome_data, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    _impl_.chrome_data_ = chrome_data;
    // @@protoc_insertion_point(field_set_allocated:userfeedback.SuggestQuery.chrome_data)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// @@protoc_insertion_point(namespace_scope)

} // namespace userfeedback

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_extension_2eproto
