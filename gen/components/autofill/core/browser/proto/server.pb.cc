// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: server.proto

#include "server.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace autofill {
PROTOBUF_CONSTEXPR AutofillRandomizedValue::AutofillRandomizedValue(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.encoded_bits_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.checksum_)*/ 0u,
        /*decltype(_impl_.encoding_type_)*/ -1 }
{
}
struct AutofillRandomizedValueDefaultTypeInternal {
    PROTOBUF_CONSTEXPR AutofillRandomizedValueDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~AutofillRandomizedValueDefaultTypeInternal()
    {
    }
    union {
        AutofillRandomizedValue _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AutofillRandomizedValueDefaultTypeInternal
    _AutofillRandomizedValue_default_instance_;
PROTOBUF_CONSTEXPR AutofillRandomizedFormMetadata_ButtonTitle::AutofillRandomizedFormMetadata_ButtonTitle(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.title_)*/ nullptr, /*decltype(_impl_.type_)*/ 0 }
{
}
struct AutofillRandomizedFormMetadata_ButtonTitleDefaultTypeInternal {
    PROTOBUF_CONSTEXPR AutofillRandomizedFormMetadata_ButtonTitleDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~AutofillRandomizedFormMetadata_ButtonTitleDefaultTypeInternal()
    {
    }
    union {
        AutofillRandomizedFormMetadata_ButtonTitle _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AutofillRandomizedFormMetadata_ButtonTitleDefaultTypeInternal
    _AutofillRandomizedFormMetadata_ButtonTitle_default_instance_;
PROTOBUF_CONSTEXPR AutofillRandomizedFormMetadata::AutofillRandomizedFormMetadata(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.button_title_)*/ {},
        /*decltype(_impl_.id_)*/ nullptr, /*decltype(_impl_.name_)*/ nullptr, /*decltype(_impl_.action_)*/ nullptr, /*decltype(_impl_.url_)*/ nullptr }
{
}
struct AutofillRandomizedFormMetadataDefaultTypeInternal {
    PROTOBUF_CONSTEXPR AutofillRandomizedFormMetadataDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~AutofillRandomizedFormMetadataDefaultTypeInternal()
    {
    }
    union {
        AutofillRandomizedFormMetadata _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AutofillRandomizedFormMetadataDefaultTypeInternal
    _AutofillRandomizedFormMetadata_default_instance_;
PROTOBUF_CONSTEXPR AutofillRandomizedFieldMetadata::AutofillRandomizedFieldMetadata(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.id_)*/ nullptr, /*decltype(_impl_.name_)*/ nullptr,
        /*decltype(_impl_.type_)*/ nullptr, /*decltype(_impl_.label_)*/ nullptr, /*decltype(_impl_.aria_label_)*/ nullptr,
        /*decltype(_impl_.aria_description_)*/ nullptr, /*decltype(_impl_.css_class_)*/ nullptr, /*decltype(_impl_.placeholder_)*/ nullptr,
        /*decltype(_impl_.initial_value_hash_)*/ nullptr, /*decltype(_impl_.autocomplete_)*/ nullptr }
{
}
struct AutofillRandomizedFieldMetadataDefaultTypeInternal {
    PROTOBUF_CONSTEXPR AutofillRandomizedFieldMetadataDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~AutofillRandomizedFieldMetadataDefaultTypeInternal()
    {
    }
    union {
        AutofillRandomizedFieldMetadata _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AutofillRandomizedFieldMetadataDefaultTypeInternal
    _AutofillRandomizedFieldMetadata_default_instance_;
PROTOBUF_CONSTEXPR AutofillUploadContents_Field::AutofillUploadContents_Field(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.autofill_type_)*/ {},
        /*decltype(_impl_.name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.autocomplete_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.type_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.css_classes_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.randomized_field_metadata_)*/ nullptr, /*decltype(_impl_.signature_)*/ 0u, /*decltype(_impl_.generation_type_)*/ 0,
        /*decltype(_impl_.properties_mask_)*/ 0u, /*decltype(_impl_.vote_type_)*/ 0, /*decltype(_impl_.generated_password_changed_)*/ false,
        /*decltype(_impl_.is_most_recent_single_username_candidate_)*/ false, /*decltype(_impl_.initial_value_changed_)*/ false,
        /*decltype(_impl_.initial_value_hash_)*/ 0u, /*decltype(_impl_.single_username_vote_type_)*/ 0 }
{
}
struct AutofillUploadContents_FieldDefaultTypeInternal {
    PROTOBUF_CONSTEXPR AutofillUploadContents_FieldDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~AutofillUploadContents_FieldDefaultTypeInternal()
    {
    }
    union {
        AutofillUploadContents_Field _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AutofillUploadContents_FieldDefaultTypeInternal
    _AutofillUploadContents_Field_default_instance_;
PROTOBUF_CONSTEXPR AutofillUploadContents_ButtonTitle::AutofillUploadContents_ButtonTitle(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.title_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.type_)*/ 0 }
{
}
struct AutofillUploadContents_ButtonTitleDefaultTypeInternal {
    PROTOBUF_CONSTEXPR AutofillUploadContents_ButtonTitleDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~AutofillUploadContents_ButtonTitleDefaultTypeInternal()
    {
    }
    union {
        AutofillUploadContents_ButtonTitle _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AutofillUploadContents_ButtonTitleDefaultTypeInternal
    _AutofillUploadContents_ButtonTitle_default_instance_;
PROTOBUF_CONSTEXPR AutofillUploadContents_SingleUsernameData::AutofillUploadContents_SingleUsernameData(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.username_form_signature_)*/ uint64_t { 0u },
        /*decltype(_impl_.username_field_signature_)*/ 0u, /*decltype(_impl_.value_type_)*/ 0, /*decltype(_impl_.prompt_edit_)*/ 0 }
{
}
struct AutofillUploadContents_SingleUsernameDataDefaultTypeInternal {
    PROTOBUF_CONSTEXPR AutofillUploadContents_SingleUsernameDataDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~AutofillUploadContents_SingleUsernameDataDefaultTypeInternal()
    {
    }
    union {
        AutofillUploadContents_SingleUsernameData _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AutofillUploadContents_SingleUsernameDataDefaultTypeInternal
    _AutofillUploadContents_SingleUsernameData_default_instance_;
PROTOBUF_CONSTEXPR AutofillUploadContents::AutofillUploadContents(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.button_title_)*/ {},
        /*decltype(_impl_.single_username_data_)*/ {}, /*decltype(_impl_.field_data_)*/ {},
        /*decltype(_impl_.client_version_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.data_present_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.form_name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.language_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.randomized_form_metadata_)*/ nullptr, /*decltype(_impl_.form_signature_)*/ uint64_t { 0u },
        /*decltype(_impl_.action_signature_)*/ uint64_t { 0u }, /*decltype(_impl_.login_form_signature_)*/ uint64_t { 0u },
        /*decltype(_impl_.autofill_used_)*/ false, /*decltype(_impl_.submission_)*/ false, /*decltype(_impl_.passwords_revealed_)*/ false,
        /*decltype(_impl_.password_has_letter_)*/ false, /*decltype(_impl_.password_length_)*/ 0u, /*decltype(_impl_.password_has_uppercase_letter_)*/ false,
        /*decltype(_impl_.password_has_numeric_)*/ false, /*decltype(_impl_.password_has_special_symbol_)*/ false, /*decltype(_impl_.has_form_tag_)*/ false,
        /*decltype(_impl_.submission_event_)*/ 0, /*decltype(_impl_.secondary_form_signature_)*/ uint64_t { 0u }, /*decltype(_impl_.was_throttleable_)*/ false,
        /*decltype(_impl_.password_special_symbol_)*/ 0u, /*decltype(_impl_.last_address_form_submitted_)*/ uint64_t { 0u },
        /*decltype(_impl_.second_last_address_form_submitted_)*/ uint64_t { 0u }, /*decltype(_impl_.last_credit_card_form_submitted_)*/ uint64_t { 0u } }
{
}
struct AutofillUploadContentsDefaultTypeInternal {
    PROTOBUF_CONSTEXPR AutofillUploadContentsDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~AutofillUploadContentsDefaultTypeInternal()
    {
    }
    union {
        AutofillUploadContents _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AutofillUploadContentsDefaultTypeInternal
    _AutofillUploadContents_default_instance_;
PROTOBUF_CONSTEXPR ProfileValidityMap_FieldValidityStatesEntry_DoNotUse::ProfileValidityMap_FieldValidityStatesEntry_DoNotUse(::_pbi::ConstantInitialized)
{
}
struct ProfileValidityMap_FieldValidityStatesEntry_DoNotUseDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ProfileValidityMap_FieldValidityStatesEntry_DoNotUseDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ProfileValidityMap_FieldValidityStatesEntry_DoNotUseDefaultTypeInternal()
    {
    }
    union {
        ProfileValidityMap_FieldValidityStatesEntry_DoNotUse _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ProfileValidityMap_FieldValidityStatesEntry_DoNotUseDefaultTypeInternal
    _ProfileValidityMap_FieldValidityStatesEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR ProfileValidityMap::ProfileValidityMap(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.field_validity_states_)*/ {}, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct ProfileValidityMapDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ProfileValidityMapDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ProfileValidityMapDefaultTypeInternal()
    {
    }
    union {
        ProfileValidityMap _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ProfileValidityMapDefaultTypeInternal _ProfileValidityMap_default_instance_;
PROTOBUF_CONSTEXPR UserProfileValidityMap_ProfileValidityEntry_DoNotUse::UserProfileValidityMap_ProfileValidityEntry_DoNotUse(::_pbi::ConstantInitialized)
{
}
struct UserProfileValidityMap_ProfileValidityEntry_DoNotUseDefaultTypeInternal {
    PROTOBUF_CONSTEXPR UserProfileValidityMap_ProfileValidityEntry_DoNotUseDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~UserProfileValidityMap_ProfileValidityEntry_DoNotUseDefaultTypeInternal()
    {
    }
    union {
        UserProfileValidityMap_ProfileValidityEntry_DoNotUse _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserProfileValidityMap_ProfileValidityEntry_DoNotUseDefaultTypeInternal
    _UserProfileValidityMap_ProfileValidityEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR UserProfileValidityMap::UserProfileValidityMap(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.profile_validity_)*/ {}, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct UserProfileValidityMapDefaultTypeInternal {
    PROTOBUF_CONSTEXPR UserProfileValidityMapDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~UserProfileValidityMapDefaultTypeInternal()
    {
    }
    union {
        UserProfileValidityMap _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserProfileValidityMapDefaultTypeInternal
    _UserProfileValidityMap_default_instance_;
} // namespace autofill
namespace autofill {
bool AutofillRandomizedValue_EncodingType_IsValid(int value)
{
    switch (value) {
    case -1:
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> AutofillRandomizedValue_EncodingType_strings[12] = {};

static const char AutofillRandomizedValue_EncodingType_names[] = "ALL_BITS"
                                                                 "BIT_0"
                                                                 "BIT_1"
                                                                 "BIT_2"
                                                                 "BIT_3"
                                                                 "BIT_4"
                                                                 "BIT_5"
                                                                 "BIT_6"
                                                                 "BIT_7"
                                                                 "EVEN_BITS"
                                                                 "ODD_BITS"
                                                                 "UNSPECIFIED_ENCODING_TYPE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry AutofillRandomizedValue_EncodingType_entries[] = {
    { { AutofillRandomizedValue_EncodingType_names + 0, 8 }, 10 },
    { { AutofillRandomizedValue_EncodingType_names + 8, 5 }, 0 },
    { { AutofillRandomizedValue_EncodingType_names + 13, 5 }, 1 },
    { { AutofillRandomizedValue_EncodingType_names + 18, 5 }, 2 },
    { { AutofillRandomizedValue_EncodingType_names + 23, 5 }, 3 },
    { { AutofillRandomizedValue_EncodingType_names + 28, 5 }, 4 },
    { { AutofillRandomizedValue_EncodingType_names + 33, 5 }, 5 },
    { { AutofillRandomizedValue_EncodingType_names + 38, 5 }, 6 },
    { { AutofillRandomizedValue_EncodingType_names + 43, 5 }, 7 },
    { { AutofillRandomizedValue_EncodingType_names + 48, 9 }, 8 },
    { { AutofillRandomizedValue_EncodingType_names + 57, 8 }, 9 },
    { { AutofillRandomizedValue_EncodingType_names + 65, 25 }, -1 },
};

static const int AutofillRandomizedValue_EncodingType_entries_by_number[] = {
    11, // -1 -> UNSPECIFIED_ENCODING_TYPE
    1, // 0 -> BIT_0
    2, // 1 -> BIT_1
    3, // 2 -> BIT_2
    4, // 3 -> BIT_3
    5, // 4 -> BIT_4
    6, // 5 -> BIT_5
    7, // 6 -> BIT_6
    8, // 7 -> BIT_7
    9, // 8 -> EVEN_BITS
    10, // 9 -> ODD_BITS
    0, // 10 -> ALL_BITS
};

const std::string& AutofillRandomizedValue_EncodingType_Name(AutofillRandomizedValue_EncodingType value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        AutofillRandomizedValue_EncodingType_entries, AutofillRandomizedValue_EncodingType_entries_by_number, 12, AutofillRandomizedValue_EncodingType_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        AutofillRandomizedValue_EncodingType_entries, AutofillRandomizedValue_EncodingType_entries_by_number, 12, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : AutofillRandomizedValue_EncodingType_strings[idx].get();
}
bool AutofillRandomizedValue_EncodingType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AutofillRandomizedValue_EncodingType* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(AutofillRandomizedValue_EncodingType_entries, 12, name, &int_value);
    if (success) {
        *value = static_cast<AutofillRandomizedValue_EncodingType>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr AutofillRandomizedValue_EncodingType AutofillRandomizedValue::UNSPECIFIED_ENCODING_TYPE;
constexpr AutofillRandomizedValue_EncodingType AutofillRandomizedValue::BIT_0;
constexpr AutofillRandomizedValue_EncodingType AutofillRandomizedValue::BIT_1;
constexpr AutofillRandomizedValue_EncodingType AutofillRandomizedValue::BIT_2;
constexpr AutofillRandomizedValue_EncodingType AutofillRandomizedValue::BIT_3;
constexpr AutofillRandomizedValue_EncodingType AutofillRandomizedValue::BIT_4;
constexpr AutofillRandomizedValue_EncodingType AutofillRandomizedValue::BIT_5;
constexpr AutofillRandomizedValue_EncodingType AutofillRandomizedValue::BIT_6;
constexpr AutofillRandomizedValue_EncodingType AutofillRandomizedValue::BIT_7;
constexpr AutofillRandomizedValue_EncodingType AutofillRandomizedValue::EVEN_BITS;
constexpr AutofillRandomizedValue_EncodingType AutofillRandomizedValue::ODD_BITS;
constexpr AutofillRandomizedValue_EncodingType AutofillRandomizedValue::ALL_BITS;
constexpr AutofillRandomizedValue_EncodingType AutofillRandomizedValue::EncodingType_MIN;
constexpr AutofillRandomizedValue_EncodingType AutofillRandomizedValue::EncodingType_MAX;
constexpr int AutofillRandomizedValue::EncodingType_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool AutofillUploadContents_Field_PasswordGenerationType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> AutofillUploadContents_Field_PasswordGenerationType_strings[6] = {};

static const char AutofillUploadContents_Field_PasswordGenerationType_names[] = "AUTOMATICALLY_TRIGGERED_GENERATION_ON_CHANGE_PASSWORD_FORM"
                                                                                "AUTOMATICALLY_TRIGGERED_GENERATION_ON_SIGN_UP_FORM"
                                                                                "IGNORED_GENERATION_POPUP"
                                                                                "MANUALLY_TRIGGERED_GENERATION_ON_CHANGE_PASSWORD_FORM"
                                                                                "MANUALLY_TRIGGERED_GENERATION_ON_SIGN_UP_FORM"
                                                                                "NO_GENERATION";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry AutofillUploadContents_Field_PasswordGenerationType_entries[] = {
    { { AutofillUploadContents_Field_PasswordGenerationType_names + 0, 58 }, 2 },
    { { AutofillUploadContents_Field_PasswordGenerationType_names + 58, 50 }, 1 },
    { { AutofillUploadContents_Field_PasswordGenerationType_names + 108, 24 }, 5 },
    { { AutofillUploadContents_Field_PasswordGenerationType_names + 132, 53 }, 4 },
    { { AutofillUploadContents_Field_PasswordGenerationType_names + 185, 45 }, 3 },
    { { AutofillUploadContents_Field_PasswordGenerationType_names + 230, 13 }, 0 },
};

static const int AutofillUploadContents_Field_PasswordGenerationType_entries_by_number[] = {
    5, // 0 -> NO_GENERATION
    1, // 1 -> AUTOMATICALLY_TRIGGERED_GENERATION_ON_SIGN_UP_FORM
    0, // 2 -> AUTOMATICALLY_TRIGGERED_GENERATION_ON_CHANGE_PASSWORD_FORM
    4, // 3 -> MANUALLY_TRIGGERED_GENERATION_ON_SIGN_UP_FORM
    3, // 4 -> MANUALLY_TRIGGERED_GENERATION_ON_CHANGE_PASSWORD_FORM
    2, // 5 -> IGNORED_GENERATION_POPUP
};

const std::string& AutofillUploadContents_Field_PasswordGenerationType_Name(AutofillUploadContents_Field_PasswordGenerationType value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(AutofillUploadContents_Field_PasswordGenerationType_entries,
        AutofillUploadContents_Field_PasswordGenerationType_entries_by_number, 6, AutofillUploadContents_Field_PasswordGenerationType_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        AutofillUploadContents_Field_PasswordGenerationType_entries, AutofillUploadContents_Field_PasswordGenerationType_entries_by_number, 6, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : AutofillUploadContents_Field_PasswordGenerationType_strings[idx].get();
}
bool AutofillUploadContents_Field_PasswordGenerationType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AutofillUploadContents_Field_PasswordGenerationType* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(AutofillUploadContents_Field_PasswordGenerationType_entries, 6, name, &int_value);
    if (success) {
        *value = static_cast<AutofillUploadContents_Field_PasswordGenerationType>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr AutofillUploadContents_Field_PasswordGenerationType AutofillUploadContents_Field::NO_GENERATION;
constexpr AutofillUploadContents_Field_PasswordGenerationType AutofillUploadContents_Field::AUTOMATICALLY_TRIGGERED_GENERATION_ON_SIGN_UP_FORM;
constexpr AutofillUploadContents_Field_PasswordGenerationType AutofillUploadContents_Field::AUTOMATICALLY_TRIGGERED_GENERATION_ON_CHANGE_PASSWORD_FORM;
constexpr AutofillUploadContents_Field_PasswordGenerationType AutofillUploadContents_Field::MANUALLY_TRIGGERED_GENERATION_ON_SIGN_UP_FORM;
constexpr AutofillUploadContents_Field_PasswordGenerationType AutofillUploadContents_Field::MANUALLY_TRIGGERED_GENERATION_ON_CHANGE_PASSWORD_FORM;
constexpr AutofillUploadContents_Field_PasswordGenerationType AutofillUploadContents_Field::IGNORED_GENERATION_POPUP;
constexpr AutofillUploadContents_Field_PasswordGenerationType AutofillUploadContents_Field::PasswordGenerationType_MIN;
constexpr AutofillUploadContents_Field_PasswordGenerationType AutofillUploadContents_Field::PasswordGenerationType_MAX;
constexpr int AutofillUploadContents_Field::PasswordGenerationType_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool AutofillUploadContents_Field_VoteType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> AutofillUploadContents_Field_VoteType_strings[7] = {};

static const char AutofillUploadContents_Field_VoteType_names[] = "BASE_HEURISTIC"
                                                                  "CREDENTIALS_REUSED"
                                                                  "FIRST_USE"
                                                                  "HTML_CLASSIFIER"
                                                                  "NO_INFORMATION"
                                                                  "USERNAME_EDITED"
                                                                  "USERNAME_OVERWRITTEN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry AutofillUploadContents_Field_VoteType_entries[] = {
    { { AutofillUploadContents_Field_VoteType_names + 0, 14 }, 4 },
    { { AutofillUploadContents_Field_VoteType_names + 14, 18 }, 1 },
    { { AutofillUploadContents_Field_VoteType_names + 32, 9 }, 6 },
    { { AutofillUploadContents_Field_VoteType_names + 41, 15 }, 5 },
    { { AutofillUploadContents_Field_VoteType_names + 56, 14 }, 0 },
    { { AutofillUploadContents_Field_VoteType_names + 70, 15 }, 3 },
    { { AutofillUploadContents_Field_VoteType_names + 85, 20 }, 2 },
};

static const int AutofillUploadContents_Field_VoteType_entries_by_number[] = {
    4, // 0 -> NO_INFORMATION
    1, // 1 -> CREDENTIALS_REUSED
    6, // 2 -> USERNAME_OVERWRITTEN
    5, // 3 -> USERNAME_EDITED
    0, // 4 -> BASE_HEURISTIC
    3, // 5 -> HTML_CLASSIFIER
    2, // 6 -> FIRST_USE
};

const std::string& AutofillUploadContents_Field_VoteType_Name(AutofillUploadContents_Field_VoteType value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(AutofillUploadContents_Field_VoteType_entries,
        AutofillUploadContents_Field_VoteType_entries_by_number, 7, AutofillUploadContents_Field_VoteType_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        AutofillUploadContents_Field_VoteType_entries, AutofillUploadContents_Field_VoteType_entries_by_number, 7, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : AutofillUploadContents_Field_VoteType_strings[idx].get();
}
bool AutofillUploadContents_Field_VoteType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AutofillUploadContents_Field_VoteType* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(AutofillUploadContents_Field_VoteType_entries, 7, name, &int_value);
    if (success) {
        *value = static_cast<AutofillUploadContents_Field_VoteType>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr AutofillUploadContents_Field_VoteType AutofillUploadContents_Field::NO_INFORMATION;
constexpr AutofillUploadContents_Field_VoteType AutofillUploadContents_Field::CREDENTIALS_REUSED;
constexpr AutofillUploadContents_Field_VoteType AutofillUploadContents_Field::USERNAME_OVERWRITTEN;
constexpr AutofillUploadContents_Field_VoteType AutofillUploadContents_Field::USERNAME_EDITED;
constexpr AutofillUploadContents_Field_VoteType AutofillUploadContents_Field::BASE_HEURISTIC;
constexpr AutofillUploadContents_Field_VoteType AutofillUploadContents_Field::HTML_CLASSIFIER;
constexpr AutofillUploadContents_Field_VoteType AutofillUploadContents_Field::FIRST_USE;
constexpr AutofillUploadContents_Field_VoteType AutofillUploadContents_Field::VoteType_MIN;
constexpr AutofillUploadContents_Field_VoteType AutofillUploadContents_Field::VoteType_MAX;
constexpr int AutofillUploadContents_Field::VoteType_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool AutofillUploadContents_Field_SingleUsernameVoteType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> AutofillUploadContents_Field_SingleUsernameVoteType_strings[6] = {};

static const char AutofillUploadContents_Field_SingleUsernameVoteType_names[] = "DEFAULT"
                                                                                "IN_FORM_OVERRULE"
                                                                                "STRONG"
                                                                                "STRONG_FORGOT_PASSWORD"
                                                                                "WEAK"
                                                                                "WEAK_FORGOT_PASSWORD";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry AutofillUploadContents_Field_SingleUsernameVoteType_entries[] = {
    { { AutofillUploadContents_Field_SingleUsernameVoteType_names + 0, 7 }, 0 },
    { { AutofillUploadContents_Field_SingleUsernameVoteType_names + 7, 16 }, 5 },
    { { AutofillUploadContents_Field_SingleUsernameVoteType_names + 23, 6 }, 2 },
    { { AutofillUploadContents_Field_SingleUsernameVoteType_names + 29, 22 }, 4 },
    { { AutofillUploadContents_Field_SingleUsernameVoteType_names + 51, 4 }, 1 },
    { { AutofillUploadContents_Field_SingleUsernameVoteType_names + 55, 20 }, 3 },
};

static const int AutofillUploadContents_Field_SingleUsernameVoteType_entries_by_number[] = {
    0, // 0 -> DEFAULT
    4, // 1 -> WEAK
    2, // 2 -> STRONG
    5, // 3 -> WEAK_FORGOT_PASSWORD
    3, // 4 -> STRONG_FORGOT_PASSWORD
    1, // 5 -> IN_FORM_OVERRULE
};

const std::string& AutofillUploadContents_Field_SingleUsernameVoteType_Name(AutofillUploadContents_Field_SingleUsernameVoteType value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(AutofillUploadContents_Field_SingleUsernameVoteType_entries,
        AutofillUploadContents_Field_SingleUsernameVoteType_entries_by_number, 6, AutofillUploadContents_Field_SingleUsernameVoteType_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        AutofillUploadContents_Field_SingleUsernameVoteType_entries, AutofillUploadContents_Field_SingleUsernameVoteType_entries_by_number, 6, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : AutofillUploadContents_Field_SingleUsernameVoteType_strings[idx].get();
}
bool AutofillUploadContents_Field_SingleUsernameVoteType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AutofillUploadContents_Field_SingleUsernameVoteType* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(AutofillUploadContents_Field_SingleUsernameVoteType_entries, 6, name, &int_value);
    if (success) {
        *value = static_cast<AutofillUploadContents_Field_SingleUsernameVoteType>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr AutofillUploadContents_Field_SingleUsernameVoteType AutofillUploadContents_Field::DEFAULT;
constexpr AutofillUploadContents_Field_SingleUsernameVoteType AutofillUploadContents_Field::WEAK;
constexpr AutofillUploadContents_Field_SingleUsernameVoteType AutofillUploadContents_Field::STRONG;
constexpr AutofillUploadContents_Field_SingleUsernameVoteType AutofillUploadContents_Field::WEAK_FORGOT_PASSWORD;
constexpr AutofillUploadContents_Field_SingleUsernameVoteType AutofillUploadContents_Field::STRONG_FORGOT_PASSWORD;
constexpr AutofillUploadContents_Field_SingleUsernameVoteType AutofillUploadContents_Field::IN_FORM_OVERRULE;
constexpr AutofillUploadContents_Field_SingleUsernameVoteType AutofillUploadContents_Field::SingleUsernameVoteType_MIN;
constexpr AutofillUploadContents_Field_SingleUsernameVoteType AutofillUploadContents_Field::SingleUsernameVoteType_MAX;
constexpr int AutofillUploadContents_Field::SingleUsernameVoteType_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool AutofillUploadContents_SubmissionIndicatorEvent_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> AutofillUploadContents_SubmissionIndicatorEvent_strings[13] = {};

static const char AutofillUploadContents_SubmissionIndicatorEvent_names[] = "CHANGE_PASSWORD_FORM_CLEARED"
                                                                            "DEPRECATED_DOM_MUTATION_AFTER_XHR"
                                                                            "DEPRECATED_FILLED_FORM_ON_START_PROVISIONAL_LOAD"
                                                                            "DEPRECATED_FILLED_INPUT_ELEMENTS_ON_START_PROVISIONAL_LOAD"
                                                                            "DEPRECATED_MANUAL_SAVE"
                                                                            "DEPRECATED_PROVISIONALLY_SAVED_FORM_ON_START_PROVISIONAL_LOAD"
                                                                            "DOM_MUTATION_AFTER_AUTOFILL"
                                                                            "FRAME_DETACHED"
                                                                            "HTML_FORM_SUBMISSION"
                                                                            "NONE"
                                                                            "PROBABLE_FORM_SUBMISSION"
                                                                            "SAME_DOCUMENT_NAVIGATION"
                                                                            "XHR_SUCCEEDED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry AutofillUploadContents_SubmissionIndicatorEvent_entries[] = {
    { { AutofillUploadContents_SubmissionIndicatorEvent_names + 0, 28 }, 11 },
    { { AutofillUploadContents_SubmissionIndicatorEvent_names + 28, 33 }, 6 },
    { { AutofillUploadContents_SubmissionIndicatorEvent_names + 61, 48 }, 8 },
    { { AutofillUploadContents_SubmissionIndicatorEvent_names + 109, 58 }, 9 },
    { { AutofillUploadContents_SubmissionIndicatorEvent_names + 167, 22 }, 5 },
    { { AutofillUploadContents_SubmissionIndicatorEvent_names + 189, 61 }, 7 },
    { { AutofillUploadContents_SubmissionIndicatorEvent_names + 250, 27 }, 12 },
    { { AutofillUploadContents_SubmissionIndicatorEvent_names + 277, 14 }, 4 },
    { { AutofillUploadContents_SubmissionIndicatorEvent_names + 291, 20 }, 1 },
    { { AutofillUploadContents_SubmissionIndicatorEvent_names + 311, 4 }, 0 },
    { { AutofillUploadContents_SubmissionIndicatorEvent_names + 315, 24 }, 10 },
    { { AutofillUploadContents_SubmissionIndicatorEvent_names + 339, 24 }, 2 },
    { { AutofillUploadContents_SubmissionIndicatorEvent_names + 363, 13 }, 3 },
};

static const int AutofillUploadContents_SubmissionIndicatorEvent_entries_by_number[] = {
    9, // 0 -> NONE
    8, // 1 -> HTML_FORM_SUBMISSION
    11, // 2 -> SAME_DOCUMENT_NAVIGATION
    12, // 3 -> XHR_SUCCEEDED
    7, // 4 -> FRAME_DETACHED
    4, // 5 -> DEPRECATED_MANUAL_SAVE
    1, // 6 -> DEPRECATED_DOM_MUTATION_AFTER_XHR
    5, // 7 -> DEPRECATED_PROVISIONALLY_SAVED_FORM_ON_START_PROVISIONAL_LOAD
    2, // 8 -> DEPRECATED_FILLED_FORM_ON_START_PROVISIONAL_LOAD
    3, // 9 -> DEPRECATED_FILLED_INPUT_ELEMENTS_ON_START_PROVISIONAL_LOAD
    10, // 10 -> PROBABLE_FORM_SUBMISSION
    0, // 11 -> CHANGE_PASSWORD_FORM_CLEARED
    6, // 12 -> DOM_MUTATION_AFTER_AUTOFILL
};

const std::string& AutofillUploadContents_SubmissionIndicatorEvent_Name(AutofillUploadContents_SubmissionIndicatorEvent value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(AutofillUploadContents_SubmissionIndicatorEvent_entries,
        AutofillUploadContents_SubmissionIndicatorEvent_entries_by_number, 13, AutofillUploadContents_SubmissionIndicatorEvent_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        AutofillUploadContents_SubmissionIndicatorEvent_entries, AutofillUploadContents_SubmissionIndicatorEvent_entries_by_number, 13, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : AutofillUploadContents_SubmissionIndicatorEvent_strings[idx].get();
}
bool AutofillUploadContents_SubmissionIndicatorEvent_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AutofillUploadContents_SubmissionIndicatorEvent* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(AutofillUploadContents_SubmissionIndicatorEvent_entries, 13, name, &int_value);
    if (success) {
        *value = static_cast<AutofillUploadContents_SubmissionIndicatorEvent>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr AutofillUploadContents_SubmissionIndicatorEvent AutofillUploadContents::NONE;
constexpr AutofillUploadContents_SubmissionIndicatorEvent AutofillUploadContents::HTML_FORM_SUBMISSION;
constexpr AutofillUploadContents_SubmissionIndicatorEvent AutofillUploadContents::SAME_DOCUMENT_NAVIGATION;
constexpr AutofillUploadContents_SubmissionIndicatorEvent AutofillUploadContents::XHR_SUCCEEDED;
constexpr AutofillUploadContents_SubmissionIndicatorEvent AutofillUploadContents::FRAME_DETACHED;
constexpr AutofillUploadContents_SubmissionIndicatorEvent AutofillUploadContents::DEPRECATED_MANUAL_SAVE;
constexpr AutofillUploadContents_SubmissionIndicatorEvent AutofillUploadContents::DEPRECATED_DOM_MUTATION_AFTER_XHR;
constexpr AutofillUploadContents_SubmissionIndicatorEvent AutofillUploadContents::DEPRECATED_PROVISIONALLY_SAVED_FORM_ON_START_PROVISIONAL_LOAD;
constexpr AutofillUploadContents_SubmissionIndicatorEvent AutofillUploadContents::DEPRECATED_FILLED_FORM_ON_START_PROVISIONAL_LOAD;
constexpr AutofillUploadContents_SubmissionIndicatorEvent AutofillUploadContents::DEPRECATED_FILLED_INPUT_ELEMENTS_ON_START_PROVISIONAL_LOAD;
constexpr AutofillUploadContents_SubmissionIndicatorEvent AutofillUploadContents::PROBABLE_FORM_SUBMISSION;
constexpr AutofillUploadContents_SubmissionIndicatorEvent AutofillUploadContents::CHANGE_PASSWORD_FORM_CLEARED;
constexpr AutofillUploadContents_SubmissionIndicatorEvent AutofillUploadContents::DOM_MUTATION_AFTER_AUTOFILL;
constexpr AutofillUploadContents_SubmissionIndicatorEvent AutofillUploadContents::SubmissionIndicatorEvent_MIN;
constexpr AutofillUploadContents_SubmissionIndicatorEvent AutofillUploadContents::SubmissionIndicatorEvent_MAX;
constexpr int AutofillUploadContents::SubmissionIndicatorEvent_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool AutofillUploadContents_ValueType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> AutofillUploadContents_ValueType_strings[9] = {};

static const char AutofillUploadContents_ValueType_names[] = "EMAIL"
                                                             "NO_VALUE_TYPE"
                                                             "PHONE"
                                                             "STORED_FOR_ANOTHER_DOMAIN"
                                                             "STORED_FOR_CURRENT_DOMAIN"
                                                             "TYPE_UNSPECIFIED"
                                                             "USERNAME_LIKE"
                                                             "VALUE_WITH_NO_WHITESPACE"
                                                             "VALUE_WITH_WHITESPACE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry AutofillUploadContents_ValueType_entries[] = {
    { { AutofillUploadContents_ValueType_names + 0, 5 }, 4 },
    { { AutofillUploadContents_ValueType_names + 5, 13 }, 1 },
    { { AutofillUploadContents_ValueType_names + 18, 5 }, 5 },
    { { AutofillUploadContents_ValueType_names + 23, 25 }, 3 },
    { { AutofillUploadContents_ValueType_names + 48, 25 }, 2 },
    { { AutofillUploadContents_ValueType_names + 73, 16 }, 0 },
    { { AutofillUploadContents_ValueType_names + 89, 13 }, 6 },
    { { AutofillUploadContents_ValueType_names + 102, 24 }, 7 },
    { { AutofillUploadContents_ValueType_names + 126, 21 }, 8 },
};

static const int AutofillUploadContents_ValueType_entries_by_number[] = {
    5, // 0 -> TYPE_UNSPECIFIED
    1, // 1 -> NO_VALUE_TYPE
    4, // 2 -> STORED_FOR_CURRENT_DOMAIN
    3, // 3 -> STORED_FOR_ANOTHER_DOMAIN
    0, // 4 -> EMAIL
    2, // 5 -> PHONE
    6, // 6 -> USERNAME_LIKE
    7, // 7 -> VALUE_WITH_NO_WHITESPACE
    8, // 8 -> VALUE_WITH_WHITESPACE
};

const std::string& AutofillUploadContents_ValueType_Name(AutofillUploadContents_ValueType value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        AutofillUploadContents_ValueType_entries, AutofillUploadContents_ValueType_entries_by_number, 9, AutofillUploadContents_ValueType_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        AutofillUploadContents_ValueType_entries, AutofillUploadContents_ValueType_entries_by_number, 9, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : AutofillUploadContents_ValueType_strings[idx].get();
}
bool AutofillUploadContents_ValueType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AutofillUploadContents_ValueType* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(AutofillUploadContents_ValueType_entries, 9, name, &int_value);
    if (success) {
        *value = static_cast<AutofillUploadContents_ValueType>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr AutofillUploadContents_ValueType AutofillUploadContents::TYPE_UNSPECIFIED;
constexpr AutofillUploadContents_ValueType AutofillUploadContents::NO_VALUE_TYPE;
constexpr AutofillUploadContents_ValueType AutofillUploadContents::STORED_FOR_CURRENT_DOMAIN;
constexpr AutofillUploadContents_ValueType AutofillUploadContents::STORED_FOR_ANOTHER_DOMAIN;
constexpr AutofillUploadContents_ValueType AutofillUploadContents::EMAIL;
constexpr AutofillUploadContents_ValueType AutofillUploadContents::PHONE;
constexpr AutofillUploadContents_ValueType AutofillUploadContents::USERNAME_LIKE;
constexpr AutofillUploadContents_ValueType AutofillUploadContents::VALUE_WITH_NO_WHITESPACE;
constexpr AutofillUploadContents_ValueType AutofillUploadContents::VALUE_WITH_WHITESPACE;
constexpr AutofillUploadContents_ValueType AutofillUploadContents::ValueType_MIN;
constexpr AutofillUploadContents_ValueType AutofillUploadContents::ValueType_MAX;
constexpr int AutofillUploadContents::ValueType_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool AutofillUploadContents_SingleUsernamePromptEdit_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> AutofillUploadContents_SingleUsernamePromptEdit_strings[5] = {};

static const char AutofillUploadContents_SingleUsernamePromptEdit_names[] = "EDITED_NEGATIVE"
                                                                            "EDITED_POSITIVE"
                                                                            "EDIT_UNSPECIFIED"
                                                                            "NOT_EDITED_NEGATIVE"
                                                                            "NOT_EDITED_POSITIVE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry AutofillUploadContents_SingleUsernamePromptEdit_entries[] = {
    { { AutofillUploadContents_SingleUsernamePromptEdit_names + 0, 15 }, 4 },
    { { AutofillUploadContents_SingleUsernamePromptEdit_names + 15, 15 }, 3 },
    { { AutofillUploadContents_SingleUsernamePromptEdit_names + 30, 16 }, 0 },
    { { AutofillUploadContents_SingleUsernamePromptEdit_names + 46, 19 }, 2 },
    { { AutofillUploadContents_SingleUsernamePromptEdit_names + 65, 19 }, 1 },
};

static const int AutofillUploadContents_SingleUsernamePromptEdit_entries_by_number[] = {
    2, // 0 -> EDIT_UNSPECIFIED
    4, // 1 -> NOT_EDITED_POSITIVE
    3, // 2 -> NOT_EDITED_NEGATIVE
    1, // 3 -> EDITED_POSITIVE
    0, // 4 -> EDITED_NEGATIVE
};

const std::string& AutofillUploadContents_SingleUsernamePromptEdit_Name(AutofillUploadContents_SingleUsernamePromptEdit value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(AutofillUploadContents_SingleUsernamePromptEdit_entries,
        AutofillUploadContents_SingleUsernamePromptEdit_entries_by_number, 5, AutofillUploadContents_SingleUsernamePromptEdit_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        AutofillUploadContents_SingleUsernamePromptEdit_entries, AutofillUploadContents_SingleUsernamePromptEdit_entries_by_number, 5, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : AutofillUploadContents_SingleUsernamePromptEdit_strings[idx].get();
}
bool AutofillUploadContents_SingleUsernamePromptEdit_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AutofillUploadContents_SingleUsernamePromptEdit* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(AutofillUploadContents_SingleUsernamePromptEdit_entries, 5, name, &int_value);
    if (success) {
        *value = static_cast<AutofillUploadContents_SingleUsernamePromptEdit>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr AutofillUploadContents_SingleUsernamePromptEdit AutofillUploadContents::EDIT_UNSPECIFIED;
constexpr AutofillUploadContents_SingleUsernamePromptEdit AutofillUploadContents::NOT_EDITED_POSITIVE;
constexpr AutofillUploadContents_SingleUsernamePromptEdit AutofillUploadContents::NOT_EDITED_NEGATIVE;
constexpr AutofillUploadContents_SingleUsernamePromptEdit AutofillUploadContents::EDITED_POSITIVE;
constexpr AutofillUploadContents_SingleUsernamePromptEdit AutofillUploadContents::EDITED_NEGATIVE;
constexpr AutofillUploadContents_SingleUsernamePromptEdit AutofillUploadContents::SingleUsernamePromptEdit_MIN;
constexpr AutofillUploadContents_SingleUsernamePromptEdit AutofillUploadContents::SingleUsernamePromptEdit_MAX;
constexpr int AutofillUploadContents::SingleUsernamePromptEdit_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ButtonTitleType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ButtonTitleType_strings[8] = {};

static const char ButtonTitleType_names[] = "BUTTON_ELEMENT_BUTTON_TYPE"
                                            "BUTTON_ELEMENT_SUBMIT_TYPE"
                                            "DIV"
                                            "HYPERLINK"
                                            "INPUT_ELEMENT_BUTTON_TYPE"
                                            "INPUT_ELEMENT_SUBMIT_TYPE"
                                            "NONE"
                                            "SPAN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ButtonTitleType_entries[] = {
    { { ButtonTitleType_names + 0, 26 }, 2 },
    { { ButtonTitleType_names + 26, 26 }, 1 },
    { { ButtonTitleType_names + 52, 3 }, 6 },
    { { ButtonTitleType_names + 55, 9 }, 5 },
    { { ButtonTitleType_names + 64, 25 }, 4 },
    { { ButtonTitleType_names + 89, 25 }, 3 },
    { { ButtonTitleType_names + 114, 4 }, 0 },
    { { ButtonTitleType_names + 118, 4 }, 7 },
};

static const int ButtonTitleType_entries_by_number[] = {
    6, // 0 -> NONE
    1, // 1 -> BUTTON_ELEMENT_SUBMIT_TYPE
    0, // 2 -> BUTTON_ELEMENT_BUTTON_TYPE
    5, // 3 -> INPUT_ELEMENT_SUBMIT_TYPE
    4, // 4 -> INPUT_ELEMENT_BUTTON_TYPE
    3, // 5 -> HYPERLINK
    2, // 6 -> DIV
    7, // 7 -> SPAN
};

const std::string& ButtonTitleType_Name(ButtonTitleType value)
{
    static const bool dummy
        = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(ButtonTitleType_entries, ButtonTitleType_entries_by_number, 8, ButtonTitleType_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(ButtonTitleType_entries, ButtonTitleType_entries_by_number, 8, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : ButtonTitleType_strings[idx].get();
}
bool ButtonTitleType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ButtonTitleType* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(ButtonTitleType_entries, 8, name, &int_value);
    if (success) {
        *value = static_cast<ButtonTitleType>(int_value);
    }
    return success;
}

// ===================================================================

class AutofillRandomizedValue::_Internal {
public:
    using HasBits = decltype(std::declval<AutofillRandomizedValue>()._impl_._has_bits_);
    static void set_has_encoding_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_encoded_bits(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_checksum(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

AutofillRandomizedValue::AutofillRandomizedValue(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:autofill.AutofillRandomizedValue)
}
AutofillRandomizedValue::AutofillRandomizedValue(const AutofillRandomizedValue& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    AutofillRandomizedValue* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.encoded_bits_) {},
        decltype(_impl_.checksum_) {}, decltype(_impl_.encoding_type_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.encoded_bits_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.encoded_bits_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_encoded_bits()) {
        _this->_impl_.encoded_bits_.Set(from._internal_encoded_bits(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.checksum_, &from._impl_.checksum_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.encoding_type_) - reinterpret_cast<char*>(&_impl_.checksum_)) + sizeof(_impl_.encoding_type_));
    // @@protoc_insertion_point(copy_constructor:autofill.AutofillRandomizedValue)
}

inline void AutofillRandomizedValue::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.encoded_bits_) {},
        decltype(_impl_.checksum_) { 0u }, decltype(_impl_.encoding_type_) { -1 } };
    _impl_.encoded_bits_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.encoded_bits_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AutofillRandomizedValue::~AutofillRandomizedValue()
{
    // @@protoc_insertion_point(destructor:autofill.AutofillRandomizedValue)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void AutofillRandomizedValue::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.encoded_bits_.Destroy();
}

void AutofillRandomizedValue::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void AutofillRandomizedValue::Clear()
{
    // @@protoc_insertion_point(message_clear_start:autofill.AutofillRandomizedValue)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.encoded_bits_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000006u) {
        _impl_.checksum_ = 0u;
        _impl_.encoding_type_ = -1;
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* AutofillRandomizedValue::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .autofill.AutofillRandomizedValue.EncodingType encoding_type = 1 [default = UNSPECIFIED_ENCODING_TYPE];
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::autofill::AutofillRandomizedValue_EncodingType_IsValid(val))) {
                    _internal_set_encoding_type(static_cast<::autofill::AutofillRandomizedValue_EncodingType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional bytes encoded_bits = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_encoded_bits();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional fixed32 checksum = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
                _Internal::set_has_checksum(&has_bits);
                _impl_.checksum_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
                ptr += sizeof(uint32_t);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* AutofillRandomizedValue::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:autofill.AutofillRandomizedValue)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .autofill.AutofillRandomizedValue.EncodingType encoding_type = 1 [default = UNSPECIFIED_ENCODING_TYPE];
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(1, this->_internal_encoding_type(), target);
    }

    // optional bytes encoded_bits = 2;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteBytesMaybeAliased(2, this->_internal_encoded_bits(), target);
    }

    // optional fixed32 checksum = 3;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteFixed32ToArray(3, this->_internal_checksum(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:autofill.AutofillRandomizedValue)
    return target;
}

size_t AutofillRandomizedValue::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:autofill.AutofillRandomizedValue)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional bytes encoded_bits = 2;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_encoded_bits());
        }

        // optional fixed32 checksum = 3;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + 4;
        }

        // optional .autofill.AutofillRandomizedValue.EncodingType encoding_type = 1 [default = UNSPECIFIED_ENCODING_TYPE];
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_encoding_type());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void AutofillRandomizedValue::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const AutofillRandomizedValue*>(&from));
}

void AutofillRandomizedValue::MergeFrom(const AutofillRandomizedValue& from)
{
    AutofillRandomizedValue* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:autofill.AutofillRandomizedValue)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_encoded_bits(from._internal_encoded_bits());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.checksum_ = from._impl_.checksum_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.encoding_type_ = from._impl_.encoding_type_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AutofillRandomizedValue::CopyFrom(const AutofillRandomizedValue& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:autofill.AutofillRandomizedValue)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool AutofillRandomizedValue::IsInitialized() const
{
    return true;
}

void AutofillRandomizedValue::InternalSwap(AutofillRandomizedValue* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.encoded_bits_, lhs_arena, &other->_impl_.encoded_bits_, rhs_arena);
    swap(_impl_.checksum_, other->_impl_.checksum_);
    swap(_impl_.encoding_type_, other->_impl_.encoding_type_);
}

std::string AutofillRandomizedValue::GetTypeName() const
{
    return "autofill.AutofillRandomizedValue";
}

// ===================================================================

class AutofillRandomizedFormMetadata_ButtonTitle::_Internal {
public:
    using HasBits = decltype(std::declval<AutofillRandomizedFormMetadata_ButtonTitle>()._impl_._has_bits_);
    static const ::autofill::AutofillRandomizedValue& title(const AutofillRandomizedFormMetadata_ButtonTitle* msg);
    static void set_has_title(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

const ::autofill::AutofillRandomizedValue& AutofillRandomizedFormMetadata_ButtonTitle::_Internal::title(const AutofillRandomizedFormMetadata_ButtonTitle* msg)
{
    return *msg->_impl_.title_;
}
AutofillRandomizedFormMetadata_ButtonTitle::AutofillRandomizedFormMetadata_ButtonTitle(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:autofill.AutofillRandomizedFormMetadata.ButtonTitle)
}
AutofillRandomizedFormMetadata_ButtonTitle::AutofillRandomizedFormMetadata_ButtonTitle(const AutofillRandomizedFormMetadata_ButtonTitle& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    AutofillRandomizedFormMetadata_ButtonTitle* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.title_) { nullptr },
        decltype(_impl_.type_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_title()) {
        _this->_impl_.title_ = new ::autofill::AutofillRandomizedValue(*from._impl_.title_);
    }
    _this->_impl_.type_ = from._impl_.type_;
    // @@protoc_insertion_point(copy_constructor:autofill.AutofillRandomizedFormMetadata.ButtonTitle)
}

inline void AutofillRandomizedFormMetadata_ButtonTitle::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_)
        Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.title_) { nullptr }, decltype(_impl_.type_) { 0 } };
}

AutofillRandomizedFormMetadata_ButtonTitle::~AutofillRandomizedFormMetadata_ButtonTitle()
{
    // @@protoc_insertion_point(destructor:autofill.AutofillRandomizedFormMetadata.ButtonTitle)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void AutofillRandomizedFormMetadata_ButtonTitle::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (this != internal_default_instance())
        delete _impl_.title_;
}

void AutofillRandomizedFormMetadata_ButtonTitle::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void AutofillRandomizedFormMetadata_ButtonTitle::Clear()
{
    // @@protoc_insertion_point(message_clear_start:autofill.AutofillRandomizedFormMetadata.ButtonTitle)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        GOOGLE_DCHECK(_impl_.title_ != nullptr);
        _impl_.title_->Clear();
    }
    _impl_.type_ = 0;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* AutofillRandomizedFormMetadata_ButtonTitle::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .autofill.AutofillRandomizedValue title = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_title(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .autofill.ButtonTitleType type = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::autofill::ButtonTitleType_IsValid(val))) {
                    _internal_set_type(static_cast<::autofill::ButtonTitleType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* AutofillRandomizedFormMetadata_ButtonTitle::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:autofill.AutofillRandomizedFormMetadata.ButtonTitle)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .autofill.AutofillRandomizedValue title = 1;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::title(this), _Internal::title(this).GetCachedSize(), target, stream);
    }

    // optional .autofill.ButtonTitleType type = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(2, this->_internal_type(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:autofill.AutofillRandomizedFormMetadata.ButtonTitle)
    return target;
}

size_t AutofillRandomizedFormMetadata_ButtonTitle::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:autofill.AutofillRandomizedFormMetadata.ButtonTitle)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional .autofill.AutofillRandomizedValue title = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.title_);
        }

        // optional .autofill.ButtonTitleType type = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void AutofillRandomizedFormMetadata_ButtonTitle::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const AutofillRandomizedFormMetadata_ButtonTitle*>(&from));
}

void AutofillRandomizedFormMetadata_ButtonTitle::MergeFrom(const AutofillRandomizedFormMetadata_ButtonTitle& from)
{
    AutofillRandomizedFormMetadata_ButtonTitle* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:autofill.AutofillRandomizedFormMetadata.ButtonTitle)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_mutable_title()->::autofill::AutofillRandomizedValue::MergeFrom(from._internal_title());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.type_ = from._impl_.type_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AutofillRandomizedFormMetadata_ButtonTitle::CopyFrom(const AutofillRandomizedFormMetadata_ButtonTitle& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:autofill.AutofillRandomizedFormMetadata.ButtonTitle)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool AutofillRandomizedFormMetadata_ButtonTitle::IsInitialized() const
{
    return true;
}

void AutofillRandomizedFormMetadata_ButtonTitle::InternalSwap(AutofillRandomizedFormMetadata_ButtonTitle* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(AutofillRandomizedFormMetadata_ButtonTitle, _impl_.type_)
        + sizeof(AutofillRandomizedFormMetadata_ButtonTitle::_impl_.type_) - PROTOBUF_FIELD_OFFSET(AutofillRandomizedFormMetadata_ButtonTitle, _impl_.title_)>(
        reinterpret_cast<char*>(&_impl_.title_), reinterpret_cast<char*>(&other->_impl_.title_));
}

std::string AutofillRandomizedFormMetadata_ButtonTitle::GetTypeName() const
{
    return "autofill.AutofillRandomizedFormMetadata.ButtonTitle";
}

// ===================================================================

class AutofillRandomizedFormMetadata::_Internal {
public:
    using HasBits = decltype(std::declval<AutofillRandomizedFormMetadata>()._impl_._has_bits_);
    static const ::autofill::AutofillRandomizedValue& id(const AutofillRandomizedFormMetadata* msg);
    static void set_has_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static const ::autofill::AutofillRandomizedValue& name(const AutofillRandomizedFormMetadata* msg);
    static void set_has_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static const ::autofill::AutofillRandomizedValue& action(const AutofillRandomizedFormMetadata* msg);
    static void set_has_action(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static const ::autofill::AutofillRandomizedValue& url(const AutofillRandomizedFormMetadata* msg);
    static void set_has_url(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
};

const ::autofill::AutofillRandomizedValue& AutofillRandomizedFormMetadata::_Internal::id(const AutofillRandomizedFormMetadata* msg)
{
    return *msg->_impl_.id_;
}
const ::autofill::AutofillRandomizedValue& AutofillRandomizedFormMetadata::_Internal::name(const AutofillRandomizedFormMetadata* msg)
{
    return *msg->_impl_.name_;
}
const ::autofill::AutofillRandomizedValue& AutofillRandomizedFormMetadata::_Internal::action(const AutofillRandomizedFormMetadata* msg)
{
    return *msg->_impl_.action_;
}
const ::autofill::AutofillRandomizedValue& AutofillRandomizedFormMetadata::_Internal::url(const AutofillRandomizedFormMetadata* msg)
{
    return *msg->_impl_.url_;
}
AutofillRandomizedFormMetadata::AutofillRandomizedFormMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:autofill.AutofillRandomizedFormMetadata)
}
AutofillRandomizedFormMetadata::AutofillRandomizedFormMetadata(const AutofillRandomizedFormMetadata& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    AutofillRandomizedFormMetadata* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.button_title_) { from._impl_.button_title_ }, decltype(_impl_.id_) { nullptr }, decltype(_impl_.name_) { nullptr },
        decltype(_impl_.action_) { nullptr }, decltype(_impl_.url_) { nullptr } };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_id()) {
        _this->_impl_.id_ = new ::autofill::AutofillRandomizedValue(*from._impl_.id_);
    }
    if (from._internal_has_name()) {
        _this->_impl_.name_ = new ::autofill::AutofillRandomizedValue(*from._impl_.name_);
    }
    if (from._internal_has_action()) {
        _this->_impl_.action_ = new ::autofill::AutofillRandomizedValue(*from._impl_.action_);
    }
    if (from._internal_has_url()) {
        _this->_impl_.url_ = new ::autofill::AutofillRandomizedValue(*from._impl_.url_);
    }
    // @@protoc_insertion_point(copy_constructor:autofill.AutofillRandomizedFormMetadata)
}

inline void AutofillRandomizedFormMetadata::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.button_title_) { arena },
        decltype(_impl_.id_) { nullptr }, decltype(_impl_.name_) { nullptr }, decltype(_impl_.action_) { nullptr }, decltype(_impl_.url_) { nullptr } };
}

AutofillRandomizedFormMetadata::~AutofillRandomizedFormMetadata()
{
    // @@protoc_insertion_point(destructor:autofill.AutofillRandomizedFormMetadata)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void AutofillRandomizedFormMetadata::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.button_title_.~RepeatedPtrField();
    if (this != internal_default_instance())
        delete _impl_.id_;
    if (this != internal_default_instance())
        delete _impl_.name_;
    if (this != internal_default_instance())
        delete _impl_.action_;
    if (this != internal_default_instance())
        delete _impl_.url_;
}

void AutofillRandomizedFormMetadata::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void AutofillRandomizedFormMetadata::Clear()
{
    // @@protoc_insertion_point(message_clear_start:autofill.AutofillRandomizedFormMetadata)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.button_title_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            GOOGLE_DCHECK(_impl_.id_ != nullptr);
            _impl_.id_->Clear();
        }
        if (cached_has_bits & 0x00000002u) {
            GOOGLE_DCHECK(_impl_.name_ != nullptr);
            _impl_.name_->Clear();
        }
        if (cached_has_bits & 0x00000004u) {
            GOOGLE_DCHECK(_impl_.action_ != nullptr);
            _impl_.action_->Clear();
        }
        if (cached_has_bits & 0x00000008u) {
            GOOGLE_DCHECK(_impl_.url_ != nullptr);
            _impl_.url_->Clear();
        }
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* AutofillRandomizedFormMetadata::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .autofill.AutofillRandomizedValue id = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_id(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .autofill.AutofillRandomizedValue name = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_name(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .autofill.AutofillRandomizedValue action = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr = ctx->ParseMessage(_internal_mutable_action(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .autofill.AutofillRandomizedValue url = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr = ctx->ParseMessage(_internal_mutable_url(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .autofill.AutofillRandomizedFormMetadata.ButtonTitle button_title = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_button_title(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* AutofillRandomizedFormMetadata::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:autofill.AutofillRandomizedFormMetadata)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .autofill.AutofillRandomizedValue id = 1;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::id(this), _Internal::id(this).GetCachedSize(), target, stream);
    }

    // optional .autofill.AutofillRandomizedValue name = 2;
    if (cached_has_bits & 0x00000002u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::name(this), _Internal::name(this).GetCachedSize(), target, stream);
    }

    // optional .autofill.AutofillRandomizedValue action = 3;
    if (cached_has_bits & 0x00000004u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            3, _Internal::action(this), _Internal::action(this).GetCachedSize(), target, stream);
    }

    // optional .autofill.AutofillRandomizedValue url = 4;
    if (cached_has_bits & 0x00000008u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            4, _Internal::url(this), _Internal::url(this).GetCachedSize(), target, stream);
    }

    // repeated .autofill.AutofillRandomizedFormMetadata.ButtonTitle button_title = 5;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_button_title_size()); i < n; i++) {
        const auto& repfield = this->_internal_button_title(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:autofill.AutofillRandomizedFormMetadata)
    return target;
}

size_t AutofillRandomizedFormMetadata::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:autofill.AutofillRandomizedFormMetadata)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .autofill.AutofillRandomizedFormMetadata.ButtonTitle button_title = 5;
    total_size += 1UL * this->_internal_button_title_size();
    for (const auto& msg : this->_impl_.button_title_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        // optional .autofill.AutofillRandomizedValue id = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.id_);
        }

        // optional .autofill.AutofillRandomizedValue name = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.name_);
        }

        // optional .autofill.AutofillRandomizedValue action = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.action_);
        }

        // optional .autofill.AutofillRandomizedValue url = 4;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.url_);
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void AutofillRandomizedFormMetadata::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const AutofillRandomizedFormMetadata*>(&from));
}

void AutofillRandomizedFormMetadata::MergeFrom(const AutofillRandomizedFormMetadata& from)
{
    AutofillRandomizedFormMetadata* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:autofill.AutofillRandomizedFormMetadata)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.button_title_.MergeFrom(from._impl_.button_title_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_mutable_id()->::autofill::AutofillRandomizedValue::MergeFrom(from._internal_id());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_mutable_name()->::autofill::AutofillRandomizedValue::MergeFrom(from._internal_name());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_mutable_action()->::autofill::AutofillRandomizedValue::MergeFrom(from._internal_action());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_mutable_url()->::autofill::AutofillRandomizedValue::MergeFrom(from._internal_url());
        }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AutofillRandomizedFormMetadata::CopyFrom(const AutofillRandomizedFormMetadata& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:autofill.AutofillRandomizedFormMetadata)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool AutofillRandomizedFormMetadata::IsInitialized() const
{
    return true;
}

void AutofillRandomizedFormMetadata::InternalSwap(AutofillRandomizedFormMetadata* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.button_title_.InternalSwap(&other->_impl_.button_title_);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(AutofillRandomizedFormMetadata, _impl_.url_)
        + sizeof(AutofillRandomizedFormMetadata::_impl_.url_) - PROTOBUF_FIELD_OFFSET(AutofillRandomizedFormMetadata, _impl_.id_)>(
        reinterpret_cast<char*>(&_impl_.id_), reinterpret_cast<char*>(&other->_impl_.id_));
}

std::string AutofillRandomizedFormMetadata::GetTypeName() const
{
    return "autofill.AutofillRandomizedFormMetadata";
}

// ===================================================================

class AutofillRandomizedFieldMetadata::_Internal {
public:
    using HasBits = decltype(std::declval<AutofillRandomizedFieldMetadata>()._impl_._has_bits_);
    static const ::autofill::AutofillRandomizedValue& id(const AutofillRandomizedFieldMetadata* msg);
    static void set_has_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static const ::autofill::AutofillRandomizedValue& name(const AutofillRandomizedFieldMetadata* msg);
    static void set_has_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static const ::autofill::AutofillRandomizedValue& type(const AutofillRandomizedFieldMetadata* msg);
    static void set_has_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static const ::autofill::AutofillRandomizedValue& label(const AutofillRandomizedFieldMetadata* msg);
    static void set_has_label(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static const ::autofill::AutofillRandomizedValue& aria_label(const AutofillRandomizedFieldMetadata* msg);
    static void set_has_aria_label(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static const ::autofill::AutofillRandomizedValue& aria_description(const AutofillRandomizedFieldMetadata* msg);
    static void set_has_aria_description(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
    static const ::autofill::AutofillRandomizedValue& css_class(const AutofillRandomizedFieldMetadata* msg);
    static void set_has_css_class(HasBits* has_bits)
    {
        (*has_bits)[0] |= 64u;
    }
    static const ::autofill::AutofillRandomizedValue& placeholder(const AutofillRandomizedFieldMetadata* msg);
    static void set_has_placeholder(HasBits* has_bits)
    {
        (*has_bits)[0] |= 128u;
    }
    static const ::autofill::AutofillRandomizedValue& initial_value_hash(const AutofillRandomizedFieldMetadata* msg);
    static void set_has_initial_value_hash(HasBits* has_bits)
    {
        (*has_bits)[0] |= 256u;
    }
    static const ::autofill::AutofillRandomizedValue& autocomplete(const AutofillRandomizedFieldMetadata* msg);
    static void set_has_autocomplete(HasBits* has_bits)
    {
        (*has_bits)[0] |= 512u;
    }
};

const ::autofill::AutofillRandomizedValue& AutofillRandomizedFieldMetadata::_Internal::id(const AutofillRandomizedFieldMetadata* msg)
{
    return *msg->_impl_.id_;
}
const ::autofill::AutofillRandomizedValue& AutofillRandomizedFieldMetadata::_Internal::name(const AutofillRandomizedFieldMetadata* msg)
{
    return *msg->_impl_.name_;
}
const ::autofill::AutofillRandomizedValue& AutofillRandomizedFieldMetadata::_Internal::type(const AutofillRandomizedFieldMetadata* msg)
{
    return *msg->_impl_.type_;
}
const ::autofill::AutofillRandomizedValue& AutofillRandomizedFieldMetadata::_Internal::label(const AutofillRandomizedFieldMetadata* msg)
{
    return *msg->_impl_.label_;
}
const ::autofill::AutofillRandomizedValue& AutofillRandomizedFieldMetadata::_Internal::aria_label(const AutofillRandomizedFieldMetadata* msg)
{
    return *msg->_impl_.aria_label_;
}
const ::autofill::AutofillRandomizedValue& AutofillRandomizedFieldMetadata::_Internal::aria_description(const AutofillRandomizedFieldMetadata* msg)
{
    return *msg->_impl_.aria_description_;
}
const ::autofill::AutofillRandomizedValue& AutofillRandomizedFieldMetadata::_Internal::css_class(const AutofillRandomizedFieldMetadata* msg)
{
    return *msg->_impl_.css_class_;
}
const ::autofill::AutofillRandomizedValue& AutofillRandomizedFieldMetadata::_Internal::placeholder(const AutofillRandomizedFieldMetadata* msg)
{
    return *msg->_impl_.placeholder_;
}
const ::autofill::AutofillRandomizedValue& AutofillRandomizedFieldMetadata::_Internal::initial_value_hash(const AutofillRandomizedFieldMetadata* msg)
{
    return *msg->_impl_.initial_value_hash_;
}
const ::autofill::AutofillRandomizedValue& AutofillRandomizedFieldMetadata::_Internal::autocomplete(const AutofillRandomizedFieldMetadata* msg)
{
    return *msg->_impl_.autocomplete_;
}
AutofillRandomizedFieldMetadata::AutofillRandomizedFieldMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:autofill.AutofillRandomizedFieldMetadata)
}
AutofillRandomizedFieldMetadata::AutofillRandomizedFieldMetadata(const AutofillRandomizedFieldMetadata& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    AutofillRandomizedFieldMetadata* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.id_) { nullptr },
        decltype(_impl_.name_) { nullptr }, decltype(_impl_.type_) { nullptr }, decltype(_impl_.label_) { nullptr }, decltype(_impl_.aria_label_) { nullptr },
        decltype(_impl_.aria_description_) { nullptr }, decltype(_impl_.css_class_) { nullptr }, decltype(_impl_.placeholder_) { nullptr },
        decltype(_impl_.initial_value_hash_) { nullptr }, decltype(_impl_.autocomplete_) { nullptr } };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_id()) {
        _this->_impl_.id_ = new ::autofill::AutofillRandomizedValue(*from._impl_.id_);
    }
    if (from._internal_has_name()) {
        _this->_impl_.name_ = new ::autofill::AutofillRandomizedValue(*from._impl_.name_);
    }
    if (from._internal_has_type()) {
        _this->_impl_.type_ = new ::autofill::AutofillRandomizedValue(*from._impl_.type_);
    }
    if (from._internal_has_label()) {
        _this->_impl_.label_ = new ::autofill::AutofillRandomizedValue(*from._impl_.label_);
    }
    if (from._internal_has_aria_label()) {
        _this->_impl_.aria_label_ = new ::autofill::AutofillRandomizedValue(*from._impl_.aria_label_);
    }
    if (from._internal_has_aria_description()) {
        _this->_impl_.aria_description_ = new ::autofill::AutofillRandomizedValue(*from._impl_.aria_description_);
    }
    if (from._internal_has_css_class()) {
        _this->_impl_.css_class_ = new ::autofill::AutofillRandomizedValue(*from._impl_.css_class_);
    }
    if (from._internal_has_placeholder()) {
        _this->_impl_.placeholder_ = new ::autofill::AutofillRandomizedValue(*from._impl_.placeholder_);
    }
    if (from._internal_has_initial_value_hash()) {
        _this->_impl_.initial_value_hash_ = new ::autofill::AutofillRandomizedValue(*from._impl_.initial_value_hash_);
    }
    if (from._internal_has_autocomplete()) {
        _this->_impl_.autocomplete_ = new ::autofill::AutofillRandomizedValue(*from._impl_.autocomplete_);
    }
    // @@protoc_insertion_point(copy_constructor:autofill.AutofillRandomizedFieldMetadata)
}

inline void AutofillRandomizedFieldMetadata::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.id_) { nullptr },
        decltype(_impl_.name_) { nullptr }, decltype(_impl_.type_) { nullptr }, decltype(_impl_.label_) { nullptr }, decltype(_impl_.aria_label_) { nullptr },
        decltype(_impl_.aria_description_) { nullptr }, decltype(_impl_.css_class_) { nullptr }, decltype(_impl_.placeholder_) { nullptr },
        decltype(_impl_.initial_value_hash_) { nullptr }, decltype(_impl_.autocomplete_) { nullptr } };
}

AutofillRandomizedFieldMetadata::~AutofillRandomizedFieldMetadata()
{
    // @@protoc_insertion_point(destructor:autofill.AutofillRandomizedFieldMetadata)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void AutofillRandomizedFieldMetadata::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (this != internal_default_instance())
        delete _impl_.id_;
    if (this != internal_default_instance())
        delete _impl_.name_;
    if (this != internal_default_instance())
        delete _impl_.type_;
    if (this != internal_default_instance())
        delete _impl_.label_;
    if (this != internal_default_instance())
        delete _impl_.aria_label_;
    if (this != internal_default_instance())
        delete _impl_.aria_description_;
    if (this != internal_default_instance())
        delete _impl_.css_class_;
    if (this != internal_default_instance())
        delete _impl_.placeholder_;
    if (this != internal_default_instance())
        delete _impl_.initial_value_hash_;
    if (this != internal_default_instance())
        delete _impl_.autocomplete_;
}

void AutofillRandomizedFieldMetadata::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void AutofillRandomizedFieldMetadata::Clear()
{
    // @@protoc_insertion_point(message_clear_start:autofill.AutofillRandomizedFieldMetadata)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        if (cached_has_bits & 0x00000001u) {
            GOOGLE_DCHECK(_impl_.id_ != nullptr);
            _impl_.id_->Clear();
        }
        if (cached_has_bits & 0x00000002u) {
            GOOGLE_DCHECK(_impl_.name_ != nullptr);
            _impl_.name_->Clear();
        }
        if (cached_has_bits & 0x00000004u) {
            GOOGLE_DCHECK(_impl_.type_ != nullptr);
            _impl_.type_->Clear();
        }
        if (cached_has_bits & 0x00000008u) {
            GOOGLE_DCHECK(_impl_.label_ != nullptr);
            _impl_.label_->Clear();
        }
        if (cached_has_bits & 0x00000010u) {
            GOOGLE_DCHECK(_impl_.aria_label_ != nullptr);
            _impl_.aria_label_->Clear();
        }
        if (cached_has_bits & 0x00000020u) {
            GOOGLE_DCHECK(_impl_.aria_description_ != nullptr);
            _impl_.aria_description_->Clear();
        }
        if (cached_has_bits & 0x00000040u) {
            GOOGLE_DCHECK(_impl_.css_class_ != nullptr);
            _impl_.css_class_->Clear();
        }
        if (cached_has_bits & 0x00000080u) {
            GOOGLE_DCHECK(_impl_.placeholder_ != nullptr);
            _impl_.placeholder_->Clear();
        }
    }
    if (cached_has_bits & 0x00000300u) {
        if (cached_has_bits & 0x00000100u) {
            GOOGLE_DCHECK(_impl_.initial_value_hash_ != nullptr);
            _impl_.initial_value_hash_->Clear();
        }
        if (cached_has_bits & 0x00000200u) {
            GOOGLE_DCHECK(_impl_.autocomplete_ != nullptr);
            _impl_.autocomplete_->Clear();
        }
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* AutofillRandomizedFieldMetadata::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .autofill.AutofillRandomizedValue id = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_id(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .autofill.AutofillRandomizedValue name = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_name(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .autofill.AutofillRandomizedValue type = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr = ctx->ParseMessage(_internal_mutable_type(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .autofill.AutofillRandomizedValue label = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr = ctx->ParseMessage(_internal_mutable_label(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .autofill.AutofillRandomizedValue aria_label = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                ptr = ctx->ParseMessage(_internal_mutable_aria_label(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .autofill.AutofillRandomizedValue aria_description = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
                ptr = ctx->ParseMessage(_internal_mutable_aria_description(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .autofill.AutofillRandomizedValue css_class = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
                ptr = ctx->ParseMessage(_internal_mutable_css_class(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .autofill.AutofillRandomizedValue placeholder = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
                ptr = ctx->ParseMessage(_internal_mutable_placeholder(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .autofill.AutofillRandomizedValue initial_value_hash = 9;
        case 9:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
                ptr = ctx->ParseMessage(_internal_mutable_initial_value_hash(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .autofill.AutofillRandomizedValue autocomplete = 10;
        case 10:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
                ptr = ctx->ParseMessage(_internal_mutable_autocomplete(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* AutofillRandomizedFieldMetadata::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:autofill.AutofillRandomizedFieldMetadata)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .autofill.AutofillRandomizedValue id = 1;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::id(this), _Internal::id(this).GetCachedSize(), target, stream);
    }

    // optional .autofill.AutofillRandomizedValue name = 2;
    if (cached_has_bits & 0x00000002u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::name(this), _Internal::name(this).GetCachedSize(), target, stream);
    }

    // optional .autofill.AutofillRandomizedValue type = 3;
    if (cached_has_bits & 0x00000004u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            3, _Internal::type(this), _Internal::type(this).GetCachedSize(), target, stream);
    }

    // optional .autofill.AutofillRandomizedValue label = 4;
    if (cached_has_bits & 0x00000008u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            4, _Internal::label(this), _Internal::label(this).GetCachedSize(), target, stream);
    }

    // optional .autofill.AutofillRandomizedValue aria_label = 5;
    if (cached_has_bits & 0x00000010u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            5, _Internal::aria_label(this), _Internal::aria_label(this).GetCachedSize(), target, stream);
    }

    // optional .autofill.AutofillRandomizedValue aria_description = 6;
    if (cached_has_bits & 0x00000020u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            6, _Internal::aria_description(this), _Internal::aria_description(this).GetCachedSize(), target, stream);
    }

    // optional .autofill.AutofillRandomizedValue css_class = 7;
    if (cached_has_bits & 0x00000040u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            7, _Internal::css_class(this), _Internal::css_class(this).GetCachedSize(), target, stream);
    }

    // optional .autofill.AutofillRandomizedValue placeholder = 8;
    if (cached_has_bits & 0x00000080u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            8, _Internal::placeholder(this), _Internal::placeholder(this).GetCachedSize(), target, stream);
    }

    // optional .autofill.AutofillRandomizedValue initial_value_hash = 9;
    if (cached_has_bits & 0x00000100u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            9, _Internal::initial_value_hash(this), _Internal::initial_value_hash(this).GetCachedSize(), target, stream);
    }

    // optional .autofill.AutofillRandomizedValue autocomplete = 10;
    if (cached_has_bits & 0x00000200u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            10, _Internal::autocomplete(this), _Internal::autocomplete(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:autofill.AutofillRandomizedFieldMetadata)
    return target;
}

size_t AutofillRandomizedFieldMetadata::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:autofill.AutofillRandomizedFieldMetadata)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        // optional .autofill.AutofillRandomizedValue id = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.id_);
        }

        // optional .autofill.AutofillRandomizedValue name = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.name_);
        }

        // optional .autofill.AutofillRandomizedValue type = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.type_);
        }

        // optional .autofill.AutofillRandomizedValue label = 4;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.label_);
        }

        // optional .autofill.AutofillRandomizedValue aria_label = 5;
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.aria_label_);
        }

        // optional .autofill.AutofillRandomizedValue aria_description = 6;
        if (cached_has_bits & 0x00000020u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.aria_description_);
        }

        // optional .autofill.AutofillRandomizedValue css_class = 7;
        if (cached_has_bits & 0x00000040u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.css_class_);
        }

        // optional .autofill.AutofillRandomizedValue placeholder = 8;
        if (cached_has_bits & 0x00000080u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.placeholder_);
        }
    }
    if (cached_has_bits & 0x00000300u) {
        // optional .autofill.AutofillRandomizedValue initial_value_hash = 9;
        if (cached_has_bits & 0x00000100u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.initial_value_hash_);
        }

        // optional .autofill.AutofillRandomizedValue autocomplete = 10;
        if (cached_has_bits & 0x00000200u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.autocomplete_);
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void AutofillRandomizedFieldMetadata::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const AutofillRandomizedFieldMetadata*>(&from));
}

void AutofillRandomizedFieldMetadata::MergeFrom(const AutofillRandomizedFieldMetadata& from)
{
    AutofillRandomizedFieldMetadata* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:autofill.AutofillRandomizedFieldMetadata)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_mutable_id()->::autofill::AutofillRandomizedValue::MergeFrom(from._internal_id());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_mutable_name()->::autofill::AutofillRandomizedValue::MergeFrom(from._internal_name());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_mutable_type()->::autofill::AutofillRandomizedValue::MergeFrom(from._internal_type());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_mutable_label()->::autofill::AutofillRandomizedValue::MergeFrom(from._internal_label());
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_internal_mutable_aria_label()->::autofill::AutofillRandomizedValue::MergeFrom(from._internal_aria_label());
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_internal_mutable_aria_description()->::autofill::AutofillRandomizedValue::MergeFrom(from._internal_aria_description());
        }
        if (cached_has_bits & 0x00000040u) {
            _this->_internal_mutable_css_class()->::autofill::AutofillRandomizedValue::MergeFrom(from._internal_css_class());
        }
        if (cached_has_bits & 0x00000080u) {
            _this->_internal_mutable_placeholder()->::autofill::AutofillRandomizedValue::MergeFrom(from._internal_placeholder());
        }
    }
    if (cached_has_bits & 0x00000300u) {
        if (cached_has_bits & 0x00000100u) {
            _this->_internal_mutable_initial_value_hash()->::autofill::AutofillRandomizedValue::MergeFrom(from._internal_initial_value_hash());
        }
        if (cached_has_bits & 0x00000200u) {
            _this->_internal_mutable_autocomplete()->::autofill::AutofillRandomizedValue::MergeFrom(from._internal_autocomplete());
        }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AutofillRandomizedFieldMetadata::CopyFrom(const AutofillRandomizedFieldMetadata& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:autofill.AutofillRandomizedFieldMetadata)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool AutofillRandomizedFieldMetadata::IsInitialized() const
{
    return true;
}

void AutofillRandomizedFieldMetadata::InternalSwap(AutofillRandomizedFieldMetadata* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(AutofillRandomizedFieldMetadata, _impl_.autocomplete_)
        + sizeof(AutofillRandomizedFieldMetadata::_impl_.autocomplete_) - PROTOBUF_FIELD_OFFSET(AutofillRandomizedFieldMetadata, _impl_.id_)>(
        reinterpret_cast<char*>(&_impl_.id_), reinterpret_cast<char*>(&other->_impl_.id_));
}

std::string AutofillRandomizedFieldMetadata::GetTypeName() const
{
    return "autofill.AutofillRandomizedFieldMetadata";
}

// ===================================================================

class AutofillUploadContents_Field::_Internal {
public:
    using HasBits = decltype(std::declval<AutofillUploadContents_Field>()._impl_._has_bits_);
    static void set_has_signature(HasBits* has_bits)
    {
        (*has_bits)[0] |= 64u;
    }
    static void set_has_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_autocomplete(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static const ::autofill::AutofillRandomizedFieldMetadata& randomized_field_metadata(const AutofillUploadContents_Field* msg);
    static void set_has_randomized_field_metadata(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
    static void set_has_generation_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 128u;
    }
    static void set_has_css_classes(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_properties_mask(HasBits* has_bits)
    {
        (*has_bits)[0] |= 256u;
    }
    static void set_has_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static void set_has_generated_password_changed(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1024u;
    }
    static void set_has_vote_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 512u;
    }
    static void set_has_initial_value_hash(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8192u;
    }
    static void set_has_single_username_vote_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16384u;
    }
    static void set_has_is_most_recent_single_username_candidate(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2048u;
    }
    static void set_has_initial_value_changed(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4096u;
    }
    static bool MissingRequiredFields(const HasBits& has_bits)
    {
        return ((has_bits[0] & 0x00000040) ^ 0x00000040) != 0;
    }
};

const ::autofill::AutofillRandomizedFieldMetadata& AutofillUploadContents_Field::_Internal::randomized_field_metadata(const AutofillUploadContents_Field* msg)
{
    return *msg->_impl_.randomized_field_metadata_;
}
AutofillUploadContents_Field::AutofillUploadContents_Field(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:autofill.AutofillUploadContents.Field)
}
AutofillUploadContents_Field::AutofillUploadContents_Field(const AutofillUploadContents_Field& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    AutofillUploadContents_Field* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.autofill_type_) { from._impl_.autofill_type_ }, decltype(_impl_.name_) {}, decltype(_impl_.autocomplete_) {}, decltype(_impl_.type_) {},
        decltype(_impl_.css_classes_) {}, decltype(_impl_.id_) {}, decltype(_impl_.randomized_field_metadata_) { nullptr }, decltype(_impl_.signature_) {},
        decltype(_impl_.generation_type_) {}, decltype(_impl_.properties_mask_) {}, decltype(_impl_.vote_type_) {},
        decltype(_impl_.generated_password_changed_) {}, decltype(_impl_.is_most_recent_single_username_candidate_) {},
        decltype(_impl_.initial_value_changed_) {}, decltype(_impl_.initial_value_hash_) {}, decltype(_impl_.single_username_vote_type_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_name()) {
        _this->_impl_.name_.Set(from._internal_name(), _this->GetArenaForAllocation());
    }
    _impl_.autocomplete_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.autocomplete_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_autocomplete()) {
        _this->_impl_.autocomplete_.Set(from._internal_autocomplete(), _this->GetArenaForAllocation());
    }
    _impl_.type_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_type()) {
        _this->_impl_.type_.Set(from._internal_type(), _this->GetArenaForAllocation());
    }
    _impl_.css_classes_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.css_classes_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_css_classes()) {
        _this->_impl_.css_classes_.Set(from._internal_css_classes(), _this->GetArenaForAllocation());
    }
    _impl_.id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_id()) {
        _this->_impl_.id_.Set(from._internal_id(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_randomized_field_metadata()) {
        _this->_impl_.randomized_field_metadata_ = new ::autofill::AutofillRandomizedFieldMetadata(*from._impl_.randomized_field_metadata_);
    }
    ::memcpy(&_impl_.signature_, &from._impl_.signature_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.single_username_vote_type_) - reinterpret_cast<char*>(&_impl_.signature_))
            + sizeof(_impl_.single_username_vote_type_));
    // @@protoc_insertion_point(copy_constructor:autofill.AutofillUploadContents.Field)
}

inline void AutofillUploadContents_Field::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.autofill_type_) { arena },
        decltype(_impl_.name_) {}, decltype(_impl_.autocomplete_) {}, decltype(_impl_.type_) {}, decltype(_impl_.css_classes_) {}, decltype(_impl_.id_) {},
        decltype(_impl_.randomized_field_metadata_) { nullptr }, decltype(_impl_.signature_) { 0u }, decltype(_impl_.generation_type_) { 0 },
        decltype(_impl_.properties_mask_) { 0u }, decltype(_impl_.vote_type_) { 0 }, decltype(_impl_.generated_password_changed_) { false },
        decltype(_impl_.is_most_recent_single_username_candidate_) { false }, decltype(_impl_.initial_value_changed_) { false },
        decltype(_impl_.initial_value_hash_) { 0u }, decltype(_impl_.single_username_vote_type_) { 0 } };
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.autocomplete_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.autocomplete_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.css_classes_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.css_classes_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AutofillUploadContents_Field::~AutofillUploadContents_Field()
{
    // @@protoc_insertion_point(destructor:autofill.AutofillUploadContents.Field)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void AutofillUploadContents_Field::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.autofill_type_.~RepeatedField();
    _impl_.name_.Destroy();
    _impl_.autocomplete_.Destroy();
    _impl_.type_.Destroy();
    _impl_.css_classes_.Destroy();
    _impl_.id_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.randomized_field_metadata_;
}

void AutofillUploadContents_Field::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void AutofillUploadContents_Field::Clear()
{
    // @@protoc_insertion_point(message_clear_start:autofill.AutofillUploadContents.Field)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.autofill_type_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000003fu) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.name_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.autocomplete_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            _impl_.type_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000008u) {
            _impl_.css_classes_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000010u) {
            _impl_.id_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000020u) {
            GOOGLE_DCHECK(_impl_.randomized_field_metadata_ != nullptr);
            _impl_.randomized_field_metadata_->Clear();
        }
    }
    if (cached_has_bits & 0x000000c0u) {
        ::memset(&_impl_.signature_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.generation_type_) - reinterpret_cast<char*>(&_impl_.signature_))
                + sizeof(_impl_.generation_type_));
    }
    if (cached_has_bits & 0x00007f00u) {
        ::memset(&_impl_.properties_mask_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.single_username_vote_type_) - reinterpret_cast<char*>(&_impl_.properties_mask_))
                + sizeof(_impl_.single_username_vote_type_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* AutofillUploadContents_Field::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // required fixed32 signature = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
                _Internal::set_has_signature(&has_bits);
                _impl_.signature_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
                ptr += sizeof(uint32_t);
            } else
                goto handle_unusual;
            continue;
        // repeated fixed32 autofill_type = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    _internal_add_autofill_type(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr));
                    ptr += sizeof(uint32_t);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<61>(ptr));
            } else if (static_cast<uint8_t>(tag) == 58) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFixed32Parser(_internal_mutable_autofill_type(), ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string name = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
                auto str = _internal_mutable_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string autocomplete = 9;
        case 9:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
                auto str = _internal_mutable_autocomplete();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string type = 10;
        case 10:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
                auto str = _internal_mutable_type();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .autofill.AutofillUploadContents.Field.PasswordGenerationType generation_type = 17;
        case 17:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::autofill::AutofillUploadContents_Field_PasswordGenerationType_IsValid(val))) {
                    _internal_set_generation_type(static_cast<::autofill::AutofillUploadContents_Field_PasswordGenerationType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(17, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional string css_classes = 19;
        case 19:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
                auto str = _internal_mutable_css_classes();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional uint32 properties_mask = 20;
        case 20:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
                _Internal::set_has_properties_mask(&has_bits);
                _impl_.properties_mask_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string id = 21;
        case 21:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
                auto str = _internal_mutable_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool generated_password_changed = 22;
        case 22:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
                _Internal::set_has_generated_password_changed(&has_bits);
                _impl_.generated_password_changed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .autofill.AutofillUploadContents.Field.VoteType vote_type = 23;
        case 23:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 184)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::autofill::AutofillUploadContents_Field_VoteType_IsValid(val))) {
                    _internal_set_vote_type(static_cast<::autofill::AutofillUploadContents_Field_VoteType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(23, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional .autofill.AutofillRandomizedFieldMetadata randomized_field_metadata = 33;
        case 33:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_randomized_field_metadata(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional uint32 initial_value_hash = 40;
        case 40:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
                _Internal::set_has_initial_value_hash(&has_bits);
                _impl_.initial_value_hash_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .autofill.AutofillUploadContents.Field.SingleUsernameVoteType single_username_vote_type = 41;
        case 41:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::autofill::AutofillUploadContents_Field_SingleUsernameVoteType_IsValid(val))) {
                    _internal_set_single_username_vote_type(static_cast<::autofill::AutofillUploadContents_Field_SingleUsernameVoteType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(41, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional bool is_most_recent_single_username_candidate = 46;
        case 46:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
                _Internal::set_has_is_most_recent_single_username_candidate(&has_bits);
                _impl_.is_most_recent_single_username_candidate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool initial_value_changed = 47;
        case 47:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
                _Internal::set_has_initial_value_changed(&has_bits);
                _impl_.initial_value_changed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* AutofillUploadContents_Field::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:autofill.AutofillUploadContents.Field)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // required fixed32 signature = 6;
    if (cached_has_bits & 0x00000040u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteFixed32ToArray(6, this->_internal_signature(), target);
    }

    // repeated fixed32 autofill_type = 7;
    for (int i = 0, n = this->_internal_autofill_type_size(); i < n; i++) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteFixed32ToArray(7, this->_internal_autofill_type(i), target);
    }

    // optional string name = 8;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(8, this->_internal_name(), target);
    }

    // optional string autocomplete = 9;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(9, this->_internal_autocomplete(), target);
    }

    // optional string type = 10;
    if (cached_has_bits & 0x00000004u) {
        target = stream->WriteStringMaybeAliased(10, this->_internal_type(), target);
    }

    // optional .autofill.AutofillUploadContents.Field.PasswordGenerationType generation_type = 17;
    if (cached_has_bits & 0x00000080u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(17, this->_internal_generation_type(), target);
    }

    // optional string css_classes = 19;
    if (cached_has_bits & 0x00000008u) {
        target = stream->WriteStringMaybeAliased(19, this->_internal_css_classes(), target);
    }

    // optional uint32 properties_mask = 20;
    if (cached_has_bits & 0x00000100u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(20, this->_internal_properties_mask(), target);
    }

    // optional string id = 21;
    if (cached_has_bits & 0x00000010u) {
        target = stream->WriteStringMaybeAliased(21, this->_internal_id(), target);
    }

    // optional bool generated_password_changed = 22;
    if (cached_has_bits & 0x00000400u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(22, this->_internal_generated_password_changed(), target);
    }

    // optional .autofill.AutofillUploadContents.Field.VoteType vote_type = 23;
    if (cached_has_bits & 0x00000200u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(23, this->_internal_vote_type(), target);
    }

    // optional .autofill.AutofillRandomizedFieldMetadata randomized_field_metadata = 33;
    if (cached_has_bits & 0x00000020u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            33, _Internal::randomized_field_metadata(this), _Internal::randomized_field_metadata(this).GetCachedSize(), target, stream);
    }

    // optional uint32 initial_value_hash = 40;
    if (cached_has_bits & 0x00002000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(40, this->_internal_initial_value_hash(), target);
    }

    // optional .autofill.AutofillUploadContents.Field.SingleUsernameVoteType single_username_vote_type = 41;
    if (cached_has_bits & 0x00004000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(41, this->_internal_single_username_vote_type(), target);
    }

    // optional bool is_most_recent_single_username_candidate = 46;
    if (cached_has_bits & 0x00000800u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(46, this->_internal_is_most_recent_single_username_candidate(), target);
    }

    // optional bool initial_value_changed = 47;
    if (cached_has_bits & 0x00001000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(47, this->_internal_initial_value_changed(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:autofill.AutofillUploadContents.Field)
    return target;
}

size_t AutofillUploadContents_Field::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:autofill.AutofillUploadContents.Field)
    size_t total_size = 0;

    // required fixed32 signature = 6;
    if (_internal_has_signature()) {
        total_size += 1 + 4;
    }
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated fixed32 autofill_type = 7;
    {
        unsigned int count = static_cast<unsigned int>(this->_internal_autofill_type_size());
        size_t data_size = 4UL * count;
        total_size += 1 * ::_pbi::FromIntSize(this->_internal_autofill_type_size());
        total_size += data_size;
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000003fu) {
        // optional string name = 8;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_name());
        }

        // optional string autocomplete = 9;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_autocomplete());
        }

        // optional string type = 10;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_type());
        }

        // optional string css_classes = 19;
        if (cached_has_bits & 0x00000008u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_css_classes());
        }

        // optional string id = 21;
        if (cached_has_bits & 0x00000010u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_id());
        }

        // optional .autofill.AutofillRandomizedFieldMetadata randomized_field_metadata = 33;
        if (cached_has_bits & 0x00000020u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.randomized_field_metadata_);
        }
    }
    // optional .autofill.AutofillUploadContents.Field.PasswordGenerationType generation_type = 17;
    if (cached_has_bits & 0x00000080u) {
        total_size += 2 + ::_pbi::WireFormatLite::EnumSize(this->_internal_generation_type());
    }

    if (cached_has_bits & 0x00007f00u) {
        // optional uint32 properties_mask = 20;
        if (cached_has_bits & 0x00000100u) {
            total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(this->_internal_properties_mask());
        }

        // optional .autofill.AutofillUploadContents.Field.VoteType vote_type = 23;
        if (cached_has_bits & 0x00000200u) {
            total_size += 2 + ::_pbi::WireFormatLite::EnumSize(this->_internal_vote_type());
        }

        // optional bool generated_password_changed = 22;
        if (cached_has_bits & 0x00000400u) {
            total_size += 2 + 1;
        }

        // optional bool is_most_recent_single_username_candidate = 46;
        if (cached_has_bits & 0x00000800u) {
            total_size += 2 + 1;
        }

        // optional bool initial_value_changed = 47;
        if (cached_has_bits & 0x00001000u) {
            total_size += 2 + 1;
        }

        // optional uint32 initial_value_hash = 40;
        if (cached_has_bits & 0x00002000u) {
            total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(this->_internal_initial_value_hash());
        }

        // optional .autofill.AutofillUploadContents.Field.SingleUsernameVoteType single_username_vote_type = 41;
        if (cached_has_bits & 0x00004000u) {
            total_size += 2 + ::_pbi::WireFormatLite::EnumSize(this->_internal_single_username_vote_type());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void AutofillUploadContents_Field::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const AutofillUploadContents_Field*>(&from));
}

void AutofillUploadContents_Field::MergeFrom(const AutofillUploadContents_Field& from)
{
    AutofillUploadContents_Field* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:autofill.AutofillUploadContents.Field)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.autofill_type_.MergeFrom(from._impl_.autofill_type_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_name(from._internal_name());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_autocomplete(from._internal_autocomplete());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_set_type(from._internal_type());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_set_css_classes(from._internal_css_classes());
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_internal_set_id(from._internal_id());
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_internal_mutable_randomized_field_metadata()->::autofill::AutofillRandomizedFieldMetadata::MergeFrom(
                from._internal_randomized_field_metadata());
        }
        if (cached_has_bits & 0x00000040u) {
            _this->_impl_.signature_ = from._impl_.signature_;
        }
        if (cached_has_bits & 0x00000080u) {
            _this->_impl_.generation_type_ = from._impl_.generation_type_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    if (cached_has_bits & 0x00007f00u) {
        if (cached_has_bits & 0x00000100u) {
            _this->_impl_.properties_mask_ = from._impl_.properties_mask_;
        }
        if (cached_has_bits & 0x00000200u) {
            _this->_impl_.vote_type_ = from._impl_.vote_type_;
        }
        if (cached_has_bits & 0x00000400u) {
            _this->_impl_.generated_password_changed_ = from._impl_.generated_password_changed_;
        }
        if (cached_has_bits & 0x00000800u) {
            _this->_impl_.is_most_recent_single_username_candidate_ = from._impl_.is_most_recent_single_username_candidate_;
        }
        if (cached_has_bits & 0x00001000u) {
            _this->_impl_.initial_value_changed_ = from._impl_.initial_value_changed_;
        }
        if (cached_has_bits & 0x00002000u) {
            _this->_impl_.initial_value_hash_ = from._impl_.initial_value_hash_;
        }
        if (cached_has_bits & 0x00004000u) {
            _this->_impl_.single_username_vote_type_ = from._impl_.single_username_vote_type_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AutofillUploadContents_Field::CopyFrom(const AutofillUploadContents_Field& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:autofill.AutofillUploadContents.Field)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool AutofillUploadContents_Field::IsInitialized() const
{
    if (_Internal::MissingRequiredFields(_impl_._has_bits_))
        return false;
    return true;
}

void AutofillUploadContents_Field::InternalSwap(AutofillUploadContents_Field* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.autofill_type_.InternalSwap(&other->_impl_.autofill_type_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.name_, lhs_arena, &other->_impl_.name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.autocomplete_, lhs_arena, &other->_impl_.autocomplete_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.type_, lhs_arena, &other->_impl_.type_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.css_classes_, lhs_arena, &other->_impl_.css_classes_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.id_, lhs_arena, &other->_impl_.id_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(AutofillUploadContents_Field, _impl_.single_username_vote_type_)
        + sizeof(AutofillUploadContents_Field::_impl_.single_username_vote_type_)
        - PROTOBUF_FIELD_OFFSET(AutofillUploadContents_Field, _impl_.randomized_field_metadata_)>(
        reinterpret_cast<char*>(&_impl_.randomized_field_metadata_), reinterpret_cast<char*>(&other->_impl_.randomized_field_metadata_));
}

std::string AutofillUploadContents_Field::GetTypeName() const
{
    return "autofill.AutofillUploadContents.Field";
}

// ===================================================================

class AutofillUploadContents_ButtonTitle::_Internal {
public:
    using HasBits = decltype(std::declval<AutofillUploadContents_ButtonTitle>()._impl_._has_bits_);
    static void set_has_title(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

AutofillUploadContents_ButtonTitle::AutofillUploadContents_ButtonTitle(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:autofill.AutofillUploadContents.ButtonTitle)
}
AutofillUploadContents_ButtonTitle::AutofillUploadContents_ButtonTitle(const AutofillUploadContents_ButtonTitle& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    AutofillUploadContents_ButtonTitle* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.title_) {},
        decltype(_impl_.type_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.title_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_title()) {
        _this->_impl_.title_.Set(from._internal_title(), _this->GetArenaForAllocation());
    }
    _this->_impl_.type_ = from._impl_.type_;
    // @@protoc_insertion_point(copy_constructor:autofill.AutofillUploadContents.ButtonTitle)
}

inline void AutofillUploadContents_ButtonTitle::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.title_) {}, decltype(_impl_.type_) { 0 } };
    _impl_.title_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AutofillUploadContents_ButtonTitle::~AutofillUploadContents_ButtonTitle()
{
    // @@protoc_insertion_point(destructor:autofill.AutofillUploadContents.ButtonTitle)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void AutofillUploadContents_ButtonTitle::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.title_.Destroy();
}

void AutofillUploadContents_ButtonTitle::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void AutofillUploadContents_ButtonTitle::Clear()
{
    // @@protoc_insertion_point(message_clear_start:autofill.AutofillUploadContents.ButtonTitle)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.title_.ClearNonDefaultToEmpty();
    }
    _impl_.type_ = 0;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* AutofillUploadContents_ButtonTitle::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string title = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_title();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .autofill.ButtonTitleType type = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::autofill::ButtonTitleType_IsValid(val))) {
                    _internal_set_type(static_cast<::autofill::ButtonTitleType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* AutofillUploadContents_ButtonTitle::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:autofill.AutofillUploadContents.ButtonTitle)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string title = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_title(), target);
    }

    // optional .autofill.ButtonTitleType type = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(2, this->_internal_type(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:autofill.AutofillUploadContents.ButtonTitle)
    return target;
}

size_t AutofillUploadContents_ButtonTitle::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:autofill.AutofillUploadContents.ButtonTitle)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional string title = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_title());
        }

        // optional .autofill.ButtonTitleType type = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void AutofillUploadContents_ButtonTitle::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const AutofillUploadContents_ButtonTitle*>(&from));
}

void AutofillUploadContents_ButtonTitle::MergeFrom(const AutofillUploadContents_ButtonTitle& from)
{
    AutofillUploadContents_ButtonTitle* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:autofill.AutofillUploadContents.ButtonTitle)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_title(from._internal_title());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.type_ = from._impl_.type_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AutofillUploadContents_ButtonTitle::CopyFrom(const AutofillUploadContents_ButtonTitle& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:autofill.AutofillUploadContents.ButtonTitle)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool AutofillUploadContents_ButtonTitle::IsInitialized() const
{
    return true;
}

void AutofillUploadContents_ButtonTitle::InternalSwap(AutofillUploadContents_ButtonTitle* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.title_, lhs_arena, &other->_impl_.title_, rhs_arena);
    swap(_impl_.type_, other->_impl_.type_);
}

std::string AutofillUploadContents_ButtonTitle::GetTypeName() const
{
    return "autofill.AutofillUploadContents.ButtonTitle";
}

// ===================================================================

class AutofillUploadContents_SingleUsernameData::_Internal {
public:
    using HasBits = decltype(std::declval<AutofillUploadContents_SingleUsernameData>()._impl_._has_bits_);
    static void set_has_username_form_signature(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_username_field_signature(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_value_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_prompt_edit(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
};

AutofillUploadContents_SingleUsernameData::AutofillUploadContents_SingleUsernameData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:autofill.AutofillUploadContents.SingleUsernameData)
}
AutofillUploadContents_SingleUsernameData::AutofillUploadContents_SingleUsernameData(const AutofillUploadContents_SingleUsernameData& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    AutofillUploadContents_SingleUsernameData* const _this = this;
    (void)_this;
    new (&_impl_)
        Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.username_form_signature_) {},
            decltype(_impl_.username_field_signature_) {}, decltype(_impl_.value_type_) {}, decltype(_impl_.prompt_edit_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.username_form_signature_, &from._impl_.username_form_signature_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.prompt_edit_) - reinterpret_cast<char*>(&_impl_.username_form_signature_))
            + sizeof(_impl_.prompt_edit_));
    // @@protoc_insertion_point(copy_constructor:autofill.AutofillUploadContents.SingleUsernameData)
}

inline void AutofillUploadContents_SingleUsernameData::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.username_form_signature_) { uint64_t { 0u } },
        decltype(_impl_.username_field_signature_) { 0u }, decltype(_impl_.value_type_) { 0 }, decltype(_impl_.prompt_edit_) { 0 } };
}

AutofillUploadContents_SingleUsernameData::~AutofillUploadContents_SingleUsernameData()
{
    // @@protoc_insertion_point(destructor:autofill.AutofillUploadContents.SingleUsernameData)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void AutofillUploadContents_SingleUsernameData::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AutofillUploadContents_SingleUsernameData::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void AutofillUploadContents_SingleUsernameData::Clear()
{
    // @@protoc_insertion_point(message_clear_start:autofill.AutofillUploadContents.SingleUsernameData)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        ::memset(&_impl_.username_form_signature_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.prompt_edit_) - reinterpret_cast<char*>(&_impl_.username_form_signature_))
                + sizeof(_impl_.prompt_edit_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* AutofillUploadContents_SingleUsernameData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional fixed64 username_form_signature = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
                _Internal::set_has_username_form_signature(&has_bits);
                _impl_.username_form_signature_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
                ptr += sizeof(uint64_t);
            } else
                goto handle_unusual;
            continue;
        // optional fixed32 username_field_signature = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
                _Internal::set_has_username_field_signature(&has_bits);
                _impl_.username_field_signature_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
                ptr += sizeof(uint32_t);
            } else
                goto handle_unusual;
            continue;
        // optional .autofill.AutofillUploadContents.ValueType value_type = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::autofill::AutofillUploadContents_ValueType_IsValid(val))) {
                    _internal_set_value_type(static_cast<::autofill::AutofillUploadContents_ValueType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional .autofill.AutofillUploadContents.SingleUsernamePromptEdit prompt_edit = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::autofill::AutofillUploadContents_SingleUsernamePromptEdit_IsValid(val))) {
                    _internal_set_prompt_edit(static_cast<::autofill::AutofillUploadContents_SingleUsernamePromptEdit>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* AutofillUploadContents_SingleUsernameData::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:autofill.AutofillUploadContents.SingleUsernameData)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional fixed64 username_form_signature = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_username_form_signature(), target);
    }

    // optional fixed32 username_field_signature = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteFixed32ToArray(2, this->_internal_username_field_signature(), target);
    }

    // optional .autofill.AutofillUploadContents.ValueType value_type = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(3, this->_internal_value_type(), target);
    }

    // optional .autofill.AutofillUploadContents.SingleUsernamePromptEdit prompt_edit = 4;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(4, this->_internal_prompt_edit(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:autofill.AutofillUploadContents.SingleUsernameData)
    return target;
}

size_t AutofillUploadContents_SingleUsernameData::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:autofill.AutofillUploadContents.SingleUsernameData)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        // optional fixed64 username_form_signature = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + 8;
        }

        // optional fixed32 username_field_signature = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + 4;
        }

        // optional .autofill.AutofillUploadContents.ValueType value_type = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_value_type());
        }

        // optional .autofill.AutofillUploadContents.SingleUsernamePromptEdit prompt_edit = 4;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_prompt_edit());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void AutofillUploadContents_SingleUsernameData::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const AutofillUploadContents_SingleUsernameData*>(&from));
}

void AutofillUploadContents_SingleUsernameData::MergeFrom(const AutofillUploadContents_SingleUsernameData& from)
{
    AutofillUploadContents_SingleUsernameData* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:autofill.AutofillUploadContents.SingleUsernameData)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_impl_.username_form_signature_ = from._impl_.username_form_signature_;
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.username_field_signature_ = from._impl_.username_field_signature_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.value_type_ = from._impl_.value_type_;
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.prompt_edit_ = from._impl_.prompt_edit_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AutofillUploadContents_SingleUsernameData::CopyFrom(const AutofillUploadContents_SingleUsernameData& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:autofill.AutofillUploadContents.SingleUsernameData)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool AutofillUploadContents_SingleUsernameData::IsInitialized() const
{
    return true;
}

void AutofillUploadContents_SingleUsernameData::InternalSwap(AutofillUploadContents_SingleUsernameData* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(AutofillUploadContents_SingleUsernameData, _impl_.prompt_edit_)
        + sizeof(AutofillUploadContents_SingleUsernameData::_impl_.prompt_edit_)
        - PROTOBUF_FIELD_OFFSET(AutofillUploadContents_SingleUsernameData, _impl_.username_form_signature_)>(
        reinterpret_cast<char*>(&_impl_.username_form_signature_), reinterpret_cast<char*>(&other->_impl_.username_form_signature_));
}

std::string AutofillUploadContents_SingleUsernameData::GetTypeName() const
{
    return "autofill.AutofillUploadContents.SingleUsernameData";
}

// ===================================================================

class AutofillUploadContents::_Internal {
public:
    using HasBits = decltype(std::declval<AutofillUploadContents>()._impl_._has_bits_);
    static void set_has_client_version(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_form_signature(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
    static void set_has_secondary_form_signature(HasBits* has_bits)
    {
        (*has_bits)[0] |= 262144u;
    }
    static void set_has_autofill_used(HasBits* has_bits)
    {
        (*has_bits)[0] |= 256u;
    }
    static void set_has_data_present(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_action_signature(HasBits* has_bits)
    {
        (*has_bits)[0] |= 64u;
    }
    static void set_has_login_form_signature(HasBits* has_bits)
    {
        (*has_bits)[0] |= 128u;
    }
    static void set_has_submission(HasBits* has_bits)
    {
        (*has_bits)[0] |= 512u;
    }
    static void set_has_form_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_passwords_revealed(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1024u;
    }
    static void set_has_password_has_letter(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2048u;
    }
    static void set_has_password_has_uppercase_letter(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8192u;
    }
    static void set_has_password_has_numeric(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16384u;
    }
    static void set_has_password_has_special_symbol(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32768u;
    }
    static void set_has_password_length(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4096u;
    }
    static void set_has_password_special_symbol(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1048576u;
    }
    static void set_has_submission_event(HasBits* has_bits)
    {
        (*has_bits)[0] |= 131072u;
    }
    static void set_has_language(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static const ::autofill::AutofillRandomizedFormMetadata& randomized_form_metadata(const AutofillUploadContents* msg);
    static void set_has_randomized_form_metadata(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static void set_has_has_form_tag(HasBits* has_bits)
    {
        (*has_bits)[0] |= 65536u;
    }
    static void set_has_was_throttleable(HasBits* has_bits)
    {
        (*has_bits)[0] |= 524288u;
    }
    static void set_has_last_address_form_submitted(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2097152u;
    }
    static void set_has_second_last_address_form_submitted(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4194304u;
    }
    static void set_has_last_credit_card_form_submitted(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8388608u;
    }
    static bool MissingRequiredFields(const HasBits& has_bits)
    {
        return ((has_bits[0] & 0x00000123) ^ 0x00000123) != 0;
    }
};

const ::autofill::AutofillRandomizedFormMetadata& AutofillUploadContents::_Internal::randomized_form_metadata(const AutofillUploadContents* msg)
{
    return *msg->_impl_.randomized_form_metadata_;
}
AutofillUploadContents::AutofillUploadContents(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:autofill.AutofillUploadContents)
}
AutofillUploadContents::AutofillUploadContents(const AutofillUploadContents& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    AutofillUploadContents* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.button_title_) { from._impl_.button_title_ }, decltype(_impl_.single_username_data_) { from._impl_.single_username_data_ },
        decltype(_impl_.field_data_) { from._impl_.field_data_ }, decltype(_impl_.client_version_) {}, decltype(_impl_.data_present_) {},
        decltype(_impl_.form_name_) {}, decltype(_impl_.language_) {}, decltype(_impl_.randomized_form_metadata_) { nullptr },
        decltype(_impl_.form_signature_) {}, decltype(_impl_.action_signature_) {}, decltype(_impl_.login_form_signature_) {},
        decltype(_impl_.autofill_used_) {}, decltype(_impl_.submission_) {}, decltype(_impl_.passwords_revealed_) {}, decltype(_impl_.password_has_letter_) {},
        decltype(_impl_.password_length_) {}, decltype(_impl_.password_has_uppercase_letter_) {}, decltype(_impl_.password_has_numeric_) {},
        decltype(_impl_.password_has_special_symbol_) {}, decltype(_impl_.has_form_tag_) {}, decltype(_impl_.submission_event_) {},
        decltype(_impl_.secondary_form_signature_) {}, decltype(_impl_.was_throttleable_) {}, decltype(_impl_.password_special_symbol_) {},
        decltype(_impl_.last_address_form_submitted_) {}, decltype(_impl_.second_last_address_form_submitted_) {},
        decltype(_impl_.last_credit_card_form_submitted_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.client_version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.client_version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_client_version()) {
        _this->_impl_.client_version_.Set(from._internal_client_version(), _this->GetArenaForAllocation());
    }
    _impl_.data_present_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_present_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_data_present()) {
        _this->_impl_.data_present_.Set(from._internal_data_present(), _this->GetArenaForAllocation());
    }
    _impl_.form_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.form_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_form_name()) {
        _this->_impl_.form_name_.Set(from._internal_form_name(), _this->GetArenaForAllocation());
    }
    _impl_.language_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.language_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_language()) {
        _this->_impl_.language_.Set(from._internal_language(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_randomized_form_metadata()) {
        _this->_impl_.randomized_form_metadata_ = new ::autofill::AutofillRandomizedFormMetadata(*from._impl_.randomized_form_metadata_);
    }
    ::memcpy(&_impl_.form_signature_, &from._impl_.form_signature_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.last_credit_card_form_submitted_) - reinterpret_cast<char*>(&_impl_.form_signature_))
            + sizeof(_impl_.last_credit_card_form_submitted_));
    // @@protoc_insertion_point(copy_constructor:autofill.AutofillUploadContents)
}

inline void AutofillUploadContents::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.button_title_) { arena },
        decltype(_impl_.single_username_data_) { arena }, decltype(_impl_.field_data_) { arena }, decltype(_impl_.client_version_) {},
        decltype(_impl_.data_present_) {}, decltype(_impl_.form_name_) {}, decltype(_impl_.language_) {},
        decltype(_impl_.randomized_form_metadata_) { nullptr }, decltype(_impl_.form_signature_) { uint64_t { 0u } },
        decltype(_impl_.action_signature_) { uint64_t { 0u } }, decltype(_impl_.login_form_signature_) { uint64_t { 0u } },
        decltype(_impl_.autofill_used_) { false }, decltype(_impl_.submission_) { false }, decltype(_impl_.passwords_revealed_) { false },
        decltype(_impl_.password_has_letter_) { false }, decltype(_impl_.password_length_) { 0u }, decltype(_impl_.password_has_uppercase_letter_) { false },
        decltype(_impl_.password_has_numeric_) { false }, decltype(_impl_.password_has_special_symbol_) { false }, decltype(_impl_.has_form_tag_) { false },
        decltype(_impl_.submission_event_) { 0 }, decltype(_impl_.secondary_form_signature_) { uint64_t { 0u } }, decltype(_impl_.was_throttleable_) { false },
        decltype(_impl_.password_special_symbol_) { 0u }, decltype(_impl_.last_address_form_submitted_) { uint64_t { 0u } },
        decltype(_impl_.second_last_address_form_submitted_) { uint64_t { 0u } }, decltype(_impl_.last_credit_card_form_submitted_) { uint64_t { 0u } } };
    _impl_.client_version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.client_version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_present_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_present_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.form_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.form_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.language_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.language_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AutofillUploadContents::~AutofillUploadContents()
{
    // @@protoc_insertion_point(destructor:autofill.AutofillUploadContents)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void AutofillUploadContents::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.button_title_.~RepeatedPtrField();
    _impl_.single_username_data_.~RepeatedPtrField();
    _impl_.field_data_.~RepeatedPtrField();
    _impl_.client_version_.Destroy();
    _impl_.data_present_.Destroy();
    _impl_.form_name_.Destroy();
    _impl_.language_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.randomized_form_metadata_;
}

void AutofillUploadContents::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void AutofillUploadContents::Clear()
{
    // @@protoc_insertion_point(message_clear_start:autofill.AutofillUploadContents)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.button_title_.Clear();
    _impl_.single_username_data_.Clear();
    _impl_.field_data_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.client_version_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.data_present_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            _impl_.form_name_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000008u) {
            _impl_.language_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000010u) {
            GOOGLE_DCHECK(_impl_.randomized_form_metadata_ != nullptr);
            _impl_.randomized_form_metadata_->Clear();
        }
    }
    if (cached_has_bits & 0x000000e0u) {
        ::memset(&_impl_.form_signature_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.login_form_signature_) - reinterpret_cast<char*>(&_impl_.form_signature_))
                + sizeof(_impl_.login_form_signature_));
    }
    if (cached_has_bits & 0x0000ff00u) {
        ::memset(&_impl_.autofill_used_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.password_has_special_symbol_) - reinterpret_cast<char*>(&_impl_.autofill_used_))
                + sizeof(_impl_.password_has_special_symbol_));
    }
    if (cached_has_bits & 0x00ff0000u) {
        ::memset(&_impl_.has_form_tag_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.last_credit_card_form_submitted_) - reinterpret_cast<char*>(&_impl_.has_form_tag_))
                + sizeof(_impl_.last_credit_card_form_submitted_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* AutofillUploadContents::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // required string client_version = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_client_version();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // required fixed64 form_signature = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
                _Internal::set_has_form_signature(&has_bits);
                _impl_.form_signature_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
                ptr += sizeof(uint64_t);
            } else
                goto handle_unusual;
            continue;
        // required bool autofill_used = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_autofill_used(&has_bits);
                _impl_.autofill_used_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // required string data_present = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                auto str = _internal_mutable_data_present();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional fixed64 action_signature = 13;
        case 13:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 105)) {
                _Internal::set_has_action_signature(&has_bits);
                _impl_.action_signature_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
                ptr += sizeof(uint64_t);
            } else
                goto handle_unusual;
            continue;
        // optional fixed64 login_form_signature = 14;
        case 14:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 113)) {
                _Internal::set_has_login_form_signature(&has_bits);
                _impl_.login_form_signature_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
                ptr += sizeof(uint64_t);
            } else
                goto handle_unusual;
            continue;
        // optional bool submission = 15;
        case 15:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
                _Internal::set_has_submission(&has_bits);
                _impl_.submission_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string form_name = 16;
        case 16:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
                auto str = _internal_mutable_form_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool passwords_revealed = 24;
        case 24:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
                _Internal::set_has_passwords_revealed(&has_bits);
                _impl_.passwords_revealed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool password_has_letter = 25;
        case 25:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 200)) {
                _Internal::set_has_password_has_letter(&has_bits);
                _impl_.password_has_letter_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool password_has_uppercase_letter = 26 [deprecated = true];
        case 26:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 208)) {
                _Internal::set_has_password_has_uppercase_letter(&has_bits);
                _impl_.password_has_uppercase_letter_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool password_has_numeric = 27 [deprecated = true];
        case 27:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 216)) {
                _Internal::set_has_password_has_numeric(&has_bits);
                _impl_.password_has_numeric_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool password_has_special_symbol = 28;
        case 28:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 224)) {
                _Internal::set_has_password_has_special_symbol(&has_bits);
                _impl_.password_has_special_symbol_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional uint32 password_length = 29;
        case 29:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 232)) {
                _Internal::set_has_password_length(&has_bits);
                _impl_.password_length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .autofill.AutofillUploadContents.SubmissionIndicatorEvent submission_event = 30;
        case 30:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 240)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::autofill::AutofillUploadContents_SubmissionIndicatorEvent_IsValid(val))) {
                    _internal_set_submission_event(static_cast<::autofill::AutofillUploadContents_SubmissionIndicatorEvent>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(30, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional string language = 31;
        case 31:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 250)) {
                auto str = _internal_mutable_language();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .autofill.AutofillRandomizedFormMetadata randomized_form_metadata = 32;
        case 32:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 2)) {
                ptr = ctx->ParseMessage(_internal_mutable_randomized_form_metadata(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional fixed64 secondary_form_signature = 34;
        case 34:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
                _Internal::set_has_secondary_form_signature(&has_bits);
                _impl_.secondary_form_signature_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
                ptr += sizeof(uint64_t);
            } else
                goto handle_unusual;
            continue;
        // repeated .autofill.AutofillUploadContents.ButtonTitle button_title = 36;
        case 36:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr -= 2;
                do {
                    ptr += 2;
                    ptr = ctx->ParseMessage(_internal_add_button_title(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<290>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional bool has_form_tag = 37;
        case 37:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
                _Internal::set_has_has_form_tag(&has_bits);
                _impl_.has_form_tag_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool was_throttleable = 38 [deprecated = true];
        case 38:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
                _Internal::set_has_was_throttleable(&has_bits);
                _impl_.was_throttleable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional uint32 password_special_symbol = 39;
        case 39:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
                _Internal::set_has_password_special_symbol(&has_bits);
                _impl_.password_special_symbol_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .autofill.AutofillUploadContents.SingleUsernameData single_username_data = 42;
        case 42:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
                ptr -= 2;
                do {
                    ptr += 2;
                    ptr = ctx->ParseMessage(_internal_add_single_username_data(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<338>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional fixed64 last_address_form_submitted = 43;
        case 43:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 89)) {
                _Internal::set_has_last_address_form_submitted(&has_bits);
                _impl_.last_address_form_submitted_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
                ptr += sizeof(uint64_t);
            } else
                goto handle_unusual;
            continue;
        // optional fixed64 second_last_address_form_submitted = 44;
        case 44:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 97)) {
                _Internal::set_has_second_last_address_form_submitted(&has_bits);
                _impl_.second_last_address_form_submitted_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
                ptr += sizeof(uint64_t);
            } else
                goto handle_unusual;
            continue;
        // optional fixed64 last_credit_card_form_submitted = 45;
        case 45:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 105)) {
                _Internal::set_has_last_credit_card_form_submitted(&has_bits);
                _impl_.last_credit_card_form_submitted_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
                ptr += sizeof(uint64_t);
            } else
                goto handle_unusual;
            continue;
        // repeated .autofill.AutofillUploadContents.Field field_data = 48;
        case 48:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
                ptr -= 2;
                do {
                    ptr += 2;
                    ptr = ctx->ParseMessage(_internal_add_field_data(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<386>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* AutofillUploadContents::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:autofill.AutofillUploadContents)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // required string client_version = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_client_version(), target);
    }

    // required fixed64 form_signature = 2;
    if (cached_has_bits & 0x00000020u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteFixed64ToArray(2, this->_internal_form_signature(), target);
    }

    // required bool autofill_used = 3;
    if (cached_has_bits & 0x00000100u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_autofill_used(), target);
    }

    // required string data_present = 4;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(4, this->_internal_data_present(), target);
    }

    // optional fixed64 action_signature = 13;
    if (cached_has_bits & 0x00000040u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteFixed64ToArray(13, this->_internal_action_signature(), target);
    }

    // optional fixed64 login_form_signature = 14;
    if (cached_has_bits & 0x00000080u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteFixed64ToArray(14, this->_internal_login_form_signature(), target);
    }

    // optional bool submission = 15;
    if (cached_has_bits & 0x00000200u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(15, this->_internal_submission(), target);
    }

    // optional string form_name = 16;
    if (cached_has_bits & 0x00000004u) {
        target = stream->WriteStringMaybeAliased(16, this->_internal_form_name(), target);
    }

    // optional bool passwords_revealed = 24;
    if (cached_has_bits & 0x00000400u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(24, this->_internal_passwords_revealed(), target);
    }

    // optional bool password_has_letter = 25;
    if (cached_has_bits & 0x00000800u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(25, this->_internal_password_has_letter(), target);
    }

    // optional bool password_has_uppercase_letter = 26 [deprecated = true];
    if (cached_has_bits & 0x00002000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(26, this->_internal_password_has_uppercase_letter(), target);
    }

    // optional bool password_has_numeric = 27 [deprecated = true];
    if (cached_has_bits & 0x00004000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(27, this->_internal_password_has_numeric(), target);
    }

    // optional bool password_has_special_symbol = 28;
    if (cached_has_bits & 0x00008000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(28, this->_internal_password_has_special_symbol(), target);
    }

    // optional uint32 password_length = 29;
    if (cached_has_bits & 0x00001000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(29, this->_internal_password_length(), target);
    }

    // optional .autofill.AutofillUploadContents.SubmissionIndicatorEvent submission_event = 30;
    if (cached_has_bits & 0x00020000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(30, this->_internal_submission_event(), target);
    }

    // optional string language = 31;
    if (cached_has_bits & 0x00000008u) {
        target = stream->WriteStringMaybeAliased(31, this->_internal_language(), target);
    }

    // optional .autofill.AutofillRandomizedFormMetadata randomized_form_metadata = 32;
    if (cached_has_bits & 0x00000010u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            32, _Internal::randomized_form_metadata(this), _Internal::randomized_form_metadata(this).GetCachedSize(), target, stream);
    }

    // optional fixed64 secondary_form_signature = 34;
    if (cached_has_bits & 0x00040000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteFixed64ToArray(34, this->_internal_secondary_form_signature(), target);
    }

    // repeated .autofill.AutofillUploadContents.ButtonTitle button_title = 36;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_button_title_size()); i < n; i++) {
        const auto& repfield = this->_internal_button_title(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(36, repfield, repfield.GetCachedSize(), target, stream);
    }

    // optional bool has_form_tag = 37;
    if (cached_has_bits & 0x00010000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(37, this->_internal_has_form_tag(), target);
    }

    // optional bool was_throttleable = 38 [deprecated = true];
    if (cached_has_bits & 0x00080000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(38, this->_internal_was_throttleable(), target);
    }

    // optional uint32 password_special_symbol = 39;
    if (cached_has_bits & 0x00100000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(39, this->_internal_password_special_symbol(), target);
    }

    // repeated .autofill.AutofillUploadContents.SingleUsernameData single_username_data = 42;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_single_username_data_size()); i < n; i++) {
        const auto& repfield = this->_internal_single_username_data(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(42, repfield, repfield.GetCachedSize(), target, stream);
    }

    // optional fixed64 last_address_form_submitted = 43;
    if (cached_has_bits & 0x00200000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteFixed64ToArray(43, this->_internal_last_address_form_submitted(), target);
    }

    // optional fixed64 second_last_address_form_submitted = 44;
    if (cached_has_bits & 0x00400000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteFixed64ToArray(44, this->_internal_second_last_address_form_submitted(), target);
    }

    // optional fixed64 last_credit_card_form_submitted = 45;
    if (cached_has_bits & 0x00800000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteFixed64ToArray(45, this->_internal_last_credit_card_form_submitted(), target);
    }

    // repeated .autofill.AutofillUploadContents.Field field_data = 48;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_field_data_size()); i < n; i++) {
        const auto& repfield = this->_internal_field_data(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(48, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:autofill.AutofillUploadContents)
    return target;
}

size_t AutofillUploadContents::RequiredFieldsByteSizeFallback() const
{
    // @@protoc_insertion_point(required_fields_byte_size_fallback_start:autofill.AutofillUploadContents)
    size_t total_size = 0;

    if (_internal_has_client_version()) {
        // required string client_version = 1;
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_client_version());
    }

    if (_internal_has_data_present()) {
        // required string data_present = 4;
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_data_present());
    }

    if (_internal_has_form_signature()) {
        // required fixed64 form_signature = 2;
        total_size += 1 + 8;
    }

    if (_internal_has_autofill_used()) {
        // required bool autofill_used = 3;
        total_size += 1 + 1;
    }

    return total_size;
}
size_t AutofillUploadContents::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:autofill.AutofillUploadContents)
    size_t total_size = 0;

    if (((_impl_._has_bits_[0] & 0x00000123) ^ 0x00000123) == 0) { // All required fields are present.
        // required string client_version = 1;
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_client_version());

        // required string data_present = 4;
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_data_present());

        // required fixed64 form_signature = 2;
        total_size += 1 + 8;

        // required bool autofill_used = 3;
        total_size += 1 + 1;

    } else {
        total_size += RequiredFieldsByteSizeFallback();
    }
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .autofill.AutofillUploadContents.ButtonTitle button_title = 36;
    total_size += 2UL * this->_internal_button_title_size();
    for (const auto& msg : this->_impl_.button_title_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // repeated .autofill.AutofillUploadContents.SingleUsernameData single_username_data = 42;
    total_size += 2UL * this->_internal_single_username_data_size();
    for (const auto& msg : this->_impl_.single_username_data_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // repeated .autofill.AutofillUploadContents.Field field_data = 48;
    total_size += 2UL * this->_internal_field_data_size();
    for (const auto& msg : this->_impl_.field_data_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001cu) {
        // optional string form_name = 16;
        if (cached_has_bits & 0x00000004u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_form_name());
        }

        // optional string language = 31;
        if (cached_has_bits & 0x00000008u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_language());
        }

        // optional .autofill.AutofillRandomizedFormMetadata randomized_form_metadata = 32;
        if (cached_has_bits & 0x00000010u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.randomized_form_metadata_);
        }
    }
    if (cached_has_bits & 0x000000c0u) {
        // optional fixed64 action_signature = 13;
        if (cached_has_bits & 0x00000040u) {
            total_size += 1 + 8;
        }

        // optional fixed64 login_form_signature = 14;
        if (cached_has_bits & 0x00000080u) {
            total_size += 1 + 8;
        }
    }
    if (cached_has_bits & 0x0000fe00u) {
        // optional bool submission = 15;
        if (cached_has_bits & 0x00000200u) {
            total_size += 1 + 1;
        }

        // optional bool passwords_revealed = 24;
        if (cached_has_bits & 0x00000400u) {
            total_size += 2 + 1;
        }

        // optional bool password_has_letter = 25;
        if (cached_has_bits & 0x00000800u) {
            total_size += 2 + 1;
        }

        // optional uint32 password_length = 29;
        if (cached_has_bits & 0x00001000u) {
            total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(this->_internal_password_length());
        }

        // optional bool password_has_uppercase_letter = 26 [deprecated = true];
        if (cached_has_bits & 0x00002000u) {
            total_size += 2 + 1;
        }

        // optional bool password_has_numeric = 27 [deprecated = true];
        if (cached_has_bits & 0x00004000u) {
            total_size += 2 + 1;
        }

        // optional bool password_has_special_symbol = 28;
        if (cached_has_bits & 0x00008000u) {
            total_size += 2 + 1;
        }
    }
    if (cached_has_bits & 0x00ff0000u) {
        // optional bool has_form_tag = 37;
        if (cached_has_bits & 0x00010000u) {
            total_size += 2 + 1;
        }

        // optional .autofill.AutofillUploadContents.SubmissionIndicatorEvent submission_event = 30;
        if (cached_has_bits & 0x00020000u) {
            total_size += 2 + ::_pbi::WireFormatLite::EnumSize(this->_internal_submission_event());
        }

        // optional fixed64 secondary_form_signature = 34;
        if (cached_has_bits & 0x00040000u) {
            total_size += 2 + 8;
        }

        // optional bool was_throttleable = 38 [deprecated = true];
        if (cached_has_bits & 0x00080000u) {
            total_size += 2 + 1;
        }

        // optional uint32 password_special_symbol = 39;
        if (cached_has_bits & 0x00100000u) {
            total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(this->_internal_password_special_symbol());
        }

        // optional fixed64 last_address_form_submitted = 43;
        if (cached_has_bits & 0x00200000u) {
            total_size += 2 + 8;
        }

        // optional fixed64 second_last_address_form_submitted = 44;
        if (cached_has_bits & 0x00400000u) {
            total_size += 2 + 8;
        }

        // optional fixed64 last_credit_card_form_submitted = 45;
        if (cached_has_bits & 0x00800000u) {
            total_size += 2 + 8;
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void AutofillUploadContents::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const AutofillUploadContents*>(&from));
}

void AutofillUploadContents::MergeFrom(const AutofillUploadContents& from)
{
    AutofillUploadContents* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:autofill.AutofillUploadContents)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.button_title_.MergeFrom(from._impl_.button_title_);
    _this->_impl_.single_username_data_.MergeFrom(from._impl_.single_username_data_);
    _this->_impl_.field_data_.MergeFrom(from._impl_.field_data_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_client_version(from._internal_client_version());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_data_present(from._internal_data_present());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_set_form_name(from._internal_form_name());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_set_language(from._internal_language());
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_internal_mutable_randomized_form_metadata()->::autofill::AutofillRandomizedFormMetadata::MergeFrom(
                from._internal_randomized_form_metadata());
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_impl_.form_signature_ = from._impl_.form_signature_;
        }
        if (cached_has_bits & 0x00000040u) {
            _this->_impl_.action_signature_ = from._impl_.action_signature_;
        }
        if (cached_has_bits & 0x00000080u) {
            _this->_impl_.login_form_signature_ = from._impl_.login_form_signature_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    if (cached_has_bits & 0x0000ff00u) {
        if (cached_has_bits & 0x00000100u) {
            _this->_impl_.autofill_used_ = from._impl_.autofill_used_;
        }
        if (cached_has_bits & 0x00000200u) {
            _this->_impl_.submission_ = from._impl_.submission_;
        }
        if (cached_has_bits & 0x00000400u) {
            _this->_impl_.passwords_revealed_ = from._impl_.passwords_revealed_;
        }
        if (cached_has_bits & 0x00000800u) {
            _this->_impl_.password_has_letter_ = from._impl_.password_has_letter_;
        }
        if (cached_has_bits & 0x00001000u) {
            _this->_impl_.password_length_ = from._impl_.password_length_;
        }
        if (cached_has_bits & 0x00002000u) {
            _this->_impl_.password_has_uppercase_letter_ = from._impl_.password_has_uppercase_letter_;
        }
        if (cached_has_bits & 0x00004000u) {
            _this->_impl_.password_has_numeric_ = from._impl_.password_has_numeric_;
        }
        if (cached_has_bits & 0x00008000u) {
            _this->_impl_.password_has_special_symbol_ = from._impl_.password_has_special_symbol_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    if (cached_has_bits & 0x00ff0000u) {
        if (cached_has_bits & 0x00010000u) {
            _this->_impl_.has_form_tag_ = from._impl_.has_form_tag_;
        }
        if (cached_has_bits & 0x00020000u) {
            _this->_impl_.submission_event_ = from._impl_.submission_event_;
        }
        if (cached_has_bits & 0x00040000u) {
            _this->_impl_.secondary_form_signature_ = from._impl_.secondary_form_signature_;
        }
        if (cached_has_bits & 0x00080000u) {
            _this->_impl_.was_throttleable_ = from._impl_.was_throttleable_;
        }
        if (cached_has_bits & 0x00100000u) {
            _this->_impl_.password_special_symbol_ = from._impl_.password_special_symbol_;
        }
        if (cached_has_bits & 0x00200000u) {
            _this->_impl_.last_address_form_submitted_ = from._impl_.last_address_form_submitted_;
        }
        if (cached_has_bits & 0x00400000u) {
            _this->_impl_.second_last_address_form_submitted_ = from._impl_.second_last_address_form_submitted_;
        }
        if (cached_has_bits & 0x00800000u) {
            _this->_impl_.last_credit_card_form_submitted_ = from._impl_.last_credit_card_form_submitted_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AutofillUploadContents::CopyFrom(const AutofillUploadContents& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:autofill.AutofillUploadContents)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool AutofillUploadContents::IsInitialized() const
{
    if (_Internal::MissingRequiredFields(_impl_._has_bits_))
        return false;
    if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.field_data_))
        return false;
    return true;
}

void AutofillUploadContents::InternalSwap(AutofillUploadContents* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.button_title_.InternalSwap(&other->_impl_.button_title_);
    _impl_.single_username_data_.InternalSwap(&other->_impl_.single_username_data_);
    _impl_.field_data_.InternalSwap(&other->_impl_.field_data_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.client_version_, lhs_arena, &other->_impl_.client_version_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.data_present_, lhs_arena, &other->_impl_.data_present_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.form_name_, lhs_arena, &other->_impl_.form_name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.language_, lhs_arena, &other->_impl_.language_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(AutofillUploadContents, _impl_.last_credit_card_form_submitted_)
        + sizeof(AutofillUploadContents::_impl_.last_credit_card_form_submitted_)
        - PROTOBUF_FIELD_OFFSET(AutofillUploadContents, _impl_.randomized_form_metadata_)>(
        reinterpret_cast<char*>(&_impl_.randomized_form_metadata_), reinterpret_cast<char*>(&other->_impl_.randomized_form_metadata_));
}

std::string AutofillUploadContents::GetTypeName() const
{
    return "autofill.AutofillUploadContents";
}

// ===================================================================

ProfileValidityMap_FieldValidityStatesEntry_DoNotUse::ProfileValidityMap_FieldValidityStatesEntry_DoNotUse()
{
}
ProfileValidityMap_FieldValidityStatesEntry_DoNotUse::ProfileValidityMap_FieldValidityStatesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena)
{
}
void ProfileValidityMap_FieldValidityStatesEntry_DoNotUse::MergeFrom(const ProfileValidityMap_FieldValidityStatesEntry_DoNotUse& other)
{
    MergeFromInternal(other);
}

// ===================================================================

class ProfileValidityMap::_Internal {
public:
};

ProfileValidityMap::ProfileValidityMap(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:autofill.ProfileValidityMap)
}
ProfileValidityMap::ProfileValidityMap(const ProfileValidityMap& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ProfileValidityMap* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { /*decltype(_impl_.field_validity_states_)*/ {}, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _this->_impl_.field_validity_states_.MergeFrom(from._impl_.field_validity_states_);
    // @@protoc_insertion_point(copy_constructor:autofill.ProfileValidityMap)
}

inline void ProfileValidityMap::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { /*decltype(_impl_.field_validity_states_)*/ { ::_pbi::ArenaInitialized(), arena }, /*decltype(_impl_._cached_size_)*/ {} };
}

ProfileValidityMap::~ProfileValidityMap()
{
    // @@protoc_insertion_point(destructor:autofill.ProfileValidityMap)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ProfileValidityMap::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.field_validity_states_.Destruct();
    _impl_.field_validity_states_.~MapFieldLite();
}

void ProfileValidityMap::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ProfileValidityMap::Clear()
{
    // @@protoc_insertion_point(message_clear_start:autofill.ProfileValidityMap)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.field_validity_states_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ProfileValidityMap::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // map<int32, int32> field_validity_states = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(&_impl_.field_validity_states_, ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ProfileValidityMap::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:autofill.ProfileValidityMap)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // map<int32, int32> field_validity_states = 1;
    if (!this->_internal_field_validity_states().empty()) {
        using MapType = ::_pb::Map<int32_t, int32_t>;
        using WireHelper = ProfileValidityMap_FieldValidityStatesEntry_DoNotUse::Funcs;
        const auto& map_field = this->_internal_field_validity_states();

        if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
            for (const auto& entry : ::_pbi::MapSorterFlat<MapType>(map_field)) {
                target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
            }
        } else {
            for (const auto& entry : map_field) {
                target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
            }
        }
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:autofill.ProfileValidityMap)
    return target;
}

size_t ProfileValidityMap::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:autofill.ProfileValidityMap)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // map<int32, int32> field_validity_states = 1;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_field_validity_states_size());
    for (::PROTOBUF_NAMESPACE_ID::Map<int32_t, int32_t>::const_iterator it = this->_internal_field_validity_states().begin();
         it != this->_internal_field_validity_states().end(); ++it) {
        total_size += ProfileValidityMap_FieldValidityStatesEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ProfileValidityMap::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ProfileValidityMap*>(&from));
}

void ProfileValidityMap::MergeFrom(const ProfileValidityMap& from)
{
    ProfileValidityMap* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:autofill.ProfileValidityMap)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.field_validity_states_.MergeFrom(from._impl_.field_validity_states_);
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ProfileValidityMap::CopyFrom(const ProfileValidityMap& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:autofill.ProfileValidityMap)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ProfileValidityMap::IsInitialized() const
{
    return true;
}

void ProfileValidityMap::InternalSwap(ProfileValidityMap* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.field_validity_states_.InternalSwap(&other->_impl_.field_validity_states_);
}

std::string ProfileValidityMap::GetTypeName() const
{
    return "autofill.ProfileValidityMap";
}

// ===================================================================

UserProfileValidityMap_ProfileValidityEntry_DoNotUse::UserProfileValidityMap_ProfileValidityEntry_DoNotUse()
{
}
UserProfileValidityMap_ProfileValidityEntry_DoNotUse::UserProfileValidityMap_ProfileValidityEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena)
{
}
void UserProfileValidityMap_ProfileValidityEntry_DoNotUse::MergeFrom(const UserProfileValidityMap_ProfileValidityEntry_DoNotUse& other)
{
    MergeFromInternal(other);
}

// ===================================================================

class UserProfileValidityMap::_Internal {
public:
};

UserProfileValidityMap::UserProfileValidityMap(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:autofill.UserProfileValidityMap)
}
UserProfileValidityMap::UserProfileValidityMap(const UserProfileValidityMap& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    UserProfileValidityMap* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { /*decltype(_impl_.profile_validity_)*/ {}, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _this->_impl_.profile_validity_.MergeFrom(from._impl_.profile_validity_);
    // @@protoc_insertion_point(copy_constructor:autofill.UserProfileValidityMap)
}

inline void UserProfileValidityMap::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { /*decltype(_impl_.profile_validity_)*/ { ::_pbi::ArenaInitialized(), arena }, /*decltype(_impl_._cached_size_)*/ {} };
}

UserProfileValidityMap::~UserProfileValidityMap()
{
    // @@protoc_insertion_point(destructor:autofill.UserProfileValidityMap)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void UserProfileValidityMap::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.profile_validity_.Destruct();
    _impl_.profile_validity_.~MapFieldLite();
}

void UserProfileValidityMap::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void UserProfileValidityMap::Clear()
{
    // @@protoc_insertion_point(message_clear_start:autofill.UserProfileValidityMap)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.profile_validity_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* UserProfileValidityMap::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // map<string, .autofill.ProfileValidityMap> profile_validity = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(&_impl_.profile_validity_, ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* UserProfileValidityMap::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:autofill.UserProfileValidityMap)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // map<string, .autofill.ProfileValidityMap> profile_validity = 1;
    if (!this->_internal_profile_validity().empty()) {
        using MapType = ::_pb::Map<std::string, ::autofill::ProfileValidityMap>;
        using WireHelper = UserProfileValidityMap_ProfileValidityEntry_DoNotUse::Funcs;
        const auto& map_field = this->_internal_profile_validity();
        auto check_utf8 = [](const MapType::value_type& entry) { (void)entry; };

        if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
            for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
                target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
                check_utf8(entry);
            }
        } else {
            for (const auto& entry : map_field) {
                target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
                check_utf8(entry);
            }
        }
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:autofill.UserProfileValidityMap)
    return target;
}

size_t UserProfileValidityMap::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:autofill.UserProfileValidityMap)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // map<string, .autofill.ProfileValidityMap> profile_validity = 1;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_profile_validity_size());
    for (::PROTOBUF_NAMESPACE_ID::Map<std::string, ::autofill::ProfileValidityMap>::const_iterator it = this->_internal_profile_validity().begin();
         it != this->_internal_profile_validity().end(); ++it) {
        total_size += UserProfileValidityMap_ProfileValidityEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void UserProfileValidityMap::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const UserProfileValidityMap*>(&from));
}

void UserProfileValidityMap::MergeFrom(const UserProfileValidityMap& from)
{
    UserProfileValidityMap* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:autofill.UserProfileValidityMap)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.profile_validity_.MergeFrom(from._impl_.profile_validity_);
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UserProfileValidityMap::CopyFrom(const UserProfileValidityMap& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:autofill.UserProfileValidityMap)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool UserProfileValidityMap::IsInitialized() const
{
    return true;
}

void UserProfileValidityMap::InternalSwap(UserProfileValidityMap* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.profile_validity_.InternalSwap(&other->_impl_.profile_validity_);
}

std::string UserProfileValidityMap::GetTypeName() const
{
    return "autofill.UserProfileValidityMap";
}

// @@protoc_insertion_point(namespace_scope)
} // namespace autofill
PROTOBUF_NAMESPACE_OPEN
template <> PROTOBUF_NOINLINE ::autofill::AutofillRandomizedValue* Arena::CreateMaybeMessage<::autofill::AutofillRandomizedValue>(Arena* arena)
{
    return Arena::CreateMessageInternal<::autofill::AutofillRandomizedValue>(arena);
}
template <>
PROTOBUF_NOINLINE ::autofill::AutofillRandomizedFormMetadata_ButtonTitle* Arena::CreateMaybeMessage<::autofill::AutofillRandomizedFormMetadata_ButtonTitle>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<::autofill::AutofillRandomizedFormMetadata_ButtonTitle>(arena);
}
template <> PROTOBUF_NOINLINE ::autofill::AutofillRandomizedFormMetadata* Arena::CreateMaybeMessage<::autofill::AutofillRandomizedFormMetadata>(Arena* arena)
{
    return Arena::CreateMessageInternal<::autofill::AutofillRandomizedFormMetadata>(arena);
}
template <> PROTOBUF_NOINLINE ::autofill::AutofillRandomizedFieldMetadata* Arena::CreateMaybeMessage<::autofill::AutofillRandomizedFieldMetadata>(Arena* arena)
{
    return Arena::CreateMessageInternal<::autofill::AutofillRandomizedFieldMetadata>(arena);
}
template <> PROTOBUF_NOINLINE ::autofill::AutofillUploadContents_Field* Arena::CreateMaybeMessage<::autofill::AutofillUploadContents_Field>(Arena* arena)
{
    return Arena::CreateMessageInternal<::autofill::AutofillUploadContents_Field>(arena);
}
template <>
PROTOBUF_NOINLINE ::autofill::AutofillUploadContents_ButtonTitle* Arena::CreateMaybeMessage<::autofill::AutofillUploadContents_ButtonTitle>(Arena* arena)
{
    return Arena::CreateMessageInternal<::autofill::AutofillUploadContents_ButtonTitle>(arena);
}
template <>
PROTOBUF_NOINLINE ::autofill::AutofillUploadContents_SingleUsernameData* Arena::CreateMaybeMessage<::autofill::AutofillUploadContents_SingleUsernameData>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<::autofill::AutofillUploadContents_SingleUsernameData>(arena);
}
template <> PROTOBUF_NOINLINE ::autofill::AutofillUploadContents* Arena::CreateMaybeMessage<::autofill::AutofillUploadContents>(Arena* arena)
{
    return Arena::CreateMessageInternal<::autofill::AutofillUploadContents>(arena);
}
template <>
PROTOBUF_NOINLINE ::autofill::ProfileValidityMap_FieldValidityStatesEntry_DoNotUse*
Arena::CreateMaybeMessage<::autofill::ProfileValidityMap_FieldValidityStatesEntry_DoNotUse>(Arena* arena)
{
    return Arena::CreateMessageInternal<::autofill::ProfileValidityMap_FieldValidityStatesEntry_DoNotUse>(arena);
}
template <> PROTOBUF_NOINLINE ::autofill::ProfileValidityMap* Arena::CreateMaybeMessage<::autofill::ProfileValidityMap>(Arena* arena)
{
    return Arena::CreateMessageInternal<::autofill::ProfileValidityMap>(arena);
}
template <>
PROTOBUF_NOINLINE ::autofill::UserProfileValidityMap_ProfileValidityEntry_DoNotUse*
Arena::CreateMaybeMessage<::autofill::UserProfileValidityMap_ProfileValidityEntry_DoNotUse>(Arena* arena)
{
    return Arena::CreateMessageInternal<::autofill::UserProfileValidityMap_ProfileValidityEntry_DoNotUse>(arena);
}
template <> PROTOBUF_NOINLINE ::autofill::UserProfileValidityMap* Arena::CreateMaybeMessage<::autofill::UserProfileValidityMap>(Arena* arena)
{
    return Arena::CreateMessageInternal<::autofill::UserProfileValidityMap>(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
