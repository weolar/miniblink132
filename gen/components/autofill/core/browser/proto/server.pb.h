// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: server.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_server_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_server_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h> // IWYU pragma: export
#include <google/protobuf/extension_set.h> // IWYU pragma: export
#include <google/protobuf/map.h> // IWYU pragma: export
#include <google/protobuf/map_entry_lite.h>
#include <google/protobuf/map_field_lite.h>
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_server_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
} // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_server_2eproto {
    static const uint32_t offsets[];
};
namespace autofill {
class AutofillRandomizedFieldMetadata;
struct AutofillRandomizedFieldMetadataDefaultTypeInternal;
extern AutofillRandomizedFieldMetadataDefaultTypeInternal _AutofillRandomizedFieldMetadata_default_instance_;
class AutofillRandomizedFormMetadata;
struct AutofillRandomizedFormMetadataDefaultTypeInternal;
extern AutofillRandomizedFormMetadataDefaultTypeInternal _AutofillRandomizedFormMetadata_default_instance_;
class AutofillRandomizedFormMetadata_ButtonTitle;
struct AutofillRandomizedFormMetadata_ButtonTitleDefaultTypeInternal;
extern AutofillRandomizedFormMetadata_ButtonTitleDefaultTypeInternal _AutofillRandomizedFormMetadata_ButtonTitle_default_instance_;
class AutofillRandomizedValue;
struct AutofillRandomizedValueDefaultTypeInternal;
extern AutofillRandomizedValueDefaultTypeInternal _AutofillRandomizedValue_default_instance_;
class AutofillUploadContents;
struct AutofillUploadContentsDefaultTypeInternal;
extern AutofillUploadContentsDefaultTypeInternal _AutofillUploadContents_default_instance_;
class AutofillUploadContents_ButtonTitle;
struct AutofillUploadContents_ButtonTitleDefaultTypeInternal;
extern AutofillUploadContents_ButtonTitleDefaultTypeInternal _AutofillUploadContents_ButtonTitle_default_instance_;
class AutofillUploadContents_Field;
struct AutofillUploadContents_FieldDefaultTypeInternal;
extern AutofillUploadContents_FieldDefaultTypeInternal _AutofillUploadContents_Field_default_instance_;
class AutofillUploadContents_SingleUsernameData;
struct AutofillUploadContents_SingleUsernameDataDefaultTypeInternal;
extern AutofillUploadContents_SingleUsernameDataDefaultTypeInternal _AutofillUploadContents_SingleUsernameData_default_instance_;
class ProfileValidityMap;
struct ProfileValidityMapDefaultTypeInternal;
extern ProfileValidityMapDefaultTypeInternal _ProfileValidityMap_default_instance_;
class ProfileValidityMap_FieldValidityStatesEntry_DoNotUse;
struct ProfileValidityMap_FieldValidityStatesEntry_DoNotUseDefaultTypeInternal;
extern ProfileValidityMap_FieldValidityStatesEntry_DoNotUseDefaultTypeInternal _ProfileValidityMap_FieldValidityStatesEntry_DoNotUse_default_instance_;
class UserProfileValidityMap;
struct UserProfileValidityMapDefaultTypeInternal;
extern UserProfileValidityMapDefaultTypeInternal _UserProfileValidityMap_default_instance_;
class UserProfileValidityMap_ProfileValidityEntry_DoNotUse;
struct UserProfileValidityMap_ProfileValidityEntry_DoNotUseDefaultTypeInternal;
extern UserProfileValidityMap_ProfileValidityEntry_DoNotUseDefaultTypeInternal _UserProfileValidityMap_ProfileValidityEntry_DoNotUse_default_instance_;
} // namespace autofill
PROTOBUF_NAMESPACE_OPEN
template <>::autofill::AutofillRandomizedFieldMetadata* Arena::CreateMaybeMessage<::autofill::AutofillRandomizedFieldMetadata>(Arena*);
template <>::autofill::AutofillRandomizedFormMetadata* Arena::CreateMaybeMessage<::autofill::AutofillRandomizedFormMetadata>(Arena*);
template <>::autofill::AutofillRandomizedFormMetadata_ButtonTitle* Arena::CreateMaybeMessage<::autofill::AutofillRandomizedFormMetadata_ButtonTitle>(Arena*);
template <>::autofill::AutofillRandomizedValue* Arena::CreateMaybeMessage<::autofill::AutofillRandomizedValue>(Arena*);
template <>::autofill::AutofillUploadContents* Arena::CreateMaybeMessage<::autofill::AutofillUploadContents>(Arena*);
template <>::autofill::AutofillUploadContents_ButtonTitle* Arena::CreateMaybeMessage<::autofill::AutofillUploadContents_ButtonTitle>(Arena*);
template <>::autofill::AutofillUploadContents_Field* Arena::CreateMaybeMessage<::autofill::AutofillUploadContents_Field>(Arena*);
template <>::autofill::AutofillUploadContents_SingleUsernameData* Arena::CreateMaybeMessage<::autofill::AutofillUploadContents_SingleUsernameData>(Arena*);
template <>::autofill::ProfileValidityMap* Arena::CreateMaybeMessage<::autofill::ProfileValidityMap>(Arena*);
template <>
::autofill::ProfileValidityMap_FieldValidityStatesEntry_DoNotUse* Arena::CreateMaybeMessage<::autofill::ProfileValidityMap_FieldValidityStatesEntry_DoNotUse>(
    Arena*);
template <>::autofill::UserProfileValidityMap* Arena::CreateMaybeMessage<::autofill::UserProfileValidityMap>(Arena*);
template <>
::autofill::UserProfileValidityMap_ProfileValidityEntry_DoNotUse* Arena::CreateMaybeMessage<::autofill::UserProfileValidityMap_ProfileValidityEntry_DoNotUse>(
    Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace autofill {

enum AutofillRandomizedValue_EncodingType : int {
    AutofillRandomizedValue_EncodingType_UNSPECIFIED_ENCODING_TYPE = -1,
    AutofillRandomizedValue_EncodingType_BIT_0 = 0,
    AutofillRandomizedValue_EncodingType_BIT_1 = 1,
    AutofillRandomizedValue_EncodingType_BIT_2 = 2,
    AutofillRandomizedValue_EncodingType_BIT_3 = 3,
    AutofillRandomizedValue_EncodingType_BIT_4 = 4,
    AutofillRandomizedValue_EncodingType_BIT_5 = 5,
    AutofillRandomizedValue_EncodingType_BIT_6 = 6,
    AutofillRandomizedValue_EncodingType_BIT_7 = 7,
    AutofillRandomizedValue_EncodingType_EVEN_BITS = 8,
    AutofillRandomizedValue_EncodingType_ODD_BITS = 9,
    AutofillRandomizedValue_EncodingType_ALL_BITS = 10
};
bool AutofillRandomizedValue_EncodingType_IsValid(int value);
constexpr AutofillRandomizedValue_EncodingType AutofillRandomizedValue_EncodingType_EncodingType_MIN
    = AutofillRandomizedValue_EncodingType_UNSPECIFIED_ENCODING_TYPE;
constexpr AutofillRandomizedValue_EncodingType AutofillRandomizedValue_EncodingType_EncodingType_MAX = AutofillRandomizedValue_EncodingType_ALL_BITS;
constexpr int AutofillRandomizedValue_EncodingType_EncodingType_ARRAYSIZE = AutofillRandomizedValue_EncodingType_EncodingType_MAX + 1;

const std::string& AutofillRandomizedValue_EncodingType_Name(AutofillRandomizedValue_EncodingType value);
template <typename T> inline const std::string& AutofillRandomizedValue_EncodingType_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, AutofillRandomizedValue_EncodingType>::value || ::std::is_integral<T>::value,
        "Incorrect type passed to function AutofillRandomizedValue_EncodingType_Name.");
    return AutofillRandomizedValue_EncodingType_Name(static_cast<AutofillRandomizedValue_EncodingType>(enum_t_value));
}
bool AutofillRandomizedValue_EncodingType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AutofillRandomizedValue_EncodingType* value);
enum AutofillUploadContents_Field_PasswordGenerationType : int {
    AutofillUploadContents_Field_PasswordGenerationType_NO_GENERATION = 0,
    AutofillUploadContents_Field_PasswordGenerationType_AUTOMATICALLY_TRIGGERED_GENERATION_ON_SIGN_UP_FORM = 1,
    AutofillUploadContents_Field_PasswordGenerationType_AUTOMATICALLY_TRIGGERED_GENERATION_ON_CHANGE_PASSWORD_FORM = 2,
    AutofillUploadContents_Field_PasswordGenerationType_MANUALLY_TRIGGERED_GENERATION_ON_SIGN_UP_FORM = 3,
    AutofillUploadContents_Field_PasswordGenerationType_MANUALLY_TRIGGERED_GENERATION_ON_CHANGE_PASSWORD_FORM = 4,
    AutofillUploadContents_Field_PasswordGenerationType_IGNORED_GENERATION_POPUP = 5
};
bool AutofillUploadContents_Field_PasswordGenerationType_IsValid(int value);
constexpr AutofillUploadContents_Field_PasswordGenerationType AutofillUploadContents_Field_PasswordGenerationType_PasswordGenerationType_MIN
    = AutofillUploadContents_Field_PasswordGenerationType_NO_GENERATION;
constexpr AutofillUploadContents_Field_PasswordGenerationType AutofillUploadContents_Field_PasswordGenerationType_PasswordGenerationType_MAX
    = AutofillUploadContents_Field_PasswordGenerationType_IGNORED_GENERATION_POPUP;
constexpr int AutofillUploadContents_Field_PasswordGenerationType_PasswordGenerationType_ARRAYSIZE
    = AutofillUploadContents_Field_PasswordGenerationType_PasswordGenerationType_MAX + 1;

const std::string& AutofillUploadContents_Field_PasswordGenerationType_Name(AutofillUploadContents_Field_PasswordGenerationType value);
template <typename T> inline const std::string& AutofillUploadContents_Field_PasswordGenerationType_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, AutofillUploadContents_Field_PasswordGenerationType>::value || ::std::is_integral<T>::value,
        "Incorrect type passed to function AutofillUploadContents_Field_PasswordGenerationType_Name.");
    return AutofillUploadContents_Field_PasswordGenerationType_Name(static_cast<AutofillUploadContents_Field_PasswordGenerationType>(enum_t_value));
}
bool AutofillUploadContents_Field_PasswordGenerationType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AutofillUploadContents_Field_PasswordGenerationType* value);
enum AutofillUploadContents_Field_VoteType : int {
    AutofillUploadContents_Field_VoteType_NO_INFORMATION = 0,
    AutofillUploadContents_Field_VoteType_CREDENTIALS_REUSED = 1,
    AutofillUploadContents_Field_VoteType_USERNAME_OVERWRITTEN = 2,
    AutofillUploadContents_Field_VoteType_USERNAME_EDITED = 3,
    AutofillUploadContents_Field_VoteType_BASE_HEURISTIC = 4,
    AutofillUploadContents_Field_VoteType_HTML_CLASSIFIER = 5,
    AutofillUploadContents_Field_VoteType_FIRST_USE = 6
};
bool AutofillUploadContents_Field_VoteType_IsValid(int value);
constexpr AutofillUploadContents_Field_VoteType AutofillUploadContents_Field_VoteType_VoteType_MIN = AutofillUploadContents_Field_VoteType_NO_INFORMATION;
constexpr AutofillUploadContents_Field_VoteType AutofillUploadContents_Field_VoteType_VoteType_MAX = AutofillUploadContents_Field_VoteType_FIRST_USE;
constexpr int AutofillUploadContents_Field_VoteType_VoteType_ARRAYSIZE = AutofillUploadContents_Field_VoteType_VoteType_MAX + 1;

const std::string& AutofillUploadContents_Field_VoteType_Name(AutofillUploadContents_Field_VoteType value);
template <typename T> inline const std::string& AutofillUploadContents_Field_VoteType_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, AutofillUploadContents_Field_VoteType>::value || ::std::is_integral<T>::value,
        "Incorrect type passed to function AutofillUploadContents_Field_VoteType_Name.");
    return AutofillUploadContents_Field_VoteType_Name(static_cast<AutofillUploadContents_Field_VoteType>(enum_t_value));
}
bool AutofillUploadContents_Field_VoteType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AutofillUploadContents_Field_VoteType* value);
enum AutofillUploadContents_Field_SingleUsernameVoteType : int {
    AutofillUploadContents_Field_SingleUsernameVoteType_DEFAULT = 0,
    AutofillUploadContents_Field_SingleUsernameVoteType_WEAK = 1,
    AutofillUploadContents_Field_SingleUsernameVoteType_STRONG = 2,
    AutofillUploadContents_Field_SingleUsernameVoteType_WEAK_FORGOT_PASSWORD = 3,
    AutofillUploadContents_Field_SingleUsernameVoteType_STRONG_FORGOT_PASSWORD = 4,
    AutofillUploadContents_Field_SingleUsernameVoteType_IN_FORM_OVERRULE = 5
};
bool AutofillUploadContents_Field_SingleUsernameVoteType_IsValid(int value);
constexpr AutofillUploadContents_Field_SingleUsernameVoteType AutofillUploadContents_Field_SingleUsernameVoteType_SingleUsernameVoteType_MIN
    = AutofillUploadContents_Field_SingleUsernameVoteType_DEFAULT;
constexpr AutofillUploadContents_Field_SingleUsernameVoteType AutofillUploadContents_Field_SingleUsernameVoteType_SingleUsernameVoteType_MAX
    = AutofillUploadContents_Field_SingleUsernameVoteType_IN_FORM_OVERRULE;
constexpr int AutofillUploadContents_Field_SingleUsernameVoteType_SingleUsernameVoteType_ARRAYSIZE
    = AutofillUploadContents_Field_SingleUsernameVoteType_SingleUsernameVoteType_MAX + 1;

const std::string& AutofillUploadContents_Field_SingleUsernameVoteType_Name(AutofillUploadContents_Field_SingleUsernameVoteType value);
template <typename T> inline const std::string& AutofillUploadContents_Field_SingleUsernameVoteType_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, AutofillUploadContents_Field_SingleUsernameVoteType>::value || ::std::is_integral<T>::value,
        "Incorrect type passed to function AutofillUploadContents_Field_SingleUsernameVoteType_Name.");
    return AutofillUploadContents_Field_SingleUsernameVoteType_Name(static_cast<AutofillUploadContents_Field_SingleUsernameVoteType>(enum_t_value));
}
bool AutofillUploadContents_Field_SingleUsernameVoteType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AutofillUploadContents_Field_SingleUsernameVoteType* value);
enum AutofillUploadContents_SubmissionIndicatorEvent : int {
    AutofillUploadContents_SubmissionIndicatorEvent_NONE = 0,
    AutofillUploadContents_SubmissionIndicatorEvent_HTML_FORM_SUBMISSION = 1,
    AutofillUploadContents_SubmissionIndicatorEvent_SAME_DOCUMENT_NAVIGATION = 2,
    AutofillUploadContents_SubmissionIndicatorEvent_XHR_SUCCEEDED = 3,
    AutofillUploadContents_SubmissionIndicatorEvent_FRAME_DETACHED = 4,
    AutofillUploadContents_SubmissionIndicatorEvent_DEPRECATED_MANUAL_SAVE = 5,
    AutofillUploadContents_SubmissionIndicatorEvent_DEPRECATED_DOM_MUTATION_AFTER_XHR = 6,
    AutofillUploadContents_SubmissionIndicatorEvent_DEPRECATED_PROVISIONALLY_SAVED_FORM_ON_START_PROVISIONAL_LOAD = 7,
    AutofillUploadContents_SubmissionIndicatorEvent_DEPRECATED_FILLED_FORM_ON_START_PROVISIONAL_LOAD = 8,
    AutofillUploadContents_SubmissionIndicatorEvent_DEPRECATED_FILLED_INPUT_ELEMENTS_ON_START_PROVISIONAL_LOAD = 9,
    AutofillUploadContents_SubmissionIndicatorEvent_PROBABLE_FORM_SUBMISSION = 10,
    AutofillUploadContents_SubmissionIndicatorEvent_CHANGE_PASSWORD_FORM_CLEARED = 11,
    AutofillUploadContents_SubmissionIndicatorEvent_DOM_MUTATION_AFTER_AUTOFILL = 12
};
bool AutofillUploadContents_SubmissionIndicatorEvent_IsValid(int value);
constexpr AutofillUploadContents_SubmissionIndicatorEvent AutofillUploadContents_SubmissionIndicatorEvent_SubmissionIndicatorEvent_MIN
    = AutofillUploadContents_SubmissionIndicatorEvent_NONE;
constexpr AutofillUploadContents_SubmissionIndicatorEvent AutofillUploadContents_SubmissionIndicatorEvent_SubmissionIndicatorEvent_MAX
    = AutofillUploadContents_SubmissionIndicatorEvent_DOM_MUTATION_AFTER_AUTOFILL;
constexpr int AutofillUploadContents_SubmissionIndicatorEvent_SubmissionIndicatorEvent_ARRAYSIZE
    = AutofillUploadContents_SubmissionIndicatorEvent_SubmissionIndicatorEvent_MAX + 1;

const std::string& AutofillUploadContents_SubmissionIndicatorEvent_Name(AutofillUploadContents_SubmissionIndicatorEvent value);
template <typename T> inline const std::string& AutofillUploadContents_SubmissionIndicatorEvent_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, AutofillUploadContents_SubmissionIndicatorEvent>::value || ::std::is_integral<T>::value,
        "Incorrect type passed to function AutofillUploadContents_SubmissionIndicatorEvent_Name.");
    return AutofillUploadContents_SubmissionIndicatorEvent_Name(static_cast<AutofillUploadContents_SubmissionIndicatorEvent>(enum_t_value));
}
bool AutofillUploadContents_SubmissionIndicatorEvent_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AutofillUploadContents_SubmissionIndicatorEvent* value);
enum AutofillUploadContents_ValueType : int {
    AutofillUploadContents_ValueType_TYPE_UNSPECIFIED = 0,
    AutofillUploadContents_ValueType_NO_VALUE_TYPE = 1,
    AutofillUploadContents_ValueType_STORED_FOR_CURRENT_DOMAIN = 2,
    AutofillUploadContents_ValueType_STORED_FOR_ANOTHER_DOMAIN = 3,
    AutofillUploadContents_ValueType_EMAIL = 4,
    AutofillUploadContents_ValueType_PHONE = 5,
    AutofillUploadContents_ValueType_USERNAME_LIKE = 6,
    AutofillUploadContents_ValueType_VALUE_WITH_NO_WHITESPACE = 7,
    AutofillUploadContents_ValueType_VALUE_WITH_WHITESPACE = 8
};
bool AutofillUploadContents_ValueType_IsValid(int value);
constexpr AutofillUploadContents_ValueType AutofillUploadContents_ValueType_ValueType_MIN = AutofillUploadContents_ValueType_TYPE_UNSPECIFIED;
constexpr AutofillUploadContents_ValueType AutofillUploadContents_ValueType_ValueType_MAX = AutofillUploadContents_ValueType_VALUE_WITH_WHITESPACE;
constexpr int AutofillUploadContents_ValueType_ValueType_ARRAYSIZE = AutofillUploadContents_ValueType_ValueType_MAX + 1;

const std::string& AutofillUploadContents_ValueType_Name(AutofillUploadContents_ValueType value);
template <typename T> inline const std::string& AutofillUploadContents_ValueType_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, AutofillUploadContents_ValueType>::value || ::std::is_integral<T>::value,
        "Incorrect type passed to function AutofillUploadContents_ValueType_Name.");
    return AutofillUploadContents_ValueType_Name(static_cast<AutofillUploadContents_ValueType>(enum_t_value));
}
bool AutofillUploadContents_ValueType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AutofillUploadContents_ValueType* value);
enum AutofillUploadContents_SingleUsernamePromptEdit : int {
    AutofillUploadContents_SingleUsernamePromptEdit_EDIT_UNSPECIFIED = 0,
    AutofillUploadContents_SingleUsernamePromptEdit_NOT_EDITED_POSITIVE = 1,
    AutofillUploadContents_SingleUsernamePromptEdit_NOT_EDITED_NEGATIVE = 2,
    AutofillUploadContents_SingleUsernamePromptEdit_EDITED_POSITIVE = 3,
    AutofillUploadContents_SingleUsernamePromptEdit_EDITED_NEGATIVE = 4
};
bool AutofillUploadContents_SingleUsernamePromptEdit_IsValid(int value);
constexpr AutofillUploadContents_SingleUsernamePromptEdit AutofillUploadContents_SingleUsernamePromptEdit_SingleUsernamePromptEdit_MIN
    = AutofillUploadContents_SingleUsernamePromptEdit_EDIT_UNSPECIFIED;
constexpr AutofillUploadContents_SingleUsernamePromptEdit AutofillUploadContents_SingleUsernamePromptEdit_SingleUsernamePromptEdit_MAX
    = AutofillUploadContents_SingleUsernamePromptEdit_EDITED_NEGATIVE;
constexpr int AutofillUploadContents_SingleUsernamePromptEdit_SingleUsernamePromptEdit_ARRAYSIZE
    = AutofillUploadContents_SingleUsernamePromptEdit_SingleUsernamePromptEdit_MAX + 1;

const std::string& AutofillUploadContents_SingleUsernamePromptEdit_Name(AutofillUploadContents_SingleUsernamePromptEdit value);
template <typename T> inline const std::string& AutofillUploadContents_SingleUsernamePromptEdit_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, AutofillUploadContents_SingleUsernamePromptEdit>::value || ::std::is_integral<T>::value,
        "Incorrect type passed to function AutofillUploadContents_SingleUsernamePromptEdit_Name.");
    return AutofillUploadContents_SingleUsernamePromptEdit_Name(static_cast<AutofillUploadContents_SingleUsernamePromptEdit>(enum_t_value));
}
bool AutofillUploadContents_SingleUsernamePromptEdit_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AutofillUploadContents_SingleUsernamePromptEdit* value);
enum ButtonTitleType : int {
    NONE = 0,
    BUTTON_ELEMENT_SUBMIT_TYPE = 1,
    BUTTON_ELEMENT_BUTTON_TYPE = 2,
    INPUT_ELEMENT_SUBMIT_TYPE = 3,
    INPUT_ELEMENT_BUTTON_TYPE = 4,
    HYPERLINK = 5,
    DIV = 6,
    SPAN = 7
};
bool ButtonTitleType_IsValid(int value);
constexpr ButtonTitleType ButtonTitleType_MIN = NONE;
constexpr ButtonTitleType ButtonTitleType_MAX = SPAN;
constexpr int ButtonTitleType_ARRAYSIZE = ButtonTitleType_MAX + 1;

const std::string& ButtonTitleType_Name(ButtonTitleType value);
template <typename T> inline const std::string& ButtonTitleType_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, ButtonTitleType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function ButtonTitleType_Name.");
    return ButtonTitleType_Name(static_cast<ButtonTitleType>(enum_t_value));
}
bool ButtonTitleType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ButtonTitleType* value);
// ===================================================================

class AutofillRandomizedValue final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.AutofillRandomizedValue) */ {
public:
    inline AutofillRandomizedValue()
        : AutofillRandomizedValue(nullptr)
    {
    }
    ~AutofillRandomizedValue() override;
    explicit PROTOBUF_CONSTEXPR AutofillRandomizedValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    AutofillRandomizedValue(const AutofillRandomizedValue& from);
    AutofillRandomizedValue(AutofillRandomizedValue&& from) noexcept
        : AutofillRandomizedValue()
    {
        *this = ::std::move(from);
    }

    inline AutofillRandomizedValue& operator=(const AutofillRandomizedValue& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline AutofillRandomizedValue& operator=(AutofillRandomizedValue&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const AutofillRandomizedValue& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const AutofillRandomizedValue* internal_default_instance()
    {
        return reinterpret_cast<const AutofillRandomizedValue*>(&_AutofillRandomizedValue_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 0;

    friend void swap(AutofillRandomizedValue& a, AutofillRandomizedValue& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(AutofillRandomizedValue* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(AutofillRandomizedValue* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    AutofillRandomizedValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<AutofillRandomizedValue>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const AutofillRandomizedValue& from);
    void MergeFrom(const AutofillRandomizedValue& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(AutofillRandomizedValue* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "autofill.AutofillRandomizedValue";
    }

protected:
    explicit AutofillRandomizedValue(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef AutofillRandomizedValue_EncodingType EncodingType;
    static constexpr EncodingType UNSPECIFIED_ENCODING_TYPE = AutofillRandomizedValue_EncodingType_UNSPECIFIED_ENCODING_TYPE;
    static constexpr EncodingType BIT_0 = AutofillRandomizedValue_EncodingType_BIT_0;
    static constexpr EncodingType BIT_1 = AutofillRandomizedValue_EncodingType_BIT_1;
    static constexpr EncodingType BIT_2 = AutofillRandomizedValue_EncodingType_BIT_2;
    static constexpr EncodingType BIT_3 = AutofillRandomizedValue_EncodingType_BIT_3;
    static constexpr EncodingType BIT_4 = AutofillRandomizedValue_EncodingType_BIT_4;
    static constexpr EncodingType BIT_5 = AutofillRandomizedValue_EncodingType_BIT_5;
    static constexpr EncodingType BIT_6 = AutofillRandomizedValue_EncodingType_BIT_6;
    static constexpr EncodingType BIT_7 = AutofillRandomizedValue_EncodingType_BIT_7;
    static constexpr EncodingType EVEN_BITS = AutofillRandomizedValue_EncodingType_EVEN_BITS;
    static constexpr EncodingType ODD_BITS = AutofillRandomizedValue_EncodingType_ODD_BITS;
    static constexpr EncodingType ALL_BITS = AutofillRandomizedValue_EncodingType_ALL_BITS;
    static inline bool EncodingType_IsValid(int value)
    {
        return AutofillRandomizedValue_EncodingType_IsValid(value);
    }
    static constexpr EncodingType EncodingType_MIN = AutofillRandomizedValue_EncodingType_EncodingType_MIN;
    static constexpr EncodingType EncodingType_MAX = AutofillRandomizedValue_EncodingType_EncodingType_MAX;
    static constexpr int EncodingType_ARRAYSIZE = AutofillRandomizedValue_EncodingType_EncodingType_ARRAYSIZE;
    template <typename T> static inline const std::string& EncodingType_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, EncodingType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function EncodingType_Name.");
        return AutofillRandomizedValue_EncodingType_Name(enum_t_value);
    }
    static inline bool EncodingType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EncodingType* value)
    {
        return AutofillRandomizedValue_EncodingType_Parse(name, value);
    }

    // accessors -------------------------------------------------------

    enum : int {
        kEncodedBitsFieldNumber = 2,
        kChecksumFieldNumber = 3,
        kEncodingTypeFieldNumber = 1,
    };
    // optional bytes encoded_bits = 2;
    bool has_encoded_bits() const;

private:
    bool _internal_has_encoded_bits() const;

public:
    void clear_encoded_bits();
    const std::string& encoded_bits() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_encoded_bits(ArgT0&& arg0, ArgT... args);
    std::string* mutable_encoded_bits();
    PROTOBUF_NODISCARD std::string* release_encoded_bits();
    void set_allocated_encoded_bits(std::string* encoded_bits);

private:
    const std::string& _internal_encoded_bits() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_encoded_bits(const std::string& value);
    std::string* _internal_mutable_encoded_bits();

public:
    // optional fixed32 checksum = 3;
    bool has_checksum() const;

private:
    bool _internal_has_checksum() const;

public:
    void clear_checksum();
    uint32_t checksum() const;
    void set_checksum(uint32_t value);

private:
    uint32_t _internal_checksum() const;
    void _internal_set_checksum(uint32_t value);

public:
    // optional .autofill.AutofillRandomizedValue.EncodingType encoding_type = 1 [default = UNSPECIFIED_ENCODING_TYPE];
    bool has_encoding_type() const;

private:
    bool _internal_has_encoding_type() const;

public:
    void clear_encoding_type();
    ::autofill::AutofillRandomizedValue_EncodingType encoding_type() const;
    void set_encoding_type(::autofill::AutofillRandomizedValue_EncodingType value);

private:
    ::autofill::AutofillRandomizedValue_EncodingType _internal_encoding_type() const;
    void _internal_set_encoding_type(::autofill::AutofillRandomizedValue_EncodingType value);

public:
    // @@protoc_insertion_point(class_scope:autofill.AutofillRandomizedValue)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encoded_bits_;
        uint32_t checksum_;
        int encoding_type_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class AutofillRandomizedFormMetadata_ButtonTitle final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.AutofillRandomizedFormMetadata.ButtonTitle) */ {
public:
    inline AutofillRandomizedFormMetadata_ButtonTitle()
        : AutofillRandomizedFormMetadata_ButtonTitle(nullptr)
    {
    }
    ~AutofillRandomizedFormMetadata_ButtonTitle() override;
    explicit PROTOBUF_CONSTEXPR AutofillRandomizedFormMetadata_ButtonTitle(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    AutofillRandomizedFormMetadata_ButtonTitle(const AutofillRandomizedFormMetadata_ButtonTitle& from);
    AutofillRandomizedFormMetadata_ButtonTitle(AutofillRandomizedFormMetadata_ButtonTitle&& from) noexcept
        : AutofillRandomizedFormMetadata_ButtonTitle()
    {
        *this = ::std::move(from);
    }

    inline AutofillRandomizedFormMetadata_ButtonTitle& operator=(const AutofillRandomizedFormMetadata_ButtonTitle& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline AutofillRandomizedFormMetadata_ButtonTitle& operator=(AutofillRandomizedFormMetadata_ButtonTitle&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const AutofillRandomizedFormMetadata_ButtonTitle& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const AutofillRandomizedFormMetadata_ButtonTitle* internal_default_instance()
    {
        return reinterpret_cast<const AutofillRandomizedFormMetadata_ButtonTitle*>(&_AutofillRandomizedFormMetadata_ButtonTitle_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 1;

    friend void swap(AutofillRandomizedFormMetadata_ButtonTitle& a, AutofillRandomizedFormMetadata_ButtonTitle& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(AutofillRandomizedFormMetadata_ButtonTitle* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(AutofillRandomizedFormMetadata_ButtonTitle* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    AutofillRandomizedFormMetadata_ButtonTitle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<AutofillRandomizedFormMetadata_ButtonTitle>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const AutofillRandomizedFormMetadata_ButtonTitle& from);
    void MergeFrom(const AutofillRandomizedFormMetadata_ButtonTitle& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(AutofillRandomizedFormMetadata_ButtonTitle* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "autofill.AutofillRandomizedFormMetadata.ButtonTitle";
    }

protected:
    explicit AutofillRandomizedFormMetadata_ButtonTitle(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kTitleFieldNumber = 1,
        kTypeFieldNumber = 2,
    };
    // optional .autofill.AutofillRandomizedValue title = 1;
    bool has_title() const;

private:
    bool _internal_has_title() const;

public:
    void clear_title();
    const ::autofill::AutofillRandomizedValue& title() const;
    PROTOBUF_NODISCARD ::autofill::AutofillRandomizedValue* release_title();
    ::autofill::AutofillRandomizedValue* mutable_title();
    void set_allocated_title(::autofill::AutofillRandomizedValue* title);

private:
    const ::autofill::AutofillRandomizedValue& _internal_title() const;
    ::autofill::AutofillRandomizedValue* _internal_mutable_title();

public:
    void unsafe_arena_set_allocated_title(::autofill::AutofillRandomizedValue* title);
    ::autofill::AutofillRandomizedValue* unsafe_arena_release_title();

    // optional .autofill.ButtonTitleType type = 2;
    bool has_type() const;

private:
    bool _internal_has_type() const;

public:
    void clear_type();
    ::autofill::ButtonTitleType type() const;
    void set_type(::autofill::ButtonTitleType value);

private:
    ::autofill::ButtonTitleType _internal_type() const;
    void _internal_set_type(::autofill::ButtonTitleType value);

public:
    // @@protoc_insertion_point(class_scope:autofill.AutofillRandomizedFormMetadata.ButtonTitle)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::autofill::AutofillRandomizedValue* title_;
        int type_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class AutofillRandomizedFormMetadata final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.AutofillRandomizedFormMetadata) */ {
public:
    inline AutofillRandomizedFormMetadata()
        : AutofillRandomizedFormMetadata(nullptr)
    {
    }
    ~AutofillRandomizedFormMetadata() override;
    explicit PROTOBUF_CONSTEXPR AutofillRandomizedFormMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    AutofillRandomizedFormMetadata(const AutofillRandomizedFormMetadata& from);
    AutofillRandomizedFormMetadata(AutofillRandomizedFormMetadata&& from) noexcept
        : AutofillRandomizedFormMetadata()
    {
        *this = ::std::move(from);
    }

    inline AutofillRandomizedFormMetadata& operator=(const AutofillRandomizedFormMetadata& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline AutofillRandomizedFormMetadata& operator=(AutofillRandomizedFormMetadata&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const AutofillRandomizedFormMetadata& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const AutofillRandomizedFormMetadata* internal_default_instance()
    {
        return reinterpret_cast<const AutofillRandomizedFormMetadata*>(&_AutofillRandomizedFormMetadata_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 2;

    friend void swap(AutofillRandomizedFormMetadata& a, AutofillRandomizedFormMetadata& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(AutofillRandomizedFormMetadata* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(AutofillRandomizedFormMetadata* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    AutofillRandomizedFormMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<AutofillRandomizedFormMetadata>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const AutofillRandomizedFormMetadata& from);
    void MergeFrom(const AutofillRandomizedFormMetadata& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(AutofillRandomizedFormMetadata* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "autofill.AutofillRandomizedFormMetadata";
    }

protected:
    explicit AutofillRandomizedFormMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef AutofillRandomizedFormMetadata_ButtonTitle ButtonTitle;

    // accessors -------------------------------------------------------

    enum : int {
        kButtonTitleFieldNumber = 5,
        kIdFieldNumber = 1,
        kNameFieldNumber = 2,
        kActionFieldNumber = 3,
        kUrlFieldNumber = 4,
    };
    // repeated .autofill.AutofillRandomizedFormMetadata.ButtonTitle button_title = 5;
    int button_title_size() const;

private:
    int _internal_button_title_size() const;

public:
    void clear_button_title();
    ::autofill::AutofillRandomizedFormMetadata_ButtonTitle* mutable_button_title(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::autofill::AutofillRandomizedFormMetadata_ButtonTitle>* mutable_button_title();

private:
    const ::autofill::AutofillRandomizedFormMetadata_ButtonTitle& _internal_button_title(int index) const;
    ::autofill::AutofillRandomizedFormMetadata_ButtonTitle* _internal_add_button_title();

public:
    const ::autofill::AutofillRandomizedFormMetadata_ButtonTitle& button_title(int index) const;
    ::autofill::AutofillRandomizedFormMetadata_ButtonTitle* add_button_title();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::autofill::AutofillRandomizedFormMetadata_ButtonTitle>& button_title() const;

    // optional .autofill.AutofillRandomizedValue id = 1;
    bool has_id() const;

private:
    bool _internal_has_id() const;

public:
    void clear_id();
    const ::autofill::AutofillRandomizedValue& id() const;
    PROTOBUF_NODISCARD ::autofill::AutofillRandomizedValue* release_id();
    ::autofill::AutofillRandomizedValue* mutable_id();
    void set_allocated_id(::autofill::AutofillRandomizedValue* id);

private:
    const ::autofill::AutofillRandomizedValue& _internal_id() const;
    ::autofill::AutofillRandomizedValue* _internal_mutable_id();

public:
    void unsafe_arena_set_allocated_id(::autofill::AutofillRandomizedValue* id);
    ::autofill::AutofillRandomizedValue* unsafe_arena_release_id();

    // optional .autofill.AutofillRandomizedValue name = 2;
    bool has_name() const;

private:
    bool _internal_has_name() const;

public:
    void clear_name();
    const ::autofill::AutofillRandomizedValue& name() const;
    PROTOBUF_NODISCARD ::autofill::AutofillRandomizedValue* release_name();
    ::autofill::AutofillRandomizedValue* mutable_name();
    void set_allocated_name(::autofill::AutofillRandomizedValue* name);

private:
    const ::autofill::AutofillRandomizedValue& _internal_name() const;
    ::autofill::AutofillRandomizedValue* _internal_mutable_name();

public:
    void unsafe_arena_set_allocated_name(::autofill::AutofillRandomizedValue* name);
    ::autofill::AutofillRandomizedValue* unsafe_arena_release_name();

    // optional .autofill.AutofillRandomizedValue action = 3;
    bool has_action() const;

private:
    bool _internal_has_action() const;

public:
    void clear_action();
    const ::autofill::AutofillRandomizedValue& action() const;
    PROTOBUF_NODISCARD ::autofill::AutofillRandomizedValue* release_action();
    ::autofill::AutofillRandomizedValue* mutable_action();
    void set_allocated_action(::autofill::AutofillRandomizedValue* action);

private:
    const ::autofill::AutofillRandomizedValue& _internal_action() const;
    ::autofill::AutofillRandomizedValue* _internal_mutable_action();

public:
    void unsafe_arena_set_allocated_action(::autofill::AutofillRandomizedValue* action);
    ::autofill::AutofillRandomizedValue* unsafe_arena_release_action();

    // optional .autofill.AutofillRandomizedValue url = 4;
    bool has_url() const;

private:
    bool _internal_has_url() const;

public:
    void clear_url();
    const ::autofill::AutofillRandomizedValue& url() const;
    PROTOBUF_NODISCARD ::autofill::AutofillRandomizedValue* release_url();
    ::autofill::AutofillRandomizedValue* mutable_url();
    void set_allocated_url(::autofill::AutofillRandomizedValue* url);

private:
    const ::autofill::AutofillRandomizedValue& _internal_url() const;
    ::autofill::AutofillRandomizedValue* _internal_mutable_url();

public:
    void unsafe_arena_set_allocated_url(::autofill::AutofillRandomizedValue* url);
    ::autofill::AutofillRandomizedValue* unsafe_arena_release_url();

    // @@protoc_insertion_point(class_scope:autofill.AutofillRandomizedFormMetadata)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::autofill::AutofillRandomizedFormMetadata_ButtonTitle> button_title_;
        ::autofill::AutofillRandomizedValue* id_;
        ::autofill::AutofillRandomizedValue* name_;
        ::autofill::AutofillRandomizedValue* action_;
        ::autofill::AutofillRandomizedValue* url_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class AutofillRandomizedFieldMetadata final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.AutofillRandomizedFieldMetadata) */ {
public:
    inline AutofillRandomizedFieldMetadata()
        : AutofillRandomizedFieldMetadata(nullptr)
    {
    }
    ~AutofillRandomizedFieldMetadata() override;
    explicit PROTOBUF_CONSTEXPR AutofillRandomizedFieldMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    AutofillRandomizedFieldMetadata(const AutofillRandomizedFieldMetadata& from);
    AutofillRandomizedFieldMetadata(AutofillRandomizedFieldMetadata&& from) noexcept
        : AutofillRandomizedFieldMetadata()
    {
        *this = ::std::move(from);
    }

    inline AutofillRandomizedFieldMetadata& operator=(const AutofillRandomizedFieldMetadata& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline AutofillRandomizedFieldMetadata& operator=(AutofillRandomizedFieldMetadata&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const AutofillRandomizedFieldMetadata& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const AutofillRandomizedFieldMetadata* internal_default_instance()
    {
        return reinterpret_cast<const AutofillRandomizedFieldMetadata*>(&_AutofillRandomizedFieldMetadata_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 3;

    friend void swap(AutofillRandomizedFieldMetadata& a, AutofillRandomizedFieldMetadata& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(AutofillRandomizedFieldMetadata* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(AutofillRandomizedFieldMetadata* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    AutofillRandomizedFieldMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<AutofillRandomizedFieldMetadata>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const AutofillRandomizedFieldMetadata& from);
    void MergeFrom(const AutofillRandomizedFieldMetadata& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(AutofillRandomizedFieldMetadata* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "autofill.AutofillRandomizedFieldMetadata";
    }

protected:
    explicit AutofillRandomizedFieldMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kIdFieldNumber = 1,
        kNameFieldNumber = 2,
        kTypeFieldNumber = 3,
        kLabelFieldNumber = 4,
        kAriaLabelFieldNumber = 5,
        kAriaDescriptionFieldNumber = 6,
        kCssClassFieldNumber = 7,
        kPlaceholderFieldNumber = 8,
        kInitialValueHashFieldNumber = 9,
        kAutocompleteFieldNumber = 10,
    };
    // optional .autofill.AutofillRandomizedValue id = 1;
    bool has_id() const;

private:
    bool _internal_has_id() const;

public:
    void clear_id();
    const ::autofill::AutofillRandomizedValue& id() const;
    PROTOBUF_NODISCARD ::autofill::AutofillRandomizedValue* release_id();
    ::autofill::AutofillRandomizedValue* mutable_id();
    void set_allocated_id(::autofill::AutofillRandomizedValue* id);

private:
    const ::autofill::AutofillRandomizedValue& _internal_id() const;
    ::autofill::AutofillRandomizedValue* _internal_mutable_id();

public:
    void unsafe_arena_set_allocated_id(::autofill::AutofillRandomizedValue* id);
    ::autofill::AutofillRandomizedValue* unsafe_arena_release_id();

    // optional .autofill.AutofillRandomizedValue name = 2;
    bool has_name() const;

private:
    bool _internal_has_name() const;

public:
    void clear_name();
    const ::autofill::AutofillRandomizedValue& name() const;
    PROTOBUF_NODISCARD ::autofill::AutofillRandomizedValue* release_name();
    ::autofill::AutofillRandomizedValue* mutable_name();
    void set_allocated_name(::autofill::AutofillRandomizedValue* name);

private:
    const ::autofill::AutofillRandomizedValue& _internal_name() const;
    ::autofill::AutofillRandomizedValue* _internal_mutable_name();

public:
    void unsafe_arena_set_allocated_name(::autofill::AutofillRandomizedValue* name);
    ::autofill::AutofillRandomizedValue* unsafe_arena_release_name();

    // optional .autofill.AutofillRandomizedValue type = 3;
    bool has_type() const;

private:
    bool _internal_has_type() const;

public:
    void clear_type();
    const ::autofill::AutofillRandomizedValue& type() const;
    PROTOBUF_NODISCARD ::autofill::AutofillRandomizedValue* release_type();
    ::autofill::AutofillRandomizedValue* mutable_type();
    void set_allocated_type(::autofill::AutofillRandomizedValue* type);

private:
    const ::autofill::AutofillRandomizedValue& _internal_type() const;
    ::autofill::AutofillRandomizedValue* _internal_mutable_type();

public:
    void unsafe_arena_set_allocated_type(::autofill::AutofillRandomizedValue* type);
    ::autofill::AutofillRandomizedValue* unsafe_arena_release_type();

    // optional .autofill.AutofillRandomizedValue label = 4;
    bool has_label() const;

private:
    bool _internal_has_label() const;

public:
    void clear_label();
    const ::autofill::AutofillRandomizedValue& label() const;
    PROTOBUF_NODISCARD ::autofill::AutofillRandomizedValue* release_label();
    ::autofill::AutofillRandomizedValue* mutable_label();
    void set_allocated_label(::autofill::AutofillRandomizedValue* label);

private:
    const ::autofill::AutofillRandomizedValue& _internal_label() const;
    ::autofill::AutofillRandomizedValue* _internal_mutable_label();

public:
    void unsafe_arena_set_allocated_label(::autofill::AutofillRandomizedValue* label);
    ::autofill::AutofillRandomizedValue* unsafe_arena_release_label();

    // optional .autofill.AutofillRandomizedValue aria_label = 5;
    bool has_aria_label() const;

private:
    bool _internal_has_aria_label() const;

public:
    void clear_aria_label();
    const ::autofill::AutofillRandomizedValue& aria_label() const;
    PROTOBUF_NODISCARD ::autofill::AutofillRandomizedValue* release_aria_label();
    ::autofill::AutofillRandomizedValue* mutable_aria_label();
    void set_allocated_aria_label(::autofill::AutofillRandomizedValue* aria_label);

private:
    const ::autofill::AutofillRandomizedValue& _internal_aria_label() const;
    ::autofill::AutofillRandomizedValue* _internal_mutable_aria_label();

public:
    void unsafe_arena_set_allocated_aria_label(::autofill::AutofillRandomizedValue* aria_label);
    ::autofill::AutofillRandomizedValue* unsafe_arena_release_aria_label();

    // optional .autofill.AutofillRandomizedValue aria_description = 6;
    bool has_aria_description() const;

private:
    bool _internal_has_aria_description() const;

public:
    void clear_aria_description();
    const ::autofill::AutofillRandomizedValue& aria_description() const;
    PROTOBUF_NODISCARD ::autofill::AutofillRandomizedValue* release_aria_description();
    ::autofill::AutofillRandomizedValue* mutable_aria_description();
    void set_allocated_aria_description(::autofill::AutofillRandomizedValue* aria_description);

private:
    const ::autofill::AutofillRandomizedValue& _internal_aria_description() const;
    ::autofill::AutofillRandomizedValue* _internal_mutable_aria_description();

public:
    void unsafe_arena_set_allocated_aria_description(::autofill::AutofillRandomizedValue* aria_description);
    ::autofill::AutofillRandomizedValue* unsafe_arena_release_aria_description();

    // optional .autofill.AutofillRandomizedValue css_class = 7;
    bool has_css_class() const;

private:
    bool _internal_has_css_class() const;

public:
    void clear_css_class();
    const ::autofill::AutofillRandomizedValue& css_class() const;
    PROTOBUF_NODISCARD ::autofill::AutofillRandomizedValue* release_css_class();
    ::autofill::AutofillRandomizedValue* mutable_css_class();
    void set_allocated_css_class(::autofill::AutofillRandomizedValue* css_class);

private:
    const ::autofill::AutofillRandomizedValue& _internal_css_class() const;
    ::autofill::AutofillRandomizedValue* _internal_mutable_css_class();

public:
    void unsafe_arena_set_allocated_css_class(::autofill::AutofillRandomizedValue* css_class);
    ::autofill::AutofillRandomizedValue* unsafe_arena_release_css_class();

    // optional .autofill.AutofillRandomizedValue placeholder = 8;
    bool has_placeholder() const;

private:
    bool _internal_has_placeholder() const;

public:
    void clear_placeholder();
    const ::autofill::AutofillRandomizedValue& placeholder() const;
    PROTOBUF_NODISCARD ::autofill::AutofillRandomizedValue* release_placeholder();
    ::autofill::AutofillRandomizedValue* mutable_placeholder();
    void set_allocated_placeholder(::autofill::AutofillRandomizedValue* placeholder);

private:
    const ::autofill::AutofillRandomizedValue& _internal_placeholder() const;
    ::autofill::AutofillRandomizedValue* _internal_mutable_placeholder();

public:
    void unsafe_arena_set_allocated_placeholder(::autofill::AutofillRandomizedValue* placeholder);
    ::autofill::AutofillRandomizedValue* unsafe_arena_release_placeholder();

    // optional .autofill.AutofillRandomizedValue initial_value_hash = 9;
    bool has_initial_value_hash() const;

private:
    bool _internal_has_initial_value_hash() const;

public:
    void clear_initial_value_hash();
    const ::autofill::AutofillRandomizedValue& initial_value_hash() const;
    PROTOBUF_NODISCARD ::autofill::AutofillRandomizedValue* release_initial_value_hash();
    ::autofill::AutofillRandomizedValue* mutable_initial_value_hash();
    void set_allocated_initial_value_hash(::autofill::AutofillRandomizedValue* initial_value_hash);

private:
    const ::autofill::AutofillRandomizedValue& _internal_initial_value_hash() const;
    ::autofill::AutofillRandomizedValue* _internal_mutable_initial_value_hash();

public:
    void unsafe_arena_set_allocated_initial_value_hash(::autofill::AutofillRandomizedValue* initial_value_hash);
    ::autofill::AutofillRandomizedValue* unsafe_arena_release_initial_value_hash();

    // optional .autofill.AutofillRandomizedValue autocomplete = 10;
    bool has_autocomplete() const;

private:
    bool _internal_has_autocomplete() const;

public:
    void clear_autocomplete();
    const ::autofill::AutofillRandomizedValue& autocomplete() const;
    PROTOBUF_NODISCARD ::autofill::AutofillRandomizedValue* release_autocomplete();
    ::autofill::AutofillRandomizedValue* mutable_autocomplete();
    void set_allocated_autocomplete(::autofill::AutofillRandomizedValue* autocomplete);

private:
    const ::autofill::AutofillRandomizedValue& _internal_autocomplete() const;
    ::autofill::AutofillRandomizedValue* _internal_mutable_autocomplete();

public:
    void unsafe_arena_set_allocated_autocomplete(::autofill::AutofillRandomizedValue* autocomplete);
    ::autofill::AutofillRandomizedValue* unsafe_arena_release_autocomplete();

    // @@protoc_insertion_point(class_scope:autofill.AutofillRandomizedFieldMetadata)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::autofill::AutofillRandomizedValue* id_;
        ::autofill::AutofillRandomizedValue* name_;
        ::autofill::AutofillRandomizedValue* type_;
        ::autofill::AutofillRandomizedValue* label_;
        ::autofill::AutofillRandomizedValue* aria_label_;
        ::autofill::AutofillRandomizedValue* aria_description_;
        ::autofill::AutofillRandomizedValue* css_class_;
        ::autofill::AutofillRandomizedValue* placeholder_;
        ::autofill::AutofillRandomizedValue* initial_value_hash_;
        ::autofill::AutofillRandomizedValue* autocomplete_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class AutofillUploadContents_Field final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.AutofillUploadContents.Field) */ {
public:
    inline AutofillUploadContents_Field()
        : AutofillUploadContents_Field(nullptr)
    {
    }
    ~AutofillUploadContents_Field() override;
    explicit PROTOBUF_CONSTEXPR AutofillUploadContents_Field(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    AutofillUploadContents_Field(const AutofillUploadContents_Field& from);
    AutofillUploadContents_Field(AutofillUploadContents_Field&& from) noexcept
        : AutofillUploadContents_Field()
    {
        *this = ::std::move(from);
    }

    inline AutofillUploadContents_Field& operator=(const AutofillUploadContents_Field& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline AutofillUploadContents_Field& operator=(AutofillUploadContents_Field&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const AutofillUploadContents_Field& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const AutofillUploadContents_Field* internal_default_instance()
    {
        return reinterpret_cast<const AutofillUploadContents_Field*>(&_AutofillUploadContents_Field_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 4;

    friend void swap(AutofillUploadContents_Field& a, AutofillUploadContents_Field& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(AutofillUploadContents_Field* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(AutofillUploadContents_Field* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    AutofillUploadContents_Field* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<AutofillUploadContents_Field>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const AutofillUploadContents_Field& from);
    void MergeFrom(const AutofillUploadContents_Field& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(AutofillUploadContents_Field* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "autofill.AutofillUploadContents.Field";
    }

protected:
    explicit AutofillUploadContents_Field(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef AutofillUploadContents_Field_PasswordGenerationType PasswordGenerationType;
    static constexpr PasswordGenerationType NO_GENERATION = AutofillUploadContents_Field_PasswordGenerationType_NO_GENERATION;
    static constexpr PasswordGenerationType AUTOMATICALLY_TRIGGERED_GENERATION_ON_SIGN_UP_FORM
        = AutofillUploadContents_Field_PasswordGenerationType_AUTOMATICALLY_TRIGGERED_GENERATION_ON_SIGN_UP_FORM;
    static constexpr PasswordGenerationType AUTOMATICALLY_TRIGGERED_GENERATION_ON_CHANGE_PASSWORD_FORM
        = AutofillUploadContents_Field_PasswordGenerationType_AUTOMATICALLY_TRIGGERED_GENERATION_ON_CHANGE_PASSWORD_FORM;
    static constexpr PasswordGenerationType MANUALLY_TRIGGERED_GENERATION_ON_SIGN_UP_FORM
        = AutofillUploadContents_Field_PasswordGenerationType_MANUALLY_TRIGGERED_GENERATION_ON_SIGN_UP_FORM;
    static constexpr PasswordGenerationType MANUALLY_TRIGGERED_GENERATION_ON_CHANGE_PASSWORD_FORM
        = AutofillUploadContents_Field_PasswordGenerationType_MANUALLY_TRIGGERED_GENERATION_ON_CHANGE_PASSWORD_FORM;
    static constexpr PasswordGenerationType IGNORED_GENERATION_POPUP = AutofillUploadContents_Field_PasswordGenerationType_IGNORED_GENERATION_POPUP;
    static inline bool PasswordGenerationType_IsValid(int value)
    {
        return AutofillUploadContents_Field_PasswordGenerationType_IsValid(value);
    }
    static constexpr PasswordGenerationType PasswordGenerationType_MIN = AutofillUploadContents_Field_PasswordGenerationType_PasswordGenerationType_MIN;
    static constexpr PasswordGenerationType PasswordGenerationType_MAX = AutofillUploadContents_Field_PasswordGenerationType_PasswordGenerationType_MAX;
    static constexpr int PasswordGenerationType_ARRAYSIZE = AutofillUploadContents_Field_PasswordGenerationType_PasswordGenerationType_ARRAYSIZE;
    template <typename T> static inline const std::string& PasswordGenerationType_Name(T enum_t_value)
    {
        static_assert(
            ::std::is_same<T, PasswordGenerationType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function PasswordGenerationType_Name.");
        return AutofillUploadContents_Field_PasswordGenerationType_Name(enum_t_value);
    }
    static inline bool PasswordGenerationType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PasswordGenerationType* value)
    {
        return AutofillUploadContents_Field_PasswordGenerationType_Parse(name, value);
    }

    typedef AutofillUploadContents_Field_VoteType VoteType;
    static constexpr VoteType NO_INFORMATION = AutofillUploadContents_Field_VoteType_NO_INFORMATION;
    static constexpr VoteType CREDENTIALS_REUSED = AutofillUploadContents_Field_VoteType_CREDENTIALS_REUSED;
    static constexpr VoteType USERNAME_OVERWRITTEN = AutofillUploadContents_Field_VoteType_USERNAME_OVERWRITTEN;
    static constexpr VoteType USERNAME_EDITED = AutofillUploadContents_Field_VoteType_USERNAME_EDITED;
    static constexpr VoteType BASE_HEURISTIC = AutofillUploadContents_Field_VoteType_BASE_HEURISTIC;
    static constexpr VoteType HTML_CLASSIFIER = AutofillUploadContents_Field_VoteType_HTML_CLASSIFIER;
    static constexpr VoteType FIRST_USE = AutofillUploadContents_Field_VoteType_FIRST_USE;
    static inline bool VoteType_IsValid(int value)
    {
        return AutofillUploadContents_Field_VoteType_IsValid(value);
    }
    static constexpr VoteType VoteType_MIN = AutofillUploadContents_Field_VoteType_VoteType_MIN;
    static constexpr VoteType VoteType_MAX = AutofillUploadContents_Field_VoteType_VoteType_MAX;
    static constexpr int VoteType_ARRAYSIZE = AutofillUploadContents_Field_VoteType_VoteType_ARRAYSIZE;
    template <typename T> static inline const std::string& VoteType_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, VoteType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function VoteType_Name.");
        return AutofillUploadContents_Field_VoteType_Name(enum_t_value);
    }
    static inline bool VoteType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, VoteType* value)
    {
        return AutofillUploadContents_Field_VoteType_Parse(name, value);
    }

    typedef AutofillUploadContents_Field_SingleUsernameVoteType SingleUsernameVoteType;
    static constexpr SingleUsernameVoteType DEFAULT = AutofillUploadContents_Field_SingleUsernameVoteType_DEFAULT;
    static constexpr SingleUsernameVoteType WEAK = AutofillUploadContents_Field_SingleUsernameVoteType_WEAK;
    static constexpr SingleUsernameVoteType STRONG = AutofillUploadContents_Field_SingleUsernameVoteType_STRONG;
    static constexpr SingleUsernameVoteType WEAK_FORGOT_PASSWORD = AutofillUploadContents_Field_SingleUsernameVoteType_WEAK_FORGOT_PASSWORD;
    static constexpr SingleUsernameVoteType STRONG_FORGOT_PASSWORD = AutofillUploadContents_Field_SingleUsernameVoteType_STRONG_FORGOT_PASSWORD;
    static constexpr SingleUsernameVoteType IN_FORM_OVERRULE = AutofillUploadContents_Field_SingleUsernameVoteType_IN_FORM_OVERRULE;
    static inline bool SingleUsernameVoteType_IsValid(int value)
    {
        return AutofillUploadContents_Field_SingleUsernameVoteType_IsValid(value);
    }
    static constexpr SingleUsernameVoteType SingleUsernameVoteType_MIN = AutofillUploadContents_Field_SingleUsernameVoteType_SingleUsernameVoteType_MIN;
    static constexpr SingleUsernameVoteType SingleUsernameVoteType_MAX = AutofillUploadContents_Field_SingleUsernameVoteType_SingleUsernameVoteType_MAX;
    static constexpr int SingleUsernameVoteType_ARRAYSIZE = AutofillUploadContents_Field_SingleUsernameVoteType_SingleUsernameVoteType_ARRAYSIZE;
    template <typename T> static inline const std::string& SingleUsernameVoteType_Name(T enum_t_value)
    {
        static_assert(
            ::std::is_same<T, SingleUsernameVoteType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function SingleUsernameVoteType_Name.");
        return AutofillUploadContents_Field_SingleUsernameVoteType_Name(enum_t_value);
    }
    static inline bool SingleUsernameVoteType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SingleUsernameVoteType* value)
    {
        return AutofillUploadContents_Field_SingleUsernameVoteType_Parse(name, value);
    }

    // accessors -------------------------------------------------------

    enum : int {
        kAutofillTypeFieldNumber = 7,
        kNameFieldNumber = 8,
        kAutocompleteFieldNumber = 9,
        kTypeFieldNumber = 10,
        kCssClassesFieldNumber = 19,
        kIdFieldNumber = 21,
        kRandomizedFieldMetadataFieldNumber = 33,
        kSignatureFieldNumber = 6,
        kGenerationTypeFieldNumber = 17,
        kPropertiesMaskFieldNumber = 20,
        kVoteTypeFieldNumber = 23,
        kGeneratedPasswordChangedFieldNumber = 22,
        kIsMostRecentSingleUsernameCandidateFieldNumber = 46,
        kInitialValueChangedFieldNumber = 47,
        kInitialValueHashFieldNumber = 40,
        kSingleUsernameVoteTypeFieldNumber = 41,
    };
    // repeated fixed32 autofill_type = 7;
    int autofill_type_size() const;

private:
    int _internal_autofill_type_size() const;

public:
    void clear_autofill_type();

private:
    uint32_t _internal_autofill_type(int index) const;
    const ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t>& _internal_autofill_type() const;
    void _internal_add_autofill_type(uint32_t value);
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t>* _internal_mutable_autofill_type();

public:
    uint32_t autofill_type(int index) const;
    void set_autofill_type(int index, uint32_t value);
    void add_autofill_type(uint32_t value);
    const ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t>& autofill_type() const;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t>* mutable_autofill_type();

    // optional string name = 8;
    bool has_name() const;

private:
    bool _internal_has_name() const;

public:
    void clear_name();
    const std::string& name() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_name(ArgT0&& arg0, ArgT... args);
    std::string* mutable_name();
    PROTOBUF_NODISCARD std::string* release_name();
    void set_allocated_name(std::string* name);

private:
    const std::string& _internal_name() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
    std::string* _internal_mutable_name();

public:
    // optional string autocomplete = 9;
    bool has_autocomplete() const;

private:
    bool _internal_has_autocomplete() const;

public:
    void clear_autocomplete();
    const std::string& autocomplete() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_autocomplete(ArgT0&& arg0, ArgT... args);
    std::string* mutable_autocomplete();
    PROTOBUF_NODISCARD std::string* release_autocomplete();
    void set_allocated_autocomplete(std::string* autocomplete);

private:
    const std::string& _internal_autocomplete() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_autocomplete(const std::string& value);
    std::string* _internal_mutable_autocomplete();

public:
    // optional string type = 10;
    bool has_type() const;

private:
    bool _internal_has_type() const;

public:
    void clear_type();
    const std::string& type() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_type(ArgT0&& arg0, ArgT... args);
    std::string* mutable_type();
    PROTOBUF_NODISCARD std::string* release_type();
    void set_allocated_type(std::string* type);

private:
    const std::string& _internal_type() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
    std::string* _internal_mutable_type();

public:
    // optional string css_classes = 19;
    bool has_css_classes() const;

private:
    bool _internal_has_css_classes() const;

public:
    void clear_css_classes();
    const std::string& css_classes() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_css_classes(ArgT0&& arg0, ArgT... args);
    std::string* mutable_css_classes();
    PROTOBUF_NODISCARD std::string* release_css_classes();
    void set_allocated_css_classes(std::string* css_classes);

private:
    const std::string& _internal_css_classes() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_css_classes(const std::string& value);
    std::string* _internal_mutable_css_classes();

public:
    // optional string id = 21;
    bool has_id() const;

private:
    bool _internal_has_id() const;

public:
    void clear_id();
    const std::string& id() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_id(ArgT0&& arg0, ArgT... args);
    std::string* mutable_id();
    PROTOBUF_NODISCARD std::string* release_id();
    void set_allocated_id(std::string* id);

private:
    const std::string& _internal_id() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
    std::string* _internal_mutable_id();

public:
    // optional .autofill.AutofillRandomizedFieldMetadata randomized_field_metadata = 33;
    bool has_randomized_field_metadata() const;

private:
    bool _internal_has_randomized_field_metadata() const;

public:
    void clear_randomized_field_metadata();
    const ::autofill::AutofillRandomizedFieldMetadata& randomized_field_metadata() const;
    PROTOBUF_NODISCARD ::autofill::AutofillRandomizedFieldMetadata* release_randomized_field_metadata();
    ::autofill::AutofillRandomizedFieldMetadata* mutable_randomized_field_metadata();
    void set_allocated_randomized_field_metadata(::autofill::AutofillRandomizedFieldMetadata* randomized_field_metadata);

private:
    const ::autofill::AutofillRandomizedFieldMetadata& _internal_randomized_field_metadata() const;
    ::autofill::AutofillRandomizedFieldMetadata* _internal_mutable_randomized_field_metadata();

public:
    void unsafe_arena_set_allocated_randomized_field_metadata(::autofill::AutofillRandomizedFieldMetadata* randomized_field_metadata);
    ::autofill::AutofillRandomizedFieldMetadata* unsafe_arena_release_randomized_field_metadata();

    // required fixed32 signature = 6;
    bool has_signature() const;

private:
    bool _internal_has_signature() const;

public:
    void clear_signature();
    uint32_t signature() const;
    void set_signature(uint32_t value);

private:
    uint32_t _internal_signature() const;
    void _internal_set_signature(uint32_t value);

public:
    // optional .autofill.AutofillUploadContents.Field.PasswordGenerationType generation_type = 17;
    bool has_generation_type() const;

private:
    bool _internal_has_generation_type() const;

public:
    void clear_generation_type();
    ::autofill::AutofillUploadContents_Field_PasswordGenerationType generation_type() const;
    void set_generation_type(::autofill::AutofillUploadContents_Field_PasswordGenerationType value);

private:
    ::autofill::AutofillUploadContents_Field_PasswordGenerationType _internal_generation_type() const;
    void _internal_set_generation_type(::autofill::AutofillUploadContents_Field_PasswordGenerationType value);

public:
    // optional uint32 properties_mask = 20;
    bool has_properties_mask() const;

private:
    bool _internal_has_properties_mask() const;

public:
    void clear_properties_mask();
    uint32_t properties_mask() const;
    void set_properties_mask(uint32_t value);

private:
    uint32_t _internal_properties_mask() const;
    void _internal_set_properties_mask(uint32_t value);

public:
    // optional .autofill.AutofillUploadContents.Field.VoteType vote_type = 23;
    bool has_vote_type() const;

private:
    bool _internal_has_vote_type() const;

public:
    void clear_vote_type();
    ::autofill::AutofillUploadContents_Field_VoteType vote_type() const;
    void set_vote_type(::autofill::AutofillUploadContents_Field_VoteType value);

private:
    ::autofill::AutofillUploadContents_Field_VoteType _internal_vote_type() const;
    void _internal_set_vote_type(::autofill::AutofillUploadContents_Field_VoteType value);

public:
    // optional bool generated_password_changed = 22;
    bool has_generated_password_changed() const;

private:
    bool _internal_has_generated_password_changed() const;

public:
    void clear_generated_password_changed();
    bool generated_password_changed() const;
    void set_generated_password_changed(bool value);

private:
    bool _internal_generated_password_changed() const;
    void _internal_set_generated_password_changed(bool value);

public:
    // optional bool is_most_recent_single_username_candidate = 46;
    bool has_is_most_recent_single_username_candidate() const;

private:
    bool _internal_has_is_most_recent_single_username_candidate() const;

public:
    void clear_is_most_recent_single_username_candidate();
    bool is_most_recent_single_username_candidate() const;
    void set_is_most_recent_single_username_candidate(bool value);

private:
    bool _internal_is_most_recent_single_username_candidate() const;
    void _internal_set_is_most_recent_single_username_candidate(bool value);

public:
    // optional bool initial_value_changed = 47;
    bool has_initial_value_changed() const;

private:
    bool _internal_has_initial_value_changed() const;

public:
    void clear_initial_value_changed();
    bool initial_value_changed() const;
    void set_initial_value_changed(bool value);

private:
    bool _internal_initial_value_changed() const;
    void _internal_set_initial_value_changed(bool value);

public:
    // optional uint32 initial_value_hash = 40;
    bool has_initial_value_hash() const;

private:
    bool _internal_has_initial_value_hash() const;

public:
    void clear_initial_value_hash();
    uint32_t initial_value_hash() const;
    void set_initial_value_hash(uint32_t value);

private:
    uint32_t _internal_initial_value_hash() const;
    void _internal_set_initial_value_hash(uint32_t value);

public:
    // optional .autofill.AutofillUploadContents.Field.SingleUsernameVoteType single_username_vote_type = 41;
    bool has_single_username_vote_type() const;

private:
    bool _internal_has_single_username_vote_type() const;

public:
    void clear_single_username_vote_type();
    ::autofill::AutofillUploadContents_Field_SingleUsernameVoteType single_username_vote_type() const;
    void set_single_username_vote_type(::autofill::AutofillUploadContents_Field_SingleUsernameVoteType value);

private:
    ::autofill::AutofillUploadContents_Field_SingleUsernameVoteType _internal_single_username_vote_type() const;
    void _internal_set_single_username_vote_type(::autofill::AutofillUploadContents_Field_SingleUsernameVoteType value);

public:
    // @@protoc_insertion_point(class_scope:autofill.AutofillUploadContents.Field)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t> autofill_type_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr autocomplete_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr css_classes_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
        ::autofill::AutofillRandomizedFieldMetadata* randomized_field_metadata_;
        uint32_t signature_;
        int generation_type_;
        uint32_t properties_mask_;
        int vote_type_;
        bool generated_password_changed_;
        bool is_most_recent_single_username_candidate_;
        bool initial_value_changed_;
        uint32_t initial_value_hash_;
        int single_username_vote_type_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class AutofillUploadContents_ButtonTitle final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.AutofillUploadContents.ButtonTitle) */ {
public:
    inline AutofillUploadContents_ButtonTitle()
        : AutofillUploadContents_ButtonTitle(nullptr)
    {
    }
    ~AutofillUploadContents_ButtonTitle() override;
    explicit PROTOBUF_CONSTEXPR AutofillUploadContents_ButtonTitle(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    AutofillUploadContents_ButtonTitle(const AutofillUploadContents_ButtonTitle& from);
    AutofillUploadContents_ButtonTitle(AutofillUploadContents_ButtonTitle&& from) noexcept
        : AutofillUploadContents_ButtonTitle()
    {
        *this = ::std::move(from);
    }

    inline AutofillUploadContents_ButtonTitle& operator=(const AutofillUploadContents_ButtonTitle& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline AutofillUploadContents_ButtonTitle& operator=(AutofillUploadContents_ButtonTitle&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const AutofillUploadContents_ButtonTitle& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const AutofillUploadContents_ButtonTitle* internal_default_instance()
    {
        return reinterpret_cast<const AutofillUploadContents_ButtonTitle*>(&_AutofillUploadContents_ButtonTitle_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 5;

    friend void swap(AutofillUploadContents_ButtonTitle& a, AutofillUploadContents_ButtonTitle& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(AutofillUploadContents_ButtonTitle* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(AutofillUploadContents_ButtonTitle* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    AutofillUploadContents_ButtonTitle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<AutofillUploadContents_ButtonTitle>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const AutofillUploadContents_ButtonTitle& from);
    void MergeFrom(const AutofillUploadContents_ButtonTitle& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(AutofillUploadContents_ButtonTitle* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "autofill.AutofillUploadContents.ButtonTitle";
    }

protected:
    explicit AutofillUploadContents_ButtonTitle(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kTitleFieldNumber = 1,
        kTypeFieldNumber = 2,
    };
    // optional string title = 1;
    bool has_title() const;

private:
    bool _internal_has_title() const;

public:
    void clear_title();
    const std::string& title() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_title(ArgT0&& arg0, ArgT... args);
    std::string* mutable_title();
    PROTOBUF_NODISCARD std::string* release_title();
    void set_allocated_title(std::string* title);

private:
    const std::string& _internal_title() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
    std::string* _internal_mutable_title();

public:
    // optional .autofill.ButtonTitleType type = 2;
    bool has_type() const;

private:
    bool _internal_has_type() const;

public:
    void clear_type();
    ::autofill::ButtonTitleType type() const;
    void set_type(::autofill::ButtonTitleType value);

private:
    ::autofill::ButtonTitleType _internal_type() const;
    void _internal_set_type(::autofill::ButtonTitleType value);

public:
    // @@protoc_insertion_point(class_scope:autofill.AutofillUploadContents.ButtonTitle)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
        int type_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class AutofillUploadContents_SingleUsernameData final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.AutofillUploadContents.SingleUsernameData) */ {
public:
    inline AutofillUploadContents_SingleUsernameData()
        : AutofillUploadContents_SingleUsernameData(nullptr)
    {
    }
    ~AutofillUploadContents_SingleUsernameData() override;
    explicit PROTOBUF_CONSTEXPR AutofillUploadContents_SingleUsernameData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    AutofillUploadContents_SingleUsernameData(const AutofillUploadContents_SingleUsernameData& from);
    AutofillUploadContents_SingleUsernameData(AutofillUploadContents_SingleUsernameData&& from) noexcept
        : AutofillUploadContents_SingleUsernameData()
    {
        *this = ::std::move(from);
    }

    inline AutofillUploadContents_SingleUsernameData& operator=(const AutofillUploadContents_SingleUsernameData& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline AutofillUploadContents_SingleUsernameData& operator=(AutofillUploadContents_SingleUsernameData&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const AutofillUploadContents_SingleUsernameData& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const AutofillUploadContents_SingleUsernameData* internal_default_instance()
    {
        return reinterpret_cast<const AutofillUploadContents_SingleUsernameData*>(&_AutofillUploadContents_SingleUsernameData_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 6;

    friend void swap(AutofillUploadContents_SingleUsernameData& a, AutofillUploadContents_SingleUsernameData& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(AutofillUploadContents_SingleUsernameData* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(AutofillUploadContents_SingleUsernameData* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    AutofillUploadContents_SingleUsernameData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<AutofillUploadContents_SingleUsernameData>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const AutofillUploadContents_SingleUsernameData& from);
    void MergeFrom(const AutofillUploadContents_SingleUsernameData& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(AutofillUploadContents_SingleUsernameData* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "autofill.AutofillUploadContents.SingleUsernameData";
    }

protected:
    explicit AutofillUploadContents_SingleUsernameData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kUsernameFormSignatureFieldNumber = 1,
        kUsernameFieldSignatureFieldNumber = 2,
        kValueTypeFieldNumber = 3,
        kPromptEditFieldNumber = 4,
    };
    // optional fixed64 username_form_signature = 1;
    bool has_username_form_signature() const;

private:
    bool _internal_has_username_form_signature() const;

public:
    void clear_username_form_signature();
    uint64_t username_form_signature() const;
    void set_username_form_signature(uint64_t value);

private:
    uint64_t _internal_username_form_signature() const;
    void _internal_set_username_form_signature(uint64_t value);

public:
    // optional fixed32 username_field_signature = 2;
    bool has_username_field_signature() const;

private:
    bool _internal_has_username_field_signature() const;

public:
    void clear_username_field_signature();
    uint32_t username_field_signature() const;
    void set_username_field_signature(uint32_t value);

private:
    uint32_t _internal_username_field_signature() const;
    void _internal_set_username_field_signature(uint32_t value);

public:
    // optional .autofill.AutofillUploadContents.ValueType value_type = 3;
    bool has_value_type() const;

private:
    bool _internal_has_value_type() const;

public:
    void clear_value_type();
    ::autofill::AutofillUploadContents_ValueType value_type() const;
    void set_value_type(::autofill::AutofillUploadContents_ValueType value);

private:
    ::autofill::AutofillUploadContents_ValueType _internal_value_type() const;
    void _internal_set_value_type(::autofill::AutofillUploadContents_ValueType value);

public:
    // optional .autofill.AutofillUploadContents.SingleUsernamePromptEdit prompt_edit = 4;
    bool has_prompt_edit() const;

private:
    bool _internal_has_prompt_edit() const;

public:
    void clear_prompt_edit();
    ::autofill::AutofillUploadContents_SingleUsernamePromptEdit prompt_edit() const;
    void set_prompt_edit(::autofill::AutofillUploadContents_SingleUsernamePromptEdit value);

private:
    ::autofill::AutofillUploadContents_SingleUsernamePromptEdit _internal_prompt_edit() const;
    void _internal_set_prompt_edit(::autofill::AutofillUploadContents_SingleUsernamePromptEdit value);

public:
    // @@protoc_insertion_point(class_scope:autofill.AutofillUploadContents.SingleUsernameData)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        uint64_t username_form_signature_;
        uint32_t username_field_signature_;
        int value_type_;
        int prompt_edit_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class AutofillUploadContents final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.AutofillUploadContents) */ {
public:
    inline AutofillUploadContents()
        : AutofillUploadContents(nullptr)
    {
    }
    ~AutofillUploadContents() override;
    explicit PROTOBUF_CONSTEXPR AutofillUploadContents(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    AutofillUploadContents(const AutofillUploadContents& from);
    AutofillUploadContents(AutofillUploadContents&& from) noexcept
        : AutofillUploadContents()
    {
        *this = ::std::move(from);
    }

    inline AutofillUploadContents& operator=(const AutofillUploadContents& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline AutofillUploadContents& operator=(AutofillUploadContents&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const AutofillUploadContents& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const AutofillUploadContents* internal_default_instance()
    {
        return reinterpret_cast<const AutofillUploadContents*>(&_AutofillUploadContents_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 7;

    friend void swap(AutofillUploadContents& a, AutofillUploadContents& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(AutofillUploadContents* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(AutofillUploadContents* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    AutofillUploadContents* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<AutofillUploadContents>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const AutofillUploadContents& from);
    void MergeFrom(const AutofillUploadContents& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(AutofillUploadContents* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "autofill.AutofillUploadContents";
    }

protected:
    explicit AutofillUploadContents(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef AutofillUploadContents_Field Field;
    typedef AutofillUploadContents_ButtonTitle ButtonTitle;
    typedef AutofillUploadContents_SingleUsernameData SingleUsernameData;

    typedef AutofillUploadContents_SubmissionIndicatorEvent SubmissionIndicatorEvent;
    static constexpr SubmissionIndicatorEvent NONE = AutofillUploadContents_SubmissionIndicatorEvent_NONE;
    static constexpr SubmissionIndicatorEvent HTML_FORM_SUBMISSION = AutofillUploadContents_SubmissionIndicatorEvent_HTML_FORM_SUBMISSION;
    static constexpr SubmissionIndicatorEvent SAME_DOCUMENT_NAVIGATION = AutofillUploadContents_SubmissionIndicatorEvent_SAME_DOCUMENT_NAVIGATION;
    static constexpr SubmissionIndicatorEvent XHR_SUCCEEDED = AutofillUploadContents_SubmissionIndicatorEvent_XHR_SUCCEEDED;
    static constexpr SubmissionIndicatorEvent FRAME_DETACHED = AutofillUploadContents_SubmissionIndicatorEvent_FRAME_DETACHED;
    static constexpr SubmissionIndicatorEvent DEPRECATED_MANUAL_SAVE = AutofillUploadContents_SubmissionIndicatorEvent_DEPRECATED_MANUAL_SAVE;
    static constexpr SubmissionIndicatorEvent DEPRECATED_DOM_MUTATION_AFTER_XHR
        = AutofillUploadContents_SubmissionIndicatorEvent_DEPRECATED_DOM_MUTATION_AFTER_XHR;
    static constexpr SubmissionIndicatorEvent DEPRECATED_PROVISIONALLY_SAVED_FORM_ON_START_PROVISIONAL_LOAD
        = AutofillUploadContents_SubmissionIndicatorEvent_DEPRECATED_PROVISIONALLY_SAVED_FORM_ON_START_PROVISIONAL_LOAD;
    static constexpr SubmissionIndicatorEvent DEPRECATED_FILLED_FORM_ON_START_PROVISIONAL_LOAD
        = AutofillUploadContents_SubmissionIndicatorEvent_DEPRECATED_FILLED_FORM_ON_START_PROVISIONAL_LOAD;
    static constexpr SubmissionIndicatorEvent DEPRECATED_FILLED_INPUT_ELEMENTS_ON_START_PROVISIONAL_LOAD
        = AutofillUploadContents_SubmissionIndicatorEvent_DEPRECATED_FILLED_INPUT_ELEMENTS_ON_START_PROVISIONAL_LOAD;
    static constexpr SubmissionIndicatorEvent PROBABLE_FORM_SUBMISSION = AutofillUploadContents_SubmissionIndicatorEvent_PROBABLE_FORM_SUBMISSION;
    static constexpr SubmissionIndicatorEvent CHANGE_PASSWORD_FORM_CLEARED = AutofillUploadContents_SubmissionIndicatorEvent_CHANGE_PASSWORD_FORM_CLEARED;
    static constexpr SubmissionIndicatorEvent DOM_MUTATION_AFTER_AUTOFILL = AutofillUploadContents_SubmissionIndicatorEvent_DOM_MUTATION_AFTER_AUTOFILL;
    static inline bool SubmissionIndicatorEvent_IsValid(int value)
    {
        return AutofillUploadContents_SubmissionIndicatorEvent_IsValid(value);
    }
    static constexpr SubmissionIndicatorEvent SubmissionIndicatorEvent_MIN = AutofillUploadContents_SubmissionIndicatorEvent_SubmissionIndicatorEvent_MIN;
    static constexpr SubmissionIndicatorEvent SubmissionIndicatorEvent_MAX = AutofillUploadContents_SubmissionIndicatorEvent_SubmissionIndicatorEvent_MAX;
    static constexpr int SubmissionIndicatorEvent_ARRAYSIZE = AutofillUploadContents_SubmissionIndicatorEvent_SubmissionIndicatorEvent_ARRAYSIZE;
    template <typename T> static inline const std::string& SubmissionIndicatorEvent_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, SubmissionIndicatorEvent>::value || ::std::is_integral<T>::value,
            "Incorrect type passed to function SubmissionIndicatorEvent_Name.");
        return AutofillUploadContents_SubmissionIndicatorEvent_Name(enum_t_value);
    }
    static inline bool SubmissionIndicatorEvent_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SubmissionIndicatorEvent* value)
    {
        return AutofillUploadContents_SubmissionIndicatorEvent_Parse(name, value);
    }

    typedef AutofillUploadContents_ValueType ValueType;
    static constexpr ValueType TYPE_UNSPECIFIED = AutofillUploadContents_ValueType_TYPE_UNSPECIFIED;
    static constexpr ValueType NO_VALUE_TYPE = AutofillUploadContents_ValueType_NO_VALUE_TYPE;
    static constexpr ValueType STORED_FOR_CURRENT_DOMAIN = AutofillUploadContents_ValueType_STORED_FOR_CURRENT_DOMAIN;
    static constexpr ValueType STORED_FOR_ANOTHER_DOMAIN = AutofillUploadContents_ValueType_STORED_FOR_ANOTHER_DOMAIN;
    static constexpr ValueType EMAIL = AutofillUploadContents_ValueType_EMAIL;
    static constexpr ValueType PHONE = AutofillUploadContents_ValueType_PHONE;
    static constexpr ValueType USERNAME_LIKE = AutofillUploadContents_ValueType_USERNAME_LIKE;
    static constexpr ValueType VALUE_WITH_NO_WHITESPACE = AutofillUploadContents_ValueType_VALUE_WITH_NO_WHITESPACE;
    static constexpr ValueType VALUE_WITH_WHITESPACE = AutofillUploadContents_ValueType_VALUE_WITH_WHITESPACE;
    static inline bool ValueType_IsValid(int value)
    {
        return AutofillUploadContents_ValueType_IsValid(value);
    }
    static constexpr ValueType ValueType_MIN = AutofillUploadContents_ValueType_ValueType_MIN;
    static constexpr ValueType ValueType_MAX = AutofillUploadContents_ValueType_ValueType_MAX;
    static constexpr int ValueType_ARRAYSIZE = AutofillUploadContents_ValueType_ValueType_ARRAYSIZE;
    template <typename T> static inline const std::string& ValueType_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, ValueType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function ValueType_Name.");
        return AutofillUploadContents_ValueType_Name(enum_t_value);
    }
    static inline bool ValueType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ValueType* value)
    {
        return AutofillUploadContents_ValueType_Parse(name, value);
    }

    typedef AutofillUploadContents_SingleUsernamePromptEdit SingleUsernamePromptEdit;
    static constexpr SingleUsernamePromptEdit EDIT_UNSPECIFIED = AutofillUploadContents_SingleUsernamePromptEdit_EDIT_UNSPECIFIED;
    static constexpr SingleUsernamePromptEdit NOT_EDITED_POSITIVE = AutofillUploadContents_SingleUsernamePromptEdit_NOT_EDITED_POSITIVE;
    static constexpr SingleUsernamePromptEdit NOT_EDITED_NEGATIVE = AutofillUploadContents_SingleUsernamePromptEdit_NOT_EDITED_NEGATIVE;
    static constexpr SingleUsernamePromptEdit EDITED_POSITIVE = AutofillUploadContents_SingleUsernamePromptEdit_EDITED_POSITIVE;
    static constexpr SingleUsernamePromptEdit EDITED_NEGATIVE = AutofillUploadContents_SingleUsernamePromptEdit_EDITED_NEGATIVE;
    static inline bool SingleUsernamePromptEdit_IsValid(int value)
    {
        return AutofillUploadContents_SingleUsernamePromptEdit_IsValid(value);
    }
    static constexpr SingleUsernamePromptEdit SingleUsernamePromptEdit_MIN = AutofillUploadContents_SingleUsernamePromptEdit_SingleUsernamePromptEdit_MIN;
    static constexpr SingleUsernamePromptEdit SingleUsernamePromptEdit_MAX = AutofillUploadContents_SingleUsernamePromptEdit_SingleUsernamePromptEdit_MAX;
    static constexpr int SingleUsernamePromptEdit_ARRAYSIZE = AutofillUploadContents_SingleUsernamePromptEdit_SingleUsernamePromptEdit_ARRAYSIZE;
    template <typename T> static inline const std::string& SingleUsernamePromptEdit_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, SingleUsernamePromptEdit>::value || ::std::is_integral<T>::value,
            "Incorrect type passed to function SingleUsernamePromptEdit_Name.");
        return AutofillUploadContents_SingleUsernamePromptEdit_Name(enum_t_value);
    }
    static inline bool SingleUsernamePromptEdit_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SingleUsernamePromptEdit* value)
    {
        return AutofillUploadContents_SingleUsernamePromptEdit_Parse(name, value);
    }

    // accessors -------------------------------------------------------

    enum : int {
        kButtonTitleFieldNumber = 36,
        kSingleUsernameDataFieldNumber = 42,
        kFieldDataFieldNumber = 48,
        kClientVersionFieldNumber = 1,
        kDataPresentFieldNumber = 4,
        kFormNameFieldNumber = 16,
        kLanguageFieldNumber = 31,
        kRandomizedFormMetadataFieldNumber = 32,
        kFormSignatureFieldNumber = 2,
        kActionSignatureFieldNumber = 13,
        kLoginFormSignatureFieldNumber = 14,
        kAutofillUsedFieldNumber = 3,
        kSubmissionFieldNumber = 15,
        kPasswordsRevealedFieldNumber = 24,
        kPasswordHasLetterFieldNumber = 25,
        kPasswordLengthFieldNumber = 29,
        kPasswordHasUppercaseLetterFieldNumber = 26,
        kPasswordHasNumericFieldNumber = 27,
        kPasswordHasSpecialSymbolFieldNumber = 28,
        kHasFormTagFieldNumber = 37,
        kSubmissionEventFieldNumber = 30,
        kSecondaryFormSignatureFieldNumber = 34,
        kWasThrottleableFieldNumber = 38,
        kPasswordSpecialSymbolFieldNumber = 39,
        kLastAddressFormSubmittedFieldNumber = 43,
        kSecondLastAddressFormSubmittedFieldNumber = 44,
        kLastCreditCardFormSubmittedFieldNumber = 45,
    };
    // repeated .autofill.AutofillUploadContents.ButtonTitle button_title = 36;
    int button_title_size() const;

private:
    int _internal_button_title_size() const;

public:
    void clear_button_title();
    ::autofill::AutofillUploadContents_ButtonTitle* mutable_button_title(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::autofill::AutofillUploadContents_ButtonTitle>* mutable_button_title();

private:
    const ::autofill::AutofillUploadContents_ButtonTitle& _internal_button_title(int index) const;
    ::autofill::AutofillUploadContents_ButtonTitle* _internal_add_button_title();

public:
    const ::autofill::AutofillUploadContents_ButtonTitle& button_title(int index) const;
    ::autofill::AutofillUploadContents_ButtonTitle* add_button_title();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::autofill::AutofillUploadContents_ButtonTitle>& button_title() const;

    // repeated .autofill.AutofillUploadContents.SingleUsernameData single_username_data = 42;
    int single_username_data_size() const;

private:
    int _internal_single_username_data_size() const;

public:
    void clear_single_username_data();
    ::autofill::AutofillUploadContents_SingleUsernameData* mutable_single_username_data(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::autofill::AutofillUploadContents_SingleUsernameData>* mutable_single_username_data();

private:
    const ::autofill::AutofillUploadContents_SingleUsernameData& _internal_single_username_data(int index) const;
    ::autofill::AutofillUploadContents_SingleUsernameData* _internal_add_single_username_data();

public:
    const ::autofill::AutofillUploadContents_SingleUsernameData& single_username_data(int index) const;
    ::autofill::AutofillUploadContents_SingleUsernameData* add_single_username_data();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::autofill::AutofillUploadContents_SingleUsernameData>& single_username_data() const;

    // repeated .autofill.AutofillUploadContents.Field field_data = 48;
    int field_data_size() const;

private:
    int _internal_field_data_size() const;

public:
    void clear_field_data();
    ::autofill::AutofillUploadContents_Field* mutable_field_data(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::autofill::AutofillUploadContents_Field>* mutable_field_data();

private:
    const ::autofill::AutofillUploadContents_Field& _internal_field_data(int index) const;
    ::autofill::AutofillUploadContents_Field* _internal_add_field_data();

public:
    const ::autofill::AutofillUploadContents_Field& field_data(int index) const;
    ::autofill::AutofillUploadContents_Field* add_field_data();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::autofill::AutofillUploadContents_Field>& field_data() const;

    // required string client_version = 1;
    bool has_client_version() const;

private:
    bool _internal_has_client_version() const;

public:
    void clear_client_version();
    const std::string& client_version() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_client_version(ArgT0&& arg0, ArgT... args);
    std::string* mutable_client_version();
    PROTOBUF_NODISCARD std::string* release_client_version();
    void set_allocated_client_version(std::string* client_version);

private:
    const std::string& _internal_client_version() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_version(const std::string& value);
    std::string* _internal_mutable_client_version();

public:
    // required string data_present = 4;
    bool has_data_present() const;

private:
    bool _internal_has_data_present() const;

public:
    void clear_data_present();
    const std::string& data_present() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_data_present(ArgT0&& arg0, ArgT... args);
    std::string* mutable_data_present();
    PROTOBUF_NODISCARD std::string* release_data_present();
    void set_allocated_data_present(std::string* data_present);

private:
    const std::string& _internal_data_present() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_data_present(const std::string& value);
    std::string* _internal_mutable_data_present();

public:
    // optional string form_name = 16;
    bool has_form_name() const;

private:
    bool _internal_has_form_name() const;

public:
    void clear_form_name();
    const std::string& form_name() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_form_name(ArgT0&& arg0, ArgT... args);
    std::string* mutable_form_name();
    PROTOBUF_NODISCARD std::string* release_form_name();
    void set_allocated_form_name(std::string* form_name);

private:
    const std::string& _internal_form_name() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_form_name(const std::string& value);
    std::string* _internal_mutable_form_name();

public:
    // optional string language = 31;
    bool has_language() const;

private:
    bool _internal_has_language() const;

public:
    void clear_language();
    const std::string& language() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_language(ArgT0&& arg0, ArgT... args);
    std::string* mutable_language();
    PROTOBUF_NODISCARD std::string* release_language();
    void set_allocated_language(std::string* language);

private:
    const std::string& _internal_language() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_language(const std::string& value);
    std::string* _internal_mutable_language();

public:
    // optional .autofill.AutofillRandomizedFormMetadata randomized_form_metadata = 32;
    bool has_randomized_form_metadata() const;

private:
    bool _internal_has_randomized_form_metadata() const;

public:
    void clear_randomized_form_metadata();
    const ::autofill::AutofillRandomizedFormMetadata& randomized_form_metadata() const;
    PROTOBUF_NODISCARD ::autofill::AutofillRandomizedFormMetadata* release_randomized_form_metadata();
    ::autofill::AutofillRandomizedFormMetadata* mutable_randomized_form_metadata();
    void set_allocated_randomized_form_metadata(::autofill::AutofillRandomizedFormMetadata* randomized_form_metadata);

private:
    const ::autofill::AutofillRandomizedFormMetadata& _internal_randomized_form_metadata() const;
    ::autofill::AutofillRandomizedFormMetadata* _internal_mutable_randomized_form_metadata();

public:
    void unsafe_arena_set_allocated_randomized_form_metadata(::autofill::AutofillRandomizedFormMetadata* randomized_form_metadata);
    ::autofill::AutofillRandomizedFormMetadata* unsafe_arena_release_randomized_form_metadata();

    // required fixed64 form_signature = 2;
    bool has_form_signature() const;

private:
    bool _internal_has_form_signature() const;

public:
    void clear_form_signature();
    uint64_t form_signature() const;
    void set_form_signature(uint64_t value);

private:
    uint64_t _internal_form_signature() const;
    void _internal_set_form_signature(uint64_t value);

public:
    // optional fixed64 action_signature = 13;
    bool has_action_signature() const;

private:
    bool _internal_has_action_signature() const;

public:
    void clear_action_signature();
    uint64_t action_signature() const;
    void set_action_signature(uint64_t value);

private:
    uint64_t _internal_action_signature() const;
    void _internal_set_action_signature(uint64_t value);

public:
    // optional fixed64 login_form_signature = 14;
    bool has_login_form_signature() const;

private:
    bool _internal_has_login_form_signature() const;

public:
    void clear_login_form_signature();
    uint64_t login_form_signature() const;
    void set_login_form_signature(uint64_t value);

private:
    uint64_t _internal_login_form_signature() const;
    void _internal_set_login_form_signature(uint64_t value);

public:
    // required bool autofill_used = 3;
    bool has_autofill_used() const;

private:
    bool _internal_has_autofill_used() const;

public:
    void clear_autofill_used();
    bool autofill_used() const;
    void set_autofill_used(bool value);

private:
    bool _internal_autofill_used() const;
    void _internal_set_autofill_used(bool value);

public:
    // optional bool submission = 15;
    bool has_submission() const;

private:
    bool _internal_has_submission() const;

public:
    void clear_submission();
    bool submission() const;
    void set_submission(bool value);

private:
    bool _internal_submission() const;
    void _internal_set_submission(bool value);

public:
    // optional bool passwords_revealed = 24;
    bool has_passwords_revealed() const;

private:
    bool _internal_has_passwords_revealed() const;

public:
    void clear_passwords_revealed();
    bool passwords_revealed() const;
    void set_passwords_revealed(bool value);

private:
    bool _internal_passwords_revealed() const;
    void _internal_set_passwords_revealed(bool value);

public:
    // optional bool password_has_letter = 25;
    bool has_password_has_letter() const;

private:
    bool _internal_has_password_has_letter() const;

public:
    void clear_password_has_letter();
    bool password_has_letter() const;
    void set_password_has_letter(bool value);

private:
    bool _internal_password_has_letter() const;
    void _internal_set_password_has_letter(bool value);

public:
    // optional uint32 password_length = 29;
    bool has_password_length() const;

private:
    bool _internal_has_password_length() const;

public:
    void clear_password_length();
    uint32_t password_length() const;
    void set_password_length(uint32_t value);

private:
    uint32_t _internal_password_length() const;
    void _internal_set_password_length(uint32_t value);

public:
    // optional bool password_has_uppercase_letter = 26 [deprecated = true];
    PROTOBUF_DEPRECATED bool has_password_has_uppercase_letter() const;

private:
    bool _internal_has_password_has_uppercase_letter() const;

public:
    PROTOBUF_DEPRECATED void clear_password_has_uppercase_letter();
    PROTOBUF_DEPRECATED bool password_has_uppercase_letter() const;
    PROTOBUF_DEPRECATED void set_password_has_uppercase_letter(bool value);

private:
    bool _internal_password_has_uppercase_letter() const;
    void _internal_set_password_has_uppercase_letter(bool value);

public:
    // optional bool password_has_numeric = 27 [deprecated = true];
    PROTOBUF_DEPRECATED bool has_password_has_numeric() const;

private:
    bool _internal_has_password_has_numeric() const;

public:
    PROTOBUF_DEPRECATED void clear_password_has_numeric();
    PROTOBUF_DEPRECATED bool password_has_numeric() const;
    PROTOBUF_DEPRECATED void set_password_has_numeric(bool value);

private:
    bool _internal_password_has_numeric() const;
    void _internal_set_password_has_numeric(bool value);

public:
    // optional bool password_has_special_symbol = 28;
    bool has_password_has_special_symbol() const;

private:
    bool _internal_has_password_has_special_symbol() const;

public:
    void clear_password_has_special_symbol();
    bool password_has_special_symbol() const;
    void set_password_has_special_symbol(bool value);

private:
    bool _internal_password_has_special_symbol() const;
    void _internal_set_password_has_special_symbol(bool value);

public:
    // optional bool has_form_tag = 37;
    bool has_has_form_tag() const;

private:
    bool _internal_has_has_form_tag() const;

public:
    void clear_has_form_tag();
    bool has_form_tag() const;
    void set_has_form_tag(bool value);

private:
    bool _internal_has_form_tag() const;
    void _internal_set_has_form_tag(bool value);

public:
    // optional .autofill.AutofillUploadContents.SubmissionIndicatorEvent submission_event = 30;
    bool has_submission_event() const;

private:
    bool _internal_has_submission_event() const;

public:
    void clear_submission_event();
    ::autofill::AutofillUploadContents_SubmissionIndicatorEvent submission_event() const;
    void set_submission_event(::autofill::AutofillUploadContents_SubmissionIndicatorEvent value);

private:
    ::autofill::AutofillUploadContents_SubmissionIndicatorEvent _internal_submission_event() const;
    void _internal_set_submission_event(::autofill::AutofillUploadContents_SubmissionIndicatorEvent value);

public:
    // optional fixed64 secondary_form_signature = 34;
    bool has_secondary_form_signature() const;

private:
    bool _internal_has_secondary_form_signature() const;

public:
    void clear_secondary_form_signature();
    uint64_t secondary_form_signature() const;
    void set_secondary_form_signature(uint64_t value);

private:
    uint64_t _internal_secondary_form_signature() const;
    void _internal_set_secondary_form_signature(uint64_t value);

public:
    // optional bool was_throttleable = 38 [deprecated = true];
    PROTOBUF_DEPRECATED bool has_was_throttleable() const;

private:
    bool _internal_has_was_throttleable() const;

public:
    PROTOBUF_DEPRECATED void clear_was_throttleable();
    PROTOBUF_DEPRECATED bool was_throttleable() const;
    PROTOBUF_DEPRECATED void set_was_throttleable(bool value);

private:
    bool _internal_was_throttleable() const;
    void _internal_set_was_throttleable(bool value);

public:
    // optional uint32 password_special_symbol = 39;
    bool has_password_special_symbol() const;

private:
    bool _internal_has_password_special_symbol() const;

public:
    void clear_password_special_symbol();
    uint32_t password_special_symbol() const;
    void set_password_special_symbol(uint32_t value);

private:
    uint32_t _internal_password_special_symbol() const;
    void _internal_set_password_special_symbol(uint32_t value);

public:
    // optional fixed64 last_address_form_submitted = 43;
    bool has_last_address_form_submitted() const;

private:
    bool _internal_has_last_address_form_submitted() const;

public:
    void clear_last_address_form_submitted();
    uint64_t last_address_form_submitted() const;
    void set_last_address_form_submitted(uint64_t value);

private:
    uint64_t _internal_last_address_form_submitted() const;
    void _internal_set_last_address_form_submitted(uint64_t value);

public:
    // optional fixed64 second_last_address_form_submitted = 44;
    bool has_second_last_address_form_submitted() const;

private:
    bool _internal_has_second_last_address_form_submitted() const;

public:
    void clear_second_last_address_form_submitted();
    uint64_t second_last_address_form_submitted() const;
    void set_second_last_address_form_submitted(uint64_t value);

private:
    uint64_t _internal_second_last_address_form_submitted() const;
    void _internal_set_second_last_address_form_submitted(uint64_t value);

public:
    // optional fixed64 last_credit_card_form_submitted = 45;
    bool has_last_credit_card_form_submitted() const;

private:
    bool _internal_has_last_credit_card_form_submitted() const;

public:
    void clear_last_credit_card_form_submitted();
    uint64_t last_credit_card_form_submitted() const;
    void set_last_credit_card_form_submitted(uint64_t value);

private:
    uint64_t _internal_last_credit_card_form_submitted() const;
    void _internal_set_last_credit_card_form_submitted(uint64_t value);

public:
    // @@protoc_insertion_point(class_scope:autofill.AutofillUploadContents)
private:
    class _Internal;

    // helper for ByteSizeLong()
    size_t RequiredFieldsByteSizeFallback() const;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::autofill::AutofillUploadContents_ButtonTitle> button_title_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::autofill::AutofillUploadContents_SingleUsernameData> single_username_data_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::autofill::AutofillUploadContents_Field> field_data_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_version_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_present_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr form_name_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_;
        ::autofill::AutofillRandomizedFormMetadata* randomized_form_metadata_;
        uint64_t form_signature_;
        uint64_t action_signature_;
        uint64_t login_form_signature_;
        bool autofill_used_;
        bool submission_;
        bool passwords_revealed_;
        bool password_has_letter_;
        uint32_t password_length_;
        bool password_has_uppercase_letter_;
        bool password_has_numeric_;
        bool password_has_special_symbol_;
        bool has_form_tag_;
        int submission_event_;
        uint64_t secondary_form_signature_;
        bool was_throttleable_;
        uint32_t password_special_symbol_;
        uint64_t last_address_form_submitted_;
        uint64_t second_last_address_form_submitted_;
        uint64_t last_credit_card_form_submitted_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class ProfileValidityMap_FieldValidityStatesEntry_DoNotUse
    : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<ProfileValidityMap_FieldValidityStatesEntry_DoNotUse, int32_t, int32_t,
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32> {
public:
    typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<ProfileValidityMap_FieldValidityStatesEntry_DoNotUse, int32_t, int32_t,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>
        SuperType;
    ProfileValidityMap_FieldValidityStatesEntry_DoNotUse();
    explicit PROTOBUF_CONSTEXPR ProfileValidityMap_FieldValidityStatesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
    explicit ProfileValidityMap_FieldValidityStatesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
    void MergeFrom(const ProfileValidityMap_FieldValidityStatesEntry_DoNotUse& other);
    static const ProfileValidityMap_FieldValidityStatesEntry_DoNotUse* internal_default_instance()
    {
        return reinterpret_cast<const ProfileValidityMap_FieldValidityStatesEntry_DoNotUse*>(
            &_ProfileValidityMap_FieldValidityStatesEntry_DoNotUse_default_instance_);
    }
    static bool ValidateKey(void*)
    {
        return true;
    }
    static bool ValidateValue(void*)
    {
        return true;
    }
    friend struct ::TableStruct_server_2eproto;
};

// -------------------------------------------------------------------

class ProfileValidityMap final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.ProfileValidityMap) */ {
public:
    inline ProfileValidityMap()
        : ProfileValidityMap(nullptr)
    {
    }
    ~ProfileValidityMap() override;
    explicit PROTOBUF_CONSTEXPR ProfileValidityMap(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ProfileValidityMap(const ProfileValidityMap& from);
    ProfileValidityMap(ProfileValidityMap&& from) noexcept
        : ProfileValidityMap()
    {
        *this = ::std::move(from);
    }

    inline ProfileValidityMap& operator=(const ProfileValidityMap& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ProfileValidityMap& operator=(ProfileValidityMap&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ProfileValidityMap& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ProfileValidityMap* internal_default_instance()
    {
        return reinterpret_cast<const ProfileValidityMap*>(&_ProfileValidityMap_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 9;

    friend void swap(ProfileValidityMap& a, ProfileValidityMap& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ProfileValidityMap* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ProfileValidityMap* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ProfileValidityMap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ProfileValidityMap>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ProfileValidityMap& from);
    void MergeFrom(const ProfileValidityMap& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ProfileValidityMap* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "autofill.ProfileValidityMap";
    }

protected:
    explicit ProfileValidityMap(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kFieldValidityStatesFieldNumber = 1,
    };
    // map<int32, int32> field_validity_states = 1;
    int field_validity_states_size() const;

private:
    int _internal_field_validity_states_size() const;

public:
    void clear_field_validity_states();

private:
    const ::PROTOBUF_NAMESPACE_ID::Map<int32_t, int32_t>& _internal_field_validity_states() const;
    ::PROTOBUF_NAMESPACE_ID::Map<int32_t, int32_t>* _internal_mutable_field_validity_states();

public:
    const ::PROTOBUF_NAMESPACE_ID::Map<int32_t, int32_t>& field_validity_states() const;
    ::PROTOBUF_NAMESPACE_ID::Map<int32_t, int32_t>* mutable_field_validity_states();

    // @@protoc_insertion_point(class_scope:autofill.ProfileValidityMap)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::MapFieldLite<ProfileValidityMap_FieldValidityStatesEntry_DoNotUse, int32_t, int32_t,
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>
            field_validity_states_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class UserProfileValidityMap_ProfileValidityEntry_DoNotUse
    : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<UserProfileValidityMap_ProfileValidityEntry_DoNotUse, std::string, ::autofill::ProfileValidityMap,
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
    typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<UserProfileValidityMap_ProfileValidityEntry_DoNotUse, std::string, ::autofill::ProfileValidityMap,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE>
        SuperType;
    UserProfileValidityMap_ProfileValidityEntry_DoNotUse();
    explicit PROTOBUF_CONSTEXPR UserProfileValidityMap_ProfileValidityEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
    explicit UserProfileValidityMap_ProfileValidityEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
    void MergeFrom(const UserProfileValidityMap_ProfileValidityEntry_DoNotUse& other);
    static const UserProfileValidityMap_ProfileValidityEntry_DoNotUse* internal_default_instance()
    {
        return reinterpret_cast<const UserProfileValidityMap_ProfileValidityEntry_DoNotUse*>(
            &_UserProfileValidityMap_ProfileValidityEntry_DoNotUse_default_instance_);
    }
    static bool ValidateKey(void*)
    {
        return true;
    }
    static bool ValidateValue(void*)
    {
        return true;
    }
    friend struct ::TableStruct_server_2eproto;
};

// -------------------------------------------------------------------

class UserProfileValidityMap final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.UserProfileValidityMap) */ {
public:
    inline UserProfileValidityMap()
        : UserProfileValidityMap(nullptr)
    {
    }
    ~UserProfileValidityMap() override;
    explicit PROTOBUF_CONSTEXPR UserProfileValidityMap(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    UserProfileValidityMap(const UserProfileValidityMap& from);
    UserProfileValidityMap(UserProfileValidityMap&& from) noexcept
        : UserProfileValidityMap()
    {
        *this = ::std::move(from);
    }

    inline UserProfileValidityMap& operator=(const UserProfileValidityMap& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline UserProfileValidityMap& operator=(UserProfileValidityMap&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const UserProfileValidityMap& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const UserProfileValidityMap* internal_default_instance()
    {
        return reinterpret_cast<const UserProfileValidityMap*>(&_UserProfileValidityMap_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 11;

    friend void swap(UserProfileValidityMap& a, UserProfileValidityMap& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(UserProfileValidityMap* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(UserProfileValidityMap* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    UserProfileValidityMap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<UserProfileValidityMap>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const UserProfileValidityMap& from);
    void MergeFrom(const UserProfileValidityMap& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(UserProfileValidityMap* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "autofill.UserProfileValidityMap";
    }

protected:
    explicit UserProfileValidityMap(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kProfileValidityFieldNumber = 1,
    };
    // map<string, .autofill.ProfileValidityMap> profile_validity = 1;
    int profile_validity_size() const;

private:
    int _internal_profile_validity_size() const;

public:
    void clear_profile_validity();

private:
    const ::PROTOBUF_NAMESPACE_ID::Map<std::string, ::autofill::ProfileValidityMap>& _internal_profile_validity() const;
    ::PROTOBUF_NAMESPACE_ID::Map<std::string, ::autofill::ProfileValidityMap>* _internal_mutable_profile_validity();

public:
    const ::PROTOBUF_NAMESPACE_ID::Map<std::string, ::autofill::ProfileValidityMap>& profile_validity() const;
    ::PROTOBUF_NAMESPACE_ID::Map<std::string, ::autofill::ProfileValidityMap>* mutable_profile_validity();

    // @@protoc_insertion_point(class_scope:autofill.UserProfileValidityMap)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::MapFieldLite<UserProfileValidityMap_ProfileValidityEntry_DoNotUse, std::string, ::autofill::ProfileValidityMap,
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE>
            profile_validity_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_server_2eproto;
};
// ===================================================================

// ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif // __GNUC__
// AutofillRandomizedValue

// optional .autofill.AutofillRandomizedValue.EncodingType encoding_type = 1 [default = UNSPECIFIED_ENCODING_TYPE];
inline bool AutofillRandomizedValue::_internal_has_encoding_type() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool AutofillRandomizedValue::has_encoding_type() const
{
    return _internal_has_encoding_type();
}
inline void AutofillRandomizedValue::clear_encoding_type()
{
    _impl_.encoding_type_ = -1;
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::autofill::AutofillRandomizedValue_EncodingType AutofillRandomizedValue::_internal_encoding_type() const
{
    return static_cast<::autofill::AutofillRandomizedValue_EncodingType>(_impl_.encoding_type_);
}
inline ::autofill::AutofillRandomizedValue_EncodingType AutofillRandomizedValue::encoding_type() const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillRandomizedValue.encoding_type)
    return _internal_encoding_type();
}
inline void AutofillRandomizedValue::_internal_set_encoding_type(::autofill::AutofillRandomizedValue_EncodingType value)
{
    assert(::autofill::AutofillRandomizedValue_EncodingType_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.encoding_type_ = value;
}
inline void AutofillRandomizedValue::set_encoding_type(::autofill::AutofillRandomizedValue_EncodingType value)
{
    _internal_set_encoding_type(value);
    // @@protoc_insertion_point(field_set:autofill.AutofillRandomizedValue.encoding_type)
}

// optional bytes encoded_bits = 2;
inline bool AutofillRandomizedValue::_internal_has_encoded_bits() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool AutofillRandomizedValue::has_encoded_bits() const
{
    return _internal_has_encoded_bits();
}
inline void AutofillRandomizedValue::clear_encoded_bits()
{
    _impl_.encoded_bits_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AutofillRandomizedValue::encoded_bits() const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillRandomizedValue.encoded_bits)
    return _internal_encoded_bits();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void AutofillRandomizedValue::set_encoded_bits(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.encoded_bits_.SetBytes(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:autofill.AutofillRandomizedValue.encoded_bits)
}
inline std::string* AutofillRandomizedValue::mutable_encoded_bits()
{
    std::string* _s = _internal_mutable_encoded_bits();
    // @@protoc_insertion_point(field_mutable:autofill.AutofillRandomizedValue.encoded_bits)
    return _s;
}
inline const std::string& AutofillRandomizedValue::_internal_encoded_bits() const
{
    return _impl_.encoded_bits_.Get();
}
inline void AutofillRandomizedValue::_internal_set_encoded_bits(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.encoded_bits_.Set(value, GetArenaForAllocation());
}
inline std::string* AutofillRandomizedValue::_internal_mutable_encoded_bits()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.encoded_bits_.Mutable(GetArenaForAllocation());
}
inline std::string* AutofillRandomizedValue::release_encoded_bits()
{
    // @@protoc_insertion_point(field_release:autofill.AutofillRandomizedValue.encoded_bits)
    if (!_internal_has_encoded_bits()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.encoded_bits_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.encoded_bits_.IsDefault()) {
        _impl_.encoded_bits_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void AutofillRandomizedValue::set_allocated_encoded_bits(std::string* encoded_bits)
{
    if (encoded_bits != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.encoded_bits_.SetAllocated(encoded_bits, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.encoded_bits_.IsDefault()) {
        _impl_.encoded_bits_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:autofill.AutofillRandomizedValue.encoded_bits)
}

// optional fixed32 checksum = 3;
inline bool AutofillRandomizedValue::_internal_has_checksum() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool AutofillRandomizedValue::has_checksum() const
{
    return _internal_has_checksum();
}
inline void AutofillRandomizedValue::clear_checksum()
{
    _impl_.checksum_ = 0u;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t AutofillRandomizedValue::_internal_checksum() const
{
    return _impl_.checksum_;
}
inline uint32_t AutofillRandomizedValue::checksum() const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillRandomizedValue.checksum)
    return _internal_checksum();
}
inline void AutofillRandomizedValue::_internal_set_checksum(uint32_t value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.checksum_ = value;
}
inline void AutofillRandomizedValue::set_checksum(uint32_t value)
{
    _internal_set_checksum(value);
    // @@protoc_insertion_point(field_set:autofill.AutofillRandomizedValue.checksum)
}

// -------------------------------------------------------------------

// AutofillRandomizedFormMetadata_ButtonTitle

// optional .autofill.AutofillRandomizedValue title = 1;
inline bool AutofillRandomizedFormMetadata_ButtonTitle::_internal_has_title() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.title_ != nullptr);
    return value;
}
inline bool AutofillRandomizedFormMetadata_ButtonTitle::has_title() const
{
    return _internal_has_title();
}
inline void AutofillRandomizedFormMetadata_ButtonTitle::clear_title()
{
    if (_impl_.title_ != nullptr)
        _impl_.title_->Clear();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFormMetadata_ButtonTitle::_internal_title() const
{
    const ::autofill::AutofillRandomizedValue* p = _impl_.title_;
    return p != nullptr ? *p : reinterpret_cast<const ::autofill::AutofillRandomizedValue&>(::autofill::_AutofillRandomizedValue_default_instance_);
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFormMetadata_ButtonTitle::title() const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillRandomizedFormMetadata.ButtonTitle.title)
    return _internal_title();
}
inline void AutofillRandomizedFormMetadata_ButtonTitle::unsafe_arena_set_allocated_title(::autofill::AutofillRandomizedValue* title)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.title_);
    }
    _impl_.title_ = title;
    if (title) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill.AutofillRandomizedFormMetadata.ButtonTitle.title)
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFormMetadata_ButtonTitle::release_title()
{
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::autofill::AutofillRandomizedValue* temp = _impl_.title_;
    _impl_.title_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFormMetadata_ButtonTitle::unsafe_arena_release_title()
{
    // @@protoc_insertion_point(field_release:autofill.AutofillRandomizedFormMetadata.ButtonTitle.title)
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::autofill::AutofillRandomizedValue* temp = _impl_.title_;
    _impl_.title_ = nullptr;
    return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFormMetadata_ButtonTitle::_internal_mutable_title()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    if (_impl_.title_ == nullptr) {
        auto* p = CreateMaybeMessage<::autofill::AutofillRandomizedValue>(GetArenaForAllocation());
        _impl_.title_ = p;
    }
    return _impl_.title_;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFormMetadata_ButtonTitle::mutable_title()
{
    ::autofill::AutofillRandomizedValue* _msg = _internal_mutable_title();
    // @@protoc_insertion_point(field_mutable:autofill.AutofillRandomizedFormMetadata.ButtonTitle.title)
    return _msg;
}
inline void AutofillRandomizedFormMetadata_ButtonTitle::set_allocated_title(::autofill::AutofillRandomizedValue* title)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.title_;
    }
    if (title) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(title);
        if (message_arena != submessage_arena) {
            title = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, title, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.title_ = title;
    // @@protoc_insertion_point(field_set_allocated:autofill.AutofillRandomizedFormMetadata.ButtonTitle.title)
}

// optional .autofill.ButtonTitleType type = 2;
inline bool AutofillRandomizedFormMetadata_ButtonTitle::_internal_has_type() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool AutofillRandomizedFormMetadata_ButtonTitle::has_type() const
{
    return _internal_has_type();
}
inline void AutofillRandomizedFormMetadata_ButtonTitle::clear_type()
{
    _impl_.type_ = 0;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::autofill::ButtonTitleType AutofillRandomizedFormMetadata_ButtonTitle::_internal_type() const
{
    return static_cast<::autofill::ButtonTitleType>(_impl_.type_);
}
inline ::autofill::ButtonTitleType AutofillRandomizedFormMetadata_ButtonTitle::type() const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillRandomizedFormMetadata.ButtonTitle.type)
    return _internal_type();
}
inline void AutofillRandomizedFormMetadata_ButtonTitle::_internal_set_type(::autofill::ButtonTitleType value)
{
    assert(::autofill::ButtonTitleType_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.type_ = value;
}
inline void AutofillRandomizedFormMetadata_ButtonTitle::set_type(::autofill::ButtonTitleType value)
{
    _internal_set_type(value);
    // @@protoc_insertion_point(field_set:autofill.AutofillRandomizedFormMetadata.ButtonTitle.type)
}

// -------------------------------------------------------------------

// AutofillRandomizedFormMetadata

// optional .autofill.AutofillRandomizedValue id = 1;
inline bool AutofillRandomizedFormMetadata::_internal_has_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.id_ != nullptr);
    return value;
}
inline bool AutofillRandomizedFormMetadata::has_id() const
{
    return _internal_has_id();
}
inline void AutofillRandomizedFormMetadata::clear_id()
{
    if (_impl_.id_ != nullptr)
        _impl_.id_->Clear();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFormMetadata::_internal_id() const
{
    const ::autofill::AutofillRandomizedValue* p = _impl_.id_;
    return p != nullptr ? *p : reinterpret_cast<const ::autofill::AutofillRandomizedValue&>(::autofill::_AutofillRandomizedValue_default_instance_);
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFormMetadata::id() const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillRandomizedFormMetadata.id)
    return _internal_id();
}
inline void AutofillRandomizedFormMetadata::unsafe_arena_set_allocated_id(::autofill::AutofillRandomizedValue* id)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.id_);
    }
    _impl_.id_ = id;
    if (id) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill.AutofillRandomizedFormMetadata.id)
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFormMetadata::release_id()
{
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::autofill::AutofillRandomizedValue* temp = _impl_.id_;
    _impl_.id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFormMetadata::unsafe_arena_release_id()
{
    // @@protoc_insertion_point(field_release:autofill.AutofillRandomizedFormMetadata.id)
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::autofill::AutofillRandomizedValue* temp = _impl_.id_;
    _impl_.id_ = nullptr;
    return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFormMetadata::_internal_mutable_id()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    if (_impl_.id_ == nullptr) {
        auto* p = CreateMaybeMessage<::autofill::AutofillRandomizedValue>(GetArenaForAllocation());
        _impl_.id_ = p;
    }
    return _impl_.id_;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFormMetadata::mutable_id()
{
    ::autofill::AutofillRandomizedValue* _msg = _internal_mutable_id();
    // @@protoc_insertion_point(field_mutable:autofill.AutofillRandomizedFormMetadata.id)
    return _msg;
}
inline void AutofillRandomizedFormMetadata::set_allocated_id(::autofill::AutofillRandomizedValue* id)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.id_;
    }
    if (id) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(id);
        if (message_arena != submessage_arena) {
            id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, id, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.id_ = id;
    // @@protoc_insertion_point(field_set_allocated:autofill.AutofillRandomizedFormMetadata.id)
}

// optional .autofill.AutofillRandomizedValue name = 2;
inline bool AutofillRandomizedFormMetadata::_internal_has_name() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.name_ != nullptr);
    return value;
}
inline bool AutofillRandomizedFormMetadata::has_name() const
{
    return _internal_has_name();
}
inline void AutofillRandomizedFormMetadata::clear_name()
{
    if (_impl_.name_ != nullptr)
        _impl_.name_->Clear();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFormMetadata::_internal_name() const
{
    const ::autofill::AutofillRandomizedValue* p = _impl_.name_;
    return p != nullptr ? *p : reinterpret_cast<const ::autofill::AutofillRandomizedValue&>(::autofill::_AutofillRandomizedValue_default_instance_);
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFormMetadata::name() const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillRandomizedFormMetadata.name)
    return _internal_name();
}
inline void AutofillRandomizedFormMetadata::unsafe_arena_set_allocated_name(::autofill::AutofillRandomizedValue* name)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.name_);
    }
    _impl_.name_ = name;
    if (name) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill.AutofillRandomizedFormMetadata.name)
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFormMetadata::release_name()
{
    _impl_._has_bits_[0] &= ~0x00000002u;
    ::autofill::AutofillRandomizedValue* temp = _impl_.name_;
    _impl_.name_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFormMetadata::unsafe_arena_release_name()
{
    // @@protoc_insertion_point(field_release:autofill.AutofillRandomizedFormMetadata.name)
    _impl_._has_bits_[0] &= ~0x00000002u;
    ::autofill::AutofillRandomizedValue* temp = _impl_.name_;
    _impl_.name_ = nullptr;
    return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFormMetadata::_internal_mutable_name()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    if (_impl_.name_ == nullptr) {
        auto* p = CreateMaybeMessage<::autofill::AutofillRandomizedValue>(GetArenaForAllocation());
        _impl_.name_ = p;
    }
    return _impl_.name_;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFormMetadata::mutable_name()
{
    ::autofill::AutofillRandomizedValue* _msg = _internal_mutable_name();
    // @@protoc_insertion_point(field_mutable:autofill.AutofillRandomizedFormMetadata.name)
    return _msg;
}
inline void AutofillRandomizedFormMetadata::set_allocated_name(::autofill::AutofillRandomizedValue* name)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.name_;
    }
    if (name) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(name);
        if (message_arena != submessage_arena) {
            name = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, name, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.name_ = name;
    // @@protoc_insertion_point(field_set_allocated:autofill.AutofillRandomizedFormMetadata.name)
}

// optional .autofill.AutofillRandomizedValue action = 3;
inline bool AutofillRandomizedFormMetadata::_internal_has_action() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.action_ != nullptr);
    return value;
}
inline bool AutofillRandomizedFormMetadata::has_action() const
{
    return _internal_has_action();
}
inline void AutofillRandomizedFormMetadata::clear_action()
{
    if (_impl_.action_ != nullptr)
        _impl_.action_->Clear();
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFormMetadata::_internal_action() const
{
    const ::autofill::AutofillRandomizedValue* p = _impl_.action_;
    return p != nullptr ? *p : reinterpret_cast<const ::autofill::AutofillRandomizedValue&>(::autofill::_AutofillRandomizedValue_default_instance_);
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFormMetadata::action() const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillRandomizedFormMetadata.action)
    return _internal_action();
}
inline void AutofillRandomizedFormMetadata::unsafe_arena_set_allocated_action(::autofill::AutofillRandomizedValue* action)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.action_);
    }
    _impl_.action_ = action;
    if (action) {
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill.AutofillRandomizedFormMetadata.action)
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFormMetadata::release_action()
{
    _impl_._has_bits_[0] &= ~0x00000004u;
    ::autofill::AutofillRandomizedValue* temp = _impl_.action_;
    _impl_.action_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFormMetadata::unsafe_arena_release_action()
{
    // @@protoc_insertion_point(field_release:autofill.AutofillRandomizedFormMetadata.action)
    _impl_._has_bits_[0] &= ~0x00000004u;
    ::autofill::AutofillRandomizedValue* temp = _impl_.action_;
    _impl_.action_ = nullptr;
    return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFormMetadata::_internal_mutable_action()
{
    _impl_._has_bits_[0] |= 0x00000004u;
    if (_impl_.action_ == nullptr) {
        auto* p = CreateMaybeMessage<::autofill::AutofillRandomizedValue>(GetArenaForAllocation());
        _impl_.action_ = p;
    }
    return _impl_.action_;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFormMetadata::mutable_action()
{
    ::autofill::AutofillRandomizedValue* _msg = _internal_mutable_action();
    // @@protoc_insertion_point(field_mutable:autofill.AutofillRandomizedFormMetadata.action)
    return _msg;
}
inline void AutofillRandomizedFormMetadata::set_allocated_action(::autofill::AutofillRandomizedValue* action)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.action_;
    }
    if (action) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(action);
        if (message_arena != submessage_arena) {
            action = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, action, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    _impl_.action_ = action;
    // @@protoc_insertion_point(field_set_allocated:autofill.AutofillRandomizedFormMetadata.action)
}

// optional .autofill.AutofillRandomizedValue url = 4;
inline bool AutofillRandomizedFormMetadata::_internal_has_url() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.url_ != nullptr);
    return value;
}
inline bool AutofillRandomizedFormMetadata::has_url() const
{
    return _internal_has_url();
}
inline void AutofillRandomizedFormMetadata::clear_url()
{
    if (_impl_.url_ != nullptr)
        _impl_.url_->Clear();
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFormMetadata::_internal_url() const
{
    const ::autofill::AutofillRandomizedValue* p = _impl_.url_;
    return p != nullptr ? *p : reinterpret_cast<const ::autofill::AutofillRandomizedValue&>(::autofill::_AutofillRandomizedValue_default_instance_);
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFormMetadata::url() const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillRandomizedFormMetadata.url)
    return _internal_url();
}
inline void AutofillRandomizedFormMetadata::unsafe_arena_set_allocated_url(::autofill::AutofillRandomizedValue* url)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.url_);
    }
    _impl_.url_ = url;
    if (url) {
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill.AutofillRandomizedFormMetadata.url)
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFormMetadata::release_url()
{
    _impl_._has_bits_[0] &= ~0x00000008u;
    ::autofill::AutofillRandomizedValue* temp = _impl_.url_;
    _impl_.url_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFormMetadata::unsafe_arena_release_url()
{
    // @@protoc_insertion_point(field_release:autofill.AutofillRandomizedFormMetadata.url)
    _impl_._has_bits_[0] &= ~0x00000008u;
    ::autofill::AutofillRandomizedValue* temp = _impl_.url_;
    _impl_.url_ = nullptr;
    return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFormMetadata::_internal_mutable_url()
{
    _impl_._has_bits_[0] |= 0x00000008u;
    if (_impl_.url_ == nullptr) {
        auto* p = CreateMaybeMessage<::autofill::AutofillRandomizedValue>(GetArenaForAllocation());
        _impl_.url_ = p;
    }
    return _impl_.url_;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFormMetadata::mutable_url()
{
    ::autofill::AutofillRandomizedValue* _msg = _internal_mutable_url();
    // @@protoc_insertion_point(field_mutable:autofill.AutofillRandomizedFormMetadata.url)
    return _msg;
}
inline void AutofillRandomizedFormMetadata::set_allocated_url(::autofill::AutofillRandomizedValue* url)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.url_;
    }
    if (url) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(url);
        if (message_arena != submessage_arena) {
            url = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, url, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    _impl_.url_ = url;
    // @@protoc_insertion_point(field_set_allocated:autofill.AutofillRandomizedFormMetadata.url)
}

// repeated .autofill.AutofillRandomizedFormMetadata.ButtonTitle button_title = 5;
inline int AutofillRandomizedFormMetadata::_internal_button_title_size() const
{
    return _impl_.button_title_.size();
}
inline int AutofillRandomizedFormMetadata::button_title_size() const
{
    return _internal_button_title_size();
}
inline void AutofillRandomizedFormMetadata::clear_button_title()
{
    _impl_.button_title_.Clear();
}
inline ::autofill::AutofillRandomizedFormMetadata_ButtonTitle* AutofillRandomizedFormMetadata::mutable_button_title(int index)
{
    // @@protoc_insertion_point(field_mutable:autofill.AutofillRandomizedFormMetadata.button_title)
    return _impl_.button_title_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::autofill::AutofillRandomizedFormMetadata_ButtonTitle>* AutofillRandomizedFormMetadata::mutable_button_title()
{
    // @@protoc_insertion_point(field_mutable_list:autofill.AutofillRandomizedFormMetadata.button_title)
    return &_impl_.button_title_;
}
inline const ::autofill::AutofillRandomizedFormMetadata_ButtonTitle& AutofillRandomizedFormMetadata::_internal_button_title(int index) const
{
    return _impl_.button_title_.Get(index);
}
inline const ::autofill::AutofillRandomizedFormMetadata_ButtonTitle& AutofillRandomizedFormMetadata::button_title(int index) const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillRandomizedFormMetadata.button_title)
    return _internal_button_title(index);
}
inline ::autofill::AutofillRandomizedFormMetadata_ButtonTitle* AutofillRandomizedFormMetadata::_internal_add_button_title()
{
    return _impl_.button_title_.Add();
}
inline ::autofill::AutofillRandomizedFormMetadata_ButtonTitle* AutofillRandomizedFormMetadata::add_button_title()
{
    ::autofill::AutofillRandomizedFormMetadata_ButtonTitle* _add = _internal_add_button_title();
    // @@protoc_insertion_point(field_add:autofill.AutofillRandomizedFormMetadata.button_title)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::autofill::AutofillRandomizedFormMetadata_ButtonTitle>&
AutofillRandomizedFormMetadata::button_title() const
{
    // @@protoc_insertion_point(field_list:autofill.AutofillRandomizedFormMetadata.button_title)
    return _impl_.button_title_;
}

// -------------------------------------------------------------------

// AutofillRandomizedFieldMetadata

// optional .autofill.AutofillRandomizedValue id = 1;
inline bool AutofillRandomizedFieldMetadata::_internal_has_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.id_ != nullptr);
    return value;
}
inline bool AutofillRandomizedFieldMetadata::has_id() const
{
    return _internal_has_id();
}
inline void AutofillRandomizedFieldMetadata::clear_id()
{
    if (_impl_.id_ != nullptr)
        _impl_.id_->Clear();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFieldMetadata::_internal_id() const
{
    const ::autofill::AutofillRandomizedValue* p = _impl_.id_;
    return p != nullptr ? *p : reinterpret_cast<const ::autofill::AutofillRandomizedValue&>(::autofill::_AutofillRandomizedValue_default_instance_);
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFieldMetadata::id() const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillRandomizedFieldMetadata.id)
    return _internal_id();
}
inline void AutofillRandomizedFieldMetadata::unsafe_arena_set_allocated_id(::autofill::AutofillRandomizedValue* id)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.id_);
    }
    _impl_.id_ = id;
    if (id) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill.AutofillRandomizedFieldMetadata.id)
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::release_id()
{
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::autofill::AutofillRandomizedValue* temp = _impl_.id_;
    _impl_.id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::unsafe_arena_release_id()
{
    // @@protoc_insertion_point(field_release:autofill.AutofillRandomizedFieldMetadata.id)
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::autofill::AutofillRandomizedValue* temp = _impl_.id_;
    _impl_.id_ = nullptr;
    return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::_internal_mutable_id()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    if (_impl_.id_ == nullptr) {
        auto* p = CreateMaybeMessage<::autofill::AutofillRandomizedValue>(GetArenaForAllocation());
        _impl_.id_ = p;
    }
    return _impl_.id_;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::mutable_id()
{
    ::autofill::AutofillRandomizedValue* _msg = _internal_mutable_id();
    // @@protoc_insertion_point(field_mutable:autofill.AutofillRandomizedFieldMetadata.id)
    return _msg;
}
inline void AutofillRandomizedFieldMetadata::set_allocated_id(::autofill::AutofillRandomizedValue* id)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.id_;
    }
    if (id) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(id);
        if (message_arena != submessage_arena) {
            id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, id, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.id_ = id;
    // @@protoc_insertion_point(field_set_allocated:autofill.AutofillRandomizedFieldMetadata.id)
}

// optional .autofill.AutofillRandomizedValue name = 2;
inline bool AutofillRandomizedFieldMetadata::_internal_has_name() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.name_ != nullptr);
    return value;
}
inline bool AutofillRandomizedFieldMetadata::has_name() const
{
    return _internal_has_name();
}
inline void AutofillRandomizedFieldMetadata::clear_name()
{
    if (_impl_.name_ != nullptr)
        _impl_.name_->Clear();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFieldMetadata::_internal_name() const
{
    const ::autofill::AutofillRandomizedValue* p = _impl_.name_;
    return p != nullptr ? *p : reinterpret_cast<const ::autofill::AutofillRandomizedValue&>(::autofill::_AutofillRandomizedValue_default_instance_);
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFieldMetadata::name() const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillRandomizedFieldMetadata.name)
    return _internal_name();
}
inline void AutofillRandomizedFieldMetadata::unsafe_arena_set_allocated_name(::autofill::AutofillRandomizedValue* name)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.name_);
    }
    _impl_.name_ = name;
    if (name) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill.AutofillRandomizedFieldMetadata.name)
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::release_name()
{
    _impl_._has_bits_[0] &= ~0x00000002u;
    ::autofill::AutofillRandomizedValue* temp = _impl_.name_;
    _impl_.name_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::unsafe_arena_release_name()
{
    // @@protoc_insertion_point(field_release:autofill.AutofillRandomizedFieldMetadata.name)
    _impl_._has_bits_[0] &= ~0x00000002u;
    ::autofill::AutofillRandomizedValue* temp = _impl_.name_;
    _impl_.name_ = nullptr;
    return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::_internal_mutable_name()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    if (_impl_.name_ == nullptr) {
        auto* p = CreateMaybeMessage<::autofill::AutofillRandomizedValue>(GetArenaForAllocation());
        _impl_.name_ = p;
    }
    return _impl_.name_;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::mutable_name()
{
    ::autofill::AutofillRandomizedValue* _msg = _internal_mutable_name();
    // @@protoc_insertion_point(field_mutable:autofill.AutofillRandomizedFieldMetadata.name)
    return _msg;
}
inline void AutofillRandomizedFieldMetadata::set_allocated_name(::autofill::AutofillRandomizedValue* name)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.name_;
    }
    if (name) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(name);
        if (message_arena != submessage_arena) {
            name = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, name, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.name_ = name;
    // @@protoc_insertion_point(field_set_allocated:autofill.AutofillRandomizedFieldMetadata.name)
}

// optional .autofill.AutofillRandomizedValue type = 3;
inline bool AutofillRandomizedFieldMetadata::_internal_has_type() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.type_ != nullptr);
    return value;
}
inline bool AutofillRandomizedFieldMetadata::has_type() const
{
    return _internal_has_type();
}
inline void AutofillRandomizedFieldMetadata::clear_type()
{
    if (_impl_.type_ != nullptr)
        _impl_.type_->Clear();
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFieldMetadata::_internal_type() const
{
    const ::autofill::AutofillRandomizedValue* p = _impl_.type_;
    return p != nullptr ? *p : reinterpret_cast<const ::autofill::AutofillRandomizedValue&>(::autofill::_AutofillRandomizedValue_default_instance_);
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFieldMetadata::type() const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillRandomizedFieldMetadata.type)
    return _internal_type();
}
inline void AutofillRandomizedFieldMetadata::unsafe_arena_set_allocated_type(::autofill::AutofillRandomizedValue* type)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.type_);
    }
    _impl_.type_ = type;
    if (type) {
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill.AutofillRandomizedFieldMetadata.type)
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::release_type()
{
    _impl_._has_bits_[0] &= ~0x00000004u;
    ::autofill::AutofillRandomizedValue* temp = _impl_.type_;
    _impl_.type_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::unsafe_arena_release_type()
{
    // @@protoc_insertion_point(field_release:autofill.AutofillRandomizedFieldMetadata.type)
    _impl_._has_bits_[0] &= ~0x00000004u;
    ::autofill::AutofillRandomizedValue* temp = _impl_.type_;
    _impl_.type_ = nullptr;
    return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::_internal_mutable_type()
{
    _impl_._has_bits_[0] |= 0x00000004u;
    if (_impl_.type_ == nullptr) {
        auto* p = CreateMaybeMessage<::autofill::AutofillRandomizedValue>(GetArenaForAllocation());
        _impl_.type_ = p;
    }
    return _impl_.type_;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::mutable_type()
{
    ::autofill::AutofillRandomizedValue* _msg = _internal_mutable_type();
    // @@protoc_insertion_point(field_mutable:autofill.AutofillRandomizedFieldMetadata.type)
    return _msg;
}
inline void AutofillRandomizedFieldMetadata::set_allocated_type(::autofill::AutofillRandomizedValue* type)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.type_;
    }
    if (type) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(type);
        if (message_arena != submessage_arena) {
            type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, type, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    _impl_.type_ = type;
    // @@protoc_insertion_point(field_set_allocated:autofill.AutofillRandomizedFieldMetadata.type)
}

// optional .autofill.AutofillRandomizedValue label = 4;
inline bool AutofillRandomizedFieldMetadata::_internal_has_label() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.label_ != nullptr);
    return value;
}
inline bool AutofillRandomizedFieldMetadata::has_label() const
{
    return _internal_has_label();
}
inline void AutofillRandomizedFieldMetadata::clear_label()
{
    if (_impl_.label_ != nullptr)
        _impl_.label_->Clear();
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFieldMetadata::_internal_label() const
{
    const ::autofill::AutofillRandomizedValue* p = _impl_.label_;
    return p != nullptr ? *p : reinterpret_cast<const ::autofill::AutofillRandomizedValue&>(::autofill::_AutofillRandomizedValue_default_instance_);
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFieldMetadata::label() const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillRandomizedFieldMetadata.label)
    return _internal_label();
}
inline void AutofillRandomizedFieldMetadata::unsafe_arena_set_allocated_label(::autofill::AutofillRandomizedValue* label)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.label_);
    }
    _impl_.label_ = label;
    if (label) {
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill.AutofillRandomizedFieldMetadata.label)
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::release_label()
{
    _impl_._has_bits_[0] &= ~0x00000008u;
    ::autofill::AutofillRandomizedValue* temp = _impl_.label_;
    _impl_.label_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::unsafe_arena_release_label()
{
    // @@protoc_insertion_point(field_release:autofill.AutofillRandomizedFieldMetadata.label)
    _impl_._has_bits_[0] &= ~0x00000008u;
    ::autofill::AutofillRandomizedValue* temp = _impl_.label_;
    _impl_.label_ = nullptr;
    return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::_internal_mutable_label()
{
    _impl_._has_bits_[0] |= 0x00000008u;
    if (_impl_.label_ == nullptr) {
        auto* p = CreateMaybeMessage<::autofill::AutofillRandomizedValue>(GetArenaForAllocation());
        _impl_.label_ = p;
    }
    return _impl_.label_;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::mutable_label()
{
    ::autofill::AutofillRandomizedValue* _msg = _internal_mutable_label();
    // @@protoc_insertion_point(field_mutable:autofill.AutofillRandomizedFieldMetadata.label)
    return _msg;
}
inline void AutofillRandomizedFieldMetadata::set_allocated_label(::autofill::AutofillRandomizedValue* label)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.label_;
    }
    if (label) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(label);
        if (message_arena != submessage_arena) {
            label = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, label, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    _impl_.label_ = label;
    // @@protoc_insertion_point(field_set_allocated:autofill.AutofillRandomizedFieldMetadata.label)
}

// optional .autofill.AutofillRandomizedValue aria_label = 5;
inline bool AutofillRandomizedFieldMetadata::_internal_has_aria_label() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.aria_label_ != nullptr);
    return value;
}
inline bool AutofillRandomizedFieldMetadata::has_aria_label() const
{
    return _internal_has_aria_label();
}
inline void AutofillRandomizedFieldMetadata::clear_aria_label()
{
    if (_impl_.aria_label_ != nullptr)
        _impl_.aria_label_->Clear();
    _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFieldMetadata::_internal_aria_label() const
{
    const ::autofill::AutofillRandomizedValue* p = _impl_.aria_label_;
    return p != nullptr ? *p : reinterpret_cast<const ::autofill::AutofillRandomizedValue&>(::autofill::_AutofillRandomizedValue_default_instance_);
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFieldMetadata::aria_label() const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillRandomizedFieldMetadata.aria_label)
    return _internal_aria_label();
}
inline void AutofillRandomizedFieldMetadata::unsafe_arena_set_allocated_aria_label(::autofill::AutofillRandomizedValue* aria_label)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.aria_label_);
    }
    _impl_.aria_label_ = aria_label;
    if (aria_label) {
        _impl_._has_bits_[0] |= 0x00000010u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000010u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill.AutofillRandomizedFieldMetadata.aria_label)
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::release_aria_label()
{
    _impl_._has_bits_[0] &= ~0x00000010u;
    ::autofill::AutofillRandomizedValue* temp = _impl_.aria_label_;
    _impl_.aria_label_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::unsafe_arena_release_aria_label()
{
    // @@protoc_insertion_point(field_release:autofill.AutofillRandomizedFieldMetadata.aria_label)
    _impl_._has_bits_[0] &= ~0x00000010u;
    ::autofill::AutofillRandomizedValue* temp = _impl_.aria_label_;
    _impl_.aria_label_ = nullptr;
    return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::_internal_mutable_aria_label()
{
    _impl_._has_bits_[0] |= 0x00000010u;
    if (_impl_.aria_label_ == nullptr) {
        auto* p = CreateMaybeMessage<::autofill::AutofillRandomizedValue>(GetArenaForAllocation());
        _impl_.aria_label_ = p;
    }
    return _impl_.aria_label_;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::mutable_aria_label()
{
    ::autofill::AutofillRandomizedValue* _msg = _internal_mutable_aria_label();
    // @@protoc_insertion_point(field_mutable:autofill.AutofillRandomizedFieldMetadata.aria_label)
    return _msg;
}
inline void AutofillRandomizedFieldMetadata::set_allocated_aria_label(::autofill::AutofillRandomizedValue* aria_label)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.aria_label_;
    }
    if (aria_label) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(aria_label);
        if (message_arena != submessage_arena) {
            aria_label = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, aria_label, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000010u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000010u;
    }
    _impl_.aria_label_ = aria_label;
    // @@protoc_insertion_point(field_set_allocated:autofill.AutofillRandomizedFieldMetadata.aria_label)
}

// optional .autofill.AutofillRandomizedValue aria_description = 6;
inline bool AutofillRandomizedFieldMetadata::_internal_has_aria_description() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.aria_description_ != nullptr);
    return value;
}
inline bool AutofillRandomizedFieldMetadata::has_aria_description() const
{
    return _internal_has_aria_description();
}
inline void AutofillRandomizedFieldMetadata::clear_aria_description()
{
    if (_impl_.aria_description_ != nullptr)
        _impl_.aria_description_->Clear();
    _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFieldMetadata::_internal_aria_description() const
{
    const ::autofill::AutofillRandomizedValue* p = _impl_.aria_description_;
    return p != nullptr ? *p : reinterpret_cast<const ::autofill::AutofillRandomizedValue&>(::autofill::_AutofillRandomizedValue_default_instance_);
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFieldMetadata::aria_description() const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillRandomizedFieldMetadata.aria_description)
    return _internal_aria_description();
}
inline void AutofillRandomizedFieldMetadata::unsafe_arena_set_allocated_aria_description(::autofill::AutofillRandomizedValue* aria_description)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.aria_description_);
    }
    _impl_.aria_description_ = aria_description;
    if (aria_description) {
        _impl_._has_bits_[0] |= 0x00000020u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000020u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill.AutofillRandomizedFieldMetadata.aria_description)
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::release_aria_description()
{
    _impl_._has_bits_[0] &= ~0x00000020u;
    ::autofill::AutofillRandomizedValue* temp = _impl_.aria_description_;
    _impl_.aria_description_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::unsafe_arena_release_aria_description()
{
    // @@protoc_insertion_point(field_release:autofill.AutofillRandomizedFieldMetadata.aria_description)
    _impl_._has_bits_[0] &= ~0x00000020u;
    ::autofill::AutofillRandomizedValue* temp = _impl_.aria_description_;
    _impl_.aria_description_ = nullptr;
    return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::_internal_mutable_aria_description()
{
    _impl_._has_bits_[0] |= 0x00000020u;
    if (_impl_.aria_description_ == nullptr) {
        auto* p = CreateMaybeMessage<::autofill::AutofillRandomizedValue>(GetArenaForAllocation());
        _impl_.aria_description_ = p;
    }
    return _impl_.aria_description_;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::mutable_aria_description()
{
    ::autofill::AutofillRandomizedValue* _msg = _internal_mutable_aria_description();
    // @@protoc_insertion_point(field_mutable:autofill.AutofillRandomizedFieldMetadata.aria_description)
    return _msg;
}
inline void AutofillRandomizedFieldMetadata::set_allocated_aria_description(::autofill::AutofillRandomizedValue* aria_description)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.aria_description_;
    }
    if (aria_description) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(aria_description);
        if (message_arena != submessage_arena) {
            aria_description = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, aria_description, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000020u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000020u;
    }
    _impl_.aria_description_ = aria_description;
    // @@protoc_insertion_point(field_set_allocated:autofill.AutofillRandomizedFieldMetadata.aria_description)
}

// optional .autofill.AutofillRandomizedValue css_class = 7;
inline bool AutofillRandomizedFieldMetadata::_internal_has_css_class() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.css_class_ != nullptr);
    return value;
}
inline bool AutofillRandomizedFieldMetadata::has_css_class() const
{
    return _internal_has_css_class();
}
inline void AutofillRandomizedFieldMetadata::clear_css_class()
{
    if (_impl_.css_class_ != nullptr)
        _impl_.css_class_->Clear();
    _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFieldMetadata::_internal_css_class() const
{
    const ::autofill::AutofillRandomizedValue* p = _impl_.css_class_;
    return p != nullptr ? *p : reinterpret_cast<const ::autofill::AutofillRandomizedValue&>(::autofill::_AutofillRandomizedValue_default_instance_);
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFieldMetadata::css_class() const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillRandomizedFieldMetadata.css_class)
    return _internal_css_class();
}
inline void AutofillRandomizedFieldMetadata::unsafe_arena_set_allocated_css_class(::autofill::AutofillRandomizedValue* css_class)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.css_class_);
    }
    _impl_.css_class_ = css_class;
    if (css_class) {
        _impl_._has_bits_[0] |= 0x00000040u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000040u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill.AutofillRandomizedFieldMetadata.css_class)
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::release_css_class()
{
    _impl_._has_bits_[0] &= ~0x00000040u;
    ::autofill::AutofillRandomizedValue* temp = _impl_.css_class_;
    _impl_.css_class_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::unsafe_arena_release_css_class()
{
    // @@protoc_insertion_point(field_release:autofill.AutofillRandomizedFieldMetadata.css_class)
    _impl_._has_bits_[0] &= ~0x00000040u;
    ::autofill::AutofillRandomizedValue* temp = _impl_.css_class_;
    _impl_.css_class_ = nullptr;
    return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::_internal_mutable_css_class()
{
    _impl_._has_bits_[0] |= 0x00000040u;
    if (_impl_.css_class_ == nullptr) {
        auto* p = CreateMaybeMessage<::autofill::AutofillRandomizedValue>(GetArenaForAllocation());
        _impl_.css_class_ = p;
    }
    return _impl_.css_class_;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::mutable_css_class()
{
    ::autofill::AutofillRandomizedValue* _msg = _internal_mutable_css_class();
    // @@protoc_insertion_point(field_mutable:autofill.AutofillRandomizedFieldMetadata.css_class)
    return _msg;
}
inline void AutofillRandomizedFieldMetadata::set_allocated_css_class(::autofill::AutofillRandomizedValue* css_class)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.css_class_;
    }
    if (css_class) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(css_class);
        if (message_arena != submessage_arena) {
            css_class = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, css_class, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000040u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000040u;
    }
    _impl_.css_class_ = css_class;
    // @@protoc_insertion_point(field_set_allocated:autofill.AutofillRandomizedFieldMetadata.css_class)
}

// optional .autofill.AutofillRandomizedValue placeholder = 8;
inline bool AutofillRandomizedFieldMetadata::_internal_has_placeholder() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.placeholder_ != nullptr);
    return value;
}
inline bool AutofillRandomizedFieldMetadata::has_placeholder() const
{
    return _internal_has_placeholder();
}
inline void AutofillRandomizedFieldMetadata::clear_placeholder()
{
    if (_impl_.placeholder_ != nullptr)
        _impl_.placeholder_->Clear();
    _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFieldMetadata::_internal_placeholder() const
{
    const ::autofill::AutofillRandomizedValue* p = _impl_.placeholder_;
    return p != nullptr ? *p : reinterpret_cast<const ::autofill::AutofillRandomizedValue&>(::autofill::_AutofillRandomizedValue_default_instance_);
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFieldMetadata::placeholder() const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillRandomizedFieldMetadata.placeholder)
    return _internal_placeholder();
}
inline void AutofillRandomizedFieldMetadata::unsafe_arena_set_allocated_placeholder(::autofill::AutofillRandomizedValue* placeholder)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.placeholder_);
    }
    _impl_.placeholder_ = placeholder;
    if (placeholder) {
        _impl_._has_bits_[0] |= 0x00000080u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000080u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill.AutofillRandomizedFieldMetadata.placeholder)
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::release_placeholder()
{
    _impl_._has_bits_[0] &= ~0x00000080u;
    ::autofill::AutofillRandomizedValue* temp = _impl_.placeholder_;
    _impl_.placeholder_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::unsafe_arena_release_placeholder()
{
    // @@protoc_insertion_point(field_release:autofill.AutofillRandomizedFieldMetadata.placeholder)
    _impl_._has_bits_[0] &= ~0x00000080u;
    ::autofill::AutofillRandomizedValue* temp = _impl_.placeholder_;
    _impl_.placeholder_ = nullptr;
    return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::_internal_mutable_placeholder()
{
    _impl_._has_bits_[0] |= 0x00000080u;
    if (_impl_.placeholder_ == nullptr) {
        auto* p = CreateMaybeMessage<::autofill::AutofillRandomizedValue>(GetArenaForAllocation());
        _impl_.placeholder_ = p;
    }
    return _impl_.placeholder_;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::mutable_placeholder()
{
    ::autofill::AutofillRandomizedValue* _msg = _internal_mutable_placeholder();
    // @@protoc_insertion_point(field_mutable:autofill.AutofillRandomizedFieldMetadata.placeholder)
    return _msg;
}
inline void AutofillRandomizedFieldMetadata::set_allocated_placeholder(::autofill::AutofillRandomizedValue* placeholder)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.placeholder_;
    }
    if (placeholder) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(placeholder);
        if (message_arena != submessage_arena) {
            placeholder = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, placeholder, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000080u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000080u;
    }
    _impl_.placeholder_ = placeholder;
    // @@protoc_insertion_point(field_set_allocated:autofill.AutofillRandomizedFieldMetadata.placeholder)
}

// optional .autofill.AutofillRandomizedValue initial_value_hash = 9;
inline bool AutofillRandomizedFieldMetadata::_internal_has_initial_value_hash() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.initial_value_hash_ != nullptr);
    return value;
}
inline bool AutofillRandomizedFieldMetadata::has_initial_value_hash() const
{
    return _internal_has_initial_value_hash();
}
inline void AutofillRandomizedFieldMetadata::clear_initial_value_hash()
{
    if (_impl_.initial_value_hash_ != nullptr)
        _impl_.initial_value_hash_->Clear();
    _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFieldMetadata::_internal_initial_value_hash() const
{
    const ::autofill::AutofillRandomizedValue* p = _impl_.initial_value_hash_;
    return p != nullptr ? *p : reinterpret_cast<const ::autofill::AutofillRandomizedValue&>(::autofill::_AutofillRandomizedValue_default_instance_);
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFieldMetadata::initial_value_hash() const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillRandomizedFieldMetadata.initial_value_hash)
    return _internal_initial_value_hash();
}
inline void AutofillRandomizedFieldMetadata::unsafe_arena_set_allocated_initial_value_hash(::autofill::AutofillRandomizedValue* initial_value_hash)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.initial_value_hash_);
    }
    _impl_.initial_value_hash_ = initial_value_hash;
    if (initial_value_hash) {
        _impl_._has_bits_[0] |= 0x00000100u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000100u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill.AutofillRandomizedFieldMetadata.initial_value_hash)
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::release_initial_value_hash()
{
    _impl_._has_bits_[0] &= ~0x00000100u;
    ::autofill::AutofillRandomizedValue* temp = _impl_.initial_value_hash_;
    _impl_.initial_value_hash_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::unsafe_arena_release_initial_value_hash()
{
    // @@protoc_insertion_point(field_release:autofill.AutofillRandomizedFieldMetadata.initial_value_hash)
    _impl_._has_bits_[0] &= ~0x00000100u;
    ::autofill::AutofillRandomizedValue* temp = _impl_.initial_value_hash_;
    _impl_.initial_value_hash_ = nullptr;
    return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::_internal_mutable_initial_value_hash()
{
    _impl_._has_bits_[0] |= 0x00000100u;
    if (_impl_.initial_value_hash_ == nullptr) {
        auto* p = CreateMaybeMessage<::autofill::AutofillRandomizedValue>(GetArenaForAllocation());
        _impl_.initial_value_hash_ = p;
    }
    return _impl_.initial_value_hash_;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::mutable_initial_value_hash()
{
    ::autofill::AutofillRandomizedValue* _msg = _internal_mutable_initial_value_hash();
    // @@protoc_insertion_point(field_mutable:autofill.AutofillRandomizedFieldMetadata.initial_value_hash)
    return _msg;
}
inline void AutofillRandomizedFieldMetadata::set_allocated_initial_value_hash(::autofill::AutofillRandomizedValue* initial_value_hash)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.initial_value_hash_;
    }
    if (initial_value_hash) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(initial_value_hash);
        if (message_arena != submessage_arena) {
            initial_value_hash = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, initial_value_hash, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000100u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000100u;
    }
    _impl_.initial_value_hash_ = initial_value_hash;
    // @@protoc_insertion_point(field_set_allocated:autofill.AutofillRandomizedFieldMetadata.initial_value_hash)
}

// optional .autofill.AutofillRandomizedValue autocomplete = 10;
inline bool AutofillRandomizedFieldMetadata::_internal_has_autocomplete() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.autocomplete_ != nullptr);
    return value;
}
inline bool AutofillRandomizedFieldMetadata::has_autocomplete() const
{
    return _internal_has_autocomplete();
}
inline void AutofillRandomizedFieldMetadata::clear_autocomplete()
{
    if (_impl_.autocomplete_ != nullptr)
        _impl_.autocomplete_->Clear();
    _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFieldMetadata::_internal_autocomplete() const
{
    const ::autofill::AutofillRandomizedValue* p = _impl_.autocomplete_;
    return p != nullptr ? *p : reinterpret_cast<const ::autofill::AutofillRandomizedValue&>(::autofill::_AutofillRandomizedValue_default_instance_);
}
inline const ::autofill::AutofillRandomizedValue& AutofillRandomizedFieldMetadata::autocomplete() const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillRandomizedFieldMetadata.autocomplete)
    return _internal_autocomplete();
}
inline void AutofillRandomizedFieldMetadata::unsafe_arena_set_allocated_autocomplete(::autofill::AutofillRandomizedValue* autocomplete)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.autocomplete_);
    }
    _impl_.autocomplete_ = autocomplete;
    if (autocomplete) {
        _impl_._has_bits_[0] |= 0x00000200u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000200u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill.AutofillRandomizedFieldMetadata.autocomplete)
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::release_autocomplete()
{
    _impl_._has_bits_[0] &= ~0x00000200u;
    ::autofill::AutofillRandomizedValue* temp = _impl_.autocomplete_;
    _impl_.autocomplete_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::unsafe_arena_release_autocomplete()
{
    // @@protoc_insertion_point(field_release:autofill.AutofillRandomizedFieldMetadata.autocomplete)
    _impl_._has_bits_[0] &= ~0x00000200u;
    ::autofill::AutofillRandomizedValue* temp = _impl_.autocomplete_;
    _impl_.autocomplete_ = nullptr;
    return temp;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::_internal_mutable_autocomplete()
{
    _impl_._has_bits_[0] |= 0x00000200u;
    if (_impl_.autocomplete_ == nullptr) {
        auto* p = CreateMaybeMessage<::autofill::AutofillRandomizedValue>(GetArenaForAllocation());
        _impl_.autocomplete_ = p;
    }
    return _impl_.autocomplete_;
}
inline ::autofill::AutofillRandomizedValue* AutofillRandomizedFieldMetadata::mutable_autocomplete()
{
    ::autofill::AutofillRandomizedValue* _msg = _internal_mutable_autocomplete();
    // @@protoc_insertion_point(field_mutable:autofill.AutofillRandomizedFieldMetadata.autocomplete)
    return _msg;
}
inline void AutofillRandomizedFieldMetadata::set_allocated_autocomplete(::autofill::AutofillRandomizedValue* autocomplete)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.autocomplete_;
    }
    if (autocomplete) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(autocomplete);
        if (message_arena != submessage_arena) {
            autocomplete = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, autocomplete, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000200u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000200u;
    }
    _impl_.autocomplete_ = autocomplete;
    // @@protoc_insertion_point(field_set_allocated:autofill.AutofillRandomizedFieldMetadata.autocomplete)
}

// -------------------------------------------------------------------

// AutofillUploadContents_Field

// required fixed32 signature = 6;
inline bool AutofillUploadContents_Field::_internal_has_signature() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
    return value;
}
inline bool AutofillUploadContents_Field::has_signature() const
{
    return _internal_has_signature();
}
inline void AutofillUploadContents_Field::clear_signature()
{
    _impl_.signature_ = 0u;
    _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint32_t AutofillUploadContents_Field::_internal_signature() const
{
    return _impl_.signature_;
}
inline uint32_t AutofillUploadContents_Field::signature() const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.Field.signature)
    return _internal_signature();
}
inline void AutofillUploadContents_Field::_internal_set_signature(uint32_t value)
{
    _impl_._has_bits_[0] |= 0x00000040u;
    _impl_.signature_ = value;
}
inline void AutofillUploadContents_Field::set_signature(uint32_t value)
{
    _internal_set_signature(value);
    // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.Field.signature)
}

// repeated fixed32 autofill_type = 7;
inline int AutofillUploadContents_Field::_internal_autofill_type_size() const
{
    return _impl_.autofill_type_.size();
}
inline int AutofillUploadContents_Field::autofill_type_size() const
{
    return _internal_autofill_type_size();
}
inline void AutofillUploadContents_Field::clear_autofill_type()
{
    _impl_.autofill_type_.Clear();
}
inline uint32_t AutofillUploadContents_Field::_internal_autofill_type(int index) const
{
    return _impl_.autofill_type_.Get(index);
}
inline uint32_t AutofillUploadContents_Field::autofill_type(int index) const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.Field.autofill_type)
    return _internal_autofill_type(index);
}
inline void AutofillUploadContents_Field::set_autofill_type(int index, uint32_t value)
{
    _impl_.autofill_type_.Set(index, value);
    // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.Field.autofill_type)
}
inline void AutofillUploadContents_Field::_internal_add_autofill_type(uint32_t value)
{
    _impl_.autofill_type_.Add(value);
}
inline void AutofillUploadContents_Field::add_autofill_type(uint32_t value)
{
    _internal_add_autofill_type(value);
    // @@protoc_insertion_point(field_add:autofill.AutofillUploadContents.Field.autofill_type)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t>& AutofillUploadContents_Field::_internal_autofill_type() const
{
    return _impl_.autofill_type_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t>& AutofillUploadContents_Field::autofill_type() const
{
    // @@protoc_insertion_point(field_list:autofill.AutofillUploadContents.Field.autofill_type)
    return _internal_autofill_type();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t>* AutofillUploadContents_Field::_internal_mutable_autofill_type()
{
    return &_impl_.autofill_type_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t>* AutofillUploadContents_Field::mutable_autofill_type()
{
    // @@protoc_insertion_point(field_mutable_list:autofill.AutofillUploadContents.Field.autofill_type)
    return _internal_mutable_autofill_type();
}

// optional string name = 8;
inline bool AutofillUploadContents_Field::_internal_has_name() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool AutofillUploadContents_Field::has_name() const
{
    return _internal_has_name();
}
inline void AutofillUploadContents_Field::clear_name()
{
    _impl_.name_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AutofillUploadContents_Field::name() const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.Field.name)
    return _internal_name();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void AutofillUploadContents_Field::set_name(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.name_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.Field.name)
}
inline std::string* AutofillUploadContents_Field::mutable_name()
{
    std::string* _s = _internal_mutable_name();
    // @@protoc_insertion_point(field_mutable:autofill.AutofillUploadContents.Field.name)
    return _s;
}
inline const std::string& AutofillUploadContents_Field::_internal_name() const
{
    return _impl_.name_.Get();
}
inline void AutofillUploadContents_Field::_internal_set_name(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* AutofillUploadContents_Field::_internal_mutable_name()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* AutofillUploadContents_Field::release_name()
{
    // @@protoc_insertion_point(field_release:autofill.AutofillUploadContents.Field.name)
    if (!_internal_has_name()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.name_.IsDefault()) {
        _impl_.name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void AutofillUploadContents_Field::set_allocated_name(std::string* name)
{
    if (name != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.name_.IsDefault()) {
        _impl_.name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:autofill.AutofillUploadContents.Field.name)
}

// optional string autocomplete = 9;
inline bool AutofillUploadContents_Field::_internal_has_autocomplete() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool AutofillUploadContents_Field::has_autocomplete() const
{
    return _internal_has_autocomplete();
}
inline void AutofillUploadContents_Field::clear_autocomplete()
{
    _impl_.autocomplete_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AutofillUploadContents_Field::autocomplete() const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.Field.autocomplete)
    return _internal_autocomplete();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void AutofillUploadContents_Field::set_autocomplete(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.autocomplete_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.Field.autocomplete)
}
inline std::string* AutofillUploadContents_Field::mutable_autocomplete()
{
    std::string* _s = _internal_mutable_autocomplete();
    // @@protoc_insertion_point(field_mutable:autofill.AutofillUploadContents.Field.autocomplete)
    return _s;
}
inline const std::string& AutofillUploadContents_Field::_internal_autocomplete() const
{
    return _impl_.autocomplete_.Get();
}
inline void AutofillUploadContents_Field::_internal_set_autocomplete(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.autocomplete_.Set(value, GetArenaForAllocation());
}
inline std::string* AutofillUploadContents_Field::_internal_mutable_autocomplete()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.autocomplete_.Mutable(GetArenaForAllocation());
}
inline std::string* AutofillUploadContents_Field::release_autocomplete()
{
    // @@protoc_insertion_point(field_release:autofill.AutofillUploadContents.Field.autocomplete)
    if (!_internal_has_autocomplete()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.autocomplete_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.autocomplete_.IsDefault()) {
        _impl_.autocomplete_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void AutofillUploadContents_Field::set_allocated_autocomplete(std::string* autocomplete)
{
    if (autocomplete != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.autocomplete_.SetAllocated(autocomplete, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.autocomplete_.IsDefault()) {
        _impl_.autocomplete_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:autofill.AutofillUploadContents.Field.autocomplete)
}

// optional string type = 10;
inline bool AutofillUploadContents_Field::_internal_has_type() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool AutofillUploadContents_Field::has_type() const
{
    return _internal_has_type();
}
inline void AutofillUploadContents_Field::clear_type()
{
    _impl_.type_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& AutofillUploadContents_Field::type() const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.Field.type)
    return _internal_type();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void AutofillUploadContents_Field::set_type(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.type_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.Field.type)
}
inline std::string* AutofillUploadContents_Field::mutable_type()
{
    std::string* _s = _internal_mutable_type();
    // @@protoc_insertion_point(field_mutable:autofill.AutofillUploadContents.Field.type)
    return _s;
}
inline const std::string& AutofillUploadContents_Field::_internal_type() const
{
    return _impl_.type_.Get();
}
inline void AutofillUploadContents_Field::_internal_set_type(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* AutofillUploadContents_Field::_internal_mutable_type()
{
    _impl_._has_bits_[0] |= 0x00000004u;
    return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* AutofillUploadContents_Field::release_type()
{
    // @@protoc_insertion_point(field_release:autofill.AutofillUploadContents.Field.type)
    if (!_internal_has_type()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000004u;
    auto* p = _impl_.type_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.type_.IsDefault()) {
        _impl_.type_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void AutofillUploadContents_Field::set_allocated_type(std::string* type)
{
    if (type != nullptr) {
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.type_.IsDefault()) {
        _impl_.type_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:autofill.AutofillUploadContents.Field.type)
}

// optional .autofill.AutofillRandomizedFieldMetadata randomized_field_metadata = 33;
inline bool AutofillUploadContents_Field::_internal_has_randomized_field_metadata() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.randomized_field_metadata_ != nullptr);
    return value;
}
inline bool AutofillUploadContents_Field::has_randomized_field_metadata() const
{
    return _internal_has_randomized_field_metadata();
}
inline void AutofillUploadContents_Field::clear_randomized_field_metadata()
{
    if (_impl_.randomized_field_metadata_ != nullptr)
        _impl_.randomized_field_metadata_->Clear();
    _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::autofill::AutofillRandomizedFieldMetadata& AutofillUploadContents_Field::_internal_randomized_field_metadata() const
{
    const ::autofill::AutofillRandomizedFieldMetadata* p = _impl_.randomized_field_metadata_;
    return p != nullptr ? *p
                        : reinterpret_cast<const ::autofill::AutofillRandomizedFieldMetadata&>(::autofill::_AutofillRandomizedFieldMetadata_default_instance_);
}
inline const ::autofill::AutofillRandomizedFieldMetadata& AutofillUploadContents_Field::randomized_field_metadata() const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.Field.randomized_field_metadata)
    return _internal_randomized_field_metadata();
}
inline void AutofillUploadContents_Field::unsafe_arena_set_allocated_randomized_field_metadata(
    ::autofill::AutofillRandomizedFieldMetadata* randomized_field_metadata)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.randomized_field_metadata_);
    }
    _impl_.randomized_field_metadata_ = randomized_field_metadata;
    if (randomized_field_metadata) {
        _impl_._has_bits_[0] |= 0x00000020u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000020u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill.AutofillUploadContents.Field.randomized_field_metadata)
}
inline ::autofill::AutofillRandomizedFieldMetadata* AutofillUploadContents_Field::release_randomized_field_metadata()
{
    _impl_._has_bits_[0] &= ~0x00000020u;
    ::autofill::AutofillRandomizedFieldMetadata* temp = _impl_.randomized_field_metadata_;
    _impl_.randomized_field_metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::autofill::AutofillRandomizedFieldMetadata* AutofillUploadContents_Field::unsafe_arena_release_randomized_field_metadata()
{
    // @@protoc_insertion_point(field_release:autofill.AutofillUploadContents.Field.randomized_field_metadata)
    _impl_._has_bits_[0] &= ~0x00000020u;
    ::autofill::AutofillRandomizedFieldMetadata* temp = _impl_.randomized_field_metadata_;
    _impl_.randomized_field_metadata_ = nullptr;
    return temp;
}
inline ::autofill::AutofillRandomizedFieldMetadata* AutofillUploadContents_Field::_internal_mutable_randomized_field_metadata()
{
    _impl_._has_bits_[0] |= 0x00000020u;
    if (_impl_.randomized_field_metadata_ == nullptr) {
        auto* p = CreateMaybeMessage<::autofill::AutofillRandomizedFieldMetadata>(GetArenaForAllocation());
        _impl_.randomized_field_metadata_ = p;
    }
    return _impl_.randomized_field_metadata_;
}
inline ::autofill::AutofillRandomizedFieldMetadata* AutofillUploadContents_Field::mutable_randomized_field_metadata()
{
    ::autofill::AutofillRandomizedFieldMetadata* _msg = _internal_mutable_randomized_field_metadata();
    // @@protoc_insertion_point(field_mutable:autofill.AutofillUploadContents.Field.randomized_field_metadata)
    return _msg;
}
inline void AutofillUploadContents_Field::set_allocated_randomized_field_metadata(::autofill::AutofillRandomizedFieldMetadata* randomized_field_metadata)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.randomized_field_metadata_;
    }
    if (randomized_field_metadata) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(randomized_field_metadata);
        if (message_arena != submessage_arena) {
            randomized_field_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, randomized_field_metadata, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000020u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000020u;
    }
    _impl_.randomized_field_metadata_ = randomized_field_metadata;
    // @@protoc_insertion_point(field_set_allocated:autofill.AutofillUploadContents.Field.randomized_field_metadata)
}

// optional .autofill.AutofillUploadContents.Field.PasswordGenerationType generation_type = 17;
inline bool AutofillUploadContents_Field::_internal_has_generation_type() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
    return value;
}
inline bool AutofillUploadContents_Field::has_generation_type() const
{
    return _internal_has_generation_type();
}
inline void AutofillUploadContents_Field::clear_generation_type()
{
    _impl_.generation_type_ = 0;
    _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::autofill::AutofillUploadContents_Field_PasswordGenerationType AutofillUploadContents_Field::_internal_generation_type() const
{
    return static_cast<::autofill::AutofillUploadContents_Field_PasswordGenerationType>(_impl_.generation_type_);
}
inline ::autofill::AutofillUploadContents_Field_PasswordGenerationType AutofillUploadContents_Field::generation_type() const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.Field.generation_type)
    return _internal_generation_type();
}
inline void AutofillUploadContents_Field::_internal_set_generation_type(::autofill::AutofillUploadContents_Field_PasswordGenerationType value)
{
    assert(::autofill::AutofillUploadContents_Field_PasswordGenerationType_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000080u;
    _impl_.generation_type_ = value;
}
inline void AutofillUploadContents_Field::set_generation_type(::autofill::AutofillUploadContents_Field_PasswordGenerationType value)
{
    _internal_set_generation_type(value);
    // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.Field.generation_type)
}

// optional string css_classes = 19;
inline bool AutofillUploadContents_Field::_internal_has_css_classes() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    return value;
}
inline bool AutofillUploadContents_Field::has_css_classes() const
{
    return _internal_has_css_classes();
}
inline void AutofillUploadContents_Field::clear_css_classes()
{
    _impl_.css_classes_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& AutofillUploadContents_Field::css_classes() const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.Field.css_classes)
    return _internal_css_classes();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void AutofillUploadContents_Field::set_css_classes(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.css_classes_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.Field.css_classes)
}
inline std::string* AutofillUploadContents_Field::mutable_css_classes()
{
    std::string* _s = _internal_mutable_css_classes();
    // @@protoc_insertion_point(field_mutable:autofill.AutofillUploadContents.Field.css_classes)
    return _s;
}
inline const std::string& AutofillUploadContents_Field::_internal_css_classes() const
{
    return _impl_.css_classes_.Get();
}
inline void AutofillUploadContents_Field::_internal_set_css_classes(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.css_classes_.Set(value, GetArenaForAllocation());
}
inline std::string* AutofillUploadContents_Field::_internal_mutable_css_classes()
{
    _impl_._has_bits_[0] |= 0x00000008u;
    return _impl_.css_classes_.Mutable(GetArenaForAllocation());
}
inline std::string* AutofillUploadContents_Field::release_css_classes()
{
    // @@protoc_insertion_point(field_release:autofill.AutofillUploadContents.Field.css_classes)
    if (!_internal_has_css_classes()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000008u;
    auto* p = _impl_.css_classes_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.css_classes_.IsDefault()) {
        _impl_.css_classes_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void AutofillUploadContents_Field::set_allocated_css_classes(std::string* css_classes)
{
    if (css_classes != nullptr) {
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    _impl_.css_classes_.SetAllocated(css_classes, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.css_classes_.IsDefault()) {
        _impl_.css_classes_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:autofill.AutofillUploadContents.Field.css_classes)
}

// optional uint32 properties_mask = 20;
inline bool AutofillUploadContents_Field::_internal_has_properties_mask() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
    return value;
}
inline bool AutofillUploadContents_Field::has_properties_mask() const
{
    return _internal_has_properties_mask();
}
inline void AutofillUploadContents_Field::clear_properties_mask()
{
    _impl_.properties_mask_ = 0u;
    _impl_._has_bits_[0] &= ~0x00000100u;
}
inline uint32_t AutofillUploadContents_Field::_internal_properties_mask() const
{
    return _impl_.properties_mask_;
}
inline uint32_t AutofillUploadContents_Field::properties_mask() const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.Field.properties_mask)
    return _internal_properties_mask();
}
inline void AutofillUploadContents_Field::_internal_set_properties_mask(uint32_t value)
{
    _impl_._has_bits_[0] |= 0x00000100u;
    _impl_.properties_mask_ = value;
}
inline void AutofillUploadContents_Field::set_properties_mask(uint32_t value)
{
    _internal_set_properties_mask(value);
    // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.Field.properties_mask)
}

// optional string id = 21;
inline bool AutofillUploadContents_Field::_internal_has_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
    return value;
}
inline bool AutofillUploadContents_Field::has_id() const
{
    return _internal_has_id();
}
inline void AutofillUploadContents_Field::clear_id()
{
    _impl_.id_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& AutofillUploadContents_Field::id() const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.Field.id)
    return _internal_id();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void AutofillUploadContents_Field::set_id(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000010u;
    _impl_.id_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.Field.id)
}
inline std::string* AutofillUploadContents_Field::mutable_id()
{
    std::string* _s = _internal_mutable_id();
    // @@protoc_insertion_point(field_mutable:autofill.AutofillUploadContents.Field.id)
    return _s;
}
inline const std::string& AutofillUploadContents_Field::_internal_id() const
{
    return _impl_.id_.Get();
}
inline void AutofillUploadContents_Field::_internal_set_id(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000010u;
    _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* AutofillUploadContents_Field::_internal_mutable_id()
{
    _impl_._has_bits_[0] |= 0x00000010u;
    return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* AutofillUploadContents_Field::release_id()
{
    // @@protoc_insertion_point(field_release:autofill.AutofillUploadContents.Field.id)
    if (!_internal_has_id()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000010u;
    auto* p = _impl_.id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.id_.IsDefault()) {
        _impl_.id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void AutofillUploadContents_Field::set_allocated_id(std::string* id)
{
    if (id != nullptr) {
        _impl_._has_bits_[0] |= 0x00000010u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000010u;
    }
    _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.id_.IsDefault()) {
        _impl_.id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:autofill.AutofillUploadContents.Field.id)
}

// optional bool generated_password_changed = 22;
inline bool AutofillUploadContents_Field::_internal_has_generated_password_changed() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
    return value;
}
inline bool AutofillUploadContents_Field::has_generated_password_changed() const
{
    return _internal_has_generated_password_changed();
}
inline void AutofillUploadContents_Field::clear_generated_password_changed()
{
    _impl_.generated_password_changed_ = false;
    _impl_._has_bits_[0] &= ~0x00000400u;
}
inline bool AutofillUploadContents_Field::_internal_generated_password_changed() const
{
    return _impl_.generated_password_changed_;
}
inline bool AutofillUploadContents_Field::generated_password_changed() const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.Field.generated_password_changed)
    return _internal_generated_password_changed();
}
inline void AutofillUploadContents_Field::_internal_set_generated_password_changed(bool value)
{
    _impl_._has_bits_[0] |= 0x00000400u;
    _impl_.generated_password_changed_ = value;
}
inline void AutofillUploadContents_Field::set_generated_password_changed(bool value)
{
    _internal_set_generated_password_changed(value);
    // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.Field.generated_password_changed)
}

// optional .autofill.AutofillUploadContents.Field.VoteType vote_type = 23;
inline bool AutofillUploadContents_Field::_internal_has_vote_type() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
    return value;
}
inline bool AutofillUploadContents_Field::has_vote_type() const
{
    return _internal_has_vote_type();
}
inline void AutofillUploadContents_Field::clear_vote_type()
{
    _impl_.vote_type_ = 0;
    _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::autofill::AutofillUploadContents_Field_VoteType AutofillUploadContents_Field::_internal_vote_type() const
{
    return static_cast<::autofill::AutofillUploadContents_Field_VoteType>(_impl_.vote_type_);
}
inline ::autofill::AutofillUploadContents_Field_VoteType AutofillUploadContents_Field::vote_type() const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.Field.vote_type)
    return _internal_vote_type();
}
inline void AutofillUploadContents_Field::_internal_set_vote_type(::autofill::AutofillUploadContents_Field_VoteType value)
{
    assert(::autofill::AutofillUploadContents_Field_VoteType_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000200u;
    _impl_.vote_type_ = value;
}
inline void AutofillUploadContents_Field::set_vote_type(::autofill::AutofillUploadContents_Field_VoteType value)
{
    _internal_set_vote_type(value);
    // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.Field.vote_type)
}

// optional uint32 initial_value_hash = 40;
inline bool AutofillUploadContents_Field::_internal_has_initial_value_hash() const
{
    bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
    return value;
}
inline bool AutofillUploadContents_Field::has_initial_value_hash() const
{
    return _internal_has_initial_value_hash();
}
inline void AutofillUploadContents_Field::clear_initial_value_hash()
{
    _impl_.initial_value_hash_ = 0u;
    _impl_._has_bits_[0] &= ~0x00002000u;
}
inline uint32_t AutofillUploadContents_Field::_internal_initial_value_hash() const
{
    return _impl_.initial_value_hash_;
}
inline uint32_t AutofillUploadContents_Field::initial_value_hash() const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.Field.initial_value_hash)
    return _internal_initial_value_hash();
}
inline void AutofillUploadContents_Field::_internal_set_initial_value_hash(uint32_t value)
{
    _impl_._has_bits_[0] |= 0x00002000u;
    _impl_.initial_value_hash_ = value;
}
inline void AutofillUploadContents_Field::set_initial_value_hash(uint32_t value)
{
    _internal_set_initial_value_hash(value);
    // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.Field.initial_value_hash)
}

// optional .autofill.AutofillUploadContents.Field.SingleUsernameVoteType single_username_vote_type = 41;
inline bool AutofillUploadContents_Field::_internal_has_single_username_vote_type() const
{
    bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
    return value;
}
inline bool AutofillUploadContents_Field::has_single_username_vote_type() const
{
    return _internal_has_single_username_vote_type();
}
inline void AutofillUploadContents_Field::clear_single_username_vote_type()
{
    _impl_.single_username_vote_type_ = 0;
    _impl_._has_bits_[0] &= ~0x00004000u;
}
inline ::autofill::AutofillUploadContents_Field_SingleUsernameVoteType AutofillUploadContents_Field::_internal_single_username_vote_type() const
{
    return static_cast<::autofill::AutofillUploadContents_Field_SingleUsernameVoteType>(_impl_.single_username_vote_type_);
}
inline ::autofill::AutofillUploadContents_Field_SingleUsernameVoteType AutofillUploadContents_Field::single_username_vote_type() const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.Field.single_username_vote_type)
    return _internal_single_username_vote_type();
}
inline void AutofillUploadContents_Field::_internal_set_single_username_vote_type(::autofill::AutofillUploadContents_Field_SingleUsernameVoteType value)
{
    assert(::autofill::AutofillUploadContents_Field_SingleUsernameVoteType_IsValid(value));
    _impl_._has_bits_[0] |= 0x00004000u;
    _impl_.single_username_vote_type_ = value;
}
inline void AutofillUploadContents_Field::set_single_username_vote_type(::autofill::AutofillUploadContents_Field_SingleUsernameVoteType value)
{
    _internal_set_single_username_vote_type(value);
    // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.Field.single_username_vote_type)
}

// optional bool is_most_recent_single_username_candidate = 46;
inline bool AutofillUploadContents_Field::_internal_has_is_most_recent_single_username_candidate() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
    return value;
}
inline bool AutofillUploadContents_Field::has_is_most_recent_single_username_candidate() const
{
    return _internal_has_is_most_recent_single_username_candidate();
}
inline void AutofillUploadContents_Field::clear_is_most_recent_single_username_candidate()
{
    _impl_.is_most_recent_single_username_candidate_ = false;
    _impl_._has_bits_[0] &= ~0x00000800u;
}
inline bool AutofillUploadContents_Field::_internal_is_most_recent_single_username_candidate() const
{
    return _impl_.is_most_recent_single_username_candidate_;
}
inline bool AutofillUploadContents_Field::is_most_recent_single_username_candidate() const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.Field.is_most_recent_single_username_candidate)
    return _internal_is_most_recent_single_username_candidate();
}
inline void AutofillUploadContents_Field::_internal_set_is_most_recent_single_username_candidate(bool value)
{
    _impl_._has_bits_[0] |= 0x00000800u;
    _impl_.is_most_recent_single_username_candidate_ = value;
}
inline void AutofillUploadContents_Field::set_is_most_recent_single_username_candidate(bool value)
{
    _internal_set_is_most_recent_single_username_candidate(value);
    // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.Field.is_most_recent_single_username_candidate)
}

// optional bool initial_value_changed = 47;
inline bool AutofillUploadContents_Field::_internal_has_initial_value_changed() const
{
    bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
    return value;
}
inline bool AutofillUploadContents_Field::has_initial_value_changed() const
{
    return _internal_has_initial_value_changed();
}
inline void AutofillUploadContents_Field::clear_initial_value_changed()
{
    _impl_.initial_value_changed_ = false;
    _impl_._has_bits_[0] &= ~0x00001000u;
}
inline bool AutofillUploadContents_Field::_internal_initial_value_changed() const
{
    return _impl_.initial_value_changed_;
}
inline bool AutofillUploadContents_Field::initial_value_changed() const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.Field.initial_value_changed)
    return _internal_initial_value_changed();
}
inline void AutofillUploadContents_Field::_internal_set_initial_value_changed(bool value)
{
    _impl_._has_bits_[0] |= 0x00001000u;
    _impl_.initial_value_changed_ = value;
}
inline void AutofillUploadContents_Field::set_initial_value_changed(bool value)
{
    _internal_set_initial_value_changed(value);
    // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.Field.initial_value_changed)
}

// -------------------------------------------------------------------

// AutofillUploadContents_ButtonTitle

// optional string title = 1;
inline bool AutofillUploadContents_ButtonTitle::_internal_has_title() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool AutofillUploadContents_ButtonTitle::has_title() const
{
    return _internal_has_title();
}
inline void AutofillUploadContents_ButtonTitle::clear_title()
{
    _impl_.title_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AutofillUploadContents_ButtonTitle::title() const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.ButtonTitle.title)
    return _internal_title();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void AutofillUploadContents_ButtonTitle::set_title(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.title_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.ButtonTitle.title)
}
inline std::string* AutofillUploadContents_ButtonTitle::mutable_title()
{
    std::string* _s = _internal_mutable_title();
    // @@protoc_insertion_point(field_mutable:autofill.AutofillUploadContents.ButtonTitle.title)
    return _s;
}
inline const std::string& AutofillUploadContents_ButtonTitle::_internal_title() const
{
    return _impl_.title_.Get();
}
inline void AutofillUploadContents_ButtonTitle::_internal_set_title(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* AutofillUploadContents_ButtonTitle::_internal_mutable_title()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* AutofillUploadContents_ButtonTitle::release_title()
{
    // @@protoc_insertion_point(field_release:autofill.AutofillUploadContents.ButtonTitle.title)
    if (!_internal_has_title()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.title_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.title_.IsDefault()) {
        _impl_.title_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void AutofillUploadContents_ButtonTitle::set_allocated_title(std::string* title)
{
    if (title != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.title_.IsDefault()) {
        _impl_.title_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:autofill.AutofillUploadContents.ButtonTitle.title)
}

// optional .autofill.ButtonTitleType type = 2;
inline bool AutofillUploadContents_ButtonTitle::_internal_has_type() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool AutofillUploadContents_ButtonTitle::has_type() const
{
    return _internal_has_type();
}
inline void AutofillUploadContents_ButtonTitle::clear_type()
{
    _impl_.type_ = 0;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::autofill::ButtonTitleType AutofillUploadContents_ButtonTitle::_internal_type() const
{
    return static_cast<::autofill::ButtonTitleType>(_impl_.type_);
}
inline ::autofill::ButtonTitleType AutofillUploadContents_ButtonTitle::type() const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.ButtonTitle.type)
    return _internal_type();
}
inline void AutofillUploadContents_ButtonTitle::_internal_set_type(::autofill::ButtonTitleType value)
{
    assert(::autofill::ButtonTitleType_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.type_ = value;
}
inline void AutofillUploadContents_ButtonTitle::set_type(::autofill::ButtonTitleType value)
{
    _internal_set_type(value);
    // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.ButtonTitle.type)
}

// -------------------------------------------------------------------

// AutofillUploadContents_SingleUsernameData

// optional fixed64 username_form_signature = 1;
inline bool AutofillUploadContents_SingleUsernameData::_internal_has_username_form_signature() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool AutofillUploadContents_SingleUsernameData::has_username_form_signature() const
{
    return _internal_has_username_form_signature();
}
inline void AutofillUploadContents_SingleUsernameData::clear_username_form_signature()
{
    _impl_.username_form_signature_ = uint64_t { 0u };
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t AutofillUploadContents_SingleUsernameData::_internal_username_form_signature() const
{
    return _impl_.username_form_signature_;
}
inline uint64_t AutofillUploadContents_SingleUsernameData::username_form_signature() const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.SingleUsernameData.username_form_signature)
    return _internal_username_form_signature();
}
inline void AutofillUploadContents_SingleUsernameData::_internal_set_username_form_signature(uint64_t value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.username_form_signature_ = value;
}
inline void AutofillUploadContents_SingleUsernameData::set_username_form_signature(uint64_t value)
{
    _internal_set_username_form_signature(value);
    // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.SingleUsernameData.username_form_signature)
}

// optional fixed32 username_field_signature = 2;
inline bool AutofillUploadContents_SingleUsernameData::_internal_has_username_field_signature() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool AutofillUploadContents_SingleUsernameData::has_username_field_signature() const
{
    return _internal_has_username_field_signature();
}
inline void AutofillUploadContents_SingleUsernameData::clear_username_field_signature()
{
    _impl_.username_field_signature_ = 0u;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t AutofillUploadContents_SingleUsernameData::_internal_username_field_signature() const
{
    return _impl_.username_field_signature_;
}
inline uint32_t AutofillUploadContents_SingleUsernameData::username_field_signature() const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.SingleUsernameData.username_field_signature)
    return _internal_username_field_signature();
}
inline void AutofillUploadContents_SingleUsernameData::_internal_set_username_field_signature(uint32_t value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.username_field_signature_ = value;
}
inline void AutofillUploadContents_SingleUsernameData::set_username_field_signature(uint32_t value)
{
    _internal_set_username_field_signature(value);
    // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.SingleUsernameData.username_field_signature)
}

// optional .autofill.AutofillUploadContents.ValueType value_type = 3;
inline bool AutofillUploadContents_SingleUsernameData::_internal_has_value_type() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool AutofillUploadContents_SingleUsernameData::has_value_type() const
{
    return _internal_has_value_type();
}
inline void AutofillUploadContents_SingleUsernameData::clear_value_type()
{
    _impl_.value_type_ = 0;
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::autofill::AutofillUploadContents_ValueType AutofillUploadContents_SingleUsernameData::_internal_value_type() const
{
    return static_cast<::autofill::AutofillUploadContents_ValueType>(_impl_.value_type_);
}
inline ::autofill::AutofillUploadContents_ValueType AutofillUploadContents_SingleUsernameData::value_type() const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.SingleUsernameData.value_type)
    return _internal_value_type();
}
inline void AutofillUploadContents_SingleUsernameData::_internal_set_value_type(::autofill::AutofillUploadContents_ValueType value)
{
    assert(::autofill::AutofillUploadContents_ValueType_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.value_type_ = value;
}
inline void AutofillUploadContents_SingleUsernameData::set_value_type(::autofill::AutofillUploadContents_ValueType value)
{
    _internal_set_value_type(value);
    // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.SingleUsernameData.value_type)
}

// optional .autofill.AutofillUploadContents.SingleUsernamePromptEdit prompt_edit = 4;
inline bool AutofillUploadContents_SingleUsernameData::_internal_has_prompt_edit() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    return value;
}
inline bool AutofillUploadContents_SingleUsernameData::has_prompt_edit() const
{
    return _internal_has_prompt_edit();
}
inline void AutofillUploadContents_SingleUsernameData::clear_prompt_edit()
{
    _impl_.prompt_edit_ = 0;
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::autofill::AutofillUploadContents_SingleUsernamePromptEdit AutofillUploadContents_SingleUsernameData::_internal_prompt_edit() const
{
    return static_cast<::autofill::AutofillUploadContents_SingleUsernamePromptEdit>(_impl_.prompt_edit_);
}
inline ::autofill::AutofillUploadContents_SingleUsernamePromptEdit AutofillUploadContents_SingleUsernameData::prompt_edit() const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.SingleUsernameData.prompt_edit)
    return _internal_prompt_edit();
}
inline void AutofillUploadContents_SingleUsernameData::_internal_set_prompt_edit(::autofill::AutofillUploadContents_SingleUsernamePromptEdit value)
{
    assert(::autofill::AutofillUploadContents_SingleUsernamePromptEdit_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.prompt_edit_ = value;
}
inline void AutofillUploadContents_SingleUsernameData::set_prompt_edit(::autofill::AutofillUploadContents_SingleUsernamePromptEdit value)
{
    _internal_set_prompt_edit(value);
    // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.SingleUsernameData.prompt_edit)
}

// -------------------------------------------------------------------

// AutofillUploadContents

// required string client_version = 1;
inline bool AutofillUploadContents::_internal_has_client_version() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool AutofillUploadContents::has_client_version() const
{
    return _internal_has_client_version();
}
inline void AutofillUploadContents::clear_client_version()
{
    _impl_.client_version_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AutofillUploadContents::client_version() const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.client_version)
    return _internal_client_version();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void AutofillUploadContents::set_client_version(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.client_version_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.client_version)
}
inline std::string* AutofillUploadContents::mutable_client_version()
{
    std::string* _s = _internal_mutable_client_version();
    // @@protoc_insertion_point(field_mutable:autofill.AutofillUploadContents.client_version)
    return _s;
}
inline const std::string& AutofillUploadContents::_internal_client_version() const
{
    return _impl_.client_version_.Get();
}
inline void AutofillUploadContents::_internal_set_client_version(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.client_version_.Set(value, GetArenaForAllocation());
}
inline std::string* AutofillUploadContents::_internal_mutable_client_version()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.client_version_.Mutable(GetArenaForAllocation());
}
inline std::string* AutofillUploadContents::release_client_version()
{
    // @@protoc_insertion_point(field_release:autofill.AutofillUploadContents.client_version)
    if (!_internal_has_client_version()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.client_version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.client_version_.IsDefault()) {
        _impl_.client_version_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void AutofillUploadContents::set_allocated_client_version(std::string* client_version)
{
    if (client_version != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.client_version_.SetAllocated(client_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.client_version_.IsDefault()) {
        _impl_.client_version_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:autofill.AutofillUploadContents.client_version)
}

// required fixed64 form_signature = 2;
inline bool AutofillUploadContents::_internal_has_form_signature() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
    return value;
}
inline bool AutofillUploadContents::has_form_signature() const
{
    return _internal_has_form_signature();
}
inline void AutofillUploadContents::clear_form_signature()
{
    _impl_.form_signature_ = uint64_t { 0u };
    _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint64_t AutofillUploadContents::_internal_form_signature() const
{
    return _impl_.form_signature_;
}
inline uint64_t AutofillUploadContents::form_signature() const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.form_signature)
    return _internal_form_signature();
}
inline void AutofillUploadContents::_internal_set_form_signature(uint64_t value)
{
    _impl_._has_bits_[0] |= 0x00000020u;
    _impl_.form_signature_ = value;
}
inline void AutofillUploadContents::set_form_signature(uint64_t value)
{
    _internal_set_form_signature(value);
    // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.form_signature)
}

// optional fixed64 secondary_form_signature = 34;
inline bool AutofillUploadContents::_internal_has_secondary_form_signature() const
{
    bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
    return value;
}
inline bool AutofillUploadContents::has_secondary_form_signature() const
{
    return _internal_has_secondary_form_signature();
}
inline void AutofillUploadContents::clear_secondary_form_signature()
{
    _impl_.secondary_form_signature_ = uint64_t { 0u };
    _impl_._has_bits_[0] &= ~0x00040000u;
}
inline uint64_t AutofillUploadContents::_internal_secondary_form_signature() const
{
    return _impl_.secondary_form_signature_;
}
inline uint64_t AutofillUploadContents::secondary_form_signature() const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.secondary_form_signature)
    return _internal_secondary_form_signature();
}
inline void AutofillUploadContents::_internal_set_secondary_form_signature(uint64_t value)
{
    _impl_._has_bits_[0] |= 0x00040000u;
    _impl_.secondary_form_signature_ = value;
}
inline void AutofillUploadContents::set_secondary_form_signature(uint64_t value)
{
    _internal_set_secondary_form_signature(value);
    // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.secondary_form_signature)
}

// required bool autofill_used = 3;
inline bool AutofillUploadContents::_internal_has_autofill_used() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
    return value;
}
inline bool AutofillUploadContents::has_autofill_used() const
{
    return _internal_has_autofill_used();
}
inline void AutofillUploadContents::clear_autofill_used()
{
    _impl_.autofill_used_ = false;
    _impl_._has_bits_[0] &= ~0x00000100u;
}
inline bool AutofillUploadContents::_internal_autofill_used() const
{
    return _impl_.autofill_used_;
}
inline bool AutofillUploadContents::autofill_used() const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.autofill_used)
    return _internal_autofill_used();
}
inline void AutofillUploadContents::_internal_set_autofill_used(bool value)
{
    _impl_._has_bits_[0] |= 0x00000100u;
    _impl_.autofill_used_ = value;
}
inline void AutofillUploadContents::set_autofill_used(bool value)
{
    _internal_set_autofill_used(value);
    // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.autofill_used)
}

// required string data_present = 4;
inline bool AutofillUploadContents::_internal_has_data_present() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool AutofillUploadContents::has_data_present() const
{
    return _internal_has_data_present();
}
inline void AutofillUploadContents::clear_data_present()
{
    _impl_.data_present_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AutofillUploadContents::data_present() const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.data_present)
    return _internal_data_present();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void AutofillUploadContents::set_data_present(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.data_present_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.data_present)
}
inline std::string* AutofillUploadContents::mutable_data_present()
{
    std::string* _s = _internal_mutable_data_present();
    // @@protoc_insertion_point(field_mutable:autofill.AutofillUploadContents.data_present)
    return _s;
}
inline const std::string& AutofillUploadContents::_internal_data_present() const
{
    return _impl_.data_present_.Get();
}
inline void AutofillUploadContents::_internal_set_data_present(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.data_present_.Set(value, GetArenaForAllocation());
}
inline std::string* AutofillUploadContents::_internal_mutable_data_present()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.data_present_.Mutable(GetArenaForAllocation());
}
inline std::string* AutofillUploadContents::release_data_present()
{
    // @@protoc_insertion_point(field_release:autofill.AutofillUploadContents.data_present)
    if (!_internal_has_data_present()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.data_present_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.data_present_.IsDefault()) {
        _impl_.data_present_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void AutofillUploadContents::set_allocated_data_present(std::string* data_present)
{
    if (data_present != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.data_present_.SetAllocated(data_present, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.data_present_.IsDefault()) {
        _impl_.data_present_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:autofill.AutofillUploadContents.data_present)
}

// repeated .autofill.AutofillUploadContents.Field field_data = 48;
inline int AutofillUploadContents::_internal_field_data_size() const
{
    return _impl_.field_data_.size();
}
inline int AutofillUploadContents::field_data_size() const
{
    return _internal_field_data_size();
}
inline void AutofillUploadContents::clear_field_data()
{
    _impl_.field_data_.Clear();
}
inline ::autofill::AutofillUploadContents_Field* AutofillUploadContents::mutable_field_data(int index)
{
    // @@protoc_insertion_point(field_mutable:autofill.AutofillUploadContents.field_data)
    return _impl_.field_data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::autofill::AutofillUploadContents_Field>* AutofillUploadContents::mutable_field_data()
{
    // @@protoc_insertion_point(field_mutable_list:autofill.AutofillUploadContents.field_data)
    return &_impl_.field_data_;
}
inline const ::autofill::AutofillUploadContents_Field& AutofillUploadContents::_internal_field_data(int index) const
{
    return _impl_.field_data_.Get(index);
}
inline const ::autofill::AutofillUploadContents_Field& AutofillUploadContents::field_data(int index) const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.field_data)
    return _internal_field_data(index);
}
inline ::autofill::AutofillUploadContents_Field* AutofillUploadContents::_internal_add_field_data()
{
    return _impl_.field_data_.Add();
}
inline ::autofill::AutofillUploadContents_Field* AutofillUploadContents::add_field_data()
{
    ::autofill::AutofillUploadContents_Field* _add = _internal_add_field_data();
    // @@protoc_insertion_point(field_add:autofill.AutofillUploadContents.field_data)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::autofill::AutofillUploadContents_Field>& AutofillUploadContents::field_data() const
{
    // @@protoc_insertion_point(field_list:autofill.AutofillUploadContents.field_data)
    return _impl_.field_data_;
}

// optional fixed64 action_signature = 13;
inline bool AutofillUploadContents::_internal_has_action_signature() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
    return value;
}
inline bool AutofillUploadContents::has_action_signature() const
{
    return _internal_has_action_signature();
}
inline void AutofillUploadContents::clear_action_signature()
{
    _impl_.action_signature_ = uint64_t { 0u };
    _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint64_t AutofillUploadContents::_internal_action_signature() const
{
    return _impl_.action_signature_;
}
inline uint64_t AutofillUploadContents::action_signature() const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.action_signature)
    return _internal_action_signature();
}
inline void AutofillUploadContents::_internal_set_action_signature(uint64_t value)
{
    _impl_._has_bits_[0] |= 0x00000040u;
    _impl_.action_signature_ = value;
}
inline void AutofillUploadContents::set_action_signature(uint64_t value)
{
    _internal_set_action_signature(value);
    // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.action_signature)
}

// optional fixed64 login_form_signature = 14;
inline bool AutofillUploadContents::_internal_has_login_form_signature() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
    return value;
}
inline bool AutofillUploadContents::has_login_form_signature() const
{
    return _internal_has_login_form_signature();
}
inline void AutofillUploadContents::clear_login_form_signature()
{
    _impl_.login_form_signature_ = uint64_t { 0u };
    _impl_._has_bits_[0] &= ~0x00000080u;
}
inline uint64_t AutofillUploadContents::_internal_login_form_signature() const
{
    return _impl_.login_form_signature_;
}
inline uint64_t AutofillUploadContents::login_form_signature() const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.login_form_signature)
    return _internal_login_form_signature();
}
inline void AutofillUploadContents::_internal_set_login_form_signature(uint64_t value)
{
    _impl_._has_bits_[0] |= 0x00000080u;
    _impl_.login_form_signature_ = value;
}
inline void AutofillUploadContents::set_login_form_signature(uint64_t value)
{
    _internal_set_login_form_signature(value);
    // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.login_form_signature)
}

// optional bool submission = 15;
inline bool AutofillUploadContents::_internal_has_submission() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
    return value;
}
inline bool AutofillUploadContents::has_submission() const
{
    return _internal_has_submission();
}
inline void AutofillUploadContents::clear_submission()
{
    _impl_.submission_ = false;
    _impl_._has_bits_[0] &= ~0x00000200u;
}
inline bool AutofillUploadContents::_internal_submission() const
{
    return _impl_.submission_;
}
inline bool AutofillUploadContents::submission() const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.submission)
    return _internal_submission();
}
inline void AutofillUploadContents::_internal_set_submission(bool value)
{
    _impl_._has_bits_[0] |= 0x00000200u;
    _impl_.submission_ = value;
}
inline void AutofillUploadContents::set_submission(bool value)
{
    _internal_set_submission(value);
    // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.submission)
}

// optional string form_name = 16;
inline bool AutofillUploadContents::_internal_has_form_name() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool AutofillUploadContents::has_form_name() const
{
    return _internal_has_form_name();
}
inline void AutofillUploadContents::clear_form_name()
{
    _impl_.form_name_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& AutofillUploadContents::form_name() const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.form_name)
    return _internal_form_name();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void AutofillUploadContents::set_form_name(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.form_name_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.form_name)
}
inline std::string* AutofillUploadContents::mutable_form_name()
{
    std::string* _s = _internal_mutable_form_name();
    // @@protoc_insertion_point(field_mutable:autofill.AutofillUploadContents.form_name)
    return _s;
}
inline const std::string& AutofillUploadContents::_internal_form_name() const
{
    return _impl_.form_name_.Get();
}
inline void AutofillUploadContents::_internal_set_form_name(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.form_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AutofillUploadContents::_internal_mutable_form_name()
{
    _impl_._has_bits_[0] |= 0x00000004u;
    return _impl_.form_name_.Mutable(GetArenaForAllocation());
}
inline std::string* AutofillUploadContents::release_form_name()
{
    // @@protoc_insertion_point(field_release:autofill.AutofillUploadContents.form_name)
    if (!_internal_has_form_name()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000004u;
    auto* p = _impl_.form_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.form_name_.IsDefault()) {
        _impl_.form_name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void AutofillUploadContents::set_allocated_form_name(std::string* form_name)
{
    if (form_name != nullptr) {
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    _impl_.form_name_.SetAllocated(form_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.form_name_.IsDefault()) {
        _impl_.form_name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:autofill.AutofillUploadContents.form_name)
}

// optional bool passwords_revealed = 24;
inline bool AutofillUploadContents::_internal_has_passwords_revealed() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
    return value;
}
inline bool AutofillUploadContents::has_passwords_revealed() const
{
    return _internal_has_passwords_revealed();
}
inline void AutofillUploadContents::clear_passwords_revealed()
{
    _impl_.passwords_revealed_ = false;
    _impl_._has_bits_[0] &= ~0x00000400u;
}
inline bool AutofillUploadContents::_internal_passwords_revealed() const
{
    return _impl_.passwords_revealed_;
}
inline bool AutofillUploadContents::passwords_revealed() const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.passwords_revealed)
    return _internal_passwords_revealed();
}
inline void AutofillUploadContents::_internal_set_passwords_revealed(bool value)
{
    _impl_._has_bits_[0] |= 0x00000400u;
    _impl_.passwords_revealed_ = value;
}
inline void AutofillUploadContents::set_passwords_revealed(bool value)
{
    _internal_set_passwords_revealed(value);
    // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.passwords_revealed)
}

// optional bool password_has_letter = 25;
inline bool AutofillUploadContents::_internal_has_password_has_letter() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
    return value;
}
inline bool AutofillUploadContents::has_password_has_letter() const
{
    return _internal_has_password_has_letter();
}
inline void AutofillUploadContents::clear_password_has_letter()
{
    _impl_.password_has_letter_ = false;
    _impl_._has_bits_[0] &= ~0x00000800u;
}
inline bool AutofillUploadContents::_internal_password_has_letter() const
{
    return _impl_.password_has_letter_;
}
inline bool AutofillUploadContents::password_has_letter() const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.password_has_letter)
    return _internal_password_has_letter();
}
inline void AutofillUploadContents::_internal_set_password_has_letter(bool value)
{
    _impl_._has_bits_[0] |= 0x00000800u;
    _impl_.password_has_letter_ = value;
}
inline void AutofillUploadContents::set_password_has_letter(bool value)
{
    _internal_set_password_has_letter(value);
    // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.password_has_letter)
}

// optional bool password_has_uppercase_letter = 26 [deprecated = true];
inline bool AutofillUploadContents::_internal_has_password_has_uppercase_letter() const
{
    bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
    return value;
}
inline bool AutofillUploadContents::has_password_has_uppercase_letter() const
{
    return _internal_has_password_has_uppercase_letter();
}
inline void AutofillUploadContents::clear_password_has_uppercase_letter()
{
    _impl_.password_has_uppercase_letter_ = false;
    _impl_._has_bits_[0] &= ~0x00002000u;
}
inline bool AutofillUploadContents::_internal_password_has_uppercase_letter() const
{
    return _impl_.password_has_uppercase_letter_;
}
inline bool AutofillUploadContents::password_has_uppercase_letter() const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.password_has_uppercase_letter)
    return _internal_password_has_uppercase_letter();
}
inline void AutofillUploadContents::_internal_set_password_has_uppercase_letter(bool value)
{
    _impl_._has_bits_[0] |= 0x00002000u;
    _impl_.password_has_uppercase_letter_ = value;
}
inline void AutofillUploadContents::set_password_has_uppercase_letter(bool value)
{
    _internal_set_password_has_uppercase_letter(value);
    // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.password_has_uppercase_letter)
}

// optional bool password_has_numeric = 27 [deprecated = true];
inline bool AutofillUploadContents::_internal_has_password_has_numeric() const
{
    bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
    return value;
}
inline bool AutofillUploadContents::has_password_has_numeric() const
{
    return _internal_has_password_has_numeric();
}
inline void AutofillUploadContents::clear_password_has_numeric()
{
    _impl_.password_has_numeric_ = false;
    _impl_._has_bits_[0] &= ~0x00004000u;
}
inline bool AutofillUploadContents::_internal_password_has_numeric() const
{
    return _impl_.password_has_numeric_;
}
inline bool AutofillUploadContents::password_has_numeric() const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.password_has_numeric)
    return _internal_password_has_numeric();
}
inline void AutofillUploadContents::_internal_set_password_has_numeric(bool value)
{
    _impl_._has_bits_[0] |= 0x00004000u;
    _impl_.password_has_numeric_ = value;
}
inline void AutofillUploadContents::set_password_has_numeric(bool value)
{
    _internal_set_password_has_numeric(value);
    // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.password_has_numeric)
}

// optional bool password_has_special_symbol = 28;
inline bool AutofillUploadContents::_internal_has_password_has_special_symbol() const
{
    bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
    return value;
}
inline bool AutofillUploadContents::has_password_has_special_symbol() const
{
    return _internal_has_password_has_special_symbol();
}
inline void AutofillUploadContents::clear_password_has_special_symbol()
{
    _impl_.password_has_special_symbol_ = false;
    _impl_._has_bits_[0] &= ~0x00008000u;
}
inline bool AutofillUploadContents::_internal_password_has_special_symbol() const
{
    return _impl_.password_has_special_symbol_;
}
inline bool AutofillUploadContents::password_has_special_symbol() const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.password_has_special_symbol)
    return _internal_password_has_special_symbol();
}
inline void AutofillUploadContents::_internal_set_password_has_special_symbol(bool value)
{
    _impl_._has_bits_[0] |= 0x00008000u;
    _impl_.password_has_special_symbol_ = value;
}
inline void AutofillUploadContents::set_password_has_special_symbol(bool value)
{
    _internal_set_password_has_special_symbol(value);
    // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.password_has_special_symbol)
}

// optional uint32 password_length = 29;
inline bool AutofillUploadContents::_internal_has_password_length() const
{
    bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
    return value;
}
inline bool AutofillUploadContents::has_password_length() const
{
    return _internal_has_password_length();
}
inline void AutofillUploadContents::clear_password_length()
{
    _impl_.password_length_ = 0u;
    _impl_._has_bits_[0] &= ~0x00001000u;
}
inline uint32_t AutofillUploadContents::_internal_password_length() const
{
    return _impl_.password_length_;
}
inline uint32_t AutofillUploadContents::password_length() const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.password_length)
    return _internal_password_length();
}
inline void AutofillUploadContents::_internal_set_password_length(uint32_t value)
{
    _impl_._has_bits_[0] |= 0x00001000u;
    _impl_.password_length_ = value;
}
inline void AutofillUploadContents::set_password_length(uint32_t value)
{
    _internal_set_password_length(value);
    // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.password_length)
}

// optional uint32 password_special_symbol = 39;
inline bool AutofillUploadContents::_internal_has_password_special_symbol() const
{
    bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
    return value;
}
inline bool AutofillUploadContents::has_password_special_symbol() const
{
    return _internal_has_password_special_symbol();
}
inline void AutofillUploadContents::clear_password_special_symbol()
{
    _impl_.password_special_symbol_ = 0u;
    _impl_._has_bits_[0] &= ~0x00100000u;
}
inline uint32_t AutofillUploadContents::_internal_password_special_symbol() const
{
    return _impl_.password_special_symbol_;
}
inline uint32_t AutofillUploadContents::password_special_symbol() const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.password_special_symbol)
    return _internal_password_special_symbol();
}
inline void AutofillUploadContents::_internal_set_password_special_symbol(uint32_t value)
{
    _impl_._has_bits_[0] |= 0x00100000u;
    _impl_.password_special_symbol_ = value;
}
inline void AutofillUploadContents::set_password_special_symbol(uint32_t value)
{
    _internal_set_password_special_symbol(value);
    // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.password_special_symbol)
}

// optional .autofill.AutofillUploadContents.SubmissionIndicatorEvent submission_event = 30;
inline bool AutofillUploadContents::_internal_has_submission_event() const
{
    bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
    return value;
}
inline bool AutofillUploadContents::has_submission_event() const
{
    return _internal_has_submission_event();
}
inline void AutofillUploadContents::clear_submission_event()
{
    _impl_.submission_event_ = 0;
    _impl_._has_bits_[0] &= ~0x00020000u;
}
inline ::autofill::AutofillUploadContents_SubmissionIndicatorEvent AutofillUploadContents::_internal_submission_event() const
{
    return static_cast<::autofill::AutofillUploadContents_SubmissionIndicatorEvent>(_impl_.submission_event_);
}
inline ::autofill::AutofillUploadContents_SubmissionIndicatorEvent AutofillUploadContents::submission_event() const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.submission_event)
    return _internal_submission_event();
}
inline void AutofillUploadContents::_internal_set_submission_event(::autofill::AutofillUploadContents_SubmissionIndicatorEvent value)
{
    assert(::autofill::AutofillUploadContents_SubmissionIndicatorEvent_IsValid(value));
    _impl_._has_bits_[0] |= 0x00020000u;
    _impl_.submission_event_ = value;
}
inline void AutofillUploadContents::set_submission_event(::autofill::AutofillUploadContents_SubmissionIndicatorEvent value)
{
    _internal_set_submission_event(value);
    // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.submission_event)
}

// optional string language = 31;
inline bool AutofillUploadContents::_internal_has_language() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    return value;
}
inline bool AutofillUploadContents::has_language() const
{
    return _internal_has_language();
}
inline void AutofillUploadContents::clear_language()
{
    _impl_.language_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& AutofillUploadContents::language() const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.language)
    return _internal_language();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void AutofillUploadContents::set_language(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.language_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.language)
}
inline std::string* AutofillUploadContents::mutable_language()
{
    std::string* _s = _internal_mutable_language();
    // @@protoc_insertion_point(field_mutable:autofill.AutofillUploadContents.language)
    return _s;
}
inline const std::string& AutofillUploadContents::_internal_language() const
{
    return _impl_.language_.Get();
}
inline void AutofillUploadContents::_internal_set_language(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.language_.Set(value, GetArenaForAllocation());
}
inline std::string* AutofillUploadContents::_internal_mutable_language()
{
    _impl_._has_bits_[0] |= 0x00000008u;
    return _impl_.language_.Mutable(GetArenaForAllocation());
}
inline std::string* AutofillUploadContents::release_language()
{
    // @@protoc_insertion_point(field_release:autofill.AutofillUploadContents.language)
    if (!_internal_has_language()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000008u;
    auto* p = _impl_.language_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.language_.IsDefault()) {
        _impl_.language_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void AutofillUploadContents::set_allocated_language(std::string* language)
{
    if (language != nullptr) {
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    _impl_.language_.SetAllocated(language, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.language_.IsDefault()) {
        _impl_.language_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:autofill.AutofillUploadContents.language)
}

// optional .autofill.AutofillRandomizedFormMetadata randomized_form_metadata = 32;
inline bool AutofillUploadContents::_internal_has_randomized_form_metadata() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.randomized_form_metadata_ != nullptr);
    return value;
}
inline bool AutofillUploadContents::has_randomized_form_metadata() const
{
    return _internal_has_randomized_form_metadata();
}
inline void AutofillUploadContents::clear_randomized_form_metadata()
{
    if (_impl_.randomized_form_metadata_ != nullptr)
        _impl_.randomized_form_metadata_->Clear();
    _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::autofill::AutofillRandomizedFormMetadata& AutofillUploadContents::_internal_randomized_form_metadata() const
{
    const ::autofill::AutofillRandomizedFormMetadata* p = _impl_.randomized_form_metadata_;
    return p != nullptr ? *p
                        : reinterpret_cast<const ::autofill::AutofillRandomizedFormMetadata&>(::autofill::_AutofillRandomizedFormMetadata_default_instance_);
}
inline const ::autofill::AutofillRandomizedFormMetadata& AutofillUploadContents::randomized_form_metadata() const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.randomized_form_metadata)
    return _internal_randomized_form_metadata();
}
inline void AutofillUploadContents::unsafe_arena_set_allocated_randomized_form_metadata(::autofill::AutofillRandomizedFormMetadata* randomized_form_metadata)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.randomized_form_metadata_);
    }
    _impl_.randomized_form_metadata_ = randomized_form_metadata;
    if (randomized_form_metadata) {
        _impl_._has_bits_[0] |= 0x00000010u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000010u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill.AutofillUploadContents.randomized_form_metadata)
}
inline ::autofill::AutofillRandomizedFormMetadata* AutofillUploadContents::release_randomized_form_metadata()
{
    _impl_._has_bits_[0] &= ~0x00000010u;
    ::autofill::AutofillRandomizedFormMetadata* temp = _impl_.randomized_form_metadata_;
    _impl_.randomized_form_metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::autofill::AutofillRandomizedFormMetadata* AutofillUploadContents::unsafe_arena_release_randomized_form_metadata()
{
    // @@protoc_insertion_point(field_release:autofill.AutofillUploadContents.randomized_form_metadata)
    _impl_._has_bits_[0] &= ~0x00000010u;
    ::autofill::AutofillRandomizedFormMetadata* temp = _impl_.randomized_form_metadata_;
    _impl_.randomized_form_metadata_ = nullptr;
    return temp;
}
inline ::autofill::AutofillRandomizedFormMetadata* AutofillUploadContents::_internal_mutable_randomized_form_metadata()
{
    _impl_._has_bits_[0] |= 0x00000010u;
    if (_impl_.randomized_form_metadata_ == nullptr) {
        auto* p = CreateMaybeMessage<::autofill::AutofillRandomizedFormMetadata>(GetArenaForAllocation());
        _impl_.randomized_form_metadata_ = p;
    }
    return _impl_.randomized_form_metadata_;
}
inline ::autofill::AutofillRandomizedFormMetadata* AutofillUploadContents::mutable_randomized_form_metadata()
{
    ::autofill::AutofillRandomizedFormMetadata* _msg = _internal_mutable_randomized_form_metadata();
    // @@protoc_insertion_point(field_mutable:autofill.AutofillUploadContents.randomized_form_metadata)
    return _msg;
}
inline void AutofillUploadContents::set_allocated_randomized_form_metadata(::autofill::AutofillRandomizedFormMetadata* randomized_form_metadata)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.randomized_form_metadata_;
    }
    if (randomized_form_metadata) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(randomized_form_metadata);
        if (message_arena != submessage_arena) {
            randomized_form_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, randomized_form_metadata, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000010u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000010u;
    }
    _impl_.randomized_form_metadata_ = randomized_form_metadata;
    // @@protoc_insertion_point(field_set_allocated:autofill.AutofillUploadContents.randomized_form_metadata)
}

// repeated .autofill.AutofillUploadContents.ButtonTitle button_title = 36;
inline int AutofillUploadContents::_internal_button_title_size() const
{
    return _impl_.button_title_.size();
}
inline int AutofillUploadContents::button_title_size() const
{
    return _internal_button_title_size();
}
inline void AutofillUploadContents::clear_button_title()
{
    _impl_.button_title_.Clear();
}
inline ::autofill::AutofillUploadContents_ButtonTitle* AutofillUploadContents::mutable_button_title(int index)
{
    // @@protoc_insertion_point(field_mutable:autofill.AutofillUploadContents.button_title)
    return _impl_.button_title_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::autofill::AutofillUploadContents_ButtonTitle>* AutofillUploadContents::mutable_button_title()
{
    // @@protoc_insertion_point(field_mutable_list:autofill.AutofillUploadContents.button_title)
    return &_impl_.button_title_;
}
inline const ::autofill::AutofillUploadContents_ButtonTitle& AutofillUploadContents::_internal_button_title(int index) const
{
    return _impl_.button_title_.Get(index);
}
inline const ::autofill::AutofillUploadContents_ButtonTitle& AutofillUploadContents::button_title(int index) const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.button_title)
    return _internal_button_title(index);
}
inline ::autofill::AutofillUploadContents_ButtonTitle* AutofillUploadContents::_internal_add_button_title()
{
    return _impl_.button_title_.Add();
}
inline ::autofill::AutofillUploadContents_ButtonTitle* AutofillUploadContents::add_button_title()
{
    ::autofill::AutofillUploadContents_ButtonTitle* _add = _internal_add_button_title();
    // @@protoc_insertion_point(field_add:autofill.AutofillUploadContents.button_title)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::autofill::AutofillUploadContents_ButtonTitle>& AutofillUploadContents::button_title() const
{
    // @@protoc_insertion_point(field_list:autofill.AutofillUploadContents.button_title)
    return _impl_.button_title_;
}

// optional bool has_form_tag = 37;
inline bool AutofillUploadContents::_internal_has_has_form_tag() const
{
    bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
    return value;
}
inline bool AutofillUploadContents::has_has_form_tag() const
{
    return _internal_has_has_form_tag();
}
inline void AutofillUploadContents::clear_has_form_tag()
{
    _impl_.has_form_tag_ = false;
    _impl_._has_bits_[0] &= ~0x00010000u;
}
inline bool AutofillUploadContents::_internal_has_form_tag() const
{
    return _impl_.has_form_tag_;
}
inline bool AutofillUploadContents::has_form_tag() const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.has_form_tag)
    return _internal_has_form_tag();
}
inline void AutofillUploadContents::_internal_set_has_form_tag(bool value)
{
    _impl_._has_bits_[0] |= 0x00010000u;
    _impl_.has_form_tag_ = value;
}
inline void AutofillUploadContents::set_has_form_tag(bool value)
{
    _internal_set_has_form_tag(value);
    // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.has_form_tag)
}

// optional bool was_throttleable = 38 [deprecated = true];
inline bool AutofillUploadContents::_internal_has_was_throttleable() const
{
    bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
    return value;
}
inline bool AutofillUploadContents::has_was_throttleable() const
{
    return _internal_has_was_throttleable();
}
inline void AutofillUploadContents::clear_was_throttleable()
{
    _impl_.was_throttleable_ = false;
    _impl_._has_bits_[0] &= ~0x00080000u;
}
inline bool AutofillUploadContents::_internal_was_throttleable() const
{
    return _impl_.was_throttleable_;
}
inline bool AutofillUploadContents::was_throttleable() const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.was_throttleable)
    return _internal_was_throttleable();
}
inline void AutofillUploadContents::_internal_set_was_throttleable(bool value)
{
    _impl_._has_bits_[0] |= 0x00080000u;
    _impl_.was_throttleable_ = value;
}
inline void AutofillUploadContents::set_was_throttleable(bool value)
{
    _internal_set_was_throttleable(value);
    // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.was_throttleable)
}

// repeated .autofill.AutofillUploadContents.SingleUsernameData single_username_data = 42;
inline int AutofillUploadContents::_internal_single_username_data_size() const
{
    return _impl_.single_username_data_.size();
}
inline int AutofillUploadContents::single_username_data_size() const
{
    return _internal_single_username_data_size();
}
inline void AutofillUploadContents::clear_single_username_data()
{
    _impl_.single_username_data_.Clear();
}
inline ::autofill::AutofillUploadContents_SingleUsernameData* AutofillUploadContents::mutable_single_username_data(int index)
{
    // @@protoc_insertion_point(field_mutable:autofill.AutofillUploadContents.single_username_data)
    return _impl_.single_username_data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::autofill::AutofillUploadContents_SingleUsernameData>* AutofillUploadContents::mutable_single_username_data()
{
    // @@protoc_insertion_point(field_mutable_list:autofill.AutofillUploadContents.single_username_data)
    return &_impl_.single_username_data_;
}
inline const ::autofill::AutofillUploadContents_SingleUsernameData& AutofillUploadContents::_internal_single_username_data(int index) const
{
    return _impl_.single_username_data_.Get(index);
}
inline const ::autofill::AutofillUploadContents_SingleUsernameData& AutofillUploadContents::single_username_data(int index) const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.single_username_data)
    return _internal_single_username_data(index);
}
inline ::autofill::AutofillUploadContents_SingleUsernameData* AutofillUploadContents::_internal_add_single_username_data()
{
    return _impl_.single_username_data_.Add();
}
inline ::autofill::AutofillUploadContents_SingleUsernameData* AutofillUploadContents::add_single_username_data()
{
    ::autofill::AutofillUploadContents_SingleUsernameData* _add = _internal_add_single_username_data();
    // @@protoc_insertion_point(field_add:autofill.AutofillUploadContents.single_username_data)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::autofill::AutofillUploadContents_SingleUsernameData>&
AutofillUploadContents::single_username_data() const
{
    // @@protoc_insertion_point(field_list:autofill.AutofillUploadContents.single_username_data)
    return _impl_.single_username_data_;
}

// optional fixed64 last_address_form_submitted = 43;
inline bool AutofillUploadContents::_internal_has_last_address_form_submitted() const
{
    bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
    return value;
}
inline bool AutofillUploadContents::has_last_address_form_submitted() const
{
    return _internal_has_last_address_form_submitted();
}
inline void AutofillUploadContents::clear_last_address_form_submitted()
{
    _impl_.last_address_form_submitted_ = uint64_t { 0u };
    _impl_._has_bits_[0] &= ~0x00200000u;
}
inline uint64_t AutofillUploadContents::_internal_last_address_form_submitted() const
{
    return _impl_.last_address_form_submitted_;
}
inline uint64_t AutofillUploadContents::last_address_form_submitted() const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.last_address_form_submitted)
    return _internal_last_address_form_submitted();
}
inline void AutofillUploadContents::_internal_set_last_address_form_submitted(uint64_t value)
{
    _impl_._has_bits_[0] |= 0x00200000u;
    _impl_.last_address_form_submitted_ = value;
}
inline void AutofillUploadContents::set_last_address_form_submitted(uint64_t value)
{
    _internal_set_last_address_form_submitted(value);
    // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.last_address_form_submitted)
}

// optional fixed64 second_last_address_form_submitted = 44;
inline bool AutofillUploadContents::_internal_has_second_last_address_form_submitted() const
{
    bool value = (_impl_._has_bits_[0] & 0x00400000u) != 0;
    return value;
}
inline bool AutofillUploadContents::has_second_last_address_form_submitted() const
{
    return _internal_has_second_last_address_form_submitted();
}
inline void AutofillUploadContents::clear_second_last_address_form_submitted()
{
    _impl_.second_last_address_form_submitted_ = uint64_t { 0u };
    _impl_._has_bits_[0] &= ~0x00400000u;
}
inline uint64_t AutofillUploadContents::_internal_second_last_address_form_submitted() const
{
    return _impl_.second_last_address_form_submitted_;
}
inline uint64_t AutofillUploadContents::second_last_address_form_submitted() const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.second_last_address_form_submitted)
    return _internal_second_last_address_form_submitted();
}
inline void AutofillUploadContents::_internal_set_second_last_address_form_submitted(uint64_t value)
{
    _impl_._has_bits_[0] |= 0x00400000u;
    _impl_.second_last_address_form_submitted_ = value;
}
inline void AutofillUploadContents::set_second_last_address_form_submitted(uint64_t value)
{
    _internal_set_second_last_address_form_submitted(value);
    // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.second_last_address_form_submitted)
}

// optional fixed64 last_credit_card_form_submitted = 45;
inline bool AutofillUploadContents::_internal_has_last_credit_card_form_submitted() const
{
    bool value = (_impl_._has_bits_[0] & 0x00800000u) != 0;
    return value;
}
inline bool AutofillUploadContents::has_last_credit_card_form_submitted() const
{
    return _internal_has_last_credit_card_form_submitted();
}
inline void AutofillUploadContents::clear_last_credit_card_form_submitted()
{
    _impl_.last_credit_card_form_submitted_ = uint64_t { 0u };
    _impl_._has_bits_[0] &= ~0x00800000u;
}
inline uint64_t AutofillUploadContents::_internal_last_credit_card_form_submitted() const
{
    return _impl_.last_credit_card_form_submitted_;
}
inline uint64_t AutofillUploadContents::last_credit_card_form_submitted() const
{
    // @@protoc_insertion_point(field_get:autofill.AutofillUploadContents.last_credit_card_form_submitted)
    return _internal_last_credit_card_form_submitted();
}
inline void AutofillUploadContents::_internal_set_last_credit_card_form_submitted(uint64_t value)
{
    _impl_._has_bits_[0] |= 0x00800000u;
    _impl_.last_credit_card_form_submitted_ = value;
}
inline void AutofillUploadContents::set_last_credit_card_form_submitted(uint64_t value)
{
    _internal_set_last_credit_card_form_submitted(value);
    // @@protoc_insertion_point(field_set:autofill.AutofillUploadContents.last_credit_card_form_submitted)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ProfileValidityMap

// map<int32, int32> field_validity_states = 1;
inline int ProfileValidityMap::_internal_field_validity_states_size() const
{
    return _impl_.field_validity_states_.size();
}
inline int ProfileValidityMap::field_validity_states_size() const
{
    return _internal_field_validity_states_size();
}
inline void ProfileValidityMap::clear_field_validity_states()
{
    _impl_.field_validity_states_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map<int32_t, int32_t>& ProfileValidityMap::_internal_field_validity_states() const
{
    return _impl_.field_validity_states_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map<int32_t, int32_t>& ProfileValidityMap::field_validity_states() const
{
    // @@protoc_insertion_point(field_map:autofill.ProfileValidityMap.field_validity_states)
    return _internal_field_validity_states();
}
inline ::PROTOBUF_NAMESPACE_ID::Map<int32_t, int32_t>* ProfileValidityMap::_internal_mutable_field_validity_states()
{
    return _impl_.field_validity_states_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map<int32_t, int32_t>* ProfileValidityMap::mutable_field_validity_states()
{
    // @@protoc_insertion_point(field_mutable_map:autofill.ProfileValidityMap.field_validity_states)
    return _internal_mutable_field_validity_states();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// UserProfileValidityMap

// map<string, .autofill.ProfileValidityMap> profile_validity = 1;
inline int UserProfileValidityMap::_internal_profile_validity_size() const
{
    return _impl_.profile_validity_.size();
}
inline int UserProfileValidityMap::profile_validity_size() const
{
    return _internal_profile_validity_size();
}
inline void UserProfileValidityMap::clear_profile_validity()
{
    _impl_.profile_validity_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map<std::string, ::autofill::ProfileValidityMap>& UserProfileValidityMap::_internal_profile_validity() const
{
    return _impl_.profile_validity_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map<std::string, ::autofill::ProfileValidityMap>& UserProfileValidityMap::profile_validity() const
{
    // @@protoc_insertion_point(field_map:autofill.UserProfileValidityMap.profile_validity)
    return _internal_profile_validity();
}
inline ::PROTOBUF_NAMESPACE_ID::Map<std::string, ::autofill::ProfileValidityMap>* UserProfileValidityMap::_internal_mutable_profile_validity()
{
    return _impl_.profile_validity_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map<std::string, ::autofill::ProfileValidityMap>* UserProfileValidityMap::mutable_profile_validity()
{
    // @@protoc_insertion_point(field_mutable_map:autofill.UserProfileValidityMap.profile_validity)
    return _internal_mutable_profile_validity();
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// @@protoc_insertion_point(namespace_scope)

} // namespace autofill

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum<::autofill::AutofillRandomizedValue_EncodingType> : ::std::true_type { };
template <> struct is_proto_enum<::autofill::AutofillUploadContents_Field_PasswordGenerationType> : ::std::true_type { };
template <> struct is_proto_enum<::autofill::AutofillUploadContents_Field_VoteType> : ::std::true_type { };
template <> struct is_proto_enum<::autofill::AutofillUploadContents_Field_SingleUsernameVoteType> : ::std::true_type { };
template <> struct is_proto_enum<::autofill::AutofillUploadContents_SubmissionIndicatorEvent> : ::std::true_type { };
template <> struct is_proto_enum<::autofill::AutofillUploadContents_ValueType> : ::std::true_type { };
template <> struct is_proto_enum<::autofill::AutofillUploadContents_SingleUsernamePromptEdit> : ::std::true_type { };
template <> struct is_proto_enum<::autofill::ButtonTitleType> : ::std::true_type { };

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_server_2eproto
