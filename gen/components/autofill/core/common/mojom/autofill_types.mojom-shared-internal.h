// components/autofill/core/common/mojom/autofill_types.mojom-shared-internal.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef COMPONENTS_AUTOFILL_CORE_COMMON_MOJOM_AUTOFILL_TYPES_MOJOM_SHARED_INTERNAL_H_
#define COMPONENTS_AUTOFILL_CORE_COMMON_MOJOM_AUTOFILL_TYPES_MOJOM_SHARED_INTERNAL_H_
#include "mojo/public/cpp/bindings/lib/array_internal.h"
#include "mojo/public/cpp/bindings/lib/bindings_internal.h"
#include "mojo/public/cpp/bindings/lib/map_data_internal.h"
#include "mojo/public/cpp/bindings/lib/buffer.h"
#include "mojo/public/mojom/base/text_direction.mojom-shared-internal.h"
#include "mojo/public/mojom/base/time.mojom-shared-internal.h"
#include "mojo/public/mojom/base/string16.mojom-shared-internal.h"
#include "mojo/public/mojom/base/unguessable_token.mojom-shared-internal.h"
#include "ui/gfx/geometry/mojom/geometry.mojom-shared-internal.h"
#include "url/mojom/url.mojom-shared-internal.h"
#include "mojo/public/cpp/bindings/lib/native_enum_data.h"
#include "mojo/public/interfaces/bindings/native_struct.mojom-shared-internal.h"

namespace mojo {
namespace internal {
class ValidationContext;
}
}

namespace autofill::mojom {
namespace internal {
class FrameToken_Data;
class FrameTokenWithPredecessor_Data;
class FormRendererId_Data;
class FieldRendererId_Data;
class SelectOption_Data;
class SectionAutocomplete_Data;
class SectionFieldIdentifier_Data;
class Section_Data;
class AutocompleteParsingResult_Data;
class FormFieldData_Data;
class FormFieldData_FillData_Data;
class ButtonTitleInfo_Data;
class FormData_Data;
class FormFieldDataPredictions_Data;
class FormDataPredictions_Data;
class PasswordAndMetadata_Data;
class PasswordFormFillData_Data;
class PasswordFormGenerationData_Data;
class PasswordGenerationUIData_Data;
class PasswordSuggestionRequest_Data;
class ParsingResult_Data;
class SectionValue_Data;

struct FormControlType_Data {
public:
    static bool constexpr kIsExtensible = false;

    static bool IsKnownValue(int32_t value)
    {
        switch (value) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
        case 10:
        case 11:
        case 12:
        case 14:
            return true;
        }
        return false;
    }

    static bool Validate(int32_t value, mojo::internal::ValidationContext* validation_context)
    {
        if (kIsExtensible || IsKnownValue(value))
            return true;

        ReportValidationError(validation_context, mojo::internal::VALIDATION_ERROR_UNKNOWN_ENUM_VALUE);
        return false;
    }
};

struct HtmlFieldMode_Data {
public:
    static bool constexpr kIsExtensible = false;

    static bool IsKnownValue(int32_t value)
    {
        switch (value) {
        case 0:
        case 1:
        case 2:
            return true;
        }
        return false;
    }

    static bool Validate(int32_t value, mojo::internal::ValidationContext* validation_context)
    {
        if (kIsExtensible || IsKnownValue(value))
            return true;

        ReportValidationError(validation_context, mojo::internal::VALIDATION_ERROR_UNKNOWN_ENUM_VALUE);
        return false;
    }
};

struct HtmlFieldType_Data {
public:
    static bool constexpr kIsExtensible = false;

    static bool IsKnownValue(int32_t value)
    {
        switch (value) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 14:
        case 15:
        case 16:
        case 18:
        case 19:
        case 20:
        case 21:
        case 22:
        case 23:
        case 24:
        case 25:
        case 26:
        case 27:
        case 28:
        case 29:
        case 30:
        case 31:
        case 32:
        case 33:
        case 34:
        case 35:
        case 36:
        case 37:
        case 38:
        case 39:
        case 40:
        case 41:
        case 42:
        case 43:
        case 44:
        case 45:
        case 47:
        case 48:
        case 49:
        case 50:
            return true;
        }
        return false;
    }

    static bool Validate(int32_t value, mojo::internal::ValidationContext* validation_context)
    {
        if (kIsExtensible || IsKnownValue(value))
            return true;

        ReportValidationError(validation_context, mojo::internal::VALIDATION_ERROR_UNKNOWN_ENUM_VALUE);
        return false;
    }
};

struct SubmissionIndicatorEvent_Data {
public:
    static bool constexpr kIsExtensible = false;

    static bool IsKnownValue(int32_t value)
    {
        switch (value) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 10:
        case 11:
        case 12:
            return true;
        }
        return false;
    }

    static bool Validate(int32_t value, mojo::internal::ValidationContext* validation_context)
    {
        if (kIsExtensible || IsKnownValue(value))
            return true;

        ReportValidationError(validation_context, mojo::internal::VALIDATION_ERROR_UNKNOWN_ENUM_VALUE);
        return false;
    }
};

struct SubmissionSource_Data {
public:
    static bool constexpr kIsExtensible = false;

    static bool IsKnownValue(int32_t value)
    {
        switch (value) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
            return true;
        }
        return false;
    }

    static bool Validate(int32_t value, mojo::internal::ValidationContext* validation_context)
    {
        if (kIsExtensible || IsKnownValue(value))
            return true;

        ReportValidationError(validation_context, mojo::internal::VALIDATION_ERROR_UNKNOWN_ENUM_VALUE);
        return false;
    }
};

struct FocusedFieldType_Data {
public:
    static bool constexpr kIsExtensible = false;

    static bool IsKnownValue(int32_t value)
    {
        switch (value) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
            return true;
        }
        return false;
    }

    static bool Validate(int32_t value, mojo::internal::ValidationContext* validation_context)
    {
        if (kIsExtensible || IsKnownValue(value))
            return true;

        ReportValidationError(validation_context, mojo::internal::VALIDATION_ERROR_UNKNOWN_ENUM_VALUE);
        return false;
    }
};

struct ButtonTitleType_Data {
public:
    static bool constexpr kIsExtensible = false;

    static bool IsKnownValue(int32_t value)
    {
        switch (value) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
            return true;
        }
        return false;
    }

    static bool Validate(int32_t value, mojo::internal::ValidationContext* validation_context)
    {
        if (kIsExtensible || IsKnownValue(value))
            return true;

        ReportValidationError(validation_context, mojo::internal::VALIDATION_ERROR_UNKNOWN_ENUM_VALUE);
        return false;
    }
};

struct SubmissionReadinessState_Data {
public:
    static bool constexpr kIsExtensible = false;

    static bool IsKnownValue(int32_t value)
    {
        switch (value) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
            return true;
        }
        return false;
    }

    static bool Validate(int32_t value, mojo::internal::ValidationContext* validation_context)
    {
        if (kIsExtensible || IsKnownValue(value))
            return true;

        ReportValidationError(validation_context, mojo::internal::VALIDATION_ERROR_UNKNOWN_ENUM_VALUE);
        return false;
    }
};

struct AutofillSuggestionAvailability_Data {
public:
    static bool constexpr kIsExtensible = false;

    static bool IsKnownValue(int32_t value)
    {
        switch (value) {
        case 0:
        case 1:
        case 2:
            return true;
        }
        return false;
    }

    static bool Validate(int32_t value, mojo::internal::ValidationContext* validation_context)
    {
        if (kIsExtensible || IsKnownValue(value))
            return true;

        ReportValidationError(validation_context, mojo::internal::VALIDATION_ERROR_UNKNOWN_ENUM_VALUE);
        return false;
    }
};

struct ActionPersistence_Data {
public:
    static bool constexpr kIsExtensible = false;

    static bool IsKnownValue(int32_t value)
    {
        switch (value) {
        case 0:
        case 1:
            return true;
        }
        return false;
    }

    static bool Validate(int32_t value, mojo::internal::ValidationContext* validation_context)
    {
        if (kIsExtensible || IsKnownValue(value))
            return true;

        ReportValidationError(validation_context, mojo::internal::VALIDATION_ERROR_UNKNOWN_ENUM_VALUE);
        return false;
    }
};

struct FormActionType_Data {
public:
    static bool constexpr kIsExtensible = false;

    static bool IsKnownValue(int32_t value)
    {
        switch (value) {
        case 0:
        case 1:
            return true;
        }
        return false;
    }

    static bool Validate(int32_t value, mojo::internal::ValidationContext* validation_context)
    {
        if (kIsExtensible || IsKnownValue(value))
            return true;

        ReportValidationError(validation_context, mojo::internal::VALIDATION_ERROR_UNKNOWN_ENUM_VALUE);
        return false;
    }
};

struct FieldActionType_Data {
public:
    static bool constexpr kIsExtensible = false;

    static bool IsKnownValue(int32_t value)
    {
        switch (value) {
        case 0:
        case 1:
        case 2:
            return true;
        }
        return false;
    }

    static bool Validate(int32_t value, mojo::internal::ValidationContext* validation_context)
    {
        if (kIsExtensible || IsKnownValue(value))
            return true;

        ReportValidationError(validation_context, mojo::internal::VALIDATION_ERROR_UNKNOWN_ENUM_VALUE);
        return false;
    }
};

struct AutofillSuggestionTriggerSource_Data {
public:
    static bool constexpr kIsExtensible = false;

    static bool IsKnownValue(int32_t value)
    {
        switch (value) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 14:
        case 15:
        case 16:
        case 17:
        case 18:
        case 19:
            return true;
        }
        return false;
    }

    static bool Validate(int32_t value, mojo::internal::ValidationContext* validation_context)
    {
        if (kIsExtensible || IsKnownValue(value))
            return true;

        ReportValidationError(validation_context, mojo::internal::VALIDATION_ERROR_UNKNOWN_ENUM_VALUE);
        return false;
    }
};

struct FormFieldData_CheckStatus_Data {
public:
    static bool constexpr kIsExtensible = false;

    static bool IsKnownValue(int32_t value)
    {
        switch (value) {
        case 0:
        case 1:
        case 2:
            return true;
        }
        return false;
    }

    static bool Validate(int32_t value, mojo::internal::ValidationContext* validation_context)
    {
        if (kIsExtensible || IsKnownValue(value))
            return true;

        ReportValidationError(validation_context, mojo::internal::VALIDATION_ERROR_UNKNOWN_ENUM_VALUE);
        return false;
    }
};

struct FormFieldData_RoleAttribute_Data {
public:
    static bool constexpr kIsExtensible = false;

    static bool IsKnownValue(int32_t value)
    {
        switch (value) {
        case 0:
        case 1:
            return true;
        }
        return false;
    }

    static bool Validate(int32_t value, mojo::internal::ValidationContext* validation_context)
    {
        if (kIsExtensible || IsKnownValue(value))
            return true;

        ReportValidationError(validation_context, mojo::internal::VALIDATION_ERROR_UNKNOWN_ENUM_VALUE);
        return false;
    }
};

struct FormFieldData_LabelSource_Data {
public:
    static bool constexpr kIsExtensible = false;

    static bool IsKnownValue(int32_t value)
    {
        switch (value) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 14:
        case 15:
        case 16:
            return true;
        }
        return false;
    }

    static bool Validate(int32_t value, mojo::internal::ValidationContext* validation_context)
    {
        if (kIsExtensible || IsKnownValue(value))
            return true;

        ReportValidationError(validation_context, mojo::internal::VALIDATION_ERROR_UNKNOWN_ENUM_VALUE);
        return false;
    }
};

#pragma pack(push, 1)

class SectionValue_Data {
public:
    // Used to identify Mojom Union Data Classes.
    typedef void MojomUnionDataType;

    SectionValue_Data() = default;
    // Do nothing in the destructor since it won't be called when it is a
    // non-inlined union.
    ~SectionValue_Data() = default;

    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context, bool inlined);

    bool is_null() const
    {
        return size == 0;
    }

    void set_null()
    {
        size = 0U;
        tag = static_cast<SectionValue_Tag>(0);
        data.unknown = 0U;
    }

    // TODO(crbug.com/40731316): SHOUTY_CASE values are being deprecated per C++ code style
    // guidelines (https://google.github.io/styleguide/cppguide.html#Enumerator_Names),
    // please use kCamelCase values instead.  Cleanup NULL_VALUE, BOOL_VALUE, INT_VALUE, etc.
    // generation once codebase is transitioned to kNullValue, kBoolValue, kIntValue, etc.
    enum class SectionValue_Tag : uint32_t {

        kDefaultSection,

        kAutocomplete,

        kFieldIdentifier,
    };

    // A note on layout:
    // "Each non-static data member is allocated as if it were the sole member of
    // a struct." - Section 9.5.2 ISO/IEC 14882:2011 (The C++ Spec)
    union MOJO_ALIGNAS(8) Union_ {
        Union_()
            : unknown(0)
        {
        }
        uint8_t f_default_section : 1;
        mojo::internal::Pointer<internal::SectionAutocomplete_Data> f_autocomplete;
        mojo::internal::Pointer<internal::SectionFieldIdentifier_Data> f_field_identifier;
        uint64_t unknown;
    };

    uint32_t size;
    SectionValue_Tag tag;
    Union_ data;
};
static_assert(sizeof(SectionValue_Data) == mojo::internal::kUnionDataSize, "Bad sizeof(SectionValue_Data)");
class FrameToken_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    mojo::internal::Pointer<::mojo_base::mojom::internal::UnguessableToken_Data> token;
    uint8_t is_local : 1;
    uint8_t padfinal_[7];

private:
    friend class mojo::internal::MessageFragment<FrameToken_Data>;

    FrameToken_Data();
    ~FrameToken_Data() = delete;
};
static_assert(sizeof(FrameToken_Data) == 24, "Bad sizeof(FrameToken_Data)");
// Used by FrameToken::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct FrameToken_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    FrameToken_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~FrameToken_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<FrameToken_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag FrameToken_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class FrameTokenWithPredecessor_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    mojo::internal::Pointer<internal::FrameToken_Data> token;
    int32_t predecessor;
    uint8_t padfinal_[4];

private:
    friend class mojo::internal::MessageFragment<FrameTokenWithPredecessor_Data>;

    FrameTokenWithPredecessor_Data();
    ~FrameTokenWithPredecessor_Data() = delete;
};
static_assert(sizeof(FrameTokenWithPredecessor_Data) == 24, "Bad sizeof(FrameTokenWithPredecessor_Data)");
// Used by FrameTokenWithPredecessor::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct FrameTokenWithPredecessor_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    FrameTokenWithPredecessor_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~FrameTokenWithPredecessor_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<FrameTokenWithPredecessor_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag FrameTokenWithPredecessor_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class FormRendererId_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    uint64_t id;

private:
    friend class mojo::internal::MessageFragment<FormRendererId_Data>;

    FormRendererId_Data();
    ~FormRendererId_Data() = delete;
};
static_assert(sizeof(FormRendererId_Data) == 16, "Bad sizeof(FormRendererId_Data)");
// Used by FormRendererId::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct FormRendererId_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    FormRendererId_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~FormRendererId_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<FormRendererId_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag FormRendererId_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class FieldRendererId_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    uint64_t id;

private:
    friend class mojo::internal::MessageFragment<FieldRendererId_Data>;

    FieldRendererId_Data();
    ~FieldRendererId_Data() = delete;
};
static_assert(sizeof(FieldRendererId_Data) == 16, "Bad sizeof(FieldRendererId_Data)");
// Used by FieldRendererId::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct FieldRendererId_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    FieldRendererId_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~FieldRendererId_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<FieldRendererId_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag FieldRendererId_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class SelectOption_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    mojo::internal::Pointer<::mojo_base::mojom::internal::String16_Data> value;
    mojo::internal::Pointer<::mojo_base::mojom::internal::String16_Data> text;

private:
    friend class mojo::internal::MessageFragment<SelectOption_Data>;

    SelectOption_Data();
    ~SelectOption_Data() = delete;
};
static_assert(sizeof(SelectOption_Data) == 24, "Bad sizeof(SelectOption_Data)");
// Used by SelectOption::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct SelectOption_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    SelectOption_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~SelectOption_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<SelectOption_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag SelectOption_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class SectionAutocomplete_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    mojo::internal::Pointer<mojo::internal::String_Data> section;
    int32_t html_field_mode;
    uint8_t padfinal_[4];

private:
    friend class mojo::internal::MessageFragment<SectionAutocomplete_Data>;

    SectionAutocomplete_Data();
    ~SectionAutocomplete_Data() = delete;
};
static_assert(sizeof(SectionAutocomplete_Data) == 24, "Bad sizeof(SectionAutocomplete_Data)");
// Used by SectionAutocomplete::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct SectionAutocomplete_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    SectionAutocomplete_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~SectionAutocomplete_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<SectionAutocomplete_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag SectionAutocomplete_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class SectionFieldIdentifier_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    mojo::internal::Pointer<mojo::internal::String_Data> field_name;
    uint64_t local_frame_id;
    mojo::internal::Pointer<internal::FieldRendererId_Data> field_renderer_id;

private:
    friend class mojo::internal::MessageFragment<SectionFieldIdentifier_Data>;

    SectionFieldIdentifier_Data();
    ~SectionFieldIdentifier_Data() = delete;
};
static_assert(sizeof(SectionFieldIdentifier_Data) == 32, "Bad sizeof(SectionFieldIdentifier_Data)");
// Used by SectionFieldIdentifier::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct SectionFieldIdentifier_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    SectionFieldIdentifier_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~SectionFieldIdentifier_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<SectionFieldIdentifier_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag SectionFieldIdentifier_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class Section_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    internal::SectionValue_Data value;

private:
    friend class mojo::internal::MessageFragment<Section_Data>;

    Section_Data();
    ~Section_Data() = delete;
};
static_assert(sizeof(Section_Data) == 24, "Bad sizeof(Section_Data)");
// Used by Section::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct Section_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    Section_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~Section_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<Section_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag Section_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class AutocompleteParsingResult_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    mojo::internal::Pointer<mojo::internal::String_Data> section;
    int32_t mode;
    int32_t field_type;
    uint8_t webauthn : 1;
    uint8_t padfinal_[7];

private:
    friend class mojo::internal::MessageFragment<AutocompleteParsingResult_Data>;

    AutocompleteParsingResult_Data();
    ~AutocompleteParsingResult_Data() = delete;
};
static_assert(sizeof(AutocompleteParsingResult_Data) == 32, "Bad sizeof(AutocompleteParsingResult_Data)");
// Used by AutocompleteParsingResult::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct AutocompleteParsingResult_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    AutocompleteParsingResult_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~AutocompleteParsingResult_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<AutocompleteParsingResult_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag AutocompleteParsingResult_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class FormFieldData_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    mojo::internal::Pointer<::mojo_base::mojom::internal::String16_Data> label;
    mojo::internal::Pointer<::mojo_base::mojom::internal::String16_Data> name;
    mojo::internal::Pointer<::mojo_base::mojom::internal::String16_Data> id_attribute;
    mojo::internal::Pointer<::mojo_base::mojom::internal::String16_Data> name_attribute;
    mojo::internal::Pointer<::mojo_base::mojom::internal::String16_Data> value;
    mojo::internal::Pointer<::mojo_base::mojom::internal::String16_Data> selected_text;
    int32_t form_control_type;
    uint32_t properties_mask;
    mojo::internal::Pointer<mojo::internal::String_Data> autocomplete_attribute;
    mojo::internal::Pointer<internal::AutocompleteParsingResult_Data> parsed_autocomplete;
    mojo::internal::Pointer<::mojo_base::mojom::internal::String16_Data> placeholder;
    mojo::internal::Pointer<::mojo_base::mojom::internal::String16_Data> css_classes;
    mojo::internal::Pointer<::mojo_base::mojom::internal::String16_Data> aria_label;
    mojo::internal::Pointer<::mojo_base::mojom::internal::String16_Data> aria_description;
    mojo::internal::Pointer<internal::FieldRendererId_Data> renderer_id;
    mojo::internal::Pointer<internal::FormRendererId_Data> host_form_id;
    int32_t form_control_ax_id;
    uint8_t is_user_edited : 1;
    uint8_t is_autofilled : 1;
    uint8_t is_focusable : 1;
    uint8_t is_visible : 1;
    uint8_t should_autocomplete : 1;
    uint8_t is_enabled : 1;
    uint8_t is_readonly : 1;
    uint8_t allows_writing_suggestions : 1;
    uint8_t force_override : 1;
    uint8_t pad25_[2];
    uint64_t max_length;
    mojo::internal::Pointer<internal::Section_Data> section;
    int32_t check_status;
    int32_t role;
    int32_t text_direction;
    int32_t label_source;
    mojo::internal::Pointer<::mojo_base::mojom::internal::String16_Data> user_input;
    mojo::internal::Pointer<mojo::internal::Array_Data<mojo::internal::Pointer<internal::SelectOption_Data>>> options;
    mojo::internal::Pointer<::gfx::mojom::internal::RectF_Data> bounds;
    mojo::internal::Pointer<mojo::internal::Array_Data<mojo::internal::Pointer<internal::SelectOption_Data>>> datalist_options;

private:
    friend class mojo::internal::MessageFragment<FormFieldData_Data>;

    FormFieldData_Data();
    ~FormFieldData_Data() = delete;
};
static_assert(sizeof(FormFieldData_Data) == 200, "Bad sizeof(FormFieldData_Data)");
// Used by FormFieldData::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct FormFieldData_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    FormFieldData_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~FormFieldData_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<FormFieldData_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag FormFieldData_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class FormFieldData_FillData_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    mojo::internal::Pointer<::mojo_base::mojom::internal::String16_Data> value;
    mojo::internal::Pointer<internal::FieldRendererId_Data> renderer_id;
    mojo::internal::Pointer<internal::FormRendererId_Data> host_form_id;
    uint8_t is_autofilled : 1;
    uint8_t force_override : 1;
    uint8_t padfinal_[7];

private:
    friend class mojo::internal::MessageFragment<FormFieldData_FillData_Data>;

    FormFieldData_FillData_Data();
    ~FormFieldData_FillData_Data() = delete;
};
static_assert(sizeof(FormFieldData_FillData_Data) == 40, "Bad sizeof(FormFieldData_FillData_Data)");
// Used by FormFieldData_FillData::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct FormFieldData_FillData_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    FormFieldData_FillData_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~FormFieldData_FillData_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<FormFieldData_FillData_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag FormFieldData_FillData_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class ButtonTitleInfo_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    mojo::internal::Pointer<::mojo_base::mojom::internal::String16_Data> title;
    int32_t type;
    uint8_t padfinal_[4];

private:
    friend class mojo::internal::MessageFragment<ButtonTitleInfo_Data>;

    ButtonTitleInfo_Data();
    ~ButtonTitleInfo_Data() = delete;
};
static_assert(sizeof(ButtonTitleInfo_Data) == 24, "Bad sizeof(ButtonTitleInfo_Data)");
// Used by ButtonTitleInfo::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct ButtonTitleInfo_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    ButtonTitleInfo_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~ButtonTitleInfo_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<ButtonTitleInfo_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag ButtonTitleInfo_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class FormData_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    mojo::internal::Pointer<::mojo_base::mojom::internal::String16_Data> id_attribute;
    mojo::internal::Pointer<::mojo_base::mojom::internal::String16_Data> name_attribute;
    mojo::internal::Pointer<::mojo_base::mojom::internal::String16_Data> name;
    mojo::internal::Pointer<mojo::internal::Array_Data<mojo::internal::Pointer<internal::ButtonTitleInfo_Data>>> button_titles;
    mojo::internal::Pointer<::url::mojom::internal::Url_Data> action;
    uint8_t is_action_empty : 1;
    uint8_t is_gaia_with_skip_save_password_form : 1;
    uint8_t likely_contains_captcha : 1;
    uint8_t pad7_[3];
    int32_t submission_event;
    mojo::internal::Pointer<internal::FormRendererId_Data> renderer_id;
    mojo::internal::Pointer<mojo::internal::Array_Data<mojo::internal::Pointer<internal::FrameTokenWithPredecessor_Data>>> child_frames;
    mojo::internal::Pointer<mojo::internal::Array_Data<mojo::internal::Pointer<internal::FormFieldData_Data>>> fields;
    mojo::internal::Pointer<mojo::internal::Array_Data<mojo::internal::Pointer<internal::FieldRendererId_Data>>> username_predictions;

private:
    friend class mojo::internal::MessageFragment<FormData_Data>;

    FormData_Data();
    ~FormData_Data() = delete;
};
static_assert(sizeof(FormData_Data) == 88, "Bad sizeof(FormData_Data)");
// Used by FormData::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct FormData_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    FormData_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~FormData_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<FormData_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag FormData_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class FormFieldDataPredictions_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    mojo::internal::Pointer<mojo::internal::String_Data> host_form_signature;
    mojo::internal::Pointer<mojo::internal::String_Data> signature;
    mojo::internal::Pointer<mojo::internal::String_Data> heuristic_type;
    mojo::internal::Pointer<mojo::internal::String_Data> server_type;
    mojo::internal::Pointer<mojo::internal::String_Data> html_type;
    mojo::internal::Pointer<mojo::internal::String_Data> overall_type;
    mojo::internal::Pointer<mojo::internal::String_Data> parseable_name;
    mojo::internal::Pointer<mojo::internal::String_Data> parseable_label;
    mojo::internal::Pointer<mojo::internal::String_Data> section;
    uint32_t rank;
    uint32_t rank_in_signature_group;
    uint32_t rank_in_host_form;
    uint32_t rank_in_host_form_signature_group;

private:
    friend class mojo::internal::MessageFragment<FormFieldDataPredictions_Data>;

    FormFieldDataPredictions_Data();
    ~FormFieldDataPredictions_Data() = delete;
};
static_assert(sizeof(FormFieldDataPredictions_Data) == 96, "Bad sizeof(FormFieldDataPredictions_Data)");
// Used by FormFieldDataPredictions::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct FormFieldDataPredictions_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    FormFieldDataPredictions_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~FormFieldDataPredictions_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<FormFieldDataPredictions_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag FormFieldDataPredictions_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class FormDataPredictions_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    mojo::internal::Pointer<internal::FormData_Data> data;
    mojo::internal::Pointer<mojo::internal::String_Data> signature;
    mojo::internal::Pointer<mojo::internal::String_Data> alternative_signature;
    mojo::internal::Pointer<mojo::internal::Array_Data<mojo::internal::Pointer<internal::FormFieldDataPredictions_Data>>> fields;

private:
    friend class mojo::internal::MessageFragment<FormDataPredictions_Data>;

    FormDataPredictions_Data();
    ~FormDataPredictions_Data() = delete;
};
static_assert(sizeof(FormDataPredictions_Data) == 40, "Bad sizeof(FormDataPredictions_Data)");
// Used by FormDataPredictions::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct FormDataPredictions_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    FormDataPredictions_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~FormDataPredictions_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<FormDataPredictions_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag FormDataPredictions_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class PasswordAndMetadata_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    mojo::internal::Pointer<::mojo_base::mojom::internal::String16_Data> username_value;
    mojo::internal::Pointer<::mojo_base::mojom::internal::String16_Data> password_value;
    mojo::internal::Pointer<mojo::internal::String_Data> realm;
    uint8_t uses_account_store : 1;
    uint8_t padfinal_[7];

private:
    friend class mojo::internal::MessageFragment<PasswordAndMetadata_Data>;

    PasswordAndMetadata_Data();
    ~PasswordAndMetadata_Data() = delete;
};
static_assert(sizeof(PasswordAndMetadata_Data) == 40, "Bad sizeof(PasswordAndMetadata_Data)");
// Used by PasswordAndMetadata::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct PasswordAndMetadata_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    PasswordAndMetadata_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~PasswordAndMetadata_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<PasswordAndMetadata_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag PasswordAndMetadata_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class PasswordFormFillData_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    mojo::internal::Pointer<internal::FormRendererId_Data> form_renderer_id;
    mojo::internal::Pointer<::url::mojom::internal::Url_Data> url;
    mojo::internal::Pointer<internal::FieldRendererId_Data> username_element_renderer_id;
    mojo::internal::Pointer<internal::FieldRendererId_Data> password_element_renderer_id;
    uint8_t username_may_use_prefilled_placeholder : 1;
    uint8_t wait_for_username : 1;
    uint8_t pad5_[7];
    mojo::internal::Pointer<internal::PasswordAndMetadata_Data> preferred_login;
    mojo::internal::Pointer<mojo::internal::Array_Data<mojo::internal::Pointer<internal::PasswordAndMetadata_Data>>> additional_logins;
    mojo::internal::Pointer<mojo::internal::Array_Data<mojo::internal::Pointer<internal::FieldRendererId_Data>>> suggestion_banned_fields;

private:
    friend class mojo::internal::MessageFragment<PasswordFormFillData_Data>;

    PasswordFormFillData_Data();
    ~PasswordFormFillData_Data() = delete;
};
static_assert(sizeof(PasswordFormFillData_Data) == 72, "Bad sizeof(PasswordFormFillData_Data)");
// Used by PasswordFormFillData::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct PasswordFormFillData_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    PasswordFormFillData_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~PasswordFormFillData_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<PasswordFormFillData_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag PasswordFormFillData_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class PasswordFormGenerationData_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    mojo::internal::Pointer<internal::FieldRendererId_Data> new_password_renderer_id;
    mojo::internal::Pointer<internal::FieldRendererId_Data> confirmation_password_renderer_id;

private:
    friend class mojo::internal::MessageFragment<PasswordFormGenerationData_Data>;

    PasswordFormGenerationData_Data();
    ~PasswordFormGenerationData_Data() = delete;
};
static_assert(sizeof(PasswordFormGenerationData_Data) == 24, "Bad sizeof(PasswordFormGenerationData_Data)");
// Used by PasswordFormGenerationData::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct PasswordFormGenerationData_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    PasswordFormGenerationData_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~PasswordFormGenerationData_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<PasswordFormGenerationData_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag PasswordFormGenerationData_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class PasswordGenerationUIData_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    mojo::internal::Pointer<::gfx::mojom::internal::RectF_Data> bounds;
    int32_t max_length;
    uint8_t is_generation_element_password_type : 1;
    uint8_t input_field_empty : 1;
    uint8_t pad3_[3];
    mojo::internal::Pointer<::mojo_base::mojom::internal::String16_Data> generation_element;
    mojo::internal::Pointer<internal::FieldRendererId_Data> generation_element_id;
    int32_t text_direction;
    uint8_t pad6_[4];
    mojo::internal::Pointer<internal::FormData_Data> form_data;

private:
    friend class mojo::internal::MessageFragment<PasswordGenerationUIData_Data>;

    PasswordGenerationUIData_Data();
    ~PasswordGenerationUIData_Data() = delete;
};
static_assert(sizeof(PasswordGenerationUIData_Data) == 56, "Bad sizeof(PasswordGenerationUIData_Data)");
// Used by PasswordGenerationUIData::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct PasswordGenerationUIData_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    PasswordGenerationUIData_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~PasswordGenerationUIData_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<PasswordGenerationUIData_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag PasswordGenerationUIData_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class PasswordSuggestionRequest_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    mojo::internal::Pointer<internal::FieldRendererId_Data> element_id;
    mojo::internal::Pointer<internal::FormData_Data> form_data;
    int32_t trigger_source;
    int32_t text_direction;
    uint64_t username_field_index;
    uint64_t password_field_index;
    mojo::internal::Pointer<::mojo_base::mojom::internal::String16_Data> typed_username;
    uint8_t show_webauthn_credentials : 1;
    uint8_t pad7_[7];
    mojo::internal::Pointer<::gfx::mojom::internal::RectF_Data> bounds;

private:
    friend class mojo::internal::MessageFragment<PasswordSuggestionRequest_Data>;

    PasswordSuggestionRequest_Data();
    ~PasswordSuggestionRequest_Data() = delete;
};
static_assert(sizeof(PasswordSuggestionRequest_Data) == 72, "Bad sizeof(PasswordSuggestionRequest_Data)");
// Used by PasswordSuggestionRequest::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct PasswordSuggestionRequest_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    PasswordSuggestionRequest_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~PasswordSuggestionRequest_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<PasswordSuggestionRequest_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag PasswordSuggestionRequest_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class ParsingResult_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    mojo::internal::Pointer<internal::FieldRendererId_Data> username_renderer_id;
    mojo::internal::Pointer<internal::FieldRendererId_Data> password_renderer_id;
    mojo::internal::Pointer<internal::FieldRendererId_Data> new_password_renderer_id;
    mojo::internal::Pointer<internal::FieldRendererId_Data> confirm_password_renderer_id;

private:
    friend class mojo::internal::MessageFragment<ParsingResult_Data>;

    ParsingResult_Data();
    ~ParsingResult_Data() = delete;
};
static_assert(sizeof(ParsingResult_Data) == 40, "Bad sizeof(ParsingResult_Data)");
// Used by ParsingResult::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct ParsingResult_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    ParsingResult_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~ParsingResult_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<ParsingResult_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag ParsingResult_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};

#pragma pack(pop)

} // namespace internal

} // autofill::mojom

#endif // COMPONENTS_AUTOFILL_CORE_COMMON_MOJOM_AUTOFILL_TYPES_MOJOM_SHARED_INTERNAL_H_
