// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: fingerprint.proto

#include "fingerprint.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace autofill {
namespace risk {
PROTOBUF_CONSTEXPR Fingerprint_Dimension::Fingerprint_Dimension(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.width_)*/ 0, /*decltype(_impl_.height_)*/ 0 }
{
}
struct Fingerprint_DimensionDefaultTypeInternal {
    PROTOBUF_CONSTEXPR Fingerprint_DimensionDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~Fingerprint_DimensionDefaultTypeInternal()
    {
    }
    union {
        Fingerprint_Dimension _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Fingerprint_DimensionDefaultTypeInternal
    _Fingerprint_Dimension_default_instance_;
PROTOBUF_CONSTEXPR Fingerprint_MachineCharacteristics_Plugin::Fingerprint_MachineCharacteristics_Plugin(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.mime_type_)*/ {},
        /*decltype(_impl_.name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.description_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.version_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct Fingerprint_MachineCharacteristics_PluginDefaultTypeInternal {
    PROTOBUF_CONSTEXPR Fingerprint_MachineCharacteristics_PluginDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~Fingerprint_MachineCharacteristics_PluginDefaultTypeInternal()
    {
    }
    union {
        Fingerprint_MachineCharacteristics_Plugin _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Fingerprint_MachineCharacteristics_PluginDefaultTypeInternal
    _Fingerprint_MachineCharacteristics_Plugin_default_instance_;
PROTOBUF_CONSTEXPR Fingerprint_MachineCharacteristics_Cpu::Fingerprint_MachineCharacteristics_Cpu(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.vendor_name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.brand_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct Fingerprint_MachineCharacteristics_CpuDefaultTypeInternal {
    PROTOBUF_CONSTEXPR Fingerprint_MachineCharacteristics_CpuDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~Fingerprint_MachineCharacteristics_CpuDefaultTypeInternal()
    {
    }
    union {
        Fingerprint_MachineCharacteristics_Cpu _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Fingerprint_MachineCharacteristics_CpuDefaultTypeInternal
    _Fingerprint_MachineCharacteristics_Cpu_default_instance_;
PROTOBUF_CONSTEXPR Fingerprint_MachineCharacteristics_Graphics::Fingerprint_MachineCharacteristics_Graphics(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.driver_version_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.driver_date_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.vendor_id_)*/ 0u,
        /*decltype(_impl_.device_id_)*/ 0u }
{
}
struct Fingerprint_MachineCharacteristics_GraphicsDefaultTypeInternal {
    PROTOBUF_CONSTEXPR Fingerprint_MachineCharacteristics_GraphicsDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~Fingerprint_MachineCharacteristics_GraphicsDefaultTypeInternal()
    {
    }
    union {
        Fingerprint_MachineCharacteristics_Graphics _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Fingerprint_MachineCharacteristics_GraphicsDefaultTypeInternal
    _Fingerprint_MachineCharacteristics_Graphics_default_instance_;
PROTOBUF_CONSTEXPR Fingerprint_MachineCharacteristics::Fingerprint_MachineCharacteristics(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.font_)*/ {}, /*decltype(_impl_.plugin_)*/ {},
        /*decltype(_impl_.requested_language_)*/ {}, /*decltype(_impl_.partition_size_)*/ {},
        /*decltype(_impl_.operating_system_build_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.browser_language_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.charset_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.user_agent_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.browser_build_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.screen_size_)*/ nullptr,
        /*decltype(_impl_.unavailable_screen_size_)*/ nullptr, /*decltype(_impl_.cpu_)*/ nullptr, /*decltype(_impl_.graphics_card_)*/ nullptr,
        /*decltype(_impl_.user_and_device_name_hash_)*/ uint64_t { 0u }, /*decltype(_impl_.browser_install_time_hours_)*/ int64_t { 0 },
        /*decltype(_impl_.utc_offset_ms_)*/ int64_t { 0 }, /*decltype(_impl_.screen_count_)*/ 0, /*decltype(_impl_.screen_color_depth_)*/ 0,
        /*decltype(_impl_.ram_)*/ int64_t { 0 }, /*decltype(_impl_.browser_feature_)*/ 0 }
{
}
struct Fingerprint_MachineCharacteristicsDefaultTypeInternal {
    PROTOBUF_CONSTEXPR Fingerprint_MachineCharacteristicsDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~Fingerprint_MachineCharacteristicsDefaultTypeInternal()
    {
    }
    union {
        Fingerprint_MachineCharacteristics _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Fingerprint_MachineCharacteristicsDefaultTypeInternal
    _Fingerprint_MachineCharacteristics_default_instance_;
PROTOBUF_CONSTEXPR Fingerprint_TransientState::Fingerprint_TransientState(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.inner_window_size_)*/ nullptr,
        /*decltype(_impl_.outer_window_size_)*/ nullptr }
{
}
struct Fingerprint_TransientStateDefaultTypeInternal {
    PROTOBUF_CONSTEXPR Fingerprint_TransientStateDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~Fingerprint_TransientStateDefaultTypeInternal()
    {
    }
    union {
        Fingerprint_TransientState _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Fingerprint_TransientStateDefaultTypeInternal
    _Fingerprint_TransientState_default_instance_;
PROTOBUF_CONSTEXPR Fingerprint_Performance::Fingerprint_Performance(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.network_type_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.bandwidth_)*/ 0,
        /*decltype(_impl_.metered_)*/ false }
{
}
struct Fingerprint_PerformanceDefaultTypeInternal {
    PROTOBUF_CONSTEXPR Fingerprint_PerformanceDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~Fingerprint_PerformanceDefaultTypeInternal()
    {
    }
    union {
        Fingerprint_Performance _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Fingerprint_PerformanceDefaultTypeInternal
    _Fingerprint_Performance_default_instance_;
PROTOBUF_CONSTEXPR Fingerprint_UserCharacteristics_Vector::Fingerprint_UserCharacteristics_Vector(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.x_)*/ 0, /*decltype(_impl_.y_)*/ 0,
        /*decltype(_impl_.z_)*/ 0 }
{
}
struct Fingerprint_UserCharacteristics_VectorDefaultTypeInternal {
    PROTOBUF_CONSTEXPR Fingerprint_UserCharacteristics_VectorDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~Fingerprint_UserCharacteristics_VectorDefaultTypeInternal()
    {
    }
    union {
        Fingerprint_UserCharacteristics_Vector _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Fingerprint_UserCharacteristics_VectorDefaultTypeInternal
    _Fingerprint_UserCharacteristics_Vector_default_instance_;
PROTOBUF_CONSTEXPR Fingerprint_UserCharacteristics_Location::Fingerprint_UserCharacteristics_Location(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.altitude_)*/ 0, /*decltype(_impl_.latitude_)*/ 0,
        /*decltype(_impl_.longitude_)*/ 0, /*decltype(_impl_.accuracy_)*/ 0, /*decltype(_impl_.time_in_ms_)*/ int64_t { 0 } }
{
}
struct Fingerprint_UserCharacteristics_LocationDefaultTypeInternal {
    PROTOBUF_CONSTEXPR Fingerprint_UserCharacteristics_LocationDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~Fingerprint_UserCharacteristics_LocationDefaultTypeInternal()
    {
    }
    union {
        Fingerprint_UserCharacteristics_Location _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Fingerprint_UserCharacteristics_LocationDefaultTypeInternal
    _Fingerprint_UserCharacteristics_Location_default_instance_;
PROTOBUF_CONSTEXPR Fingerprint_UserCharacteristics::Fingerprint_UserCharacteristics(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.device_orientation_)*/ nullptr,
        /*decltype(_impl_.device_acceleration_)*/ nullptr, /*decltype(_impl_.location_)*/ nullptr, /*decltype(_impl_.force_)*/ 0,
        /*decltype(_impl_.touch_width_)*/ 0, /*decltype(_impl_.touch_height_)*/ 0, /*decltype(_impl_.touch_rotation_)*/ 0 }
{
}
struct Fingerprint_UserCharacteristicsDefaultTypeInternal {
    PROTOBUF_CONSTEXPR Fingerprint_UserCharacteristicsDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~Fingerprint_UserCharacteristicsDefaultTypeInternal()
    {
    }
    union {
        Fingerprint_UserCharacteristics _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Fingerprint_UserCharacteristicsDefaultTypeInternal
    _Fingerprint_UserCharacteristics_default_instance_;
PROTOBUF_CONSTEXPR Fingerprint_Metadata::Fingerprint_Metadata(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.timestamp_ms_)*/ int64_t { 0 },
        /*decltype(_impl_.obfuscated_gaia_id_)*/ uint64_t { 0u }, /*decltype(_impl_.fingerprinter_version_)*/ 0 }
{
}
struct Fingerprint_MetadataDefaultTypeInternal {
    PROTOBUF_CONSTEXPR Fingerprint_MetadataDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~Fingerprint_MetadataDefaultTypeInternal()
    {
    }
    union {
        Fingerprint_Metadata _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Fingerprint_MetadataDefaultTypeInternal
    _Fingerprint_Metadata_default_instance_;
PROTOBUF_CONSTEXPR Fingerprint::Fingerprint(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.machine_characteristics_)*/ nullptr,
        /*decltype(_impl_.performance_)*/ nullptr, /*decltype(_impl_.user_characteristics_)*/ nullptr, /*decltype(_impl_.transient_state_)*/ nullptr,
        /*decltype(_impl_.metadata_)*/ nullptr }
{
}
struct FingerprintDefaultTypeInternal {
    PROTOBUF_CONSTEXPR FingerprintDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~FingerprintDefaultTypeInternal()
    {
    }
    union {
        Fingerprint _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FingerprintDefaultTypeInternal _Fingerprint_default_instance_;
} // namespace risk
} // namespace autofill
namespace autofill {
namespace risk {
bool Fingerprint_MachineCharacteristics_BrowserFeature_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Fingerprint_MachineCharacteristics_BrowserFeature_strings[3] = {};

static const char Fingerprint_MachineCharacteristics_BrowserFeature_names[] = "DEPRECATED_FEATURE_AUTOCHECKOUT"
                                                                              "FEATURE_REQUEST_AUTOCOMPLETE"
                                                                              "FEATURE_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Fingerprint_MachineCharacteristics_BrowserFeature_entries[] = {
    { { Fingerprint_MachineCharacteristics_BrowserFeature_names + 0, 31 }, 1 },
    { { Fingerprint_MachineCharacteristics_BrowserFeature_names + 31, 28 }, 2 },
    { { Fingerprint_MachineCharacteristics_BrowserFeature_names + 59, 15 }, 0 },
};

static const int Fingerprint_MachineCharacteristics_BrowserFeature_entries_by_number[] = {
    2, // 0 -> FEATURE_UNKNOWN
    0, // 1 -> DEPRECATED_FEATURE_AUTOCHECKOUT
    1, // 2 -> FEATURE_REQUEST_AUTOCOMPLETE
};

const std::string& Fingerprint_MachineCharacteristics_BrowserFeature_Name(Fingerprint_MachineCharacteristics_BrowserFeature value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(Fingerprint_MachineCharacteristics_BrowserFeature_entries,
        Fingerprint_MachineCharacteristics_BrowserFeature_entries_by_number, 3, Fingerprint_MachineCharacteristics_BrowserFeature_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        Fingerprint_MachineCharacteristics_BrowserFeature_entries, Fingerprint_MachineCharacteristics_BrowserFeature_entries_by_number, 3, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : Fingerprint_MachineCharacteristics_BrowserFeature_strings[idx].get();
}
bool Fingerprint_MachineCharacteristics_BrowserFeature_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Fingerprint_MachineCharacteristics_BrowserFeature* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(Fingerprint_MachineCharacteristics_BrowserFeature_entries, 3, name, &int_value);
    if (success) {
        *value = static_cast<Fingerprint_MachineCharacteristics_BrowserFeature>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Fingerprint_MachineCharacteristics_BrowserFeature Fingerprint_MachineCharacteristics::FEATURE_UNKNOWN;
constexpr Fingerprint_MachineCharacteristics_BrowserFeature Fingerprint_MachineCharacteristics::DEPRECATED_FEATURE_AUTOCHECKOUT;
constexpr Fingerprint_MachineCharacteristics_BrowserFeature Fingerprint_MachineCharacteristics::FEATURE_REQUEST_AUTOCOMPLETE;
constexpr Fingerprint_MachineCharacteristics_BrowserFeature Fingerprint_MachineCharacteristics::BrowserFeature_MIN;
constexpr Fingerprint_MachineCharacteristics_BrowserFeature Fingerprint_MachineCharacteristics::BrowserFeature_MAX;
constexpr int Fingerprint_MachineCharacteristics::BrowserFeature_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class Fingerprint_Dimension::_Internal {
public:
    using HasBits = decltype(std::declval<Fingerprint_Dimension>()._impl_._has_bits_);
    static void set_has_width(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_height(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

Fingerprint_Dimension::Fingerprint_Dimension(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:autofill.risk.Fingerprint.Dimension)
}
Fingerprint_Dimension::Fingerprint_Dimension(const Fingerprint_Dimension& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    Fingerprint_Dimension* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.width_) {},
        decltype(_impl_.height_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.width_, &from._impl_.width_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.height_) - reinterpret_cast<char*>(&_impl_.width_)) + sizeof(_impl_.height_));
    // @@protoc_insertion_point(copy_constructor:autofill.risk.Fingerprint.Dimension)
}

inline void Fingerprint_Dimension::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_)
        Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.width_) { 0 }, decltype(_impl_.height_) { 0 } };
}

Fingerprint_Dimension::~Fingerprint_Dimension()
{
    // @@protoc_insertion_point(destructor:autofill.risk.Fingerprint.Dimension)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void Fingerprint_Dimension::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Fingerprint_Dimension::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void Fingerprint_Dimension::Clear()
{
    // @@protoc_insertion_point(message_clear_start:autofill.risk.Fingerprint.Dimension)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        ::memset(&_impl_.width_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.height_) - reinterpret_cast<char*>(&_impl_.width_)) + sizeof(_impl_.height_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* Fingerprint_Dimension::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional int32 width = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_width(&has_bits);
                _impl_.width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 height = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_height(&has_bits);
                _impl_.height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* Fingerprint_Dimension::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:autofill.risk.Fingerprint.Dimension)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional int32 width = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_width(), target);
    }

    // optional int32 height = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_height(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:autofill.risk.Fingerprint.Dimension)
    return target;
}

size_t Fingerprint_Dimension::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:autofill.risk.Fingerprint.Dimension)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional int32 width = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_width());
        }

        // optional int32 height = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_height());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void Fingerprint_Dimension::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const Fingerprint_Dimension*>(&from));
}

void Fingerprint_Dimension::MergeFrom(const Fingerprint_Dimension& from)
{
    Fingerprint_Dimension* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:autofill.risk.Fingerprint.Dimension)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_impl_.width_ = from._impl_.width_;
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.height_ = from._impl_.height_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Fingerprint_Dimension::CopyFrom(const Fingerprint_Dimension& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:autofill.risk.Fingerprint.Dimension)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool Fingerprint_Dimension::IsInitialized() const
{
    return true;
}

void Fingerprint_Dimension::InternalSwap(Fingerprint_Dimension* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(Fingerprint_Dimension, _impl_.height_) + sizeof(Fingerprint_Dimension::_impl_.height_)
        - PROTOBUF_FIELD_OFFSET(Fingerprint_Dimension, _impl_.width_)>(reinterpret_cast<char*>(&_impl_.width_), reinterpret_cast<char*>(&other->_impl_.width_));
}

std::string Fingerprint_Dimension::GetTypeName() const
{
    return "autofill.risk.Fingerprint.Dimension";
}

// ===================================================================

class Fingerprint_MachineCharacteristics_Plugin::_Internal {
public:
    using HasBits = decltype(std::declval<Fingerprint_MachineCharacteristics_Plugin>()._impl_._has_bits_);
    static void set_has_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_description(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_version(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
};

Fingerprint_MachineCharacteristics_Plugin::Fingerprint_MachineCharacteristics_Plugin(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:autofill.risk.Fingerprint.MachineCharacteristics.Plugin)
}
Fingerprint_MachineCharacteristics_Plugin::Fingerprint_MachineCharacteristics_Plugin(const Fingerprint_MachineCharacteristics_Plugin& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    Fingerprint_MachineCharacteristics_Plugin* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.mime_type_) { from._impl_.mime_type_ }, decltype(_impl_.name_) {}, decltype(_impl_.description_) {}, decltype(_impl_.version_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_name()) {
        _this->_impl_.name_.Set(from._internal_name(), _this->GetArenaForAllocation());
    }
    _impl_.description_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_description()) {
        _this->_impl_.description_.Set(from._internal_description(), _this->GetArenaForAllocation());
    }
    _impl_.version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_version()) {
        _this->_impl_.version_.Set(from._internal_version(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:autofill.risk.Fingerprint.MachineCharacteristics.Plugin)
}

inline void Fingerprint_MachineCharacteristics_Plugin::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.mime_type_) { arena },
        decltype(_impl_.name_) {}, decltype(_impl_.description_) {}, decltype(_impl_.version_) {} };
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Fingerprint_MachineCharacteristics_Plugin::~Fingerprint_MachineCharacteristics_Plugin()
{
    // @@protoc_insertion_point(destructor:autofill.risk.Fingerprint.MachineCharacteristics.Plugin)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void Fingerprint_MachineCharacteristics_Plugin::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.mime_type_.~RepeatedPtrField();
    _impl_.name_.Destroy();
    _impl_.description_.Destroy();
    _impl_.version_.Destroy();
}

void Fingerprint_MachineCharacteristics_Plugin::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void Fingerprint_MachineCharacteristics_Plugin::Clear()
{
    // @@protoc_insertion_point(message_clear_start:autofill.risk.Fingerprint.MachineCharacteristics.Plugin)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.mime_type_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.name_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.description_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            _impl_.version_.ClearNonDefaultToEmpty();
        }
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* Fingerprint_MachineCharacteristics_Plugin::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string name = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string description = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_description();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated string mime_type = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    auto str = _internal_add_mime_type();
                    ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional string version = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                auto str = _internal_mutable_version();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* Fingerprint_MachineCharacteristics_Plugin::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:autofill.risk.Fingerprint.MachineCharacteristics.Plugin)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_name(), target);
    }

    // optional string description = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_description(), target);
    }

    // repeated string mime_type = 3;
    for (int i = 0, n = this->_internal_mime_type_size(); i < n; i++) {
        const auto& s = this->_internal_mime_type(i);
        target = stream->WriteString(3, s, target);
    }

    // optional string version = 4;
    if (cached_has_bits & 0x00000004u) {
        target = stream->WriteStringMaybeAliased(4, this->_internal_version(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:autofill.risk.Fingerprint.MachineCharacteristics.Plugin)
    return target;
}

size_t Fingerprint_MachineCharacteristics_Plugin::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:autofill.risk.Fingerprint.MachineCharacteristics.Plugin)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated string mime_type = 3;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.mime_type_.size());
    for (int i = 0, n = _impl_.mime_type_.size(); i < n; i++) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(_impl_.mime_type_.Get(i));
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional string name = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_name());
        }

        // optional string description = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_description());
        }

        // optional string version = 4;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_version());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void Fingerprint_MachineCharacteristics_Plugin::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const Fingerprint_MachineCharacteristics_Plugin*>(&from));
}

void Fingerprint_MachineCharacteristics_Plugin::MergeFrom(const Fingerprint_MachineCharacteristics_Plugin& from)
{
    Fingerprint_MachineCharacteristics_Plugin* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:autofill.risk.Fingerprint.MachineCharacteristics.Plugin)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.mime_type_.MergeFrom(from._impl_.mime_type_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_name(from._internal_name());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_description(from._internal_description());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_set_version(from._internal_version());
        }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Fingerprint_MachineCharacteristics_Plugin::CopyFrom(const Fingerprint_MachineCharacteristics_Plugin& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:autofill.risk.Fingerprint.MachineCharacteristics.Plugin)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool Fingerprint_MachineCharacteristics_Plugin::IsInitialized() const
{
    return true;
}

void Fingerprint_MachineCharacteristics_Plugin::InternalSwap(Fingerprint_MachineCharacteristics_Plugin* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.mime_type_.InternalSwap(&other->_impl_.mime_type_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.name_, lhs_arena, &other->_impl_.name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.description_, lhs_arena, &other->_impl_.description_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.version_, lhs_arena, &other->_impl_.version_, rhs_arena);
}

std::string Fingerprint_MachineCharacteristics_Plugin::GetTypeName() const
{
    return "autofill.risk.Fingerprint.MachineCharacteristics.Plugin";
}

// ===================================================================

class Fingerprint_MachineCharacteristics_Cpu::_Internal {
public:
    using HasBits = decltype(std::declval<Fingerprint_MachineCharacteristics_Cpu>()._impl_._has_bits_);
    static void set_has_vendor_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_brand(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

Fingerprint_MachineCharacteristics_Cpu::Fingerprint_MachineCharacteristics_Cpu(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:autofill.risk.Fingerprint.MachineCharacteristics.Cpu)
}
Fingerprint_MachineCharacteristics_Cpu::Fingerprint_MachineCharacteristics_Cpu(const Fingerprint_MachineCharacteristics_Cpu& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    Fingerprint_MachineCharacteristics_Cpu* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.vendor_name_) {},
        decltype(_impl_.brand_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.vendor_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.vendor_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_vendor_name()) {
        _this->_impl_.vendor_name_.Set(from._internal_vendor_name(), _this->GetArenaForAllocation());
    }
    _impl_.brand_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.brand_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_brand()) {
        _this->_impl_.brand_.Set(from._internal_brand(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:autofill.risk.Fingerprint.MachineCharacteristics.Cpu)
}

inline void Fingerprint_MachineCharacteristics_Cpu::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.vendor_name_) {}, decltype(_impl_.brand_) {} };
    _impl_.vendor_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.vendor_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.brand_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.brand_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Fingerprint_MachineCharacteristics_Cpu::~Fingerprint_MachineCharacteristics_Cpu()
{
    // @@protoc_insertion_point(destructor:autofill.risk.Fingerprint.MachineCharacteristics.Cpu)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void Fingerprint_MachineCharacteristics_Cpu::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.vendor_name_.Destroy();
    _impl_.brand_.Destroy();
}

void Fingerprint_MachineCharacteristics_Cpu::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void Fingerprint_MachineCharacteristics_Cpu::Clear()
{
    // @@protoc_insertion_point(message_clear_start:autofill.risk.Fingerprint.MachineCharacteristics.Cpu)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.vendor_name_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.brand_.ClearNonDefaultToEmpty();
        }
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* Fingerprint_MachineCharacteristics_Cpu::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string vendor_name = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_vendor_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string brand = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_brand();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* Fingerprint_MachineCharacteristics_Cpu::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:autofill.risk.Fingerprint.MachineCharacteristics.Cpu)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string vendor_name = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_vendor_name(), target);
    }

    // optional string brand = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_brand(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:autofill.risk.Fingerprint.MachineCharacteristics.Cpu)
    return target;
}

size_t Fingerprint_MachineCharacteristics_Cpu::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:autofill.risk.Fingerprint.MachineCharacteristics.Cpu)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional string vendor_name = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_vendor_name());
        }

        // optional string brand = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_brand());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void Fingerprint_MachineCharacteristics_Cpu::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const Fingerprint_MachineCharacteristics_Cpu*>(&from));
}

void Fingerprint_MachineCharacteristics_Cpu::MergeFrom(const Fingerprint_MachineCharacteristics_Cpu& from)
{
    Fingerprint_MachineCharacteristics_Cpu* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:autofill.risk.Fingerprint.MachineCharacteristics.Cpu)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_vendor_name(from._internal_vendor_name());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_brand(from._internal_brand());
        }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Fingerprint_MachineCharacteristics_Cpu::CopyFrom(const Fingerprint_MachineCharacteristics_Cpu& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:autofill.risk.Fingerprint.MachineCharacteristics.Cpu)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool Fingerprint_MachineCharacteristics_Cpu::IsInitialized() const
{
    return true;
}

void Fingerprint_MachineCharacteristics_Cpu::InternalSwap(Fingerprint_MachineCharacteristics_Cpu* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.vendor_name_, lhs_arena, &other->_impl_.vendor_name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.brand_, lhs_arena, &other->_impl_.brand_, rhs_arena);
}

std::string Fingerprint_MachineCharacteristics_Cpu::GetTypeName() const
{
    return "autofill.risk.Fingerprint.MachineCharacteristics.Cpu";
}

// ===================================================================

class Fingerprint_MachineCharacteristics_Graphics::_Internal {
public:
    using HasBits = decltype(std::declval<Fingerprint_MachineCharacteristics_Graphics>()._impl_._has_bits_);
    static void set_has_vendor_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_device_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_driver_version(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_driver_date(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

Fingerprint_MachineCharacteristics_Graphics::Fingerprint_MachineCharacteristics_Graphics(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:autofill.risk.Fingerprint.MachineCharacteristics.Graphics)
}
Fingerprint_MachineCharacteristics_Graphics::Fingerprint_MachineCharacteristics_Graphics(const Fingerprint_MachineCharacteristics_Graphics& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    Fingerprint_MachineCharacteristics_Graphics* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.driver_version_) {},
        decltype(_impl_.driver_date_) {}, decltype(_impl_.vendor_id_) {}, decltype(_impl_.device_id_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.driver_version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.driver_version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_driver_version()) {
        _this->_impl_.driver_version_.Set(from._internal_driver_version(), _this->GetArenaForAllocation());
    }
    _impl_.driver_date_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.driver_date_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_driver_date()) {
        _this->_impl_.driver_date_.Set(from._internal_driver_date(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.vendor_id_, &from._impl_.vendor_id_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.device_id_) - reinterpret_cast<char*>(&_impl_.vendor_id_)) + sizeof(_impl_.device_id_));
    // @@protoc_insertion_point(copy_constructor:autofill.risk.Fingerprint.MachineCharacteristics.Graphics)
}

inline void Fingerprint_MachineCharacteristics_Graphics::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.driver_version_) {},
        decltype(_impl_.driver_date_) {}, decltype(_impl_.vendor_id_) { 0u }, decltype(_impl_.device_id_) { 0u } };
    _impl_.driver_version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.driver_version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.driver_date_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.driver_date_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Fingerprint_MachineCharacteristics_Graphics::~Fingerprint_MachineCharacteristics_Graphics()
{
    // @@protoc_insertion_point(destructor:autofill.risk.Fingerprint.MachineCharacteristics.Graphics)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void Fingerprint_MachineCharacteristics_Graphics::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.driver_version_.Destroy();
    _impl_.driver_date_.Destroy();
}

void Fingerprint_MachineCharacteristics_Graphics::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void Fingerprint_MachineCharacteristics_Graphics::Clear()
{
    // @@protoc_insertion_point(message_clear_start:autofill.risk.Fingerprint.MachineCharacteristics.Graphics)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.driver_version_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.driver_date_.ClearNonDefaultToEmpty();
        }
    }
    if (cached_has_bits & 0x0000000cu) {
        ::memset(&_impl_.vendor_id_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.device_id_) - reinterpret_cast<char*>(&_impl_.vendor_id_)) + sizeof(_impl_.device_id_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* Fingerprint_MachineCharacteristics_Graphics::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional uint32 vendor_id = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_vendor_id(&has_bits);
                _impl_.vendor_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional uint32 device_id = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_device_id(&has_bits);
                _impl_.device_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string driver_version = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_driver_version();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string driver_date = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                auto str = _internal_mutable_driver_date();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* Fingerprint_MachineCharacteristics_Graphics::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:autofill.risk.Fingerprint.MachineCharacteristics.Graphics)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional uint32 vendor_id = 1;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_vendor_id(), target);
    }

    // optional uint32 device_id = 2;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_device_id(), target);
    }

    // optional string driver_version = 3;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(3, this->_internal_driver_version(), target);
    }

    // optional string driver_date = 4;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(4, this->_internal_driver_date(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:autofill.risk.Fingerprint.MachineCharacteristics.Graphics)
    return target;
}

size_t Fingerprint_MachineCharacteristics_Graphics::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:autofill.risk.Fingerprint.MachineCharacteristics.Graphics)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        // optional string driver_version = 3;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_driver_version());
        }

        // optional string driver_date = 4;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_driver_date());
        }

        // optional uint32 vendor_id = 1;
        if (cached_has_bits & 0x00000004u) {
            total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_vendor_id());
        }

        // optional uint32 device_id = 2;
        if (cached_has_bits & 0x00000008u) {
            total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_device_id());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void Fingerprint_MachineCharacteristics_Graphics::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const Fingerprint_MachineCharacteristics_Graphics*>(&from));
}

void Fingerprint_MachineCharacteristics_Graphics::MergeFrom(const Fingerprint_MachineCharacteristics_Graphics& from)
{
    Fingerprint_MachineCharacteristics_Graphics* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:autofill.risk.Fingerprint.MachineCharacteristics.Graphics)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_driver_version(from._internal_driver_version());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_driver_date(from._internal_driver_date());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.vendor_id_ = from._impl_.vendor_id_;
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.device_id_ = from._impl_.device_id_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Fingerprint_MachineCharacteristics_Graphics::CopyFrom(const Fingerprint_MachineCharacteristics_Graphics& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:autofill.risk.Fingerprint.MachineCharacteristics.Graphics)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool Fingerprint_MachineCharacteristics_Graphics::IsInitialized() const
{
    return true;
}

void Fingerprint_MachineCharacteristics_Graphics::InternalSwap(Fingerprint_MachineCharacteristics_Graphics* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.driver_version_, lhs_arena, &other->_impl_.driver_version_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.driver_date_, lhs_arena, &other->_impl_.driver_date_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(Fingerprint_MachineCharacteristics_Graphics, _impl_.device_id_)
        + sizeof(Fingerprint_MachineCharacteristics_Graphics::_impl_.device_id_)
        - PROTOBUF_FIELD_OFFSET(Fingerprint_MachineCharacteristics_Graphics, _impl_.vendor_id_)>(
        reinterpret_cast<char*>(&_impl_.vendor_id_), reinterpret_cast<char*>(&other->_impl_.vendor_id_));
}

std::string Fingerprint_MachineCharacteristics_Graphics::GetTypeName() const
{
    return "autofill.risk.Fingerprint.MachineCharacteristics.Graphics";
}

// ===================================================================

class Fingerprint_MachineCharacteristics::_Internal {
public:
    using HasBits = decltype(std::declval<Fingerprint_MachineCharacteristics>()._impl_._has_bits_);
    static void set_has_user_and_device_name_hash(HasBits* has_bits)
    {
        (*has_bits)[0] |= 512u;
    }
    static void set_has_operating_system_build(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_browser_install_time_hours(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1024u;
    }
    static void set_has_utc_offset_ms(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2048u;
    }
    static void set_has_browser_language(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_charset(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_screen_count(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4096u;
    }
    static const ::autofill::risk::Fingerprint_Dimension& screen_size(const Fingerprint_MachineCharacteristics* msg);
    static void set_has_screen_size(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
    static void set_has_screen_color_depth(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8192u;
    }
    static const ::autofill::risk::Fingerprint_Dimension& unavailable_screen_size(const Fingerprint_MachineCharacteristics* msg);
    static void set_has_unavailable_screen_size(HasBits* has_bits)
    {
        (*has_bits)[0] |= 64u;
    }
    static void set_has_user_agent(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static const ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu& cpu(const Fingerprint_MachineCharacteristics* msg);
    static void set_has_cpu(HasBits* has_bits)
    {
        (*has_bits)[0] |= 128u;
    }
    static void set_has_ram(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16384u;
    }
    static const ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics& graphics_card(const Fingerprint_MachineCharacteristics* msg);
    static void set_has_graphics_card(HasBits* has_bits)
    {
        (*has_bits)[0] |= 256u;
    }
    static void set_has_browser_build(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static void set_has_browser_feature(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32768u;
    }
};

const ::autofill::risk::Fingerprint_Dimension& Fingerprint_MachineCharacteristics::_Internal::screen_size(const Fingerprint_MachineCharacteristics* msg)
{
    return *msg->_impl_.screen_size_;
}
const ::autofill::risk::Fingerprint_Dimension& Fingerprint_MachineCharacteristics::_Internal::unavailable_screen_size(
    const Fingerprint_MachineCharacteristics* msg)
{
    return *msg->_impl_.unavailable_screen_size_;
}
const ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu& Fingerprint_MachineCharacteristics::_Internal::cpu(
    const Fingerprint_MachineCharacteristics* msg)
{
    return *msg->_impl_.cpu_;
}
const ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics& Fingerprint_MachineCharacteristics::_Internal::graphics_card(
    const Fingerprint_MachineCharacteristics* msg)
{
    return *msg->_impl_.graphics_card_;
}
Fingerprint_MachineCharacteristics::Fingerprint_MachineCharacteristics(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:autofill.risk.Fingerprint.MachineCharacteristics)
}
Fingerprint_MachineCharacteristics::Fingerprint_MachineCharacteristics(const Fingerprint_MachineCharacteristics& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    Fingerprint_MachineCharacteristics* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.font_) { from._impl_.font_ }, decltype(_impl_.plugin_) { from._impl_.plugin_ },
        decltype(_impl_.requested_language_) { from._impl_.requested_language_ }, decltype(_impl_.partition_size_) { from._impl_.partition_size_ },
        decltype(_impl_.operating_system_build_) {}, decltype(_impl_.browser_language_) {}, decltype(_impl_.charset_) {}, decltype(_impl_.user_agent_) {},
        decltype(_impl_.browser_build_) {}, decltype(_impl_.screen_size_) { nullptr }, decltype(_impl_.unavailable_screen_size_) { nullptr },
        decltype(_impl_.cpu_) { nullptr }, decltype(_impl_.graphics_card_) { nullptr }, decltype(_impl_.user_and_device_name_hash_) {},
        decltype(_impl_.browser_install_time_hours_) {}, decltype(_impl_.utc_offset_ms_) {}, decltype(_impl_.screen_count_) {},
        decltype(_impl_.screen_color_depth_) {}, decltype(_impl_.ram_) {}, decltype(_impl_.browser_feature_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.operating_system_build_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.operating_system_build_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_operating_system_build()) {
        _this->_impl_.operating_system_build_.Set(from._internal_operating_system_build(), _this->GetArenaForAllocation());
    }
    _impl_.browser_language_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.browser_language_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_browser_language()) {
        _this->_impl_.browser_language_.Set(from._internal_browser_language(), _this->GetArenaForAllocation());
    }
    _impl_.charset_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.charset_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_charset()) {
        _this->_impl_.charset_.Set(from._internal_charset(), _this->GetArenaForAllocation());
    }
    _impl_.user_agent_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_agent_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_user_agent()) {
        _this->_impl_.user_agent_.Set(from._internal_user_agent(), _this->GetArenaForAllocation());
    }
    _impl_.browser_build_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.browser_build_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_browser_build()) {
        _this->_impl_.browser_build_.Set(from._internal_browser_build(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_screen_size()) {
        _this->_impl_.screen_size_ = new ::autofill::risk::Fingerprint_Dimension(*from._impl_.screen_size_);
    }
    if (from._internal_has_unavailable_screen_size()) {
        _this->_impl_.unavailable_screen_size_ = new ::autofill::risk::Fingerprint_Dimension(*from._impl_.unavailable_screen_size_);
    }
    if (from._internal_has_cpu()) {
        _this->_impl_.cpu_ = new ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu(*from._impl_.cpu_);
    }
    if (from._internal_has_graphics_card()) {
        _this->_impl_.graphics_card_ = new ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics(*from._impl_.graphics_card_);
    }
    ::memcpy(&_impl_.user_and_device_name_hash_, &from._impl_.user_and_device_name_hash_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.browser_feature_) - reinterpret_cast<char*>(&_impl_.user_and_device_name_hash_))
            + sizeof(_impl_.browser_feature_));
    // @@protoc_insertion_point(copy_constructor:autofill.risk.Fingerprint.MachineCharacteristics)
}

inline void Fingerprint_MachineCharacteristics::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.font_) { arena },
        decltype(_impl_.plugin_) { arena }, decltype(_impl_.requested_language_) { arena }, decltype(_impl_.partition_size_) { arena },
        decltype(_impl_.operating_system_build_) {}, decltype(_impl_.browser_language_) {}, decltype(_impl_.charset_) {}, decltype(_impl_.user_agent_) {},
        decltype(_impl_.browser_build_) {}, decltype(_impl_.screen_size_) { nullptr }, decltype(_impl_.unavailable_screen_size_) { nullptr },
        decltype(_impl_.cpu_) { nullptr }, decltype(_impl_.graphics_card_) { nullptr }, decltype(_impl_.user_and_device_name_hash_) { uint64_t { 0u } },
        decltype(_impl_.browser_install_time_hours_) { int64_t { 0 } }, decltype(_impl_.utc_offset_ms_) { int64_t { 0 } }, decltype(_impl_.screen_count_) { 0 },
        decltype(_impl_.screen_color_depth_) { 0 }, decltype(_impl_.ram_) { int64_t { 0 } }, decltype(_impl_.browser_feature_) { 0 } };
    _impl_.operating_system_build_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.operating_system_build_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.browser_language_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.browser_language_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.charset_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.charset_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_agent_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_agent_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.browser_build_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.browser_build_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Fingerprint_MachineCharacteristics::~Fingerprint_MachineCharacteristics()
{
    // @@protoc_insertion_point(destructor:autofill.risk.Fingerprint.MachineCharacteristics)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void Fingerprint_MachineCharacteristics::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.font_.~RepeatedPtrField();
    _impl_.plugin_.~RepeatedPtrField();
    _impl_.requested_language_.~RepeatedPtrField();
    _impl_.partition_size_.~RepeatedField();
    _impl_.operating_system_build_.Destroy();
    _impl_.browser_language_.Destroy();
    _impl_.charset_.Destroy();
    _impl_.user_agent_.Destroy();
    _impl_.browser_build_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.screen_size_;
    if (this != internal_default_instance())
        delete _impl_.unavailable_screen_size_;
    if (this != internal_default_instance())
        delete _impl_.cpu_;
    if (this != internal_default_instance())
        delete _impl_.graphics_card_;
}

void Fingerprint_MachineCharacteristics::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void Fingerprint_MachineCharacteristics::Clear()
{
    // @@protoc_insertion_point(message_clear_start:autofill.risk.Fingerprint.MachineCharacteristics)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.font_.Clear();
    _impl_.plugin_.Clear();
    _impl_.requested_language_.Clear();
    _impl_.partition_size_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.operating_system_build_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.browser_language_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            _impl_.charset_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000008u) {
            _impl_.user_agent_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000010u) {
            _impl_.browser_build_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000020u) {
            GOOGLE_DCHECK(_impl_.screen_size_ != nullptr);
            _impl_.screen_size_->Clear();
        }
        if (cached_has_bits & 0x00000040u) {
            GOOGLE_DCHECK(_impl_.unavailable_screen_size_ != nullptr);
            _impl_.unavailable_screen_size_->Clear();
        }
        if (cached_has_bits & 0x00000080u) {
            GOOGLE_DCHECK(_impl_.cpu_ != nullptr);
            _impl_.cpu_->Clear();
        }
    }
    if (cached_has_bits & 0x00000100u) {
        GOOGLE_DCHECK(_impl_.graphics_card_ != nullptr);
        _impl_.graphics_card_->Clear();
    }
    if (cached_has_bits & 0x0000fe00u) {
        ::memset(&_impl_.user_and_device_name_hash_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.browser_feature_) - reinterpret_cast<char*>(&_impl_.user_and_device_name_hash_))
                + sizeof(_impl_.browser_feature_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* Fingerprint_MachineCharacteristics::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional fixed64 user_and_device_name_hash = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
                _Internal::set_has_user_and_device_name_hash(&has_bits);
                _impl_.user_and_device_name_hash_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
                ptr += sizeof(uint64_t);
            } else
                goto handle_unusual;
            continue;
        // optional string operating_system_build = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_operating_system_build();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 browser_install_time_hours = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_browser_install_time_hours(&has_bits);
                _impl_.browser_install_time_hours_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated string font = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    auto str = _internal_add_font();
                    ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
            } else
                goto handle_unusual;
            continue;
        // repeated .autofill.risk.Fingerprint.MachineCharacteristics.Plugin plugin = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_plugin(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional int64 utc_offset_ms = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
                _Internal::set_has_utc_offset_ms(&has_bits);
                _impl_.utc_offset_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string browser_language = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
                auto str = _internal_mutable_browser_language();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated string requested_language = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    auto str = _internal_add_requested_language();
                    ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional string charset = 9;
        case 9:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
                auto str = _internal_mutable_charset();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 screen_count = 10;
        case 10:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
                _Internal::set_has_screen_count(&has_bits);
                _impl_.screen_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .autofill.risk.Fingerprint.Dimension screen_size = 11;
        case 11:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
                ptr = ctx->ParseMessage(_internal_mutable_screen_size(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 screen_color_depth = 12;
        case 12:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
                _Internal::set_has_screen_color_depth(&has_bits);
                _impl_.screen_color_depth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .autofill.risk.Fingerprint.Dimension unavailable_screen_size = 13;
        case 13:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
                ptr = ctx->ParseMessage(_internal_mutable_unavailable_screen_size(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string user_agent = 14;
        case 14:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
                auto str = _internal_mutable_user_agent();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated int32 partition_size = 15;
        case 15:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    _internal_add_partition_size(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<120>(ptr));
            } else if (static_cast<uint8_t>(tag) == 122) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_partition_size(), ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .autofill.risk.Fingerprint.MachineCharacteristics.Cpu cpu = 16;
        case 16:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
                ptr = ctx->ParseMessage(_internal_mutable_cpu(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 ram = 17;
        case 17:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
                _Internal::set_has_ram(&has_bits);
                _impl_.ram_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .autofill.risk.Fingerprint.MachineCharacteristics.Graphics graphics_card = 18;
        case 18:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
                ptr = ctx->ParseMessage(_internal_mutable_graphics_card(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string browser_build = 19;
        case 19:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
                auto str = _internal_mutable_browser_build();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .autofill.risk.Fingerprint.MachineCharacteristics.BrowserFeature browser_feature = 20;
        case 20:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::autofill::risk::Fingerprint_MachineCharacteristics_BrowserFeature_IsValid(val))) {
                    _internal_set_browser_feature(static_cast<::autofill::risk::Fingerprint_MachineCharacteristics_BrowserFeature>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(20, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* Fingerprint_MachineCharacteristics::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:autofill.risk.Fingerprint.MachineCharacteristics)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional fixed64 user_and_device_name_hash = 1;
    if (cached_has_bits & 0x00000200u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_user_and_device_name_hash(), target);
    }

    // optional string operating_system_build = 2;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_operating_system_build(), target);
    }

    // optional int64 browser_install_time_hours = 3;
    if (cached_has_bits & 0x00000400u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_browser_install_time_hours(), target);
    }

    // repeated string font = 4;
    for (int i = 0, n = this->_internal_font_size(); i < n; i++) {
        const auto& s = this->_internal_font(i);
        target = stream->WriteString(4, s, target);
    }

    // repeated .autofill.risk.Fingerprint.MachineCharacteristics.Plugin plugin = 5;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_plugin_size()); i < n; i++) {
        const auto& repfield = this->_internal_plugin(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
    }

    // optional int64 utc_offset_ms = 6;
    if (cached_has_bits & 0x00000800u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(6, this->_internal_utc_offset_ms(), target);
    }

    // optional string browser_language = 7;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(7, this->_internal_browser_language(), target);
    }

    // repeated string requested_language = 8;
    for (int i = 0, n = this->_internal_requested_language_size(); i < n; i++) {
        const auto& s = this->_internal_requested_language(i);
        target = stream->WriteString(8, s, target);
    }

    // optional string charset = 9;
    if (cached_has_bits & 0x00000004u) {
        target = stream->WriteStringMaybeAliased(9, this->_internal_charset(), target);
    }

    // optional int32 screen_count = 10;
    if (cached_has_bits & 0x00001000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(10, this->_internal_screen_count(), target);
    }

    // optional .autofill.risk.Fingerprint.Dimension screen_size = 11;
    if (cached_has_bits & 0x00000020u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            11, _Internal::screen_size(this), _Internal::screen_size(this).GetCachedSize(), target, stream);
    }

    // optional int32 screen_color_depth = 12;
    if (cached_has_bits & 0x00002000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(12, this->_internal_screen_color_depth(), target);
    }

    // optional .autofill.risk.Fingerprint.Dimension unavailable_screen_size = 13;
    if (cached_has_bits & 0x00000040u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            13, _Internal::unavailable_screen_size(this), _Internal::unavailable_screen_size(this).GetCachedSize(), target, stream);
    }

    // optional string user_agent = 14;
    if (cached_has_bits & 0x00000008u) {
        target = stream->WriteStringMaybeAliased(14, this->_internal_user_agent(), target);
    }

    // repeated int32 partition_size = 15;
    for (int i = 0, n = this->_internal_partition_size_size(); i < n; i++) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(15, this->_internal_partition_size(i), target);
    }

    // optional .autofill.risk.Fingerprint.MachineCharacteristics.Cpu cpu = 16;
    if (cached_has_bits & 0x00000080u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            16, _Internal::cpu(this), _Internal::cpu(this).GetCachedSize(), target, stream);
    }

    // optional int64 ram = 17;
    if (cached_has_bits & 0x00004000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(17, this->_internal_ram(), target);
    }

    // optional .autofill.risk.Fingerprint.MachineCharacteristics.Graphics graphics_card = 18;
    if (cached_has_bits & 0x00000100u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            18, _Internal::graphics_card(this), _Internal::graphics_card(this).GetCachedSize(), target, stream);
    }

    // optional string browser_build = 19;
    if (cached_has_bits & 0x00000010u) {
        target = stream->WriteStringMaybeAliased(19, this->_internal_browser_build(), target);
    }

    // optional .autofill.risk.Fingerprint.MachineCharacteristics.BrowserFeature browser_feature = 20;
    if (cached_has_bits & 0x00008000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(20, this->_internal_browser_feature(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:autofill.risk.Fingerprint.MachineCharacteristics)
    return target;
}

size_t Fingerprint_MachineCharacteristics::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:autofill.risk.Fingerprint.MachineCharacteristics)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated string font = 4;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.font_.size());
    for (int i = 0, n = _impl_.font_.size(); i < n; i++) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(_impl_.font_.Get(i));
    }

    // repeated .autofill.risk.Fingerprint.MachineCharacteristics.Plugin plugin = 5;
    total_size += 1UL * this->_internal_plugin_size();
    for (const auto& msg : this->_impl_.plugin_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // repeated string requested_language = 8;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.requested_language_.size());
    for (int i = 0, n = _impl_.requested_language_.size(); i < n; i++) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(_impl_.requested_language_.Get(i));
    }

    // repeated int32 partition_size = 15;
    {
        size_t data_size = ::_pbi::WireFormatLite::Int32Size(this->_impl_.partition_size_);
        total_size += 1 * ::_pbi::FromIntSize(this->_internal_partition_size_size());
        total_size += data_size;
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        // optional string operating_system_build = 2;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_operating_system_build());
        }

        // optional string browser_language = 7;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_browser_language());
        }

        // optional string charset = 9;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_charset());
        }

        // optional string user_agent = 14;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_user_agent());
        }

        // optional string browser_build = 19;
        if (cached_has_bits & 0x00000010u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_browser_build());
        }

        // optional .autofill.risk.Fingerprint.Dimension screen_size = 11;
        if (cached_has_bits & 0x00000020u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.screen_size_);
        }

        // optional .autofill.risk.Fingerprint.Dimension unavailable_screen_size = 13;
        if (cached_has_bits & 0x00000040u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.unavailable_screen_size_);
        }

        // optional .autofill.risk.Fingerprint.MachineCharacteristics.Cpu cpu = 16;
        if (cached_has_bits & 0x00000080u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.cpu_);
        }
    }
    if (cached_has_bits & 0x0000ff00u) {
        // optional .autofill.risk.Fingerprint.MachineCharacteristics.Graphics graphics_card = 18;
        if (cached_has_bits & 0x00000100u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.graphics_card_);
        }

        // optional fixed64 user_and_device_name_hash = 1;
        if (cached_has_bits & 0x00000200u) {
            total_size += 1 + 8;
        }

        // optional int64 browser_install_time_hours = 3;
        if (cached_has_bits & 0x00000400u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_browser_install_time_hours());
        }

        // optional int64 utc_offset_ms = 6;
        if (cached_has_bits & 0x00000800u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_utc_offset_ms());
        }

        // optional int32 screen_count = 10;
        if (cached_has_bits & 0x00001000u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_screen_count());
        }

        // optional int32 screen_color_depth = 12;
        if (cached_has_bits & 0x00002000u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_screen_color_depth());
        }

        // optional int64 ram = 17;
        if (cached_has_bits & 0x00004000u) {
            total_size += 2 + ::_pbi::WireFormatLite::Int64Size(this->_internal_ram());
        }

        // optional .autofill.risk.Fingerprint.MachineCharacteristics.BrowserFeature browser_feature = 20;
        if (cached_has_bits & 0x00008000u) {
            total_size += 2 + ::_pbi::WireFormatLite::EnumSize(this->_internal_browser_feature());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void Fingerprint_MachineCharacteristics::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const Fingerprint_MachineCharacteristics*>(&from));
}

void Fingerprint_MachineCharacteristics::MergeFrom(const Fingerprint_MachineCharacteristics& from)
{
    Fingerprint_MachineCharacteristics* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:autofill.risk.Fingerprint.MachineCharacteristics)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.font_.MergeFrom(from._impl_.font_);
    _this->_impl_.plugin_.MergeFrom(from._impl_.plugin_);
    _this->_impl_.requested_language_.MergeFrom(from._impl_.requested_language_);
    _this->_impl_.partition_size_.MergeFrom(from._impl_.partition_size_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_operating_system_build(from._internal_operating_system_build());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_browser_language(from._internal_browser_language());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_set_charset(from._internal_charset());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_set_user_agent(from._internal_user_agent());
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_internal_set_browser_build(from._internal_browser_build());
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_internal_mutable_screen_size()->::autofill::risk::Fingerprint_Dimension::MergeFrom(from._internal_screen_size());
        }
        if (cached_has_bits & 0x00000040u) {
            _this->_internal_mutable_unavailable_screen_size()->::autofill::risk::Fingerprint_Dimension::MergeFrom(from._internal_unavailable_screen_size());
        }
        if (cached_has_bits & 0x00000080u) {
            _this->_internal_mutable_cpu()->::autofill::risk::Fingerprint_MachineCharacteristics_Cpu::MergeFrom(from._internal_cpu());
        }
    }
    if (cached_has_bits & 0x0000ff00u) {
        if (cached_has_bits & 0x00000100u) {
            _this->_internal_mutable_graphics_card()->::autofill::risk::Fingerprint_MachineCharacteristics_Graphics::MergeFrom(from._internal_graphics_card());
        }
        if (cached_has_bits & 0x00000200u) {
            _this->_impl_.user_and_device_name_hash_ = from._impl_.user_and_device_name_hash_;
        }
        if (cached_has_bits & 0x00000400u) {
            _this->_impl_.browser_install_time_hours_ = from._impl_.browser_install_time_hours_;
        }
        if (cached_has_bits & 0x00000800u) {
            _this->_impl_.utc_offset_ms_ = from._impl_.utc_offset_ms_;
        }
        if (cached_has_bits & 0x00001000u) {
            _this->_impl_.screen_count_ = from._impl_.screen_count_;
        }
        if (cached_has_bits & 0x00002000u) {
            _this->_impl_.screen_color_depth_ = from._impl_.screen_color_depth_;
        }
        if (cached_has_bits & 0x00004000u) {
            _this->_impl_.ram_ = from._impl_.ram_;
        }
        if (cached_has_bits & 0x00008000u) {
            _this->_impl_.browser_feature_ = from._impl_.browser_feature_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Fingerprint_MachineCharacteristics::CopyFrom(const Fingerprint_MachineCharacteristics& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:autofill.risk.Fingerprint.MachineCharacteristics)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool Fingerprint_MachineCharacteristics::IsInitialized() const
{
    return true;
}

void Fingerprint_MachineCharacteristics::InternalSwap(Fingerprint_MachineCharacteristics* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.font_.InternalSwap(&other->_impl_.font_);
    _impl_.plugin_.InternalSwap(&other->_impl_.plugin_);
    _impl_.requested_language_.InternalSwap(&other->_impl_.requested_language_);
    _impl_.partition_size_.InternalSwap(&other->_impl_.partition_size_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
        &_impl_.operating_system_build_, lhs_arena, &other->_impl_.operating_system_build_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.browser_language_, lhs_arena, &other->_impl_.browser_language_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.charset_, lhs_arena, &other->_impl_.charset_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.user_agent_, lhs_arena, &other->_impl_.user_agent_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.browser_build_, lhs_arena, &other->_impl_.browser_build_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(Fingerprint_MachineCharacteristics, _impl_.browser_feature_)
        + sizeof(Fingerprint_MachineCharacteristics::_impl_.browser_feature_) - PROTOBUF_FIELD_OFFSET(Fingerprint_MachineCharacteristics, _impl_.screen_size_)>(
        reinterpret_cast<char*>(&_impl_.screen_size_), reinterpret_cast<char*>(&other->_impl_.screen_size_));
}

std::string Fingerprint_MachineCharacteristics::GetTypeName() const
{
    return "autofill.risk.Fingerprint.MachineCharacteristics";
}

// ===================================================================

class Fingerprint_TransientState::_Internal {
public:
    using HasBits = decltype(std::declval<Fingerprint_TransientState>()._impl_._has_bits_);
    static const ::autofill::risk::Fingerprint_Dimension& inner_window_size(const Fingerprint_TransientState* msg);
    static void set_has_inner_window_size(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static const ::autofill::risk::Fingerprint_Dimension& outer_window_size(const Fingerprint_TransientState* msg);
    static void set_has_outer_window_size(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

const ::autofill::risk::Fingerprint_Dimension& Fingerprint_TransientState::_Internal::inner_window_size(const Fingerprint_TransientState* msg)
{
    return *msg->_impl_.inner_window_size_;
}
const ::autofill::risk::Fingerprint_Dimension& Fingerprint_TransientState::_Internal::outer_window_size(const Fingerprint_TransientState* msg)
{
    return *msg->_impl_.outer_window_size_;
}
Fingerprint_TransientState::Fingerprint_TransientState(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:autofill.risk.Fingerprint.TransientState)
}
Fingerprint_TransientState::Fingerprint_TransientState(const Fingerprint_TransientState& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    Fingerprint_TransientState* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.inner_window_size_) { nullptr }, decltype(_impl_.outer_window_size_) { nullptr } };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_inner_window_size()) {
        _this->_impl_.inner_window_size_ = new ::autofill::risk::Fingerprint_Dimension(*from._impl_.inner_window_size_);
    }
    if (from._internal_has_outer_window_size()) {
        _this->_impl_.outer_window_size_ = new ::autofill::risk::Fingerprint_Dimension(*from._impl_.outer_window_size_);
    }
    // @@protoc_insertion_point(copy_constructor:autofill.risk.Fingerprint.TransientState)
}

inline void Fingerprint_TransientState::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.inner_window_size_) { nullptr },
        decltype(_impl_.outer_window_size_) { nullptr } };
}

Fingerprint_TransientState::~Fingerprint_TransientState()
{
    // @@protoc_insertion_point(destructor:autofill.risk.Fingerprint.TransientState)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void Fingerprint_TransientState::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (this != internal_default_instance())
        delete _impl_.inner_window_size_;
    if (this != internal_default_instance())
        delete _impl_.outer_window_size_;
}

void Fingerprint_TransientState::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void Fingerprint_TransientState::Clear()
{
    // @@protoc_insertion_point(message_clear_start:autofill.risk.Fingerprint.TransientState)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            GOOGLE_DCHECK(_impl_.inner_window_size_ != nullptr);
            _impl_.inner_window_size_->Clear();
        }
        if (cached_has_bits & 0x00000002u) {
            GOOGLE_DCHECK(_impl_.outer_window_size_ != nullptr);
            _impl_.outer_window_size_->Clear();
        }
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* Fingerprint_TransientState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .autofill.risk.Fingerprint.Dimension inner_window_size = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_inner_window_size(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .autofill.risk.Fingerprint.Dimension outer_window_size = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_outer_window_size(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* Fingerprint_TransientState::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:autofill.risk.Fingerprint.TransientState)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .autofill.risk.Fingerprint.Dimension inner_window_size = 1;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::inner_window_size(this), _Internal::inner_window_size(this).GetCachedSize(), target, stream);
    }

    // optional .autofill.risk.Fingerprint.Dimension outer_window_size = 2;
    if (cached_has_bits & 0x00000002u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::outer_window_size(this), _Internal::outer_window_size(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:autofill.risk.Fingerprint.TransientState)
    return target;
}

size_t Fingerprint_TransientState::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:autofill.risk.Fingerprint.TransientState)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional .autofill.risk.Fingerprint.Dimension inner_window_size = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.inner_window_size_);
        }

        // optional .autofill.risk.Fingerprint.Dimension outer_window_size = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.outer_window_size_);
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void Fingerprint_TransientState::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const Fingerprint_TransientState*>(&from));
}

void Fingerprint_TransientState::MergeFrom(const Fingerprint_TransientState& from)
{
    Fingerprint_TransientState* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:autofill.risk.Fingerprint.TransientState)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_mutable_inner_window_size()->::autofill::risk::Fingerprint_Dimension::MergeFrom(from._internal_inner_window_size());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_mutable_outer_window_size()->::autofill::risk::Fingerprint_Dimension::MergeFrom(from._internal_outer_window_size());
        }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Fingerprint_TransientState::CopyFrom(const Fingerprint_TransientState& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:autofill.risk.Fingerprint.TransientState)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool Fingerprint_TransientState::IsInitialized() const
{
    return true;
}

void Fingerprint_TransientState::InternalSwap(Fingerprint_TransientState* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(Fingerprint_TransientState, _impl_.outer_window_size_)
        + sizeof(Fingerprint_TransientState::_impl_.outer_window_size_) - PROTOBUF_FIELD_OFFSET(Fingerprint_TransientState, _impl_.inner_window_size_)>(
        reinterpret_cast<char*>(&_impl_.inner_window_size_), reinterpret_cast<char*>(&other->_impl_.inner_window_size_));
}

std::string Fingerprint_TransientState::GetTypeName() const
{
    return "autofill.risk.Fingerprint.TransientState";
}

// ===================================================================

class Fingerprint_Performance::_Internal {
public:
    using HasBits = decltype(std::declval<Fingerprint_Performance>()._impl_._has_bits_);
    static void set_has_bandwidth(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_metered(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_network_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

Fingerprint_Performance::Fingerprint_Performance(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:autofill.risk.Fingerprint.Performance)
}
Fingerprint_Performance::Fingerprint_Performance(const Fingerprint_Performance& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    Fingerprint_Performance* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.network_type_) {},
        decltype(_impl_.bandwidth_) {}, decltype(_impl_.metered_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.network_type_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.network_type_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_network_type()) {
        _this->_impl_.network_type_.Set(from._internal_network_type(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.bandwidth_, &from._impl_.bandwidth_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.metered_) - reinterpret_cast<char*>(&_impl_.bandwidth_)) + sizeof(_impl_.metered_));
    // @@protoc_insertion_point(copy_constructor:autofill.risk.Fingerprint.Performance)
}

inline void Fingerprint_Performance::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.network_type_) {},
        decltype(_impl_.bandwidth_) { 0 }, decltype(_impl_.metered_) { false } };
    _impl_.network_type_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.network_type_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Fingerprint_Performance::~Fingerprint_Performance()
{
    // @@protoc_insertion_point(destructor:autofill.risk.Fingerprint.Performance)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void Fingerprint_Performance::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.network_type_.Destroy();
}

void Fingerprint_Performance::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void Fingerprint_Performance::Clear()
{
    // @@protoc_insertion_point(message_clear_start:autofill.risk.Fingerprint.Performance)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.network_type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000006u) {
        ::memset(&_impl_.bandwidth_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.metered_) - reinterpret_cast<char*>(&_impl_.bandwidth_)) + sizeof(_impl_.metered_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* Fingerprint_Performance::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional float bandwidth = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
                _Internal::set_has_bandwidth(&has_bits);
                _impl_.bandwidth_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
                ptr += sizeof(float);
            } else
                goto handle_unusual;
            continue;
        // optional bool metered = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_metered(&has_bits);
                _impl_.metered_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string network_type = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_network_type();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* Fingerprint_Performance::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:autofill.risk.Fingerprint.Performance)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional float bandwidth = 1;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_bandwidth(), target);
    }

    // optional bool metered = 2;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_metered(), target);
    }

    // optional string network_type = 3;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(3, this->_internal_network_type(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:autofill.risk.Fingerprint.Performance)
    return target;
}

size_t Fingerprint_Performance::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:autofill.risk.Fingerprint.Performance)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional string network_type = 3;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_network_type());
        }

        // optional float bandwidth = 1;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + 4;
        }

        // optional bool metered = 2;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + 1;
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void Fingerprint_Performance::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const Fingerprint_Performance*>(&from));
}

void Fingerprint_Performance::MergeFrom(const Fingerprint_Performance& from)
{
    Fingerprint_Performance* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:autofill.risk.Fingerprint.Performance)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_network_type(from._internal_network_type());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.bandwidth_ = from._impl_.bandwidth_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.metered_ = from._impl_.metered_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Fingerprint_Performance::CopyFrom(const Fingerprint_Performance& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:autofill.risk.Fingerprint.Performance)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool Fingerprint_Performance::IsInitialized() const
{
    return true;
}

void Fingerprint_Performance::InternalSwap(Fingerprint_Performance* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.network_type_, lhs_arena, &other->_impl_.network_type_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(Fingerprint_Performance, _impl_.metered_)
        + sizeof(Fingerprint_Performance::_impl_.metered_) - PROTOBUF_FIELD_OFFSET(Fingerprint_Performance, _impl_.bandwidth_)>(
        reinterpret_cast<char*>(&_impl_.bandwidth_), reinterpret_cast<char*>(&other->_impl_.bandwidth_));
}

std::string Fingerprint_Performance::GetTypeName() const
{
    return "autofill.risk.Fingerprint.Performance";
}

// ===================================================================

class Fingerprint_UserCharacteristics_Vector::_Internal {
public:
    using HasBits = decltype(std::declval<Fingerprint_UserCharacteristics_Vector>()._impl_._has_bits_);
    static void set_has_x(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_y(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_z(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
};

Fingerprint_UserCharacteristics_Vector::Fingerprint_UserCharacteristics_Vector(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:autofill.risk.Fingerprint.UserCharacteristics.Vector)
}
Fingerprint_UserCharacteristics_Vector::Fingerprint_UserCharacteristics_Vector(const Fingerprint_UserCharacteristics_Vector& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    Fingerprint_UserCharacteristics_Vector* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.x_) {},
        decltype(_impl_.y_) {}, decltype(_impl_.z_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.x_, &from._impl_.x_, static_cast<size_t>(reinterpret_cast<char*>(&_impl_.z_) - reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.z_));
    // @@protoc_insertion_point(copy_constructor:autofill.risk.Fingerprint.UserCharacteristics.Vector)
}

inline void Fingerprint_UserCharacteristics_Vector::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.x_) { 0 }, decltype(_impl_.y_) { 0 },
        decltype(_impl_.z_) { 0 } };
}

Fingerprint_UserCharacteristics_Vector::~Fingerprint_UserCharacteristics_Vector()
{
    // @@protoc_insertion_point(destructor:autofill.risk.Fingerprint.UserCharacteristics.Vector)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void Fingerprint_UserCharacteristics_Vector::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Fingerprint_UserCharacteristics_Vector::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void Fingerprint_UserCharacteristics_Vector::Clear()
{
    // @@protoc_insertion_point(message_clear_start:autofill.risk.Fingerprint.UserCharacteristics.Vector)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        ::memset(&_impl_.x_, 0, static_cast<size_t>(reinterpret_cast<char*>(&_impl_.z_) - reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.z_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* Fingerprint_UserCharacteristics_Vector::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional int32 x = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_x(&has_bits);
                _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 y = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_y(&has_bits);
                _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 z = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_z(&has_bits);
                _impl_.z_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* Fingerprint_UserCharacteristics_Vector::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:autofill.risk.Fingerprint.UserCharacteristics.Vector)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional int32 x = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_x(), target);
    }

    // optional int32 y = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_y(), target);
    }

    // optional int32 z = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_z(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:autofill.risk.Fingerprint.UserCharacteristics.Vector)
    return target;
}

size_t Fingerprint_UserCharacteristics_Vector::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:autofill.risk.Fingerprint.UserCharacteristics.Vector)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional int32 x = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_x());
        }

        // optional int32 y = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_y());
        }

        // optional int32 z = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_z());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void Fingerprint_UserCharacteristics_Vector::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const Fingerprint_UserCharacteristics_Vector*>(&from));
}

void Fingerprint_UserCharacteristics_Vector::MergeFrom(const Fingerprint_UserCharacteristics_Vector& from)
{
    Fingerprint_UserCharacteristics_Vector* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:autofill.risk.Fingerprint.UserCharacteristics.Vector)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_impl_.x_ = from._impl_.x_;
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.y_ = from._impl_.y_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.z_ = from._impl_.z_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Fingerprint_UserCharacteristics_Vector::CopyFrom(const Fingerprint_UserCharacteristics_Vector& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:autofill.risk.Fingerprint.UserCharacteristics.Vector)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool Fingerprint_UserCharacteristics_Vector::IsInitialized() const
{
    return true;
}

void Fingerprint_UserCharacteristics_Vector::InternalSwap(Fingerprint_UserCharacteristics_Vector* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(Fingerprint_UserCharacteristics_Vector, _impl_.z_)
        + sizeof(Fingerprint_UserCharacteristics_Vector::_impl_.z_) - PROTOBUF_FIELD_OFFSET(Fingerprint_UserCharacteristics_Vector, _impl_.x_)>(
        reinterpret_cast<char*>(&_impl_.x_), reinterpret_cast<char*>(&other->_impl_.x_));
}

std::string Fingerprint_UserCharacteristics_Vector::GetTypeName() const
{
    return "autofill.risk.Fingerprint.UserCharacteristics.Vector";
}

// ===================================================================

class Fingerprint_UserCharacteristics_Location::_Internal {
public:
    using HasBits = decltype(std::declval<Fingerprint_UserCharacteristics_Location>()._impl_._has_bits_);
    static void set_has_altitude(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_latitude(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_longitude(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_accuracy(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_time_in_ms(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
};

Fingerprint_UserCharacteristics_Location::Fingerprint_UserCharacteristics_Location(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:autofill.risk.Fingerprint.UserCharacteristics.Location)
}
Fingerprint_UserCharacteristics_Location::Fingerprint_UserCharacteristics_Location(const Fingerprint_UserCharacteristics_Location& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    Fingerprint_UserCharacteristics_Location* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.altitude_) {},
        decltype(_impl_.latitude_) {}, decltype(_impl_.longitude_) {}, decltype(_impl_.accuracy_) {}, decltype(_impl_.time_in_ms_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.altitude_, &from._impl_.altitude_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.time_in_ms_) - reinterpret_cast<char*>(&_impl_.altitude_)) + sizeof(_impl_.time_in_ms_));
    // @@protoc_insertion_point(copy_constructor:autofill.risk.Fingerprint.UserCharacteristics.Location)
}

inline void Fingerprint_UserCharacteristics_Location::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.altitude_) { 0 },
        decltype(_impl_.latitude_) { 0 }, decltype(_impl_.longitude_) { 0 }, decltype(_impl_.accuracy_) { 0 }, decltype(_impl_.time_in_ms_) { int64_t { 0 } } };
}

Fingerprint_UserCharacteristics_Location::~Fingerprint_UserCharacteristics_Location()
{
    // @@protoc_insertion_point(destructor:autofill.risk.Fingerprint.UserCharacteristics.Location)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void Fingerprint_UserCharacteristics_Location::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Fingerprint_UserCharacteristics_Location::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void Fingerprint_UserCharacteristics_Location::Clear()
{
    // @@protoc_insertion_point(message_clear_start:autofill.risk.Fingerprint.UserCharacteristics.Location)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        ::memset(&_impl_.altitude_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.time_in_ms_) - reinterpret_cast<char*>(&_impl_.altitude_)) + sizeof(_impl_.time_in_ms_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* Fingerprint_UserCharacteristics_Location::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional double altitude = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
                _Internal::set_has_altitude(&has_bits);
                _impl_.altitude_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
                ptr += sizeof(double);
            } else
                goto handle_unusual;
            continue;
        // optional double latitude = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
                _Internal::set_has_latitude(&has_bits);
                _impl_.latitude_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
                ptr += sizeof(double);
            } else
                goto handle_unusual;
            continue;
        // optional double longitude = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
                _Internal::set_has_longitude(&has_bits);
                _impl_.longitude_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
                ptr += sizeof(double);
            } else
                goto handle_unusual;
            continue;
        // optional double accuracy = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
                _Internal::set_has_accuracy(&has_bits);
                _impl_.accuracy_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
                ptr += sizeof(double);
            } else
                goto handle_unusual;
            continue;
        // optional int64 time_in_ms = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
                _Internal::set_has_time_in_ms(&has_bits);
                _impl_.time_in_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* Fingerprint_UserCharacteristics_Location::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:autofill.risk.Fingerprint.UserCharacteristics.Location)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional double altitude = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_altitude(), target);
    }

    // optional double latitude = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_latitude(), target);
    }

    // optional double longitude = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_longitude(), target);
    }

    // optional double accuracy = 4;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_accuracy(), target);
    }

    // optional int64 time_in_ms = 5;
    if (cached_has_bits & 0x00000010u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(5, this->_internal_time_in_ms(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:autofill.risk.Fingerprint.UserCharacteristics.Location)
    return target;
}

size_t Fingerprint_UserCharacteristics_Location::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:autofill.risk.Fingerprint.UserCharacteristics.Location)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        // optional double altitude = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + 8;
        }

        // optional double latitude = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + 8;
        }

        // optional double longitude = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + 8;
        }

        // optional double accuracy = 4;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + 8;
        }

        // optional int64 time_in_ms = 5;
        if (cached_has_bits & 0x00000010u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_time_in_ms());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void Fingerprint_UserCharacteristics_Location::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const Fingerprint_UserCharacteristics_Location*>(&from));
}

void Fingerprint_UserCharacteristics_Location::MergeFrom(const Fingerprint_UserCharacteristics_Location& from)
{
    Fingerprint_UserCharacteristics_Location* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:autofill.risk.Fingerprint.UserCharacteristics.Location)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_impl_.altitude_ = from._impl_.altitude_;
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.latitude_ = from._impl_.latitude_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.longitude_ = from._impl_.longitude_;
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.accuracy_ = from._impl_.accuracy_;
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_impl_.time_in_ms_ = from._impl_.time_in_ms_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Fingerprint_UserCharacteristics_Location::CopyFrom(const Fingerprint_UserCharacteristics_Location& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:autofill.risk.Fingerprint.UserCharacteristics.Location)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool Fingerprint_UserCharacteristics_Location::IsInitialized() const
{
    return true;
}

void Fingerprint_UserCharacteristics_Location::InternalSwap(Fingerprint_UserCharacteristics_Location* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(Fingerprint_UserCharacteristics_Location, _impl_.time_in_ms_)
        + sizeof(Fingerprint_UserCharacteristics_Location::_impl_.time_in_ms_)
        - PROTOBUF_FIELD_OFFSET(Fingerprint_UserCharacteristics_Location, _impl_.altitude_)>(
        reinterpret_cast<char*>(&_impl_.altitude_), reinterpret_cast<char*>(&other->_impl_.altitude_));
}

std::string Fingerprint_UserCharacteristics_Location::GetTypeName() const
{
    return "autofill.risk.Fingerprint.UserCharacteristics.Location";
}

// ===================================================================

class Fingerprint_UserCharacteristics::_Internal {
public:
    using HasBits = decltype(std::declval<Fingerprint_UserCharacteristics>()._impl_._has_bits_);
    static void set_has_force(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_touch_width(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static void set_has_touch_height(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
    static void set_has_touch_rotation(HasBits* has_bits)
    {
        (*has_bits)[0] |= 64u;
    }
    static const ::autofill::risk::Fingerprint_UserCharacteristics_Vector& device_orientation(const Fingerprint_UserCharacteristics* msg);
    static void set_has_device_orientation(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static const ::autofill::risk::Fingerprint_UserCharacteristics_Vector& device_acceleration(const Fingerprint_UserCharacteristics* msg);
    static void set_has_device_acceleration(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static const ::autofill::risk::Fingerprint_UserCharacteristics_Location& location(const Fingerprint_UserCharacteristics* msg);
    static void set_has_location(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
};

const ::autofill::risk::Fingerprint_UserCharacteristics_Vector& Fingerprint_UserCharacteristics::_Internal::device_orientation(
    const Fingerprint_UserCharacteristics* msg)
{
    return *msg->_impl_.device_orientation_;
}
const ::autofill::risk::Fingerprint_UserCharacteristics_Vector& Fingerprint_UserCharacteristics::_Internal::device_acceleration(
    const Fingerprint_UserCharacteristics* msg)
{
    return *msg->_impl_.device_acceleration_;
}
const ::autofill::risk::Fingerprint_UserCharacteristics_Location& Fingerprint_UserCharacteristics::_Internal::location(
    const Fingerprint_UserCharacteristics* msg)
{
    return *msg->_impl_.location_;
}
Fingerprint_UserCharacteristics::Fingerprint_UserCharacteristics(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:autofill.risk.Fingerprint.UserCharacteristics)
}
Fingerprint_UserCharacteristics::Fingerprint_UserCharacteristics(const Fingerprint_UserCharacteristics& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    Fingerprint_UserCharacteristics* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.device_orientation_) { nullptr }, decltype(_impl_.device_acceleration_) { nullptr }, decltype(_impl_.location_) { nullptr },
        decltype(_impl_.force_) {}, decltype(_impl_.touch_width_) {}, decltype(_impl_.touch_height_) {}, decltype(_impl_.touch_rotation_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_device_orientation()) {
        _this->_impl_.device_orientation_ = new ::autofill::risk::Fingerprint_UserCharacteristics_Vector(*from._impl_.device_orientation_);
    }
    if (from._internal_has_device_acceleration()) {
        _this->_impl_.device_acceleration_ = new ::autofill::risk::Fingerprint_UserCharacteristics_Vector(*from._impl_.device_acceleration_);
    }
    if (from._internal_has_location()) {
        _this->_impl_.location_ = new ::autofill::risk::Fingerprint_UserCharacteristics_Location(*from._impl_.location_);
    }
    ::memcpy(&_impl_.force_, &from._impl_.force_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.touch_rotation_) - reinterpret_cast<char*>(&_impl_.force_)) + sizeof(_impl_.touch_rotation_));
    // @@protoc_insertion_point(copy_constructor:autofill.risk.Fingerprint.UserCharacteristics)
}

inline void Fingerprint_UserCharacteristics::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.device_orientation_) { nullptr },
        decltype(_impl_.device_acceleration_) { nullptr }, decltype(_impl_.location_) { nullptr }, decltype(_impl_.force_) { 0 },
        decltype(_impl_.touch_width_) { 0 }, decltype(_impl_.touch_height_) { 0 }, decltype(_impl_.touch_rotation_) { 0 } };
}

Fingerprint_UserCharacteristics::~Fingerprint_UserCharacteristics()
{
    // @@protoc_insertion_point(destructor:autofill.risk.Fingerprint.UserCharacteristics)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void Fingerprint_UserCharacteristics::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (this != internal_default_instance())
        delete _impl_.device_orientation_;
    if (this != internal_default_instance())
        delete _impl_.device_acceleration_;
    if (this != internal_default_instance())
        delete _impl_.location_;
}

void Fingerprint_UserCharacteristics::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void Fingerprint_UserCharacteristics::Clear()
{
    // @@protoc_insertion_point(message_clear_start:autofill.risk.Fingerprint.UserCharacteristics)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            GOOGLE_DCHECK(_impl_.device_orientation_ != nullptr);
            _impl_.device_orientation_->Clear();
        }
        if (cached_has_bits & 0x00000002u) {
            GOOGLE_DCHECK(_impl_.device_acceleration_ != nullptr);
            _impl_.device_acceleration_->Clear();
        }
        if (cached_has_bits & 0x00000004u) {
            GOOGLE_DCHECK(_impl_.location_ != nullptr);
            _impl_.location_->Clear();
        }
    }
    if (cached_has_bits & 0x00000078u) {
        ::memset(&_impl_.force_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.touch_rotation_) - reinterpret_cast<char*>(&_impl_.force_)) + sizeof(_impl_.touch_rotation_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* Fingerprint_UserCharacteristics::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional float force = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
                _Internal::set_has_force(&has_bits);
                _impl_.force_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
                ptr += sizeof(float);
            } else
                goto handle_unusual;
            continue;
        // optional float touch_width = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
                _Internal::set_has_touch_width(&has_bits);
                _impl_.touch_width_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
                ptr += sizeof(float);
            } else
                goto handle_unusual;
            continue;
        // optional float touch_height = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
                _Internal::set_has_touch_height(&has_bits);
                _impl_.touch_height_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
                ptr += sizeof(float);
            } else
                goto handle_unusual;
            continue;
        // optional int32 touch_rotation = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _Internal::set_has_touch_rotation(&has_bits);
                _impl_.touch_rotation_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .autofill.risk.Fingerprint.UserCharacteristics.Vector device_orientation = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                ptr = ctx->ParseMessage(_internal_mutable_device_orientation(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .autofill.risk.Fingerprint.UserCharacteristics.Vector device_acceleration = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
                ptr = ctx->ParseMessage(_internal_mutable_device_acceleration(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .autofill.risk.Fingerprint.UserCharacteristics.Location location = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
                ptr = ctx->ParseMessage(_internal_mutable_location(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* Fingerprint_UserCharacteristics::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:autofill.risk.Fingerprint.UserCharacteristics)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional float force = 1;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_force(), target);
    }

    // optional float touch_width = 2;
    if (cached_has_bits & 0x00000010u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_touch_width(), target);
    }

    // optional float touch_height = 3;
    if (cached_has_bits & 0x00000020u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_touch_height(), target);
    }

    // optional int32 touch_rotation = 4;
    if (cached_has_bits & 0x00000040u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_touch_rotation(), target);
    }

    // optional .autofill.risk.Fingerprint.UserCharacteristics.Vector device_orientation = 5;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            5, _Internal::device_orientation(this), _Internal::device_orientation(this).GetCachedSize(), target, stream);
    }

    // optional .autofill.risk.Fingerprint.UserCharacteristics.Vector device_acceleration = 6;
    if (cached_has_bits & 0x00000002u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            6, _Internal::device_acceleration(this), _Internal::device_acceleration(this).GetCachedSize(), target, stream);
    }

    // optional .autofill.risk.Fingerprint.UserCharacteristics.Location location = 7;
    if (cached_has_bits & 0x00000004u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            7, _Internal::location(this), _Internal::location(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:autofill.risk.Fingerprint.UserCharacteristics)
    return target;
}

size_t Fingerprint_UserCharacteristics::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:autofill.risk.Fingerprint.UserCharacteristics)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000007fu) {
        // optional .autofill.risk.Fingerprint.UserCharacteristics.Vector device_orientation = 5;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.device_orientation_);
        }

        // optional .autofill.risk.Fingerprint.UserCharacteristics.Vector device_acceleration = 6;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.device_acceleration_);
        }

        // optional .autofill.risk.Fingerprint.UserCharacteristics.Location location = 7;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.location_);
        }

        // optional float force = 1;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + 4;
        }

        // optional float touch_width = 2;
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + 4;
        }

        // optional float touch_height = 3;
        if (cached_has_bits & 0x00000020u) {
            total_size += 1 + 4;
        }

        // optional int32 touch_rotation = 4;
        if (cached_has_bits & 0x00000040u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_touch_rotation());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void Fingerprint_UserCharacteristics::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const Fingerprint_UserCharacteristics*>(&from));
}

void Fingerprint_UserCharacteristics::MergeFrom(const Fingerprint_UserCharacteristics& from)
{
    Fingerprint_UserCharacteristics* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:autofill.risk.Fingerprint.UserCharacteristics)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000007fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_mutable_device_orientation()->::autofill::risk::Fingerprint_UserCharacteristics_Vector::MergeFrom(
                from._internal_device_orientation());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_mutable_device_acceleration()->::autofill::risk::Fingerprint_UserCharacteristics_Vector::MergeFrom(
                from._internal_device_acceleration());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_mutable_location()->::autofill::risk::Fingerprint_UserCharacteristics_Location::MergeFrom(from._internal_location());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.force_ = from._impl_.force_;
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_impl_.touch_width_ = from._impl_.touch_width_;
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_impl_.touch_height_ = from._impl_.touch_height_;
        }
        if (cached_has_bits & 0x00000040u) {
            _this->_impl_.touch_rotation_ = from._impl_.touch_rotation_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Fingerprint_UserCharacteristics::CopyFrom(const Fingerprint_UserCharacteristics& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:autofill.risk.Fingerprint.UserCharacteristics)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool Fingerprint_UserCharacteristics::IsInitialized() const
{
    return true;
}

void Fingerprint_UserCharacteristics::InternalSwap(Fingerprint_UserCharacteristics* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(Fingerprint_UserCharacteristics, _impl_.touch_rotation_)
        + sizeof(Fingerprint_UserCharacteristics::_impl_.touch_rotation_) - PROTOBUF_FIELD_OFFSET(Fingerprint_UserCharacteristics, _impl_.device_orientation_)>(
        reinterpret_cast<char*>(&_impl_.device_orientation_), reinterpret_cast<char*>(&other->_impl_.device_orientation_));
}

std::string Fingerprint_UserCharacteristics::GetTypeName() const
{
    return "autofill.risk.Fingerprint.UserCharacteristics";
}

// ===================================================================

class Fingerprint_Metadata::_Internal {
public:
    using HasBits = decltype(std::declval<Fingerprint_Metadata>()._impl_._has_bits_);
    static void set_has_timestamp_ms(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_obfuscated_gaia_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_fingerprinter_version(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
};

Fingerprint_Metadata::Fingerprint_Metadata(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:autofill.risk.Fingerprint.Metadata)
}
Fingerprint_Metadata::Fingerprint_Metadata(const Fingerprint_Metadata& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    Fingerprint_Metadata* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.timestamp_ms_) {},
        decltype(_impl_.obfuscated_gaia_id_) {}, decltype(_impl_.fingerprinter_version_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.timestamp_ms_, &from._impl_.timestamp_ms_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.fingerprinter_version_) - reinterpret_cast<char*>(&_impl_.timestamp_ms_))
            + sizeof(_impl_.fingerprinter_version_));
    // @@protoc_insertion_point(copy_constructor:autofill.risk.Fingerprint.Metadata)
}

inline void Fingerprint_Metadata::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.timestamp_ms_) { int64_t { 0 } },
        decltype(_impl_.obfuscated_gaia_id_) { uint64_t { 0u } }, decltype(_impl_.fingerprinter_version_) { 0 } };
}

Fingerprint_Metadata::~Fingerprint_Metadata()
{
    // @@protoc_insertion_point(destructor:autofill.risk.Fingerprint.Metadata)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void Fingerprint_Metadata::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Fingerprint_Metadata::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void Fingerprint_Metadata::Clear()
{
    // @@protoc_insertion_point(message_clear_start:autofill.risk.Fingerprint.Metadata)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        ::memset(&_impl_.timestamp_ms_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.fingerprinter_version_) - reinterpret_cast<char*>(&_impl_.timestamp_ms_))
                + sizeof(_impl_.fingerprinter_version_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* Fingerprint_Metadata::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional int64 timestamp_ms = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_timestamp_ms(&has_bits);
                _impl_.timestamp_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional uint64 obfuscated_gaia_id = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_obfuscated_gaia_id(&has_bits);
                _impl_.obfuscated_gaia_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 fingerprinter_version = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_fingerprinter_version(&has_bits);
                _impl_.fingerprinter_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* Fingerprint_Metadata::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:autofill.risk.Fingerprint.Metadata)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional int64 timestamp_ms = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_timestamp_ms(), target);
    }

    // optional uint64 obfuscated_gaia_id = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_obfuscated_gaia_id(), target);
    }

    // optional int32 fingerprinter_version = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_fingerprinter_version(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:autofill.risk.Fingerprint.Metadata)
    return target;
}

size_t Fingerprint_Metadata::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:autofill.risk.Fingerprint.Metadata)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional int64 timestamp_ms = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_timestamp_ms());
        }

        // optional uint64 obfuscated_gaia_id = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_obfuscated_gaia_id());
        }

        // optional int32 fingerprinter_version = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_fingerprinter_version());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void Fingerprint_Metadata::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const Fingerprint_Metadata*>(&from));
}

void Fingerprint_Metadata::MergeFrom(const Fingerprint_Metadata& from)
{
    Fingerprint_Metadata* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:autofill.risk.Fingerprint.Metadata)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_impl_.timestamp_ms_ = from._impl_.timestamp_ms_;
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.obfuscated_gaia_id_ = from._impl_.obfuscated_gaia_id_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.fingerprinter_version_ = from._impl_.fingerprinter_version_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Fingerprint_Metadata::CopyFrom(const Fingerprint_Metadata& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:autofill.risk.Fingerprint.Metadata)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool Fingerprint_Metadata::IsInitialized() const
{
    return true;
}

void Fingerprint_Metadata::InternalSwap(Fingerprint_Metadata* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(Fingerprint_Metadata, _impl_.fingerprinter_version_)
        + sizeof(Fingerprint_Metadata::_impl_.fingerprinter_version_) - PROTOBUF_FIELD_OFFSET(Fingerprint_Metadata, _impl_.timestamp_ms_)>(
        reinterpret_cast<char*>(&_impl_.timestamp_ms_), reinterpret_cast<char*>(&other->_impl_.timestamp_ms_));
}

std::string Fingerprint_Metadata::GetTypeName() const
{
    return "autofill.risk.Fingerprint.Metadata";
}

// ===================================================================

class Fingerprint::_Internal {
public:
    using HasBits = decltype(std::declval<Fingerprint>()._impl_._has_bits_);
    static const ::autofill::risk::Fingerprint_MachineCharacteristics& machine_characteristics(const Fingerprint* msg);
    static void set_has_machine_characteristics(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static const ::autofill::risk::Fingerprint_Performance& performance(const Fingerprint* msg);
    static void set_has_performance(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static const ::autofill::risk::Fingerprint_UserCharacteristics& user_characteristics(const Fingerprint* msg);
    static void set_has_user_characteristics(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static const ::autofill::risk::Fingerprint_TransientState& transient_state(const Fingerprint* msg);
    static void set_has_transient_state(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static const ::autofill::risk::Fingerprint_Metadata& metadata(const Fingerprint* msg);
    static void set_has_metadata(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
};

const ::autofill::risk::Fingerprint_MachineCharacteristics& Fingerprint::_Internal::machine_characteristics(const Fingerprint* msg)
{
    return *msg->_impl_.machine_characteristics_;
}
const ::autofill::risk::Fingerprint_Performance& Fingerprint::_Internal::performance(const Fingerprint* msg)
{
    return *msg->_impl_.performance_;
}
const ::autofill::risk::Fingerprint_UserCharacteristics& Fingerprint::_Internal::user_characteristics(const Fingerprint* msg)
{
    return *msg->_impl_.user_characteristics_;
}
const ::autofill::risk::Fingerprint_TransientState& Fingerprint::_Internal::transient_state(const Fingerprint* msg)
{
    return *msg->_impl_.transient_state_;
}
const ::autofill::risk::Fingerprint_Metadata& Fingerprint::_Internal::metadata(const Fingerprint* msg)
{
    return *msg->_impl_.metadata_;
}
Fingerprint::Fingerprint(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:autofill.risk.Fingerprint)
}
Fingerprint::Fingerprint(const Fingerprint& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    Fingerprint* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.machine_characteristics_) { nullptr }, decltype(_impl_.performance_) { nullptr }, decltype(_impl_.user_characteristics_) { nullptr },
        decltype(_impl_.transient_state_) { nullptr }, decltype(_impl_.metadata_) { nullptr } };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_machine_characteristics()) {
        _this->_impl_.machine_characteristics_ = new ::autofill::risk::Fingerprint_MachineCharacteristics(*from._impl_.machine_characteristics_);
    }
    if (from._internal_has_performance()) {
        _this->_impl_.performance_ = new ::autofill::risk::Fingerprint_Performance(*from._impl_.performance_);
    }
    if (from._internal_has_user_characteristics()) {
        _this->_impl_.user_characteristics_ = new ::autofill::risk::Fingerprint_UserCharacteristics(*from._impl_.user_characteristics_);
    }
    if (from._internal_has_transient_state()) {
        _this->_impl_.transient_state_ = new ::autofill::risk::Fingerprint_TransientState(*from._impl_.transient_state_);
    }
    if (from._internal_has_metadata()) {
        _this->_impl_.metadata_ = new ::autofill::risk::Fingerprint_Metadata(*from._impl_.metadata_);
    }
    // @@protoc_insertion_point(copy_constructor:autofill.risk.Fingerprint)
}

inline void Fingerprint::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.machine_characteristics_) { nullptr },
        decltype(_impl_.performance_) { nullptr }, decltype(_impl_.user_characteristics_) { nullptr }, decltype(_impl_.transient_state_) { nullptr },
        decltype(_impl_.metadata_) { nullptr } };
}

Fingerprint::~Fingerprint()
{
    // @@protoc_insertion_point(destructor:autofill.risk.Fingerprint)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void Fingerprint::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (this != internal_default_instance())
        delete _impl_.machine_characteristics_;
    if (this != internal_default_instance())
        delete _impl_.performance_;
    if (this != internal_default_instance())
        delete _impl_.user_characteristics_;
    if (this != internal_default_instance())
        delete _impl_.transient_state_;
    if (this != internal_default_instance())
        delete _impl_.metadata_;
}

void Fingerprint::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void Fingerprint::Clear()
{
    // @@protoc_insertion_point(message_clear_start:autofill.risk.Fingerprint)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        if (cached_has_bits & 0x00000001u) {
            GOOGLE_DCHECK(_impl_.machine_characteristics_ != nullptr);
            _impl_.machine_characteristics_->Clear();
        }
        if (cached_has_bits & 0x00000002u) {
            GOOGLE_DCHECK(_impl_.performance_ != nullptr);
            _impl_.performance_->Clear();
        }
        if (cached_has_bits & 0x00000004u) {
            GOOGLE_DCHECK(_impl_.user_characteristics_ != nullptr);
            _impl_.user_characteristics_->Clear();
        }
        if (cached_has_bits & 0x00000008u) {
            GOOGLE_DCHECK(_impl_.transient_state_ != nullptr);
            _impl_.transient_state_->Clear();
        }
        if (cached_has_bits & 0x00000010u) {
            GOOGLE_DCHECK(_impl_.metadata_ != nullptr);
            _impl_.metadata_->Clear();
        }
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* Fingerprint::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .autofill.risk.Fingerprint.MachineCharacteristics machine_characteristics = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_machine_characteristics(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .autofill.risk.Fingerprint.Performance performance = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_performance(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .autofill.risk.Fingerprint.UserCharacteristics user_characteristics = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr = ctx->ParseMessage(_internal_mutable_user_characteristics(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .autofill.risk.Fingerprint.TransientState transient_state = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr = ctx->ParseMessage(_internal_mutable_transient_state(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .autofill.risk.Fingerprint.Metadata metadata = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                ptr = ctx->ParseMessage(_internal_mutable_metadata(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* Fingerprint::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:autofill.risk.Fingerprint)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .autofill.risk.Fingerprint.MachineCharacteristics machine_characteristics = 1;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::machine_characteristics(this), _Internal::machine_characteristics(this).GetCachedSize(), target, stream);
    }

    // optional .autofill.risk.Fingerprint.Performance performance = 2;
    if (cached_has_bits & 0x00000002u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::performance(this), _Internal::performance(this).GetCachedSize(), target, stream);
    }

    // optional .autofill.risk.Fingerprint.UserCharacteristics user_characteristics = 3;
    if (cached_has_bits & 0x00000004u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            3, _Internal::user_characteristics(this), _Internal::user_characteristics(this).GetCachedSize(), target, stream);
    }

    // optional .autofill.risk.Fingerprint.TransientState transient_state = 4;
    if (cached_has_bits & 0x00000008u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            4, _Internal::transient_state(this), _Internal::transient_state(this).GetCachedSize(), target, stream);
    }

    // optional .autofill.risk.Fingerprint.Metadata metadata = 5;
    if (cached_has_bits & 0x00000010u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            5, _Internal::metadata(this), _Internal::metadata(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:autofill.risk.Fingerprint)
    return target;
}

size_t Fingerprint::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:autofill.risk.Fingerprint)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        // optional .autofill.risk.Fingerprint.MachineCharacteristics machine_characteristics = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.machine_characteristics_);
        }

        // optional .autofill.risk.Fingerprint.Performance performance = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.performance_);
        }

        // optional .autofill.risk.Fingerprint.UserCharacteristics user_characteristics = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.user_characteristics_);
        }

        // optional .autofill.risk.Fingerprint.TransientState transient_state = 4;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.transient_state_);
        }

        // optional .autofill.risk.Fingerprint.Metadata metadata = 5;
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.metadata_);
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void Fingerprint::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const Fingerprint*>(&from));
}

void Fingerprint::MergeFrom(const Fingerprint& from)
{
    Fingerprint* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:autofill.risk.Fingerprint)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_mutable_machine_characteristics()->::autofill::risk::Fingerprint_MachineCharacteristics::MergeFrom(
                from._internal_machine_characteristics());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_mutable_performance()->::autofill::risk::Fingerprint_Performance::MergeFrom(from._internal_performance());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_mutable_user_characteristics()->::autofill::risk::Fingerprint_UserCharacteristics::MergeFrom(
                from._internal_user_characteristics());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_mutable_transient_state()->::autofill::risk::Fingerprint_TransientState::MergeFrom(from._internal_transient_state());
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_internal_mutable_metadata()->::autofill::risk::Fingerprint_Metadata::MergeFrom(from._internal_metadata());
        }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Fingerprint::CopyFrom(const Fingerprint& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:autofill.risk.Fingerprint)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool Fingerprint::IsInitialized() const
{
    return true;
}

void Fingerprint::InternalSwap(Fingerprint* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(Fingerprint, _impl_.metadata_) + sizeof(Fingerprint::_impl_.metadata_)
        - PROTOBUF_FIELD_OFFSET(Fingerprint, _impl_.machine_characteristics_)>(
        reinterpret_cast<char*>(&_impl_.machine_characteristics_), reinterpret_cast<char*>(&other->_impl_.machine_characteristics_));
}

std::string Fingerprint::GetTypeName() const
{
    return "autofill.risk.Fingerprint";
}

// @@protoc_insertion_point(namespace_scope)
} // namespace risk
} // namespace autofill
PROTOBUF_NAMESPACE_OPEN
template <> PROTOBUF_NOINLINE ::autofill::risk::Fingerprint_Dimension* Arena::CreateMaybeMessage<::autofill::risk::Fingerprint_Dimension>(Arena* arena)
{
    return Arena::CreateMessageInternal<::autofill::risk::Fingerprint_Dimension>(arena);
}
template <>
PROTOBUF_NOINLINE ::autofill::risk::Fingerprint_MachineCharacteristics_Plugin*
Arena::CreateMaybeMessage<::autofill::risk::Fingerprint_MachineCharacteristics_Plugin>(Arena* arena)
{
    return Arena::CreateMessageInternal<::autofill::risk::Fingerprint_MachineCharacteristics_Plugin>(arena);
}
template <>
PROTOBUF_NOINLINE ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu* Arena::CreateMaybeMessage<::autofill::risk::Fingerprint_MachineCharacteristics_Cpu>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<::autofill::risk::Fingerprint_MachineCharacteristics_Cpu>(arena);
}
template <>
PROTOBUF_NOINLINE ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics*
Arena::CreateMaybeMessage<::autofill::risk::Fingerprint_MachineCharacteristics_Graphics>(Arena* arena)
{
    return Arena::CreateMessageInternal<::autofill::risk::Fingerprint_MachineCharacteristics_Graphics>(arena);
}
template <>
PROTOBUF_NOINLINE ::autofill::risk::Fingerprint_MachineCharacteristics* Arena::CreateMaybeMessage<::autofill::risk::Fingerprint_MachineCharacteristics>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<::autofill::risk::Fingerprint_MachineCharacteristics>(arena);
}
template <>
PROTOBUF_NOINLINE ::autofill::risk::Fingerprint_TransientState* Arena::CreateMaybeMessage<::autofill::risk::Fingerprint_TransientState>(Arena* arena)
{
    return Arena::CreateMessageInternal<::autofill::risk::Fingerprint_TransientState>(arena);
}
template <> PROTOBUF_NOINLINE ::autofill::risk::Fingerprint_Performance* Arena::CreateMaybeMessage<::autofill::risk::Fingerprint_Performance>(Arena* arena)
{
    return Arena::CreateMessageInternal<::autofill::risk::Fingerprint_Performance>(arena);
}
template <>
PROTOBUF_NOINLINE ::autofill::risk::Fingerprint_UserCharacteristics_Vector* Arena::CreateMaybeMessage<::autofill::risk::Fingerprint_UserCharacteristics_Vector>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<::autofill::risk::Fingerprint_UserCharacteristics_Vector>(arena);
}
template <>
PROTOBUF_NOINLINE ::autofill::risk::Fingerprint_UserCharacteristics_Location*
Arena::CreateMaybeMessage<::autofill::risk::Fingerprint_UserCharacteristics_Location>(Arena* arena)
{
    return Arena::CreateMessageInternal<::autofill::risk::Fingerprint_UserCharacteristics_Location>(arena);
}
template <>
PROTOBUF_NOINLINE ::autofill::risk::Fingerprint_UserCharacteristics* Arena::CreateMaybeMessage<::autofill::risk::Fingerprint_UserCharacteristics>(Arena* arena)
{
    return Arena::CreateMessageInternal<::autofill::risk::Fingerprint_UserCharacteristics>(arena);
}
template <> PROTOBUF_NOINLINE ::autofill::risk::Fingerprint_Metadata* Arena::CreateMaybeMessage<::autofill::risk::Fingerprint_Metadata>(Arena* arena)
{
    return Arena::CreateMessageInternal<::autofill::risk::Fingerprint_Metadata>(arena);
}
template <> PROTOBUF_NOINLINE ::autofill::risk::Fingerprint* Arena::CreateMaybeMessage<::autofill::risk::Fingerprint>(Arena* arena)
{
    return Arena::CreateMessageInternal<::autofill::risk::Fingerprint>(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
