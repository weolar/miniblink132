// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: fingerprint.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_fingerprint_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_fingerprint_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h> // IWYU pragma: export
#include <google/protobuf/extension_set.h> // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_fingerprint_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
} // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_fingerprint_2eproto {
    static const uint32_t offsets[];
};
namespace autofill {
namespace risk {
class Fingerprint;
struct FingerprintDefaultTypeInternal;
extern FingerprintDefaultTypeInternal _Fingerprint_default_instance_;
class Fingerprint_Dimension;
struct Fingerprint_DimensionDefaultTypeInternal;
extern Fingerprint_DimensionDefaultTypeInternal _Fingerprint_Dimension_default_instance_;
class Fingerprint_MachineCharacteristics;
struct Fingerprint_MachineCharacteristicsDefaultTypeInternal;
extern Fingerprint_MachineCharacteristicsDefaultTypeInternal _Fingerprint_MachineCharacteristics_default_instance_;
class Fingerprint_MachineCharacteristics_Cpu;
struct Fingerprint_MachineCharacteristics_CpuDefaultTypeInternal;
extern Fingerprint_MachineCharacteristics_CpuDefaultTypeInternal _Fingerprint_MachineCharacteristics_Cpu_default_instance_;
class Fingerprint_MachineCharacteristics_Graphics;
struct Fingerprint_MachineCharacteristics_GraphicsDefaultTypeInternal;
extern Fingerprint_MachineCharacteristics_GraphicsDefaultTypeInternal _Fingerprint_MachineCharacteristics_Graphics_default_instance_;
class Fingerprint_MachineCharacteristics_Plugin;
struct Fingerprint_MachineCharacteristics_PluginDefaultTypeInternal;
extern Fingerprint_MachineCharacteristics_PluginDefaultTypeInternal _Fingerprint_MachineCharacteristics_Plugin_default_instance_;
class Fingerprint_Metadata;
struct Fingerprint_MetadataDefaultTypeInternal;
extern Fingerprint_MetadataDefaultTypeInternal _Fingerprint_Metadata_default_instance_;
class Fingerprint_Performance;
struct Fingerprint_PerformanceDefaultTypeInternal;
extern Fingerprint_PerformanceDefaultTypeInternal _Fingerprint_Performance_default_instance_;
class Fingerprint_TransientState;
struct Fingerprint_TransientStateDefaultTypeInternal;
extern Fingerprint_TransientStateDefaultTypeInternal _Fingerprint_TransientState_default_instance_;
class Fingerprint_UserCharacteristics;
struct Fingerprint_UserCharacteristicsDefaultTypeInternal;
extern Fingerprint_UserCharacteristicsDefaultTypeInternal _Fingerprint_UserCharacteristics_default_instance_;
class Fingerprint_UserCharacteristics_Location;
struct Fingerprint_UserCharacteristics_LocationDefaultTypeInternal;
extern Fingerprint_UserCharacteristics_LocationDefaultTypeInternal _Fingerprint_UserCharacteristics_Location_default_instance_;
class Fingerprint_UserCharacteristics_Vector;
struct Fingerprint_UserCharacteristics_VectorDefaultTypeInternal;
extern Fingerprint_UserCharacteristics_VectorDefaultTypeInternal _Fingerprint_UserCharacteristics_Vector_default_instance_;
} // namespace risk
} // namespace autofill
PROTOBUF_NAMESPACE_OPEN
template <>::autofill::risk::Fingerprint* Arena::CreateMaybeMessage<::autofill::risk::Fingerprint>(Arena*);
template <>::autofill::risk::Fingerprint_Dimension* Arena::CreateMaybeMessage<::autofill::risk::Fingerprint_Dimension>(Arena*);
template <>::autofill::risk::Fingerprint_MachineCharacteristics* Arena::CreateMaybeMessage<::autofill::risk::Fingerprint_MachineCharacteristics>(Arena*);
template <>
::autofill::risk::Fingerprint_MachineCharacteristics_Cpu* Arena::CreateMaybeMessage<::autofill::risk::Fingerprint_MachineCharacteristics_Cpu>(Arena*);
template <>
::autofill::risk::Fingerprint_MachineCharacteristics_Graphics* Arena::CreateMaybeMessage<::autofill::risk::Fingerprint_MachineCharacteristics_Graphics>(Arena*);
template <>
::autofill::risk::Fingerprint_MachineCharacteristics_Plugin* Arena::CreateMaybeMessage<::autofill::risk::Fingerprint_MachineCharacteristics_Plugin>(Arena*);
template <>::autofill::risk::Fingerprint_Metadata* Arena::CreateMaybeMessage<::autofill::risk::Fingerprint_Metadata>(Arena*);
template <>::autofill::risk::Fingerprint_Performance* Arena::CreateMaybeMessage<::autofill::risk::Fingerprint_Performance>(Arena*);
template <>::autofill::risk::Fingerprint_TransientState* Arena::CreateMaybeMessage<::autofill::risk::Fingerprint_TransientState>(Arena*);
template <>::autofill::risk::Fingerprint_UserCharacteristics* Arena::CreateMaybeMessage<::autofill::risk::Fingerprint_UserCharacteristics>(Arena*);
template <>
::autofill::risk::Fingerprint_UserCharacteristics_Location* Arena::CreateMaybeMessage<::autofill::risk::Fingerprint_UserCharacteristics_Location>(Arena*);
template <>
::autofill::risk::Fingerprint_UserCharacteristics_Vector* Arena::CreateMaybeMessage<::autofill::risk::Fingerprint_UserCharacteristics_Vector>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace autofill {
namespace risk {

enum Fingerprint_MachineCharacteristics_BrowserFeature : int {
    Fingerprint_MachineCharacteristics_BrowserFeature_FEATURE_UNKNOWN = 0,
    Fingerprint_MachineCharacteristics_BrowserFeature_DEPRECATED_FEATURE_AUTOCHECKOUT = 1,
    Fingerprint_MachineCharacteristics_BrowserFeature_FEATURE_REQUEST_AUTOCOMPLETE = 2
};
bool Fingerprint_MachineCharacteristics_BrowserFeature_IsValid(int value);
constexpr Fingerprint_MachineCharacteristics_BrowserFeature Fingerprint_MachineCharacteristics_BrowserFeature_BrowserFeature_MIN
    = Fingerprint_MachineCharacteristics_BrowserFeature_FEATURE_UNKNOWN;
constexpr Fingerprint_MachineCharacteristics_BrowserFeature Fingerprint_MachineCharacteristics_BrowserFeature_BrowserFeature_MAX
    = Fingerprint_MachineCharacteristics_BrowserFeature_FEATURE_REQUEST_AUTOCOMPLETE;
constexpr int Fingerprint_MachineCharacteristics_BrowserFeature_BrowserFeature_ARRAYSIZE
    = Fingerprint_MachineCharacteristics_BrowserFeature_BrowserFeature_MAX + 1;

const std::string& Fingerprint_MachineCharacteristics_BrowserFeature_Name(Fingerprint_MachineCharacteristics_BrowserFeature value);
template <typename T> inline const std::string& Fingerprint_MachineCharacteristics_BrowserFeature_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, Fingerprint_MachineCharacteristics_BrowserFeature>::value || ::std::is_integral<T>::value,
        "Incorrect type passed to function Fingerprint_MachineCharacteristics_BrowserFeature_Name.");
    return Fingerprint_MachineCharacteristics_BrowserFeature_Name(static_cast<Fingerprint_MachineCharacteristics_BrowserFeature>(enum_t_value));
}
bool Fingerprint_MachineCharacteristics_BrowserFeature_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Fingerprint_MachineCharacteristics_BrowserFeature* value);
// ===================================================================

class Fingerprint_Dimension final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.risk.Fingerprint.Dimension) */ {
public:
    inline Fingerprint_Dimension()
        : Fingerprint_Dimension(nullptr)
    {
    }
    ~Fingerprint_Dimension() override;
    explicit PROTOBUF_CONSTEXPR Fingerprint_Dimension(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    Fingerprint_Dimension(const Fingerprint_Dimension& from);
    Fingerprint_Dimension(Fingerprint_Dimension&& from) noexcept
        : Fingerprint_Dimension()
    {
        *this = ::std::move(from);
    }

    inline Fingerprint_Dimension& operator=(const Fingerprint_Dimension& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline Fingerprint_Dimension& operator=(Fingerprint_Dimension&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const Fingerprint_Dimension& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const Fingerprint_Dimension* internal_default_instance()
    {
        return reinterpret_cast<const Fingerprint_Dimension*>(&_Fingerprint_Dimension_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 0;

    friend void swap(Fingerprint_Dimension& a, Fingerprint_Dimension& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(Fingerprint_Dimension* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(Fingerprint_Dimension* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    Fingerprint_Dimension* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<Fingerprint_Dimension>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const Fingerprint_Dimension& from);
    void MergeFrom(const Fingerprint_Dimension& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(Fingerprint_Dimension* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "autofill.risk.Fingerprint.Dimension";
    }

protected:
    explicit Fingerprint_Dimension(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kWidthFieldNumber = 1,
        kHeightFieldNumber = 2,
    };
    // optional int32 width = 1;
    bool has_width() const;

private:
    bool _internal_has_width() const;

public:
    void clear_width();
    int32_t width() const;
    void set_width(int32_t value);

private:
    int32_t _internal_width() const;
    void _internal_set_width(int32_t value);

public:
    // optional int32 height = 2;
    bool has_height() const;

private:
    bool _internal_has_height() const;

public:
    void clear_height();
    int32_t height() const;
    void set_height(int32_t value);

private:
    int32_t _internal_height() const;
    void _internal_set_height(int32_t value);

public:
    // @@protoc_insertion_point(class_scope:autofill.risk.Fingerprint.Dimension)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        int32_t width_;
        int32_t height_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_fingerprint_2eproto;
};
// -------------------------------------------------------------------

class Fingerprint_MachineCharacteristics_Plugin final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.risk.Fingerprint.MachineCharacteristics.Plugin) */ {
public:
    inline Fingerprint_MachineCharacteristics_Plugin()
        : Fingerprint_MachineCharacteristics_Plugin(nullptr)
    {
    }
    ~Fingerprint_MachineCharacteristics_Plugin() override;
    explicit PROTOBUF_CONSTEXPR Fingerprint_MachineCharacteristics_Plugin(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    Fingerprint_MachineCharacteristics_Plugin(const Fingerprint_MachineCharacteristics_Plugin& from);
    Fingerprint_MachineCharacteristics_Plugin(Fingerprint_MachineCharacteristics_Plugin&& from) noexcept
        : Fingerprint_MachineCharacteristics_Plugin()
    {
        *this = ::std::move(from);
    }

    inline Fingerprint_MachineCharacteristics_Plugin& operator=(const Fingerprint_MachineCharacteristics_Plugin& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline Fingerprint_MachineCharacteristics_Plugin& operator=(Fingerprint_MachineCharacteristics_Plugin&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const Fingerprint_MachineCharacteristics_Plugin& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const Fingerprint_MachineCharacteristics_Plugin* internal_default_instance()
    {
        return reinterpret_cast<const Fingerprint_MachineCharacteristics_Plugin*>(&_Fingerprint_MachineCharacteristics_Plugin_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 1;

    friend void swap(Fingerprint_MachineCharacteristics_Plugin& a, Fingerprint_MachineCharacteristics_Plugin& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(Fingerprint_MachineCharacteristics_Plugin* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(Fingerprint_MachineCharacteristics_Plugin* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    Fingerprint_MachineCharacteristics_Plugin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<Fingerprint_MachineCharacteristics_Plugin>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const Fingerprint_MachineCharacteristics_Plugin& from);
    void MergeFrom(const Fingerprint_MachineCharacteristics_Plugin& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(Fingerprint_MachineCharacteristics_Plugin* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "autofill.risk.Fingerprint.MachineCharacteristics.Plugin";
    }

protected:
    explicit Fingerprint_MachineCharacteristics_Plugin(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kMimeTypeFieldNumber = 3,
        kNameFieldNumber = 1,
        kDescriptionFieldNumber = 2,
        kVersionFieldNumber = 4,
    };
    // repeated string mime_type = 3;
    int mime_type_size() const;

private:
    int _internal_mime_type_size() const;

public:
    void clear_mime_type();
    const std::string& mime_type(int index) const;
    std::string* mutable_mime_type(int index);
    void set_mime_type(int index, const std::string& value);
    void set_mime_type(int index, std::string&& value);
    void set_mime_type(int index, const char* value);
    void set_mime_type(int index, const char* value, size_t size);
    std::string* add_mime_type();
    void add_mime_type(const std::string& value);
    void add_mime_type(std::string&& value);
    void add_mime_type(const char* value);
    void add_mime_type(const char* value, size_t size);
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& mime_type() const;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_mime_type();

private:
    const std::string& _internal_mime_type(int index) const;
    std::string* _internal_add_mime_type();

public:
    // optional string name = 1;
    bool has_name() const;

private:
    bool _internal_has_name() const;

public:
    void clear_name();
    const std::string& name() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_name(ArgT0&& arg0, ArgT... args);
    std::string* mutable_name();
    PROTOBUF_NODISCARD std::string* release_name();
    void set_allocated_name(std::string* name);

private:
    const std::string& _internal_name() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
    std::string* _internal_mutable_name();

public:
    // optional string description = 2;
    bool has_description() const;

private:
    bool _internal_has_description() const;

public:
    void clear_description();
    const std::string& description() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_description(ArgT0&& arg0, ArgT... args);
    std::string* mutable_description();
    PROTOBUF_NODISCARD std::string* release_description();
    void set_allocated_description(std::string* description);

private:
    const std::string& _internal_description() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
    std::string* _internal_mutable_description();

public:
    // optional string version = 4;
    bool has_version() const;

private:
    bool _internal_has_version() const;

public:
    void clear_version();
    const std::string& version() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_version(ArgT0&& arg0, ArgT... args);
    std::string* mutable_version();
    PROTOBUF_NODISCARD std::string* release_version();
    void set_allocated_version(std::string* version);

private:
    const std::string& _internal_version() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
    std::string* _internal_mutable_version();

public:
    // @@protoc_insertion_point(class_scope:autofill.risk.Fingerprint.MachineCharacteristics.Plugin)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> mime_type_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_fingerprint_2eproto;
};
// -------------------------------------------------------------------

class Fingerprint_MachineCharacteristics_Cpu final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.risk.Fingerprint.MachineCharacteristics.Cpu) */ {
public:
    inline Fingerprint_MachineCharacteristics_Cpu()
        : Fingerprint_MachineCharacteristics_Cpu(nullptr)
    {
    }
    ~Fingerprint_MachineCharacteristics_Cpu() override;
    explicit PROTOBUF_CONSTEXPR Fingerprint_MachineCharacteristics_Cpu(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    Fingerprint_MachineCharacteristics_Cpu(const Fingerprint_MachineCharacteristics_Cpu& from);
    Fingerprint_MachineCharacteristics_Cpu(Fingerprint_MachineCharacteristics_Cpu&& from) noexcept
        : Fingerprint_MachineCharacteristics_Cpu()
    {
        *this = ::std::move(from);
    }

    inline Fingerprint_MachineCharacteristics_Cpu& operator=(const Fingerprint_MachineCharacteristics_Cpu& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline Fingerprint_MachineCharacteristics_Cpu& operator=(Fingerprint_MachineCharacteristics_Cpu&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const Fingerprint_MachineCharacteristics_Cpu& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const Fingerprint_MachineCharacteristics_Cpu* internal_default_instance()
    {
        return reinterpret_cast<const Fingerprint_MachineCharacteristics_Cpu*>(&_Fingerprint_MachineCharacteristics_Cpu_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 2;

    friend void swap(Fingerprint_MachineCharacteristics_Cpu& a, Fingerprint_MachineCharacteristics_Cpu& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(Fingerprint_MachineCharacteristics_Cpu* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(Fingerprint_MachineCharacteristics_Cpu* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    Fingerprint_MachineCharacteristics_Cpu* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<Fingerprint_MachineCharacteristics_Cpu>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const Fingerprint_MachineCharacteristics_Cpu& from);
    void MergeFrom(const Fingerprint_MachineCharacteristics_Cpu& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(Fingerprint_MachineCharacteristics_Cpu* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "autofill.risk.Fingerprint.MachineCharacteristics.Cpu";
    }

protected:
    explicit Fingerprint_MachineCharacteristics_Cpu(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kVendorNameFieldNumber = 1,
        kBrandFieldNumber = 2,
    };
    // optional string vendor_name = 1;
    bool has_vendor_name() const;

private:
    bool _internal_has_vendor_name() const;

public:
    void clear_vendor_name();
    const std::string& vendor_name() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_vendor_name(ArgT0&& arg0, ArgT... args);
    std::string* mutable_vendor_name();
    PROTOBUF_NODISCARD std::string* release_vendor_name();
    void set_allocated_vendor_name(std::string* vendor_name);

private:
    const std::string& _internal_vendor_name() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_vendor_name(const std::string& value);
    std::string* _internal_mutable_vendor_name();

public:
    // optional string brand = 2;
    bool has_brand() const;

private:
    bool _internal_has_brand() const;

public:
    void clear_brand();
    const std::string& brand() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_brand(ArgT0&& arg0, ArgT... args);
    std::string* mutable_brand();
    PROTOBUF_NODISCARD std::string* release_brand();
    void set_allocated_brand(std::string* brand);

private:
    const std::string& _internal_brand() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_brand(const std::string& value);
    std::string* _internal_mutable_brand();

public:
    // @@protoc_insertion_point(class_scope:autofill.risk.Fingerprint.MachineCharacteristics.Cpu)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vendor_name_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr brand_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_fingerprint_2eproto;
};
// -------------------------------------------------------------------

class Fingerprint_MachineCharacteristics_Graphics final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.risk.Fingerprint.MachineCharacteristics.Graphics) */ {
public:
    inline Fingerprint_MachineCharacteristics_Graphics()
        : Fingerprint_MachineCharacteristics_Graphics(nullptr)
    {
    }
    ~Fingerprint_MachineCharacteristics_Graphics() override;
    explicit PROTOBUF_CONSTEXPR Fingerprint_MachineCharacteristics_Graphics(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    Fingerprint_MachineCharacteristics_Graphics(const Fingerprint_MachineCharacteristics_Graphics& from);
    Fingerprint_MachineCharacteristics_Graphics(Fingerprint_MachineCharacteristics_Graphics&& from) noexcept
        : Fingerprint_MachineCharacteristics_Graphics()
    {
        *this = ::std::move(from);
    }

    inline Fingerprint_MachineCharacteristics_Graphics& operator=(const Fingerprint_MachineCharacteristics_Graphics& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline Fingerprint_MachineCharacteristics_Graphics& operator=(Fingerprint_MachineCharacteristics_Graphics&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const Fingerprint_MachineCharacteristics_Graphics& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const Fingerprint_MachineCharacteristics_Graphics* internal_default_instance()
    {
        return reinterpret_cast<const Fingerprint_MachineCharacteristics_Graphics*>(&_Fingerprint_MachineCharacteristics_Graphics_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 3;

    friend void swap(Fingerprint_MachineCharacteristics_Graphics& a, Fingerprint_MachineCharacteristics_Graphics& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(Fingerprint_MachineCharacteristics_Graphics* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(Fingerprint_MachineCharacteristics_Graphics* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    Fingerprint_MachineCharacteristics_Graphics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<Fingerprint_MachineCharacteristics_Graphics>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const Fingerprint_MachineCharacteristics_Graphics& from);
    void MergeFrom(const Fingerprint_MachineCharacteristics_Graphics& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(Fingerprint_MachineCharacteristics_Graphics* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "autofill.risk.Fingerprint.MachineCharacteristics.Graphics";
    }

protected:
    explicit Fingerprint_MachineCharacteristics_Graphics(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kDriverVersionFieldNumber = 3,
        kDriverDateFieldNumber = 4,
        kVendorIdFieldNumber = 1,
        kDeviceIdFieldNumber = 2,
    };
    // optional string driver_version = 3;
    bool has_driver_version() const;

private:
    bool _internal_has_driver_version() const;

public:
    void clear_driver_version();
    const std::string& driver_version() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_driver_version(ArgT0&& arg0, ArgT... args);
    std::string* mutable_driver_version();
    PROTOBUF_NODISCARD std::string* release_driver_version();
    void set_allocated_driver_version(std::string* driver_version);

private:
    const std::string& _internal_driver_version() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_driver_version(const std::string& value);
    std::string* _internal_mutable_driver_version();

public:
    // optional string driver_date = 4;
    bool has_driver_date() const;

private:
    bool _internal_has_driver_date() const;

public:
    void clear_driver_date();
    const std::string& driver_date() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_driver_date(ArgT0&& arg0, ArgT... args);
    std::string* mutable_driver_date();
    PROTOBUF_NODISCARD std::string* release_driver_date();
    void set_allocated_driver_date(std::string* driver_date);

private:
    const std::string& _internal_driver_date() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_driver_date(const std::string& value);
    std::string* _internal_mutable_driver_date();

public:
    // optional uint32 vendor_id = 1;
    bool has_vendor_id() const;

private:
    bool _internal_has_vendor_id() const;

public:
    void clear_vendor_id();
    uint32_t vendor_id() const;
    void set_vendor_id(uint32_t value);

private:
    uint32_t _internal_vendor_id() const;
    void _internal_set_vendor_id(uint32_t value);

public:
    // optional uint32 device_id = 2;
    bool has_device_id() const;

private:
    bool _internal_has_device_id() const;

public:
    void clear_device_id();
    uint32_t device_id() const;
    void set_device_id(uint32_t value);

private:
    uint32_t _internal_device_id() const;
    void _internal_set_device_id(uint32_t value);

public:
    // @@protoc_insertion_point(class_scope:autofill.risk.Fingerprint.MachineCharacteristics.Graphics)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr driver_version_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr driver_date_;
        uint32_t vendor_id_;
        uint32_t device_id_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_fingerprint_2eproto;
};
// -------------------------------------------------------------------

class Fingerprint_MachineCharacteristics final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.risk.Fingerprint.MachineCharacteristics) */ {
public:
    inline Fingerprint_MachineCharacteristics()
        : Fingerprint_MachineCharacteristics(nullptr)
    {
    }
    ~Fingerprint_MachineCharacteristics() override;
    explicit PROTOBUF_CONSTEXPR Fingerprint_MachineCharacteristics(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    Fingerprint_MachineCharacteristics(const Fingerprint_MachineCharacteristics& from);
    Fingerprint_MachineCharacteristics(Fingerprint_MachineCharacteristics&& from) noexcept
        : Fingerprint_MachineCharacteristics()
    {
        *this = ::std::move(from);
    }

    inline Fingerprint_MachineCharacteristics& operator=(const Fingerprint_MachineCharacteristics& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline Fingerprint_MachineCharacteristics& operator=(Fingerprint_MachineCharacteristics&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const Fingerprint_MachineCharacteristics& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const Fingerprint_MachineCharacteristics* internal_default_instance()
    {
        return reinterpret_cast<const Fingerprint_MachineCharacteristics*>(&_Fingerprint_MachineCharacteristics_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 4;

    friend void swap(Fingerprint_MachineCharacteristics& a, Fingerprint_MachineCharacteristics& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(Fingerprint_MachineCharacteristics* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(Fingerprint_MachineCharacteristics* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    Fingerprint_MachineCharacteristics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<Fingerprint_MachineCharacteristics>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const Fingerprint_MachineCharacteristics& from);
    void MergeFrom(const Fingerprint_MachineCharacteristics& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(Fingerprint_MachineCharacteristics* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "autofill.risk.Fingerprint.MachineCharacteristics";
    }

protected:
    explicit Fingerprint_MachineCharacteristics(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef Fingerprint_MachineCharacteristics_Plugin Plugin;
    typedef Fingerprint_MachineCharacteristics_Cpu Cpu;
    typedef Fingerprint_MachineCharacteristics_Graphics Graphics;

    typedef Fingerprint_MachineCharacteristics_BrowserFeature BrowserFeature;
    static constexpr BrowserFeature FEATURE_UNKNOWN = Fingerprint_MachineCharacteristics_BrowserFeature_FEATURE_UNKNOWN;
    static constexpr BrowserFeature DEPRECATED_FEATURE_AUTOCHECKOUT = Fingerprint_MachineCharacteristics_BrowserFeature_DEPRECATED_FEATURE_AUTOCHECKOUT;
    static constexpr BrowserFeature FEATURE_REQUEST_AUTOCOMPLETE = Fingerprint_MachineCharacteristics_BrowserFeature_FEATURE_REQUEST_AUTOCOMPLETE;
    static inline bool BrowserFeature_IsValid(int value)
    {
        return Fingerprint_MachineCharacteristics_BrowserFeature_IsValid(value);
    }
    static constexpr BrowserFeature BrowserFeature_MIN = Fingerprint_MachineCharacteristics_BrowserFeature_BrowserFeature_MIN;
    static constexpr BrowserFeature BrowserFeature_MAX = Fingerprint_MachineCharacteristics_BrowserFeature_BrowserFeature_MAX;
    static constexpr int BrowserFeature_ARRAYSIZE = Fingerprint_MachineCharacteristics_BrowserFeature_BrowserFeature_ARRAYSIZE;
    template <typename T> static inline const std::string& BrowserFeature_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, BrowserFeature>::value || ::std::is_integral<T>::value, "Incorrect type passed to function BrowserFeature_Name.");
        return Fingerprint_MachineCharacteristics_BrowserFeature_Name(enum_t_value);
    }
    static inline bool BrowserFeature_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BrowserFeature* value)
    {
        return Fingerprint_MachineCharacteristics_BrowserFeature_Parse(name, value);
    }

    // accessors -------------------------------------------------------

    enum : int {
        kFontFieldNumber = 4,
        kPluginFieldNumber = 5,
        kRequestedLanguageFieldNumber = 8,
        kPartitionSizeFieldNumber = 15,
        kOperatingSystemBuildFieldNumber = 2,
        kBrowserLanguageFieldNumber = 7,
        kCharsetFieldNumber = 9,
        kUserAgentFieldNumber = 14,
        kBrowserBuildFieldNumber = 19,
        kScreenSizeFieldNumber = 11,
        kUnavailableScreenSizeFieldNumber = 13,
        kCpuFieldNumber = 16,
        kGraphicsCardFieldNumber = 18,
        kUserAndDeviceNameHashFieldNumber = 1,
        kBrowserInstallTimeHoursFieldNumber = 3,
        kUtcOffsetMsFieldNumber = 6,
        kScreenCountFieldNumber = 10,
        kScreenColorDepthFieldNumber = 12,
        kRamFieldNumber = 17,
        kBrowserFeatureFieldNumber = 20,
    };
    // repeated string font = 4;
    int font_size() const;

private:
    int _internal_font_size() const;

public:
    void clear_font();
    const std::string& font(int index) const;
    std::string* mutable_font(int index);
    void set_font(int index, const std::string& value);
    void set_font(int index, std::string&& value);
    void set_font(int index, const char* value);
    void set_font(int index, const char* value, size_t size);
    std::string* add_font();
    void add_font(const std::string& value);
    void add_font(std::string&& value);
    void add_font(const char* value);
    void add_font(const char* value, size_t size);
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& font() const;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_font();

private:
    const std::string& _internal_font(int index) const;
    std::string* _internal_add_font();

public:
    // repeated .autofill.risk.Fingerprint.MachineCharacteristics.Plugin plugin = 5;
    int plugin_size() const;

private:
    int _internal_plugin_size() const;

public:
    void clear_plugin();
    ::autofill::risk::Fingerprint_MachineCharacteristics_Plugin* mutable_plugin(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::autofill::risk::Fingerprint_MachineCharacteristics_Plugin>* mutable_plugin();

private:
    const ::autofill::risk::Fingerprint_MachineCharacteristics_Plugin& _internal_plugin(int index) const;
    ::autofill::risk::Fingerprint_MachineCharacteristics_Plugin* _internal_add_plugin();

public:
    const ::autofill::risk::Fingerprint_MachineCharacteristics_Plugin& plugin(int index) const;
    ::autofill::risk::Fingerprint_MachineCharacteristics_Plugin* add_plugin();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::autofill::risk::Fingerprint_MachineCharacteristics_Plugin>& plugin() const;

    // repeated string requested_language = 8;
    int requested_language_size() const;

private:
    int _internal_requested_language_size() const;

public:
    void clear_requested_language();
    const std::string& requested_language(int index) const;
    std::string* mutable_requested_language(int index);
    void set_requested_language(int index, const std::string& value);
    void set_requested_language(int index, std::string&& value);
    void set_requested_language(int index, const char* value);
    void set_requested_language(int index, const char* value, size_t size);
    std::string* add_requested_language();
    void add_requested_language(const std::string& value);
    void add_requested_language(std::string&& value);
    void add_requested_language(const char* value);
    void add_requested_language(const char* value, size_t size);
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& requested_language() const;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_requested_language();

private:
    const std::string& _internal_requested_language(int index) const;
    std::string* _internal_add_requested_language();

public:
    // repeated int32 partition_size = 15;
    int partition_size_size() const;

private:
    int _internal_partition_size_size() const;

public:
    void clear_partition_size();

private:
    int32_t _internal_partition_size(int index) const;
    const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>& _internal_partition_size() const;
    void _internal_add_partition_size(int32_t value);
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>* _internal_mutable_partition_size();

public:
    int32_t partition_size(int index) const;
    void set_partition_size(int index, int32_t value);
    void add_partition_size(int32_t value);
    const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>& partition_size() const;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>* mutable_partition_size();

    // optional string operating_system_build = 2;
    bool has_operating_system_build() const;

private:
    bool _internal_has_operating_system_build() const;

public:
    void clear_operating_system_build();
    const std::string& operating_system_build() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_operating_system_build(ArgT0&& arg0, ArgT... args);
    std::string* mutable_operating_system_build();
    PROTOBUF_NODISCARD std::string* release_operating_system_build();
    void set_allocated_operating_system_build(std::string* operating_system_build);

private:
    const std::string& _internal_operating_system_build() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_operating_system_build(const std::string& value);
    std::string* _internal_mutable_operating_system_build();

public:
    // optional string browser_language = 7;
    bool has_browser_language() const;

private:
    bool _internal_has_browser_language() const;

public:
    void clear_browser_language();
    const std::string& browser_language() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_browser_language(ArgT0&& arg0, ArgT... args);
    std::string* mutable_browser_language();
    PROTOBUF_NODISCARD std::string* release_browser_language();
    void set_allocated_browser_language(std::string* browser_language);

private:
    const std::string& _internal_browser_language() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_browser_language(const std::string& value);
    std::string* _internal_mutable_browser_language();

public:
    // optional string charset = 9;
    bool has_charset() const;

private:
    bool _internal_has_charset() const;

public:
    void clear_charset();
    const std::string& charset() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_charset(ArgT0&& arg0, ArgT... args);
    std::string* mutable_charset();
    PROTOBUF_NODISCARD std::string* release_charset();
    void set_allocated_charset(std::string* charset);

private:
    const std::string& _internal_charset() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_charset(const std::string& value);
    std::string* _internal_mutable_charset();

public:
    // optional string user_agent = 14;
    bool has_user_agent() const;

private:
    bool _internal_has_user_agent() const;

public:
    void clear_user_agent();
    const std::string& user_agent() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_user_agent(ArgT0&& arg0, ArgT... args);
    std::string* mutable_user_agent();
    PROTOBUF_NODISCARD std::string* release_user_agent();
    void set_allocated_user_agent(std::string* user_agent);

private:
    const std::string& _internal_user_agent() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_agent(const std::string& value);
    std::string* _internal_mutable_user_agent();

public:
    // optional string browser_build = 19;
    bool has_browser_build() const;

private:
    bool _internal_has_browser_build() const;

public:
    void clear_browser_build();
    const std::string& browser_build() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_browser_build(ArgT0&& arg0, ArgT... args);
    std::string* mutable_browser_build();
    PROTOBUF_NODISCARD std::string* release_browser_build();
    void set_allocated_browser_build(std::string* browser_build);

private:
    const std::string& _internal_browser_build() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_browser_build(const std::string& value);
    std::string* _internal_mutable_browser_build();

public:
    // optional .autofill.risk.Fingerprint.Dimension screen_size = 11;
    bool has_screen_size() const;

private:
    bool _internal_has_screen_size() const;

public:
    void clear_screen_size();
    const ::autofill::risk::Fingerprint_Dimension& screen_size() const;
    PROTOBUF_NODISCARD ::autofill::risk::Fingerprint_Dimension* release_screen_size();
    ::autofill::risk::Fingerprint_Dimension* mutable_screen_size();
    void set_allocated_screen_size(::autofill::risk::Fingerprint_Dimension* screen_size);

private:
    const ::autofill::risk::Fingerprint_Dimension& _internal_screen_size() const;
    ::autofill::risk::Fingerprint_Dimension* _internal_mutable_screen_size();

public:
    void unsafe_arena_set_allocated_screen_size(::autofill::risk::Fingerprint_Dimension* screen_size);
    ::autofill::risk::Fingerprint_Dimension* unsafe_arena_release_screen_size();

    // optional .autofill.risk.Fingerprint.Dimension unavailable_screen_size = 13;
    bool has_unavailable_screen_size() const;

private:
    bool _internal_has_unavailable_screen_size() const;

public:
    void clear_unavailable_screen_size();
    const ::autofill::risk::Fingerprint_Dimension& unavailable_screen_size() const;
    PROTOBUF_NODISCARD ::autofill::risk::Fingerprint_Dimension* release_unavailable_screen_size();
    ::autofill::risk::Fingerprint_Dimension* mutable_unavailable_screen_size();
    void set_allocated_unavailable_screen_size(::autofill::risk::Fingerprint_Dimension* unavailable_screen_size);

private:
    const ::autofill::risk::Fingerprint_Dimension& _internal_unavailable_screen_size() const;
    ::autofill::risk::Fingerprint_Dimension* _internal_mutable_unavailable_screen_size();

public:
    void unsafe_arena_set_allocated_unavailable_screen_size(::autofill::risk::Fingerprint_Dimension* unavailable_screen_size);
    ::autofill::risk::Fingerprint_Dimension* unsafe_arena_release_unavailable_screen_size();

    // optional .autofill.risk.Fingerprint.MachineCharacteristics.Cpu cpu = 16;
    bool has_cpu() const;

private:
    bool _internal_has_cpu() const;

public:
    void clear_cpu();
    const ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu& cpu() const;
    PROTOBUF_NODISCARD ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu* release_cpu();
    ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu* mutable_cpu();
    void set_allocated_cpu(::autofill::risk::Fingerprint_MachineCharacteristics_Cpu* cpu);

private:
    const ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu& _internal_cpu() const;
    ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu* _internal_mutable_cpu();

public:
    void unsafe_arena_set_allocated_cpu(::autofill::risk::Fingerprint_MachineCharacteristics_Cpu* cpu);
    ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu* unsafe_arena_release_cpu();

    // optional .autofill.risk.Fingerprint.MachineCharacteristics.Graphics graphics_card = 18;
    bool has_graphics_card() const;

private:
    bool _internal_has_graphics_card() const;

public:
    void clear_graphics_card();
    const ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics& graphics_card() const;
    PROTOBUF_NODISCARD ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics* release_graphics_card();
    ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics* mutable_graphics_card();
    void set_allocated_graphics_card(::autofill::risk::Fingerprint_MachineCharacteristics_Graphics* graphics_card);

private:
    const ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics& _internal_graphics_card() const;
    ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics* _internal_mutable_graphics_card();

public:
    void unsafe_arena_set_allocated_graphics_card(::autofill::risk::Fingerprint_MachineCharacteristics_Graphics* graphics_card);
    ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics* unsafe_arena_release_graphics_card();

    // optional fixed64 user_and_device_name_hash = 1;
    bool has_user_and_device_name_hash() const;

private:
    bool _internal_has_user_and_device_name_hash() const;

public:
    void clear_user_and_device_name_hash();
    uint64_t user_and_device_name_hash() const;
    void set_user_and_device_name_hash(uint64_t value);

private:
    uint64_t _internal_user_and_device_name_hash() const;
    void _internal_set_user_and_device_name_hash(uint64_t value);

public:
    // optional int64 browser_install_time_hours = 3;
    bool has_browser_install_time_hours() const;

private:
    bool _internal_has_browser_install_time_hours() const;

public:
    void clear_browser_install_time_hours();
    int64_t browser_install_time_hours() const;
    void set_browser_install_time_hours(int64_t value);

private:
    int64_t _internal_browser_install_time_hours() const;
    void _internal_set_browser_install_time_hours(int64_t value);

public:
    // optional int64 utc_offset_ms = 6;
    bool has_utc_offset_ms() const;

private:
    bool _internal_has_utc_offset_ms() const;

public:
    void clear_utc_offset_ms();
    int64_t utc_offset_ms() const;
    void set_utc_offset_ms(int64_t value);

private:
    int64_t _internal_utc_offset_ms() const;
    void _internal_set_utc_offset_ms(int64_t value);

public:
    // optional int32 screen_count = 10;
    bool has_screen_count() const;

private:
    bool _internal_has_screen_count() const;

public:
    void clear_screen_count();
    int32_t screen_count() const;
    void set_screen_count(int32_t value);

private:
    int32_t _internal_screen_count() const;
    void _internal_set_screen_count(int32_t value);

public:
    // optional int32 screen_color_depth = 12;
    bool has_screen_color_depth() const;

private:
    bool _internal_has_screen_color_depth() const;

public:
    void clear_screen_color_depth();
    int32_t screen_color_depth() const;
    void set_screen_color_depth(int32_t value);

private:
    int32_t _internal_screen_color_depth() const;
    void _internal_set_screen_color_depth(int32_t value);

public:
    // optional int64 ram = 17;
    bool has_ram() const;

private:
    bool _internal_has_ram() const;

public:
    void clear_ram();
    int64_t ram() const;
    void set_ram(int64_t value);

private:
    int64_t _internal_ram() const;
    void _internal_set_ram(int64_t value);

public:
    // optional .autofill.risk.Fingerprint.MachineCharacteristics.BrowserFeature browser_feature = 20;
    bool has_browser_feature() const;

private:
    bool _internal_has_browser_feature() const;

public:
    void clear_browser_feature();
    ::autofill::risk::Fingerprint_MachineCharacteristics_BrowserFeature browser_feature() const;
    void set_browser_feature(::autofill::risk::Fingerprint_MachineCharacteristics_BrowserFeature value);

private:
    ::autofill::risk::Fingerprint_MachineCharacteristics_BrowserFeature _internal_browser_feature() const;
    void _internal_set_browser_feature(::autofill::risk::Fingerprint_MachineCharacteristics_BrowserFeature value);

public:
    // @@protoc_insertion_point(class_scope:autofill.risk.Fingerprint.MachineCharacteristics)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> font_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::autofill::risk::Fingerprint_MachineCharacteristics_Plugin> plugin_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> requested_language_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t> partition_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr operating_system_build_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr browser_language_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr charset_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_agent_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr browser_build_;
        ::autofill::risk::Fingerprint_Dimension* screen_size_;
        ::autofill::risk::Fingerprint_Dimension* unavailable_screen_size_;
        ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu* cpu_;
        ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics* graphics_card_;
        uint64_t user_and_device_name_hash_;
        int64_t browser_install_time_hours_;
        int64_t utc_offset_ms_;
        int32_t screen_count_;
        int32_t screen_color_depth_;
        int64_t ram_;
        int browser_feature_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_fingerprint_2eproto;
};
// -------------------------------------------------------------------

class Fingerprint_TransientState final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.risk.Fingerprint.TransientState) */ {
public:
    inline Fingerprint_TransientState()
        : Fingerprint_TransientState(nullptr)
    {
    }
    ~Fingerprint_TransientState() override;
    explicit PROTOBUF_CONSTEXPR Fingerprint_TransientState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    Fingerprint_TransientState(const Fingerprint_TransientState& from);
    Fingerprint_TransientState(Fingerprint_TransientState&& from) noexcept
        : Fingerprint_TransientState()
    {
        *this = ::std::move(from);
    }

    inline Fingerprint_TransientState& operator=(const Fingerprint_TransientState& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline Fingerprint_TransientState& operator=(Fingerprint_TransientState&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const Fingerprint_TransientState& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const Fingerprint_TransientState* internal_default_instance()
    {
        return reinterpret_cast<const Fingerprint_TransientState*>(&_Fingerprint_TransientState_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 5;

    friend void swap(Fingerprint_TransientState& a, Fingerprint_TransientState& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(Fingerprint_TransientState* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(Fingerprint_TransientState* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    Fingerprint_TransientState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<Fingerprint_TransientState>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const Fingerprint_TransientState& from);
    void MergeFrom(const Fingerprint_TransientState& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(Fingerprint_TransientState* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "autofill.risk.Fingerprint.TransientState";
    }

protected:
    explicit Fingerprint_TransientState(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kInnerWindowSizeFieldNumber = 1,
        kOuterWindowSizeFieldNumber = 2,
    };
    // optional .autofill.risk.Fingerprint.Dimension inner_window_size = 1;
    bool has_inner_window_size() const;

private:
    bool _internal_has_inner_window_size() const;

public:
    void clear_inner_window_size();
    const ::autofill::risk::Fingerprint_Dimension& inner_window_size() const;
    PROTOBUF_NODISCARD ::autofill::risk::Fingerprint_Dimension* release_inner_window_size();
    ::autofill::risk::Fingerprint_Dimension* mutable_inner_window_size();
    void set_allocated_inner_window_size(::autofill::risk::Fingerprint_Dimension* inner_window_size);

private:
    const ::autofill::risk::Fingerprint_Dimension& _internal_inner_window_size() const;
    ::autofill::risk::Fingerprint_Dimension* _internal_mutable_inner_window_size();

public:
    void unsafe_arena_set_allocated_inner_window_size(::autofill::risk::Fingerprint_Dimension* inner_window_size);
    ::autofill::risk::Fingerprint_Dimension* unsafe_arena_release_inner_window_size();

    // optional .autofill.risk.Fingerprint.Dimension outer_window_size = 2;
    bool has_outer_window_size() const;

private:
    bool _internal_has_outer_window_size() const;

public:
    void clear_outer_window_size();
    const ::autofill::risk::Fingerprint_Dimension& outer_window_size() const;
    PROTOBUF_NODISCARD ::autofill::risk::Fingerprint_Dimension* release_outer_window_size();
    ::autofill::risk::Fingerprint_Dimension* mutable_outer_window_size();
    void set_allocated_outer_window_size(::autofill::risk::Fingerprint_Dimension* outer_window_size);

private:
    const ::autofill::risk::Fingerprint_Dimension& _internal_outer_window_size() const;
    ::autofill::risk::Fingerprint_Dimension* _internal_mutable_outer_window_size();

public:
    void unsafe_arena_set_allocated_outer_window_size(::autofill::risk::Fingerprint_Dimension* outer_window_size);
    ::autofill::risk::Fingerprint_Dimension* unsafe_arena_release_outer_window_size();

    // @@protoc_insertion_point(class_scope:autofill.risk.Fingerprint.TransientState)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::autofill::risk::Fingerprint_Dimension* inner_window_size_;
        ::autofill::risk::Fingerprint_Dimension* outer_window_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_fingerprint_2eproto;
};
// -------------------------------------------------------------------

class Fingerprint_Performance final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.risk.Fingerprint.Performance) */ {
public:
    inline Fingerprint_Performance()
        : Fingerprint_Performance(nullptr)
    {
    }
    ~Fingerprint_Performance() override;
    explicit PROTOBUF_CONSTEXPR Fingerprint_Performance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    Fingerprint_Performance(const Fingerprint_Performance& from);
    Fingerprint_Performance(Fingerprint_Performance&& from) noexcept
        : Fingerprint_Performance()
    {
        *this = ::std::move(from);
    }

    inline Fingerprint_Performance& operator=(const Fingerprint_Performance& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline Fingerprint_Performance& operator=(Fingerprint_Performance&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const Fingerprint_Performance& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const Fingerprint_Performance* internal_default_instance()
    {
        return reinterpret_cast<const Fingerprint_Performance*>(&_Fingerprint_Performance_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 6;

    friend void swap(Fingerprint_Performance& a, Fingerprint_Performance& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(Fingerprint_Performance* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(Fingerprint_Performance* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    Fingerprint_Performance* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<Fingerprint_Performance>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const Fingerprint_Performance& from);
    void MergeFrom(const Fingerprint_Performance& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(Fingerprint_Performance* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "autofill.risk.Fingerprint.Performance";
    }

protected:
    explicit Fingerprint_Performance(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kNetworkTypeFieldNumber = 3,
        kBandwidthFieldNumber = 1,
        kMeteredFieldNumber = 2,
    };
    // optional string network_type = 3;
    bool has_network_type() const;

private:
    bool _internal_has_network_type() const;

public:
    void clear_network_type();
    const std::string& network_type() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_network_type(ArgT0&& arg0, ArgT... args);
    std::string* mutable_network_type();
    PROTOBUF_NODISCARD std::string* release_network_type();
    void set_allocated_network_type(std::string* network_type);

private:
    const std::string& _internal_network_type() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_network_type(const std::string& value);
    std::string* _internal_mutable_network_type();

public:
    // optional float bandwidth = 1;
    bool has_bandwidth() const;

private:
    bool _internal_has_bandwidth() const;

public:
    void clear_bandwidth();
    float bandwidth() const;
    void set_bandwidth(float value);

private:
    float _internal_bandwidth() const;
    void _internal_set_bandwidth(float value);

public:
    // optional bool metered = 2;
    bool has_metered() const;

private:
    bool _internal_has_metered() const;

public:
    void clear_metered();
    bool metered() const;
    void set_metered(bool value);

private:
    bool _internal_metered() const;
    void _internal_set_metered(bool value);

public:
    // @@protoc_insertion_point(class_scope:autofill.risk.Fingerprint.Performance)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr network_type_;
        float bandwidth_;
        bool metered_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_fingerprint_2eproto;
};
// -------------------------------------------------------------------

class Fingerprint_UserCharacteristics_Vector final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.risk.Fingerprint.UserCharacteristics.Vector) */ {
public:
    inline Fingerprint_UserCharacteristics_Vector()
        : Fingerprint_UserCharacteristics_Vector(nullptr)
    {
    }
    ~Fingerprint_UserCharacteristics_Vector() override;
    explicit PROTOBUF_CONSTEXPR Fingerprint_UserCharacteristics_Vector(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    Fingerprint_UserCharacteristics_Vector(const Fingerprint_UserCharacteristics_Vector& from);
    Fingerprint_UserCharacteristics_Vector(Fingerprint_UserCharacteristics_Vector&& from) noexcept
        : Fingerprint_UserCharacteristics_Vector()
    {
        *this = ::std::move(from);
    }

    inline Fingerprint_UserCharacteristics_Vector& operator=(const Fingerprint_UserCharacteristics_Vector& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline Fingerprint_UserCharacteristics_Vector& operator=(Fingerprint_UserCharacteristics_Vector&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const Fingerprint_UserCharacteristics_Vector& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const Fingerprint_UserCharacteristics_Vector* internal_default_instance()
    {
        return reinterpret_cast<const Fingerprint_UserCharacteristics_Vector*>(&_Fingerprint_UserCharacteristics_Vector_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 7;

    friend void swap(Fingerprint_UserCharacteristics_Vector& a, Fingerprint_UserCharacteristics_Vector& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(Fingerprint_UserCharacteristics_Vector* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(Fingerprint_UserCharacteristics_Vector* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    Fingerprint_UserCharacteristics_Vector* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<Fingerprint_UserCharacteristics_Vector>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const Fingerprint_UserCharacteristics_Vector& from);
    void MergeFrom(const Fingerprint_UserCharacteristics_Vector& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(Fingerprint_UserCharacteristics_Vector* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "autofill.risk.Fingerprint.UserCharacteristics.Vector";
    }

protected:
    explicit Fingerprint_UserCharacteristics_Vector(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kXFieldNumber = 1,
        kYFieldNumber = 2,
        kZFieldNumber = 3,
    };
    // optional int32 x = 1;
    bool has_x() const;

private:
    bool _internal_has_x() const;

public:
    void clear_x();
    int32_t x() const;
    void set_x(int32_t value);

private:
    int32_t _internal_x() const;
    void _internal_set_x(int32_t value);

public:
    // optional int32 y = 2;
    bool has_y() const;

private:
    bool _internal_has_y() const;

public:
    void clear_y();
    int32_t y() const;
    void set_y(int32_t value);

private:
    int32_t _internal_y() const;
    void _internal_set_y(int32_t value);

public:
    // optional int32 z = 3;
    bool has_z() const;

private:
    bool _internal_has_z() const;

public:
    void clear_z();
    int32_t z() const;
    void set_z(int32_t value);

private:
    int32_t _internal_z() const;
    void _internal_set_z(int32_t value);

public:
    // @@protoc_insertion_point(class_scope:autofill.risk.Fingerprint.UserCharacteristics.Vector)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        int32_t x_;
        int32_t y_;
        int32_t z_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_fingerprint_2eproto;
};
// -------------------------------------------------------------------

class Fingerprint_UserCharacteristics_Location final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.risk.Fingerprint.UserCharacteristics.Location) */ {
public:
    inline Fingerprint_UserCharacteristics_Location()
        : Fingerprint_UserCharacteristics_Location(nullptr)
    {
    }
    ~Fingerprint_UserCharacteristics_Location() override;
    explicit PROTOBUF_CONSTEXPR Fingerprint_UserCharacteristics_Location(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    Fingerprint_UserCharacteristics_Location(const Fingerprint_UserCharacteristics_Location& from);
    Fingerprint_UserCharacteristics_Location(Fingerprint_UserCharacteristics_Location&& from) noexcept
        : Fingerprint_UserCharacteristics_Location()
    {
        *this = ::std::move(from);
    }

    inline Fingerprint_UserCharacteristics_Location& operator=(const Fingerprint_UserCharacteristics_Location& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline Fingerprint_UserCharacteristics_Location& operator=(Fingerprint_UserCharacteristics_Location&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const Fingerprint_UserCharacteristics_Location& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const Fingerprint_UserCharacteristics_Location* internal_default_instance()
    {
        return reinterpret_cast<const Fingerprint_UserCharacteristics_Location*>(&_Fingerprint_UserCharacteristics_Location_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 8;

    friend void swap(Fingerprint_UserCharacteristics_Location& a, Fingerprint_UserCharacteristics_Location& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(Fingerprint_UserCharacteristics_Location* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(Fingerprint_UserCharacteristics_Location* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    Fingerprint_UserCharacteristics_Location* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<Fingerprint_UserCharacteristics_Location>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const Fingerprint_UserCharacteristics_Location& from);
    void MergeFrom(const Fingerprint_UserCharacteristics_Location& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(Fingerprint_UserCharacteristics_Location* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "autofill.risk.Fingerprint.UserCharacteristics.Location";
    }

protected:
    explicit Fingerprint_UserCharacteristics_Location(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kAltitudeFieldNumber = 1,
        kLatitudeFieldNumber = 2,
        kLongitudeFieldNumber = 3,
        kAccuracyFieldNumber = 4,
        kTimeInMsFieldNumber = 5,
    };
    // optional double altitude = 1;
    bool has_altitude() const;

private:
    bool _internal_has_altitude() const;

public:
    void clear_altitude();
    double altitude() const;
    void set_altitude(double value);

private:
    double _internal_altitude() const;
    void _internal_set_altitude(double value);

public:
    // optional double latitude = 2;
    bool has_latitude() const;

private:
    bool _internal_has_latitude() const;

public:
    void clear_latitude();
    double latitude() const;
    void set_latitude(double value);

private:
    double _internal_latitude() const;
    void _internal_set_latitude(double value);

public:
    // optional double longitude = 3;
    bool has_longitude() const;

private:
    bool _internal_has_longitude() const;

public:
    void clear_longitude();
    double longitude() const;
    void set_longitude(double value);

private:
    double _internal_longitude() const;
    void _internal_set_longitude(double value);

public:
    // optional double accuracy = 4;
    bool has_accuracy() const;

private:
    bool _internal_has_accuracy() const;

public:
    void clear_accuracy();
    double accuracy() const;
    void set_accuracy(double value);

private:
    double _internal_accuracy() const;
    void _internal_set_accuracy(double value);

public:
    // optional int64 time_in_ms = 5;
    bool has_time_in_ms() const;

private:
    bool _internal_has_time_in_ms() const;

public:
    void clear_time_in_ms();
    int64_t time_in_ms() const;
    void set_time_in_ms(int64_t value);

private:
    int64_t _internal_time_in_ms() const;
    void _internal_set_time_in_ms(int64_t value);

public:
    // @@protoc_insertion_point(class_scope:autofill.risk.Fingerprint.UserCharacteristics.Location)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        double altitude_;
        double latitude_;
        double longitude_;
        double accuracy_;
        int64_t time_in_ms_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_fingerprint_2eproto;
};
// -------------------------------------------------------------------

class Fingerprint_UserCharacteristics final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.risk.Fingerprint.UserCharacteristics) */ {
public:
    inline Fingerprint_UserCharacteristics()
        : Fingerprint_UserCharacteristics(nullptr)
    {
    }
    ~Fingerprint_UserCharacteristics() override;
    explicit PROTOBUF_CONSTEXPR Fingerprint_UserCharacteristics(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    Fingerprint_UserCharacteristics(const Fingerprint_UserCharacteristics& from);
    Fingerprint_UserCharacteristics(Fingerprint_UserCharacteristics&& from) noexcept
        : Fingerprint_UserCharacteristics()
    {
        *this = ::std::move(from);
    }

    inline Fingerprint_UserCharacteristics& operator=(const Fingerprint_UserCharacteristics& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline Fingerprint_UserCharacteristics& operator=(Fingerprint_UserCharacteristics&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const Fingerprint_UserCharacteristics& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const Fingerprint_UserCharacteristics* internal_default_instance()
    {
        return reinterpret_cast<const Fingerprint_UserCharacteristics*>(&_Fingerprint_UserCharacteristics_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 9;

    friend void swap(Fingerprint_UserCharacteristics& a, Fingerprint_UserCharacteristics& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(Fingerprint_UserCharacteristics* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(Fingerprint_UserCharacteristics* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    Fingerprint_UserCharacteristics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<Fingerprint_UserCharacteristics>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const Fingerprint_UserCharacteristics& from);
    void MergeFrom(const Fingerprint_UserCharacteristics& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(Fingerprint_UserCharacteristics* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "autofill.risk.Fingerprint.UserCharacteristics";
    }

protected:
    explicit Fingerprint_UserCharacteristics(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef Fingerprint_UserCharacteristics_Vector Vector;
    typedef Fingerprint_UserCharacteristics_Location Location;

    // accessors -------------------------------------------------------

    enum : int {
        kDeviceOrientationFieldNumber = 5,
        kDeviceAccelerationFieldNumber = 6,
        kLocationFieldNumber = 7,
        kForceFieldNumber = 1,
        kTouchWidthFieldNumber = 2,
        kTouchHeightFieldNumber = 3,
        kTouchRotationFieldNumber = 4,
    };
    // optional .autofill.risk.Fingerprint.UserCharacteristics.Vector device_orientation = 5;
    bool has_device_orientation() const;

private:
    bool _internal_has_device_orientation() const;

public:
    void clear_device_orientation();
    const ::autofill::risk::Fingerprint_UserCharacteristics_Vector& device_orientation() const;
    PROTOBUF_NODISCARD ::autofill::risk::Fingerprint_UserCharacteristics_Vector* release_device_orientation();
    ::autofill::risk::Fingerprint_UserCharacteristics_Vector* mutable_device_orientation();
    void set_allocated_device_orientation(::autofill::risk::Fingerprint_UserCharacteristics_Vector* device_orientation);

private:
    const ::autofill::risk::Fingerprint_UserCharacteristics_Vector& _internal_device_orientation() const;
    ::autofill::risk::Fingerprint_UserCharacteristics_Vector* _internal_mutable_device_orientation();

public:
    void unsafe_arena_set_allocated_device_orientation(::autofill::risk::Fingerprint_UserCharacteristics_Vector* device_orientation);
    ::autofill::risk::Fingerprint_UserCharacteristics_Vector* unsafe_arena_release_device_orientation();

    // optional .autofill.risk.Fingerprint.UserCharacteristics.Vector device_acceleration = 6;
    bool has_device_acceleration() const;

private:
    bool _internal_has_device_acceleration() const;

public:
    void clear_device_acceleration();
    const ::autofill::risk::Fingerprint_UserCharacteristics_Vector& device_acceleration() const;
    PROTOBUF_NODISCARD ::autofill::risk::Fingerprint_UserCharacteristics_Vector* release_device_acceleration();
    ::autofill::risk::Fingerprint_UserCharacteristics_Vector* mutable_device_acceleration();
    void set_allocated_device_acceleration(::autofill::risk::Fingerprint_UserCharacteristics_Vector* device_acceleration);

private:
    const ::autofill::risk::Fingerprint_UserCharacteristics_Vector& _internal_device_acceleration() const;
    ::autofill::risk::Fingerprint_UserCharacteristics_Vector* _internal_mutable_device_acceleration();

public:
    void unsafe_arena_set_allocated_device_acceleration(::autofill::risk::Fingerprint_UserCharacteristics_Vector* device_acceleration);
    ::autofill::risk::Fingerprint_UserCharacteristics_Vector* unsafe_arena_release_device_acceleration();

    // optional .autofill.risk.Fingerprint.UserCharacteristics.Location location = 7;
    bool has_location() const;

private:
    bool _internal_has_location() const;

public:
    void clear_location();
    const ::autofill::risk::Fingerprint_UserCharacteristics_Location& location() const;
    PROTOBUF_NODISCARD ::autofill::risk::Fingerprint_UserCharacteristics_Location* release_location();
    ::autofill::risk::Fingerprint_UserCharacteristics_Location* mutable_location();
    void set_allocated_location(::autofill::risk::Fingerprint_UserCharacteristics_Location* location);

private:
    const ::autofill::risk::Fingerprint_UserCharacteristics_Location& _internal_location() const;
    ::autofill::risk::Fingerprint_UserCharacteristics_Location* _internal_mutable_location();

public:
    void unsafe_arena_set_allocated_location(::autofill::risk::Fingerprint_UserCharacteristics_Location* location);
    ::autofill::risk::Fingerprint_UserCharacteristics_Location* unsafe_arena_release_location();

    // optional float force = 1;
    bool has_force() const;

private:
    bool _internal_has_force() const;

public:
    void clear_force();
    float force() const;
    void set_force(float value);

private:
    float _internal_force() const;
    void _internal_set_force(float value);

public:
    // optional float touch_width = 2;
    bool has_touch_width() const;

private:
    bool _internal_has_touch_width() const;

public:
    void clear_touch_width();
    float touch_width() const;
    void set_touch_width(float value);

private:
    float _internal_touch_width() const;
    void _internal_set_touch_width(float value);

public:
    // optional float touch_height = 3;
    bool has_touch_height() const;

private:
    bool _internal_has_touch_height() const;

public:
    void clear_touch_height();
    float touch_height() const;
    void set_touch_height(float value);

private:
    float _internal_touch_height() const;
    void _internal_set_touch_height(float value);

public:
    // optional int32 touch_rotation = 4;
    bool has_touch_rotation() const;

private:
    bool _internal_has_touch_rotation() const;

public:
    void clear_touch_rotation();
    int32_t touch_rotation() const;
    void set_touch_rotation(int32_t value);

private:
    int32_t _internal_touch_rotation() const;
    void _internal_set_touch_rotation(int32_t value);

public:
    // @@protoc_insertion_point(class_scope:autofill.risk.Fingerprint.UserCharacteristics)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::autofill::risk::Fingerprint_UserCharacteristics_Vector* device_orientation_;
        ::autofill::risk::Fingerprint_UserCharacteristics_Vector* device_acceleration_;
        ::autofill::risk::Fingerprint_UserCharacteristics_Location* location_;
        float force_;
        float touch_width_;
        float touch_height_;
        int32_t touch_rotation_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_fingerprint_2eproto;
};
// -------------------------------------------------------------------

class Fingerprint_Metadata final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.risk.Fingerprint.Metadata) */ {
public:
    inline Fingerprint_Metadata()
        : Fingerprint_Metadata(nullptr)
    {
    }
    ~Fingerprint_Metadata() override;
    explicit PROTOBUF_CONSTEXPR Fingerprint_Metadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    Fingerprint_Metadata(const Fingerprint_Metadata& from);
    Fingerprint_Metadata(Fingerprint_Metadata&& from) noexcept
        : Fingerprint_Metadata()
    {
        *this = ::std::move(from);
    }

    inline Fingerprint_Metadata& operator=(const Fingerprint_Metadata& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline Fingerprint_Metadata& operator=(Fingerprint_Metadata&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const Fingerprint_Metadata& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const Fingerprint_Metadata* internal_default_instance()
    {
        return reinterpret_cast<const Fingerprint_Metadata*>(&_Fingerprint_Metadata_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 10;

    friend void swap(Fingerprint_Metadata& a, Fingerprint_Metadata& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(Fingerprint_Metadata* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(Fingerprint_Metadata* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    Fingerprint_Metadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<Fingerprint_Metadata>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const Fingerprint_Metadata& from);
    void MergeFrom(const Fingerprint_Metadata& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(Fingerprint_Metadata* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "autofill.risk.Fingerprint.Metadata";
    }

protected:
    explicit Fingerprint_Metadata(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kTimestampMsFieldNumber = 1,
        kObfuscatedGaiaIdFieldNumber = 2,
        kFingerprinterVersionFieldNumber = 3,
    };
    // optional int64 timestamp_ms = 1;
    bool has_timestamp_ms() const;

private:
    bool _internal_has_timestamp_ms() const;

public:
    void clear_timestamp_ms();
    int64_t timestamp_ms() const;
    void set_timestamp_ms(int64_t value);

private:
    int64_t _internal_timestamp_ms() const;
    void _internal_set_timestamp_ms(int64_t value);

public:
    // optional uint64 obfuscated_gaia_id = 2;
    bool has_obfuscated_gaia_id() const;

private:
    bool _internal_has_obfuscated_gaia_id() const;

public:
    void clear_obfuscated_gaia_id();
    uint64_t obfuscated_gaia_id() const;
    void set_obfuscated_gaia_id(uint64_t value);

private:
    uint64_t _internal_obfuscated_gaia_id() const;
    void _internal_set_obfuscated_gaia_id(uint64_t value);

public:
    // optional int32 fingerprinter_version = 3;
    bool has_fingerprinter_version() const;

private:
    bool _internal_has_fingerprinter_version() const;

public:
    void clear_fingerprinter_version();
    int32_t fingerprinter_version() const;
    void set_fingerprinter_version(int32_t value);

private:
    int32_t _internal_fingerprinter_version() const;
    void _internal_set_fingerprinter_version(int32_t value);

public:
    // @@protoc_insertion_point(class_scope:autofill.risk.Fingerprint.Metadata)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        int64_t timestamp_ms_;
        uint64_t obfuscated_gaia_id_;
        int32_t fingerprinter_version_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_fingerprint_2eproto;
};
// -------------------------------------------------------------------

class Fingerprint final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:autofill.risk.Fingerprint) */ {
public:
    inline Fingerprint()
        : Fingerprint(nullptr)
    {
    }
    ~Fingerprint() override;
    explicit PROTOBUF_CONSTEXPR Fingerprint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    Fingerprint(const Fingerprint& from);
    Fingerprint(Fingerprint&& from) noexcept
        : Fingerprint()
    {
        *this = ::std::move(from);
    }

    inline Fingerprint& operator=(const Fingerprint& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline Fingerprint& operator=(Fingerprint&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const Fingerprint& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const Fingerprint* internal_default_instance()
    {
        return reinterpret_cast<const Fingerprint*>(&_Fingerprint_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 11;

    friend void swap(Fingerprint& a, Fingerprint& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(Fingerprint* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(Fingerprint* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    Fingerprint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<Fingerprint>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const Fingerprint& from);
    void MergeFrom(const Fingerprint& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(Fingerprint* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "autofill.risk.Fingerprint";
    }

protected:
    explicit Fingerprint(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef Fingerprint_Dimension Dimension;
    typedef Fingerprint_MachineCharacteristics MachineCharacteristics;
    typedef Fingerprint_TransientState TransientState;
    typedef Fingerprint_Performance Performance;
    typedef Fingerprint_UserCharacteristics UserCharacteristics;
    typedef Fingerprint_Metadata Metadata;

    // accessors -------------------------------------------------------

    enum : int {
        kMachineCharacteristicsFieldNumber = 1,
        kPerformanceFieldNumber = 2,
        kUserCharacteristicsFieldNumber = 3,
        kTransientStateFieldNumber = 4,
        kMetadataFieldNumber = 5,
    };
    // optional .autofill.risk.Fingerprint.MachineCharacteristics machine_characteristics = 1;
    bool has_machine_characteristics() const;

private:
    bool _internal_has_machine_characteristics() const;

public:
    void clear_machine_characteristics();
    const ::autofill::risk::Fingerprint_MachineCharacteristics& machine_characteristics() const;
    PROTOBUF_NODISCARD ::autofill::risk::Fingerprint_MachineCharacteristics* release_machine_characteristics();
    ::autofill::risk::Fingerprint_MachineCharacteristics* mutable_machine_characteristics();
    void set_allocated_machine_characteristics(::autofill::risk::Fingerprint_MachineCharacteristics* machine_characteristics);

private:
    const ::autofill::risk::Fingerprint_MachineCharacteristics& _internal_machine_characteristics() const;
    ::autofill::risk::Fingerprint_MachineCharacteristics* _internal_mutable_machine_characteristics();

public:
    void unsafe_arena_set_allocated_machine_characteristics(::autofill::risk::Fingerprint_MachineCharacteristics* machine_characteristics);
    ::autofill::risk::Fingerprint_MachineCharacteristics* unsafe_arena_release_machine_characteristics();

    // optional .autofill.risk.Fingerprint.Performance performance = 2;
    bool has_performance() const;

private:
    bool _internal_has_performance() const;

public:
    void clear_performance();
    const ::autofill::risk::Fingerprint_Performance& performance() const;
    PROTOBUF_NODISCARD ::autofill::risk::Fingerprint_Performance* release_performance();
    ::autofill::risk::Fingerprint_Performance* mutable_performance();
    void set_allocated_performance(::autofill::risk::Fingerprint_Performance* performance);

private:
    const ::autofill::risk::Fingerprint_Performance& _internal_performance() const;
    ::autofill::risk::Fingerprint_Performance* _internal_mutable_performance();

public:
    void unsafe_arena_set_allocated_performance(::autofill::risk::Fingerprint_Performance* performance);
    ::autofill::risk::Fingerprint_Performance* unsafe_arena_release_performance();

    // optional .autofill.risk.Fingerprint.UserCharacteristics user_characteristics = 3;
    bool has_user_characteristics() const;

private:
    bool _internal_has_user_characteristics() const;

public:
    void clear_user_characteristics();
    const ::autofill::risk::Fingerprint_UserCharacteristics& user_characteristics() const;
    PROTOBUF_NODISCARD ::autofill::risk::Fingerprint_UserCharacteristics* release_user_characteristics();
    ::autofill::risk::Fingerprint_UserCharacteristics* mutable_user_characteristics();
    void set_allocated_user_characteristics(::autofill::risk::Fingerprint_UserCharacteristics* user_characteristics);

private:
    const ::autofill::risk::Fingerprint_UserCharacteristics& _internal_user_characteristics() const;
    ::autofill::risk::Fingerprint_UserCharacteristics* _internal_mutable_user_characteristics();

public:
    void unsafe_arena_set_allocated_user_characteristics(::autofill::risk::Fingerprint_UserCharacteristics* user_characteristics);
    ::autofill::risk::Fingerprint_UserCharacteristics* unsafe_arena_release_user_characteristics();

    // optional .autofill.risk.Fingerprint.TransientState transient_state = 4;
    bool has_transient_state() const;

private:
    bool _internal_has_transient_state() const;

public:
    void clear_transient_state();
    const ::autofill::risk::Fingerprint_TransientState& transient_state() const;
    PROTOBUF_NODISCARD ::autofill::risk::Fingerprint_TransientState* release_transient_state();
    ::autofill::risk::Fingerprint_TransientState* mutable_transient_state();
    void set_allocated_transient_state(::autofill::risk::Fingerprint_TransientState* transient_state);

private:
    const ::autofill::risk::Fingerprint_TransientState& _internal_transient_state() const;
    ::autofill::risk::Fingerprint_TransientState* _internal_mutable_transient_state();

public:
    void unsafe_arena_set_allocated_transient_state(::autofill::risk::Fingerprint_TransientState* transient_state);
    ::autofill::risk::Fingerprint_TransientState* unsafe_arena_release_transient_state();

    // optional .autofill.risk.Fingerprint.Metadata metadata = 5;
    bool has_metadata() const;

private:
    bool _internal_has_metadata() const;

public:
    void clear_metadata();
    const ::autofill::risk::Fingerprint_Metadata& metadata() const;
    PROTOBUF_NODISCARD ::autofill::risk::Fingerprint_Metadata* release_metadata();
    ::autofill::risk::Fingerprint_Metadata* mutable_metadata();
    void set_allocated_metadata(::autofill::risk::Fingerprint_Metadata* metadata);

private:
    const ::autofill::risk::Fingerprint_Metadata& _internal_metadata() const;
    ::autofill::risk::Fingerprint_Metadata* _internal_mutable_metadata();

public:
    void unsafe_arena_set_allocated_metadata(::autofill::risk::Fingerprint_Metadata* metadata);
    ::autofill::risk::Fingerprint_Metadata* unsafe_arena_release_metadata();

    // @@protoc_insertion_point(class_scope:autofill.risk.Fingerprint)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::autofill::risk::Fingerprint_MachineCharacteristics* machine_characteristics_;
        ::autofill::risk::Fingerprint_Performance* performance_;
        ::autofill::risk::Fingerprint_UserCharacteristics* user_characteristics_;
        ::autofill::risk::Fingerprint_TransientState* transient_state_;
        ::autofill::risk::Fingerprint_Metadata* metadata_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_fingerprint_2eproto;
};
// ===================================================================

// ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif // __GNUC__
// Fingerprint_Dimension

// optional int32 width = 1;
inline bool Fingerprint_Dimension::_internal_has_width() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool Fingerprint_Dimension::has_width() const
{
    return _internal_has_width();
}
inline void Fingerprint_Dimension::clear_width()
{
    _impl_.width_ = 0;
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t Fingerprint_Dimension::_internal_width() const
{
    return _impl_.width_;
}
inline int32_t Fingerprint_Dimension::width() const
{
    // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.Dimension.width)
    return _internal_width();
}
inline void Fingerprint_Dimension::_internal_set_width(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.width_ = value;
}
inline void Fingerprint_Dimension::set_width(int32_t value)
{
    _internal_set_width(value);
    // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.Dimension.width)
}

// optional int32 height = 2;
inline bool Fingerprint_Dimension::_internal_has_height() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool Fingerprint_Dimension::has_height() const
{
    return _internal_has_height();
}
inline void Fingerprint_Dimension::clear_height()
{
    _impl_.height_ = 0;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t Fingerprint_Dimension::_internal_height() const
{
    return _impl_.height_;
}
inline int32_t Fingerprint_Dimension::height() const
{
    // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.Dimension.height)
    return _internal_height();
}
inline void Fingerprint_Dimension::_internal_set_height(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.height_ = value;
}
inline void Fingerprint_Dimension::set_height(int32_t value)
{
    _internal_set_height(value);
    // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.Dimension.height)
}

// -------------------------------------------------------------------

// Fingerprint_MachineCharacteristics_Plugin

// optional string name = 1;
inline bool Fingerprint_MachineCharacteristics_Plugin::_internal_has_name() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool Fingerprint_MachineCharacteristics_Plugin::has_name() const
{
    return _internal_has_name();
}
inline void Fingerprint_MachineCharacteristics_Plugin::clear_name()
{
    _impl_.name_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Fingerprint_MachineCharacteristics_Plugin::name() const
{
    // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.name)
    return _internal_name();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void Fingerprint_MachineCharacteristics_Plugin::set_name(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.name_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.name)
}
inline std::string* Fingerprint_MachineCharacteristics_Plugin::mutable_name()
{
    std::string* _s = _internal_mutable_name();
    // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.name)
    return _s;
}
inline const std::string& Fingerprint_MachineCharacteristics_Plugin::_internal_name() const
{
    return _impl_.name_.Get();
}
inline void Fingerprint_MachineCharacteristics_Plugin::_internal_set_name(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Fingerprint_MachineCharacteristics_Plugin::_internal_mutable_name()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Fingerprint_MachineCharacteristics_Plugin::release_name()
{
    // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.name)
    if (!_internal_has_name()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.name_.IsDefault()) {
        _impl_.name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void Fingerprint_MachineCharacteristics_Plugin::set_allocated_name(std::string* name)
{
    if (name != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.name_.IsDefault()) {
        _impl_.name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.name)
}

// optional string description = 2;
inline bool Fingerprint_MachineCharacteristics_Plugin::_internal_has_description() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool Fingerprint_MachineCharacteristics_Plugin::has_description() const
{
    return _internal_has_description();
}
inline void Fingerprint_MachineCharacteristics_Plugin::clear_description()
{
    _impl_.description_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Fingerprint_MachineCharacteristics_Plugin::description() const
{
    // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.description)
    return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE void Fingerprint_MachineCharacteristics_Plugin::set_description(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.description_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.description)
}
inline std::string* Fingerprint_MachineCharacteristics_Plugin::mutable_description()
{
    std::string* _s = _internal_mutable_description();
    // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.description)
    return _s;
}
inline const std::string& Fingerprint_MachineCharacteristics_Plugin::_internal_description() const
{
    return _impl_.description_.Get();
}
inline void Fingerprint_MachineCharacteristics_Plugin::_internal_set_description(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* Fingerprint_MachineCharacteristics_Plugin::_internal_mutable_description()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* Fingerprint_MachineCharacteristics_Plugin::release_description()
{
    // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.description)
    if (!_internal_has_description()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.description_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.description_.IsDefault()) {
        _impl_.description_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void Fingerprint_MachineCharacteristics_Plugin::set_allocated_description(std::string* description)
{
    if (description != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.description_.IsDefault()) {
        _impl_.description_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.description)
}

// repeated string mime_type = 3;
inline int Fingerprint_MachineCharacteristics_Plugin::_internal_mime_type_size() const
{
    return _impl_.mime_type_.size();
}
inline int Fingerprint_MachineCharacteristics_Plugin::mime_type_size() const
{
    return _internal_mime_type_size();
}
inline void Fingerprint_MachineCharacteristics_Plugin::clear_mime_type()
{
    _impl_.mime_type_.Clear();
}
inline std::string* Fingerprint_MachineCharacteristics_Plugin::add_mime_type()
{
    std::string* _s = _internal_add_mime_type();
    // @@protoc_insertion_point(field_add_mutable:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.mime_type)
    return _s;
}
inline const std::string& Fingerprint_MachineCharacteristics_Plugin::_internal_mime_type(int index) const
{
    return _impl_.mime_type_.Get(index);
}
inline const std::string& Fingerprint_MachineCharacteristics_Plugin::mime_type(int index) const
{
    // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.mime_type)
    return _internal_mime_type(index);
}
inline std::string* Fingerprint_MachineCharacteristics_Plugin::mutable_mime_type(int index)
{
    // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.mime_type)
    return _impl_.mime_type_.Mutable(index);
}
inline void Fingerprint_MachineCharacteristics_Plugin::set_mime_type(int index, const std::string& value)
{
    _impl_.mime_type_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.mime_type)
}
inline void Fingerprint_MachineCharacteristics_Plugin::set_mime_type(int index, std::string&& value)
{
    _impl_.mime_type_.Mutable(index)->assign(std::move(value));
    // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.mime_type)
}
inline void Fingerprint_MachineCharacteristics_Plugin::set_mime_type(int index, const char* value)
{
    GOOGLE_DCHECK(value != nullptr);
    _impl_.mime_type_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set_char:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.mime_type)
}
inline void Fingerprint_MachineCharacteristics_Plugin::set_mime_type(int index, const char* value, size_t size)
{
    _impl_.mime_type_.Mutable(index)->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.mime_type)
}
inline std::string* Fingerprint_MachineCharacteristics_Plugin::_internal_add_mime_type()
{
    return _impl_.mime_type_.Add();
}
inline void Fingerprint_MachineCharacteristics_Plugin::add_mime_type(const std::string& value)
{
    _impl_.mime_type_.Add()->assign(value);
    // @@protoc_insertion_point(field_add:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.mime_type)
}
inline void Fingerprint_MachineCharacteristics_Plugin::add_mime_type(std::string&& value)
{
    _impl_.mime_type_.Add(std::move(value));
    // @@protoc_insertion_point(field_add:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.mime_type)
}
inline void Fingerprint_MachineCharacteristics_Plugin::add_mime_type(const char* value)
{
    GOOGLE_DCHECK(value != nullptr);
    _impl_.mime_type_.Add()->assign(value);
    // @@protoc_insertion_point(field_add_char:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.mime_type)
}
inline void Fingerprint_MachineCharacteristics_Plugin::add_mime_type(const char* value, size_t size)
{
    _impl_.mime_type_.Add()->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_add_pointer:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.mime_type)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& Fingerprint_MachineCharacteristics_Plugin::mime_type() const
{
    // @@protoc_insertion_point(field_list:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.mime_type)
    return _impl_.mime_type_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* Fingerprint_MachineCharacteristics_Plugin::mutable_mime_type()
{
    // @@protoc_insertion_point(field_mutable_list:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.mime_type)
    return &_impl_.mime_type_;
}

// optional string version = 4;
inline bool Fingerprint_MachineCharacteristics_Plugin::_internal_has_version() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool Fingerprint_MachineCharacteristics_Plugin::has_version() const
{
    return _internal_has_version();
}
inline void Fingerprint_MachineCharacteristics_Plugin::clear_version()
{
    _impl_.version_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Fingerprint_MachineCharacteristics_Plugin::version() const
{
    // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.version)
    return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE void Fingerprint_MachineCharacteristics_Plugin::set_version(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.version_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.version)
}
inline std::string* Fingerprint_MachineCharacteristics_Plugin::mutable_version()
{
    std::string* _s = _internal_mutable_version();
    // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.version)
    return _s;
}
inline const std::string& Fingerprint_MachineCharacteristics_Plugin::_internal_version() const
{
    return _impl_.version_.Get();
}
inline void Fingerprint_MachineCharacteristics_Plugin::_internal_set_version(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* Fingerprint_MachineCharacteristics_Plugin::_internal_mutable_version()
{
    _impl_._has_bits_[0] |= 0x00000004u;
    return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* Fingerprint_MachineCharacteristics_Plugin::release_version()
{
    // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.version)
    if (!_internal_has_version()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000004u;
    auto* p = _impl_.version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.version_.IsDefault()) {
        _impl_.version_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void Fingerprint_MachineCharacteristics_Plugin::set_allocated_version(std::string* version)
{
    if (version != nullptr) {
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.version_.IsDefault()) {
        _impl_.version_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.Plugin.version)
}

// -------------------------------------------------------------------

// Fingerprint_MachineCharacteristics_Cpu

// optional string vendor_name = 1;
inline bool Fingerprint_MachineCharacteristics_Cpu::_internal_has_vendor_name() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool Fingerprint_MachineCharacteristics_Cpu::has_vendor_name() const
{
    return _internal_has_vendor_name();
}
inline void Fingerprint_MachineCharacteristics_Cpu::clear_vendor_name()
{
    _impl_.vendor_name_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Fingerprint_MachineCharacteristics_Cpu::vendor_name() const
{
    // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.Cpu.vendor_name)
    return _internal_vendor_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE void Fingerprint_MachineCharacteristics_Cpu::set_vendor_name(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.vendor_name_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.Cpu.vendor_name)
}
inline std::string* Fingerprint_MachineCharacteristics_Cpu::mutable_vendor_name()
{
    std::string* _s = _internal_mutable_vendor_name();
    // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.Cpu.vendor_name)
    return _s;
}
inline const std::string& Fingerprint_MachineCharacteristics_Cpu::_internal_vendor_name() const
{
    return _impl_.vendor_name_.Get();
}
inline void Fingerprint_MachineCharacteristics_Cpu::_internal_set_vendor_name(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.vendor_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Fingerprint_MachineCharacteristics_Cpu::_internal_mutable_vendor_name()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.vendor_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Fingerprint_MachineCharacteristics_Cpu::release_vendor_name()
{
    // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.MachineCharacteristics.Cpu.vendor_name)
    if (!_internal_has_vendor_name()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.vendor_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.vendor_name_.IsDefault()) {
        _impl_.vendor_name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void Fingerprint_MachineCharacteristics_Cpu::set_allocated_vendor_name(std::string* vendor_name)
{
    if (vendor_name != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.vendor_name_.SetAllocated(vendor_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.vendor_name_.IsDefault()) {
        _impl_.vendor_name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.Cpu.vendor_name)
}

// optional string brand = 2;
inline bool Fingerprint_MachineCharacteristics_Cpu::_internal_has_brand() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool Fingerprint_MachineCharacteristics_Cpu::has_brand() const
{
    return _internal_has_brand();
}
inline void Fingerprint_MachineCharacteristics_Cpu::clear_brand()
{
    _impl_.brand_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Fingerprint_MachineCharacteristics_Cpu::brand() const
{
    // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.Cpu.brand)
    return _internal_brand();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void Fingerprint_MachineCharacteristics_Cpu::set_brand(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.brand_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.Cpu.brand)
}
inline std::string* Fingerprint_MachineCharacteristics_Cpu::mutable_brand()
{
    std::string* _s = _internal_mutable_brand();
    // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.Cpu.brand)
    return _s;
}
inline const std::string& Fingerprint_MachineCharacteristics_Cpu::_internal_brand() const
{
    return _impl_.brand_.Get();
}
inline void Fingerprint_MachineCharacteristics_Cpu::_internal_set_brand(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.brand_.Set(value, GetArenaForAllocation());
}
inline std::string* Fingerprint_MachineCharacteristics_Cpu::_internal_mutable_brand()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.brand_.Mutable(GetArenaForAllocation());
}
inline std::string* Fingerprint_MachineCharacteristics_Cpu::release_brand()
{
    // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.MachineCharacteristics.Cpu.brand)
    if (!_internal_has_brand()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.brand_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.brand_.IsDefault()) {
        _impl_.brand_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void Fingerprint_MachineCharacteristics_Cpu::set_allocated_brand(std::string* brand)
{
    if (brand != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.brand_.SetAllocated(brand, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.brand_.IsDefault()) {
        _impl_.brand_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.Cpu.brand)
}

// -------------------------------------------------------------------

// Fingerprint_MachineCharacteristics_Graphics

// optional uint32 vendor_id = 1;
inline bool Fingerprint_MachineCharacteristics_Graphics::_internal_has_vendor_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool Fingerprint_MachineCharacteristics_Graphics::has_vendor_id() const
{
    return _internal_has_vendor_id();
}
inline void Fingerprint_MachineCharacteristics_Graphics::clear_vendor_id()
{
    _impl_.vendor_id_ = 0u;
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t Fingerprint_MachineCharacteristics_Graphics::_internal_vendor_id() const
{
    return _impl_.vendor_id_;
}
inline uint32_t Fingerprint_MachineCharacteristics_Graphics::vendor_id() const
{
    // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.Graphics.vendor_id)
    return _internal_vendor_id();
}
inline void Fingerprint_MachineCharacteristics_Graphics::_internal_set_vendor_id(uint32_t value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.vendor_id_ = value;
}
inline void Fingerprint_MachineCharacteristics_Graphics::set_vendor_id(uint32_t value)
{
    _internal_set_vendor_id(value);
    // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.Graphics.vendor_id)
}

// optional uint32 device_id = 2;
inline bool Fingerprint_MachineCharacteristics_Graphics::_internal_has_device_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    return value;
}
inline bool Fingerprint_MachineCharacteristics_Graphics::has_device_id() const
{
    return _internal_has_device_id();
}
inline void Fingerprint_MachineCharacteristics_Graphics::clear_device_id()
{
    _impl_.device_id_ = 0u;
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t Fingerprint_MachineCharacteristics_Graphics::_internal_device_id() const
{
    return _impl_.device_id_;
}
inline uint32_t Fingerprint_MachineCharacteristics_Graphics::device_id() const
{
    // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.Graphics.device_id)
    return _internal_device_id();
}
inline void Fingerprint_MachineCharacteristics_Graphics::_internal_set_device_id(uint32_t value)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.device_id_ = value;
}
inline void Fingerprint_MachineCharacteristics_Graphics::set_device_id(uint32_t value)
{
    _internal_set_device_id(value);
    // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.Graphics.device_id)
}

// optional string driver_version = 3;
inline bool Fingerprint_MachineCharacteristics_Graphics::_internal_has_driver_version() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool Fingerprint_MachineCharacteristics_Graphics::has_driver_version() const
{
    return _internal_has_driver_version();
}
inline void Fingerprint_MachineCharacteristics_Graphics::clear_driver_version()
{
    _impl_.driver_version_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Fingerprint_MachineCharacteristics_Graphics::driver_version() const
{
    // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.Graphics.driver_version)
    return _internal_driver_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE void Fingerprint_MachineCharacteristics_Graphics::set_driver_version(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.driver_version_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.Graphics.driver_version)
}
inline std::string* Fingerprint_MachineCharacteristics_Graphics::mutable_driver_version()
{
    std::string* _s = _internal_mutable_driver_version();
    // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.Graphics.driver_version)
    return _s;
}
inline const std::string& Fingerprint_MachineCharacteristics_Graphics::_internal_driver_version() const
{
    return _impl_.driver_version_.Get();
}
inline void Fingerprint_MachineCharacteristics_Graphics::_internal_set_driver_version(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.driver_version_.Set(value, GetArenaForAllocation());
}
inline std::string* Fingerprint_MachineCharacteristics_Graphics::_internal_mutable_driver_version()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.driver_version_.Mutable(GetArenaForAllocation());
}
inline std::string* Fingerprint_MachineCharacteristics_Graphics::release_driver_version()
{
    // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.MachineCharacteristics.Graphics.driver_version)
    if (!_internal_has_driver_version()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.driver_version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.driver_version_.IsDefault()) {
        _impl_.driver_version_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void Fingerprint_MachineCharacteristics_Graphics::set_allocated_driver_version(std::string* driver_version)
{
    if (driver_version != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.driver_version_.SetAllocated(driver_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.driver_version_.IsDefault()) {
        _impl_.driver_version_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.Graphics.driver_version)
}

// optional string driver_date = 4;
inline bool Fingerprint_MachineCharacteristics_Graphics::_internal_has_driver_date() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool Fingerprint_MachineCharacteristics_Graphics::has_driver_date() const
{
    return _internal_has_driver_date();
}
inline void Fingerprint_MachineCharacteristics_Graphics::clear_driver_date()
{
    _impl_.driver_date_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Fingerprint_MachineCharacteristics_Graphics::driver_date() const
{
    // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.Graphics.driver_date)
    return _internal_driver_date();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE void Fingerprint_MachineCharacteristics_Graphics::set_driver_date(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.driver_date_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.Graphics.driver_date)
}
inline std::string* Fingerprint_MachineCharacteristics_Graphics::mutable_driver_date()
{
    std::string* _s = _internal_mutable_driver_date();
    // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.Graphics.driver_date)
    return _s;
}
inline const std::string& Fingerprint_MachineCharacteristics_Graphics::_internal_driver_date() const
{
    return _impl_.driver_date_.Get();
}
inline void Fingerprint_MachineCharacteristics_Graphics::_internal_set_driver_date(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.driver_date_.Set(value, GetArenaForAllocation());
}
inline std::string* Fingerprint_MachineCharacteristics_Graphics::_internal_mutable_driver_date()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.driver_date_.Mutable(GetArenaForAllocation());
}
inline std::string* Fingerprint_MachineCharacteristics_Graphics::release_driver_date()
{
    // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.MachineCharacteristics.Graphics.driver_date)
    if (!_internal_has_driver_date()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.driver_date_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.driver_date_.IsDefault()) {
        _impl_.driver_date_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void Fingerprint_MachineCharacteristics_Graphics::set_allocated_driver_date(std::string* driver_date)
{
    if (driver_date != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.driver_date_.SetAllocated(driver_date, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.driver_date_.IsDefault()) {
        _impl_.driver_date_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.Graphics.driver_date)
}

// -------------------------------------------------------------------

// Fingerprint_MachineCharacteristics

// optional fixed64 user_and_device_name_hash = 1;
inline bool Fingerprint_MachineCharacteristics::_internal_has_user_and_device_name_hash() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
    return value;
}
inline bool Fingerprint_MachineCharacteristics::has_user_and_device_name_hash() const
{
    return _internal_has_user_and_device_name_hash();
}
inline void Fingerprint_MachineCharacteristics::clear_user_and_device_name_hash()
{
    _impl_.user_and_device_name_hash_ = uint64_t { 0u };
    _impl_._has_bits_[0] &= ~0x00000200u;
}
inline uint64_t Fingerprint_MachineCharacteristics::_internal_user_and_device_name_hash() const
{
    return _impl_.user_and_device_name_hash_;
}
inline uint64_t Fingerprint_MachineCharacteristics::user_and_device_name_hash() const
{
    // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.user_and_device_name_hash)
    return _internal_user_and_device_name_hash();
}
inline void Fingerprint_MachineCharacteristics::_internal_set_user_and_device_name_hash(uint64_t value)
{
    _impl_._has_bits_[0] |= 0x00000200u;
    _impl_.user_and_device_name_hash_ = value;
}
inline void Fingerprint_MachineCharacteristics::set_user_and_device_name_hash(uint64_t value)
{
    _internal_set_user_and_device_name_hash(value);
    // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.user_and_device_name_hash)
}

// optional string operating_system_build = 2;
inline bool Fingerprint_MachineCharacteristics::_internal_has_operating_system_build() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool Fingerprint_MachineCharacteristics::has_operating_system_build() const
{
    return _internal_has_operating_system_build();
}
inline void Fingerprint_MachineCharacteristics::clear_operating_system_build()
{
    _impl_.operating_system_build_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Fingerprint_MachineCharacteristics::operating_system_build() const
{
    // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.operating_system_build)
    return _internal_operating_system_build();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE void Fingerprint_MachineCharacteristics::set_operating_system_build(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.operating_system_build_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.operating_system_build)
}
inline std::string* Fingerprint_MachineCharacteristics::mutable_operating_system_build()
{
    std::string* _s = _internal_mutable_operating_system_build();
    // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.operating_system_build)
    return _s;
}
inline const std::string& Fingerprint_MachineCharacteristics::_internal_operating_system_build() const
{
    return _impl_.operating_system_build_.Get();
}
inline void Fingerprint_MachineCharacteristics::_internal_set_operating_system_build(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.operating_system_build_.Set(value, GetArenaForAllocation());
}
inline std::string* Fingerprint_MachineCharacteristics::_internal_mutable_operating_system_build()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.operating_system_build_.Mutable(GetArenaForAllocation());
}
inline std::string* Fingerprint_MachineCharacteristics::release_operating_system_build()
{
    // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.MachineCharacteristics.operating_system_build)
    if (!_internal_has_operating_system_build()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.operating_system_build_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.operating_system_build_.IsDefault()) {
        _impl_.operating_system_build_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void Fingerprint_MachineCharacteristics::set_allocated_operating_system_build(std::string* operating_system_build)
{
    if (operating_system_build != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.operating_system_build_.SetAllocated(operating_system_build, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.operating_system_build_.IsDefault()) {
        _impl_.operating_system_build_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.operating_system_build)
}

// optional int64 browser_install_time_hours = 3;
inline bool Fingerprint_MachineCharacteristics::_internal_has_browser_install_time_hours() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
    return value;
}
inline bool Fingerprint_MachineCharacteristics::has_browser_install_time_hours() const
{
    return _internal_has_browser_install_time_hours();
}
inline void Fingerprint_MachineCharacteristics::clear_browser_install_time_hours()
{
    _impl_.browser_install_time_hours_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000400u;
}
inline int64_t Fingerprint_MachineCharacteristics::_internal_browser_install_time_hours() const
{
    return _impl_.browser_install_time_hours_;
}
inline int64_t Fingerprint_MachineCharacteristics::browser_install_time_hours() const
{
    // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.browser_install_time_hours)
    return _internal_browser_install_time_hours();
}
inline void Fingerprint_MachineCharacteristics::_internal_set_browser_install_time_hours(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000400u;
    _impl_.browser_install_time_hours_ = value;
}
inline void Fingerprint_MachineCharacteristics::set_browser_install_time_hours(int64_t value)
{
    _internal_set_browser_install_time_hours(value);
    // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.browser_install_time_hours)
}

// repeated string font = 4;
inline int Fingerprint_MachineCharacteristics::_internal_font_size() const
{
    return _impl_.font_.size();
}
inline int Fingerprint_MachineCharacteristics::font_size() const
{
    return _internal_font_size();
}
inline void Fingerprint_MachineCharacteristics::clear_font()
{
    _impl_.font_.Clear();
}
inline std::string* Fingerprint_MachineCharacteristics::add_font()
{
    std::string* _s = _internal_add_font();
    // @@protoc_insertion_point(field_add_mutable:autofill.risk.Fingerprint.MachineCharacteristics.font)
    return _s;
}
inline const std::string& Fingerprint_MachineCharacteristics::_internal_font(int index) const
{
    return _impl_.font_.Get(index);
}
inline const std::string& Fingerprint_MachineCharacteristics::font(int index) const
{
    // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.font)
    return _internal_font(index);
}
inline std::string* Fingerprint_MachineCharacteristics::mutable_font(int index)
{
    // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.font)
    return _impl_.font_.Mutable(index);
}
inline void Fingerprint_MachineCharacteristics::set_font(int index, const std::string& value)
{
    _impl_.font_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.font)
}
inline void Fingerprint_MachineCharacteristics::set_font(int index, std::string&& value)
{
    _impl_.font_.Mutable(index)->assign(std::move(value));
    // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.font)
}
inline void Fingerprint_MachineCharacteristics::set_font(int index, const char* value)
{
    GOOGLE_DCHECK(value != nullptr);
    _impl_.font_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set_char:autofill.risk.Fingerprint.MachineCharacteristics.font)
}
inline void Fingerprint_MachineCharacteristics::set_font(int index, const char* value, size_t size)
{
    _impl_.font_.Mutable(index)->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:autofill.risk.Fingerprint.MachineCharacteristics.font)
}
inline std::string* Fingerprint_MachineCharacteristics::_internal_add_font()
{
    return _impl_.font_.Add();
}
inline void Fingerprint_MachineCharacteristics::add_font(const std::string& value)
{
    _impl_.font_.Add()->assign(value);
    // @@protoc_insertion_point(field_add:autofill.risk.Fingerprint.MachineCharacteristics.font)
}
inline void Fingerprint_MachineCharacteristics::add_font(std::string&& value)
{
    _impl_.font_.Add(std::move(value));
    // @@protoc_insertion_point(field_add:autofill.risk.Fingerprint.MachineCharacteristics.font)
}
inline void Fingerprint_MachineCharacteristics::add_font(const char* value)
{
    GOOGLE_DCHECK(value != nullptr);
    _impl_.font_.Add()->assign(value);
    // @@protoc_insertion_point(field_add_char:autofill.risk.Fingerprint.MachineCharacteristics.font)
}
inline void Fingerprint_MachineCharacteristics::add_font(const char* value, size_t size)
{
    _impl_.font_.Add()->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_add_pointer:autofill.risk.Fingerprint.MachineCharacteristics.font)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& Fingerprint_MachineCharacteristics::font() const
{
    // @@protoc_insertion_point(field_list:autofill.risk.Fingerprint.MachineCharacteristics.font)
    return _impl_.font_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* Fingerprint_MachineCharacteristics::mutable_font()
{
    // @@protoc_insertion_point(field_mutable_list:autofill.risk.Fingerprint.MachineCharacteristics.font)
    return &_impl_.font_;
}

// repeated .autofill.risk.Fingerprint.MachineCharacteristics.Plugin plugin = 5;
inline int Fingerprint_MachineCharacteristics::_internal_plugin_size() const
{
    return _impl_.plugin_.size();
}
inline int Fingerprint_MachineCharacteristics::plugin_size() const
{
    return _internal_plugin_size();
}
inline void Fingerprint_MachineCharacteristics::clear_plugin()
{
    _impl_.plugin_.Clear();
}
inline ::autofill::risk::Fingerprint_MachineCharacteristics_Plugin* Fingerprint_MachineCharacteristics::mutable_plugin(int index)
{
    // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.plugin)
    return _impl_.plugin_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::autofill::risk::Fingerprint_MachineCharacteristics_Plugin>*
Fingerprint_MachineCharacteristics::mutable_plugin()
{
    // @@protoc_insertion_point(field_mutable_list:autofill.risk.Fingerprint.MachineCharacteristics.plugin)
    return &_impl_.plugin_;
}
inline const ::autofill::risk::Fingerprint_MachineCharacteristics_Plugin& Fingerprint_MachineCharacteristics::_internal_plugin(int index) const
{
    return _impl_.plugin_.Get(index);
}
inline const ::autofill::risk::Fingerprint_MachineCharacteristics_Plugin& Fingerprint_MachineCharacteristics::plugin(int index) const
{
    // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.plugin)
    return _internal_plugin(index);
}
inline ::autofill::risk::Fingerprint_MachineCharacteristics_Plugin* Fingerprint_MachineCharacteristics::_internal_add_plugin()
{
    return _impl_.plugin_.Add();
}
inline ::autofill::risk::Fingerprint_MachineCharacteristics_Plugin* Fingerprint_MachineCharacteristics::add_plugin()
{
    ::autofill::risk::Fingerprint_MachineCharacteristics_Plugin* _add = _internal_add_plugin();
    // @@protoc_insertion_point(field_add:autofill.risk.Fingerprint.MachineCharacteristics.plugin)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::autofill::risk::Fingerprint_MachineCharacteristics_Plugin>&
Fingerprint_MachineCharacteristics::plugin() const
{
    // @@protoc_insertion_point(field_list:autofill.risk.Fingerprint.MachineCharacteristics.plugin)
    return _impl_.plugin_;
}

// optional int64 utc_offset_ms = 6;
inline bool Fingerprint_MachineCharacteristics::_internal_has_utc_offset_ms() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
    return value;
}
inline bool Fingerprint_MachineCharacteristics::has_utc_offset_ms() const
{
    return _internal_has_utc_offset_ms();
}
inline void Fingerprint_MachineCharacteristics::clear_utc_offset_ms()
{
    _impl_.utc_offset_ms_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000800u;
}
inline int64_t Fingerprint_MachineCharacteristics::_internal_utc_offset_ms() const
{
    return _impl_.utc_offset_ms_;
}
inline int64_t Fingerprint_MachineCharacteristics::utc_offset_ms() const
{
    // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.utc_offset_ms)
    return _internal_utc_offset_ms();
}
inline void Fingerprint_MachineCharacteristics::_internal_set_utc_offset_ms(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000800u;
    _impl_.utc_offset_ms_ = value;
}
inline void Fingerprint_MachineCharacteristics::set_utc_offset_ms(int64_t value)
{
    _internal_set_utc_offset_ms(value);
    // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.utc_offset_ms)
}

// optional string browser_language = 7;
inline bool Fingerprint_MachineCharacteristics::_internal_has_browser_language() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool Fingerprint_MachineCharacteristics::has_browser_language() const
{
    return _internal_has_browser_language();
}
inline void Fingerprint_MachineCharacteristics::clear_browser_language()
{
    _impl_.browser_language_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Fingerprint_MachineCharacteristics::browser_language() const
{
    // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.browser_language)
    return _internal_browser_language();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE void Fingerprint_MachineCharacteristics::set_browser_language(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.browser_language_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.browser_language)
}
inline std::string* Fingerprint_MachineCharacteristics::mutable_browser_language()
{
    std::string* _s = _internal_mutable_browser_language();
    // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.browser_language)
    return _s;
}
inline const std::string& Fingerprint_MachineCharacteristics::_internal_browser_language() const
{
    return _impl_.browser_language_.Get();
}
inline void Fingerprint_MachineCharacteristics::_internal_set_browser_language(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.browser_language_.Set(value, GetArenaForAllocation());
}
inline std::string* Fingerprint_MachineCharacteristics::_internal_mutable_browser_language()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.browser_language_.Mutable(GetArenaForAllocation());
}
inline std::string* Fingerprint_MachineCharacteristics::release_browser_language()
{
    // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.MachineCharacteristics.browser_language)
    if (!_internal_has_browser_language()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.browser_language_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.browser_language_.IsDefault()) {
        _impl_.browser_language_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void Fingerprint_MachineCharacteristics::set_allocated_browser_language(std::string* browser_language)
{
    if (browser_language != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.browser_language_.SetAllocated(browser_language, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.browser_language_.IsDefault()) {
        _impl_.browser_language_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.browser_language)
}

// repeated string requested_language = 8;
inline int Fingerprint_MachineCharacteristics::_internal_requested_language_size() const
{
    return _impl_.requested_language_.size();
}
inline int Fingerprint_MachineCharacteristics::requested_language_size() const
{
    return _internal_requested_language_size();
}
inline void Fingerprint_MachineCharacteristics::clear_requested_language()
{
    _impl_.requested_language_.Clear();
}
inline std::string* Fingerprint_MachineCharacteristics::add_requested_language()
{
    std::string* _s = _internal_add_requested_language();
    // @@protoc_insertion_point(field_add_mutable:autofill.risk.Fingerprint.MachineCharacteristics.requested_language)
    return _s;
}
inline const std::string& Fingerprint_MachineCharacteristics::_internal_requested_language(int index) const
{
    return _impl_.requested_language_.Get(index);
}
inline const std::string& Fingerprint_MachineCharacteristics::requested_language(int index) const
{
    // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.requested_language)
    return _internal_requested_language(index);
}
inline std::string* Fingerprint_MachineCharacteristics::mutable_requested_language(int index)
{
    // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.requested_language)
    return _impl_.requested_language_.Mutable(index);
}
inline void Fingerprint_MachineCharacteristics::set_requested_language(int index, const std::string& value)
{
    _impl_.requested_language_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.requested_language)
}
inline void Fingerprint_MachineCharacteristics::set_requested_language(int index, std::string&& value)
{
    _impl_.requested_language_.Mutable(index)->assign(std::move(value));
    // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.requested_language)
}
inline void Fingerprint_MachineCharacteristics::set_requested_language(int index, const char* value)
{
    GOOGLE_DCHECK(value != nullptr);
    _impl_.requested_language_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set_char:autofill.risk.Fingerprint.MachineCharacteristics.requested_language)
}
inline void Fingerprint_MachineCharacteristics::set_requested_language(int index, const char* value, size_t size)
{
    _impl_.requested_language_.Mutable(index)->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:autofill.risk.Fingerprint.MachineCharacteristics.requested_language)
}
inline std::string* Fingerprint_MachineCharacteristics::_internal_add_requested_language()
{
    return _impl_.requested_language_.Add();
}
inline void Fingerprint_MachineCharacteristics::add_requested_language(const std::string& value)
{
    _impl_.requested_language_.Add()->assign(value);
    // @@protoc_insertion_point(field_add:autofill.risk.Fingerprint.MachineCharacteristics.requested_language)
}
inline void Fingerprint_MachineCharacteristics::add_requested_language(std::string&& value)
{
    _impl_.requested_language_.Add(std::move(value));
    // @@protoc_insertion_point(field_add:autofill.risk.Fingerprint.MachineCharacteristics.requested_language)
}
inline void Fingerprint_MachineCharacteristics::add_requested_language(const char* value)
{
    GOOGLE_DCHECK(value != nullptr);
    _impl_.requested_language_.Add()->assign(value);
    // @@protoc_insertion_point(field_add_char:autofill.risk.Fingerprint.MachineCharacteristics.requested_language)
}
inline void Fingerprint_MachineCharacteristics::add_requested_language(const char* value, size_t size)
{
    _impl_.requested_language_.Add()->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_add_pointer:autofill.risk.Fingerprint.MachineCharacteristics.requested_language)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& Fingerprint_MachineCharacteristics::requested_language() const
{
    // @@protoc_insertion_point(field_list:autofill.risk.Fingerprint.MachineCharacteristics.requested_language)
    return _impl_.requested_language_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* Fingerprint_MachineCharacteristics::mutable_requested_language()
{
    // @@protoc_insertion_point(field_mutable_list:autofill.risk.Fingerprint.MachineCharacteristics.requested_language)
    return &_impl_.requested_language_;
}

// optional string charset = 9;
inline bool Fingerprint_MachineCharacteristics::_internal_has_charset() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool Fingerprint_MachineCharacteristics::has_charset() const
{
    return _internal_has_charset();
}
inline void Fingerprint_MachineCharacteristics::clear_charset()
{
    _impl_.charset_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Fingerprint_MachineCharacteristics::charset() const
{
    // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.charset)
    return _internal_charset();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void Fingerprint_MachineCharacteristics::set_charset(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.charset_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.charset)
}
inline std::string* Fingerprint_MachineCharacteristics::mutable_charset()
{
    std::string* _s = _internal_mutable_charset();
    // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.charset)
    return _s;
}
inline const std::string& Fingerprint_MachineCharacteristics::_internal_charset() const
{
    return _impl_.charset_.Get();
}
inline void Fingerprint_MachineCharacteristics::_internal_set_charset(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.charset_.Set(value, GetArenaForAllocation());
}
inline std::string* Fingerprint_MachineCharacteristics::_internal_mutable_charset()
{
    _impl_._has_bits_[0] |= 0x00000004u;
    return _impl_.charset_.Mutable(GetArenaForAllocation());
}
inline std::string* Fingerprint_MachineCharacteristics::release_charset()
{
    // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.MachineCharacteristics.charset)
    if (!_internal_has_charset()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000004u;
    auto* p = _impl_.charset_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.charset_.IsDefault()) {
        _impl_.charset_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void Fingerprint_MachineCharacteristics::set_allocated_charset(std::string* charset)
{
    if (charset != nullptr) {
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    _impl_.charset_.SetAllocated(charset, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.charset_.IsDefault()) {
        _impl_.charset_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.charset)
}

// optional int32 screen_count = 10;
inline bool Fingerprint_MachineCharacteristics::_internal_has_screen_count() const
{
    bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
    return value;
}
inline bool Fingerprint_MachineCharacteristics::has_screen_count() const
{
    return _internal_has_screen_count();
}
inline void Fingerprint_MachineCharacteristics::clear_screen_count()
{
    _impl_.screen_count_ = 0;
    _impl_._has_bits_[0] &= ~0x00001000u;
}
inline int32_t Fingerprint_MachineCharacteristics::_internal_screen_count() const
{
    return _impl_.screen_count_;
}
inline int32_t Fingerprint_MachineCharacteristics::screen_count() const
{
    // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.screen_count)
    return _internal_screen_count();
}
inline void Fingerprint_MachineCharacteristics::_internal_set_screen_count(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00001000u;
    _impl_.screen_count_ = value;
}
inline void Fingerprint_MachineCharacteristics::set_screen_count(int32_t value)
{
    _internal_set_screen_count(value);
    // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.screen_count)
}

// optional .autofill.risk.Fingerprint.Dimension screen_size = 11;
inline bool Fingerprint_MachineCharacteristics::_internal_has_screen_size() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.screen_size_ != nullptr);
    return value;
}
inline bool Fingerprint_MachineCharacteristics::has_screen_size() const
{
    return _internal_has_screen_size();
}
inline void Fingerprint_MachineCharacteristics::clear_screen_size()
{
    if (_impl_.screen_size_ != nullptr)
        _impl_.screen_size_->Clear();
    _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::autofill::risk::Fingerprint_Dimension& Fingerprint_MachineCharacteristics::_internal_screen_size() const
{
    const ::autofill::risk::Fingerprint_Dimension* p = _impl_.screen_size_;
    return p != nullptr ? *p : reinterpret_cast<const ::autofill::risk::Fingerprint_Dimension&>(::autofill::risk::_Fingerprint_Dimension_default_instance_);
}
inline const ::autofill::risk::Fingerprint_Dimension& Fingerprint_MachineCharacteristics::screen_size() const
{
    // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.screen_size)
    return _internal_screen_size();
}
inline void Fingerprint_MachineCharacteristics::unsafe_arena_set_allocated_screen_size(::autofill::risk::Fingerprint_Dimension* screen_size)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.screen_size_);
    }
    _impl_.screen_size_ = screen_size;
    if (screen_size) {
        _impl_._has_bits_[0] |= 0x00000020u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000020u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.screen_size)
}
inline ::autofill::risk::Fingerprint_Dimension* Fingerprint_MachineCharacteristics::release_screen_size()
{
    _impl_._has_bits_[0] &= ~0x00000020u;
    ::autofill::risk::Fingerprint_Dimension* temp = _impl_.screen_size_;
    _impl_.screen_size_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::autofill::risk::Fingerprint_Dimension* Fingerprint_MachineCharacteristics::unsafe_arena_release_screen_size()
{
    // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.MachineCharacteristics.screen_size)
    _impl_._has_bits_[0] &= ~0x00000020u;
    ::autofill::risk::Fingerprint_Dimension* temp = _impl_.screen_size_;
    _impl_.screen_size_ = nullptr;
    return temp;
}
inline ::autofill::risk::Fingerprint_Dimension* Fingerprint_MachineCharacteristics::_internal_mutable_screen_size()
{
    _impl_._has_bits_[0] |= 0x00000020u;
    if (_impl_.screen_size_ == nullptr) {
        auto* p = CreateMaybeMessage<::autofill::risk::Fingerprint_Dimension>(GetArenaForAllocation());
        _impl_.screen_size_ = p;
    }
    return _impl_.screen_size_;
}
inline ::autofill::risk::Fingerprint_Dimension* Fingerprint_MachineCharacteristics::mutable_screen_size()
{
    ::autofill::risk::Fingerprint_Dimension* _msg = _internal_mutable_screen_size();
    // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.screen_size)
    return _msg;
}
inline void Fingerprint_MachineCharacteristics::set_allocated_screen_size(::autofill::risk::Fingerprint_Dimension* screen_size)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.screen_size_;
    }
    if (screen_size) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(screen_size);
        if (message_arena != submessage_arena) {
            screen_size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, screen_size, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000020u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000020u;
    }
    _impl_.screen_size_ = screen_size;
    // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.screen_size)
}

// optional int32 screen_color_depth = 12;
inline bool Fingerprint_MachineCharacteristics::_internal_has_screen_color_depth() const
{
    bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
    return value;
}
inline bool Fingerprint_MachineCharacteristics::has_screen_color_depth() const
{
    return _internal_has_screen_color_depth();
}
inline void Fingerprint_MachineCharacteristics::clear_screen_color_depth()
{
    _impl_.screen_color_depth_ = 0;
    _impl_._has_bits_[0] &= ~0x00002000u;
}
inline int32_t Fingerprint_MachineCharacteristics::_internal_screen_color_depth() const
{
    return _impl_.screen_color_depth_;
}
inline int32_t Fingerprint_MachineCharacteristics::screen_color_depth() const
{
    // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.screen_color_depth)
    return _internal_screen_color_depth();
}
inline void Fingerprint_MachineCharacteristics::_internal_set_screen_color_depth(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00002000u;
    _impl_.screen_color_depth_ = value;
}
inline void Fingerprint_MachineCharacteristics::set_screen_color_depth(int32_t value)
{
    _internal_set_screen_color_depth(value);
    // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.screen_color_depth)
}

// optional .autofill.risk.Fingerprint.Dimension unavailable_screen_size = 13;
inline bool Fingerprint_MachineCharacteristics::_internal_has_unavailable_screen_size() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.unavailable_screen_size_ != nullptr);
    return value;
}
inline bool Fingerprint_MachineCharacteristics::has_unavailable_screen_size() const
{
    return _internal_has_unavailable_screen_size();
}
inline void Fingerprint_MachineCharacteristics::clear_unavailable_screen_size()
{
    if (_impl_.unavailable_screen_size_ != nullptr)
        _impl_.unavailable_screen_size_->Clear();
    _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::autofill::risk::Fingerprint_Dimension& Fingerprint_MachineCharacteristics::_internal_unavailable_screen_size() const
{
    const ::autofill::risk::Fingerprint_Dimension* p = _impl_.unavailable_screen_size_;
    return p != nullptr ? *p : reinterpret_cast<const ::autofill::risk::Fingerprint_Dimension&>(::autofill::risk::_Fingerprint_Dimension_default_instance_);
}
inline const ::autofill::risk::Fingerprint_Dimension& Fingerprint_MachineCharacteristics::unavailable_screen_size() const
{
    // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.unavailable_screen_size)
    return _internal_unavailable_screen_size();
}
inline void Fingerprint_MachineCharacteristics::unsafe_arena_set_allocated_unavailable_screen_size(
    ::autofill::risk::Fingerprint_Dimension* unavailable_screen_size)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.unavailable_screen_size_);
    }
    _impl_.unavailable_screen_size_ = unavailable_screen_size;
    if (unavailable_screen_size) {
        _impl_._has_bits_[0] |= 0x00000040u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000040u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.unavailable_screen_size)
}
inline ::autofill::risk::Fingerprint_Dimension* Fingerprint_MachineCharacteristics::release_unavailable_screen_size()
{
    _impl_._has_bits_[0] &= ~0x00000040u;
    ::autofill::risk::Fingerprint_Dimension* temp = _impl_.unavailable_screen_size_;
    _impl_.unavailable_screen_size_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::autofill::risk::Fingerprint_Dimension* Fingerprint_MachineCharacteristics::unsafe_arena_release_unavailable_screen_size()
{
    // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.MachineCharacteristics.unavailable_screen_size)
    _impl_._has_bits_[0] &= ~0x00000040u;
    ::autofill::risk::Fingerprint_Dimension* temp = _impl_.unavailable_screen_size_;
    _impl_.unavailable_screen_size_ = nullptr;
    return temp;
}
inline ::autofill::risk::Fingerprint_Dimension* Fingerprint_MachineCharacteristics::_internal_mutable_unavailable_screen_size()
{
    _impl_._has_bits_[0] |= 0x00000040u;
    if (_impl_.unavailable_screen_size_ == nullptr) {
        auto* p = CreateMaybeMessage<::autofill::risk::Fingerprint_Dimension>(GetArenaForAllocation());
        _impl_.unavailable_screen_size_ = p;
    }
    return _impl_.unavailable_screen_size_;
}
inline ::autofill::risk::Fingerprint_Dimension* Fingerprint_MachineCharacteristics::mutable_unavailable_screen_size()
{
    ::autofill::risk::Fingerprint_Dimension* _msg = _internal_mutable_unavailable_screen_size();
    // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.unavailable_screen_size)
    return _msg;
}
inline void Fingerprint_MachineCharacteristics::set_allocated_unavailable_screen_size(::autofill::risk::Fingerprint_Dimension* unavailable_screen_size)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.unavailable_screen_size_;
    }
    if (unavailable_screen_size) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(unavailable_screen_size);
        if (message_arena != submessage_arena) {
            unavailable_screen_size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, unavailable_screen_size, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000040u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000040u;
    }
    _impl_.unavailable_screen_size_ = unavailable_screen_size;
    // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.unavailable_screen_size)
}

// optional string user_agent = 14;
inline bool Fingerprint_MachineCharacteristics::_internal_has_user_agent() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    return value;
}
inline bool Fingerprint_MachineCharacteristics::has_user_agent() const
{
    return _internal_has_user_agent();
}
inline void Fingerprint_MachineCharacteristics::clear_user_agent()
{
    _impl_.user_agent_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& Fingerprint_MachineCharacteristics::user_agent() const
{
    // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.user_agent)
    return _internal_user_agent();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void Fingerprint_MachineCharacteristics::set_user_agent(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.user_agent_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.user_agent)
}
inline std::string* Fingerprint_MachineCharacteristics::mutable_user_agent()
{
    std::string* _s = _internal_mutable_user_agent();
    // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.user_agent)
    return _s;
}
inline const std::string& Fingerprint_MachineCharacteristics::_internal_user_agent() const
{
    return _impl_.user_agent_.Get();
}
inline void Fingerprint_MachineCharacteristics::_internal_set_user_agent(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.user_agent_.Set(value, GetArenaForAllocation());
}
inline std::string* Fingerprint_MachineCharacteristics::_internal_mutable_user_agent()
{
    _impl_._has_bits_[0] |= 0x00000008u;
    return _impl_.user_agent_.Mutable(GetArenaForAllocation());
}
inline std::string* Fingerprint_MachineCharacteristics::release_user_agent()
{
    // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.MachineCharacteristics.user_agent)
    if (!_internal_has_user_agent()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000008u;
    auto* p = _impl_.user_agent_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.user_agent_.IsDefault()) {
        _impl_.user_agent_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void Fingerprint_MachineCharacteristics::set_allocated_user_agent(std::string* user_agent)
{
    if (user_agent != nullptr) {
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    _impl_.user_agent_.SetAllocated(user_agent, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.user_agent_.IsDefault()) {
        _impl_.user_agent_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.user_agent)
}

// repeated int32 partition_size = 15;
inline int Fingerprint_MachineCharacteristics::_internal_partition_size_size() const
{
    return _impl_.partition_size_.size();
}
inline int Fingerprint_MachineCharacteristics::partition_size_size() const
{
    return _internal_partition_size_size();
}
inline void Fingerprint_MachineCharacteristics::clear_partition_size()
{
    _impl_.partition_size_.Clear();
}
inline int32_t Fingerprint_MachineCharacteristics::_internal_partition_size(int index) const
{
    return _impl_.partition_size_.Get(index);
}
inline int32_t Fingerprint_MachineCharacteristics::partition_size(int index) const
{
    // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.partition_size)
    return _internal_partition_size(index);
}
inline void Fingerprint_MachineCharacteristics::set_partition_size(int index, int32_t value)
{
    _impl_.partition_size_.Set(index, value);
    // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.partition_size)
}
inline void Fingerprint_MachineCharacteristics::_internal_add_partition_size(int32_t value)
{
    _impl_.partition_size_.Add(value);
}
inline void Fingerprint_MachineCharacteristics::add_partition_size(int32_t value)
{
    _internal_add_partition_size(value);
    // @@protoc_insertion_point(field_add:autofill.risk.Fingerprint.MachineCharacteristics.partition_size)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>& Fingerprint_MachineCharacteristics::_internal_partition_size() const
{
    return _impl_.partition_size_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>& Fingerprint_MachineCharacteristics::partition_size() const
{
    // @@protoc_insertion_point(field_list:autofill.risk.Fingerprint.MachineCharacteristics.partition_size)
    return _internal_partition_size();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>* Fingerprint_MachineCharacteristics::_internal_mutable_partition_size()
{
    return &_impl_.partition_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>* Fingerprint_MachineCharacteristics::mutable_partition_size()
{
    // @@protoc_insertion_point(field_mutable_list:autofill.risk.Fingerprint.MachineCharacteristics.partition_size)
    return _internal_mutable_partition_size();
}

// optional .autofill.risk.Fingerprint.MachineCharacteristics.Cpu cpu = 16;
inline bool Fingerprint_MachineCharacteristics::_internal_has_cpu() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.cpu_ != nullptr);
    return value;
}
inline bool Fingerprint_MachineCharacteristics::has_cpu() const
{
    return _internal_has_cpu();
}
inline void Fingerprint_MachineCharacteristics::clear_cpu()
{
    if (_impl_.cpu_ != nullptr)
        _impl_.cpu_->Clear();
    _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu& Fingerprint_MachineCharacteristics::_internal_cpu() const
{
    const ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu* p = _impl_.cpu_;
    return p != nullptr ? *p
                        : reinterpret_cast<const ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu&>(
                            ::autofill::risk::_Fingerprint_MachineCharacteristics_Cpu_default_instance_);
}
inline const ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu& Fingerprint_MachineCharacteristics::cpu() const
{
    // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.cpu)
    return _internal_cpu();
}
inline void Fingerprint_MachineCharacteristics::unsafe_arena_set_allocated_cpu(::autofill::risk::Fingerprint_MachineCharacteristics_Cpu* cpu)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cpu_);
    }
    _impl_.cpu_ = cpu;
    if (cpu) {
        _impl_._has_bits_[0] |= 0x00000080u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000080u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.cpu)
}
inline ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu* Fingerprint_MachineCharacteristics::release_cpu()
{
    _impl_._has_bits_[0] &= ~0x00000080u;
    ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu* temp = _impl_.cpu_;
    _impl_.cpu_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu* Fingerprint_MachineCharacteristics::unsafe_arena_release_cpu()
{
    // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.MachineCharacteristics.cpu)
    _impl_._has_bits_[0] &= ~0x00000080u;
    ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu* temp = _impl_.cpu_;
    _impl_.cpu_ = nullptr;
    return temp;
}
inline ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu* Fingerprint_MachineCharacteristics::_internal_mutable_cpu()
{
    _impl_._has_bits_[0] |= 0x00000080u;
    if (_impl_.cpu_ == nullptr) {
        auto* p = CreateMaybeMessage<::autofill::risk::Fingerprint_MachineCharacteristics_Cpu>(GetArenaForAllocation());
        _impl_.cpu_ = p;
    }
    return _impl_.cpu_;
}
inline ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu* Fingerprint_MachineCharacteristics::mutable_cpu()
{
    ::autofill::risk::Fingerprint_MachineCharacteristics_Cpu* _msg = _internal_mutable_cpu();
    // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.cpu)
    return _msg;
}
inline void Fingerprint_MachineCharacteristics::set_allocated_cpu(::autofill::risk::Fingerprint_MachineCharacteristics_Cpu* cpu)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.cpu_;
    }
    if (cpu) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cpu);
        if (message_arena != submessage_arena) {
            cpu = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, cpu, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000080u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000080u;
    }
    _impl_.cpu_ = cpu;
    // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.cpu)
}

// optional int64 ram = 17;
inline bool Fingerprint_MachineCharacteristics::_internal_has_ram() const
{
    bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
    return value;
}
inline bool Fingerprint_MachineCharacteristics::has_ram() const
{
    return _internal_has_ram();
}
inline void Fingerprint_MachineCharacteristics::clear_ram()
{
    _impl_.ram_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00004000u;
}
inline int64_t Fingerprint_MachineCharacteristics::_internal_ram() const
{
    return _impl_.ram_;
}
inline int64_t Fingerprint_MachineCharacteristics::ram() const
{
    // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.ram)
    return _internal_ram();
}
inline void Fingerprint_MachineCharacteristics::_internal_set_ram(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00004000u;
    _impl_.ram_ = value;
}
inline void Fingerprint_MachineCharacteristics::set_ram(int64_t value)
{
    _internal_set_ram(value);
    // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.ram)
}

// optional .autofill.risk.Fingerprint.MachineCharacteristics.Graphics graphics_card = 18;
inline bool Fingerprint_MachineCharacteristics::_internal_has_graphics_card() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.graphics_card_ != nullptr);
    return value;
}
inline bool Fingerprint_MachineCharacteristics::has_graphics_card() const
{
    return _internal_has_graphics_card();
}
inline void Fingerprint_MachineCharacteristics::clear_graphics_card()
{
    if (_impl_.graphics_card_ != nullptr)
        _impl_.graphics_card_->Clear();
    _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics& Fingerprint_MachineCharacteristics::_internal_graphics_card() const
{
    const ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics* p = _impl_.graphics_card_;
    return p != nullptr ? *p
                        : reinterpret_cast<const ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics&>(
                            ::autofill::risk::_Fingerprint_MachineCharacteristics_Graphics_default_instance_);
}
inline const ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics& Fingerprint_MachineCharacteristics::graphics_card() const
{
    // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.graphics_card)
    return _internal_graphics_card();
}
inline void Fingerprint_MachineCharacteristics::unsafe_arena_set_allocated_graphics_card(
    ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics* graphics_card)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.graphics_card_);
    }
    _impl_.graphics_card_ = graphics_card;
    if (graphics_card) {
        _impl_._has_bits_[0] |= 0x00000100u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000100u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.graphics_card)
}
inline ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics* Fingerprint_MachineCharacteristics::release_graphics_card()
{
    _impl_._has_bits_[0] &= ~0x00000100u;
    ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics* temp = _impl_.graphics_card_;
    _impl_.graphics_card_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics* Fingerprint_MachineCharacteristics::unsafe_arena_release_graphics_card()
{
    // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.MachineCharacteristics.graphics_card)
    _impl_._has_bits_[0] &= ~0x00000100u;
    ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics* temp = _impl_.graphics_card_;
    _impl_.graphics_card_ = nullptr;
    return temp;
}
inline ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics* Fingerprint_MachineCharacteristics::_internal_mutable_graphics_card()
{
    _impl_._has_bits_[0] |= 0x00000100u;
    if (_impl_.graphics_card_ == nullptr) {
        auto* p = CreateMaybeMessage<::autofill::risk::Fingerprint_MachineCharacteristics_Graphics>(GetArenaForAllocation());
        _impl_.graphics_card_ = p;
    }
    return _impl_.graphics_card_;
}
inline ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics* Fingerprint_MachineCharacteristics::mutable_graphics_card()
{
    ::autofill::risk::Fingerprint_MachineCharacteristics_Graphics* _msg = _internal_mutable_graphics_card();
    // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.graphics_card)
    return _msg;
}
inline void Fingerprint_MachineCharacteristics::set_allocated_graphics_card(::autofill::risk::Fingerprint_MachineCharacteristics_Graphics* graphics_card)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.graphics_card_;
    }
    if (graphics_card) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(graphics_card);
        if (message_arena != submessage_arena) {
            graphics_card = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, graphics_card, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000100u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000100u;
    }
    _impl_.graphics_card_ = graphics_card;
    // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.graphics_card)
}

// optional string browser_build = 19;
inline bool Fingerprint_MachineCharacteristics::_internal_has_browser_build() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
    return value;
}
inline bool Fingerprint_MachineCharacteristics::has_browser_build() const
{
    return _internal_has_browser_build();
}
inline void Fingerprint_MachineCharacteristics::clear_browser_build()
{
    _impl_.browser_build_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& Fingerprint_MachineCharacteristics::browser_build() const
{
    // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.browser_build)
    return _internal_browser_build();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void Fingerprint_MachineCharacteristics::set_browser_build(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000010u;
    _impl_.browser_build_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.browser_build)
}
inline std::string* Fingerprint_MachineCharacteristics::mutable_browser_build()
{
    std::string* _s = _internal_mutable_browser_build();
    // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.MachineCharacteristics.browser_build)
    return _s;
}
inline const std::string& Fingerprint_MachineCharacteristics::_internal_browser_build() const
{
    return _impl_.browser_build_.Get();
}
inline void Fingerprint_MachineCharacteristics::_internal_set_browser_build(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000010u;
    _impl_.browser_build_.Set(value, GetArenaForAllocation());
}
inline std::string* Fingerprint_MachineCharacteristics::_internal_mutable_browser_build()
{
    _impl_._has_bits_[0] |= 0x00000010u;
    return _impl_.browser_build_.Mutable(GetArenaForAllocation());
}
inline std::string* Fingerprint_MachineCharacteristics::release_browser_build()
{
    // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.MachineCharacteristics.browser_build)
    if (!_internal_has_browser_build()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000010u;
    auto* p = _impl_.browser_build_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.browser_build_.IsDefault()) {
        _impl_.browser_build_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void Fingerprint_MachineCharacteristics::set_allocated_browser_build(std::string* browser_build)
{
    if (browser_build != nullptr) {
        _impl_._has_bits_[0] |= 0x00000010u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000010u;
    }
    _impl_.browser_build_.SetAllocated(browser_build, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.browser_build_.IsDefault()) {
        _impl_.browser_build_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.MachineCharacteristics.browser_build)
}

// optional .autofill.risk.Fingerprint.MachineCharacteristics.BrowserFeature browser_feature = 20;
inline bool Fingerprint_MachineCharacteristics::_internal_has_browser_feature() const
{
    bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
    return value;
}
inline bool Fingerprint_MachineCharacteristics::has_browser_feature() const
{
    return _internal_has_browser_feature();
}
inline void Fingerprint_MachineCharacteristics::clear_browser_feature()
{
    _impl_.browser_feature_ = 0;
    _impl_._has_bits_[0] &= ~0x00008000u;
}
inline ::autofill::risk::Fingerprint_MachineCharacteristics_BrowserFeature Fingerprint_MachineCharacteristics::_internal_browser_feature() const
{
    return static_cast<::autofill::risk::Fingerprint_MachineCharacteristics_BrowserFeature>(_impl_.browser_feature_);
}
inline ::autofill::risk::Fingerprint_MachineCharacteristics_BrowserFeature Fingerprint_MachineCharacteristics::browser_feature() const
{
    // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.MachineCharacteristics.browser_feature)
    return _internal_browser_feature();
}
inline void Fingerprint_MachineCharacteristics::_internal_set_browser_feature(::autofill::risk::Fingerprint_MachineCharacteristics_BrowserFeature value)
{
    assert(::autofill::risk::Fingerprint_MachineCharacteristics_BrowserFeature_IsValid(value));
    _impl_._has_bits_[0] |= 0x00008000u;
    _impl_.browser_feature_ = value;
}
inline void Fingerprint_MachineCharacteristics::set_browser_feature(::autofill::risk::Fingerprint_MachineCharacteristics_BrowserFeature value)
{
    _internal_set_browser_feature(value);
    // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.MachineCharacteristics.browser_feature)
}

// -------------------------------------------------------------------

// Fingerprint_TransientState

// optional .autofill.risk.Fingerprint.Dimension inner_window_size = 1;
inline bool Fingerprint_TransientState::_internal_has_inner_window_size() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.inner_window_size_ != nullptr);
    return value;
}
inline bool Fingerprint_TransientState::has_inner_window_size() const
{
    return _internal_has_inner_window_size();
}
inline void Fingerprint_TransientState::clear_inner_window_size()
{
    if (_impl_.inner_window_size_ != nullptr)
        _impl_.inner_window_size_->Clear();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill::risk::Fingerprint_Dimension& Fingerprint_TransientState::_internal_inner_window_size() const
{
    const ::autofill::risk::Fingerprint_Dimension* p = _impl_.inner_window_size_;
    return p != nullptr ? *p : reinterpret_cast<const ::autofill::risk::Fingerprint_Dimension&>(::autofill::risk::_Fingerprint_Dimension_default_instance_);
}
inline const ::autofill::risk::Fingerprint_Dimension& Fingerprint_TransientState::inner_window_size() const
{
    // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.TransientState.inner_window_size)
    return _internal_inner_window_size();
}
inline void Fingerprint_TransientState::unsafe_arena_set_allocated_inner_window_size(::autofill::risk::Fingerprint_Dimension* inner_window_size)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.inner_window_size_);
    }
    _impl_.inner_window_size_ = inner_window_size;
    if (inner_window_size) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill.risk.Fingerprint.TransientState.inner_window_size)
}
inline ::autofill::risk::Fingerprint_Dimension* Fingerprint_TransientState::release_inner_window_size()
{
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::autofill::risk::Fingerprint_Dimension* temp = _impl_.inner_window_size_;
    _impl_.inner_window_size_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::autofill::risk::Fingerprint_Dimension* Fingerprint_TransientState::unsafe_arena_release_inner_window_size()
{
    // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.TransientState.inner_window_size)
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::autofill::risk::Fingerprint_Dimension* temp = _impl_.inner_window_size_;
    _impl_.inner_window_size_ = nullptr;
    return temp;
}
inline ::autofill::risk::Fingerprint_Dimension* Fingerprint_TransientState::_internal_mutable_inner_window_size()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    if (_impl_.inner_window_size_ == nullptr) {
        auto* p = CreateMaybeMessage<::autofill::risk::Fingerprint_Dimension>(GetArenaForAllocation());
        _impl_.inner_window_size_ = p;
    }
    return _impl_.inner_window_size_;
}
inline ::autofill::risk::Fingerprint_Dimension* Fingerprint_TransientState::mutable_inner_window_size()
{
    ::autofill::risk::Fingerprint_Dimension* _msg = _internal_mutable_inner_window_size();
    // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.TransientState.inner_window_size)
    return _msg;
}
inline void Fingerprint_TransientState::set_allocated_inner_window_size(::autofill::risk::Fingerprint_Dimension* inner_window_size)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.inner_window_size_;
    }
    if (inner_window_size) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(inner_window_size);
        if (message_arena != submessage_arena) {
            inner_window_size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, inner_window_size, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.inner_window_size_ = inner_window_size;
    // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.TransientState.inner_window_size)
}

// optional .autofill.risk.Fingerprint.Dimension outer_window_size = 2;
inline bool Fingerprint_TransientState::_internal_has_outer_window_size() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.outer_window_size_ != nullptr);
    return value;
}
inline bool Fingerprint_TransientState::has_outer_window_size() const
{
    return _internal_has_outer_window_size();
}
inline void Fingerprint_TransientState::clear_outer_window_size()
{
    if (_impl_.outer_window_size_ != nullptr)
        _impl_.outer_window_size_->Clear();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::autofill::risk::Fingerprint_Dimension& Fingerprint_TransientState::_internal_outer_window_size() const
{
    const ::autofill::risk::Fingerprint_Dimension* p = _impl_.outer_window_size_;
    return p != nullptr ? *p : reinterpret_cast<const ::autofill::risk::Fingerprint_Dimension&>(::autofill::risk::_Fingerprint_Dimension_default_instance_);
}
inline const ::autofill::risk::Fingerprint_Dimension& Fingerprint_TransientState::outer_window_size() const
{
    // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.TransientState.outer_window_size)
    return _internal_outer_window_size();
}
inline void Fingerprint_TransientState::unsafe_arena_set_allocated_outer_window_size(::autofill::risk::Fingerprint_Dimension* outer_window_size)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.outer_window_size_);
    }
    _impl_.outer_window_size_ = outer_window_size;
    if (outer_window_size) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill.risk.Fingerprint.TransientState.outer_window_size)
}
inline ::autofill::risk::Fingerprint_Dimension* Fingerprint_TransientState::release_outer_window_size()
{
    _impl_._has_bits_[0] &= ~0x00000002u;
    ::autofill::risk::Fingerprint_Dimension* temp = _impl_.outer_window_size_;
    _impl_.outer_window_size_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::autofill::risk::Fingerprint_Dimension* Fingerprint_TransientState::unsafe_arena_release_outer_window_size()
{
    // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.TransientState.outer_window_size)
    _impl_._has_bits_[0] &= ~0x00000002u;
    ::autofill::risk::Fingerprint_Dimension* temp = _impl_.outer_window_size_;
    _impl_.outer_window_size_ = nullptr;
    return temp;
}
inline ::autofill::risk::Fingerprint_Dimension* Fingerprint_TransientState::_internal_mutable_outer_window_size()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    if (_impl_.outer_window_size_ == nullptr) {
        auto* p = CreateMaybeMessage<::autofill::risk::Fingerprint_Dimension>(GetArenaForAllocation());
        _impl_.outer_window_size_ = p;
    }
    return _impl_.outer_window_size_;
}
inline ::autofill::risk::Fingerprint_Dimension* Fingerprint_TransientState::mutable_outer_window_size()
{
    ::autofill::risk::Fingerprint_Dimension* _msg = _internal_mutable_outer_window_size();
    // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.TransientState.outer_window_size)
    return _msg;
}
inline void Fingerprint_TransientState::set_allocated_outer_window_size(::autofill::risk::Fingerprint_Dimension* outer_window_size)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.outer_window_size_;
    }
    if (outer_window_size) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(outer_window_size);
        if (message_arena != submessage_arena) {
            outer_window_size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, outer_window_size, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.outer_window_size_ = outer_window_size;
    // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.TransientState.outer_window_size)
}

// -------------------------------------------------------------------

// Fingerprint_Performance

// optional float bandwidth = 1;
inline bool Fingerprint_Performance::_internal_has_bandwidth() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool Fingerprint_Performance::has_bandwidth() const
{
    return _internal_has_bandwidth();
}
inline void Fingerprint_Performance::clear_bandwidth()
{
    _impl_.bandwidth_ = 0;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float Fingerprint_Performance::_internal_bandwidth() const
{
    return _impl_.bandwidth_;
}
inline float Fingerprint_Performance::bandwidth() const
{
    // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.Performance.bandwidth)
    return _internal_bandwidth();
}
inline void Fingerprint_Performance::_internal_set_bandwidth(float value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.bandwidth_ = value;
}
inline void Fingerprint_Performance::set_bandwidth(float value)
{
    _internal_set_bandwidth(value);
    // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.Performance.bandwidth)
}

// optional bool metered = 2;
inline bool Fingerprint_Performance::_internal_has_metered() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool Fingerprint_Performance::has_metered() const
{
    return _internal_has_metered();
}
inline void Fingerprint_Performance::clear_metered()
{
    _impl_.metered_ = false;
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool Fingerprint_Performance::_internal_metered() const
{
    return _impl_.metered_;
}
inline bool Fingerprint_Performance::metered() const
{
    // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.Performance.metered)
    return _internal_metered();
}
inline void Fingerprint_Performance::_internal_set_metered(bool value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.metered_ = value;
}
inline void Fingerprint_Performance::set_metered(bool value)
{
    _internal_set_metered(value);
    // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.Performance.metered)
}

// optional string network_type = 3;
inline bool Fingerprint_Performance::_internal_has_network_type() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool Fingerprint_Performance::has_network_type() const
{
    return _internal_has_network_type();
}
inline void Fingerprint_Performance::clear_network_type()
{
    _impl_.network_type_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Fingerprint_Performance::network_type() const
{
    // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.Performance.network_type)
    return _internal_network_type();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void Fingerprint_Performance::set_network_type(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.network_type_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.Performance.network_type)
}
inline std::string* Fingerprint_Performance::mutable_network_type()
{
    std::string* _s = _internal_mutable_network_type();
    // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.Performance.network_type)
    return _s;
}
inline const std::string& Fingerprint_Performance::_internal_network_type() const
{
    return _impl_.network_type_.Get();
}
inline void Fingerprint_Performance::_internal_set_network_type(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.network_type_.Set(value, GetArenaForAllocation());
}
inline std::string* Fingerprint_Performance::_internal_mutable_network_type()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.network_type_.Mutable(GetArenaForAllocation());
}
inline std::string* Fingerprint_Performance::release_network_type()
{
    // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.Performance.network_type)
    if (!_internal_has_network_type()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.network_type_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.network_type_.IsDefault()) {
        _impl_.network_type_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void Fingerprint_Performance::set_allocated_network_type(std::string* network_type)
{
    if (network_type != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.network_type_.SetAllocated(network_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.network_type_.IsDefault()) {
        _impl_.network_type_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.Performance.network_type)
}

// -------------------------------------------------------------------

// Fingerprint_UserCharacteristics_Vector

// optional int32 x = 1;
inline bool Fingerprint_UserCharacteristics_Vector::_internal_has_x() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool Fingerprint_UserCharacteristics_Vector::has_x() const
{
    return _internal_has_x();
}
inline void Fingerprint_UserCharacteristics_Vector::clear_x()
{
    _impl_.x_ = 0;
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t Fingerprint_UserCharacteristics_Vector::_internal_x() const
{
    return _impl_.x_;
}
inline int32_t Fingerprint_UserCharacteristics_Vector::x() const
{
    // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.UserCharacteristics.Vector.x)
    return _internal_x();
}
inline void Fingerprint_UserCharacteristics_Vector::_internal_set_x(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.x_ = value;
}
inline void Fingerprint_UserCharacteristics_Vector::set_x(int32_t value)
{
    _internal_set_x(value);
    // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.UserCharacteristics.Vector.x)
}

// optional int32 y = 2;
inline bool Fingerprint_UserCharacteristics_Vector::_internal_has_y() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool Fingerprint_UserCharacteristics_Vector::has_y() const
{
    return _internal_has_y();
}
inline void Fingerprint_UserCharacteristics_Vector::clear_y()
{
    _impl_.y_ = 0;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t Fingerprint_UserCharacteristics_Vector::_internal_y() const
{
    return _impl_.y_;
}
inline int32_t Fingerprint_UserCharacteristics_Vector::y() const
{
    // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.UserCharacteristics.Vector.y)
    return _internal_y();
}
inline void Fingerprint_UserCharacteristics_Vector::_internal_set_y(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.y_ = value;
}
inline void Fingerprint_UserCharacteristics_Vector::set_y(int32_t value)
{
    _internal_set_y(value);
    // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.UserCharacteristics.Vector.y)
}

// optional int32 z = 3;
inline bool Fingerprint_UserCharacteristics_Vector::_internal_has_z() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool Fingerprint_UserCharacteristics_Vector::has_z() const
{
    return _internal_has_z();
}
inline void Fingerprint_UserCharacteristics_Vector::clear_z()
{
    _impl_.z_ = 0;
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t Fingerprint_UserCharacteristics_Vector::_internal_z() const
{
    return _impl_.z_;
}
inline int32_t Fingerprint_UserCharacteristics_Vector::z() const
{
    // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.UserCharacteristics.Vector.z)
    return _internal_z();
}
inline void Fingerprint_UserCharacteristics_Vector::_internal_set_z(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.z_ = value;
}
inline void Fingerprint_UserCharacteristics_Vector::set_z(int32_t value)
{
    _internal_set_z(value);
    // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.UserCharacteristics.Vector.z)
}

// -------------------------------------------------------------------

// Fingerprint_UserCharacteristics_Location

// optional double altitude = 1;
inline bool Fingerprint_UserCharacteristics_Location::_internal_has_altitude() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool Fingerprint_UserCharacteristics_Location::has_altitude() const
{
    return _internal_has_altitude();
}
inline void Fingerprint_UserCharacteristics_Location::clear_altitude()
{
    _impl_.altitude_ = 0;
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double Fingerprint_UserCharacteristics_Location::_internal_altitude() const
{
    return _impl_.altitude_;
}
inline double Fingerprint_UserCharacteristics_Location::altitude() const
{
    // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.UserCharacteristics.Location.altitude)
    return _internal_altitude();
}
inline void Fingerprint_UserCharacteristics_Location::_internal_set_altitude(double value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.altitude_ = value;
}
inline void Fingerprint_UserCharacteristics_Location::set_altitude(double value)
{
    _internal_set_altitude(value);
    // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.UserCharacteristics.Location.altitude)
}

// optional double latitude = 2;
inline bool Fingerprint_UserCharacteristics_Location::_internal_has_latitude() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool Fingerprint_UserCharacteristics_Location::has_latitude() const
{
    return _internal_has_latitude();
}
inline void Fingerprint_UserCharacteristics_Location::clear_latitude()
{
    _impl_.latitude_ = 0;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double Fingerprint_UserCharacteristics_Location::_internal_latitude() const
{
    return _impl_.latitude_;
}
inline double Fingerprint_UserCharacteristics_Location::latitude() const
{
    // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.UserCharacteristics.Location.latitude)
    return _internal_latitude();
}
inline void Fingerprint_UserCharacteristics_Location::_internal_set_latitude(double value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.latitude_ = value;
}
inline void Fingerprint_UserCharacteristics_Location::set_latitude(double value)
{
    _internal_set_latitude(value);
    // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.UserCharacteristics.Location.latitude)
}

// optional double longitude = 3;
inline bool Fingerprint_UserCharacteristics_Location::_internal_has_longitude() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool Fingerprint_UserCharacteristics_Location::has_longitude() const
{
    return _internal_has_longitude();
}
inline void Fingerprint_UserCharacteristics_Location::clear_longitude()
{
    _impl_.longitude_ = 0;
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double Fingerprint_UserCharacteristics_Location::_internal_longitude() const
{
    return _impl_.longitude_;
}
inline double Fingerprint_UserCharacteristics_Location::longitude() const
{
    // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.UserCharacteristics.Location.longitude)
    return _internal_longitude();
}
inline void Fingerprint_UserCharacteristics_Location::_internal_set_longitude(double value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.longitude_ = value;
}
inline void Fingerprint_UserCharacteristics_Location::set_longitude(double value)
{
    _internal_set_longitude(value);
    // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.UserCharacteristics.Location.longitude)
}

// optional double accuracy = 4;
inline bool Fingerprint_UserCharacteristics_Location::_internal_has_accuracy() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    return value;
}
inline bool Fingerprint_UserCharacteristics_Location::has_accuracy() const
{
    return _internal_has_accuracy();
}
inline void Fingerprint_UserCharacteristics_Location::clear_accuracy()
{
    _impl_.accuracy_ = 0;
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double Fingerprint_UserCharacteristics_Location::_internal_accuracy() const
{
    return _impl_.accuracy_;
}
inline double Fingerprint_UserCharacteristics_Location::accuracy() const
{
    // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.UserCharacteristics.Location.accuracy)
    return _internal_accuracy();
}
inline void Fingerprint_UserCharacteristics_Location::_internal_set_accuracy(double value)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.accuracy_ = value;
}
inline void Fingerprint_UserCharacteristics_Location::set_accuracy(double value)
{
    _internal_set_accuracy(value);
    // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.UserCharacteristics.Location.accuracy)
}

// optional int64 time_in_ms = 5;
inline bool Fingerprint_UserCharacteristics_Location::_internal_has_time_in_ms() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
    return value;
}
inline bool Fingerprint_UserCharacteristics_Location::has_time_in_ms() const
{
    return _internal_has_time_in_ms();
}
inline void Fingerprint_UserCharacteristics_Location::clear_time_in_ms()
{
    _impl_.time_in_ms_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int64_t Fingerprint_UserCharacteristics_Location::_internal_time_in_ms() const
{
    return _impl_.time_in_ms_;
}
inline int64_t Fingerprint_UserCharacteristics_Location::time_in_ms() const
{
    // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.UserCharacteristics.Location.time_in_ms)
    return _internal_time_in_ms();
}
inline void Fingerprint_UserCharacteristics_Location::_internal_set_time_in_ms(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000010u;
    _impl_.time_in_ms_ = value;
}
inline void Fingerprint_UserCharacteristics_Location::set_time_in_ms(int64_t value)
{
    _internal_set_time_in_ms(value);
    // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.UserCharacteristics.Location.time_in_ms)
}

// -------------------------------------------------------------------

// Fingerprint_UserCharacteristics

// optional float force = 1;
inline bool Fingerprint_UserCharacteristics::_internal_has_force() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    return value;
}
inline bool Fingerprint_UserCharacteristics::has_force() const
{
    return _internal_has_force();
}
inline void Fingerprint_UserCharacteristics::clear_force()
{
    _impl_.force_ = 0;
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float Fingerprint_UserCharacteristics::_internal_force() const
{
    return _impl_.force_;
}
inline float Fingerprint_UserCharacteristics::force() const
{
    // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.UserCharacteristics.force)
    return _internal_force();
}
inline void Fingerprint_UserCharacteristics::_internal_set_force(float value)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.force_ = value;
}
inline void Fingerprint_UserCharacteristics::set_force(float value)
{
    _internal_set_force(value);
    // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.UserCharacteristics.force)
}

// optional float touch_width = 2;
inline bool Fingerprint_UserCharacteristics::_internal_has_touch_width() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
    return value;
}
inline bool Fingerprint_UserCharacteristics::has_touch_width() const
{
    return _internal_has_touch_width();
}
inline void Fingerprint_UserCharacteristics::clear_touch_width()
{
    _impl_.touch_width_ = 0;
    _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float Fingerprint_UserCharacteristics::_internal_touch_width() const
{
    return _impl_.touch_width_;
}
inline float Fingerprint_UserCharacteristics::touch_width() const
{
    // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.UserCharacteristics.touch_width)
    return _internal_touch_width();
}
inline void Fingerprint_UserCharacteristics::_internal_set_touch_width(float value)
{
    _impl_._has_bits_[0] |= 0x00000010u;
    _impl_.touch_width_ = value;
}
inline void Fingerprint_UserCharacteristics::set_touch_width(float value)
{
    _internal_set_touch_width(value);
    // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.UserCharacteristics.touch_width)
}

// optional float touch_height = 3;
inline bool Fingerprint_UserCharacteristics::_internal_has_touch_height() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
    return value;
}
inline bool Fingerprint_UserCharacteristics::has_touch_height() const
{
    return _internal_has_touch_height();
}
inline void Fingerprint_UserCharacteristics::clear_touch_height()
{
    _impl_.touch_height_ = 0;
    _impl_._has_bits_[0] &= ~0x00000020u;
}
inline float Fingerprint_UserCharacteristics::_internal_touch_height() const
{
    return _impl_.touch_height_;
}
inline float Fingerprint_UserCharacteristics::touch_height() const
{
    // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.UserCharacteristics.touch_height)
    return _internal_touch_height();
}
inline void Fingerprint_UserCharacteristics::_internal_set_touch_height(float value)
{
    _impl_._has_bits_[0] |= 0x00000020u;
    _impl_.touch_height_ = value;
}
inline void Fingerprint_UserCharacteristics::set_touch_height(float value)
{
    _internal_set_touch_height(value);
    // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.UserCharacteristics.touch_height)
}

// optional int32 touch_rotation = 4;
inline bool Fingerprint_UserCharacteristics::_internal_has_touch_rotation() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
    return value;
}
inline bool Fingerprint_UserCharacteristics::has_touch_rotation() const
{
    return _internal_has_touch_rotation();
}
inline void Fingerprint_UserCharacteristics::clear_touch_rotation()
{
    _impl_.touch_rotation_ = 0;
    _impl_._has_bits_[0] &= ~0x00000040u;
}
inline int32_t Fingerprint_UserCharacteristics::_internal_touch_rotation() const
{
    return _impl_.touch_rotation_;
}
inline int32_t Fingerprint_UserCharacteristics::touch_rotation() const
{
    // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.UserCharacteristics.touch_rotation)
    return _internal_touch_rotation();
}
inline void Fingerprint_UserCharacteristics::_internal_set_touch_rotation(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000040u;
    _impl_.touch_rotation_ = value;
}
inline void Fingerprint_UserCharacteristics::set_touch_rotation(int32_t value)
{
    _internal_set_touch_rotation(value);
    // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.UserCharacteristics.touch_rotation)
}

// optional .autofill.risk.Fingerprint.UserCharacteristics.Vector device_orientation = 5;
inline bool Fingerprint_UserCharacteristics::_internal_has_device_orientation() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.device_orientation_ != nullptr);
    return value;
}
inline bool Fingerprint_UserCharacteristics::has_device_orientation() const
{
    return _internal_has_device_orientation();
}
inline void Fingerprint_UserCharacteristics::clear_device_orientation()
{
    if (_impl_.device_orientation_ != nullptr)
        _impl_.device_orientation_->Clear();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill::risk::Fingerprint_UserCharacteristics_Vector& Fingerprint_UserCharacteristics::_internal_device_orientation() const
{
    const ::autofill::risk::Fingerprint_UserCharacteristics_Vector* p = _impl_.device_orientation_;
    return p != nullptr ? *p
                        : reinterpret_cast<const ::autofill::risk::Fingerprint_UserCharacteristics_Vector&>(
                            ::autofill::risk::_Fingerprint_UserCharacteristics_Vector_default_instance_);
}
inline const ::autofill::risk::Fingerprint_UserCharacteristics_Vector& Fingerprint_UserCharacteristics::device_orientation() const
{
    // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.UserCharacteristics.device_orientation)
    return _internal_device_orientation();
}
inline void Fingerprint_UserCharacteristics::unsafe_arena_set_allocated_device_orientation(
    ::autofill::risk::Fingerprint_UserCharacteristics_Vector* device_orientation)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_orientation_);
    }
    _impl_.device_orientation_ = device_orientation;
    if (device_orientation) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill.risk.Fingerprint.UserCharacteristics.device_orientation)
}
inline ::autofill::risk::Fingerprint_UserCharacteristics_Vector* Fingerprint_UserCharacteristics::release_device_orientation()
{
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::autofill::risk::Fingerprint_UserCharacteristics_Vector* temp = _impl_.device_orientation_;
    _impl_.device_orientation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::autofill::risk::Fingerprint_UserCharacteristics_Vector* Fingerprint_UserCharacteristics::unsafe_arena_release_device_orientation()
{
    // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.UserCharacteristics.device_orientation)
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::autofill::risk::Fingerprint_UserCharacteristics_Vector* temp = _impl_.device_orientation_;
    _impl_.device_orientation_ = nullptr;
    return temp;
}
inline ::autofill::risk::Fingerprint_UserCharacteristics_Vector* Fingerprint_UserCharacteristics::_internal_mutable_device_orientation()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    if (_impl_.device_orientation_ == nullptr) {
        auto* p = CreateMaybeMessage<::autofill::risk::Fingerprint_UserCharacteristics_Vector>(GetArenaForAllocation());
        _impl_.device_orientation_ = p;
    }
    return _impl_.device_orientation_;
}
inline ::autofill::risk::Fingerprint_UserCharacteristics_Vector* Fingerprint_UserCharacteristics::mutable_device_orientation()
{
    ::autofill::risk::Fingerprint_UserCharacteristics_Vector* _msg = _internal_mutable_device_orientation();
    // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.UserCharacteristics.device_orientation)
    return _msg;
}
inline void Fingerprint_UserCharacteristics::set_allocated_device_orientation(::autofill::risk::Fingerprint_UserCharacteristics_Vector* device_orientation)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.device_orientation_;
    }
    if (device_orientation) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_orientation);
        if (message_arena != submessage_arena) {
            device_orientation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, device_orientation, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.device_orientation_ = device_orientation;
    // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.UserCharacteristics.device_orientation)
}

// optional .autofill.risk.Fingerprint.UserCharacteristics.Vector device_acceleration = 6;
inline bool Fingerprint_UserCharacteristics::_internal_has_device_acceleration() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.device_acceleration_ != nullptr);
    return value;
}
inline bool Fingerprint_UserCharacteristics::has_device_acceleration() const
{
    return _internal_has_device_acceleration();
}
inline void Fingerprint_UserCharacteristics::clear_device_acceleration()
{
    if (_impl_.device_acceleration_ != nullptr)
        _impl_.device_acceleration_->Clear();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::autofill::risk::Fingerprint_UserCharacteristics_Vector& Fingerprint_UserCharacteristics::_internal_device_acceleration() const
{
    const ::autofill::risk::Fingerprint_UserCharacteristics_Vector* p = _impl_.device_acceleration_;
    return p != nullptr ? *p
                        : reinterpret_cast<const ::autofill::risk::Fingerprint_UserCharacteristics_Vector&>(
                            ::autofill::risk::_Fingerprint_UserCharacteristics_Vector_default_instance_);
}
inline const ::autofill::risk::Fingerprint_UserCharacteristics_Vector& Fingerprint_UserCharacteristics::device_acceleration() const
{
    // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.UserCharacteristics.device_acceleration)
    return _internal_device_acceleration();
}
inline void Fingerprint_UserCharacteristics::unsafe_arena_set_allocated_device_acceleration(
    ::autofill::risk::Fingerprint_UserCharacteristics_Vector* device_acceleration)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_acceleration_);
    }
    _impl_.device_acceleration_ = device_acceleration;
    if (device_acceleration) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill.risk.Fingerprint.UserCharacteristics.device_acceleration)
}
inline ::autofill::risk::Fingerprint_UserCharacteristics_Vector* Fingerprint_UserCharacteristics::release_device_acceleration()
{
    _impl_._has_bits_[0] &= ~0x00000002u;
    ::autofill::risk::Fingerprint_UserCharacteristics_Vector* temp = _impl_.device_acceleration_;
    _impl_.device_acceleration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::autofill::risk::Fingerprint_UserCharacteristics_Vector* Fingerprint_UserCharacteristics::unsafe_arena_release_device_acceleration()
{
    // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.UserCharacteristics.device_acceleration)
    _impl_._has_bits_[0] &= ~0x00000002u;
    ::autofill::risk::Fingerprint_UserCharacteristics_Vector* temp = _impl_.device_acceleration_;
    _impl_.device_acceleration_ = nullptr;
    return temp;
}
inline ::autofill::risk::Fingerprint_UserCharacteristics_Vector* Fingerprint_UserCharacteristics::_internal_mutable_device_acceleration()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    if (_impl_.device_acceleration_ == nullptr) {
        auto* p = CreateMaybeMessage<::autofill::risk::Fingerprint_UserCharacteristics_Vector>(GetArenaForAllocation());
        _impl_.device_acceleration_ = p;
    }
    return _impl_.device_acceleration_;
}
inline ::autofill::risk::Fingerprint_UserCharacteristics_Vector* Fingerprint_UserCharacteristics::mutable_device_acceleration()
{
    ::autofill::risk::Fingerprint_UserCharacteristics_Vector* _msg = _internal_mutable_device_acceleration();
    // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.UserCharacteristics.device_acceleration)
    return _msg;
}
inline void Fingerprint_UserCharacteristics::set_allocated_device_acceleration(::autofill::risk::Fingerprint_UserCharacteristics_Vector* device_acceleration)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.device_acceleration_;
    }
    if (device_acceleration) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device_acceleration);
        if (message_arena != submessage_arena) {
            device_acceleration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, device_acceleration, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.device_acceleration_ = device_acceleration;
    // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.UserCharacteristics.device_acceleration)
}

// optional .autofill.risk.Fingerprint.UserCharacteristics.Location location = 7;
inline bool Fingerprint_UserCharacteristics::_internal_has_location() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.location_ != nullptr);
    return value;
}
inline bool Fingerprint_UserCharacteristics::has_location() const
{
    return _internal_has_location();
}
inline void Fingerprint_UserCharacteristics::clear_location()
{
    if (_impl_.location_ != nullptr)
        _impl_.location_->Clear();
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::autofill::risk::Fingerprint_UserCharacteristics_Location& Fingerprint_UserCharacteristics::_internal_location() const
{
    const ::autofill::risk::Fingerprint_UserCharacteristics_Location* p = _impl_.location_;
    return p != nullptr ? *p
                        : reinterpret_cast<const ::autofill::risk::Fingerprint_UserCharacteristics_Location&>(
                            ::autofill::risk::_Fingerprint_UserCharacteristics_Location_default_instance_);
}
inline const ::autofill::risk::Fingerprint_UserCharacteristics_Location& Fingerprint_UserCharacteristics::location() const
{
    // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.UserCharacteristics.location)
    return _internal_location();
}
inline void Fingerprint_UserCharacteristics::unsafe_arena_set_allocated_location(::autofill::risk::Fingerprint_UserCharacteristics_Location* location)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.location_);
    }
    _impl_.location_ = location;
    if (location) {
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill.risk.Fingerprint.UserCharacteristics.location)
}
inline ::autofill::risk::Fingerprint_UserCharacteristics_Location* Fingerprint_UserCharacteristics::release_location()
{
    _impl_._has_bits_[0] &= ~0x00000004u;
    ::autofill::risk::Fingerprint_UserCharacteristics_Location* temp = _impl_.location_;
    _impl_.location_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::autofill::risk::Fingerprint_UserCharacteristics_Location* Fingerprint_UserCharacteristics::unsafe_arena_release_location()
{
    // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.UserCharacteristics.location)
    _impl_._has_bits_[0] &= ~0x00000004u;
    ::autofill::risk::Fingerprint_UserCharacteristics_Location* temp = _impl_.location_;
    _impl_.location_ = nullptr;
    return temp;
}
inline ::autofill::risk::Fingerprint_UserCharacteristics_Location* Fingerprint_UserCharacteristics::_internal_mutable_location()
{
    _impl_._has_bits_[0] |= 0x00000004u;
    if (_impl_.location_ == nullptr) {
        auto* p = CreateMaybeMessage<::autofill::risk::Fingerprint_UserCharacteristics_Location>(GetArenaForAllocation());
        _impl_.location_ = p;
    }
    return _impl_.location_;
}
inline ::autofill::risk::Fingerprint_UserCharacteristics_Location* Fingerprint_UserCharacteristics::mutable_location()
{
    ::autofill::risk::Fingerprint_UserCharacteristics_Location* _msg = _internal_mutable_location();
    // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.UserCharacteristics.location)
    return _msg;
}
inline void Fingerprint_UserCharacteristics::set_allocated_location(::autofill::risk::Fingerprint_UserCharacteristics_Location* location)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.location_;
    }
    if (location) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(location);
        if (message_arena != submessage_arena) {
            location = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, location, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    _impl_.location_ = location;
    // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.UserCharacteristics.location)
}

// -------------------------------------------------------------------

// Fingerprint_Metadata

// optional int64 timestamp_ms = 1;
inline bool Fingerprint_Metadata::_internal_has_timestamp_ms() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool Fingerprint_Metadata::has_timestamp_ms() const
{
    return _internal_has_timestamp_ms();
}
inline void Fingerprint_Metadata::clear_timestamp_ms()
{
    _impl_.timestamp_ms_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t Fingerprint_Metadata::_internal_timestamp_ms() const
{
    return _impl_.timestamp_ms_;
}
inline int64_t Fingerprint_Metadata::timestamp_ms() const
{
    // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.Metadata.timestamp_ms)
    return _internal_timestamp_ms();
}
inline void Fingerprint_Metadata::_internal_set_timestamp_ms(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.timestamp_ms_ = value;
}
inline void Fingerprint_Metadata::set_timestamp_ms(int64_t value)
{
    _internal_set_timestamp_ms(value);
    // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.Metadata.timestamp_ms)
}

// optional uint64 obfuscated_gaia_id = 2;
inline bool Fingerprint_Metadata::_internal_has_obfuscated_gaia_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool Fingerprint_Metadata::has_obfuscated_gaia_id() const
{
    return _internal_has_obfuscated_gaia_id();
}
inline void Fingerprint_Metadata::clear_obfuscated_gaia_id()
{
    _impl_.obfuscated_gaia_id_ = uint64_t { 0u };
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t Fingerprint_Metadata::_internal_obfuscated_gaia_id() const
{
    return _impl_.obfuscated_gaia_id_;
}
inline uint64_t Fingerprint_Metadata::obfuscated_gaia_id() const
{
    // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.Metadata.obfuscated_gaia_id)
    return _internal_obfuscated_gaia_id();
}
inline void Fingerprint_Metadata::_internal_set_obfuscated_gaia_id(uint64_t value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.obfuscated_gaia_id_ = value;
}
inline void Fingerprint_Metadata::set_obfuscated_gaia_id(uint64_t value)
{
    _internal_set_obfuscated_gaia_id(value);
    // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.Metadata.obfuscated_gaia_id)
}

// optional int32 fingerprinter_version = 3;
inline bool Fingerprint_Metadata::_internal_has_fingerprinter_version() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool Fingerprint_Metadata::has_fingerprinter_version() const
{
    return _internal_has_fingerprinter_version();
}
inline void Fingerprint_Metadata::clear_fingerprinter_version()
{
    _impl_.fingerprinter_version_ = 0;
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t Fingerprint_Metadata::_internal_fingerprinter_version() const
{
    return _impl_.fingerprinter_version_;
}
inline int32_t Fingerprint_Metadata::fingerprinter_version() const
{
    // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.Metadata.fingerprinter_version)
    return _internal_fingerprinter_version();
}
inline void Fingerprint_Metadata::_internal_set_fingerprinter_version(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.fingerprinter_version_ = value;
}
inline void Fingerprint_Metadata::set_fingerprinter_version(int32_t value)
{
    _internal_set_fingerprinter_version(value);
    // @@protoc_insertion_point(field_set:autofill.risk.Fingerprint.Metadata.fingerprinter_version)
}

// -------------------------------------------------------------------

// Fingerprint

// optional .autofill.risk.Fingerprint.MachineCharacteristics machine_characteristics = 1;
inline bool Fingerprint::_internal_has_machine_characteristics() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.machine_characteristics_ != nullptr);
    return value;
}
inline bool Fingerprint::has_machine_characteristics() const
{
    return _internal_has_machine_characteristics();
}
inline void Fingerprint::clear_machine_characteristics()
{
    if (_impl_.machine_characteristics_ != nullptr)
        _impl_.machine_characteristics_->Clear();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::autofill::risk::Fingerprint_MachineCharacteristics& Fingerprint::_internal_machine_characteristics() const
{
    const ::autofill::risk::Fingerprint_MachineCharacteristics* p = _impl_.machine_characteristics_;
    return p != nullptr ? *p
                        : reinterpret_cast<const ::autofill::risk::Fingerprint_MachineCharacteristics&>(
                            ::autofill::risk::_Fingerprint_MachineCharacteristics_default_instance_);
}
inline const ::autofill::risk::Fingerprint_MachineCharacteristics& Fingerprint::machine_characteristics() const
{
    // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.machine_characteristics)
    return _internal_machine_characteristics();
}
inline void Fingerprint::unsafe_arena_set_allocated_machine_characteristics(::autofill::risk::Fingerprint_MachineCharacteristics* machine_characteristics)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.machine_characteristics_);
    }
    _impl_.machine_characteristics_ = machine_characteristics;
    if (machine_characteristics) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill.risk.Fingerprint.machine_characteristics)
}
inline ::autofill::risk::Fingerprint_MachineCharacteristics* Fingerprint::release_machine_characteristics()
{
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::autofill::risk::Fingerprint_MachineCharacteristics* temp = _impl_.machine_characteristics_;
    _impl_.machine_characteristics_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::autofill::risk::Fingerprint_MachineCharacteristics* Fingerprint::unsafe_arena_release_machine_characteristics()
{
    // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.machine_characteristics)
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::autofill::risk::Fingerprint_MachineCharacteristics* temp = _impl_.machine_characteristics_;
    _impl_.machine_characteristics_ = nullptr;
    return temp;
}
inline ::autofill::risk::Fingerprint_MachineCharacteristics* Fingerprint::_internal_mutable_machine_characteristics()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    if (_impl_.machine_characteristics_ == nullptr) {
        auto* p = CreateMaybeMessage<::autofill::risk::Fingerprint_MachineCharacteristics>(GetArenaForAllocation());
        _impl_.machine_characteristics_ = p;
    }
    return _impl_.machine_characteristics_;
}
inline ::autofill::risk::Fingerprint_MachineCharacteristics* Fingerprint::mutable_machine_characteristics()
{
    ::autofill::risk::Fingerprint_MachineCharacteristics* _msg = _internal_mutable_machine_characteristics();
    // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.machine_characteristics)
    return _msg;
}
inline void Fingerprint::set_allocated_machine_characteristics(::autofill::risk::Fingerprint_MachineCharacteristics* machine_characteristics)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.machine_characteristics_;
    }
    if (machine_characteristics) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(machine_characteristics);
        if (message_arena != submessage_arena) {
            machine_characteristics = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, machine_characteristics, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.machine_characteristics_ = machine_characteristics;
    // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.machine_characteristics)
}

// optional .autofill.risk.Fingerprint.Performance performance = 2;
inline bool Fingerprint::_internal_has_performance() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.performance_ != nullptr);
    return value;
}
inline bool Fingerprint::has_performance() const
{
    return _internal_has_performance();
}
inline void Fingerprint::clear_performance()
{
    if (_impl_.performance_ != nullptr)
        _impl_.performance_->Clear();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::autofill::risk::Fingerprint_Performance& Fingerprint::_internal_performance() const
{
    const ::autofill::risk::Fingerprint_Performance* p = _impl_.performance_;
    return p != nullptr ? *p : reinterpret_cast<const ::autofill::risk::Fingerprint_Performance&>(::autofill::risk::_Fingerprint_Performance_default_instance_);
}
inline const ::autofill::risk::Fingerprint_Performance& Fingerprint::performance() const
{
    // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.performance)
    return _internal_performance();
}
inline void Fingerprint::unsafe_arena_set_allocated_performance(::autofill::risk::Fingerprint_Performance* performance)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.performance_);
    }
    _impl_.performance_ = performance;
    if (performance) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill.risk.Fingerprint.performance)
}
inline ::autofill::risk::Fingerprint_Performance* Fingerprint::release_performance()
{
    _impl_._has_bits_[0] &= ~0x00000002u;
    ::autofill::risk::Fingerprint_Performance* temp = _impl_.performance_;
    _impl_.performance_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::autofill::risk::Fingerprint_Performance* Fingerprint::unsafe_arena_release_performance()
{
    // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.performance)
    _impl_._has_bits_[0] &= ~0x00000002u;
    ::autofill::risk::Fingerprint_Performance* temp = _impl_.performance_;
    _impl_.performance_ = nullptr;
    return temp;
}
inline ::autofill::risk::Fingerprint_Performance* Fingerprint::_internal_mutable_performance()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    if (_impl_.performance_ == nullptr) {
        auto* p = CreateMaybeMessage<::autofill::risk::Fingerprint_Performance>(GetArenaForAllocation());
        _impl_.performance_ = p;
    }
    return _impl_.performance_;
}
inline ::autofill::risk::Fingerprint_Performance* Fingerprint::mutable_performance()
{
    ::autofill::risk::Fingerprint_Performance* _msg = _internal_mutable_performance();
    // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.performance)
    return _msg;
}
inline void Fingerprint::set_allocated_performance(::autofill::risk::Fingerprint_Performance* performance)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.performance_;
    }
    if (performance) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(performance);
        if (message_arena != submessage_arena) {
            performance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, performance, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.performance_ = performance;
    // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.performance)
}

// optional .autofill.risk.Fingerprint.UserCharacteristics user_characteristics = 3;
inline bool Fingerprint::_internal_has_user_characteristics() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.user_characteristics_ != nullptr);
    return value;
}
inline bool Fingerprint::has_user_characteristics() const
{
    return _internal_has_user_characteristics();
}
inline void Fingerprint::clear_user_characteristics()
{
    if (_impl_.user_characteristics_ != nullptr)
        _impl_.user_characteristics_->Clear();
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::autofill::risk::Fingerprint_UserCharacteristics& Fingerprint::_internal_user_characteristics() const
{
    const ::autofill::risk::Fingerprint_UserCharacteristics* p = _impl_.user_characteristics_;
    return p != nullptr
        ? *p
        : reinterpret_cast<const ::autofill::risk::Fingerprint_UserCharacteristics&>(::autofill::risk::_Fingerprint_UserCharacteristics_default_instance_);
}
inline const ::autofill::risk::Fingerprint_UserCharacteristics& Fingerprint::user_characteristics() const
{
    // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.user_characteristics)
    return _internal_user_characteristics();
}
inline void Fingerprint::unsafe_arena_set_allocated_user_characteristics(::autofill::risk::Fingerprint_UserCharacteristics* user_characteristics)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_characteristics_);
    }
    _impl_.user_characteristics_ = user_characteristics;
    if (user_characteristics) {
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill.risk.Fingerprint.user_characteristics)
}
inline ::autofill::risk::Fingerprint_UserCharacteristics* Fingerprint::release_user_characteristics()
{
    _impl_._has_bits_[0] &= ~0x00000004u;
    ::autofill::risk::Fingerprint_UserCharacteristics* temp = _impl_.user_characteristics_;
    _impl_.user_characteristics_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::autofill::risk::Fingerprint_UserCharacteristics* Fingerprint::unsafe_arena_release_user_characteristics()
{
    // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.user_characteristics)
    _impl_._has_bits_[0] &= ~0x00000004u;
    ::autofill::risk::Fingerprint_UserCharacteristics* temp = _impl_.user_characteristics_;
    _impl_.user_characteristics_ = nullptr;
    return temp;
}
inline ::autofill::risk::Fingerprint_UserCharacteristics* Fingerprint::_internal_mutable_user_characteristics()
{
    _impl_._has_bits_[0] |= 0x00000004u;
    if (_impl_.user_characteristics_ == nullptr) {
        auto* p = CreateMaybeMessage<::autofill::risk::Fingerprint_UserCharacteristics>(GetArenaForAllocation());
        _impl_.user_characteristics_ = p;
    }
    return _impl_.user_characteristics_;
}
inline ::autofill::risk::Fingerprint_UserCharacteristics* Fingerprint::mutable_user_characteristics()
{
    ::autofill::risk::Fingerprint_UserCharacteristics* _msg = _internal_mutable_user_characteristics();
    // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.user_characteristics)
    return _msg;
}
inline void Fingerprint::set_allocated_user_characteristics(::autofill::risk::Fingerprint_UserCharacteristics* user_characteristics)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.user_characteristics_;
    }
    if (user_characteristics) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user_characteristics);
        if (message_arena != submessage_arena) {
            user_characteristics = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, user_characteristics, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    _impl_.user_characteristics_ = user_characteristics;
    // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.user_characteristics)
}

// optional .autofill.risk.Fingerprint.TransientState transient_state = 4;
inline bool Fingerprint::_internal_has_transient_state() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.transient_state_ != nullptr);
    return value;
}
inline bool Fingerprint::has_transient_state() const
{
    return _internal_has_transient_state();
}
inline void Fingerprint::clear_transient_state()
{
    if (_impl_.transient_state_ != nullptr)
        _impl_.transient_state_->Clear();
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::autofill::risk::Fingerprint_TransientState& Fingerprint::_internal_transient_state() const
{
    const ::autofill::risk::Fingerprint_TransientState* p = _impl_.transient_state_;
    return p != nullptr
        ? *p
        : reinterpret_cast<const ::autofill::risk::Fingerprint_TransientState&>(::autofill::risk::_Fingerprint_TransientState_default_instance_);
}
inline const ::autofill::risk::Fingerprint_TransientState& Fingerprint::transient_state() const
{
    // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.transient_state)
    return _internal_transient_state();
}
inline void Fingerprint::unsafe_arena_set_allocated_transient_state(::autofill::risk::Fingerprint_TransientState* transient_state)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transient_state_);
    }
    _impl_.transient_state_ = transient_state;
    if (transient_state) {
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill.risk.Fingerprint.transient_state)
}
inline ::autofill::risk::Fingerprint_TransientState* Fingerprint::release_transient_state()
{
    _impl_._has_bits_[0] &= ~0x00000008u;
    ::autofill::risk::Fingerprint_TransientState* temp = _impl_.transient_state_;
    _impl_.transient_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::autofill::risk::Fingerprint_TransientState* Fingerprint::unsafe_arena_release_transient_state()
{
    // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.transient_state)
    _impl_._has_bits_[0] &= ~0x00000008u;
    ::autofill::risk::Fingerprint_TransientState* temp = _impl_.transient_state_;
    _impl_.transient_state_ = nullptr;
    return temp;
}
inline ::autofill::risk::Fingerprint_TransientState* Fingerprint::_internal_mutable_transient_state()
{
    _impl_._has_bits_[0] |= 0x00000008u;
    if (_impl_.transient_state_ == nullptr) {
        auto* p = CreateMaybeMessage<::autofill::risk::Fingerprint_TransientState>(GetArenaForAllocation());
        _impl_.transient_state_ = p;
    }
    return _impl_.transient_state_;
}
inline ::autofill::risk::Fingerprint_TransientState* Fingerprint::mutable_transient_state()
{
    ::autofill::risk::Fingerprint_TransientState* _msg = _internal_mutable_transient_state();
    // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.transient_state)
    return _msg;
}
inline void Fingerprint::set_allocated_transient_state(::autofill::risk::Fingerprint_TransientState* transient_state)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.transient_state_;
    }
    if (transient_state) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(transient_state);
        if (message_arena != submessage_arena) {
            transient_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, transient_state, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    _impl_.transient_state_ = transient_state;
    // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.transient_state)
}

// optional .autofill.risk.Fingerprint.Metadata metadata = 5;
inline bool Fingerprint::_internal_has_metadata() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.metadata_ != nullptr);
    return value;
}
inline bool Fingerprint::has_metadata() const
{
    return _internal_has_metadata();
}
inline void Fingerprint::clear_metadata()
{
    if (_impl_.metadata_ != nullptr)
        _impl_.metadata_->Clear();
    _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::autofill::risk::Fingerprint_Metadata& Fingerprint::_internal_metadata() const
{
    const ::autofill::risk::Fingerprint_Metadata* p = _impl_.metadata_;
    return p != nullptr ? *p : reinterpret_cast<const ::autofill::risk::Fingerprint_Metadata&>(::autofill::risk::_Fingerprint_Metadata_default_instance_);
}
inline const ::autofill::risk::Fingerprint_Metadata& Fingerprint::metadata() const
{
    // @@protoc_insertion_point(field_get:autofill.risk.Fingerprint.metadata)
    return _internal_metadata();
}
inline void Fingerprint::unsafe_arena_set_allocated_metadata(::autofill::risk::Fingerprint_Metadata* metadata)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
    }
    _impl_.metadata_ = metadata;
    if (metadata) {
        _impl_._has_bits_[0] |= 0x00000010u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000010u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autofill.risk.Fingerprint.metadata)
}
inline ::autofill::risk::Fingerprint_Metadata* Fingerprint::release_metadata()
{
    _impl_._has_bits_[0] &= ~0x00000010u;
    ::autofill::risk::Fingerprint_Metadata* temp = _impl_.metadata_;
    _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::autofill::risk::Fingerprint_Metadata* Fingerprint::unsafe_arena_release_metadata()
{
    // @@protoc_insertion_point(field_release:autofill.risk.Fingerprint.metadata)
    _impl_._has_bits_[0] &= ~0x00000010u;
    ::autofill::risk::Fingerprint_Metadata* temp = _impl_.metadata_;
    _impl_.metadata_ = nullptr;
    return temp;
}
inline ::autofill::risk::Fingerprint_Metadata* Fingerprint::_internal_mutable_metadata()
{
    _impl_._has_bits_[0] |= 0x00000010u;
    if (_impl_.metadata_ == nullptr) {
        auto* p = CreateMaybeMessage<::autofill::risk::Fingerprint_Metadata>(GetArenaForAllocation());
        _impl_.metadata_ = p;
    }
    return _impl_.metadata_;
}
inline ::autofill::risk::Fingerprint_Metadata* Fingerprint::mutable_metadata()
{
    ::autofill::risk::Fingerprint_Metadata* _msg = _internal_mutable_metadata();
    // @@protoc_insertion_point(field_mutable:autofill.risk.Fingerprint.metadata)
    return _msg;
}
inline void Fingerprint::set_allocated_metadata(::autofill::risk::Fingerprint_Metadata* metadata)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.metadata_;
    }
    if (metadata) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(metadata);
        if (message_arena != submessage_arena) {
            metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, metadata, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000010u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000010u;
    }
    _impl_.metadata_ = metadata;
    // @@protoc_insertion_point(field_set_allocated:autofill.risk.Fingerprint.metadata)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// @@protoc_insertion_point(namespace_scope)

} // namespace risk
} // namespace autofill

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum<::autofill::risk::Fingerprint_MachineCharacteristics_BrowserFeature> : ::std::true_type { };

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_fingerprint_2eproto
