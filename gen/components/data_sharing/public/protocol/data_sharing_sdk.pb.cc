// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/data_sharing/public/protocol/data_sharing_sdk.proto

#include "components/data_sharing/public/protocol/data_sharing_sdk.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace data_sharing_pb {
PROTOBUF_CONSTEXPR CreateGroupParams::CreateGroupParams(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.display_name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct CreateGroupParamsDefaultTypeInternal {
    PROTOBUF_CONSTEXPR CreateGroupParamsDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~CreateGroupParamsDefaultTypeInternal()
    {
    }
    union {
        CreateGroupParams _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CreateGroupParamsDefaultTypeInternal _CreateGroupParams_default_instance_;
PROTOBUF_CONSTEXPR CreateGroupResult::CreateGroupResult(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.group_data_)*/ nullptr }
{
}
struct CreateGroupResultDefaultTypeInternal {
    PROTOBUF_CONSTEXPR CreateGroupResultDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~CreateGroupResultDefaultTypeInternal()
    {
    }
    union {
        CreateGroupResult _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CreateGroupResultDefaultTypeInternal _CreateGroupResult_default_instance_;
PROTOBUF_CONSTEXPR ReadGroupsParams::ReadGroupsParams(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.group_ids_)*/ {}, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct ReadGroupsParamsDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ReadGroupsParamsDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ReadGroupsParamsDefaultTypeInternal()
    {
    }
    union {
        ReadGroupsParams _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReadGroupsParamsDefaultTypeInternal _ReadGroupsParams_default_instance_;
PROTOBUF_CONSTEXPR ReadGroupsResult::ReadGroupsResult(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.group_data_)*/ {}, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct ReadGroupsResultDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ReadGroupsResultDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ReadGroupsResultDefaultTypeInternal()
    {
    }
    union {
        ReadGroupsResult _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReadGroupsResultDefaultTypeInternal _ReadGroupsResult_default_instance_;
PROTOBUF_CONSTEXPR AddMemberParams::AddMemberParams(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.group_id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.AddMemberOptions_)*/ {},
        /*decltype(_impl_._oneof_case_)*/ {} }
{
}
struct AddMemberParamsDefaultTypeInternal {
    PROTOBUF_CONSTEXPR AddMemberParamsDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~AddMemberParamsDefaultTypeInternal()
    {
    }
    union {
        AddMemberParams _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AddMemberParamsDefaultTypeInternal _AddMemberParams_default_instance_;
PROTOBUF_CONSTEXPR RemoveMemberParams::RemoveMemberParams(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.group_id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.member_gaia_id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct RemoveMemberParamsDefaultTypeInternal {
    PROTOBUF_CONSTEXPR RemoveMemberParamsDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~RemoveMemberParamsDefaultTypeInternal()
    {
    }
    union {
        RemoveMemberParams _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RemoveMemberParamsDefaultTypeInternal _RemoveMemberParams_default_instance_;
PROTOBUF_CONSTEXPR LeaveGroupParams::LeaveGroupParams(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.group_id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct LeaveGroupParamsDefaultTypeInternal {
    PROTOBUF_CONSTEXPR LeaveGroupParamsDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~LeaveGroupParamsDefaultTypeInternal()
    {
    }
    union {
        LeaveGroupParams _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LeaveGroupParamsDefaultTypeInternal _LeaveGroupParams_default_instance_;
PROTOBUF_CONSTEXPR DeleteGroupParams::DeleteGroupParams(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.group_id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct DeleteGroupParamsDefaultTypeInternal {
    PROTOBUF_CONSTEXPR DeleteGroupParamsDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~DeleteGroupParamsDefaultTypeInternal()
    {
    }
    union {
        DeleteGroupParams _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeleteGroupParamsDefaultTypeInternal _DeleteGroupParams_default_instance_;
PROTOBUF_CONSTEXPR LookupGaiaIdByEmailParams::LookupGaiaIdByEmailParams(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.email_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct LookupGaiaIdByEmailParamsDefaultTypeInternal {
    PROTOBUF_CONSTEXPR LookupGaiaIdByEmailParamsDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~LookupGaiaIdByEmailParamsDefaultTypeInternal()
    {
    }
    union {
        LookupGaiaIdByEmailParams _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LookupGaiaIdByEmailParamsDefaultTypeInternal
    _LookupGaiaIdByEmailParams_default_instance_;
PROTOBUF_CONSTEXPR LookupGaiaIdByEmailResult::LookupGaiaIdByEmailResult(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.gaia_id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct LookupGaiaIdByEmailResultDefaultTypeInternal {
    PROTOBUF_CONSTEXPR LookupGaiaIdByEmailResultDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~LookupGaiaIdByEmailResultDefaultTypeInternal()
    {
    }
    union {
        LookupGaiaIdByEmailResult _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LookupGaiaIdByEmailResultDefaultTypeInternal
    _LookupGaiaIdByEmailResult_default_instance_;
PROTOBUF_CONSTEXPR AddAccessTokenParams::AddAccessTokenParams(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.group_id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct AddAccessTokenParamsDefaultTypeInternal {
    PROTOBUF_CONSTEXPR AddAccessTokenParamsDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~AddAccessTokenParamsDefaultTypeInternal()
    {
    }
    union {
        AddAccessTokenParams _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AddAccessTokenParamsDefaultTypeInternal
    _AddAccessTokenParams_default_instance_;
PROTOBUF_CONSTEXPR AddAccessTokenResult::AddAccessTokenResult(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.group_data_)*/ nullptr }
{
}
struct AddAccessTokenResultDefaultTypeInternal {
    PROTOBUF_CONSTEXPR AddAccessTokenResultDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~AddAccessTokenResultDefaultTypeInternal()
    {
    }
    union {
        AddAccessTokenResult _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AddAccessTokenResultDefaultTypeInternal
    _AddAccessTokenResult_default_instance_;
} // namespace data_sharing_pb
namespace data_sharing_pb {

// ===================================================================

class CreateGroupParams::_Internal {
public:
    using HasBits = decltype(std::declval<CreateGroupParams>()._impl_._has_bits_);
    static void set_has_display_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

CreateGroupParams::CreateGroupParams(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:data_sharing_pb.CreateGroupParams)
}
CreateGroupParams::CreateGroupParams(const CreateGroupParams& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    CreateGroupParams* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.display_name_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.display_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.display_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_display_name()) {
        _this->_impl_.display_name_.Set(from._internal_display_name(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:data_sharing_pb.CreateGroupParams)
}

inline void CreateGroupParams::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.display_name_) {} };
    _impl_.display_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.display_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CreateGroupParams::~CreateGroupParams()
{
    // @@protoc_insertion_point(destructor:data_sharing_pb.CreateGroupParams)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void CreateGroupParams::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.display_name_.Destroy();
}

void CreateGroupParams::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void CreateGroupParams::Clear()
{
    // @@protoc_insertion_point(message_clear_start:data_sharing_pb.CreateGroupParams)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.display_name_.ClearNonDefaultToEmpty();
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* CreateGroupParams::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string display_name = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_display_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* CreateGroupParams::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:data_sharing_pb.CreateGroupParams)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string display_name = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_display_name(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:data_sharing_pb.CreateGroupParams)
    return target;
}

size_t CreateGroupParams::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:data_sharing_pb.CreateGroupParams)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional string display_name = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_display_name());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void CreateGroupParams::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const CreateGroupParams*>(&from));
}

void CreateGroupParams::MergeFrom(const CreateGroupParams& from)
{
    CreateGroupParams* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:data_sharing_pb.CreateGroupParams)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_display_name()) {
        _this->_internal_set_display_name(from._internal_display_name());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CreateGroupParams::CopyFrom(const CreateGroupParams& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:data_sharing_pb.CreateGroupParams)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool CreateGroupParams::IsInitialized() const
{
    return true;
}

void CreateGroupParams::InternalSwap(CreateGroupParams* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.display_name_, lhs_arena, &other->_impl_.display_name_, rhs_arena);
}

std::string CreateGroupParams::GetTypeName() const
{
    return "data_sharing_pb.CreateGroupParams";
}

// ===================================================================

class CreateGroupResult::_Internal {
public:
    using HasBits = decltype(std::declval<CreateGroupResult>()._impl_._has_bits_);
    static const ::data_sharing_pb::GroupData& group_data(const CreateGroupResult* msg);
    static void set_has_group_data(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

const ::data_sharing_pb::GroupData& CreateGroupResult::_Internal::group_data(const CreateGroupResult* msg)
{
    return *msg->_impl_.group_data_;
}
void CreateGroupResult::clear_group_data()
{
    if (_impl_.group_data_ != nullptr)
        _impl_.group_data_->Clear();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
CreateGroupResult::CreateGroupResult(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:data_sharing_pb.CreateGroupResult)
}
CreateGroupResult::CreateGroupResult(const CreateGroupResult& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    CreateGroupResult* const _this = this;
    (void)_this;
    new (&_impl_)
        Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.group_data_) { nullptr } };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_group_data()) {
        _this->_impl_.group_data_ = new ::data_sharing_pb::GroupData(*from._impl_.group_data_);
    }
    // @@protoc_insertion_point(copy_constructor:data_sharing_pb.CreateGroupResult)
}

inline void CreateGroupResult::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.group_data_) { nullptr } };
}

CreateGroupResult::~CreateGroupResult()
{
    // @@protoc_insertion_point(destructor:data_sharing_pb.CreateGroupResult)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void CreateGroupResult::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (this != internal_default_instance())
        delete _impl_.group_data_;
}

void CreateGroupResult::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void CreateGroupResult::Clear()
{
    // @@protoc_insertion_point(message_clear_start:data_sharing_pb.CreateGroupResult)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        GOOGLE_DCHECK(_impl_.group_data_ != nullptr);
        _impl_.group_data_->Clear();
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* CreateGroupResult::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .data_sharing_pb.GroupData group_data = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_group_data(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* CreateGroupResult::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:data_sharing_pb.CreateGroupResult)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .data_sharing_pb.GroupData group_data = 1;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::group_data(this), _Internal::group_data(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:data_sharing_pb.CreateGroupResult)
    return target;
}

size_t CreateGroupResult::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:data_sharing_pb.CreateGroupResult)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional .data_sharing_pb.GroupData group_data = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.group_data_);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void CreateGroupResult::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const CreateGroupResult*>(&from));
}

void CreateGroupResult::MergeFrom(const CreateGroupResult& from)
{
    CreateGroupResult* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:data_sharing_pb.CreateGroupResult)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_group_data()) {
        _this->_internal_mutable_group_data()->::data_sharing_pb::GroupData::MergeFrom(from._internal_group_data());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CreateGroupResult::CopyFrom(const CreateGroupResult& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:data_sharing_pb.CreateGroupResult)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool CreateGroupResult::IsInitialized() const
{
    return true;
}

void CreateGroupResult::InternalSwap(CreateGroupResult* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    swap(_impl_.group_data_, other->_impl_.group_data_);
}

std::string CreateGroupResult::GetTypeName() const
{
    return "data_sharing_pb.CreateGroupResult";
}

// ===================================================================

class ReadGroupsParams::_Internal {
public:
};

ReadGroupsParams::ReadGroupsParams(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:data_sharing_pb.ReadGroupsParams)
}
ReadGroupsParams::ReadGroupsParams(const ReadGroupsParams& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ReadGroupsParams* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.group_ids_) { from._impl_.group_ids_ }, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:data_sharing_pb.ReadGroupsParams)
}

inline void ReadGroupsParams::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.group_ids_) { arena }, /*decltype(_impl_._cached_size_)*/ {} };
}

ReadGroupsParams::~ReadGroupsParams()
{
    // @@protoc_insertion_point(destructor:data_sharing_pb.ReadGroupsParams)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ReadGroupsParams::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.group_ids_.~RepeatedPtrField();
}

void ReadGroupsParams::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ReadGroupsParams::Clear()
{
    // @@protoc_insertion_point(message_clear_start:data_sharing_pb.ReadGroupsParams)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.group_ids_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ReadGroupsParams::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated string group_ids = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    auto str = _internal_add_group_ids();
                    ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ReadGroupsParams::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:data_sharing_pb.ReadGroupsParams)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated string group_ids = 1;
    for (int i = 0, n = this->_internal_group_ids_size(); i < n; i++) {
        const auto& s = this->_internal_group_ids(i);
        target = stream->WriteString(1, s, target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:data_sharing_pb.ReadGroupsParams)
    return target;
}

size_t ReadGroupsParams::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:data_sharing_pb.ReadGroupsParams)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated string group_ids = 1;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.group_ids_.size());
    for (int i = 0, n = _impl_.group_ids_.size(); i < n; i++) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(_impl_.group_ids_.Get(i));
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ReadGroupsParams::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ReadGroupsParams*>(&from));
}

void ReadGroupsParams::MergeFrom(const ReadGroupsParams& from)
{
    ReadGroupsParams* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:data_sharing_pb.ReadGroupsParams)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.group_ids_.MergeFrom(from._impl_.group_ids_);
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ReadGroupsParams::CopyFrom(const ReadGroupsParams& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:data_sharing_pb.ReadGroupsParams)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ReadGroupsParams::IsInitialized() const
{
    return true;
}

void ReadGroupsParams::InternalSwap(ReadGroupsParams* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.group_ids_.InternalSwap(&other->_impl_.group_ids_);
}

std::string ReadGroupsParams::GetTypeName() const
{
    return "data_sharing_pb.ReadGroupsParams";
}

// ===================================================================

class ReadGroupsResult::_Internal {
public:
};

void ReadGroupsResult::clear_group_data()
{
    _impl_.group_data_.Clear();
}
ReadGroupsResult::ReadGroupsResult(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:data_sharing_pb.ReadGroupsResult)
}
ReadGroupsResult::ReadGroupsResult(const ReadGroupsResult& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ReadGroupsResult* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.group_data_) { from._impl_.group_data_ }, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:data_sharing_pb.ReadGroupsResult)
}

inline void ReadGroupsResult::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.group_data_) { arena }, /*decltype(_impl_._cached_size_)*/ {} };
}

ReadGroupsResult::~ReadGroupsResult()
{
    // @@protoc_insertion_point(destructor:data_sharing_pb.ReadGroupsResult)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ReadGroupsResult::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.group_data_.~RepeatedPtrField();
}

void ReadGroupsResult::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ReadGroupsResult::Clear()
{
    // @@protoc_insertion_point(message_clear_start:data_sharing_pb.ReadGroupsResult)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.group_data_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ReadGroupsResult::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .data_sharing_pb.GroupData group_data = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_group_data(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ReadGroupsResult::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:data_sharing_pb.ReadGroupsResult)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .data_sharing_pb.GroupData group_data = 1;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_group_data_size()); i < n; i++) {
        const auto& repfield = this->_internal_group_data(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:data_sharing_pb.ReadGroupsResult)
    return target;
}

size_t ReadGroupsResult::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:data_sharing_pb.ReadGroupsResult)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .data_sharing_pb.GroupData group_data = 1;
    total_size += 1UL * this->_internal_group_data_size();
    for (const auto& msg : this->_impl_.group_data_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ReadGroupsResult::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ReadGroupsResult*>(&from));
}

void ReadGroupsResult::MergeFrom(const ReadGroupsResult& from)
{
    ReadGroupsResult* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:data_sharing_pb.ReadGroupsResult)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.group_data_.MergeFrom(from._impl_.group_data_);
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ReadGroupsResult::CopyFrom(const ReadGroupsResult& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:data_sharing_pb.ReadGroupsResult)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ReadGroupsResult::IsInitialized() const
{
    return true;
}

void ReadGroupsResult::InternalSwap(ReadGroupsResult* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.group_data_.InternalSwap(&other->_impl_.group_data_);
}

std::string ReadGroupsResult::GetTypeName() const
{
    return "data_sharing_pb.ReadGroupsResult";
}

// ===================================================================

class AddMemberParams::_Internal {
public:
    using HasBits = decltype(std::declval<AddMemberParams>()._impl_._has_bits_);
    static void set_has_group_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

AddMemberParams::AddMemberParams(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:data_sharing_pb.AddMemberParams)
}
AddMemberParams::AddMemberParams(const AddMemberParams& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    AddMemberParams* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.group_id_) {},
        decltype(_impl_.AddMemberOptions_) {}, /*decltype(_impl_._oneof_case_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.group_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.group_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_group_id()) {
        _this->_impl_.group_id_.Set(from._internal_group_id(), _this->GetArenaForAllocation());
    }
    clear_has_AddMemberOptions();
    switch (from.AddMemberOptions_case()) {
    case kMemberGaiaId: {
        _this->_internal_set_member_gaia_id(from._internal_member_gaia_id());
        break;
    }
    case kAccessToken: {
        _this->_internal_set_access_token(from._internal_access_token());
        break;
    }
    case ADDMEMBEROPTIONS_NOT_SET: {
        break;
    }
    }
    // @@protoc_insertion_point(copy_constructor:data_sharing_pb.AddMemberParams)
}

inline void AddMemberParams::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.group_id_) {},
        decltype(_impl_.AddMemberOptions_) {}, /*decltype(_impl_._oneof_case_)*/ {} };
    _impl_.group_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.group_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    clear_has_AddMemberOptions();
}

AddMemberParams::~AddMemberParams()
{
    // @@protoc_insertion_point(destructor:data_sharing_pb.AddMemberParams)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void AddMemberParams::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.group_id_.Destroy();
    if (has_AddMemberOptions()) {
        clear_AddMemberOptions();
    }
}

void AddMemberParams::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void AddMemberParams::clear_AddMemberOptions()
{
    // @@protoc_insertion_point(one_of_clear_start:data_sharing_pb.AddMemberParams)
    switch (AddMemberOptions_case()) {
    case kMemberGaiaId: {
        _impl_.AddMemberOptions_.member_gaia_id_.Destroy();
        break;
    }
    case kAccessToken: {
        _impl_.AddMemberOptions_.access_token_.Destroy();
        break;
    }
    case ADDMEMBEROPTIONS_NOT_SET: {
        break;
    }
    }
    _impl_._oneof_case_[0] = ADDMEMBEROPTIONS_NOT_SET;
}

void AddMemberParams::Clear()
{
    // @@protoc_insertion_point(message_clear_start:data_sharing_pb.AddMemberParams)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.group_id_.ClearNonDefaultToEmpty();
    }
    clear_AddMemberOptions();
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* AddMemberParams::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string group_id = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_group_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // string member_gaia_id = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_member_gaia_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // string access_token = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_access_token();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* AddMemberParams::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:data_sharing_pb.AddMemberParams)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string group_id = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_group_id(), target);
    }

    switch (AddMemberOptions_case()) {
    case kMemberGaiaId: {
        target = stream->WriteStringMaybeAliased(2, this->_internal_member_gaia_id(), target);
        break;
    }
    case kAccessToken: {
        target = stream->WriteStringMaybeAliased(3, this->_internal_access_token(), target);
        break;
    }
    default:;
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:data_sharing_pb.AddMemberParams)
    return target;
}

size_t AddMemberParams::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:data_sharing_pb.AddMemberParams)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional string group_id = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_group_id());
    }

    switch (AddMemberOptions_case()) {
    // string member_gaia_id = 2;
    case kMemberGaiaId: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_member_gaia_id());
        break;
    }
    // string access_token = 3;
    case kAccessToken: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_access_token());
        break;
    }
    case ADDMEMBEROPTIONS_NOT_SET: {
        break;
    }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void AddMemberParams::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const AddMemberParams*>(&from));
}

void AddMemberParams::MergeFrom(const AddMemberParams& from)
{
    AddMemberParams* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:data_sharing_pb.AddMemberParams)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_group_id()) {
        _this->_internal_set_group_id(from._internal_group_id());
    }
    switch (from.AddMemberOptions_case()) {
    case kMemberGaiaId: {
        _this->_internal_set_member_gaia_id(from._internal_member_gaia_id());
        break;
    }
    case kAccessToken: {
        _this->_internal_set_access_token(from._internal_access_token());
        break;
    }
    case ADDMEMBEROPTIONS_NOT_SET: {
        break;
    }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AddMemberParams::CopyFrom(const AddMemberParams& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:data_sharing_pb.AddMemberParams)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool AddMemberParams::IsInitialized() const
{
    return true;
}

void AddMemberParams::InternalSwap(AddMemberParams* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.group_id_, lhs_arena, &other->_impl_.group_id_, rhs_arena);
    swap(_impl_.AddMemberOptions_, other->_impl_.AddMemberOptions_);
    swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

std::string AddMemberParams::GetTypeName() const
{
    return "data_sharing_pb.AddMemberParams";
}

// ===================================================================

class RemoveMemberParams::_Internal {
public:
    using HasBits = decltype(std::declval<RemoveMemberParams>()._impl_._has_bits_);
    static void set_has_group_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_member_gaia_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

RemoveMemberParams::RemoveMemberParams(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:data_sharing_pb.RemoveMemberParams)
}
RemoveMemberParams::RemoveMemberParams(const RemoveMemberParams& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    RemoveMemberParams* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.group_id_) {},
        decltype(_impl_.member_gaia_id_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.group_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.group_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_group_id()) {
        _this->_impl_.group_id_.Set(from._internal_group_id(), _this->GetArenaForAllocation());
    }
    _impl_.member_gaia_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.member_gaia_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_member_gaia_id()) {
        _this->_impl_.member_gaia_id_.Set(from._internal_member_gaia_id(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:data_sharing_pb.RemoveMemberParams)
}

inline void RemoveMemberParams::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_)
        Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.group_id_) {}, decltype(_impl_.member_gaia_id_) {} };
    _impl_.group_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.group_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.member_gaia_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.member_gaia_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RemoveMemberParams::~RemoveMemberParams()
{
    // @@protoc_insertion_point(destructor:data_sharing_pb.RemoveMemberParams)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void RemoveMemberParams::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.group_id_.Destroy();
    _impl_.member_gaia_id_.Destroy();
}

void RemoveMemberParams::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void RemoveMemberParams::Clear()
{
    // @@protoc_insertion_point(message_clear_start:data_sharing_pb.RemoveMemberParams)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.group_id_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.member_gaia_id_.ClearNonDefaultToEmpty();
        }
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* RemoveMemberParams::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string group_id = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_group_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string member_gaia_id = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_member_gaia_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* RemoveMemberParams::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:data_sharing_pb.RemoveMemberParams)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string group_id = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_group_id(), target);
    }

    // optional string member_gaia_id = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_member_gaia_id(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:data_sharing_pb.RemoveMemberParams)
    return target;
}

size_t RemoveMemberParams::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:data_sharing_pb.RemoveMemberParams)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional string group_id = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_group_id());
        }

        // optional string member_gaia_id = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_member_gaia_id());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void RemoveMemberParams::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const RemoveMemberParams*>(&from));
}

void RemoveMemberParams::MergeFrom(const RemoveMemberParams& from)
{
    RemoveMemberParams* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:data_sharing_pb.RemoveMemberParams)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_group_id(from._internal_group_id());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_member_gaia_id(from._internal_member_gaia_id());
        }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RemoveMemberParams::CopyFrom(const RemoveMemberParams& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:data_sharing_pb.RemoveMemberParams)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool RemoveMemberParams::IsInitialized() const
{
    return true;
}

void RemoveMemberParams::InternalSwap(RemoveMemberParams* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.group_id_, lhs_arena, &other->_impl_.group_id_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.member_gaia_id_, lhs_arena, &other->_impl_.member_gaia_id_, rhs_arena);
}

std::string RemoveMemberParams::GetTypeName() const
{
    return "data_sharing_pb.RemoveMemberParams";
}

// ===================================================================

class LeaveGroupParams::_Internal {
public:
    using HasBits = decltype(std::declval<LeaveGroupParams>()._impl_._has_bits_);
    static void set_has_group_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

LeaveGroupParams::LeaveGroupParams(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:data_sharing_pb.LeaveGroupParams)
}
LeaveGroupParams::LeaveGroupParams(const LeaveGroupParams& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    LeaveGroupParams* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.group_id_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.group_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.group_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_group_id()) {
        _this->_impl_.group_id_.Set(from._internal_group_id(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:data_sharing_pb.LeaveGroupParams)
}

inline void LeaveGroupParams::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.group_id_) {} };
    _impl_.group_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.group_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LeaveGroupParams::~LeaveGroupParams()
{
    // @@protoc_insertion_point(destructor:data_sharing_pb.LeaveGroupParams)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void LeaveGroupParams::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.group_id_.Destroy();
}

void LeaveGroupParams::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void LeaveGroupParams::Clear()
{
    // @@protoc_insertion_point(message_clear_start:data_sharing_pb.LeaveGroupParams)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.group_id_.ClearNonDefaultToEmpty();
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* LeaveGroupParams::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string group_id = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_group_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* LeaveGroupParams::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:data_sharing_pb.LeaveGroupParams)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string group_id = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_group_id(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:data_sharing_pb.LeaveGroupParams)
    return target;
}

size_t LeaveGroupParams::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:data_sharing_pb.LeaveGroupParams)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional string group_id = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_group_id());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void LeaveGroupParams::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const LeaveGroupParams*>(&from));
}

void LeaveGroupParams::MergeFrom(const LeaveGroupParams& from)
{
    LeaveGroupParams* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:data_sharing_pb.LeaveGroupParams)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_group_id()) {
        _this->_internal_set_group_id(from._internal_group_id());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LeaveGroupParams::CopyFrom(const LeaveGroupParams& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:data_sharing_pb.LeaveGroupParams)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool LeaveGroupParams::IsInitialized() const
{
    return true;
}

void LeaveGroupParams::InternalSwap(LeaveGroupParams* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.group_id_, lhs_arena, &other->_impl_.group_id_, rhs_arena);
}

std::string LeaveGroupParams::GetTypeName() const
{
    return "data_sharing_pb.LeaveGroupParams";
}

// ===================================================================

class DeleteGroupParams::_Internal {
public:
    using HasBits = decltype(std::declval<DeleteGroupParams>()._impl_._has_bits_);
    static void set_has_group_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

DeleteGroupParams::DeleteGroupParams(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:data_sharing_pb.DeleteGroupParams)
}
DeleteGroupParams::DeleteGroupParams(const DeleteGroupParams& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    DeleteGroupParams* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.group_id_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.group_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.group_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_group_id()) {
        _this->_impl_.group_id_.Set(from._internal_group_id(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:data_sharing_pb.DeleteGroupParams)
}

inline void DeleteGroupParams::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.group_id_) {} };
    _impl_.group_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.group_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DeleteGroupParams::~DeleteGroupParams()
{
    // @@protoc_insertion_point(destructor:data_sharing_pb.DeleteGroupParams)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void DeleteGroupParams::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.group_id_.Destroy();
}

void DeleteGroupParams::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void DeleteGroupParams::Clear()
{
    // @@protoc_insertion_point(message_clear_start:data_sharing_pb.DeleteGroupParams)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.group_id_.ClearNonDefaultToEmpty();
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* DeleteGroupParams::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string group_id = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_group_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* DeleteGroupParams::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:data_sharing_pb.DeleteGroupParams)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string group_id = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_group_id(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:data_sharing_pb.DeleteGroupParams)
    return target;
}

size_t DeleteGroupParams::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:data_sharing_pb.DeleteGroupParams)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional string group_id = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_group_id());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void DeleteGroupParams::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const DeleteGroupParams*>(&from));
}

void DeleteGroupParams::MergeFrom(const DeleteGroupParams& from)
{
    DeleteGroupParams* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:data_sharing_pb.DeleteGroupParams)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_group_id()) {
        _this->_internal_set_group_id(from._internal_group_id());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeleteGroupParams::CopyFrom(const DeleteGroupParams& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:data_sharing_pb.DeleteGroupParams)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool DeleteGroupParams::IsInitialized() const
{
    return true;
}

void DeleteGroupParams::InternalSwap(DeleteGroupParams* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.group_id_, lhs_arena, &other->_impl_.group_id_, rhs_arena);
}

std::string DeleteGroupParams::GetTypeName() const
{
    return "data_sharing_pb.DeleteGroupParams";
}

// ===================================================================

class LookupGaiaIdByEmailParams::_Internal {
public:
    using HasBits = decltype(std::declval<LookupGaiaIdByEmailParams>()._impl_._has_bits_);
    static void set_has_email(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

LookupGaiaIdByEmailParams::LookupGaiaIdByEmailParams(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:data_sharing_pb.LookupGaiaIdByEmailParams)
}
LookupGaiaIdByEmailParams::LookupGaiaIdByEmailParams(const LookupGaiaIdByEmailParams& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    LookupGaiaIdByEmailParams* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.email_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.email_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.email_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_email()) {
        _this->_impl_.email_.Set(from._internal_email(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:data_sharing_pb.LookupGaiaIdByEmailParams)
}

inline void LookupGaiaIdByEmailParams::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.email_) {} };
    _impl_.email_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.email_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LookupGaiaIdByEmailParams::~LookupGaiaIdByEmailParams()
{
    // @@protoc_insertion_point(destructor:data_sharing_pb.LookupGaiaIdByEmailParams)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void LookupGaiaIdByEmailParams::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.email_.Destroy();
}

void LookupGaiaIdByEmailParams::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void LookupGaiaIdByEmailParams::Clear()
{
    // @@protoc_insertion_point(message_clear_start:data_sharing_pb.LookupGaiaIdByEmailParams)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.email_.ClearNonDefaultToEmpty();
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* LookupGaiaIdByEmailParams::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string email = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_email();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* LookupGaiaIdByEmailParams::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:data_sharing_pb.LookupGaiaIdByEmailParams)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string email = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_email(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:data_sharing_pb.LookupGaiaIdByEmailParams)
    return target;
}

size_t LookupGaiaIdByEmailParams::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:data_sharing_pb.LookupGaiaIdByEmailParams)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional string email = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_email());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void LookupGaiaIdByEmailParams::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const LookupGaiaIdByEmailParams*>(&from));
}

void LookupGaiaIdByEmailParams::MergeFrom(const LookupGaiaIdByEmailParams& from)
{
    LookupGaiaIdByEmailParams* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:data_sharing_pb.LookupGaiaIdByEmailParams)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_email()) {
        _this->_internal_set_email(from._internal_email());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LookupGaiaIdByEmailParams::CopyFrom(const LookupGaiaIdByEmailParams& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:data_sharing_pb.LookupGaiaIdByEmailParams)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool LookupGaiaIdByEmailParams::IsInitialized() const
{
    return true;
}

void LookupGaiaIdByEmailParams::InternalSwap(LookupGaiaIdByEmailParams* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.email_, lhs_arena, &other->_impl_.email_, rhs_arena);
}

std::string LookupGaiaIdByEmailParams::GetTypeName() const
{
    return "data_sharing_pb.LookupGaiaIdByEmailParams";
}

// ===================================================================

class LookupGaiaIdByEmailResult::_Internal {
public:
    using HasBits = decltype(std::declval<LookupGaiaIdByEmailResult>()._impl_._has_bits_);
    static void set_has_gaia_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

LookupGaiaIdByEmailResult::LookupGaiaIdByEmailResult(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:data_sharing_pb.LookupGaiaIdByEmailResult)
}
LookupGaiaIdByEmailResult::LookupGaiaIdByEmailResult(const LookupGaiaIdByEmailResult& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    LookupGaiaIdByEmailResult* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.gaia_id_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.gaia_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.gaia_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_gaia_id()) {
        _this->_impl_.gaia_id_.Set(from._internal_gaia_id(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:data_sharing_pb.LookupGaiaIdByEmailResult)
}

inline void LookupGaiaIdByEmailResult::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.gaia_id_) {} };
    _impl_.gaia_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.gaia_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LookupGaiaIdByEmailResult::~LookupGaiaIdByEmailResult()
{
    // @@protoc_insertion_point(destructor:data_sharing_pb.LookupGaiaIdByEmailResult)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void LookupGaiaIdByEmailResult::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.gaia_id_.Destroy();
}

void LookupGaiaIdByEmailResult::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void LookupGaiaIdByEmailResult::Clear()
{
    // @@protoc_insertion_point(message_clear_start:data_sharing_pb.LookupGaiaIdByEmailResult)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.gaia_id_.ClearNonDefaultToEmpty();
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* LookupGaiaIdByEmailResult::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string gaia_id = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_gaia_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* LookupGaiaIdByEmailResult::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:data_sharing_pb.LookupGaiaIdByEmailResult)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string gaia_id = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_gaia_id(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:data_sharing_pb.LookupGaiaIdByEmailResult)
    return target;
}

size_t LookupGaiaIdByEmailResult::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:data_sharing_pb.LookupGaiaIdByEmailResult)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional string gaia_id = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_gaia_id());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void LookupGaiaIdByEmailResult::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const LookupGaiaIdByEmailResult*>(&from));
}

void LookupGaiaIdByEmailResult::MergeFrom(const LookupGaiaIdByEmailResult& from)
{
    LookupGaiaIdByEmailResult* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:data_sharing_pb.LookupGaiaIdByEmailResult)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_gaia_id()) {
        _this->_internal_set_gaia_id(from._internal_gaia_id());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LookupGaiaIdByEmailResult::CopyFrom(const LookupGaiaIdByEmailResult& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:data_sharing_pb.LookupGaiaIdByEmailResult)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool LookupGaiaIdByEmailResult::IsInitialized() const
{
    return true;
}

void LookupGaiaIdByEmailResult::InternalSwap(LookupGaiaIdByEmailResult* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.gaia_id_, lhs_arena, &other->_impl_.gaia_id_, rhs_arena);
}

std::string LookupGaiaIdByEmailResult::GetTypeName() const
{
    return "data_sharing_pb.LookupGaiaIdByEmailResult";
}

// ===================================================================

class AddAccessTokenParams::_Internal {
public:
    using HasBits = decltype(std::declval<AddAccessTokenParams>()._impl_._has_bits_);
    static void set_has_group_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

AddAccessTokenParams::AddAccessTokenParams(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:data_sharing_pb.AddAccessTokenParams)
}
AddAccessTokenParams::AddAccessTokenParams(const AddAccessTokenParams& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    AddAccessTokenParams* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.group_id_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.group_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.group_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_group_id()) {
        _this->_impl_.group_id_.Set(from._internal_group_id(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:data_sharing_pb.AddAccessTokenParams)
}

inline void AddAccessTokenParams::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.group_id_) {} };
    _impl_.group_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.group_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AddAccessTokenParams::~AddAccessTokenParams()
{
    // @@protoc_insertion_point(destructor:data_sharing_pb.AddAccessTokenParams)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void AddAccessTokenParams::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.group_id_.Destroy();
}

void AddAccessTokenParams::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void AddAccessTokenParams::Clear()
{
    // @@protoc_insertion_point(message_clear_start:data_sharing_pb.AddAccessTokenParams)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.group_id_.ClearNonDefaultToEmpty();
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* AddAccessTokenParams::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string group_id = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_group_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* AddAccessTokenParams::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:data_sharing_pb.AddAccessTokenParams)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string group_id = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_group_id(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:data_sharing_pb.AddAccessTokenParams)
    return target;
}

size_t AddAccessTokenParams::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:data_sharing_pb.AddAccessTokenParams)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional string group_id = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_group_id());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void AddAccessTokenParams::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const AddAccessTokenParams*>(&from));
}

void AddAccessTokenParams::MergeFrom(const AddAccessTokenParams& from)
{
    AddAccessTokenParams* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:data_sharing_pb.AddAccessTokenParams)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_group_id()) {
        _this->_internal_set_group_id(from._internal_group_id());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AddAccessTokenParams::CopyFrom(const AddAccessTokenParams& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:data_sharing_pb.AddAccessTokenParams)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool AddAccessTokenParams::IsInitialized() const
{
    return true;
}

void AddAccessTokenParams::InternalSwap(AddAccessTokenParams* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.group_id_, lhs_arena, &other->_impl_.group_id_, rhs_arena);
}

std::string AddAccessTokenParams::GetTypeName() const
{
    return "data_sharing_pb.AddAccessTokenParams";
}

// ===================================================================

class AddAccessTokenResult::_Internal {
public:
    using HasBits = decltype(std::declval<AddAccessTokenResult>()._impl_._has_bits_);
    static const ::data_sharing_pb::GroupData& group_data(const AddAccessTokenResult* msg);
    static void set_has_group_data(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

const ::data_sharing_pb::GroupData& AddAccessTokenResult::_Internal::group_data(const AddAccessTokenResult* msg)
{
    return *msg->_impl_.group_data_;
}
void AddAccessTokenResult::clear_group_data()
{
    if (_impl_.group_data_ != nullptr)
        _impl_.group_data_->Clear();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
AddAccessTokenResult::AddAccessTokenResult(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:data_sharing_pb.AddAccessTokenResult)
}
AddAccessTokenResult::AddAccessTokenResult(const AddAccessTokenResult& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    AddAccessTokenResult* const _this = this;
    (void)_this;
    new (&_impl_)
        Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.group_data_) { nullptr } };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_group_data()) {
        _this->_impl_.group_data_ = new ::data_sharing_pb::GroupData(*from._impl_.group_data_);
    }
    // @@protoc_insertion_point(copy_constructor:data_sharing_pb.AddAccessTokenResult)
}

inline void AddAccessTokenResult::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.group_data_) { nullptr } };
}

AddAccessTokenResult::~AddAccessTokenResult()
{
    // @@protoc_insertion_point(destructor:data_sharing_pb.AddAccessTokenResult)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void AddAccessTokenResult::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (this != internal_default_instance())
        delete _impl_.group_data_;
}

void AddAccessTokenResult::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void AddAccessTokenResult::Clear()
{
    // @@protoc_insertion_point(message_clear_start:data_sharing_pb.AddAccessTokenResult)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        GOOGLE_DCHECK(_impl_.group_data_ != nullptr);
        _impl_.group_data_->Clear();
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* AddAccessTokenResult::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .data_sharing_pb.GroupData group_data = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_group_data(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* AddAccessTokenResult::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:data_sharing_pb.AddAccessTokenResult)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .data_sharing_pb.GroupData group_data = 1;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::group_data(this), _Internal::group_data(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:data_sharing_pb.AddAccessTokenResult)
    return target;
}

size_t AddAccessTokenResult::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:data_sharing_pb.AddAccessTokenResult)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional .data_sharing_pb.GroupData group_data = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.group_data_);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void AddAccessTokenResult::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const AddAccessTokenResult*>(&from));
}

void AddAccessTokenResult::MergeFrom(const AddAccessTokenResult& from)
{
    AddAccessTokenResult* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:data_sharing_pb.AddAccessTokenResult)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_group_data()) {
        _this->_internal_mutable_group_data()->::data_sharing_pb::GroupData::MergeFrom(from._internal_group_data());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AddAccessTokenResult::CopyFrom(const AddAccessTokenResult& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:data_sharing_pb.AddAccessTokenResult)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool AddAccessTokenResult::IsInitialized() const
{
    return true;
}

void AddAccessTokenResult::InternalSwap(AddAccessTokenResult* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    swap(_impl_.group_data_, other->_impl_.group_data_);
}

std::string AddAccessTokenResult::GetTypeName() const
{
    return "data_sharing_pb.AddAccessTokenResult";
}

// @@protoc_insertion_point(namespace_scope)
} // namespace data_sharing_pb
PROTOBUF_NAMESPACE_OPEN
template <> PROTOBUF_NOINLINE ::data_sharing_pb::CreateGroupParams* Arena::CreateMaybeMessage<::data_sharing_pb::CreateGroupParams>(Arena* arena)
{
    return Arena::CreateMessageInternal<::data_sharing_pb::CreateGroupParams>(arena);
}
template <> PROTOBUF_NOINLINE ::data_sharing_pb::CreateGroupResult* Arena::CreateMaybeMessage<::data_sharing_pb::CreateGroupResult>(Arena* arena)
{
    return Arena::CreateMessageInternal<::data_sharing_pb::CreateGroupResult>(arena);
}
template <> PROTOBUF_NOINLINE ::data_sharing_pb::ReadGroupsParams* Arena::CreateMaybeMessage<::data_sharing_pb::ReadGroupsParams>(Arena* arena)
{
    return Arena::CreateMessageInternal<::data_sharing_pb::ReadGroupsParams>(arena);
}
template <> PROTOBUF_NOINLINE ::data_sharing_pb::ReadGroupsResult* Arena::CreateMaybeMessage<::data_sharing_pb::ReadGroupsResult>(Arena* arena)
{
    return Arena::CreateMessageInternal<::data_sharing_pb::ReadGroupsResult>(arena);
}
template <> PROTOBUF_NOINLINE ::data_sharing_pb::AddMemberParams* Arena::CreateMaybeMessage<::data_sharing_pb::AddMemberParams>(Arena* arena)
{
    return Arena::CreateMessageInternal<::data_sharing_pb::AddMemberParams>(arena);
}
template <> PROTOBUF_NOINLINE ::data_sharing_pb::RemoveMemberParams* Arena::CreateMaybeMessage<::data_sharing_pb::RemoveMemberParams>(Arena* arena)
{
    return Arena::CreateMessageInternal<::data_sharing_pb::RemoveMemberParams>(arena);
}
template <> PROTOBUF_NOINLINE ::data_sharing_pb::LeaveGroupParams* Arena::CreateMaybeMessage<::data_sharing_pb::LeaveGroupParams>(Arena* arena)
{
    return Arena::CreateMessageInternal<::data_sharing_pb::LeaveGroupParams>(arena);
}
template <> PROTOBUF_NOINLINE ::data_sharing_pb::DeleteGroupParams* Arena::CreateMaybeMessage<::data_sharing_pb::DeleteGroupParams>(Arena* arena)
{
    return Arena::CreateMessageInternal<::data_sharing_pb::DeleteGroupParams>(arena);
}
template <>
PROTOBUF_NOINLINE ::data_sharing_pb::LookupGaiaIdByEmailParams* Arena::CreateMaybeMessage<::data_sharing_pb::LookupGaiaIdByEmailParams>(Arena* arena)
{
    return Arena::CreateMessageInternal<::data_sharing_pb::LookupGaiaIdByEmailParams>(arena);
}
template <>
PROTOBUF_NOINLINE ::data_sharing_pb::LookupGaiaIdByEmailResult* Arena::CreateMaybeMessage<::data_sharing_pb::LookupGaiaIdByEmailResult>(Arena* arena)
{
    return Arena::CreateMessageInternal<::data_sharing_pb::LookupGaiaIdByEmailResult>(arena);
}
template <> PROTOBUF_NOINLINE ::data_sharing_pb::AddAccessTokenParams* Arena::CreateMaybeMessage<::data_sharing_pb::AddAccessTokenParams>(Arena* arena)
{
    return Arena::CreateMessageInternal<::data_sharing_pb::AddAccessTokenParams>(arena);
}
template <> PROTOBUF_NOINLINE ::data_sharing_pb::AddAccessTokenResult* Arena::CreateMaybeMessage<::data_sharing_pb::AddAccessTokenResult>(Arena* arena)
{
    return Arena::CreateMessageInternal<::data_sharing_pb::AddAccessTokenResult>(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
